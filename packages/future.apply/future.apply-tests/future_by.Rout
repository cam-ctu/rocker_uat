
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:59:23.486] plan(): Setting new future strategy stack:
[17:59:23.486] List of future strategies:
[17:59:23.486] 1. sequential:
[17:59:23.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.486]    - tweaked: FALSE
[17:59:23.486]    - call: future::plan("sequential")
[17:59:23.516] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[17:59:23.624] plan(): Setting new future strategy stack:
[17:59:23.624] List of future strategies:
[17:59:23.624] 1. sequential:
[17:59:23.624]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.624]    - tweaked: FALSE
[17:59:23.624]    - call: plan(strategy)
[17:59:23.651] plan(): nbrOfWorkers() = 1
[17:59:23.652] future_by_internal() ...
[17:59:23.653] future_lapply() ...
[17:59:23.659] Number of chunks: 1
[17:59:23.660] getGlobalsAndPackagesXApply() ...
[17:59:23.660]  - future.globals: TRUE
[17:59:23.661] getGlobalsAndPackages() ...
[17:59:23.662] Searching for globals...
[17:59:23.665] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:23.666] Searching for globals ... DONE
[17:59:23.666] Resolving globals: FALSE
[17:59:23.668] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:23.668] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:23.669] - globals: [1] ‘FUN’
[17:59:23.669] 
[17:59:23.669] getGlobalsAndPackages() ... DONE
[17:59:23.669]  - globals found/used: [n=1] ‘FUN’
[17:59:23.670]  - needed namespaces: [n=0] 
[17:59:23.670] Finding globals ... DONE
[17:59:23.670]  - use_args: TRUE
[17:59:23.670]  - Getting '...' globals ...
[17:59:23.672] resolve() on list ...
[17:59:23.672]  recursive: 0
[17:59:23.672]  length: 1
[17:59:23.672]  elements: ‘...’
[17:59:23.673]  length: 0 (resolved future 1)
[17:59:23.673] resolve() on list ... DONE
[17:59:23.673]    - '...' content: [n=0] 
[17:59:23.673] List of 1
[17:59:23.673]  $ ...: list()
[17:59:23.673]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.673]  - attr(*, "where")=List of 1
[17:59:23.673]   ..$ ...:<environment: 0x62649e5b0950> 
[17:59:23.673]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.673]  - attr(*, "resolved")= logi TRUE
[17:59:23.673]  - attr(*, "total_size")= num NA
[17:59:23.681]  - Getting '...' globals ... DONE
[17:59:23.681] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:23.682] List of 2
[17:59:23.682]  $ ...future.FUN:function (object, ...)  
[17:59:23.682]  $ ...          : list()
[17:59:23.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.682]  - attr(*, "where")=List of 2
[17:59:23.682]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:23.682]   ..$ ...          :<environment: 0x62649e5b0950> 
[17:59:23.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.682]  - attr(*, "resolved")= logi FALSE
[17:59:23.682]  - attr(*, "total_size")= num 1240
[17:59:23.687] Packages to be attached in all futures: [n=0] 
[17:59:23.687] getGlobalsAndPackagesXApply() ... DONE
[17:59:23.688] Number of futures (= number of chunks): 1
[17:59:23.688] Launching 1 futures (chunks) ...
[17:59:23.688] Chunk #1 of 1 ...
[17:59:23.689]  - Finding globals in 'X' for chunk #1 ...
[17:59:23.689] getGlobalsAndPackages() ...
[17:59:23.689] Searching for globals...
[17:59:23.690] 
[17:59:23.690] Searching for globals ... DONE
[17:59:23.691] - globals: [0] <none>
[17:59:23.691] getGlobalsAndPackages() ... DONE
[17:59:23.691]    + additional globals found: [n=0] 
[17:59:23.691]    + additional namespaces needed: [n=0] 
[17:59:23.691]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:23.692]  - seeds: <none>
[17:59:23.692]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.692] getGlobalsAndPackages() ...
[17:59:23.692] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.693] Resolving globals: FALSE
[17:59:23.693] Tweak future expression to call with '...' arguments ...
[17:59:23.693] {
[17:59:23.693]     do.call(function(...) {
[17:59:23.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.693]             on.exit(options(oopts), add = TRUE)
[17:59:23.693]         }
[17:59:23.693]         {
[17:59:23.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.693]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.693]             })
[17:59:23.693]         }
[17:59:23.693]     }, args = future.call.arguments)
[17:59:23.693] }
[17:59:23.694] Tweak future expression to call with '...' arguments ... DONE
[17:59:23.694] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.694] 
[17:59:23.695] getGlobalsAndPackages() ... DONE
[17:59:23.696] run() for ‘Future’ ...
[17:59:23.696] - state: ‘created’
[17:59:23.697] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:23.697] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.697] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:23.698]   - Field: ‘label’
[17:59:23.698]   - Field: ‘local’
[17:59:23.698]   - Field: ‘owner’
[17:59:23.698]   - Field: ‘envir’
[17:59:23.698]   - Field: ‘packages’
[17:59:23.699]   - Field: ‘gc’
[17:59:23.699]   - Field: ‘conditions’
[17:59:23.699]   - Field: ‘expr’
[17:59:23.699]   - Field: ‘uuid’
[17:59:23.699]   - Field: ‘seed’
[17:59:23.700]   - Field: ‘version’
[17:59:23.700]   - Field: ‘result’
[17:59:23.700]   - Field: ‘asynchronous’
[17:59:23.700]   - Field: ‘calls’
[17:59:23.700]   - Field: ‘globals’
[17:59:23.701]   - Field: ‘stdout’
[17:59:23.701]   - Field: ‘earlySignal’
[17:59:23.701]   - Field: ‘lazy’
[17:59:23.701]   - Field: ‘state’
[17:59:23.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:23.702] - Launch lazy future ...
[17:59:23.703] Packages needed by the future expression (n = 0): <none>
[17:59:23.703] Packages needed by future strategies (n = 0): <none>
[17:59:23.705] {
[17:59:23.705]     {
[17:59:23.705]         {
[17:59:23.705]             ...future.startTime <- base::Sys.time()
[17:59:23.705]             {
[17:59:23.705]                 {
[17:59:23.705]                   {
[17:59:23.705]                     base::local({
[17:59:23.705]                       has_future <- base::requireNamespace("future", 
[17:59:23.705]                         quietly = TRUE)
[17:59:23.705]                       if (has_future) {
[17:59:23.705]                         ns <- base::getNamespace("future")
[17:59:23.705]                         version <- ns[[".package"]][["version"]]
[17:59:23.705]                         if (is.null(version)) 
[17:59:23.705]                           version <- utils::packageVersion("future")
[17:59:23.705]                       }
[17:59:23.705]                       else {
[17:59:23.705]                         version <- NULL
[17:59:23.705]                       }
[17:59:23.705]                       if (!has_future || version < "1.8.0") {
[17:59:23.705]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:23.705]                           "", base::R.version$version.string), 
[17:59:23.705]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:23.705]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:23.705]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:23.705]                             "release", "version")], collapse = " "), 
[17:59:23.705]                           hostname = base::Sys.info()[["nodename"]])
[17:59:23.705]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:23.705]                           info)
[17:59:23.705]                         info <- base::paste(info, collapse = "; ")
[17:59:23.705]                         if (!has_future) {
[17:59:23.705]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:23.705]                             info)
[17:59:23.705]                         }
[17:59:23.705]                         else {
[17:59:23.705]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:23.705]                             info, version)
[17:59:23.705]                         }
[17:59:23.705]                         base::stop(msg)
[17:59:23.705]                       }
[17:59:23.705]                     })
[17:59:23.705]                   }
[17:59:23.705]                   ...future.strategy.old <- future::plan("list")
[17:59:23.705]                   options(future.plan = NULL)
[17:59:23.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:23.705]                 }
[17:59:23.705]                 ...future.workdir <- getwd()
[17:59:23.705]             }
[17:59:23.705]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:23.705]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:23.705]         }
[17:59:23.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:23.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:23.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:23.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:23.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:23.705]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:23.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:23.705]             base::names(...future.oldOptions))
[17:59:23.705]     }
[17:59:23.705]     if (FALSE) {
[17:59:23.705]     }
[17:59:23.705]     else {
[17:59:23.705]         if (TRUE) {
[17:59:23.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:23.705]                 open = "w")
[17:59:23.705]         }
[17:59:23.705]         else {
[17:59:23.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:23.705]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:23.705]         }
[17:59:23.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:23.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:23.705]             base::sink(type = "output", split = FALSE)
[17:59:23.705]             base::close(...future.stdout)
[17:59:23.705]         }, add = TRUE)
[17:59:23.705]     }
[17:59:23.705]     ...future.frame <- base::sys.nframe()
[17:59:23.705]     ...future.conditions <- base::list()
[17:59:23.705]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:23.705]     if (FALSE) {
[17:59:23.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:23.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:23.705]     }
[17:59:23.705]     ...future.result <- base::tryCatch({
[17:59:23.705]         base::withCallingHandlers({
[17:59:23.705]             ...future.value <- base::withVisible(base::local({
[17:59:23.705]                 do.call(function(...) {
[17:59:23.705]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.705]                   if (!identical(...future.globals.maxSize.org, 
[17:59:23.705]                     ...future.globals.maxSize)) {
[17:59:23.705]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.705]                     on.exit(options(oopts), add = TRUE)
[17:59:23.705]                   }
[17:59:23.705]                   {
[17:59:23.705]                     lapply(seq_along(...future.elements_ii), 
[17:59:23.705]                       FUN = function(jj) {
[17:59:23.705]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.705]                         ...future.FUN(...future.X_jj, ...)
[17:59:23.705]                       })
[17:59:23.705]                   }
[17:59:23.705]                 }, args = future.call.arguments)
[17:59:23.705]             }))
[17:59:23.705]             future::FutureResult(value = ...future.value$value, 
[17:59:23.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.705]                   ...future.rng), globalenv = if (FALSE) 
[17:59:23.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:23.705]                     ...future.globalenv.names))
[17:59:23.705]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:23.705]         }, condition = base::local({
[17:59:23.705]             c <- base::c
[17:59:23.705]             inherits <- base::inherits
[17:59:23.705]             invokeRestart <- base::invokeRestart
[17:59:23.705]             length <- base::length
[17:59:23.705]             list <- base::list
[17:59:23.705]             seq.int <- base::seq.int
[17:59:23.705]             signalCondition <- base::signalCondition
[17:59:23.705]             sys.calls <- base::sys.calls
[17:59:23.705]             `[[` <- base::`[[`
[17:59:23.705]             `+` <- base::`+`
[17:59:23.705]             `<<-` <- base::`<<-`
[17:59:23.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:23.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:23.705]                   3L)]
[17:59:23.705]             }
[17:59:23.705]             function(cond) {
[17:59:23.705]                 is_error <- inherits(cond, "error")
[17:59:23.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:23.705]                   NULL)
[17:59:23.705]                 if (is_error) {
[17:59:23.705]                   sessionInformation <- function() {
[17:59:23.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:23.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:23.705]                       search = base::search(), system = base::Sys.info())
[17:59:23.705]                   }
[17:59:23.705]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:23.705]                     cond$call), session = sessionInformation(), 
[17:59:23.705]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:23.705]                   signalCondition(cond)
[17:59:23.705]                 }
[17:59:23.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:23.705]                 "immediateCondition"))) {
[17:59:23.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:23.705]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:23.705]                   if (TRUE && !signal) {
[17:59:23.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.705]                     {
[17:59:23.705]                       inherits <- base::inherits
[17:59:23.705]                       invokeRestart <- base::invokeRestart
[17:59:23.705]                       is.null <- base::is.null
[17:59:23.705]                       muffled <- FALSE
[17:59:23.705]                       if (inherits(cond, "message")) {
[17:59:23.705]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.705]                         if (muffled) 
[17:59:23.705]                           invokeRestart("muffleMessage")
[17:59:23.705]                       }
[17:59:23.705]                       else if (inherits(cond, "warning")) {
[17:59:23.705]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.705]                         if (muffled) 
[17:59:23.705]                           invokeRestart("muffleWarning")
[17:59:23.705]                       }
[17:59:23.705]                       else if (inherits(cond, "condition")) {
[17:59:23.705]                         if (!is.null(pattern)) {
[17:59:23.705]                           computeRestarts <- base::computeRestarts
[17:59:23.705]                           grepl <- base::grepl
[17:59:23.705]                           restarts <- computeRestarts(cond)
[17:59:23.705]                           for (restart in restarts) {
[17:59:23.705]                             name <- restart$name
[17:59:23.705]                             if (is.null(name)) 
[17:59:23.705]                               next
[17:59:23.705]                             if (!grepl(pattern, name)) 
[17:59:23.705]                               next
[17:59:23.705]                             invokeRestart(restart)
[17:59:23.705]                             muffled <- TRUE
[17:59:23.705]                             break
[17:59:23.705]                           }
[17:59:23.705]                         }
[17:59:23.705]                       }
[17:59:23.705]                       invisible(muffled)
[17:59:23.705]                     }
[17:59:23.705]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.705]                   }
[17:59:23.705]                 }
[17:59:23.705]                 else {
[17:59:23.705]                   if (TRUE) {
[17:59:23.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.705]                     {
[17:59:23.705]                       inherits <- base::inherits
[17:59:23.705]                       invokeRestart <- base::invokeRestart
[17:59:23.705]                       is.null <- base::is.null
[17:59:23.705]                       muffled <- FALSE
[17:59:23.705]                       if (inherits(cond, "message")) {
[17:59:23.705]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.705]                         if (muffled) 
[17:59:23.705]                           invokeRestart("muffleMessage")
[17:59:23.705]                       }
[17:59:23.705]                       else if (inherits(cond, "warning")) {
[17:59:23.705]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.705]                         if (muffled) 
[17:59:23.705]                           invokeRestart("muffleWarning")
[17:59:23.705]                       }
[17:59:23.705]                       else if (inherits(cond, "condition")) {
[17:59:23.705]                         if (!is.null(pattern)) {
[17:59:23.705]                           computeRestarts <- base::computeRestarts
[17:59:23.705]                           grepl <- base::grepl
[17:59:23.705]                           restarts <- computeRestarts(cond)
[17:59:23.705]                           for (restart in restarts) {
[17:59:23.705]                             name <- restart$name
[17:59:23.705]                             if (is.null(name)) 
[17:59:23.705]                               next
[17:59:23.705]                             if (!grepl(pattern, name)) 
[17:59:23.705]                               next
[17:59:23.705]                             invokeRestart(restart)
[17:59:23.705]                             muffled <- TRUE
[17:59:23.705]                             break
[17:59:23.705]                           }
[17:59:23.705]                         }
[17:59:23.705]                       }
[17:59:23.705]                       invisible(muffled)
[17:59:23.705]                     }
[17:59:23.705]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.705]                   }
[17:59:23.705]                 }
[17:59:23.705]             }
[17:59:23.705]         }))
[17:59:23.705]     }, error = function(ex) {
[17:59:23.705]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:23.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.705]                 ...future.rng), started = ...future.startTime, 
[17:59:23.705]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:23.705]             version = "1.8"), class = "FutureResult")
[17:59:23.705]     }, finally = {
[17:59:23.705]         if (!identical(...future.workdir, getwd())) 
[17:59:23.705]             setwd(...future.workdir)
[17:59:23.705]         {
[17:59:23.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:23.705]                 ...future.oldOptions$nwarnings <- NULL
[17:59:23.705]             }
[17:59:23.705]             base::options(...future.oldOptions)
[17:59:23.705]             if (.Platform$OS.type == "windows") {
[17:59:23.705]                 old_names <- names(...future.oldEnvVars)
[17:59:23.705]                 envs <- base::Sys.getenv()
[17:59:23.705]                 names <- names(envs)
[17:59:23.705]                 common <- intersect(names, old_names)
[17:59:23.705]                 added <- setdiff(names, old_names)
[17:59:23.705]                 removed <- setdiff(old_names, names)
[17:59:23.705]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:23.705]                   envs[common]]
[17:59:23.705]                 NAMES <- toupper(changed)
[17:59:23.705]                 args <- list()
[17:59:23.705]                 for (kk in seq_along(NAMES)) {
[17:59:23.705]                   name <- changed[[kk]]
[17:59:23.705]                   NAME <- NAMES[[kk]]
[17:59:23.705]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.705]                     next
[17:59:23.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.705]                 }
[17:59:23.705]                 NAMES <- toupper(added)
[17:59:23.705]                 for (kk in seq_along(NAMES)) {
[17:59:23.705]                   name <- added[[kk]]
[17:59:23.705]                   NAME <- NAMES[[kk]]
[17:59:23.705]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.705]                     next
[17:59:23.705]                   args[[name]] <- ""
[17:59:23.705]                 }
[17:59:23.705]                 NAMES <- toupper(removed)
[17:59:23.705]                 for (kk in seq_along(NAMES)) {
[17:59:23.705]                   name <- removed[[kk]]
[17:59:23.705]                   NAME <- NAMES[[kk]]
[17:59:23.705]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.705]                     next
[17:59:23.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.705]                 }
[17:59:23.705]                 if (length(args) > 0) 
[17:59:23.705]                   base::do.call(base::Sys.setenv, args = args)
[17:59:23.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:23.705]             }
[17:59:23.705]             else {
[17:59:23.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:23.705]             }
[17:59:23.705]             {
[17:59:23.705]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:23.705]                   0L) {
[17:59:23.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:23.705]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:23.705]                   base::options(opts)
[17:59:23.705]                 }
[17:59:23.705]                 {
[17:59:23.705]                   {
[17:59:23.705]                     NULL
[17:59:23.705]                     RNGkind("Mersenne-Twister")
[17:59:23.705]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:23.705]                       inherits = FALSE)
[17:59:23.705]                   }
[17:59:23.705]                   options(future.plan = NULL)
[17:59:23.705]                   if (is.na(NA_character_)) 
[17:59:23.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:23.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:23.705]                     .init = FALSE)
[17:59:23.705]                 }
[17:59:23.705]             }
[17:59:23.705]         }
[17:59:23.705]     })
[17:59:23.705]     if (TRUE) {
[17:59:23.705]         base::sink(type = "output", split = FALSE)
[17:59:23.705]         if (TRUE) {
[17:59:23.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:23.705]         }
[17:59:23.705]         else {
[17:59:23.705]             ...future.result["stdout"] <- base::list(NULL)
[17:59:23.705]         }
[17:59:23.705]         base::close(...future.stdout)
[17:59:23.705]         ...future.stdout <- NULL
[17:59:23.705]     }
[17:59:23.705]     ...future.result$conditions <- ...future.conditions
[17:59:23.705]     ...future.result$finished <- base::Sys.time()
[17:59:23.705]     ...future.result
[17:59:23.705] }
[17:59:23.708] assign_globals() ...
[17:59:23.709] List of 5
[17:59:23.709]  $ ...future.FUN            :function (object, ...)  
[17:59:23.709]  $ future.call.arguments    : list()
[17:59:23.709]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.709]  $ ...future.elements_ii    :List of 3
[17:59:23.709]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:23.709]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:23.709]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.709]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:23.709]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:23.709]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.709]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:23.709]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:23.709]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.709]  $ ...future.seeds_ii       : NULL
[17:59:23.709]  $ ...future.globals.maxSize: NULL
[17:59:23.709]  - attr(*, "where")=List of 5
[17:59:23.709]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:23.709]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:23.709]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:23.709]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:23.709]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:23.709]  - attr(*, "resolved")= logi FALSE
[17:59:23.709]  - attr(*, "total_size")= num 1240
[17:59:23.709]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.709]  - attr(*, "already-done")= logi TRUE
[17:59:23.730] - copied ‘...future.FUN’ to environment
[17:59:23.730] - copied ‘future.call.arguments’ to environment
[17:59:23.730] - copied ‘...future.elements_ii’ to environment
[17:59:23.731] - copied ‘...future.seeds_ii’ to environment
[17:59:23.731] - copied ‘...future.globals.maxSize’ to environment
[17:59:23.731] assign_globals() ... done
[17:59:23.732] plan(): Setting new future strategy stack:
[17:59:23.732] List of future strategies:
[17:59:23.732] 1. sequential:
[17:59:23.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.732]    - tweaked: FALSE
[17:59:23.732]    - call: NULL
[17:59:23.733] plan(): nbrOfWorkers() = 1
[17:59:23.738] plan(): Setting new future strategy stack:
[17:59:23.738] List of future strategies:
[17:59:23.738] 1. sequential:
[17:59:23.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.738]    - tweaked: FALSE
[17:59:23.738]    - call: plan(strategy)
[17:59:23.739] plan(): nbrOfWorkers() = 1
[17:59:23.739] SequentialFuture started (and completed)
[17:59:23.740] - Launch lazy future ... done
[17:59:23.741] run() for ‘SequentialFuture’ ... done
[17:59:23.741] Created future:
[17:59:23.741] SequentialFuture:
[17:59:23.741] Label: ‘future_by-1’
[17:59:23.741] Expression:
[17:59:23.741] {
[17:59:23.741]     do.call(function(...) {
[17:59:23.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.741]             on.exit(options(oopts), add = TRUE)
[17:59:23.741]         }
[17:59:23.741]         {
[17:59:23.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.741]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.741]             })
[17:59:23.741]         }
[17:59:23.741]     }, args = future.call.arguments)
[17:59:23.741] }
[17:59:23.741] Lazy evaluation: FALSE
[17:59:23.741] Asynchronous evaluation: FALSE
[17:59:23.741] Local evaluation: TRUE
[17:59:23.741] Environment: R_GlobalEnv
[17:59:23.741] Capture standard output: TRUE
[17:59:23.741] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:23.741] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:23.741] Packages: <none>
[17:59:23.741] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:23.741] Resolved: TRUE
[17:59:23.741] Value: 4.62 KiB of class ‘list’
[17:59:23.741] Early signaling: FALSE
[17:59:23.741] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:23.741] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.745] Chunk #1 of 1 ... DONE
[17:59:23.745] Launching 1 futures (chunks) ... DONE
[17:59:23.745] Resolving 1 futures (chunks) ...
[17:59:23.745] resolve() on list ...
[17:59:23.746]  recursive: 0
[17:59:23.746]  length: 1
[17:59:23.746] 
[17:59:23.746] resolved() for ‘SequentialFuture’ ...
[17:59:23.747] - state: ‘finished’
[17:59:23.747] - run: TRUE
[17:59:23.747] - result: ‘FutureResult’
[17:59:23.747] resolved() for ‘SequentialFuture’ ... done
[17:59:23.747] Future #1
[17:59:23.748] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:23.748] - nx: 1
[17:59:23.749] - relay: TRUE
[17:59:23.749] - stdout: TRUE
[17:59:23.749] - signal: TRUE
[17:59:23.749] - resignal: FALSE
[17:59:23.749] - force: TRUE
[17:59:23.750] - relayed: [n=1] FALSE
[17:59:23.750] - queued futures: [n=1] FALSE
[17:59:23.750]  - until=1
[17:59:23.750]  - relaying element #1
[17:59:23.751] - relayed: [n=1] TRUE
[17:59:23.751] - queued futures: [n=1] TRUE
[17:59:23.751] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:23.751]  length: 0 (resolved future 1)
[17:59:23.752] Relaying remaining futures
[17:59:23.752] signalConditionsASAP(NULL, pos=0) ...
[17:59:23.752] - nx: 1
[17:59:23.752] - relay: TRUE
[17:59:23.752] - stdout: TRUE
[17:59:23.753] - signal: TRUE
[17:59:23.753] - resignal: FALSE
[17:59:23.753] - force: TRUE
[17:59:23.753] - relayed: [n=1] TRUE
[17:59:23.753] - queued futures: [n=1] TRUE
 - flush all
[17:59:23.754] - relayed: [n=1] TRUE
[17:59:23.754] - queued futures: [n=1] TRUE
[17:59:23.754] signalConditionsASAP(NULL, pos=0) ... done
[17:59:23.754] resolve() on list ... DONE
[17:59:23.754]  - Number of value chunks collected: 1
[17:59:23.755] Resolving 1 futures (chunks) ... DONE
[17:59:23.755] Reducing values from 1 chunks ...
[17:59:23.755]  - Number of values collected after concatenation: 3
[17:59:23.755]  - Number of values expected: 3
[17:59:23.756] Reducing values from 1 chunks ... DONE
[17:59:23.756] future_lapply() ... DONE
[17:59:23.756] future_by_internal() ... DONE
[17:59:23.757] future_by_internal() ...
[17:59:23.758] future_lapply() ...
[17:59:23.759] Number of chunks: 1
[17:59:23.759] getGlobalsAndPackagesXApply() ...
[17:59:23.759]  - future.globals: TRUE
[17:59:23.760] getGlobalsAndPackages() ...
[17:59:23.760] Searching for globals...
[17:59:23.762] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:23.762] Searching for globals ... DONE
[17:59:23.762] Resolving globals: FALSE
[17:59:23.763] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:23.764] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:23.764] - globals: [1] ‘FUN’
[17:59:23.764] 
[17:59:23.764] getGlobalsAndPackages() ... DONE
[17:59:23.764]  - globals found/used: [n=1] ‘FUN’
[17:59:23.765]  - needed namespaces: [n=0] 
[17:59:23.765] Finding globals ... DONE
[17:59:23.765]  - use_args: TRUE
[17:59:23.765]  - Getting '...' globals ...
[17:59:23.766] resolve() on list ...
[17:59:23.766]  recursive: 0
[17:59:23.766]  length: 1
[17:59:23.766]  elements: ‘...’
[17:59:23.767]  length: 0 (resolved future 1)
[17:59:23.767] resolve() on list ... DONE
[17:59:23.767]    - '...' content: [n=1] ‘digits’
[17:59:23.767] List of 1
[17:59:23.767]  $ ...:List of 1
[17:59:23.767]   ..$ digits: int 2
[17:59:23.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.767]  - attr(*, "where")=List of 1
[17:59:23.767]   ..$ ...:<environment: 0x62649feeb6f0> 
[17:59:23.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.767]  - attr(*, "resolved")= logi TRUE
[17:59:23.767]  - attr(*, "total_size")= num NA
[17:59:23.776]  - Getting '...' globals ... DONE
[17:59:23.776] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:23.776] List of 2
[17:59:23.776]  $ ...future.FUN:function (object, ...)  
[17:59:23.776]  $ ...          :List of 1
[17:59:23.776]   ..$ digits: int 2
[17:59:23.776]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.776]  - attr(*, "where")=List of 2
[17:59:23.776]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:23.776]   ..$ ...          :<environment: 0x62649feeb6f0> 
[17:59:23.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.776]  - attr(*, "resolved")= logi FALSE
[17:59:23.776]  - attr(*, "total_size")= num 1296
[17:59:23.782] Packages to be attached in all futures: [n=0] 
[17:59:23.783] getGlobalsAndPackagesXApply() ... DONE
[17:59:23.783] Number of futures (= number of chunks): 1
[17:59:23.783] Launching 1 futures (chunks) ...
[17:59:23.783] Chunk #1 of 1 ...
[17:59:23.784]  - Finding globals in 'X' for chunk #1 ...
[17:59:23.784] getGlobalsAndPackages() ...
[17:59:23.784] Searching for globals...
[17:59:23.785] 
[17:59:23.785] Searching for globals ... DONE
[17:59:23.785] - globals: [0] <none>
[17:59:23.785] getGlobalsAndPackages() ... DONE
[17:59:23.785]    + additional globals found: [n=0] 
[17:59:23.786]    + additional namespaces needed: [n=0] 
[17:59:23.786]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:23.786]  - seeds: <none>
[17:59:23.786]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.786] getGlobalsAndPackages() ...
[17:59:23.787] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.787] Resolving globals: FALSE
[17:59:23.787] Tweak future expression to call with '...' arguments ...
[17:59:23.787] {
[17:59:23.787]     do.call(function(...) {
[17:59:23.787]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.787]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.787]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.787]             on.exit(options(oopts), add = TRUE)
[17:59:23.787]         }
[17:59:23.787]         {
[17:59:23.787]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.787]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.787]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.787]             })
[17:59:23.787]         }
[17:59:23.787]     }, args = future.call.arguments)
[17:59:23.787] }
[17:59:23.788] Tweak future expression to call with '...' arguments ... DONE
[17:59:23.788] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.789] 
[17:59:23.789] getGlobalsAndPackages() ... DONE
[17:59:23.789] run() for ‘Future’ ...
[17:59:23.790] - state: ‘created’
[17:59:23.790] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:23.790] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:23.791]   - Field: ‘label’
[17:59:23.791]   - Field: ‘local’
[17:59:23.791]   - Field: ‘owner’
[17:59:23.791]   - Field: ‘envir’
[17:59:23.792]   - Field: ‘packages’
[17:59:23.792]   - Field: ‘gc’
[17:59:23.792]   - Field: ‘conditions’
[17:59:23.792]   - Field: ‘expr’
[17:59:23.792]   - Field: ‘uuid’
[17:59:23.793]   - Field: ‘seed’
[17:59:23.793]   - Field: ‘version’
[17:59:23.793]   - Field: ‘result’
[17:59:23.793]   - Field: ‘asynchronous’
[17:59:23.793]   - Field: ‘calls’
[17:59:23.794]   - Field: ‘globals’
[17:59:23.794]   - Field: ‘stdout’
[17:59:23.794]   - Field: ‘earlySignal’
[17:59:23.794]   - Field: ‘lazy’
[17:59:23.794]   - Field: ‘state’
[17:59:23.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:23.795] - Launch lazy future ...
[17:59:23.795] Packages needed by the future expression (n = 0): <none>
[17:59:23.795] Packages needed by future strategies (n = 0): <none>
[17:59:23.796] {
[17:59:23.796]     {
[17:59:23.796]         {
[17:59:23.796]             ...future.startTime <- base::Sys.time()
[17:59:23.796]             {
[17:59:23.796]                 {
[17:59:23.796]                   {
[17:59:23.796]                     base::local({
[17:59:23.796]                       has_future <- base::requireNamespace("future", 
[17:59:23.796]                         quietly = TRUE)
[17:59:23.796]                       if (has_future) {
[17:59:23.796]                         ns <- base::getNamespace("future")
[17:59:23.796]                         version <- ns[[".package"]][["version"]]
[17:59:23.796]                         if (is.null(version)) 
[17:59:23.796]                           version <- utils::packageVersion("future")
[17:59:23.796]                       }
[17:59:23.796]                       else {
[17:59:23.796]                         version <- NULL
[17:59:23.796]                       }
[17:59:23.796]                       if (!has_future || version < "1.8.0") {
[17:59:23.796]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:23.796]                           "", base::R.version$version.string), 
[17:59:23.796]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:23.796]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:23.796]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:23.796]                             "release", "version")], collapse = " "), 
[17:59:23.796]                           hostname = base::Sys.info()[["nodename"]])
[17:59:23.796]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:23.796]                           info)
[17:59:23.796]                         info <- base::paste(info, collapse = "; ")
[17:59:23.796]                         if (!has_future) {
[17:59:23.796]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:23.796]                             info)
[17:59:23.796]                         }
[17:59:23.796]                         else {
[17:59:23.796]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:23.796]                             info, version)
[17:59:23.796]                         }
[17:59:23.796]                         base::stop(msg)
[17:59:23.796]                       }
[17:59:23.796]                     })
[17:59:23.796]                   }
[17:59:23.796]                   ...future.strategy.old <- future::plan("list")
[17:59:23.796]                   options(future.plan = NULL)
[17:59:23.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:23.796]                 }
[17:59:23.796]                 ...future.workdir <- getwd()
[17:59:23.796]             }
[17:59:23.796]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:23.796]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:23.796]         }
[17:59:23.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:23.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:23.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:23.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:23.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:23.796]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:23.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:23.796]             base::names(...future.oldOptions))
[17:59:23.796]     }
[17:59:23.796]     if (FALSE) {
[17:59:23.796]     }
[17:59:23.796]     else {
[17:59:23.796]         if (TRUE) {
[17:59:23.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:23.796]                 open = "w")
[17:59:23.796]         }
[17:59:23.796]         else {
[17:59:23.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:23.796]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:23.796]         }
[17:59:23.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:23.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:23.796]             base::sink(type = "output", split = FALSE)
[17:59:23.796]             base::close(...future.stdout)
[17:59:23.796]         }, add = TRUE)
[17:59:23.796]     }
[17:59:23.796]     ...future.frame <- base::sys.nframe()
[17:59:23.796]     ...future.conditions <- base::list()
[17:59:23.796]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:23.796]     if (FALSE) {
[17:59:23.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:23.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:23.796]     }
[17:59:23.796]     ...future.result <- base::tryCatch({
[17:59:23.796]         base::withCallingHandlers({
[17:59:23.796]             ...future.value <- base::withVisible(base::local({
[17:59:23.796]                 do.call(function(...) {
[17:59:23.796]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.796]                   if (!identical(...future.globals.maxSize.org, 
[17:59:23.796]                     ...future.globals.maxSize)) {
[17:59:23.796]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.796]                     on.exit(options(oopts), add = TRUE)
[17:59:23.796]                   }
[17:59:23.796]                   {
[17:59:23.796]                     lapply(seq_along(...future.elements_ii), 
[17:59:23.796]                       FUN = function(jj) {
[17:59:23.796]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.796]                         ...future.FUN(...future.X_jj, ...)
[17:59:23.796]                       })
[17:59:23.796]                   }
[17:59:23.796]                 }, args = future.call.arguments)
[17:59:23.796]             }))
[17:59:23.796]             future::FutureResult(value = ...future.value$value, 
[17:59:23.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.796]                   ...future.rng), globalenv = if (FALSE) 
[17:59:23.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:23.796]                     ...future.globalenv.names))
[17:59:23.796]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:23.796]         }, condition = base::local({
[17:59:23.796]             c <- base::c
[17:59:23.796]             inherits <- base::inherits
[17:59:23.796]             invokeRestart <- base::invokeRestart
[17:59:23.796]             length <- base::length
[17:59:23.796]             list <- base::list
[17:59:23.796]             seq.int <- base::seq.int
[17:59:23.796]             signalCondition <- base::signalCondition
[17:59:23.796]             sys.calls <- base::sys.calls
[17:59:23.796]             `[[` <- base::`[[`
[17:59:23.796]             `+` <- base::`+`
[17:59:23.796]             `<<-` <- base::`<<-`
[17:59:23.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:23.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:23.796]                   3L)]
[17:59:23.796]             }
[17:59:23.796]             function(cond) {
[17:59:23.796]                 is_error <- inherits(cond, "error")
[17:59:23.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:23.796]                   NULL)
[17:59:23.796]                 if (is_error) {
[17:59:23.796]                   sessionInformation <- function() {
[17:59:23.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:23.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:23.796]                       search = base::search(), system = base::Sys.info())
[17:59:23.796]                   }
[17:59:23.796]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:23.796]                     cond$call), session = sessionInformation(), 
[17:59:23.796]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:23.796]                   signalCondition(cond)
[17:59:23.796]                 }
[17:59:23.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:23.796]                 "immediateCondition"))) {
[17:59:23.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:23.796]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:23.796]                   if (TRUE && !signal) {
[17:59:23.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.796]                     {
[17:59:23.796]                       inherits <- base::inherits
[17:59:23.796]                       invokeRestart <- base::invokeRestart
[17:59:23.796]                       is.null <- base::is.null
[17:59:23.796]                       muffled <- FALSE
[17:59:23.796]                       if (inherits(cond, "message")) {
[17:59:23.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.796]                         if (muffled) 
[17:59:23.796]                           invokeRestart("muffleMessage")
[17:59:23.796]                       }
[17:59:23.796]                       else if (inherits(cond, "warning")) {
[17:59:23.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.796]                         if (muffled) 
[17:59:23.796]                           invokeRestart("muffleWarning")
[17:59:23.796]                       }
[17:59:23.796]                       else if (inherits(cond, "condition")) {
[17:59:23.796]                         if (!is.null(pattern)) {
[17:59:23.796]                           computeRestarts <- base::computeRestarts
[17:59:23.796]                           grepl <- base::grepl
[17:59:23.796]                           restarts <- computeRestarts(cond)
[17:59:23.796]                           for (restart in restarts) {
[17:59:23.796]                             name <- restart$name
[17:59:23.796]                             if (is.null(name)) 
[17:59:23.796]                               next
[17:59:23.796]                             if (!grepl(pattern, name)) 
[17:59:23.796]                               next
[17:59:23.796]                             invokeRestart(restart)
[17:59:23.796]                             muffled <- TRUE
[17:59:23.796]                             break
[17:59:23.796]                           }
[17:59:23.796]                         }
[17:59:23.796]                       }
[17:59:23.796]                       invisible(muffled)
[17:59:23.796]                     }
[17:59:23.796]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.796]                   }
[17:59:23.796]                 }
[17:59:23.796]                 else {
[17:59:23.796]                   if (TRUE) {
[17:59:23.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.796]                     {
[17:59:23.796]                       inherits <- base::inherits
[17:59:23.796]                       invokeRestart <- base::invokeRestart
[17:59:23.796]                       is.null <- base::is.null
[17:59:23.796]                       muffled <- FALSE
[17:59:23.796]                       if (inherits(cond, "message")) {
[17:59:23.796]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.796]                         if (muffled) 
[17:59:23.796]                           invokeRestart("muffleMessage")
[17:59:23.796]                       }
[17:59:23.796]                       else if (inherits(cond, "warning")) {
[17:59:23.796]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.796]                         if (muffled) 
[17:59:23.796]                           invokeRestart("muffleWarning")
[17:59:23.796]                       }
[17:59:23.796]                       else if (inherits(cond, "condition")) {
[17:59:23.796]                         if (!is.null(pattern)) {
[17:59:23.796]                           computeRestarts <- base::computeRestarts
[17:59:23.796]                           grepl <- base::grepl
[17:59:23.796]                           restarts <- computeRestarts(cond)
[17:59:23.796]                           for (restart in restarts) {
[17:59:23.796]                             name <- restart$name
[17:59:23.796]                             if (is.null(name)) 
[17:59:23.796]                               next
[17:59:23.796]                             if (!grepl(pattern, name)) 
[17:59:23.796]                               next
[17:59:23.796]                             invokeRestart(restart)
[17:59:23.796]                             muffled <- TRUE
[17:59:23.796]                             break
[17:59:23.796]                           }
[17:59:23.796]                         }
[17:59:23.796]                       }
[17:59:23.796]                       invisible(muffled)
[17:59:23.796]                     }
[17:59:23.796]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.796]                   }
[17:59:23.796]                 }
[17:59:23.796]             }
[17:59:23.796]         }))
[17:59:23.796]     }, error = function(ex) {
[17:59:23.796]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:23.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.796]                 ...future.rng), started = ...future.startTime, 
[17:59:23.796]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:23.796]             version = "1.8"), class = "FutureResult")
[17:59:23.796]     }, finally = {
[17:59:23.796]         if (!identical(...future.workdir, getwd())) 
[17:59:23.796]             setwd(...future.workdir)
[17:59:23.796]         {
[17:59:23.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:23.796]                 ...future.oldOptions$nwarnings <- NULL
[17:59:23.796]             }
[17:59:23.796]             base::options(...future.oldOptions)
[17:59:23.796]             if (.Platform$OS.type == "windows") {
[17:59:23.796]                 old_names <- names(...future.oldEnvVars)
[17:59:23.796]                 envs <- base::Sys.getenv()
[17:59:23.796]                 names <- names(envs)
[17:59:23.796]                 common <- intersect(names, old_names)
[17:59:23.796]                 added <- setdiff(names, old_names)
[17:59:23.796]                 removed <- setdiff(old_names, names)
[17:59:23.796]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:23.796]                   envs[common]]
[17:59:23.796]                 NAMES <- toupper(changed)
[17:59:23.796]                 args <- list()
[17:59:23.796]                 for (kk in seq_along(NAMES)) {
[17:59:23.796]                   name <- changed[[kk]]
[17:59:23.796]                   NAME <- NAMES[[kk]]
[17:59:23.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.796]                     next
[17:59:23.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.796]                 }
[17:59:23.796]                 NAMES <- toupper(added)
[17:59:23.796]                 for (kk in seq_along(NAMES)) {
[17:59:23.796]                   name <- added[[kk]]
[17:59:23.796]                   NAME <- NAMES[[kk]]
[17:59:23.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.796]                     next
[17:59:23.796]                   args[[name]] <- ""
[17:59:23.796]                 }
[17:59:23.796]                 NAMES <- toupper(removed)
[17:59:23.796]                 for (kk in seq_along(NAMES)) {
[17:59:23.796]                   name <- removed[[kk]]
[17:59:23.796]                   NAME <- NAMES[[kk]]
[17:59:23.796]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.796]                     next
[17:59:23.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.796]                 }
[17:59:23.796]                 if (length(args) > 0) 
[17:59:23.796]                   base::do.call(base::Sys.setenv, args = args)
[17:59:23.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:23.796]             }
[17:59:23.796]             else {
[17:59:23.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:23.796]             }
[17:59:23.796]             {
[17:59:23.796]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:23.796]                   0L) {
[17:59:23.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:23.796]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:23.796]                   base::options(opts)
[17:59:23.796]                 }
[17:59:23.796]                 {
[17:59:23.796]                   {
[17:59:23.796]                     NULL
[17:59:23.796]                     RNGkind("Mersenne-Twister")
[17:59:23.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:23.796]                       inherits = FALSE)
[17:59:23.796]                   }
[17:59:23.796]                   options(future.plan = NULL)
[17:59:23.796]                   if (is.na(NA_character_)) 
[17:59:23.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:23.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:23.796]                     .init = FALSE)
[17:59:23.796]                 }
[17:59:23.796]             }
[17:59:23.796]         }
[17:59:23.796]     })
[17:59:23.796]     if (TRUE) {
[17:59:23.796]         base::sink(type = "output", split = FALSE)
[17:59:23.796]         if (TRUE) {
[17:59:23.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:23.796]         }
[17:59:23.796]         else {
[17:59:23.796]             ...future.result["stdout"] <- base::list(NULL)
[17:59:23.796]         }
[17:59:23.796]         base::close(...future.stdout)
[17:59:23.796]         ...future.stdout <- NULL
[17:59:23.796]     }
[17:59:23.796]     ...future.result$conditions <- ...future.conditions
[17:59:23.796]     ...future.result$finished <- base::Sys.time()
[17:59:23.796]     ...future.result
[17:59:23.796] }
[17:59:23.799] assign_globals() ...
[17:59:23.800] List of 5
[17:59:23.800]  $ ...future.FUN            :function (object, ...)  
[17:59:23.800]  $ future.call.arguments    :List of 1
[17:59:23.800]   ..$ digits: int 2
[17:59:23.800]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.800]  $ ...future.elements_ii    :List of 6
[17:59:23.800]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:59:23.800]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:59:23.800]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:59:23.800]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:59:23.800]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:59:23.800]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:59:23.800]  $ ...future.seeds_ii       : NULL
[17:59:23.800]  $ ...future.globals.maxSize: NULL
[17:59:23.800]  - attr(*, "where")=List of 5
[17:59:23.800]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:23.800]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:23.800]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:23.800]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:23.800]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:23.800]  - attr(*, "resolved")= logi FALSE
[17:59:23.800]  - attr(*, "total_size")= num 1296
[17:59:23.800]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.800]  - attr(*, "already-done")= logi TRUE
[17:59:23.813] - copied ‘...future.FUN’ to environment
[17:59:23.813] - copied ‘future.call.arguments’ to environment
[17:59:23.813] - copied ‘...future.elements_ii’ to environment
[17:59:23.813] - copied ‘...future.seeds_ii’ to environment
[17:59:23.814] - copied ‘...future.globals.maxSize’ to environment
[17:59:23.814] assign_globals() ... done
[17:59:23.815] plan(): Setting new future strategy stack:
[17:59:23.815] List of future strategies:
[17:59:23.815] 1. sequential:
[17:59:23.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.815]    - tweaked: FALSE
[17:59:23.815]    - call: NULL
[17:59:23.816] plan(): nbrOfWorkers() = 1
[17:59:23.822] plan(): Setting new future strategy stack:
[17:59:23.823] List of future strategies:
[17:59:23.823] 1. sequential:
[17:59:23.823]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.823]    - tweaked: FALSE
[17:59:23.823]    - call: plan(strategy)
[17:59:23.824] plan(): nbrOfWorkers() = 1
[17:59:23.824] SequentialFuture started (and completed)
[17:59:23.825] - Launch lazy future ... done
[17:59:23.825] run() for ‘SequentialFuture’ ... done
[17:59:23.825] Created future:
[17:59:23.825] SequentialFuture:
[17:59:23.825] Label: ‘future_by-1’
[17:59:23.825] Expression:
[17:59:23.825] {
[17:59:23.825]     do.call(function(...) {
[17:59:23.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.825]             on.exit(options(oopts), add = TRUE)
[17:59:23.825]         }
[17:59:23.825]         {
[17:59:23.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.825]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.825]             })
[17:59:23.825]         }
[17:59:23.825]     }, args = future.call.arguments)
[17:59:23.825] }
[17:59:23.825] Lazy evaluation: FALSE
[17:59:23.825] Asynchronous evaluation: FALSE
[17:59:23.825] Local evaluation: TRUE
[17:59:23.825] Environment: R_GlobalEnv
[17:59:23.825] Capture standard output: TRUE
[17:59:23.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:23.825] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:23.825] Packages: <none>
[17:59:23.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:23.825] Resolved: TRUE
[17:59:23.825] Value: 5.48 KiB of class ‘list’
[17:59:23.825] Early signaling: FALSE
[17:59:23.825] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:23.825] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.827] Chunk #1 of 1 ... DONE
[17:59:23.828] Launching 1 futures (chunks) ... DONE
[17:59:23.828] Resolving 1 futures (chunks) ...
[17:59:23.828] resolve() on list ...
[17:59:23.828]  recursive: 0
[17:59:23.828]  length: 1
[17:59:23.829] 
[17:59:23.829] resolved() for ‘SequentialFuture’ ...
[17:59:23.829] - state: ‘finished’
[17:59:23.829] - run: TRUE
[17:59:23.829] - result: ‘FutureResult’
[17:59:23.830] resolved() for ‘SequentialFuture’ ... done
[17:59:23.830] Future #1
[17:59:23.830] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:23.830] - nx: 1
[17:59:23.830] - relay: TRUE
[17:59:23.831] - stdout: TRUE
[17:59:23.831] - signal: TRUE
[17:59:23.831] - resignal: FALSE
[17:59:23.831] - force: TRUE
[17:59:23.831] - relayed: [n=1] FALSE
[17:59:23.832] - queued futures: [n=1] FALSE
[17:59:23.832]  - until=1
[17:59:23.832]  - relaying element #1
[17:59:23.832] - relayed: [n=1] TRUE
[17:59:23.833] - queued futures: [n=1] TRUE
[17:59:23.833] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:23.833]  length: 0 (resolved future 1)
[17:59:23.833] Relaying remaining futures
[17:59:23.833] signalConditionsASAP(NULL, pos=0) ...
[17:59:23.833] - nx: 1
[17:59:23.834] - relay: TRUE
[17:59:23.834] - stdout: TRUE
[17:59:23.834] - signal: TRUE
[17:59:23.834] - resignal: FALSE
[17:59:23.834] - force: TRUE
[17:59:23.834] - relayed: [n=1] TRUE
[17:59:23.835] - queued futures: [n=1] TRUE
 - flush all
[17:59:23.835] - relayed: [n=1] TRUE
[17:59:23.835] - queued futures: [n=1] TRUE
[17:59:23.835] signalConditionsASAP(NULL, pos=0) ... done
[17:59:23.836] resolve() on list ... DONE
[17:59:23.836]  - Number of value chunks collected: 1
[17:59:23.836] Resolving 1 futures (chunks) ... DONE
[17:59:23.836] Reducing values from 1 chunks ...
[17:59:23.836]  - Number of values collected after concatenation: 6
[17:59:23.837]  - Number of values expected: 6
[17:59:23.837] Reducing values from 1 chunks ... DONE
[17:59:23.837] future_lapply() ... DONE
[17:59:23.837] future_by_internal() ... DONE
[17:59:23.843] future_by_internal() ...
[17:59:23.844] future_lapply() ...
[17:59:23.846] Number of chunks: 1
[17:59:23.846] getGlobalsAndPackagesXApply() ...
[17:59:23.846]  - future.globals: TRUE
[17:59:23.847] getGlobalsAndPackages() ...
[17:59:23.847] Searching for globals...
[17:59:23.850] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:23.850] Searching for globals ... DONE
[17:59:23.850] Resolving globals: FALSE
[17:59:23.851] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:59:23.852] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:59:23.852] - globals: [1] ‘FUN’
[17:59:23.852] - packages: [1] ‘stats’
[17:59:23.853] getGlobalsAndPackages() ... DONE
[17:59:23.853]  - globals found/used: [n=1] ‘FUN’
[17:59:23.853]  - needed namespaces: [n=1] ‘stats’
[17:59:23.853] Finding globals ... DONE
[17:59:23.853]  - use_args: TRUE
[17:59:23.854]  - Getting '...' globals ...
[17:59:23.854] resolve() on list ...
[17:59:23.854]  recursive: 0
[17:59:23.855]  length: 1
[17:59:23.855]  elements: ‘...’
[17:59:23.855]  length: 0 (resolved future 1)
[17:59:23.855] resolve() on list ... DONE
[17:59:23.855]    - '...' content: [n=1] ‘singular.ok’
[17:59:23.856] List of 1
[17:59:23.856]  $ ...:List of 1
[17:59:23.856]   ..$ singular.ok: logi FALSE
[17:59:23.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.856]  - attr(*, "where")=List of 1
[17:59:23.856]   ..$ ...:<environment: 0x62649fbad948> 
[17:59:23.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.856]  - attr(*, "resolved")= logi TRUE
[17:59:23.856]  - attr(*, "total_size")= num NA
[17:59:23.861]  - Getting '...' globals ... DONE
[17:59:23.862] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:23.862] List of 2
[17:59:23.862]  $ ...future.FUN:function (x, ...)  
[17:59:23.862]  $ ...          :List of 1
[17:59:23.862]   ..$ singular.ok: logi FALSE
[17:59:23.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.862]  - attr(*, "where")=List of 2
[17:59:23.862]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:23.862]   ..$ ...          :<environment: 0x62649fbad948> 
[17:59:23.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.862]  - attr(*, "resolved")= logi FALSE
[17:59:23.862]  - attr(*, "total_size")= num 5384
[17:59:23.870] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:23.871] getGlobalsAndPackagesXApply() ... DONE
[17:59:23.871] Number of futures (= number of chunks): 1
[17:59:23.871] Launching 1 futures (chunks) ...
[17:59:23.871] Chunk #1 of 1 ...
[17:59:23.872]  - Finding globals in 'X' for chunk #1 ...
[17:59:23.872] getGlobalsAndPackages() ...
[17:59:23.872] Searching for globals...
[17:59:23.873] 
[17:59:23.873] Searching for globals ... DONE
[17:59:23.874] - globals: [0] <none>
[17:59:23.874] getGlobalsAndPackages() ... DONE
[17:59:23.874]    + additional globals found: [n=0] 
[17:59:23.874]    + additional namespaces needed: [n=0] 
[17:59:23.874]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:23.874]  - seeds: <none>
[17:59:23.875]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.875] getGlobalsAndPackages() ...
[17:59:23.875] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.875] Resolving globals: FALSE
[17:59:23.876] Tweak future expression to call with '...' arguments ...
[17:59:23.876] {
[17:59:23.876]     do.call(function(...) {
[17:59:23.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.876]             on.exit(options(oopts), add = TRUE)
[17:59:23.876]         }
[17:59:23.876]         {
[17:59:23.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.876]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.876]             })
[17:59:23.876]         }
[17:59:23.876]     }, args = future.call.arguments)
[17:59:23.876] }
[17:59:23.876] Tweak future expression to call with '...' arguments ... DONE
[17:59:23.877] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.877] 
[17:59:23.877] getGlobalsAndPackages() ... DONE
[17:59:23.878] run() for ‘Future’ ...
[17:59:23.878] - state: ‘created’
[17:59:23.878] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:23.879] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.879] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:23.879]   - Field: ‘label’
[17:59:23.880]   - Field: ‘local’
[17:59:23.880]   - Field: ‘owner’
[17:59:23.880]   - Field: ‘envir’
[17:59:23.880]   - Field: ‘packages’
[17:59:23.880]   - Field: ‘gc’
[17:59:23.881]   - Field: ‘conditions’
[17:59:23.881]   - Field: ‘expr’
[17:59:23.881]   - Field: ‘uuid’
[17:59:23.881]   - Field: ‘seed’
[17:59:23.881]   - Field: ‘version’
[17:59:23.882]   - Field: ‘result’
[17:59:23.882]   - Field: ‘asynchronous’
[17:59:23.882]   - Field: ‘calls’
[17:59:23.882]   - Field: ‘globals’
[17:59:23.882]   - Field: ‘stdout’
[17:59:23.883]   - Field: ‘earlySignal’
[17:59:23.883]   - Field: ‘lazy’
[17:59:23.883]   - Field: ‘state’
[17:59:23.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:23.883] - Launch lazy future ...
[17:59:23.884] Packages needed by the future expression (n = 1): ‘stats’
[17:59:23.884] Packages needed by future strategies (n = 0): <none>
[17:59:23.885] {
[17:59:23.885]     {
[17:59:23.885]         {
[17:59:23.885]             ...future.startTime <- base::Sys.time()
[17:59:23.885]             {
[17:59:23.885]                 {
[17:59:23.885]                   {
[17:59:23.885]                     {
[17:59:23.885]                       base::local({
[17:59:23.885]                         has_future <- base::requireNamespace("future", 
[17:59:23.885]                           quietly = TRUE)
[17:59:23.885]                         if (has_future) {
[17:59:23.885]                           ns <- base::getNamespace("future")
[17:59:23.885]                           version <- ns[[".package"]][["version"]]
[17:59:23.885]                           if (is.null(version)) 
[17:59:23.885]                             version <- utils::packageVersion("future")
[17:59:23.885]                         }
[17:59:23.885]                         else {
[17:59:23.885]                           version <- NULL
[17:59:23.885]                         }
[17:59:23.885]                         if (!has_future || version < "1.8.0") {
[17:59:23.885]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:23.885]                             "", base::R.version$version.string), 
[17:59:23.885]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:23.885]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:23.885]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:23.885]                               "release", "version")], collapse = " "), 
[17:59:23.885]                             hostname = base::Sys.info()[["nodename"]])
[17:59:23.885]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:23.885]                             info)
[17:59:23.885]                           info <- base::paste(info, collapse = "; ")
[17:59:23.885]                           if (!has_future) {
[17:59:23.885]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:23.885]                               info)
[17:59:23.885]                           }
[17:59:23.885]                           else {
[17:59:23.885]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:23.885]                               info, version)
[17:59:23.885]                           }
[17:59:23.885]                           base::stop(msg)
[17:59:23.885]                         }
[17:59:23.885]                       })
[17:59:23.885]                     }
[17:59:23.885]                     base::local({
[17:59:23.885]                       for (pkg in "stats") {
[17:59:23.885]                         base::loadNamespace(pkg)
[17:59:23.885]                         base::library(pkg, character.only = TRUE)
[17:59:23.885]                       }
[17:59:23.885]                     })
[17:59:23.885]                   }
[17:59:23.885]                   ...future.strategy.old <- future::plan("list")
[17:59:23.885]                   options(future.plan = NULL)
[17:59:23.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:23.885]                 }
[17:59:23.885]                 ...future.workdir <- getwd()
[17:59:23.885]             }
[17:59:23.885]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:23.885]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:23.885]         }
[17:59:23.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:23.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:23.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:23.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:23.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:23.885]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:23.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:23.885]             base::names(...future.oldOptions))
[17:59:23.885]     }
[17:59:23.885]     if (FALSE) {
[17:59:23.885]     }
[17:59:23.885]     else {
[17:59:23.885]         if (TRUE) {
[17:59:23.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:23.885]                 open = "w")
[17:59:23.885]         }
[17:59:23.885]         else {
[17:59:23.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:23.885]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:23.885]         }
[17:59:23.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:23.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:23.885]             base::sink(type = "output", split = FALSE)
[17:59:23.885]             base::close(...future.stdout)
[17:59:23.885]         }, add = TRUE)
[17:59:23.885]     }
[17:59:23.885]     ...future.frame <- base::sys.nframe()
[17:59:23.885]     ...future.conditions <- base::list()
[17:59:23.885]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:23.885]     if (FALSE) {
[17:59:23.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:23.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:23.885]     }
[17:59:23.885]     ...future.result <- base::tryCatch({
[17:59:23.885]         base::withCallingHandlers({
[17:59:23.885]             ...future.value <- base::withVisible(base::local({
[17:59:23.885]                 do.call(function(...) {
[17:59:23.885]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.885]                   if (!identical(...future.globals.maxSize.org, 
[17:59:23.885]                     ...future.globals.maxSize)) {
[17:59:23.885]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.885]                     on.exit(options(oopts), add = TRUE)
[17:59:23.885]                   }
[17:59:23.885]                   {
[17:59:23.885]                     lapply(seq_along(...future.elements_ii), 
[17:59:23.885]                       FUN = function(jj) {
[17:59:23.885]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.885]                         ...future.FUN(...future.X_jj, ...)
[17:59:23.885]                       })
[17:59:23.885]                   }
[17:59:23.885]                 }, args = future.call.arguments)
[17:59:23.885]             }))
[17:59:23.885]             future::FutureResult(value = ...future.value$value, 
[17:59:23.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.885]                   ...future.rng), globalenv = if (FALSE) 
[17:59:23.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:23.885]                     ...future.globalenv.names))
[17:59:23.885]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:23.885]         }, condition = base::local({
[17:59:23.885]             c <- base::c
[17:59:23.885]             inherits <- base::inherits
[17:59:23.885]             invokeRestart <- base::invokeRestart
[17:59:23.885]             length <- base::length
[17:59:23.885]             list <- base::list
[17:59:23.885]             seq.int <- base::seq.int
[17:59:23.885]             signalCondition <- base::signalCondition
[17:59:23.885]             sys.calls <- base::sys.calls
[17:59:23.885]             `[[` <- base::`[[`
[17:59:23.885]             `+` <- base::`+`
[17:59:23.885]             `<<-` <- base::`<<-`
[17:59:23.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:23.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:23.885]                   3L)]
[17:59:23.885]             }
[17:59:23.885]             function(cond) {
[17:59:23.885]                 is_error <- inherits(cond, "error")
[17:59:23.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:23.885]                   NULL)
[17:59:23.885]                 if (is_error) {
[17:59:23.885]                   sessionInformation <- function() {
[17:59:23.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:23.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:23.885]                       search = base::search(), system = base::Sys.info())
[17:59:23.885]                   }
[17:59:23.885]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:23.885]                     cond$call), session = sessionInformation(), 
[17:59:23.885]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:23.885]                   signalCondition(cond)
[17:59:23.885]                 }
[17:59:23.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:23.885]                 "immediateCondition"))) {
[17:59:23.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:23.885]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:23.885]                   if (TRUE && !signal) {
[17:59:23.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.885]                     {
[17:59:23.885]                       inherits <- base::inherits
[17:59:23.885]                       invokeRestart <- base::invokeRestart
[17:59:23.885]                       is.null <- base::is.null
[17:59:23.885]                       muffled <- FALSE
[17:59:23.885]                       if (inherits(cond, "message")) {
[17:59:23.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.885]                         if (muffled) 
[17:59:23.885]                           invokeRestart("muffleMessage")
[17:59:23.885]                       }
[17:59:23.885]                       else if (inherits(cond, "warning")) {
[17:59:23.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.885]                         if (muffled) 
[17:59:23.885]                           invokeRestart("muffleWarning")
[17:59:23.885]                       }
[17:59:23.885]                       else if (inherits(cond, "condition")) {
[17:59:23.885]                         if (!is.null(pattern)) {
[17:59:23.885]                           computeRestarts <- base::computeRestarts
[17:59:23.885]                           grepl <- base::grepl
[17:59:23.885]                           restarts <- computeRestarts(cond)
[17:59:23.885]                           for (restart in restarts) {
[17:59:23.885]                             name <- restart$name
[17:59:23.885]                             if (is.null(name)) 
[17:59:23.885]                               next
[17:59:23.885]                             if (!grepl(pattern, name)) 
[17:59:23.885]                               next
[17:59:23.885]                             invokeRestart(restart)
[17:59:23.885]                             muffled <- TRUE
[17:59:23.885]                             break
[17:59:23.885]                           }
[17:59:23.885]                         }
[17:59:23.885]                       }
[17:59:23.885]                       invisible(muffled)
[17:59:23.885]                     }
[17:59:23.885]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.885]                   }
[17:59:23.885]                 }
[17:59:23.885]                 else {
[17:59:23.885]                   if (TRUE) {
[17:59:23.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.885]                     {
[17:59:23.885]                       inherits <- base::inherits
[17:59:23.885]                       invokeRestart <- base::invokeRestart
[17:59:23.885]                       is.null <- base::is.null
[17:59:23.885]                       muffled <- FALSE
[17:59:23.885]                       if (inherits(cond, "message")) {
[17:59:23.885]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.885]                         if (muffled) 
[17:59:23.885]                           invokeRestart("muffleMessage")
[17:59:23.885]                       }
[17:59:23.885]                       else if (inherits(cond, "warning")) {
[17:59:23.885]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.885]                         if (muffled) 
[17:59:23.885]                           invokeRestart("muffleWarning")
[17:59:23.885]                       }
[17:59:23.885]                       else if (inherits(cond, "condition")) {
[17:59:23.885]                         if (!is.null(pattern)) {
[17:59:23.885]                           computeRestarts <- base::computeRestarts
[17:59:23.885]                           grepl <- base::grepl
[17:59:23.885]                           restarts <- computeRestarts(cond)
[17:59:23.885]                           for (restart in restarts) {
[17:59:23.885]                             name <- restart$name
[17:59:23.885]                             if (is.null(name)) 
[17:59:23.885]                               next
[17:59:23.885]                             if (!grepl(pattern, name)) 
[17:59:23.885]                               next
[17:59:23.885]                             invokeRestart(restart)
[17:59:23.885]                             muffled <- TRUE
[17:59:23.885]                             break
[17:59:23.885]                           }
[17:59:23.885]                         }
[17:59:23.885]                       }
[17:59:23.885]                       invisible(muffled)
[17:59:23.885]                     }
[17:59:23.885]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.885]                   }
[17:59:23.885]                 }
[17:59:23.885]             }
[17:59:23.885]         }))
[17:59:23.885]     }, error = function(ex) {
[17:59:23.885]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:23.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.885]                 ...future.rng), started = ...future.startTime, 
[17:59:23.885]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:23.885]             version = "1.8"), class = "FutureResult")
[17:59:23.885]     }, finally = {
[17:59:23.885]         if (!identical(...future.workdir, getwd())) 
[17:59:23.885]             setwd(...future.workdir)
[17:59:23.885]         {
[17:59:23.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:23.885]                 ...future.oldOptions$nwarnings <- NULL
[17:59:23.885]             }
[17:59:23.885]             base::options(...future.oldOptions)
[17:59:23.885]             if (.Platform$OS.type == "windows") {
[17:59:23.885]                 old_names <- names(...future.oldEnvVars)
[17:59:23.885]                 envs <- base::Sys.getenv()
[17:59:23.885]                 names <- names(envs)
[17:59:23.885]                 common <- intersect(names, old_names)
[17:59:23.885]                 added <- setdiff(names, old_names)
[17:59:23.885]                 removed <- setdiff(old_names, names)
[17:59:23.885]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:23.885]                   envs[common]]
[17:59:23.885]                 NAMES <- toupper(changed)
[17:59:23.885]                 args <- list()
[17:59:23.885]                 for (kk in seq_along(NAMES)) {
[17:59:23.885]                   name <- changed[[kk]]
[17:59:23.885]                   NAME <- NAMES[[kk]]
[17:59:23.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.885]                     next
[17:59:23.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.885]                 }
[17:59:23.885]                 NAMES <- toupper(added)
[17:59:23.885]                 for (kk in seq_along(NAMES)) {
[17:59:23.885]                   name <- added[[kk]]
[17:59:23.885]                   NAME <- NAMES[[kk]]
[17:59:23.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.885]                     next
[17:59:23.885]                   args[[name]] <- ""
[17:59:23.885]                 }
[17:59:23.885]                 NAMES <- toupper(removed)
[17:59:23.885]                 for (kk in seq_along(NAMES)) {
[17:59:23.885]                   name <- removed[[kk]]
[17:59:23.885]                   NAME <- NAMES[[kk]]
[17:59:23.885]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.885]                     next
[17:59:23.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.885]                 }
[17:59:23.885]                 if (length(args) > 0) 
[17:59:23.885]                   base::do.call(base::Sys.setenv, args = args)
[17:59:23.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:23.885]             }
[17:59:23.885]             else {
[17:59:23.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:23.885]             }
[17:59:23.885]             {
[17:59:23.885]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:23.885]                   0L) {
[17:59:23.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:23.885]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:23.885]                   base::options(opts)
[17:59:23.885]                 }
[17:59:23.885]                 {
[17:59:23.885]                   {
[17:59:23.885]                     NULL
[17:59:23.885]                     RNGkind("Mersenne-Twister")
[17:59:23.885]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:23.885]                       inherits = FALSE)
[17:59:23.885]                   }
[17:59:23.885]                   options(future.plan = NULL)
[17:59:23.885]                   if (is.na(NA_character_)) 
[17:59:23.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:23.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:23.885]                     .init = FALSE)
[17:59:23.885]                 }
[17:59:23.885]             }
[17:59:23.885]         }
[17:59:23.885]     })
[17:59:23.885]     if (TRUE) {
[17:59:23.885]         base::sink(type = "output", split = FALSE)
[17:59:23.885]         if (TRUE) {
[17:59:23.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:23.885]         }
[17:59:23.885]         else {
[17:59:23.885]             ...future.result["stdout"] <- base::list(NULL)
[17:59:23.885]         }
[17:59:23.885]         base::close(...future.stdout)
[17:59:23.885]         ...future.stdout <- NULL
[17:59:23.885]     }
[17:59:23.885]     ...future.result$conditions <- ...future.conditions
[17:59:23.885]     ...future.result$finished <- base::Sys.time()
[17:59:23.885]     ...future.result
[17:59:23.885] }
[17:59:23.888] assign_globals() ...
[17:59:23.888] List of 5
[17:59:23.888]  $ ...future.FUN            :function (x, ...)  
[17:59:23.888]  $ future.call.arguments    :List of 1
[17:59:23.888]   ..$ singular.ok: logi FALSE
[17:59:23.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.888]  $ ...future.elements_ii    :List of 3
[17:59:23.888]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:23.888]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:23.888]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.888]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:23.888]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:23.888]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:23.888]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.888]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:23.888]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:23.888]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:23.888]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.888]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:23.888]  $ ...future.seeds_ii       : NULL
[17:59:23.888]  $ ...future.globals.maxSize: NULL
[17:59:23.888]  - attr(*, "where")=List of 5
[17:59:23.888]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:23.888]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:23.888]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:23.888]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:23.888]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:23.888]  - attr(*, "resolved")= logi FALSE
[17:59:23.888]  - attr(*, "total_size")= num 5384
[17:59:23.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.888]  - attr(*, "already-done")= logi TRUE
[17:59:23.906] - reassign environment for ‘...future.FUN’
[17:59:23.906] - copied ‘...future.FUN’ to environment
[17:59:23.906] - copied ‘future.call.arguments’ to environment
[17:59:23.907] - copied ‘...future.elements_ii’ to environment
[17:59:23.907] - copied ‘...future.seeds_ii’ to environment
[17:59:23.907] - copied ‘...future.globals.maxSize’ to environment
[17:59:23.907] assign_globals() ... done
[17:59:23.908] plan(): Setting new future strategy stack:
[17:59:23.908] List of future strategies:
[17:59:23.908] 1. sequential:
[17:59:23.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.908]    - tweaked: FALSE
[17:59:23.908]    - call: NULL
[17:59:23.909] plan(): nbrOfWorkers() = 1
[17:59:23.917] plan(): Setting new future strategy stack:
[17:59:23.917] List of future strategies:
[17:59:23.917] 1. sequential:
[17:59:23.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:23.917]    - tweaked: FALSE
[17:59:23.917]    - call: plan(strategy)
[17:59:23.918] plan(): nbrOfWorkers() = 1
[17:59:23.918] SequentialFuture started (and completed)
[17:59:23.919] - Launch lazy future ... done
[17:59:23.919] run() for ‘SequentialFuture’ ... done
[17:59:23.919] Created future:
[17:59:23.919] SequentialFuture:
[17:59:23.919] Label: ‘future_by-1’
[17:59:23.919] Expression:
[17:59:23.919] {
[17:59:23.919]     do.call(function(...) {
[17:59:23.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.919]             on.exit(options(oopts), add = TRUE)
[17:59:23.919]         }
[17:59:23.919]         {
[17:59:23.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.919]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.919]             })
[17:59:23.919]         }
[17:59:23.919]     }, args = future.call.arguments)
[17:59:23.919] }
[17:59:23.919] Lazy evaluation: FALSE
[17:59:23.919] Asynchronous evaluation: FALSE
[17:59:23.919] Local evaluation: TRUE
[17:59:23.919] Environment: R_GlobalEnv
[17:59:23.919] Capture standard output: TRUE
[17:59:23.919] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:23.919] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:23.919] Packages: 1 packages (‘stats’)
[17:59:23.919] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:23.919] Resolved: TRUE
[17:59:23.919] Value: 26.06 KiB of class ‘list’
[17:59:23.919] Early signaling: FALSE
[17:59:23.919] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:23.919] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.922] Chunk #1 of 1 ... DONE
[17:59:23.923] Launching 1 futures (chunks) ... DONE
[17:59:23.923] Resolving 1 futures (chunks) ...
[17:59:23.923] resolve() on list ...
[17:59:23.923]  recursive: 0
[17:59:23.923]  length: 1
[17:59:23.924] 
[17:59:23.924] resolved() for ‘SequentialFuture’ ...
[17:59:23.924] - state: ‘finished’
[17:59:23.924] - run: TRUE
[17:59:23.924] - result: ‘FutureResult’
[17:59:23.925] resolved() for ‘SequentialFuture’ ... done
[17:59:23.925] Future #1
[17:59:23.925] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:23.925] - nx: 1
[17:59:23.925] - relay: TRUE
[17:59:23.926] - stdout: TRUE
[17:59:23.926] - signal: TRUE
[17:59:23.926] - resignal: FALSE
[17:59:23.926] - force: TRUE
[17:59:23.926] - relayed: [n=1] FALSE
[17:59:23.926] - queued futures: [n=1] FALSE
[17:59:23.927]  - until=1
[17:59:23.927]  - relaying element #1
[17:59:23.927] - relayed: [n=1] TRUE
[17:59:23.927] - queued futures: [n=1] TRUE
[17:59:23.928] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:23.928]  length: 0 (resolved future 1)
[17:59:23.928] Relaying remaining futures
[17:59:23.928] signalConditionsASAP(NULL, pos=0) ...
[17:59:23.928] - nx: 1
[17:59:23.929] - relay: TRUE
[17:59:23.929] - stdout: TRUE
[17:59:23.929] - signal: TRUE
[17:59:23.929] - resignal: FALSE
[17:59:23.929] - force: TRUE
[17:59:23.929] - relayed: [n=1] TRUE
[17:59:23.930] - queued futures: [n=1] TRUE
 - flush all
[17:59:23.930] - relayed: [n=1] TRUE
[17:59:23.930] - queued futures: [n=1] TRUE
[17:59:23.930] signalConditionsASAP(NULL, pos=0) ... done
[17:59:23.930] resolve() on list ... DONE
[17:59:23.931]  - Number of value chunks collected: 1
[17:59:23.931] Resolving 1 futures (chunks) ... DONE
[17:59:23.931] Reducing values from 1 chunks ...
[17:59:23.931]  - Number of values collected after concatenation: 3
[17:59:23.932]  - Number of values expected: 3
[17:59:23.932] Reducing values from 1 chunks ... DONE
[17:59:23.932] future_lapply() ... DONE
[17:59:23.932] future_by_internal() ... DONE
[17:59:23.941] future_by_internal() ...
[17:59:23.942] future_lapply() ...
[17:59:23.943] Number of chunks: 1
[17:59:23.944] getGlobalsAndPackagesXApply() ...
[17:59:23.944]  - future.globals: TRUE
[17:59:23.944] getGlobalsAndPackages() ...
[17:59:23.944] Searching for globals...
[17:59:23.948] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:23.948] Searching for globals ... DONE
[17:59:23.948] Resolving globals: FALSE
[17:59:23.949] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:59:23.950] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:59:23.950] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:23.950] - packages: [1] ‘stats’
[17:59:23.951] getGlobalsAndPackages() ... DONE
[17:59:23.951]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:23.951]  - needed namespaces: [n=1] ‘stats’
[17:59:23.951] Finding globals ... DONE
[17:59:23.951]  - use_args: TRUE
[17:59:23.952]  - Getting '...' globals ...
[17:59:23.954] resolve() on list ...
[17:59:23.955]  recursive: 0
[17:59:23.955]  length: 1
[17:59:23.955]  elements: ‘...’
[17:59:23.955]  length: 0 (resolved future 1)
[17:59:23.956] resolve() on list ... DONE
[17:59:23.956]    - '...' content: [n=0] 
[17:59:23.956] List of 1
[17:59:23.956]  $ ...: list()
[17:59:23.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.956]  - attr(*, "where")=List of 1
[17:59:23.956]   ..$ ...:<environment: 0x62649fe76340> 
[17:59:23.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.956]  - attr(*, "resolved")= logi TRUE
[17:59:23.956]  - attr(*, "total_size")= num NA
[17:59:23.961]  - Getting '...' globals ... DONE
[17:59:23.961] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:59:23.961] List of 4
[17:59:23.961]  $ ...future.FUN:function (x)  
[17:59:23.961]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:23.961]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:23.961]  $ ...          : list()
[17:59:23.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.961]  - attr(*, "where")=List of 4
[17:59:23.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:23.961]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:59:23.961]   ..$ wool         :<environment: R_EmptyEnv> 
[17:59:23.961]   ..$ ...          :<environment: 0x62649fe76340> 
[17:59:23.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.961]  - attr(*, "resolved")= logi FALSE
[17:59:23.961]  - attr(*, "total_size")= num 2320
[17:59:23.969] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:23.969] getGlobalsAndPackagesXApply() ... DONE
[17:59:23.970] Number of futures (= number of chunks): 1
[17:59:23.970] Launching 1 futures (chunks) ...
[17:59:23.970] Chunk #1 of 1 ...
[17:59:23.970]  - Finding globals in 'X' for chunk #1 ...
[17:59:23.971] getGlobalsAndPackages() ...
[17:59:23.971] Searching for globals...
[17:59:23.972] 
[17:59:23.972] Searching for globals ... DONE
[17:59:23.972] - globals: [0] <none>
[17:59:23.972] getGlobalsAndPackages() ... DONE
[17:59:23.973]    + additional globals found: [n=0] 
[17:59:23.973]    + additional namespaces needed: [n=0] 
[17:59:23.973]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:23.973]  - seeds: <none>
[17:59:23.973]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.974] getGlobalsAndPackages() ...
[17:59:23.974] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.974] Resolving globals: FALSE
[17:59:23.974] Tweak future expression to call with '...' arguments ...
[17:59:23.975] {
[17:59:23.975]     do.call(function(...) {
[17:59:23.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:23.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.975]             on.exit(options(oopts), add = TRUE)
[17:59:23.975]         }
[17:59:23.975]         {
[17:59:23.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:23.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.975]                 ...future.FUN(...future.X_jj, ...)
[17:59:23.975]             })
[17:59:23.975]         }
[17:59:23.975]     }, args = future.call.arguments)
[17:59:23.975] }
[17:59:23.975] Tweak future expression to call with '...' arguments ... DONE
[17:59:23.976] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:23.976] 
[17:59:23.977] getGlobalsAndPackages() ... DONE
[17:59:23.977] run() for ‘Future’ ...
[17:59:23.977] - state: ‘created’
[17:59:23.978] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:23.978] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:23.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:23.979]   - Field: ‘label’
[17:59:23.979]   - Field: ‘local’
[17:59:23.979]   - Field: ‘owner’
[17:59:23.979]   - Field: ‘envir’
[17:59:23.980]   - Field: ‘packages’
[17:59:23.980]   - Field: ‘gc’
[17:59:23.980]   - Field: ‘conditions’
[17:59:23.980]   - Field: ‘expr’
[17:59:23.980]   - Field: ‘uuid’
[17:59:23.981]   - Field: ‘seed’
[17:59:23.981]   - Field: ‘version’
[17:59:23.981]   - Field: ‘result’
[17:59:23.981]   - Field: ‘asynchronous’
[17:59:23.982]   - Field: ‘calls’
[17:59:23.982]   - Field: ‘globals’
[17:59:23.982]   - Field: ‘stdout’
[17:59:23.982]   - Field: ‘earlySignal’
[17:59:23.982]   - Field: ‘lazy’
[17:59:23.983]   - Field: ‘state’
[17:59:23.983] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:23.983] - Launch lazy future ...
[17:59:23.983] Packages needed by the future expression (n = 1): ‘stats’
[17:59:23.984] Packages needed by future strategies (n = 0): <none>
[17:59:23.985] {
[17:59:23.985]     {
[17:59:23.985]         {
[17:59:23.985]             ...future.startTime <- base::Sys.time()
[17:59:23.985]             {
[17:59:23.985]                 {
[17:59:23.985]                   {
[17:59:23.985]                     {
[17:59:23.985]                       base::local({
[17:59:23.985]                         has_future <- base::requireNamespace("future", 
[17:59:23.985]                           quietly = TRUE)
[17:59:23.985]                         if (has_future) {
[17:59:23.985]                           ns <- base::getNamespace("future")
[17:59:23.985]                           version <- ns[[".package"]][["version"]]
[17:59:23.985]                           if (is.null(version)) 
[17:59:23.985]                             version <- utils::packageVersion("future")
[17:59:23.985]                         }
[17:59:23.985]                         else {
[17:59:23.985]                           version <- NULL
[17:59:23.985]                         }
[17:59:23.985]                         if (!has_future || version < "1.8.0") {
[17:59:23.985]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:23.985]                             "", base::R.version$version.string), 
[17:59:23.985]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:23.985]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:23.985]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:23.985]                               "release", "version")], collapse = " "), 
[17:59:23.985]                             hostname = base::Sys.info()[["nodename"]])
[17:59:23.985]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:23.985]                             info)
[17:59:23.985]                           info <- base::paste(info, collapse = "; ")
[17:59:23.985]                           if (!has_future) {
[17:59:23.985]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:23.985]                               info)
[17:59:23.985]                           }
[17:59:23.985]                           else {
[17:59:23.985]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:23.985]                               info, version)
[17:59:23.985]                           }
[17:59:23.985]                           base::stop(msg)
[17:59:23.985]                         }
[17:59:23.985]                       })
[17:59:23.985]                     }
[17:59:23.985]                     base::local({
[17:59:23.985]                       for (pkg in "stats") {
[17:59:23.985]                         base::loadNamespace(pkg)
[17:59:23.985]                         base::library(pkg, character.only = TRUE)
[17:59:23.985]                       }
[17:59:23.985]                     })
[17:59:23.985]                   }
[17:59:23.985]                   ...future.strategy.old <- future::plan("list")
[17:59:23.985]                   options(future.plan = NULL)
[17:59:23.985]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.985]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:23.985]                 }
[17:59:23.985]                 ...future.workdir <- getwd()
[17:59:23.985]             }
[17:59:23.985]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:23.985]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:23.985]         }
[17:59:23.985]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:23.985]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:23.985]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:23.985]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:23.985]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:23.985]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:23.985]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:23.985]             base::names(...future.oldOptions))
[17:59:23.985]     }
[17:59:23.985]     if (FALSE) {
[17:59:23.985]     }
[17:59:23.985]     else {
[17:59:23.985]         if (TRUE) {
[17:59:23.985]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:23.985]                 open = "w")
[17:59:23.985]         }
[17:59:23.985]         else {
[17:59:23.985]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:23.985]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:23.985]         }
[17:59:23.985]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:23.985]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:23.985]             base::sink(type = "output", split = FALSE)
[17:59:23.985]             base::close(...future.stdout)
[17:59:23.985]         }, add = TRUE)
[17:59:23.985]     }
[17:59:23.985]     ...future.frame <- base::sys.nframe()
[17:59:23.985]     ...future.conditions <- base::list()
[17:59:23.985]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:23.985]     if (FALSE) {
[17:59:23.985]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:23.985]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:23.985]     }
[17:59:23.985]     ...future.result <- base::tryCatch({
[17:59:23.985]         base::withCallingHandlers({
[17:59:23.985]             ...future.value <- base::withVisible(base::local({
[17:59:23.985]                 do.call(function(...) {
[17:59:23.985]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:23.985]                   if (!identical(...future.globals.maxSize.org, 
[17:59:23.985]                     ...future.globals.maxSize)) {
[17:59:23.985]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:23.985]                     on.exit(options(oopts), add = TRUE)
[17:59:23.985]                   }
[17:59:23.985]                   {
[17:59:23.985]                     lapply(seq_along(...future.elements_ii), 
[17:59:23.985]                       FUN = function(jj) {
[17:59:23.985]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:23.985]                         ...future.FUN(...future.X_jj, ...)
[17:59:23.985]                       })
[17:59:23.985]                   }
[17:59:23.985]                 }, args = future.call.arguments)
[17:59:23.985]             }))
[17:59:23.985]             future::FutureResult(value = ...future.value$value, 
[17:59:23.985]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.985]                   ...future.rng), globalenv = if (FALSE) 
[17:59:23.985]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:23.985]                     ...future.globalenv.names))
[17:59:23.985]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:23.985]         }, condition = base::local({
[17:59:23.985]             c <- base::c
[17:59:23.985]             inherits <- base::inherits
[17:59:23.985]             invokeRestart <- base::invokeRestart
[17:59:23.985]             length <- base::length
[17:59:23.985]             list <- base::list
[17:59:23.985]             seq.int <- base::seq.int
[17:59:23.985]             signalCondition <- base::signalCondition
[17:59:23.985]             sys.calls <- base::sys.calls
[17:59:23.985]             `[[` <- base::`[[`
[17:59:23.985]             `+` <- base::`+`
[17:59:23.985]             `<<-` <- base::`<<-`
[17:59:23.985]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:23.985]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:23.985]                   3L)]
[17:59:23.985]             }
[17:59:23.985]             function(cond) {
[17:59:23.985]                 is_error <- inherits(cond, "error")
[17:59:23.985]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:23.985]                   NULL)
[17:59:23.985]                 if (is_error) {
[17:59:23.985]                   sessionInformation <- function() {
[17:59:23.985]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:23.985]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:23.985]                       search = base::search(), system = base::Sys.info())
[17:59:23.985]                   }
[17:59:23.985]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.985]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:23.985]                     cond$call), session = sessionInformation(), 
[17:59:23.985]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:23.985]                   signalCondition(cond)
[17:59:23.985]                 }
[17:59:23.985]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:23.985]                 "immediateCondition"))) {
[17:59:23.985]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:23.985]                   ...future.conditions[[length(...future.conditions) + 
[17:59:23.985]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:23.985]                   if (TRUE && !signal) {
[17:59:23.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.985]                     {
[17:59:23.985]                       inherits <- base::inherits
[17:59:23.985]                       invokeRestart <- base::invokeRestart
[17:59:23.985]                       is.null <- base::is.null
[17:59:23.985]                       muffled <- FALSE
[17:59:23.985]                       if (inherits(cond, "message")) {
[17:59:23.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.985]                         if (muffled) 
[17:59:23.985]                           invokeRestart("muffleMessage")
[17:59:23.985]                       }
[17:59:23.985]                       else if (inherits(cond, "warning")) {
[17:59:23.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.985]                         if (muffled) 
[17:59:23.985]                           invokeRestart("muffleWarning")
[17:59:23.985]                       }
[17:59:23.985]                       else if (inherits(cond, "condition")) {
[17:59:23.985]                         if (!is.null(pattern)) {
[17:59:23.985]                           computeRestarts <- base::computeRestarts
[17:59:23.985]                           grepl <- base::grepl
[17:59:23.985]                           restarts <- computeRestarts(cond)
[17:59:23.985]                           for (restart in restarts) {
[17:59:23.985]                             name <- restart$name
[17:59:23.985]                             if (is.null(name)) 
[17:59:23.985]                               next
[17:59:23.985]                             if (!grepl(pattern, name)) 
[17:59:23.985]                               next
[17:59:23.985]                             invokeRestart(restart)
[17:59:23.985]                             muffled <- TRUE
[17:59:23.985]                             break
[17:59:23.985]                           }
[17:59:23.985]                         }
[17:59:23.985]                       }
[17:59:23.985]                       invisible(muffled)
[17:59:23.985]                     }
[17:59:23.985]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.985]                   }
[17:59:23.985]                 }
[17:59:23.985]                 else {
[17:59:23.985]                   if (TRUE) {
[17:59:23.985]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:23.985]                     {
[17:59:23.985]                       inherits <- base::inherits
[17:59:23.985]                       invokeRestart <- base::invokeRestart
[17:59:23.985]                       is.null <- base::is.null
[17:59:23.985]                       muffled <- FALSE
[17:59:23.985]                       if (inherits(cond, "message")) {
[17:59:23.985]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:23.985]                         if (muffled) 
[17:59:23.985]                           invokeRestart("muffleMessage")
[17:59:23.985]                       }
[17:59:23.985]                       else if (inherits(cond, "warning")) {
[17:59:23.985]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:23.985]                         if (muffled) 
[17:59:23.985]                           invokeRestart("muffleWarning")
[17:59:23.985]                       }
[17:59:23.985]                       else if (inherits(cond, "condition")) {
[17:59:23.985]                         if (!is.null(pattern)) {
[17:59:23.985]                           computeRestarts <- base::computeRestarts
[17:59:23.985]                           grepl <- base::grepl
[17:59:23.985]                           restarts <- computeRestarts(cond)
[17:59:23.985]                           for (restart in restarts) {
[17:59:23.985]                             name <- restart$name
[17:59:23.985]                             if (is.null(name)) 
[17:59:23.985]                               next
[17:59:23.985]                             if (!grepl(pattern, name)) 
[17:59:23.985]                               next
[17:59:23.985]                             invokeRestart(restart)
[17:59:23.985]                             muffled <- TRUE
[17:59:23.985]                             break
[17:59:23.985]                           }
[17:59:23.985]                         }
[17:59:23.985]                       }
[17:59:23.985]                       invisible(muffled)
[17:59:23.985]                     }
[17:59:23.985]                     muffleCondition(cond, pattern = "^muffle")
[17:59:23.985]                   }
[17:59:23.985]                 }
[17:59:23.985]             }
[17:59:23.985]         }))
[17:59:23.985]     }, error = function(ex) {
[17:59:23.985]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:23.985]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:23.985]                 ...future.rng), started = ...future.startTime, 
[17:59:23.985]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:23.985]             version = "1.8"), class = "FutureResult")
[17:59:23.985]     }, finally = {
[17:59:23.985]         if (!identical(...future.workdir, getwd())) 
[17:59:23.985]             setwd(...future.workdir)
[17:59:23.985]         {
[17:59:23.985]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:23.985]                 ...future.oldOptions$nwarnings <- NULL
[17:59:23.985]             }
[17:59:23.985]             base::options(...future.oldOptions)
[17:59:23.985]             if (.Platform$OS.type == "windows") {
[17:59:23.985]                 old_names <- names(...future.oldEnvVars)
[17:59:23.985]                 envs <- base::Sys.getenv()
[17:59:23.985]                 names <- names(envs)
[17:59:23.985]                 common <- intersect(names, old_names)
[17:59:23.985]                 added <- setdiff(names, old_names)
[17:59:23.985]                 removed <- setdiff(old_names, names)
[17:59:23.985]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:23.985]                   envs[common]]
[17:59:23.985]                 NAMES <- toupper(changed)
[17:59:23.985]                 args <- list()
[17:59:23.985]                 for (kk in seq_along(NAMES)) {
[17:59:23.985]                   name <- changed[[kk]]
[17:59:23.985]                   NAME <- NAMES[[kk]]
[17:59:23.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.985]                     next
[17:59:23.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.985]                 }
[17:59:23.985]                 NAMES <- toupper(added)
[17:59:23.985]                 for (kk in seq_along(NAMES)) {
[17:59:23.985]                   name <- added[[kk]]
[17:59:23.985]                   NAME <- NAMES[[kk]]
[17:59:23.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.985]                     next
[17:59:23.985]                   args[[name]] <- ""
[17:59:23.985]                 }
[17:59:23.985]                 NAMES <- toupper(removed)
[17:59:23.985]                 for (kk in seq_along(NAMES)) {
[17:59:23.985]                   name <- removed[[kk]]
[17:59:23.985]                   NAME <- NAMES[[kk]]
[17:59:23.985]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:23.985]                     next
[17:59:23.985]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:23.985]                 }
[17:59:23.985]                 if (length(args) > 0) 
[17:59:23.985]                   base::do.call(base::Sys.setenv, args = args)
[17:59:23.985]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:23.985]             }
[17:59:23.985]             else {
[17:59:23.985]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:23.985]             }
[17:59:23.985]             {
[17:59:23.985]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:23.985]                   0L) {
[17:59:23.985]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:23.985]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:23.985]                   base::options(opts)
[17:59:23.985]                 }
[17:59:23.985]                 {
[17:59:23.985]                   {
[17:59:23.985]                     NULL
[17:59:23.985]                     RNGkind("Mersenne-Twister")
[17:59:23.985]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:23.985]                       inherits = FALSE)
[17:59:23.985]                   }
[17:59:23.985]                   options(future.plan = NULL)
[17:59:23.985]                   if (is.na(NA_character_)) 
[17:59:23.985]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:23.985]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:23.985]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:23.985]                     .init = FALSE)
[17:59:23.985]                 }
[17:59:23.985]             }
[17:59:23.985]         }
[17:59:23.985]     })
[17:59:23.985]     if (TRUE) {
[17:59:23.985]         base::sink(type = "output", split = FALSE)
[17:59:23.985]         if (TRUE) {
[17:59:23.985]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:23.985]         }
[17:59:23.985]         else {
[17:59:23.985]             ...future.result["stdout"] <- base::list(NULL)
[17:59:23.985]         }
[17:59:23.985]         base::close(...future.stdout)
[17:59:23.985]         ...future.stdout <- NULL
[17:59:23.985]     }
[17:59:23.985]     ...future.result$conditions <- ...future.conditions
[17:59:23.985]     ...future.result$finished <- base::Sys.time()
[17:59:23.985]     ...future.result
[17:59:23.985] }
[17:59:23.988] assign_globals() ...
[17:59:23.989] List of 7
[17:59:23.989]  $ ...future.FUN            :function (x)  
[17:59:23.989]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:23.989]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:23.989]  $ future.call.arguments    : list()
[17:59:23.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:23.989]  $ ...future.elements_ii    :List of 3
[17:59:23.989]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:23.989]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:23.989]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.989]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:23.989]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:23.989]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:23.989]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.989]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:23.989]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:23.989]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:23.989]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:23.989]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:23.989]  $ ...future.seeds_ii       : NULL
[17:59:23.989]  $ ...future.globals.maxSize: NULL
[17:59:23.989]  - attr(*, "where")=List of 7
[17:59:23.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:23.989]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:59:23.989]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:59:23.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:23.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:23.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:23.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:23.989]  - attr(*, "resolved")= logi FALSE
[17:59:23.989]  - attr(*, "total_size")= num 2320
[17:59:23.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:23.989]  - attr(*, "already-done")= logi TRUE
[17:59:24.012] - reassign environment for ‘...future.FUN’
[17:59:24.013] - copied ‘...future.FUN’ to environment
[17:59:24.013] - copied ‘breaks’ to environment
[17:59:24.013] - copied ‘wool’ to environment
[17:59:24.013] - copied ‘future.call.arguments’ to environment
[17:59:24.013] - copied ‘...future.elements_ii’ to environment
[17:59:24.014] - copied ‘...future.seeds_ii’ to environment
[17:59:24.014] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.014] assign_globals() ... done
[17:59:24.015] plan(): Setting new future strategy stack:
[17:59:24.015] List of future strategies:
[17:59:24.015] 1. sequential:
[17:59:24.015]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.015]    - tweaked: FALSE
[17:59:24.015]    - call: NULL
[17:59:24.016] plan(): nbrOfWorkers() = 1
[17:59:24.023] plan(): Setting new future strategy stack:
[17:59:24.023] List of future strategies:
[17:59:24.023] 1. sequential:
[17:59:24.023]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.023]    - tweaked: FALSE
[17:59:24.023]    - call: plan(strategy)
[17:59:24.024] plan(): nbrOfWorkers() = 1
[17:59:24.025] SequentialFuture started (and completed)
[17:59:24.025] - Launch lazy future ... done
[17:59:24.025] run() for ‘SequentialFuture’ ... done
[17:59:24.026] Created future:
[17:59:24.026] SequentialFuture:
[17:59:24.026] Label: ‘future_by-1’
[17:59:24.026] Expression:
[17:59:24.026] {
[17:59:24.026]     do.call(function(...) {
[17:59:24.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.026]             on.exit(options(oopts), add = TRUE)
[17:59:24.026]         }
[17:59:24.026]         {
[17:59:24.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.026]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.026]             })
[17:59:24.026]         }
[17:59:24.026]     }, args = future.call.arguments)
[17:59:24.026] }
[17:59:24.026] Lazy evaluation: FALSE
[17:59:24.026] Asynchronous evaluation: FALSE
[17:59:24.026] Local evaluation: TRUE
[17:59:24.026] Environment: 0x62649fe2b880
[17:59:24.026] Capture standard output: TRUE
[17:59:24.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.026] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:59:24.026] Packages: 1 packages (‘stats’)
[17:59:24.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.026] Resolved: TRUE
[17:59:24.026] Value: 25.57 KiB of class ‘list’
[17:59:24.026] Early signaling: FALSE
[17:59:24.026] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.026] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.029] Chunk #1 of 1 ... DONE
[17:59:24.030] Launching 1 futures (chunks) ... DONE
[17:59:24.030] Resolving 1 futures (chunks) ...
[17:59:24.030] resolve() on list ...
[17:59:24.030]  recursive: 0
[17:59:24.031]  length: 1
[17:59:24.031] 
[17:59:24.031] resolved() for ‘SequentialFuture’ ...
[17:59:24.031] - state: ‘finished’
[17:59:24.031] - run: TRUE
[17:59:24.032] - result: ‘FutureResult’
[17:59:24.032] resolved() for ‘SequentialFuture’ ... done
[17:59:24.032] Future #1
[17:59:24.032] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.033] - nx: 1
[17:59:24.033] - relay: TRUE
[17:59:24.033] - stdout: TRUE
[17:59:24.033] - signal: TRUE
[17:59:24.033] - resignal: FALSE
[17:59:24.033] - force: TRUE
[17:59:24.034] - relayed: [n=1] FALSE
[17:59:24.034] - queued futures: [n=1] FALSE
[17:59:24.034]  - until=1
[17:59:24.034]  - relaying element #1
[17:59:24.035] - relayed: [n=1] TRUE
[17:59:24.035] - queued futures: [n=1] TRUE
[17:59:24.035] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.035]  length: 0 (resolved future 1)
[17:59:24.035] Relaying remaining futures
[17:59:24.036] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.036] - nx: 1
[17:59:24.036] - relay: TRUE
[17:59:24.036] - stdout: TRUE
[17:59:24.036] - signal: TRUE
[17:59:24.037] - resignal: FALSE
[17:59:24.037] - force: TRUE
[17:59:24.037] - relayed: [n=1] TRUE
[17:59:24.037] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.037] - relayed: [n=1] TRUE
[17:59:24.038] - queued futures: [n=1] TRUE
[17:59:24.038] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.038] resolve() on list ... DONE
[17:59:24.038]  - Number of value chunks collected: 1
[17:59:24.038] Resolving 1 futures (chunks) ... DONE
[17:59:24.039] Reducing values from 1 chunks ...
[17:59:24.039]  - Number of values collected after concatenation: 3
[17:59:24.039]  - Number of values expected: 3
[17:59:24.039] Reducing values from 1 chunks ... DONE
[17:59:24.039] future_lapply() ... DONE
[17:59:24.040] future_by_internal() ... DONE
[17:59:24.040] future_by_internal() ...
[17:59:24.041] future_lapply() ...
[17:59:24.042] Number of chunks: 1
[17:59:24.042] getGlobalsAndPackagesXApply() ...
[17:59:24.043]  - future.globals: TRUE
[17:59:24.043] getGlobalsAndPackages() ...
[17:59:24.043] Searching for globals...
[17:59:24.045] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.045] Searching for globals ... DONE
[17:59:24.045] Resolving globals: FALSE
[17:59:24.046] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.047] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.047] - globals: [1] ‘FUN’
[17:59:24.047] 
[17:59:24.050] getGlobalsAndPackages() ... DONE
[17:59:24.050]  - globals found/used: [n=1] ‘FUN’
[17:59:24.050]  - needed namespaces: [n=0] 
[17:59:24.050] Finding globals ... DONE
[17:59:24.051]  - use_args: TRUE
[17:59:24.051]  - Getting '...' globals ...
[17:59:24.051] resolve() on list ...
[17:59:24.052]  recursive: 0
[17:59:24.052]  length: 1
[17:59:24.052]  elements: ‘...’
[17:59:24.052]  length: 0 (resolved future 1)
[17:59:24.052] resolve() on list ... DONE
[17:59:24.053]    - '...' content: [n=0] 
[17:59:24.053] List of 1
[17:59:24.053]  $ ...: list()
[17:59:24.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.053]  - attr(*, "where")=List of 1
[17:59:24.053]   ..$ ...:<environment: 0x6264a000e2c0> 
[17:59:24.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.053]  - attr(*, "resolved")= logi TRUE
[17:59:24.053]  - attr(*, "total_size")= num NA
[17:59:24.058]  - Getting '...' globals ... DONE
[17:59:24.058] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.058] List of 2
[17:59:24.058]  $ ...future.FUN:function (object, ...)  
[17:59:24.058]  $ ...          : list()
[17:59:24.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.058]  - attr(*, "where")=List of 2
[17:59:24.058]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.058]   ..$ ...          :<environment: 0x6264a000e2c0> 
[17:59:24.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.058]  - attr(*, "resolved")= logi FALSE
[17:59:24.058]  - attr(*, "total_size")= num 1240
[17:59:24.064] Packages to be attached in all futures: [n=0] 
[17:59:24.064] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.064] Number of futures (= number of chunks): 1
[17:59:24.064] Launching 1 futures (chunks) ...
[17:59:24.065] Chunk #1 of 1 ...
[17:59:24.065]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.065] getGlobalsAndPackages() ...
[17:59:24.065] Searching for globals...
[17:59:24.066] 
[17:59:24.066] Searching for globals ... DONE
[17:59:24.067] - globals: [0] <none>
[17:59:24.067] getGlobalsAndPackages() ... DONE
[17:59:24.067]    + additional globals found: [n=0] 
[17:59:24.067]    + additional namespaces needed: [n=0] 
[17:59:24.067]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.068]  - seeds: <none>
[17:59:24.068]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.068] getGlobalsAndPackages() ...
[17:59:24.068] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.068] Resolving globals: FALSE
[17:59:24.069] Tweak future expression to call with '...' arguments ...
[17:59:24.069] {
[17:59:24.069]     do.call(function(...) {
[17:59:24.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.069]             on.exit(options(oopts), add = TRUE)
[17:59:24.069]         }
[17:59:24.069]         {
[17:59:24.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.069]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.069]             })
[17:59:24.069]         }
[17:59:24.069]     }, args = future.call.arguments)
[17:59:24.069] }
[17:59:24.069] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.070] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.070] 
[17:59:24.071] getGlobalsAndPackages() ... DONE
[17:59:24.071] run() for ‘Future’ ...
[17:59:24.071] - state: ‘created’
[17:59:24.072] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:24.072] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.073]   - Field: ‘label’
[17:59:24.073]   - Field: ‘local’
[17:59:24.073]   - Field: ‘owner’
[17:59:24.073]   - Field: ‘envir’
[17:59:24.073]   - Field: ‘packages’
[17:59:24.074]   - Field: ‘gc’
[17:59:24.074]   - Field: ‘conditions’
[17:59:24.074]   - Field: ‘expr’
[17:59:24.074]   - Field: ‘uuid’
[17:59:24.074]   - Field: ‘seed’
[17:59:24.075]   - Field: ‘version’
[17:59:24.075]   - Field: ‘result’
[17:59:24.075]   - Field: ‘asynchronous’
[17:59:24.075]   - Field: ‘calls’
[17:59:24.075]   - Field: ‘globals’
[17:59:24.075]   - Field: ‘stdout’
[17:59:24.076]   - Field: ‘earlySignal’
[17:59:24.076]   - Field: ‘lazy’
[17:59:24.076]   - Field: ‘state’
[17:59:24.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.076] - Launch lazy future ...
[17:59:24.077] Packages needed by the future expression (n = 0): <none>
[17:59:24.077] Packages needed by future strategies (n = 0): <none>
[17:59:24.078] {
[17:59:24.078]     {
[17:59:24.078]         {
[17:59:24.078]             ...future.startTime <- base::Sys.time()
[17:59:24.078]             {
[17:59:24.078]                 {
[17:59:24.078]                   {
[17:59:24.078]                     base::local({
[17:59:24.078]                       has_future <- base::requireNamespace("future", 
[17:59:24.078]                         quietly = TRUE)
[17:59:24.078]                       if (has_future) {
[17:59:24.078]                         ns <- base::getNamespace("future")
[17:59:24.078]                         version <- ns[[".package"]][["version"]]
[17:59:24.078]                         if (is.null(version)) 
[17:59:24.078]                           version <- utils::packageVersion("future")
[17:59:24.078]                       }
[17:59:24.078]                       else {
[17:59:24.078]                         version <- NULL
[17:59:24.078]                       }
[17:59:24.078]                       if (!has_future || version < "1.8.0") {
[17:59:24.078]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.078]                           "", base::R.version$version.string), 
[17:59:24.078]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.078]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.078]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.078]                             "release", "version")], collapse = " "), 
[17:59:24.078]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.078]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.078]                           info)
[17:59:24.078]                         info <- base::paste(info, collapse = "; ")
[17:59:24.078]                         if (!has_future) {
[17:59:24.078]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.078]                             info)
[17:59:24.078]                         }
[17:59:24.078]                         else {
[17:59:24.078]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.078]                             info, version)
[17:59:24.078]                         }
[17:59:24.078]                         base::stop(msg)
[17:59:24.078]                       }
[17:59:24.078]                     })
[17:59:24.078]                   }
[17:59:24.078]                   ...future.strategy.old <- future::plan("list")
[17:59:24.078]                   options(future.plan = NULL)
[17:59:24.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.078]                 }
[17:59:24.078]                 ...future.workdir <- getwd()
[17:59:24.078]             }
[17:59:24.078]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.078]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.078]         }
[17:59:24.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.078]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.078]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.078]             base::names(...future.oldOptions))
[17:59:24.078]     }
[17:59:24.078]     if (FALSE) {
[17:59:24.078]     }
[17:59:24.078]     else {
[17:59:24.078]         if (TRUE) {
[17:59:24.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.078]                 open = "w")
[17:59:24.078]         }
[17:59:24.078]         else {
[17:59:24.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.078]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.078]         }
[17:59:24.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.078]             base::sink(type = "output", split = FALSE)
[17:59:24.078]             base::close(...future.stdout)
[17:59:24.078]         }, add = TRUE)
[17:59:24.078]     }
[17:59:24.078]     ...future.frame <- base::sys.nframe()
[17:59:24.078]     ...future.conditions <- base::list()
[17:59:24.078]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.078]     if (FALSE) {
[17:59:24.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.078]     }
[17:59:24.078]     ...future.result <- base::tryCatch({
[17:59:24.078]         base::withCallingHandlers({
[17:59:24.078]             ...future.value <- base::withVisible(base::local({
[17:59:24.078]                 do.call(function(...) {
[17:59:24.078]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.078]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.078]                     ...future.globals.maxSize)) {
[17:59:24.078]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.078]                     on.exit(options(oopts), add = TRUE)
[17:59:24.078]                   }
[17:59:24.078]                   {
[17:59:24.078]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.078]                       FUN = function(jj) {
[17:59:24.078]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.078]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.078]                       })
[17:59:24.078]                   }
[17:59:24.078]                 }, args = future.call.arguments)
[17:59:24.078]             }))
[17:59:24.078]             future::FutureResult(value = ...future.value$value, 
[17:59:24.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.078]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.078]                     ...future.globalenv.names))
[17:59:24.078]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.078]         }, condition = base::local({
[17:59:24.078]             c <- base::c
[17:59:24.078]             inherits <- base::inherits
[17:59:24.078]             invokeRestart <- base::invokeRestart
[17:59:24.078]             length <- base::length
[17:59:24.078]             list <- base::list
[17:59:24.078]             seq.int <- base::seq.int
[17:59:24.078]             signalCondition <- base::signalCondition
[17:59:24.078]             sys.calls <- base::sys.calls
[17:59:24.078]             `[[` <- base::`[[`
[17:59:24.078]             `+` <- base::`+`
[17:59:24.078]             `<<-` <- base::`<<-`
[17:59:24.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.078]                   3L)]
[17:59:24.078]             }
[17:59:24.078]             function(cond) {
[17:59:24.078]                 is_error <- inherits(cond, "error")
[17:59:24.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.078]                   NULL)
[17:59:24.078]                 if (is_error) {
[17:59:24.078]                   sessionInformation <- function() {
[17:59:24.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.078]                       search = base::search(), system = base::Sys.info())
[17:59:24.078]                   }
[17:59:24.078]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.078]                     cond$call), session = sessionInformation(), 
[17:59:24.078]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.078]                   signalCondition(cond)
[17:59:24.078]                 }
[17:59:24.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.078]                 "immediateCondition"))) {
[17:59:24.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.078]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.078]                   if (TRUE && !signal) {
[17:59:24.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.078]                     {
[17:59:24.078]                       inherits <- base::inherits
[17:59:24.078]                       invokeRestart <- base::invokeRestart
[17:59:24.078]                       is.null <- base::is.null
[17:59:24.078]                       muffled <- FALSE
[17:59:24.078]                       if (inherits(cond, "message")) {
[17:59:24.078]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.078]                         if (muffled) 
[17:59:24.078]                           invokeRestart("muffleMessage")
[17:59:24.078]                       }
[17:59:24.078]                       else if (inherits(cond, "warning")) {
[17:59:24.078]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.078]                         if (muffled) 
[17:59:24.078]                           invokeRestart("muffleWarning")
[17:59:24.078]                       }
[17:59:24.078]                       else if (inherits(cond, "condition")) {
[17:59:24.078]                         if (!is.null(pattern)) {
[17:59:24.078]                           computeRestarts <- base::computeRestarts
[17:59:24.078]                           grepl <- base::grepl
[17:59:24.078]                           restarts <- computeRestarts(cond)
[17:59:24.078]                           for (restart in restarts) {
[17:59:24.078]                             name <- restart$name
[17:59:24.078]                             if (is.null(name)) 
[17:59:24.078]                               next
[17:59:24.078]                             if (!grepl(pattern, name)) 
[17:59:24.078]                               next
[17:59:24.078]                             invokeRestart(restart)
[17:59:24.078]                             muffled <- TRUE
[17:59:24.078]                             break
[17:59:24.078]                           }
[17:59:24.078]                         }
[17:59:24.078]                       }
[17:59:24.078]                       invisible(muffled)
[17:59:24.078]                     }
[17:59:24.078]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.078]                   }
[17:59:24.078]                 }
[17:59:24.078]                 else {
[17:59:24.078]                   if (TRUE) {
[17:59:24.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.078]                     {
[17:59:24.078]                       inherits <- base::inherits
[17:59:24.078]                       invokeRestart <- base::invokeRestart
[17:59:24.078]                       is.null <- base::is.null
[17:59:24.078]                       muffled <- FALSE
[17:59:24.078]                       if (inherits(cond, "message")) {
[17:59:24.078]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.078]                         if (muffled) 
[17:59:24.078]                           invokeRestart("muffleMessage")
[17:59:24.078]                       }
[17:59:24.078]                       else if (inherits(cond, "warning")) {
[17:59:24.078]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.078]                         if (muffled) 
[17:59:24.078]                           invokeRestart("muffleWarning")
[17:59:24.078]                       }
[17:59:24.078]                       else if (inherits(cond, "condition")) {
[17:59:24.078]                         if (!is.null(pattern)) {
[17:59:24.078]                           computeRestarts <- base::computeRestarts
[17:59:24.078]                           grepl <- base::grepl
[17:59:24.078]                           restarts <- computeRestarts(cond)
[17:59:24.078]                           for (restart in restarts) {
[17:59:24.078]                             name <- restart$name
[17:59:24.078]                             if (is.null(name)) 
[17:59:24.078]                               next
[17:59:24.078]                             if (!grepl(pattern, name)) 
[17:59:24.078]                               next
[17:59:24.078]                             invokeRestart(restart)
[17:59:24.078]                             muffled <- TRUE
[17:59:24.078]                             break
[17:59:24.078]                           }
[17:59:24.078]                         }
[17:59:24.078]                       }
[17:59:24.078]                       invisible(muffled)
[17:59:24.078]                     }
[17:59:24.078]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.078]                   }
[17:59:24.078]                 }
[17:59:24.078]             }
[17:59:24.078]         }))
[17:59:24.078]     }, error = function(ex) {
[17:59:24.078]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.078]                 ...future.rng), started = ...future.startTime, 
[17:59:24.078]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.078]             version = "1.8"), class = "FutureResult")
[17:59:24.078]     }, finally = {
[17:59:24.078]         if (!identical(...future.workdir, getwd())) 
[17:59:24.078]             setwd(...future.workdir)
[17:59:24.078]         {
[17:59:24.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.078]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.078]             }
[17:59:24.078]             base::options(...future.oldOptions)
[17:59:24.078]             if (.Platform$OS.type == "windows") {
[17:59:24.078]                 old_names <- names(...future.oldEnvVars)
[17:59:24.078]                 envs <- base::Sys.getenv()
[17:59:24.078]                 names <- names(envs)
[17:59:24.078]                 common <- intersect(names, old_names)
[17:59:24.078]                 added <- setdiff(names, old_names)
[17:59:24.078]                 removed <- setdiff(old_names, names)
[17:59:24.078]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.078]                   envs[common]]
[17:59:24.078]                 NAMES <- toupper(changed)
[17:59:24.078]                 args <- list()
[17:59:24.078]                 for (kk in seq_along(NAMES)) {
[17:59:24.078]                   name <- changed[[kk]]
[17:59:24.078]                   NAME <- NAMES[[kk]]
[17:59:24.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.078]                     next
[17:59:24.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.078]                 }
[17:59:24.078]                 NAMES <- toupper(added)
[17:59:24.078]                 for (kk in seq_along(NAMES)) {
[17:59:24.078]                   name <- added[[kk]]
[17:59:24.078]                   NAME <- NAMES[[kk]]
[17:59:24.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.078]                     next
[17:59:24.078]                   args[[name]] <- ""
[17:59:24.078]                 }
[17:59:24.078]                 NAMES <- toupper(removed)
[17:59:24.078]                 for (kk in seq_along(NAMES)) {
[17:59:24.078]                   name <- removed[[kk]]
[17:59:24.078]                   NAME <- NAMES[[kk]]
[17:59:24.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.078]                     next
[17:59:24.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.078]                 }
[17:59:24.078]                 if (length(args) > 0) 
[17:59:24.078]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.078]             }
[17:59:24.078]             else {
[17:59:24.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.078]             }
[17:59:24.078]             {
[17:59:24.078]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.078]                   0L) {
[17:59:24.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.078]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.078]                   base::options(opts)
[17:59:24.078]                 }
[17:59:24.078]                 {
[17:59:24.078]                   {
[17:59:24.078]                     NULL
[17:59:24.078]                     RNGkind("Mersenne-Twister")
[17:59:24.078]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.078]                       inherits = FALSE)
[17:59:24.078]                   }
[17:59:24.078]                   options(future.plan = NULL)
[17:59:24.078]                   if (is.na(NA_character_)) 
[17:59:24.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.078]                     .init = FALSE)
[17:59:24.078]                 }
[17:59:24.078]             }
[17:59:24.078]         }
[17:59:24.078]     })
[17:59:24.078]     if (TRUE) {
[17:59:24.078]         base::sink(type = "output", split = FALSE)
[17:59:24.078]         if (TRUE) {
[17:59:24.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.078]         }
[17:59:24.078]         else {
[17:59:24.078]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.078]         }
[17:59:24.078]         base::close(...future.stdout)
[17:59:24.078]         ...future.stdout <- NULL
[17:59:24.078]     }
[17:59:24.078]     ...future.result$conditions <- ...future.conditions
[17:59:24.078]     ...future.result$finished <- base::Sys.time()
[17:59:24.078]     ...future.result
[17:59:24.078] }
[17:59:24.081] assign_globals() ...
[17:59:24.081] List of 5
[17:59:24.081]  $ ...future.FUN            :function (object, ...)  
[17:59:24.081]  $ future.call.arguments    : list()
[17:59:24.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.081]  $ ...future.elements_ii    :List of 3
[17:59:24.081]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.081]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.081]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.081]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.081]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.081]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.081]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.081]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:24.081]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.081]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.081]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.081]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:24.081]  $ ...future.seeds_ii       : NULL
[17:59:24.081]  $ ...future.globals.maxSize: NULL
[17:59:24.081]  - attr(*, "where")=List of 5
[17:59:24.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.081]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.081]  - attr(*, "resolved")= logi FALSE
[17:59:24.081]  - attr(*, "total_size")= num 1240
[17:59:24.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.081]  - attr(*, "already-done")= logi TRUE
[17:59:24.100] - copied ‘...future.FUN’ to environment
[17:59:24.101] - copied ‘future.call.arguments’ to environment
[17:59:24.101] - copied ‘...future.elements_ii’ to environment
[17:59:24.101] - copied ‘...future.seeds_ii’ to environment
[17:59:24.101] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.102] assign_globals() ... done
[17:59:24.102] plan(): Setting new future strategy stack:
[17:59:24.102] List of future strategies:
[17:59:24.102] 1. sequential:
[17:59:24.102]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.102]    - tweaked: FALSE
[17:59:24.102]    - call: NULL
[17:59:24.103] plan(): nbrOfWorkers() = 1
[17:59:24.108] plan(): Setting new future strategy stack:
[17:59:24.108] List of future strategies:
[17:59:24.108] 1. sequential:
[17:59:24.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.108]    - tweaked: FALSE
[17:59:24.108]    - call: plan(strategy)
[17:59:24.109] plan(): nbrOfWorkers() = 1
[17:59:24.109] SequentialFuture started (and completed)
[17:59:24.109] - Launch lazy future ... done
[17:59:24.109] run() for ‘SequentialFuture’ ... done
[17:59:24.110] Created future:
[17:59:24.110] SequentialFuture:
[17:59:24.110] Label: ‘future_by-1’
[17:59:24.110] Expression:
[17:59:24.110] {
[17:59:24.110]     do.call(function(...) {
[17:59:24.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.110]             on.exit(options(oopts), add = TRUE)
[17:59:24.110]         }
[17:59:24.110]         {
[17:59:24.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.110]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.110]             })
[17:59:24.110]         }
[17:59:24.110]     }, args = future.call.arguments)
[17:59:24.110] }
[17:59:24.110] Lazy evaluation: FALSE
[17:59:24.110] Asynchronous evaluation: FALSE
[17:59:24.110] Local evaluation: TRUE
[17:59:24.110] Environment: 0x62649ffa7fb0
[17:59:24.110] Capture standard output: TRUE
[17:59:24.110] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.110] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.110] Packages: <none>
[17:59:24.110] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.110] Resolved: TRUE
[17:59:24.110] Value: 5.37 KiB of class ‘list’
[17:59:24.110] Early signaling: FALSE
[17:59:24.110] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.110] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.113] Chunk #1 of 1 ... DONE
[17:59:24.113] Launching 1 futures (chunks) ... DONE
[17:59:24.113] Resolving 1 futures (chunks) ...
[17:59:24.113] resolve() on list ...
[17:59:24.113]  recursive: 0
[17:59:24.114]  length: 1
[17:59:24.114] 
[17:59:24.114] resolved() for ‘SequentialFuture’ ...
[17:59:24.114] - state: ‘finished’
[17:59:24.114] - run: TRUE
[17:59:24.115] - result: ‘FutureResult’
[17:59:24.115] resolved() for ‘SequentialFuture’ ... done
[17:59:24.115] Future #1
[17:59:24.115] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.115] - nx: 1
[17:59:24.116] - relay: TRUE
[17:59:24.116] - stdout: TRUE
[17:59:24.116] - signal: TRUE
[17:59:24.116] - resignal: FALSE
[17:59:24.116] - force: TRUE
[17:59:24.116] - relayed: [n=1] FALSE
[17:59:24.117] - queued futures: [n=1] FALSE
[17:59:24.117]  - until=1
[17:59:24.117]  - relaying element #1
[17:59:24.117] - relayed: [n=1] TRUE
[17:59:24.118] - queued futures: [n=1] TRUE
[17:59:24.118] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.118]  length: 0 (resolved future 1)
[17:59:24.118] Relaying remaining futures
[17:59:24.118] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.119] - nx: 1
[17:59:24.119] - relay: TRUE
[17:59:24.119] - stdout: TRUE
[17:59:24.119] - signal: TRUE
[17:59:24.119] - resignal: FALSE
[17:59:24.119] - force: TRUE
[17:59:24.120] - relayed: [n=1] TRUE
[17:59:24.120] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.120] - relayed: [n=1] TRUE
[17:59:24.120] - queued futures: [n=1] TRUE
[17:59:24.120] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.121] resolve() on list ... DONE
[17:59:24.121]  - Number of value chunks collected: 1
[17:59:24.121] Resolving 1 futures (chunks) ... DONE
[17:59:24.121] Reducing values from 1 chunks ...
[17:59:24.121]  - Number of values collected after concatenation: 3
[17:59:24.122]  - Number of values expected: 3
[17:59:24.122] Reducing values from 1 chunks ... DONE
[17:59:24.122] future_lapply() ... DONE
[17:59:24.122] future_by_internal() ... DONE
[17:59:24.126] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:59:24.127] future_lapply() ...
[17:59:24.128] Number of chunks: 1
[17:59:24.128] getGlobalsAndPackagesXApply() ...
[17:59:24.129]  - future.globals: TRUE
[17:59:24.129] getGlobalsAndPackages() ...
[17:59:24.129] Searching for globals...
[17:59:24.131] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.131] Searching for globals ... DONE
[17:59:24.131] Resolving globals: FALSE
[17:59:24.132] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.133] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.133] - globals: [1] ‘FUN’
[17:59:24.133] 
[17:59:24.133] getGlobalsAndPackages() ... DONE
[17:59:24.134]  - globals found/used: [n=1] ‘FUN’
[17:59:24.134]  - needed namespaces: [n=0] 
[17:59:24.134] Finding globals ... DONE
[17:59:24.134]  - use_args: TRUE
[17:59:24.134]  - Getting '...' globals ...
[17:59:24.137] resolve() on list ...
[17:59:24.138]  recursive: 0
[17:59:24.138]  length: 1
[17:59:24.138]  elements: ‘...’
[17:59:24.138]  length: 0 (resolved future 1)
[17:59:24.138] resolve() on list ... DONE
[17:59:24.139]    - '...' content: [n=0] 
[17:59:24.139] List of 1
[17:59:24.139]  $ ...: list()
[17:59:24.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.139]  - attr(*, "where")=List of 1
[17:59:24.139]   ..$ ...:<environment: 0x62649ff63f68> 
[17:59:24.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.139]  - attr(*, "resolved")= logi TRUE
[17:59:24.139]  - attr(*, "total_size")= num NA
[17:59:24.144]  - Getting '...' globals ... DONE
[17:59:24.145] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.145] List of 2
[17:59:24.145]  $ ...future.FUN:function (object, ...)  
[17:59:24.145]  $ ...          : list()
[17:59:24.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.145]  - attr(*, "where")=List of 2
[17:59:24.145]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.145]   ..$ ...          :<environment: 0x62649ff63f68> 
[17:59:24.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.145]  - attr(*, "resolved")= logi FALSE
[17:59:24.145]  - attr(*, "total_size")= num 1240
[17:59:24.150] Packages to be attached in all futures: [n=0] 
[17:59:24.150] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.151] Number of futures (= number of chunks): 1
[17:59:24.151] Launching 1 futures (chunks) ...
[17:59:24.151] Chunk #1 of 1 ...
[17:59:24.151]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.152] getGlobalsAndPackages() ...
[17:59:24.152] Searching for globals...
[17:59:24.153] 
[17:59:24.153] Searching for globals ... DONE
[17:59:24.153] - globals: [0] <none>
[17:59:24.153] getGlobalsAndPackages() ... DONE
[17:59:24.154]    + additional globals found: [n=0] 
[17:59:24.154]    + additional namespaces needed: [n=0] 
[17:59:24.154]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.154]  - seeds: <none>
[17:59:24.154]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.155] getGlobalsAndPackages() ...
[17:59:24.155] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.155] Resolving globals: FALSE
[17:59:24.155] Tweak future expression to call with '...' arguments ...
[17:59:24.156] {
[17:59:24.156]     do.call(function(...) {
[17:59:24.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.156]             on.exit(options(oopts), add = TRUE)
[17:59:24.156]         }
[17:59:24.156]         {
[17:59:24.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.156]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.156]             })
[17:59:24.156]         }
[17:59:24.156]     }, args = future.call.arguments)
[17:59:24.156] }
[17:59:24.156] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.157] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.157] 
[17:59:24.157] getGlobalsAndPackages() ... DONE
[17:59:24.158] run() for ‘Future’ ...
[17:59:24.158] - state: ‘created’
[17:59:24.158] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:24.159] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.159]   - Field: ‘label’
[17:59:24.159]   - Field: ‘local’
[17:59:24.160]   - Field: ‘owner’
[17:59:24.160]   - Field: ‘envir’
[17:59:24.160]   - Field: ‘packages’
[17:59:24.160]   - Field: ‘gc’
[17:59:24.160]   - Field: ‘conditions’
[17:59:24.160]   - Field: ‘expr’
[17:59:24.161]   - Field: ‘uuid’
[17:59:24.161]   - Field: ‘seed’
[17:59:24.161]   - Field: ‘version’
[17:59:24.161]   - Field: ‘result’
[17:59:24.161]   - Field: ‘asynchronous’
[17:59:24.162]   - Field: ‘calls’
[17:59:24.162]   - Field: ‘globals’
[17:59:24.162]   - Field: ‘stdout’
[17:59:24.162]   - Field: ‘earlySignal’
[17:59:24.162]   - Field: ‘lazy’
[17:59:24.163]   - Field: ‘state’
[17:59:24.163] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.163] - Launch lazy future ...
[17:59:24.163] Packages needed by the future expression (n = 0): <none>
[17:59:24.164] Packages needed by future strategies (n = 0): <none>
[17:59:24.164] {
[17:59:24.164]     {
[17:59:24.164]         {
[17:59:24.164]             ...future.startTime <- base::Sys.time()
[17:59:24.164]             {
[17:59:24.164]                 {
[17:59:24.164]                   {
[17:59:24.164]                     base::local({
[17:59:24.164]                       has_future <- base::requireNamespace("future", 
[17:59:24.164]                         quietly = TRUE)
[17:59:24.164]                       if (has_future) {
[17:59:24.164]                         ns <- base::getNamespace("future")
[17:59:24.164]                         version <- ns[[".package"]][["version"]]
[17:59:24.164]                         if (is.null(version)) 
[17:59:24.164]                           version <- utils::packageVersion("future")
[17:59:24.164]                       }
[17:59:24.164]                       else {
[17:59:24.164]                         version <- NULL
[17:59:24.164]                       }
[17:59:24.164]                       if (!has_future || version < "1.8.0") {
[17:59:24.164]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.164]                           "", base::R.version$version.string), 
[17:59:24.164]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.164]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.164]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.164]                             "release", "version")], collapse = " "), 
[17:59:24.164]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.164]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.164]                           info)
[17:59:24.164]                         info <- base::paste(info, collapse = "; ")
[17:59:24.164]                         if (!has_future) {
[17:59:24.164]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.164]                             info)
[17:59:24.164]                         }
[17:59:24.164]                         else {
[17:59:24.164]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.164]                             info, version)
[17:59:24.164]                         }
[17:59:24.164]                         base::stop(msg)
[17:59:24.164]                       }
[17:59:24.164]                     })
[17:59:24.164]                   }
[17:59:24.164]                   ...future.strategy.old <- future::plan("list")
[17:59:24.164]                   options(future.plan = NULL)
[17:59:24.164]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.164]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.164]                 }
[17:59:24.164]                 ...future.workdir <- getwd()
[17:59:24.164]             }
[17:59:24.164]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.164]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.164]         }
[17:59:24.164]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.164]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.164]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.164]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.164]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.164]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.164]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.164]             base::names(...future.oldOptions))
[17:59:24.164]     }
[17:59:24.164]     if (FALSE) {
[17:59:24.164]     }
[17:59:24.164]     else {
[17:59:24.164]         if (TRUE) {
[17:59:24.164]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.164]                 open = "w")
[17:59:24.164]         }
[17:59:24.164]         else {
[17:59:24.164]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.164]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.164]         }
[17:59:24.164]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.164]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.164]             base::sink(type = "output", split = FALSE)
[17:59:24.164]             base::close(...future.stdout)
[17:59:24.164]         }, add = TRUE)
[17:59:24.164]     }
[17:59:24.164]     ...future.frame <- base::sys.nframe()
[17:59:24.164]     ...future.conditions <- base::list()
[17:59:24.164]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.164]     if (FALSE) {
[17:59:24.164]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.164]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.164]     }
[17:59:24.164]     ...future.result <- base::tryCatch({
[17:59:24.164]         base::withCallingHandlers({
[17:59:24.164]             ...future.value <- base::withVisible(base::local({
[17:59:24.164]                 do.call(function(...) {
[17:59:24.164]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.164]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.164]                     ...future.globals.maxSize)) {
[17:59:24.164]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.164]                     on.exit(options(oopts), add = TRUE)
[17:59:24.164]                   }
[17:59:24.164]                   {
[17:59:24.164]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.164]                       FUN = function(jj) {
[17:59:24.164]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.164]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.164]                       })
[17:59:24.164]                   }
[17:59:24.164]                 }, args = future.call.arguments)
[17:59:24.164]             }))
[17:59:24.164]             future::FutureResult(value = ...future.value$value, 
[17:59:24.164]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.164]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.164]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.164]                     ...future.globalenv.names))
[17:59:24.164]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.164]         }, condition = base::local({
[17:59:24.164]             c <- base::c
[17:59:24.164]             inherits <- base::inherits
[17:59:24.164]             invokeRestart <- base::invokeRestart
[17:59:24.164]             length <- base::length
[17:59:24.164]             list <- base::list
[17:59:24.164]             seq.int <- base::seq.int
[17:59:24.164]             signalCondition <- base::signalCondition
[17:59:24.164]             sys.calls <- base::sys.calls
[17:59:24.164]             `[[` <- base::`[[`
[17:59:24.164]             `+` <- base::`+`
[17:59:24.164]             `<<-` <- base::`<<-`
[17:59:24.164]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.164]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.164]                   3L)]
[17:59:24.164]             }
[17:59:24.164]             function(cond) {
[17:59:24.164]                 is_error <- inherits(cond, "error")
[17:59:24.164]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.164]                   NULL)
[17:59:24.164]                 if (is_error) {
[17:59:24.164]                   sessionInformation <- function() {
[17:59:24.164]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.164]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.164]                       search = base::search(), system = base::Sys.info())
[17:59:24.164]                   }
[17:59:24.164]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.164]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.164]                     cond$call), session = sessionInformation(), 
[17:59:24.164]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.164]                   signalCondition(cond)
[17:59:24.164]                 }
[17:59:24.164]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.164]                 "immediateCondition"))) {
[17:59:24.164]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.164]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.164]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.164]                   if (TRUE && !signal) {
[17:59:24.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.164]                     {
[17:59:24.164]                       inherits <- base::inherits
[17:59:24.164]                       invokeRestart <- base::invokeRestart
[17:59:24.164]                       is.null <- base::is.null
[17:59:24.164]                       muffled <- FALSE
[17:59:24.164]                       if (inherits(cond, "message")) {
[17:59:24.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.164]                         if (muffled) 
[17:59:24.164]                           invokeRestart("muffleMessage")
[17:59:24.164]                       }
[17:59:24.164]                       else if (inherits(cond, "warning")) {
[17:59:24.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.164]                         if (muffled) 
[17:59:24.164]                           invokeRestart("muffleWarning")
[17:59:24.164]                       }
[17:59:24.164]                       else if (inherits(cond, "condition")) {
[17:59:24.164]                         if (!is.null(pattern)) {
[17:59:24.164]                           computeRestarts <- base::computeRestarts
[17:59:24.164]                           grepl <- base::grepl
[17:59:24.164]                           restarts <- computeRestarts(cond)
[17:59:24.164]                           for (restart in restarts) {
[17:59:24.164]                             name <- restart$name
[17:59:24.164]                             if (is.null(name)) 
[17:59:24.164]                               next
[17:59:24.164]                             if (!grepl(pattern, name)) 
[17:59:24.164]                               next
[17:59:24.164]                             invokeRestart(restart)
[17:59:24.164]                             muffled <- TRUE
[17:59:24.164]                             break
[17:59:24.164]                           }
[17:59:24.164]                         }
[17:59:24.164]                       }
[17:59:24.164]                       invisible(muffled)
[17:59:24.164]                     }
[17:59:24.164]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.164]                   }
[17:59:24.164]                 }
[17:59:24.164]                 else {
[17:59:24.164]                   if (TRUE) {
[17:59:24.164]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.164]                     {
[17:59:24.164]                       inherits <- base::inherits
[17:59:24.164]                       invokeRestart <- base::invokeRestart
[17:59:24.164]                       is.null <- base::is.null
[17:59:24.164]                       muffled <- FALSE
[17:59:24.164]                       if (inherits(cond, "message")) {
[17:59:24.164]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.164]                         if (muffled) 
[17:59:24.164]                           invokeRestart("muffleMessage")
[17:59:24.164]                       }
[17:59:24.164]                       else if (inherits(cond, "warning")) {
[17:59:24.164]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.164]                         if (muffled) 
[17:59:24.164]                           invokeRestart("muffleWarning")
[17:59:24.164]                       }
[17:59:24.164]                       else if (inherits(cond, "condition")) {
[17:59:24.164]                         if (!is.null(pattern)) {
[17:59:24.164]                           computeRestarts <- base::computeRestarts
[17:59:24.164]                           grepl <- base::grepl
[17:59:24.164]                           restarts <- computeRestarts(cond)
[17:59:24.164]                           for (restart in restarts) {
[17:59:24.164]                             name <- restart$name
[17:59:24.164]                             if (is.null(name)) 
[17:59:24.164]                               next
[17:59:24.164]                             if (!grepl(pattern, name)) 
[17:59:24.164]                               next
[17:59:24.164]                             invokeRestart(restart)
[17:59:24.164]                             muffled <- TRUE
[17:59:24.164]                             break
[17:59:24.164]                           }
[17:59:24.164]                         }
[17:59:24.164]                       }
[17:59:24.164]                       invisible(muffled)
[17:59:24.164]                     }
[17:59:24.164]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.164]                   }
[17:59:24.164]                 }
[17:59:24.164]             }
[17:59:24.164]         }))
[17:59:24.164]     }, error = function(ex) {
[17:59:24.164]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.164]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.164]                 ...future.rng), started = ...future.startTime, 
[17:59:24.164]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.164]             version = "1.8"), class = "FutureResult")
[17:59:24.164]     }, finally = {
[17:59:24.164]         if (!identical(...future.workdir, getwd())) 
[17:59:24.164]             setwd(...future.workdir)
[17:59:24.164]         {
[17:59:24.164]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.164]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.164]             }
[17:59:24.164]             base::options(...future.oldOptions)
[17:59:24.164]             if (.Platform$OS.type == "windows") {
[17:59:24.164]                 old_names <- names(...future.oldEnvVars)
[17:59:24.164]                 envs <- base::Sys.getenv()
[17:59:24.164]                 names <- names(envs)
[17:59:24.164]                 common <- intersect(names, old_names)
[17:59:24.164]                 added <- setdiff(names, old_names)
[17:59:24.164]                 removed <- setdiff(old_names, names)
[17:59:24.164]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.164]                   envs[common]]
[17:59:24.164]                 NAMES <- toupper(changed)
[17:59:24.164]                 args <- list()
[17:59:24.164]                 for (kk in seq_along(NAMES)) {
[17:59:24.164]                   name <- changed[[kk]]
[17:59:24.164]                   NAME <- NAMES[[kk]]
[17:59:24.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.164]                     next
[17:59:24.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.164]                 }
[17:59:24.164]                 NAMES <- toupper(added)
[17:59:24.164]                 for (kk in seq_along(NAMES)) {
[17:59:24.164]                   name <- added[[kk]]
[17:59:24.164]                   NAME <- NAMES[[kk]]
[17:59:24.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.164]                     next
[17:59:24.164]                   args[[name]] <- ""
[17:59:24.164]                 }
[17:59:24.164]                 NAMES <- toupper(removed)
[17:59:24.164]                 for (kk in seq_along(NAMES)) {
[17:59:24.164]                   name <- removed[[kk]]
[17:59:24.164]                   NAME <- NAMES[[kk]]
[17:59:24.164]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.164]                     next
[17:59:24.164]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.164]                 }
[17:59:24.164]                 if (length(args) > 0) 
[17:59:24.164]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.164]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.164]             }
[17:59:24.164]             else {
[17:59:24.164]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.164]             }
[17:59:24.164]             {
[17:59:24.164]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.164]                   0L) {
[17:59:24.164]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.164]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.164]                   base::options(opts)
[17:59:24.164]                 }
[17:59:24.164]                 {
[17:59:24.164]                   {
[17:59:24.164]                     NULL
[17:59:24.164]                     RNGkind("Mersenne-Twister")
[17:59:24.164]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.164]                       inherits = FALSE)
[17:59:24.164]                   }
[17:59:24.164]                   options(future.plan = NULL)
[17:59:24.164]                   if (is.na(NA_character_)) 
[17:59:24.164]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.164]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.164]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.164]                     .init = FALSE)
[17:59:24.164]                 }
[17:59:24.164]             }
[17:59:24.164]         }
[17:59:24.164]     })
[17:59:24.164]     if (TRUE) {
[17:59:24.164]         base::sink(type = "output", split = FALSE)
[17:59:24.164]         if (TRUE) {
[17:59:24.164]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.164]         }
[17:59:24.164]         else {
[17:59:24.164]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.164]         }
[17:59:24.164]         base::close(...future.stdout)
[17:59:24.164]         ...future.stdout <- NULL
[17:59:24.164]     }
[17:59:24.164]     ...future.result$conditions <- ...future.conditions
[17:59:24.164]     ...future.result$finished <- base::Sys.time()
[17:59:24.164]     ...future.result
[17:59:24.164] }
[17:59:24.168] assign_globals() ...
[17:59:24.168] List of 5
[17:59:24.168]  $ ...future.FUN            :function (object, ...)  
[17:59:24.168]  $ future.call.arguments    : list()
[17:59:24.168]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.168]  $ ...future.elements_ii    :List of 3
[17:59:24.168]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.168]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.168]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.168]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.168]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.168]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.168]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.168]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:24.168]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.168]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.168]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.168]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:24.168]  $ ...future.seeds_ii       : NULL
[17:59:24.168]  $ ...future.globals.maxSize: NULL
[17:59:24.168]  - attr(*, "where")=List of 5
[17:59:24.168]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.168]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.168]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.168]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.168]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.168]  - attr(*, "resolved")= logi FALSE
[17:59:24.168]  - attr(*, "total_size")= num 1240
[17:59:24.168]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.168]  - attr(*, "already-done")= logi TRUE
[17:59:24.187] - copied ‘...future.FUN’ to environment
[17:59:24.187] - copied ‘future.call.arguments’ to environment
[17:59:24.187] - copied ‘...future.elements_ii’ to environment
[17:59:24.188] - copied ‘...future.seeds_ii’ to environment
[17:59:24.188] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.188] assign_globals() ... done
[17:59:24.189] plan(): Setting new future strategy stack:
[17:59:24.189] List of future strategies:
[17:59:24.189] 1. sequential:
[17:59:24.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.189]    - tweaked: FALSE
[17:59:24.189]    - call: NULL
[17:59:24.190] plan(): nbrOfWorkers() = 1
[17:59:24.194] plan(): Setting new future strategy stack:
[17:59:24.194] List of future strategies:
[17:59:24.194] 1. sequential:
[17:59:24.194]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.194]    - tweaked: FALSE
[17:59:24.194]    - call: plan(strategy)
[17:59:24.195] plan(): nbrOfWorkers() = 1
[17:59:24.196] SequentialFuture started (and completed)
[17:59:24.196] - Launch lazy future ... done
[17:59:24.196] run() for ‘SequentialFuture’ ... done
[17:59:24.196] Created future:
[17:59:24.196] SequentialFuture:
[17:59:24.196] Label: ‘future_by-1’
[17:59:24.196] Expression:
[17:59:24.196] {
[17:59:24.196]     do.call(function(...) {
[17:59:24.196]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.196]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.196]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.196]             on.exit(options(oopts), add = TRUE)
[17:59:24.196]         }
[17:59:24.196]         {
[17:59:24.196]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.196]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.196]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.196]             })
[17:59:24.196]         }
[17:59:24.196]     }, args = future.call.arguments)
[17:59:24.196] }
[17:59:24.196] Lazy evaluation: FALSE
[17:59:24.196] Asynchronous evaluation: FALSE
[17:59:24.196] Local evaluation: TRUE
[17:59:24.196] Environment: 0x62649fe0db20
[17:59:24.196] Capture standard output: TRUE
[17:59:24.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.196] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.196] Packages: <none>
[17:59:24.196] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.196] Resolved: TRUE
[17:59:24.196] Value: 5.37 KiB of class ‘list’
[17:59:24.196] Early signaling: FALSE
[17:59:24.196] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.196] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.199] Chunk #1 of 1 ... DONE
[17:59:24.199] Launching 1 futures (chunks) ... DONE
[17:59:24.199] Resolving 1 futures (chunks) ...
[17:59:24.200] resolve() on list ...
[17:59:24.200]  recursive: 0
[17:59:24.200]  length: 1
[17:59:24.200] 
[17:59:24.200] resolved() for ‘SequentialFuture’ ...
[17:59:24.201] - state: ‘finished’
[17:59:24.201] - run: TRUE
[17:59:24.201] - result: ‘FutureResult’
[17:59:24.201] resolved() for ‘SequentialFuture’ ... done
[17:59:24.202] Future #1
[17:59:24.202] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.202] - nx: 1
[17:59:24.202] - relay: TRUE
[17:59:24.202] - stdout: TRUE
[17:59:24.203] - signal: TRUE
[17:59:24.203] - resignal: FALSE
[17:59:24.203] - force: TRUE
[17:59:24.203] - relayed: [n=1] FALSE
[17:59:24.203] - queued futures: [n=1] FALSE
[17:59:24.203]  - until=1
[17:59:24.204]  - relaying element #1
[17:59:24.204] - relayed: [n=1] TRUE
[17:59:24.204] - queued futures: [n=1] TRUE
[17:59:24.204] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.205]  length: 0 (resolved future 1)
[17:59:24.205] Relaying remaining futures
[17:59:24.205] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.205] - nx: 1
[17:59:24.205] - relay: TRUE
[17:59:24.206] - stdout: TRUE
[17:59:24.206] - signal: TRUE
[17:59:24.206] - resignal: FALSE
[17:59:24.206] - force: TRUE
[17:59:24.206] - relayed: [n=1] TRUE
[17:59:24.206] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.207] - relayed: [n=1] TRUE
[17:59:24.207] - queued futures: [n=1] TRUE
[17:59:24.207] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.207] resolve() on list ... DONE
[17:59:24.208]  - Number of value chunks collected: 1
[17:59:24.208] Resolving 1 futures (chunks) ... DONE
[17:59:24.208] Reducing values from 1 chunks ...
[17:59:24.208]  - Number of values collected after concatenation: 3
[17:59:24.208]  - Number of values expected: 3
[17:59:24.208] Reducing values from 1 chunks ... DONE
[17:59:24.209] future_lapply() ... DONE
[17:59:24.209] future_by_internal() ... DONE
[17:59:24.211] future_by_internal() ...
- plan('multicore') ...
[17:59:24.212] plan(): Setting new future strategy stack:
[17:59:24.212] List of future strategies:
[17:59:24.212] 1. multicore:
[17:59:24.212]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.212]    - tweaked: FALSE
[17:59:24.212]    - call: plan(strategy)
[17:59:24.219] plan(): nbrOfWorkers() = 1
[17:59:24.219] future_by_internal() ...
[17:59:24.220] future_lapply() ...
[17:59:24.226] Number of chunks: 1
[17:59:24.226] getGlobalsAndPackagesXApply() ...
[17:59:24.226]  - future.globals: TRUE
[17:59:24.226] getGlobalsAndPackages() ...
[17:59:24.227] Searching for globals...
[17:59:24.229] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.229] Searching for globals ... DONE
[17:59:24.229] Resolving globals: FALSE
[17:59:24.232] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.233] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.233] - globals: [1] ‘FUN’
[17:59:24.233] 
[17:59:24.234] getGlobalsAndPackages() ... DONE
[17:59:24.234]  - globals found/used: [n=1] ‘FUN’
[17:59:24.234]  - needed namespaces: [n=0] 
[17:59:24.234] Finding globals ... DONE
[17:59:24.234]  - use_args: TRUE
[17:59:24.235]  - Getting '...' globals ...
[17:59:24.235] resolve() on list ...
[17:59:24.235]  recursive: 0
[17:59:24.236]  length: 1
[17:59:24.236]  elements: ‘...’
[17:59:24.236]  length: 0 (resolved future 1)
[17:59:24.236] resolve() on list ... DONE
[17:59:24.236]    - '...' content: [n=0] 
[17:59:24.237] List of 1
[17:59:24.237]  $ ...: list()
[17:59:24.237]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.237]  - attr(*, "where")=List of 1
[17:59:24.237]   ..$ ...:<environment: 0x62649ff7ab10> 
[17:59:24.237]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.237]  - attr(*, "resolved")= logi TRUE
[17:59:24.237]  - attr(*, "total_size")= num NA
[17:59:24.242]  - Getting '...' globals ... DONE
[17:59:24.242] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.242] List of 2
[17:59:24.242]  $ ...future.FUN:function (object, ...)  
[17:59:24.242]  $ ...          : list()
[17:59:24.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.242]  - attr(*, "where")=List of 2
[17:59:24.242]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.242]   ..$ ...          :<environment: 0x62649ff7ab10> 
[17:59:24.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.242]  - attr(*, "resolved")= logi FALSE
[17:59:24.242]  - attr(*, "total_size")= num 1240
[17:59:24.248] Packages to be attached in all futures: [n=0] 
[17:59:24.248] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.248] Number of futures (= number of chunks): 1
[17:59:24.248] Launching 1 futures (chunks) ...
[17:59:24.249] Chunk #1 of 1 ...
[17:59:24.249]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.249] getGlobalsAndPackages() ...
[17:59:24.249] Searching for globals...
[17:59:24.250] 
[17:59:24.250] Searching for globals ... DONE
[17:59:24.251] - globals: [0] <none>
[17:59:24.251] getGlobalsAndPackages() ... DONE
[17:59:24.251]    + additional globals found: [n=0] 
[17:59:24.251]    + additional namespaces needed: [n=0] 
[17:59:24.251]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.252]  - seeds: <none>
[17:59:24.252]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.252] getGlobalsAndPackages() ...
[17:59:24.252] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.252] Resolving globals: FALSE
[17:59:24.253] Tweak future expression to call with '...' arguments ...
[17:59:24.253] {
[17:59:24.253]     do.call(function(...) {
[17:59:24.253]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.253]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.253]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.253]             on.exit(options(oopts), add = TRUE)
[17:59:24.253]         }
[17:59:24.253]         {
[17:59:24.253]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.253]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.253]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.253]             })
[17:59:24.253]         }
[17:59:24.253]     }, args = future.call.arguments)
[17:59:24.253] }
[17:59:24.253] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.254] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.255] 
[17:59:24.255] getGlobalsAndPackages() ... DONE
[17:59:24.255] run() for ‘Future’ ...
[17:59:24.256] - state: ‘created’
[17:59:24.256] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.262] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.263]   - Field: ‘label’
[17:59:24.263]   - Field: ‘local’
[17:59:24.263]   - Field: ‘owner’
[17:59:24.264]   - Field: ‘envir’
[17:59:24.264]   - Field: ‘packages’
[17:59:24.264]   - Field: ‘gc’
[17:59:24.264]   - Field: ‘conditions’
[17:59:24.265]   - Field: ‘expr’
[17:59:24.265]   - Field: ‘uuid’
[17:59:24.265]   - Field: ‘seed’
[17:59:24.265]   - Field: ‘version’
[17:59:24.265]   - Field: ‘result’
[17:59:24.266]   - Field: ‘asynchronous’
[17:59:24.266]   - Field: ‘calls’
[17:59:24.266]   - Field: ‘globals’
[17:59:24.266]   - Field: ‘stdout’
[17:59:24.266]   - Field: ‘earlySignal’
[17:59:24.267]   - Field: ‘lazy’
[17:59:24.267]   - Field: ‘state’
[17:59:24.267] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.267] - Launch lazy future ...
[17:59:24.268] Packages needed by the future expression (n = 0): <none>
[17:59:24.268] Packages needed by future strategies (n = 0): <none>
[17:59:24.269] {
[17:59:24.269]     {
[17:59:24.269]         {
[17:59:24.269]             ...future.startTime <- base::Sys.time()
[17:59:24.269]             {
[17:59:24.269]                 {
[17:59:24.269]                   {
[17:59:24.269]                     base::local({
[17:59:24.269]                       has_future <- base::requireNamespace("future", 
[17:59:24.269]                         quietly = TRUE)
[17:59:24.269]                       if (has_future) {
[17:59:24.269]                         ns <- base::getNamespace("future")
[17:59:24.269]                         version <- ns[[".package"]][["version"]]
[17:59:24.269]                         if (is.null(version)) 
[17:59:24.269]                           version <- utils::packageVersion("future")
[17:59:24.269]                       }
[17:59:24.269]                       else {
[17:59:24.269]                         version <- NULL
[17:59:24.269]                       }
[17:59:24.269]                       if (!has_future || version < "1.8.0") {
[17:59:24.269]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.269]                           "", base::R.version$version.string), 
[17:59:24.269]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.269]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.269]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.269]                             "release", "version")], collapse = " "), 
[17:59:24.269]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.269]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.269]                           info)
[17:59:24.269]                         info <- base::paste(info, collapse = "; ")
[17:59:24.269]                         if (!has_future) {
[17:59:24.269]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.269]                             info)
[17:59:24.269]                         }
[17:59:24.269]                         else {
[17:59:24.269]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.269]                             info, version)
[17:59:24.269]                         }
[17:59:24.269]                         base::stop(msg)
[17:59:24.269]                       }
[17:59:24.269]                     })
[17:59:24.269]                   }
[17:59:24.269]                   ...future.strategy.old <- future::plan("list")
[17:59:24.269]                   options(future.plan = NULL)
[17:59:24.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.269]                 }
[17:59:24.269]                 ...future.workdir <- getwd()
[17:59:24.269]             }
[17:59:24.269]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.269]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.269]         }
[17:59:24.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.269]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.269]             base::names(...future.oldOptions))
[17:59:24.269]     }
[17:59:24.269]     if (FALSE) {
[17:59:24.269]     }
[17:59:24.269]     else {
[17:59:24.269]         if (TRUE) {
[17:59:24.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.269]                 open = "w")
[17:59:24.269]         }
[17:59:24.269]         else {
[17:59:24.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.269]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.269]         }
[17:59:24.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.269]             base::sink(type = "output", split = FALSE)
[17:59:24.269]             base::close(...future.stdout)
[17:59:24.269]         }, add = TRUE)
[17:59:24.269]     }
[17:59:24.269]     ...future.frame <- base::sys.nframe()
[17:59:24.269]     ...future.conditions <- base::list()
[17:59:24.269]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.269]     if (FALSE) {
[17:59:24.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.269]     }
[17:59:24.269]     ...future.result <- base::tryCatch({
[17:59:24.269]         base::withCallingHandlers({
[17:59:24.269]             ...future.value <- base::withVisible(base::local({
[17:59:24.269]                 do.call(function(...) {
[17:59:24.269]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.269]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.269]                     ...future.globals.maxSize)) {
[17:59:24.269]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.269]                     on.exit(options(oopts), add = TRUE)
[17:59:24.269]                   }
[17:59:24.269]                   {
[17:59:24.269]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.269]                       FUN = function(jj) {
[17:59:24.269]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.269]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.269]                       })
[17:59:24.269]                   }
[17:59:24.269]                 }, args = future.call.arguments)
[17:59:24.269]             }))
[17:59:24.269]             future::FutureResult(value = ...future.value$value, 
[17:59:24.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.269]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.269]                     ...future.globalenv.names))
[17:59:24.269]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.269]         }, condition = base::local({
[17:59:24.269]             c <- base::c
[17:59:24.269]             inherits <- base::inherits
[17:59:24.269]             invokeRestart <- base::invokeRestart
[17:59:24.269]             length <- base::length
[17:59:24.269]             list <- base::list
[17:59:24.269]             seq.int <- base::seq.int
[17:59:24.269]             signalCondition <- base::signalCondition
[17:59:24.269]             sys.calls <- base::sys.calls
[17:59:24.269]             `[[` <- base::`[[`
[17:59:24.269]             `+` <- base::`+`
[17:59:24.269]             `<<-` <- base::`<<-`
[17:59:24.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.269]                   3L)]
[17:59:24.269]             }
[17:59:24.269]             function(cond) {
[17:59:24.269]                 is_error <- inherits(cond, "error")
[17:59:24.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.269]                   NULL)
[17:59:24.269]                 if (is_error) {
[17:59:24.269]                   sessionInformation <- function() {
[17:59:24.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.269]                       search = base::search(), system = base::Sys.info())
[17:59:24.269]                   }
[17:59:24.269]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.269]                     cond$call), session = sessionInformation(), 
[17:59:24.269]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.269]                   signalCondition(cond)
[17:59:24.269]                 }
[17:59:24.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.269]                 "immediateCondition"))) {
[17:59:24.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.269]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.269]                   if (TRUE && !signal) {
[17:59:24.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.269]                     {
[17:59:24.269]                       inherits <- base::inherits
[17:59:24.269]                       invokeRestart <- base::invokeRestart
[17:59:24.269]                       is.null <- base::is.null
[17:59:24.269]                       muffled <- FALSE
[17:59:24.269]                       if (inherits(cond, "message")) {
[17:59:24.269]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.269]                         if (muffled) 
[17:59:24.269]                           invokeRestart("muffleMessage")
[17:59:24.269]                       }
[17:59:24.269]                       else if (inherits(cond, "warning")) {
[17:59:24.269]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.269]                         if (muffled) 
[17:59:24.269]                           invokeRestart("muffleWarning")
[17:59:24.269]                       }
[17:59:24.269]                       else if (inherits(cond, "condition")) {
[17:59:24.269]                         if (!is.null(pattern)) {
[17:59:24.269]                           computeRestarts <- base::computeRestarts
[17:59:24.269]                           grepl <- base::grepl
[17:59:24.269]                           restarts <- computeRestarts(cond)
[17:59:24.269]                           for (restart in restarts) {
[17:59:24.269]                             name <- restart$name
[17:59:24.269]                             if (is.null(name)) 
[17:59:24.269]                               next
[17:59:24.269]                             if (!grepl(pattern, name)) 
[17:59:24.269]                               next
[17:59:24.269]                             invokeRestart(restart)
[17:59:24.269]                             muffled <- TRUE
[17:59:24.269]                             break
[17:59:24.269]                           }
[17:59:24.269]                         }
[17:59:24.269]                       }
[17:59:24.269]                       invisible(muffled)
[17:59:24.269]                     }
[17:59:24.269]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.269]                   }
[17:59:24.269]                 }
[17:59:24.269]                 else {
[17:59:24.269]                   if (TRUE) {
[17:59:24.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.269]                     {
[17:59:24.269]                       inherits <- base::inherits
[17:59:24.269]                       invokeRestart <- base::invokeRestart
[17:59:24.269]                       is.null <- base::is.null
[17:59:24.269]                       muffled <- FALSE
[17:59:24.269]                       if (inherits(cond, "message")) {
[17:59:24.269]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.269]                         if (muffled) 
[17:59:24.269]                           invokeRestart("muffleMessage")
[17:59:24.269]                       }
[17:59:24.269]                       else if (inherits(cond, "warning")) {
[17:59:24.269]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.269]                         if (muffled) 
[17:59:24.269]                           invokeRestart("muffleWarning")
[17:59:24.269]                       }
[17:59:24.269]                       else if (inherits(cond, "condition")) {
[17:59:24.269]                         if (!is.null(pattern)) {
[17:59:24.269]                           computeRestarts <- base::computeRestarts
[17:59:24.269]                           grepl <- base::grepl
[17:59:24.269]                           restarts <- computeRestarts(cond)
[17:59:24.269]                           for (restart in restarts) {
[17:59:24.269]                             name <- restart$name
[17:59:24.269]                             if (is.null(name)) 
[17:59:24.269]                               next
[17:59:24.269]                             if (!grepl(pattern, name)) 
[17:59:24.269]                               next
[17:59:24.269]                             invokeRestart(restart)
[17:59:24.269]                             muffled <- TRUE
[17:59:24.269]                             break
[17:59:24.269]                           }
[17:59:24.269]                         }
[17:59:24.269]                       }
[17:59:24.269]                       invisible(muffled)
[17:59:24.269]                     }
[17:59:24.269]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.269]                   }
[17:59:24.269]                 }
[17:59:24.269]             }
[17:59:24.269]         }))
[17:59:24.269]     }, error = function(ex) {
[17:59:24.269]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.269]                 ...future.rng), started = ...future.startTime, 
[17:59:24.269]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.269]             version = "1.8"), class = "FutureResult")
[17:59:24.269]     }, finally = {
[17:59:24.269]         if (!identical(...future.workdir, getwd())) 
[17:59:24.269]             setwd(...future.workdir)
[17:59:24.269]         {
[17:59:24.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.269]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.269]             }
[17:59:24.269]             base::options(...future.oldOptions)
[17:59:24.269]             if (.Platform$OS.type == "windows") {
[17:59:24.269]                 old_names <- names(...future.oldEnvVars)
[17:59:24.269]                 envs <- base::Sys.getenv()
[17:59:24.269]                 names <- names(envs)
[17:59:24.269]                 common <- intersect(names, old_names)
[17:59:24.269]                 added <- setdiff(names, old_names)
[17:59:24.269]                 removed <- setdiff(old_names, names)
[17:59:24.269]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.269]                   envs[common]]
[17:59:24.269]                 NAMES <- toupper(changed)
[17:59:24.269]                 args <- list()
[17:59:24.269]                 for (kk in seq_along(NAMES)) {
[17:59:24.269]                   name <- changed[[kk]]
[17:59:24.269]                   NAME <- NAMES[[kk]]
[17:59:24.269]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.269]                     next
[17:59:24.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.269]                 }
[17:59:24.269]                 NAMES <- toupper(added)
[17:59:24.269]                 for (kk in seq_along(NAMES)) {
[17:59:24.269]                   name <- added[[kk]]
[17:59:24.269]                   NAME <- NAMES[[kk]]
[17:59:24.269]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.269]                     next
[17:59:24.269]                   args[[name]] <- ""
[17:59:24.269]                 }
[17:59:24.269]                 NAMES <- toupper(removed)
[17:59:24.269]                 for (kk in seq_along(NAMES)) {
[17:59:24.269]                   name <- removed[[kk]]
[17:59:24.269]                   NAME <- NAMES[[kk]]
[17:59:24.269]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.269]                     next
[17:59:24.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.269]                 }
[17:59:24.269]                 if (length(args) > 0) 
[17:59:24.269]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.269]             }
[17:59:24.269]             else {
[17:59:24.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.269]             }
[17:59:24.269]             {
[17:59:24.269]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.269]                   0L) {
[17:59:24.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.269]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.269]                   base::options(opts)
[17:59:24.269]                 }
[17:59:24.269]                 {
[17:59:24.269]                   {
[17:59:24.269]                     NULL
[17:59:24.269]                     RNGkind("Mersenne-Twister")
[17:59:24.269]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.269]                       inherits = FALSE)
[17:59:24.269]                   }
[17:59:24.269]                   options(future.plan = NULL)
[17:59:24.269]                   if (is.na(NA_character_)) 
[17:59:24.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.269]                     .init = FALSE)
[17:59:24.269]                 }
[17:59:24.269]             }
[17:59:24.269]         }
[17:59:24.269]     })
[17:59:24.269]     if (TRUE) {
[17:59:24.269]         base::sink(type = "output", split = FALSE)
[17:59:24.269]         if (TRUE) {
[17:59:24.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.269]         }
[17:59:24.269]         else {
[17:59:24.269]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.269]         }
[17:59:24.269]         base::close(...future.stdout)
[17:59:24.269]         ...future.stdout <- NULL
[17:59:24.269]     }
[17:59:24.269]     ...future.result$conditions <- ...future.conditions
[17:59:24.269]     ...future.result$finished <- base::Sys.time()
[17:59:24.269]     ...future.result
[17:59:24.269] }
[17:59:24.273] assign_globals() ...
[17:59:24.273] List of 5
[17:59:24.273]  $ ...future.FUN            :function (object, ...)  
[17:59:24.273]  $ future.call.arguments    : list()
[17:59:24.273]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.273]  $ ...future.elements_ii    :List of 3
[17:59:24.273]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:24.273]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.273]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.273]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:24.273]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.273]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.273]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:24.273]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.273]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.273]  $ ...future.seeds_ii       : NULL
[17:59:24.273]  $ ...future.globals.maxSize: NULL
[17:59:24.273]  - attr(*, "where")=List of 5
[17:59:24.273]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.273]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.273]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.273]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.273]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.273]  - attr(*, "resolved")= logi FALSE
[17:59:24.273]  - attr(*, "total_size")= num 1240
[17:59:24.273]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.273]  - attr(*, "already-done")= logi TRUE
[17:59:24.292] - copied ‘...future.FUN’ to environment
[17:59:24.292] - copied ‘future.call.arguments’ to environment
[17:59:24.292] - copied ‘...future.elements_ii’ to environment
[17:59:24.292] - copied ‘...future.seeds_ii’ to environment
[17:59:24.292] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.293] assign_globals() ... done
[17:59:24.293] plan(): Setting new future strategy stack:
[17:59:24.293] List of future strategies:
[17:59:24.293] 1. sequential:
[17:59:24.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.293]    - tweaked: FALSE
[17:59:24.293]    - call: NULL
[17:59:24.294] plan(): nbrOfWorkers() = 1
[17:59:24.298] plan(): Setting new future strategy stack:
[17:59:24.299] List of future strategies:
[17:59:24.299] 1. multicore:
[17:59:24.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.299]    - tweaked: FALSE
[17:59:24.299]    - call: plan(strategy)
[17:59:24.307] plan(): nbrOfWorkers() = 1
[17:59:24.308] SequentialFuture started (and completed)
[17:59:24.308] - Launch lazy future ... done
[17:59:24.308] run() for ‘SequentialFuture’ ... done
[17:59:24.309] Created future:
[17:59:24.309] SequentialFuture:
[17:59:24.309] Label: ‘future_by-1’
[17:59:24.309] Expression:
[17:59:24.309] {
[17:59:24.309]     do.call(function(...) {
[17:59:24.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.309]             on.exit(options(oopts), add = TRUE)
[17:59:24.309]         }
[17:59:24.309]         {
[17:59:24.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.309]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.309]             })
[17:59:24.309]         }
[17:59:24.309]     }, args = future.call.arguments)
[17:59:24.309] }
[17:59:24.309] Lazy evaluation: FALSE
[17:59:24.309] Asynchronous evaluation: FALSE
[17:59:24.309] Local evaluation: TRUE
[17:59:24.309] Environment: R_GlobalEnv
[17:59:24.309] Capture standard output: TRUE
[17:59:24.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.309] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.309] Packages: <none>
[17:59:24.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.309] Resolved: TRUE
[17:59:24.309] Value: 4.62 KiB of class ‘list’
[17:59:24.309] Early signaling: FALSE
[17:59:24.309] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.309] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.312] Chunk #1 of 1 ... DONE
[17:59:24.312] Launching 1 futures (chunks) ... DONE
[17:59:24.312] Resolving 1 futures (chunks) ...
[17:59:24.312] resolve() on list ...
[17:59:24.312]  recursive: 0
[17:59:24.313]  length: 1
[17:59:24.313] 
[17:59:24.314] resolved() for ‘SequentialFuture’ ...
[17:59:24.314] - state: ‘finished’
[17:59:24.314] - run: TRUE
[17:59:24.314] - result: ‘FutureResult’
[17:59:24.315] resolved() for ‘SequentialFuture’ ... done
[17:59:24.315] Future #1
[17:59:24.315] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.315] - nx: 1
[17:59:24.315] - relay: TRUE
[17:59:24.316] - stdout: TRUE
[17:59:24.316] - signal: TRUE
[17:59:24.316] - resignal: FALSE
[17:59:24.316] - force: TRUE
[17:59:24.316] - relayed: [n=1] FALSE
[17:59:24.317] - queued futures: [n=1] FALSE
[17:59:24.317]  - until=1
[17:59:24.317]  - relaying element #1
[17:59:24.317] - relayed: [n=1] TRUE
[17:59:24.318] - queued futures: [n=1] TRUE
[17:59:24.318] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.318]  length: 0 (resolved future 1)
[17:59:24.318] Relaying remaining futures
[17:59:24.318] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.319] - nx: 1
[17:59:24.319] - relay: TRUE
[17:59:24.319] - stdout: TRUE
[17:59:24.319] - signal: TRUE
[17:59:24.319] - resignal: FALSE
[17:59:24.319] - force: TRUE
[17:59:24.320] - relayed: [n=1] TRUE
[17:59:24.320] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.320] - relayed: [n=1] TRUE
[17:59:24.320] - queued futures: [n=1] TRUE
[17:59:24.321] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.321] resolve() on list ... DONE
[17:59:24.321]  - Number of value chunks collected: 1
[17:59:24.321] Resolving 1 futures (chunks) ... DONE
[17:59:24.321] Reducing values from 1 chunks ...
[17:59:24.322]  - Number of values collected after concatenation: 3
[17:59:24.322]  - Number of values expected: 3
[17:59:24.322] Reducing values from 1 chunks ... DONE
[17:59:24.322] future_lapply() ... DONE
[17:59:24.322] future_by_internal() ... DONE
[17:59:24.323] future_by_internal() ...
[17:59:24.324] future_lapply() ...
[17:59:24.330] Number of chunks: 1
[17:59:24.330] getGlobalsAndPackagesXApply() ...
[17:59:24.330]  - future.globals: TRUE
[17:59:24.331] getGlobalsAndPackages() ...
[17:59:24.331] Searching for globals...
[17:59:24.333] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.333] Searching for globals ... DONE
[17:59:24.333] Resolving globals: FALSE
[17:59:24.334] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.335] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.335] - globals: [1] ‘FUN’
[17:59:24.336] 
[17:59:24.338] getGlobalsAndPackages() ... DONE
[17:59:24.338]  - globals found/used: [n=1] ‘FUN’
[17:59:24.339]  - needed namespaces: [n=0] 
[17:59:24.339] Finding globals ... DONE
[17:59:24.339]  - use_args: TRUE
[17:59:24.339]  - Getting '...' globals ...
[17:59:24.341] resolve() on list ...
[17:59:24.341]  recursive: 0
[17:59:24.342]  length: 1
[17:59:24.342]  elements: ‘...’
[17:59:24.343]  length: 0 (resolved future 1)
[17:59:24.343] resolve() on list ... DONE
[17:59:24.343]    - '...' content: [n=1] ‘digits’
[17:59:24.343] List of 1
[17:59:24.343]  $ ...:List of 1
[17:59:24.343]   ..$ digits: int 2
[17:59:24.343]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.343]  - attr(*, "where")=List of 1
[17:59:24.343]   ..$ ...:<environment: 0x62649ff10278> 
[17:59:24.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.343]  - attr(*, "resolved")= logi TRUE
[17:59:24.343]  - attr(*, "total_size")= num NA
[17:59:24.350]  - Getting '...' globals ... DONE
[17:59:24.350] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.350] List of 2
[17:59:24.350]  $ ...future.FUN:function (object, ...)  
[17:59:24.350]  $ ...          :List of 1
[17:59:24.350]   ..$ digits: int 2
[17:59:24.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.350]  - attr(*, "where")=List of 2
[17:59:24.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.350]   ..$ ...          :<environment: 0x62649ff10278> 
[17:59:24.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.350]  - attr(*, "resolved")= logi FALSE
[17:59:24.350]  - attr(*, "total_size")= num 1296
[17:59:24.357] Packages to be attached in all futures: [n=0] 
[17:59:24.357] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.357] Number of futures (= number of chunks): 1
[17:59:24.357] Launching 1 futures (chunks) ...
[17:59:24.358] Chunk #1 of 1 ...
[17:59:24.358]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.358] getGlobalsAndPackages() ...
[17:59:24.358] Searching for globals...
[17:59:24.359] 
[17:59:24.359] Searching for globals ... DONE
[17:59:24.359] - globals: [0] <none>
[17:59:24.359] getGlobalsAndPackages() ... DONE
[17:59:24.360]    + additional globals found: [n=0] 
[17:59:24.360]    + additional namespaces needed: [n=0] 
[17:59:24.360]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.360]  - seeds: <none>
[17:59:24.360]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.361] getGlobalsAndPackages() ...
[17:59:24.361] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.361] Resolving globals: FALSE
[17:59:24.361] Tweak future expression to call with '...' arguments ...
[17:59:24.361] {
[17:59:24.361]     do.call(function(...) {
[17:59:24.361]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.361]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.361]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.361]             on.exit(options(oopts), add = TRUE)
[17:59:24.361]         }
[17:59:24.361]         {
[17:59:24.361]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.361]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.361]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.361]             })
[17:59:24.361]         }
[17:59:24.361]     }, args = future.call.arguments)
[17:59:24.361] }
[17:59:24.362] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.363] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.363] 
[17:59:24.363] getGlobalsAndPackages() ... DONE
[17:59:24.364] run() for ‘Future’ ...
[17:59:24.364] - state: ‘created’
[17:59:24.364] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.371] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.371] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.372]   - Field: ‘label’
[17:59:24.372]   - Field: ‘local’
[17:59:24.372]   - Field: ‘owner’
[17:59:24.372]   - Field: ‘envir’
[17:59:24.372]   - Field: ‘packages’
[17:59:24.373]   - Field: ‘gc’
[17:59:24.373]   - Field: ‘conditions’
[17:59:24.373]   - Field: ‘expr’
[17:59:24.373]   - Field: ‘uuid’
[17:59:24.373]   - Field: ‘seed’
[17:59:24.374]   - Field: ‘version’
[17:59:24.374]   - Field: ‘result’
[17:59:24.374]   - Field: ‘asynchronous’
[17:59:24.374]   - Field: ‘calls’
[17:59:24.374]   - Field: ‘globals’
[17:59:24.375]   - Field: ‘stdout’
[17:59:24.375]   - Field: ‘earlySignal’
[17:59:24.375]   - Field: ‘lazy’
[17:59:24.375]   - Field: ‘state’
[17:59:24.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.376] - Launch lazy future ...
[17:59:24.376] Packages needed by the future expression (n = 0): <none>
[17:59:24.376] Packages needed by future strategies (n = 0): <none>
[17:59:24.377] {
[17:59:24.377]     {
[17:59:24.377]         {
[17:59:24.377]             ...future.startTime <- base::Sys.time()
[17:59:24.377]             {
[17:59:24.377]                 {
[17:59:24.377]                   {
[17:59:24.377]                     base::local({
[17:59:24.377]                       has_future <- base::requireNamespace("future", 
[17:59:24.377]                         quietly = TRUE)
[17:59:24.377]                       if (has_future) {
[17:59:24.377]                         ns <- base::getNamespace("future")
[17:59:24.377]                         version <- ns[[".package"]][["version"]]
[17:59:24.377]                         if (is.null(version)) 
[17:59:24.377]                           version <- utils::packageVersion("future")
[17:59:24.377]                       }
[17:59:24.377]                       else {
[17:59:24.377]                         version <- NULL
[17:59:24.377]                       }
[17:59:24.377]                       if (!has_future || version < "1.8.0") {
[17:59:24.377]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.377]                           "", base::R.version$version.string), 
[17:59:24.377]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.377]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.377]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.377]                             "release", "version")], collapse = " "), 
[17:59:24.377]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.377]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.377]                           info)
[17:59:24.377]                         info <- base::paste(info, collapse = "; ")
[17:59:24.377]                         if (!has_future) {
[17:59:24.377]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.377]                             info)
[17:59:24.377]                         }
[17:59:24.377]                         else {
[17:59:24.377]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.377]                             info, version)
[17:59:24.377]                         }
[17:59:24.377]                         base::stop(msg)
[17:59:24.377]                       }
[17:59:24.377]                     })
[17:59:24.377]                   }
[17:59:24.377]                   ...future.strategy.old <- future::plan("list")
[17:59:24.377]                   options(future.plan = NULL)
[17:59:24.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.377]                 }
[17:59:24.377]                 ...future.workdir <- getwd()
[17:59:24.377]             }
[17:59:24.377]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.377]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.377]         }
[17:59:24.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.377]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.377]             base::names(...future.oldOptions))
[17:59:24.377]     }
[17:59:24.377]     if (FALSE) {
[17:59:24.377]     }
[17:59:24.377]     else {
[17:59:24.377]         if (TRUE) {
[17:59:24.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.377]                 open = "w")
[17:59:24.377]         }
[17:59:24.377]         else {
[17:59:24.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.377]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.377]         }
[17:59:24.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.377]             base::sink(type = "output", split = FALSE)
[17:59:24.377]             base::close(...future.stdout)
[17:59:24.377]         }, add = TRUE)
[17:59:24.377]     }
[17:59:24.377]     ...future.frame <- base::sys.nframe()
[17:59:24.377]     ...future.conditions <- base::list()
[17:59:24.377]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.377]     if (FALSE) {
[17:59:24.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.377]     }
[17:59:24.377]     ...future.result <- base::tryCatch({
[17:59:24.377]         base::withCallingHandlers({
[17:59:24.377]             ...future.value <- base::withVisible(base::local({
[17:59:24.377]                 do.call(function(...) {
[17:59:24.377]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.377]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.377]                     ...future.globals.maxSize)) {
[17:59:24.377]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.377]                     on.exit(options(oopts), add = TRUE)
[17:59:24.377]                   }
[17:59:24.377]                   {
[17:59:24.377]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.377]                       FUN = function(jj) {
[17:59:24.377]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.377]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.377]                       })
[17:59:24.377]                   }
[17:59:24.377]                 }, args = future.call.arguments)
[17:59:24.377]             }))
[17:59:24.377]             future::FutureResult(value = ...future.value$value, 
[17:59:24.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.377]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.377]                     ...future.globalenv.names))
[17:59:24.377]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.377]         }, condition = base::local({
[17:59:24.377]             c <- base::c
[17:59:24.377]             inherits <- base::inherits
[17:59:24.377]             invokeRestart <- base::invokeRestart
[17:59:24.377]             length <- base::length
[17:59:24.377]             list <- base::list
[17:59:24.377]             seq.int <- base::seq.int
[17:59:24.377]             signalCondition <- base::signalCondition
[17:59:24.377]             sys.calls <- base::sys.calls
[17:59:24.377]             `[[` <- base::`[[`
[17:59:24.377]             `+` <- base::`+`
[17:59:24.377]             `<<-` <- base::`<<-`
[17:59:24.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.377]                   3L)]
[17:59:24.377]             }
[17:59:24.377]             function(cond) {
[17:59:24.377]                 is_error <- inherits(cond, "error")
[17:59:24.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.377]                   NULL)
[17:59:24.377]                 if (is_error) {
[17:59:24.377]                   sessionInformation <- function() {
[17:59:24.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.377]                       search = base::search(), system = base::Sys.info())
[17:59:24.377]                   }
[17:59:24.377]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.377]                     cond$call), session = sessionInformation(), 
[17:59:24.377]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.377]                   signalCondition(cond)
[17:59:24.377]                 }
[17:59:24.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.377]                 "immediateCondition"))) {
[17:59:24.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.377]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.377]                   if (TRUE && !signal) {
[17:59:24.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.377]                     {
[17:59:24.377]                       inherits <- base::inherits
[17:59:24.377]                       invokeRestart <- base::invokeRestart
[17:59:24.377]                       is.null <- base::is.null
[17:59:24.377]                       muffled <- FALSE
[17:59:24.377]                       if (inherits(cond, "message")) {
[17:59:24.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.377]                         if (muffled) 
[17:59:24.377]                           invokeRestart("muffleMessage")
[17:59:24.377]                       }
[17:59:24.377]                       else if (inherits(cond, "warning")) {
[17:59:24.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.377]                         if (muffled) 
[17:59:24.377]                           invokeRestart("muffleWarning")
[17:59:24.377]                       }
[17:59:24.377]                       else if (inherits(cond, "condition")) {
[17:59:24.377]                         if (!is.null(pattern)) {
[17:59:24.377]                           computeRestarts <- base::computeRestarts
[17:59:24.377]                           grepl <- base::grepl
[17:59:24.377]                           restarts <- computeRestarts(cond)
[17:59:24.377]                           for (restart in restarts) {
[17:59:24.377]                             name <- restart$name
[17:59:24.377]                             if (is.null(name)) 
[17:59:24.377]                               next
[17:59:24.377]                             if (!grepl(pattern, name)) 
[17:59:24.377]                               next
[17:59:24.377]                             invokeRestart(restart)
[17:59:24.377]                             muffled <- TRUE
[17:59:24.377]                             break
[17:59:24.377]                           }
[17:59:24.377]                         }
[17:59:24.377]                       }
[17:59:24.377]                       invisible(muffled)
[17:59:24.377]                     }
[17:59:24.377]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.377]                   }
[17:59:24.377]                 }
[17:59:24.377]                 else {
[17:59:24.377]                   if (TRUE) {
[17:59:24.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.377]                     {
[17:59:24.377]                       inherits <- base::inherits
[17:59:24.377]                       invokeRestart <- base::invokeRestart
[17:59:24.377]                       is.null <- base::is.null
[17:59:24.377]                       muffled <- FALSE
[17:59:24.377]                       if (inherits(cond, "message")) {
[17:59:24.377]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.377]                         if (muffled) 
[17:59:24.377]                           invokeRestart("muffleMessage")
[17:59:24.377]                       }
[17:59:24.377]                       else if (inherits(cond, "warning")) {
[17:59:24.377]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.377]                         if (muffled) 
[17:59:24.377]                           invokeRestart("muffleWarning")
[17:59:24.377]                       }
[17:59:24.377]                       else if (inherits(cond, "condition")) {
[17:59:24.377]                         if (!is.null(pattern)) {
[17:59:24.377]                           computeRestarts <- base::computeRestarts
[17:59:24.377]                           grepl <- base::grepl
[17:59:24.377]                           restarts <- computeRestarts(cond)
[17:59:24.377]                           for (restart in restarts) {
[17:59:24.377]                             name <- restart$name
[17:59:24.377]                             if (is.null(name)) 
[17:59:24.377]                               next
[17:59:24.377]                             if (!grepl(pattern, name)) 
[17:59:24.377]                               next
[17:59:24.377]                             invokeRestart(restart)
[17:59:24.377]                             muffled <- TRUE
[17:59:24.377]                             break
[17:59:24.377]                           }
[17:59:24.377]                         }
[17:59:24.377]                       }
[17:59:24.377]                       invisible(muffled)
[17:59:24.377]                     }
[17:59:24.377]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.377]                   }
[17:59:24.377]                 }
[17:59:24.377]             }
[17:59:24.377]         }))
[17:59:24.377]     }, error = function(ex) {
[17:59:24.377]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.377]                 ...future.rng), started = ...future.startTime, 
[17:59:24.377]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.377]             version = "1.8"), class = "FutureResult")
[17:59:24.377]     }, finally = {
[17:59:24.377]         if (!identical(...future.workdir, getwd())) 
[17:59:24.377]             setwd(...future.workdir)
[17:59:24.377]         {
[17:59:24.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.377]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.377]             }
[17:59:24.377]             base::options(...future.oldOptions)
[17:59:24.377]             if (.Platform$OS.type == "windows") {
[17:59:24.377]                 old_names <- names(...future.oldEnvVars)
[17:59:24.377]                 envs <- base::Sys.getenv()
[17:59:24.377]                 names <- names(envs)
[17:59:24.377]                 common <- intersect(names, old_names)
[17:59:24.377]                 added <- setdiff(names, old_names)
[17:59:24.377]                 removed <- setdiff(old_names, names)
[17:59:24.377]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.377]                   envs[common]]
[17:59:24.377]                 NAMES <- toupper(changed)
[17:59:24.377]                 args <- list()
[17:59:24.377]                 for (kk in seq_along(NAMES)) {
[17:59:24.377]                   name <- changed[[kk]]
[17:59:24.377]                   NAME <- NAMES[[kk]]
[17:59:24.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.377]                     next
[17:59:24.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.377]                 }
[17:59:24.377]                 NAMES <- toupper(added)
[17:59:24.377]                 for (kk in seq_along(NAMES)) {
[17:59:24.377]                   name <- added[[kk]]
[17:59:24.377]                   NAME <- NAMES[[kk]]
[17:59:24.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.377]                     next
[17:59:24.377]                   args[[name]] <- ""
[17:59:24.377]                 }
[17:59:24.377]                 NAMES <- toupper(removed)
[17:59:24.377]                 for (kk in seq_along(NAMES)) {
[17:59:24.377]                   name <- removed[[kk]]
[17:59:24.377]                   NAME <- NAMES[[kk]]
[17:59:24.377]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.377]                     next
[17:59:24.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.377]                 }
[17:59:24.377]                 if (length(args) > 0) 
[17:59:24.377]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.377]             }
[17:59:24.377]             else {
[17:59:24.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.377]             }
[17:59:24.377]             {
[17:59:24.377]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.377]                   0L) {
[17:59:24.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.377]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.377]                   base::options(opts)
[17:59:24.377]                 }
[17:59:24.377]                 {
[17:59:24.377]                   {
[17:59:24.377]                     NULL
[17:59:24.377]                     RNGkind("Mersenne-Twister")
[17:59:24.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.377]                       inherits = FALSE)
[17:59:24.377]                   }
[17:59:24.377]                   options(future.plan = NULL)
[17:59:24.377]                   if (is.na(NA_character_)) 
[17:59:24.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.377]                     .init = FALSE)
[17:59:24.377]                 }
[17:59:24.377]             }
[17:59:24.377]         }
[17:59:24.377]     })
[17:59:24.377]     if (TRUE) {
[17:59:24.377]         base::sink(type = "output", split = FALSE)
[17:59:24.377]         if (TRUE) {
[17:59:24.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.377]         }
[17:59:24.377]         else {
[17:59:24.377]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.377]         }
[17:59:24.377]         base::close(...future.stdout)
[17:59:24.377]         ...future.stdout <- NULL
[17:59:24.377]     }
[17:59:24.377]     ...future.result$conditions <- ...future.conditions
[17:59:24.377]     ...future.result$finished <- base::Sys.time()
[17:59:24.377]     ...future.result
[17:59:24.377] }
[17:59:24.380] assign_globals() ...
[17:59:24.381] List of 5
[17:59:24.381]  $ ...future.FUN            :function (object, ...)  
[17:59:24.381]  $ future.call.arguments    :List of 1
[17:59:24.381]   ..$ digits: int 2
[17:59:24.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.381]  $ ...future.elements_ii    :List of 6
[17:59:24.381]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:59:24.381]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:59:24.381]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:59:24.381]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:59:24.381]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:59:24.381]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:59:24.381]  $ ...future.seeds_ii       : NULL
[17:59:24.381]  $ ...future.globals.maxSize: NULL
[17:59:24.381]  - attr(*, "where")=List of 5
[17:59:24.381]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.381]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.381]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.381]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.381]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.381]  - attr(*, "resolved")= logi FALSE
[17:59:24.381]  - attr(*, "total_size")= num 1296
[17:59:24.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.381]  - attr(*, "already-done")= logi TRUE
[17:59:24.398] - copied ‘...future.FUN’ to environment
[17:59:24.399] - copied ‘future.call.arguments’ to environment
[17:59:24.399] - copied ‘...future.elements_ii’ to environment
[17:59:24.399] - copied ‘...future.seeds_ii’ to environment
[17:59:24.399] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.400] assign_globals() ... done
[17:59:24.400] plan(): Setting new future strategy stack:
[17:59:24.400] List of future strategies:
[17:59:24.400] 1. sequential:
[17:59:24.400]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.400]    - tweaked: FALSE
[17:59:24.400]    - call: NULL
[17:59:24.401] plan(): nbrOfWorkers() = 1
[17:59:24.404] plan(): Setting new future strategy stack:
[17:59:24.404] List of future strategies:
[17:59:24.404] 1. multicore:
[17:59:24.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.404]    - tweaked: FALSE
[17:59:24.404]    - call: plan(strategy)
[17:59:24.410] plan(): nbrOfWorkers() = 1
[17:59:24.411] SequentialFuture started (and completed)
[17:59:24.411] - Launch lazy future ... done
[17:59:24.411] run() for ‘SequentialFuture’ ... done
[17:59:24.411] Created future:
[17:59:24.412] SequentialFuture:
[17:59:24.412] Label: ‘future_by-1’
[17:59:24.412] Expression:
[17:59:24.412] {
[17:59:24.412]     do.call(function(...) {
[17:59:24.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.412]             on.exit(options(oopts), add = TRUE)
[17:59:24.412]         }
[17:59:24.412]         {
[17:59:24.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.412]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.412]             })
[17:59:24.412]         }
[17:59:24.412]     }, args = future.call.arguments)
[17:59:24.412] }
[17:59:24.412] Lazy evaluation: FALSE
[17:59:24.412] Asynchronous evaluation: FALSE
[17:59:24.412] Local evaluation: TRUE
[17:59:24.412] Environment: R_GlobalEnv
[17:59:24.412] Capture standard output: TRUE
[17:59:24.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.412] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.412] Packages: <none>
[17:59:24.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.412] Resolved: TRUE
[17:59:24.412] Value: 5.48 KiB of class ‘list’
[17:59:24.412] Early signaling: FALSE
[17:59:24.412] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.412] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.414] Chunk #1 of 1 ... DONE
[17:59:24.414] Launching 1 futures (chunks) ... DONE
[17:59:24.414] Resolving 1 futures (chunks) ...
[17:59:24.414] resolve() on list ...
[17:59:24.415]  recursive: 0
[17:59:24.415]  length: 1
[17:59:24.415] 
[17:59:24.415] resolved() for ‘SequentialFuture’ ...
[17:59:24.415] - state: ‘finished’
[17:59:24.416] - run: TRUE
[17:59:24.416] - result: ‘FutureResult’
[17:59:24.416] resolved() for ‘SequentialFuture’ ... done
[17:59:24.416] Future #1
[17:59:24.417] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.417] - nx: 1
[17:59:24.417] - relay: TRUE
[17:59:24.417] - stdout: TRUE
[17:59:24.417] - signal: TRUE
[17:59:24.417] - resignal: FALSE
[17:59:24.418] - force: TRUE
[17:59:24.418] - relayed: [n=1] FALSE
[17:59:24.418] - queued futures: [n=1] FALSE
[17:59:24.418]  - until=1
[17:59:24.418]  - relaying element #1
[17:59:24.419] - relayed: [n=1] TRUE
[17:59:24.419] - queued futures: [n=1] TRUE
[17:59:24.419] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.419]  length: 0 (resolved future 1)
[17:59:24.420] Relaying remaining futures
[17:59:24.420] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.420] - nx: 1
[17:59:24.420] - relay: TRUE
[17:59:24.420] - stdout: TRUE
[17:59:24.420] - signal: TRUE
[17:59:24.421] - resignal: FALSE
[17:59:24.421] - force: TRUE
[17:59:24.421] - relayed: [n=1] TRUE
[17:59:24.421] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.421] - relayed: [n=1] TRUE
[17:59:24.422] - queued futures: [n=1] TRUE
[17:59:24.422] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.422] resolve() on list ... DONE
[17:59:24.422]  - Number of value chunks collected: 1
[17:59:24.422] Resolving 1 futures (chunks) ... DONE
[17:59:24.423] Reducing values from 1 chunks ...
[17:59:24.423]  - Number of values collected after concatenation: 6
[17:59:24.423]  - Number of values expected: 6
[17:59:24.423] Reducing values from 1 chunks ... DONE
[17:59:24.423] future_lapply() ... DONE
[17:59:24.424] future_by_internal() ... DONE
[17:59:24.426] future_by_internal() ...
[17:59:24.427] future_lapply() ...
[17:59:24.434] Number of chunks: 1
[17:59:24.434] getGlobalsAndPackagesXApply() ...
[17:59:24.434]  - future.globals: TRUE
[17:59:24.434] getGlobalsAndPackages() ...
[17:59:24.435] Searching for globals...
[17:59:24.440] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:24.441] Searching for globals ... DONE
[17:59:24.441] Resolving globals: FALSE
[17:59:24.442] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:59:24.442] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:59:24.443] - globals: [1] ‘FUN’
[17:59:24.443] - packages: [1] ‘stats’
[17:59:24.443] getGlobalsAndPackages() ... DONE
[17:59:24.443]  - globals found/used: [n=1] ‘FUN’
[17:59:24.443]  - needed namespaces: [n=1] ‘stats’
[17:59:24.444] Finding globals ... DONE
[17:59:24.444]  - use_args: TRUE
[17:59:24.444]  - Getting '...' globals ...
[17:59:24.445] resolve() on list ...
[17:59:24.445]  recursive: 0
[17:59:24.445]  length: 1
[17:59:24.445]  elements: ‘...’
[17:59:24.446]  length: 0 (resolved future 1)
[17:59:24.446] resolve() on list ... DONE
[17:59:24.446]    - '...' content: [n=1] ‘singular.ok’
[17:59:24.446] List of 1
[17:59:24.446]  $ ...:List of 1
[17:59:24.446]   ..$ singular.ok: logi FALSE
[17:59:24.446]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.446]  - attr(*, "where")=List of 1
[17:59:24.446]   ..$ ...:<environment: 0x62649ff41388> 
[17:59:24.446]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.446]  - attr(*, "resolved")= logi TRUE
[17:59:24.446]  - attr(*, "total_size")= num NA
[17:59:24.452]  - Getting '...' globals ... DONE
[17:59:24.452] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.452] List of 2
[17:59:24.452]  $ ...future.FUN:function (x, ...)  
[17:59:24.452]  $ ...          :List of 1
[17:59:24.452]   ..$ singular.ok: logi FALSE
[17:59:24.452]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.452]  - attr(*, "where")=List of 2
[17:59:24.452]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.452]   ..$ ...          :<environment: 0x62649ff41388> 
[17:59:24.452]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.452]  - attr(*, "resolved")= logi FALSE
[17:59:24.452]  - attr(*, "total_size")= num 5384
[17:59:24.460] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:24.460] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.461] Number of futures (= number of chunks): 1
[17:59:24.461] Launching 1 futures (chunks) ...
[17:59:24.461] Chunk #1 of 1 ...
[17:59:24.461]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.462] getGlobalsAndPackages() ...
[17:59:24.462] Searching for globals...
[17:59:24.463] 
[17:59:24.463] Searching for globals ... DONE
[17:59:24.463] - globals: [0] <none>
[17:59:24.463] getGlobalsAndPackages() ... DONE
[17:59:24.463]    + additional globals found: [n=0] 
[17:59:24.464]    + additional namespaces needed: [n=0] 
[17:59:24.464]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.464]  - seeds: <none>
[17:59:24.464]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.465] getGlobalsAndPackages() ...
[17:59:24.465] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.465] Resolving globals: FALSE
[17:59:24.466] Tweak future expression to call with '...' arguments ...
[17:59:24.466] {
[17:59:24.466]     do.call(function(...) {
[17:59:24.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.466]             on.exit(options(oopts), add = TRUE)
[17:59:24.466]         }
[17:59:24.466]         {
[17:59:24.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.466]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.466]             })
[17:59:24.466]         }
[17:59:24.466]     }, args = future.call.arguments)
[17:59:24.466] }
[17:59:24.466] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.467] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.467] 
[17:59:24.467] getGlobalsAndPackages() ... DONE
[17:59:24.468] run() for ‘Future’ ...
[17:59:24.468] - state: ‘created’
[17:59:24.468] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.475] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.475] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.475]   - Field: ‘label’
[17:59:24.475]   - Field: ‘local’
[17:59:24.476]   - Field: ‘owner’
[17:59:24.476]   - Field: ‘envir’
[17:59:24.476]   - Field: ‘packages’
[17:59:24.476]   - Field: ‘gc’
[17:59:24.476]   - Field: ‘conditions’
[17:59:24.477]   - Field: ‘expr’
[17:59:24.477]   - Field: ‘uuid’
[17:59:24.477]   - Field: ‘seed’
[17:59:24.477]   - Field: ‘version’
[17:59:24.477]   - Field: ‘result’
[17:59:24.478]   - Field: ‘asynchronous’
[17:59:24.478]   - Field: ‘calls’
[17:59:24.478]   - Field: ‘globals’
[17:59:24.478]   - Field: ‘stdout’
[17:59:24.478]   - Field: ‘earlySignal’
[17:59:24.479]   - Field: ‘lazy’
[17:59:24.479]   - Field: ‘state’
[17:59:24.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.479] - Launch lazy future ...
[17:59:24.480] Packages needed by the future expression (n = 1): ‘stats’
[17:59:24.480] Packages needed by future strategies (n = 0): <none>
[17:59:24.481] {
[17:59:24.481]     {
[17:59:24.481]         {
[17:59:24.481]             ...future.startTime <- base::Sys.time()
[17:59:24.481]             {
[17:59:24.481]                 {
[17:59:24.481]                   {
[17:59:24.481]                     {
[17:59:24.481]                       base::local({
[17:59:24.481]                         has_future <- base::requireNamespace("future", 
[17:59:24.481]                           quietly = TRUE)
[17:59:24.481]                         if (has_future) {
[17:59:24.481]                           ns <- base::getNamespace("future")
[17:59:24.481]                           version <- ns[[".package"]][["version"]]
[17:59:24.481]                           if (is.null(version)) 
[17:59:24.481]                             version <- utils::packageVersion("future")
[17:59:24.481]                         }
[17:59:24.481]                         else {
[17:59:24.481]                           version <- NULL
[17:59:24.481]                         }
[17:59:24.481]                         if (!has_future || version < "1.8.0") {
[17:59:24.481]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.481]                             "", base::R.version$version.string), 
[17:59:24.481]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:24.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.481]                               "release", "version")], collapse = " "), 
[17:59:24.481]                             hostname = base::Sys.info()[["nodename"]])
[17:59:24.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.481]                             info)
[17:59:24.481]                           info <- base::paste(info, collapse = "; ")
[17:59:24.481]                           if (!has_future) {
[17:59:24.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.481]                               info)
[17:59:24.481]                           }
[17:59:24.481]                           else {
[17:59:24.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.481]                               info, version)
[17:59:24.481]                           }
[17:59:24.481]                           base::stop(msg)
[17:59:24.481]                         }
[17:59:24.481]                       })
[17:59:24.481]                     }
[17:59:24.481]                     base::local({
[17:59:24.481]                       for (pkg in "stats") {
[17:59:24.481]                         base::loadNamespace(pkg)
[17:59:24.481]                         base::library(pkg, character.only = TRUE)
[17:59:24.481]                       }
[17:59:24.481]                     })
[17:59:24.481]                   }
[17:59:24.481]                   ...future.strategy.old <- future::plan("list")
[17:59:24.481]                   options(future.plan = NULL)
[17:59:24.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.481]                 }
[17:59:24.481]                 ...future.workdir <- getwd()
[17:59:24.481]             }
[17:59:24.481]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.481]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.481]         }
[17:59:24.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.481]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.481]             base::names(...future.oldOptions))
[17:59:24.481]     }
[17:59:24.481]     if (FALSE) {
[17:59:24.481]     }
[17:59:24.481]     else {
[17:59:24.481]         if (TRUE) {
[17:59:24.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.481]                 open = "w")
[17:59:24.481]         }
[17:59:24.481]         else {
[17:59:24.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.481]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.481]         }
[17:59:24.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.481]             base::sink(type = "output", split = FALSE)
[17:59:24.481]             base::close(...future.stdout)
[17:59:24.481]         }, add = TRUE)
[17:59:24.481]     }
[17:59:24.481]     ...future.frame <- base::sys.nframe()
[17:59:24.481]     ...future.conditions <- base::list()
[17:59:24.481]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.481]     if (FALSE) {
[17:59:24.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.481]     }
[17:59:24.481]     ...future.result <- base::tryCatch({
[17:59:24.481]         base::withCallingHandlers({
[17:59:24.481]             ...future.value <- base::withVisible(base::local({
[17:59:24.481]                 do.call(function(...) {
[17:59:24.481]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.481]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.481]                     ...future.globals.maxSize)) {
[17:59:24.481]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.481]                     on.exit(options(oopts), add = TRUE)
[17:59:24.481]                   }
[17:59:24.481]                   {
[17:59:24.481]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.481]                       FUN = function(jj) {
[17:59:24.481]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.481]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.481]                       })
[17:59:24.481]                   }
[17:59:24.481]                 }, args = future.call.arguments)
[17:59:24.481]             }))
[17:59:24.481]             future::FutureResult(value = ...future.value$value, 
[17:59:24.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.481]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.481]                     ...future.globalenv.names))
[17:59:24.481]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.481]         }, condition = base::local({
[17:59:24.481]             c <- base::c
[17:59:24.481]             inherits <- base::inherits
[17:59:24.481]             invokeRestart <- base::invokeRestart
[17:59:24.481]             length <- base::length
[17:59:24.481]             list <- base::list
[17:59:24.481]             seq.int <- base::seq.int
[17:59:24.481]             signalCondition <- base::signalCondition
[17:59:24.481]             sys.calls <- base::sys.calls
[17:59:24.481]             `[[` <- base::`[[`
[17:59:24.481]             `+` <- base::`+`
[17:59:24.481]             `<<-` <- base::`<<-`
[17:59:24.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.481]                   3L)]
[17:59:24.481]             }
[17:59:24.481]             function(cond) {
[17:59:24.481]                 is_error <- inherits(cond, "error")
[17:59:24.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.481]                   NULL)
[17:59:24.481]                 if (is_error) {
[17:59:24.481]                   sessionInformation <- function() {
[17:59:24.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.481]                       search = base::search(), system = base::Sys.info())
[17:59:24.481]                   }
[17:59:24.481]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.481]                     cond$call), session = sessionInformation(), 
[17:59:24.481]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.481]                   signalCondition(cond)
[17:59:24.481]                 }
[17:59:24.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.481]                 "immediateCondition"))) {
[17:59:24.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.481]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.481]                   if (TRUE && !signal) {
[17:59:24.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.481]                     {
[17:59:24.481]                       inherits <- base::inherits
[17:59:24.481]                       invokeRestart <- base::invokeRestart
[17:59:24.481]                       is.null <- base::is.null
[17:59:24.481]                       muffled <- FALSE
[17:59:24.481]                       if (inherits(cond, "message")) {
[17:59:24.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.481]                         if (muffled) 
[17:59:24.481]                           invokeRestart("muffleMessage")
[17:59:24.481]                       }
[17:59:24.481]                       else if (inherits(cond, "warning")) {
[17:59:24.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.481]                         if (muffled) 
[17:59:24.481]                           invokeRestart("muffleWarning")
[17:59:24.481]                       }
[17:59:24.481]                       else if (inherits(cond, "condition")) {
[17:59:24.481]                         if (!is.null(pattern)) {
[17:59:24.481]                           computeRestarts <- base::computeRestarts
[17:59:24.481]                           grepl <- base::grepl
[17:59:24.481]                           restarts <- computeRestarts(cond)
[17:59:24.481]                           for (restart in restarts) {
[17:59:24.481]                             name <- restart$name
[17:59:24.481]                             if (is.null(name)) 
[17:59:24.481]                               next
[17:59:24.481]                             if (!grepl(pattern, name)) 
[17:59:24.481]                               next
[17:59:24.481]                             invokeRestart(restart)
[17:59:24.481]                             muffled <- TRUE
[17:59:24.481]                             break
[17:59:24.481]                           }
[17:59:24.481]                         }
[17:59:24.481]                       }
[17:59:24.481]                       invisible(muffled)
[17:59:24.481]                     }
[17:59:24.481]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.481]                   }
[17:59:24.481]                 }
[17:59:24.481]                 else {
[17:59:24.481]                   if (TRUE) {
[17:59:24.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.481]                     {
[17:59:24.481]                       inherits <- base::inherits
[17:59:24.481]                       invokeRestart <- base::invokeRestart
[17:59:24.481]                       is.null <- base::is.null
[17:59:24.481]                       muffled <- FALSE
[17:59:24.481]                       if (inherits(cond, "message")) {
[17:59:24.481]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.481]                         if (muffled) 
[17:59:24.481]                           invokeRestart("muffleMessage")
[17:59:24.481]                       }
[17:59:24.481]                       else if (inherits(cond, "warning")) {
[17:59:24.481]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.481]                         if (muffled) 
[17:59:24.481]                           invokeRestart("muffleWarning")
[17:59:24.481]                       }
[17:59:24.481]                       else if (inherits(cond, "condition")) {
[17:59:24.481]                         if (!is.null(pattern)) {
[17:59:24.481]                           computeRestarts <- base::computeRestarts
[17:59:24.481]                           grepl <- base::grepl
[17:59:24.481]                           restarts <- computeRestarts(cond)
[17:59:24.481]                           for (restart in restarts) {
[17:59:24.481]                             name <- restart$name
[17:59:24.481]                             if (is.null(name)) 
[17:59:24.481]                               next
[17:59:24.481]                             if (!grepl(pattern, name)) 
[17:59:24.481]                               next
[17:59:24.481]                             invokeRestart(restart)
[17:59:24.481]                             muffled <- TRUE
[17:59:24.481]                             break
[17:59:24.481]                           }
[17:59:24.481]                         }
[17:59:24.481]                       }
[17:59:24.481]                       invisible(muffled)
[17:59:24.481]                     }
[17:59:24.481]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.481]                   }
[17:59:24.481]                 }
[17:59:24.481]             }
[17:59:24.481]         }))
[17:59:24.481]     }, error = function(ex) {
[17:59:24.481]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.481]                 ...future.rng), started = ...future.startTime, 
[17:59:24.481]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.481]             version = "1.8"), class = "FutureResult")
[17:59:24.481]     }, finally = {
[17:59:24.481]         if (!identical(...future.workdir, getwd())) 
[17:59:24.481]             setwd(...future.workdir)
[17:59:24.481]         {
[17:59:24.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.481]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.481]             }
[17:59:24.481]             base::options(...future.oldOptions)
[17:59:24.481]             if (.Platform$OS.type == "windows") {
[17:59:24.481]                 old_names <- names(...future.oldEnvVars)
[17:59:24.481]                 envs <- base::Sys.getenv()
[17:59:24.481]                 names <- names(envs)
[17:59:24.481]                 common <- intersect(names, old_names)
[17:59:24.481]                 added <- setdiff(names, old_names)
[17:59:24.481]                 removed <- setdiff(old_names, names)
[17:59:24.481]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.481]                   envs[common]]
[17:59:24.481]                 NAMES <- toupper(changed)
[17:59:24.481]                 args <- list()
[17:59:24.481]                 for (kk in seq_along(NAMES)) {
[17:59:24.481]                   name <- changed[[kk]]
[17:59:24.481]                   NAME <- NAMES[[kk]]
[17:59:24.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.481]                     next
[17:59:24.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.481]                 }
[17:59:24.481]                 NAMES <- toupper(added)
[17:59:24.481]                 for (kk in seq_along(NAMES)) {
[17:59:24.481]                   name <- added[[kk]]
[17:59:24.481]                   NAME <- NAMES[[kk]]
[17:59:24.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.481]                     next
[17:59:24.481]                   args[[name]] <- ""
[17:59:24.481]                 }
[17:59:24.481]                 NAMES <- toupper(removed)
[17:59:24.481]                 for (kk in seq_along(NAMES)) {
[17:59:24.481]                   name <- removed[[kk]]
[17:59:24.481]                   NAME <- NAMES[[kk]]
[17:59:24.481]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.481]                     next
[17:59:24.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.481]                 }
[17:59:24.481]                 if (length(args) > 0) 
[17:59:24.481]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.481]             }
[17:59:24.481]             else {
[17:59:24.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.481]             }
[17:59:24.481]             {
[17:59:24.481]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.481]                   0L) {
[17:59:24.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.481]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.481]                   base::options(opts)
[17:59:24.481]                 }
[17:59:24.481]                 {
[17:59:24.481]                   {
[17:59:24.481]                     NULL
[17:59:24.481]                     RNGkind("Mersenne-Twister")
[17:59:24.481]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.481]                       inherits = FALSE)
[17:59:24.481]                   }
[17:59:24.481]                   options(future.plan = NULL)
[17:59:24.481]                   if (is.na(NA_character_)) 
[17:59:24.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.481]                     .init = FALSE)
[17:59:24.481]                 }
[17:59:24.481]             }
[17:59:24.481]         }
[17:59:24.481]     })
[17:59:24.481]     if (TRUE) {
[17:59:24.481]         base::sink(type = "output", split = FALSE)
[17:59:24.481]         if (TRUE) {
[17:59:24.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.481]         }
[17:59:24.481]         else {
[17:59:24.481]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.481]         }
[17:59:24.481]         base::close(...future.stdout)
[17:59:24.481]         ...future.stdout <- NULL
[17:59:24.481]     }
[17:59:24.481]     ...future.result$conditions <- ...future.conditions
[17:59:24.481]     ...future.result$finished <- base::Sys.time()
[17:59:24.481]     ...future.result
[17:59:24.481] }
[17:59:24.484] assign_globals() ...
[17:59:24.484] List of 5
[17:59:24.484]  $ ...future.FUN            :function (x, ...)  
[17:59:24.484]  $ future.call.arguments    :List of 1
[17:59:24.484]   ..$ singular.ok: logi FALSE
[17:59:24.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.484]  $ ...future.elements_ii    :List of 3
[17:59:24.484]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.484]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.484]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.484]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.484]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.484]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.484]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.484]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:24.484]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.484]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.484]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.484]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:24.484]  $ ...future.seeds_ii       : NULL
[17:59:24.484]  $ ...future.globals.maxSize: NULL
[17:59:24.484]  - attr(*, "where")=List of 5
[17:59:24.484]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.484]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.484]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.484]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.484]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.484]  - attr(*, "resolved")= logi FALSE
[17:59:24.484]  - attr(*, "total_size")= num 5384
[17:59:24.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.484]  - attr(*, "already-done")= logi TRUE
[17:59:24.536] - reassign environment for ‘...future.FUN’
[17:59:24.536] - copied ‘...future.FUN’ to environment
[17:59:24.536] - copied ‘future.call.arguments’ to environment
[17:59:24.536] - copied ‘...future.elements_ii’ to environment
[17:59:24.537] - copied ‘...future.seeds_ii’ to environment
[17:59:24.537] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.537] assign_globals() ... done
[17:59:24.538] plan(): Setting new future strategy stack:
[17:59:24.538] List of future strategies:
[17:59:24.538] 1. sequential:
[17:59:24.538]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.538]    - tweaked: FALSE
[17:59:24.538]    - call: NULL
[17:59:24.539] plan(): nbrOfWorkers() = 1
[17:59:24.545] plan(): Setting new future strategy stack:
[17:59:24.546] List of future strategies:
[17:59:24.546] 1. multicore:
[17:59:24.546]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.546]    - tweaked: FALSE
[17:59:24.546]    - call: plan(strategy)
[17:59:24.552] plan(): nbrOfWorkers() = 1
[17:59:24.553] SequentialFuture started (and completed)
[17:59:24.553] - Launch lazy future ... done
[17:59:24.553] run() for ‘SequentialFuture’ ... done
[17:59:24.554] Created future:
[17:59:24.554] SequentialFuture:
[17:59:24.554] Label: ‘future_by-1’
[17:59:24.554] Expression:
[17:59:24.554] {
[17:59:24.554]     do.call(function(...) {
[17:59:24.554]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.554]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.554]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.554]             on.exit(options(oopts), add = TRUE)
[17:59:24.554]         }
[17:59:24.554]         {
[17:59:24.554]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.554]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.554]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.554]             })
[17:59:24.554]         }
[17:59:24.554]     }, args = future.call.arguments)
[17:59:24.554] }
[17:59:24.554] Lazy evaluation: FALSE
[17:59:24.554] Asynchronous evaluation: FALSE
[17:59:24.554] Local evaluation: TRUE
[17:59:24.554] Environment: R_GlobalEnv
[17:59:24.554] Capture standard output: TRUE
[17:59:24.554] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.554] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.554] Packages: 1 packages (‘stats’)
[17:59:24.554] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.554] Resolved: TRUE
[17:59:24.554] Value: 26.06 KiB of class ‘list’
[17:59:24.554] Early signaling: FALSE
[17:59:24.554] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.554] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.557] Chunk #1 of 1 ... DONE
[17:59:24.558] Launching 1 futures (chunks) ... DONE
[17:59:24.558] Resolving 1 futures (chunks) ...
[17:59:24.558] resolve() on list ...
[17:59:24.558]  recursive: 0
[17:59:24.558]  length: 1
[17:59:24.559] 
[17:59:24.559] resolved() for ‘SequentialFuture’ ...
[17:59:24.559] - state: ‘finished’
[17:59:24.559] - run: TRUE
[17:59:24.559] - result: ‘FutureResult’
[17:59:24.560] resolved() for ‘SequentialFuture’ ... done
[17:59:24.560] Future #1
[17:59:24.560] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.560] - nx: 1
[17:59:24.561] - relay: TRUE
[17:59:24.561] - stdout: TRUE
[17:59:24.561] - signal: TRUE
[17:59:24.561] - resignal: FALSE
[17:59:24.561] - force: TRUE
[17:59:24.562] - relayed: [n=1] FALSE
[17:59:24.562] - queued futures: [n=1] FALSE
[17:59:24.562]  - until=1
[17:59:24.562]  - relaying element #1
[17:59:24.563] - relayed: [n=1] TRUE
[17:59:24.563] - queued futures: [n=1] TRUE
[17:59:24.563] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.563]  length: 0 (resolved future 1)
[17:59:24.563] Relaying remaining futures
[17:59:24.564] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.564] - nx: 1
[17:59:24.564] - relay: TRUE
[17:59:24.564] - stdout: TRUE
[17:59:24.564] - signal: TRUE
[17:59:24.564] - resignal: FALSE
[17:59:24.565] - force: TRUE
[17:59:24.565] - relayed: [n=1] TRUE
[17:59:24.565] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.565] - relayed: [n=1] TRUE
[17:59:24.566] - queued futures: [n=1] TRUE
[17:59:24.566] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.566] resolve() on list ... DONE
[17:59:24.566]  - Number of value chunks collected: 1
[17:59:24.567] Resolving 1 futures (chunks) ... DONE
[17:59:24.567] Reducing values from 1 chunks ...
[17:59:24.567]  - Number of values collected after concatenation: 3
[17:59:24.567]  - Number of values expected: 3
[17:59:24.567] Reducing values from 1 chunks ... DONE
[17:59:24.567] future_lapply() ... DONE
[17:59:24.568] future_by_internal() ... DONE
[17:59:24.580] future_by_internal() ...
[17:59:24.580] future_lapply() ...
[17:59:24.587] Number of chunks: 1
[17:59:24.588] getGlobalsAndPackagesXApply() ...
[17:59:24.588]  - future.globals: TRUE
[17:59:24.588] getGlobalsAndPackages() ...
[17:59:24.588] Searching for globals...
[17:59:24.592] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:24.592] Searching for globals ... DONE
[17:59:24.592] Resolving globals: FALSE
[17:59:24.593] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:59:24.594] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:59:24.594] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:24.594] - packages: [1] ‘stats’
[17:59:24.595] getGlobalsAndPackages() ... DONE
[17:59:24.595]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:24.595]  - needed namespaces: [n=1] ‘stats’
[17:59:24.595] Finding globals ... DONE
[17:59:24.596]  - use_args: TRUE
[17:59:24.596]  - Getting '...' globals ...
[17:59:24.596] resolve() on list ...
[17:59:24.597]  recursive: 0
[17:59:24.597]  length: 1
[17:59:24.597]  elements: ‘...’
[17:59:24.597]  length: 0 (resolved future 1)
[17:59:24.597] resolve() on list ... DONE
[17:59:24.598]    - '...' content: [n=0] 
[17:59:24.598] List of 1
[17:59:24.598]  $ ...: list()
[17:59:24.598]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.598]  - attr(*, "where")=List of 1
[17:59:24.598]   ..$ ...:<environment: 0x62649e749280> 
[17:59:24.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.598]  - attr(*, "resolved")= logi TRUE
[17:59:24.598]  - attr(*, "total_size")= num NA
[17:59:24.603]  - Getting '...' globals ... DONE
[17:59:24.603] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:59:24.603] List of 4
[17:59:24.603]  $ ...future.FUN:function (x)  
[17:59:24.603]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:24.603]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.603]  $ ...          : list()
[17:59:24.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.603]  - attr(*, "where")=List of 4
[17:59:24.603]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.603]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:59:24.603]   ..$ wool         :<environment: R_EmptyEnv> 
[17:59:24.603]   ..$ ...          :<environment: 0x62649e749280> 
[17:59:24.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.603]  - attr(*, "resolved")= logi FALSE
[17:59:24.603]  - attr(*, "total_size")= num 2320
[17:59:24.611] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:24.611] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.612] Number of futures (= number of chunks): 1
[17:59:24.612] Launching 1 futures (chunks) ...
[17:59:24.612] Chunk #1 of 1 ...
[17:59:24.613]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.613] getGlobalsAndPackages() ...
[17:59:24.613] Searching for globals...
[17:59:24.614] 
[17:59:24.614] Searching for globals ... DONE
[17:59:24.615] - globals: [0] <none>
[17:59:24.615] getGlobalsAndPackages() ... DONE
[17:59:24.615]    + additional globals found: [n=0] 
[17:59:24.615]    + additional namespaces needed: [n=0] 
[17:59:24.615]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.615]  - seeds: <none>
[17:59:24.616]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.616] getGlobalsAndPackages() ...
[17:59:24.616] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.616] Resolving globals: FALSE
[17:59:24.617] Tweak future expression to call with '...' arguments ...
[17:59:24.617] {
[17:59:24.617]     do.call(function(...) {
[17:59:24.617]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.617]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.617]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.617]             on.exit(options(oopts), add = TRUE)
[17:59:24.617]         }
[17:59:24.617]         {
[17:59:24.617]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.617]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.617]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.617]             })
[17:59:24.617]         }
[17:59:24.617]     }, args = future.call.arguments)
[17:59:24.617] }
[17:59:24.617] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.618] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.618] 
[17:59:24.619] getGlobalsAndPackages() ... DONE
[17:59:24.621] run() for ‘Future’ ...
[17:59:24.621] - state: ‘created’
[17:59:24.622] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.628] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.629]   - Field: ‘label’
[17:59:24.629]   - Field: ‘local’
[17:59:24.629]   - Field: ‘owner’
[17:59:24.629]   - Field: ‘envir’
[17:59:24.630]   - Field: ‘packages’
[17:59:24.630]   - Field: ‘gc’
[17:59:24.630]   - Field: ‘conditions’
[17:59:24.630]   - Field: ‘expr’
[17:59:24.631]   - Field: ‘uuid’
[17:59:24.631]   - Field: ‘seed’
[17:59:24.631]   - Field: ‘version’
[17:59:24.631]   - Field: ‘result’
[17:59:24.631]   - Field: ‘asynchronous’
[17:59:24.632]   - Field: ‘calls’
[17:59:24.632]   - Field: ‘globals’
[17:59:24.632]   - Field: ‘stdout’
[17:59:24.632]   - Field: ‘earlySignal’
[17:59:24.632]   - Field: ‘lazy’
[17:59:24.633]   - Field: ‘state’
[17:59:24.633] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.633] - Launch lazy future ...
[17:59:24.633] Packages needed by the future expression (n = 1): ‘stats’
[17:59:24.634] Packages needed by future strategies (n = 0): <none>
[17:59:24.635] {
[17:59:24.635]     {
[17:59:24.635]         {
[17:59:24.635]             ...future.startTime <- base::Sys.time()
[17:59:24.635]             {
[17:59:24.635]                 {
[17:59:24.635]                   {
[17:59:24.635]                     {
[17:59:24.635]                       base::local({
[17:59:24.635]                         has_future <- base::requireNamespace("future", 
[17:59:24.635]                           quietly = TRUE)
[17:59:24.635]                         if (has_future) {
[17:59:24.635]                           ns <- base::getNamespace("future")
[17:59:24.635]                           version <- ns[[".package"]][["version"]]
[17:59:24.635]                           if (is.null(version)) 
[17:59:24.635]                             version <- utils::packageVersion("future")
[17:59:24.635]                         }
[17:59:24.635]                         else {
[17:59:24.635]                           version <- NULL
[17:59:24.635]                         }
[17:59:24.635]                         if (!has_future || version < "1.8.0") {
[17:59:24.635]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.635]                             "", base::R.version$version.string), 
[17:59:24.635]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:24.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.635]                               "release", "version")], collapse = " "), 
[17:59:24.635]                             hostname = base::Sys.info()[["nodename"]])
[17:59:24.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.635]                             info)
[17:59:24.635]                           info <- base::paste(info, collapse = "; ")
[17:59:24.635]                           if (!has_future) {
[17:59:24.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.635]                               info)
[17:59:24.635]                           }
[17:59:24.635]                           else {
[17:59:24.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.635]                               info, version)
[17:59:24.635]                           }
[17:59:24.635]                           base::stop(msg)
[17:59:24.635]                         }
[17:59:24.635]                       })
[17:59:24.635]                     }
[17:59:24.635]                     base::local({
[17:59:24.635]                       for (pkg in "stats") {
[17:59:24.635]                         base::loadNamespace(pkg)
[17:59:24.635]                         base::library(pkg, character.only = TRUE)
[17:59:24.635]                       }
[17:59:24.635]                     })
[17:59:24.635]                   }
[17:59:24.635]                   ...future.strategy.old <- future::plan("list")
[17:59:24.635]                   options(future.plan = NULL)
[17:59:24.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.635]                 }
[17:59:24.635]                 ...future.workdir <- getwd()
[17:59:24.635]             }
[17:59:24.635]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.635]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.635]         }
[17:59:24.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.635]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.635]             base::names(...future.oldOptions))
[17:59:24.635]     }
[17:59:24.635]     if (FALSE) {
[17:59:24.635]     }
[17:59:24.635]     else {
[17:59:24.635]         if (TRUE) {
[17:59:24.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.635]                 open = "w")
[17:59:24.635]         }
[17:59:24.635]         else {
[17:59:24.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.635]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.635]         }
[17:59:24.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.635]             base::sink(type = "output", split = FALSE)
[17:59:24.635]             base::close(...future.stdout)
[17:59:24.635]         }, add = TRUE)
[17:59:24.635]     }
[17:59:24.635]     ...future.frame <- base::sys.nframe()
[17:59:24.635]     ...future.conditions <- base::list()
[17:59:24.635]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.635]     if (FALSE) {
[17:59:24.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.635]     }
[17:59:24.635]     ...future.result <- base::tryCatch({
[17:59:24.635]         base::withCallingHandlers({
[17:59:24.635]             ...future.value <- base::withVisible(base::local({
[17:59:24.635]                 do.call(function(...) {
[17:59:24.635]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.635]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.635]                     ...future.globals.maxSize)) {
[17:59:24.635]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.635]                     on.exit(options(oopts), add = TRUE)
[17:59:24.635]                   }
[17:59:24.635]                   {
[17:59:24.635]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.635]                       FUN = function(jj) {
[17:59:24.635]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.635]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.635]                       })
[17:59:24.635]                   }
[17:59:24.635]                 }, args = future.call.arguments)
[17:59:24.635]             }))
[17:59:24.635]             future::FutureResult(value = ...future.value$value, 
[17:59:24.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.635]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.635]                     ...future.globalenv.names))
[17:59:24.635]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.635]         }, condition = base::local({
[17:59:24.635]             c <- base::c
[17:59:24.635]             inherits <- base::inherits
[17:59:24.635]             invokeRestart <- base::invokeRestart
[17:59:24.635]             length <- base::length
[17:59:24.635]             list <- base::list
[17:59:24.635]             seq.int <- base::seq.int
[17:59:24.635]             signalCondition <- base::signalCondition
[17:59:24.635]             sys.calls <- base::sys.calls
[17:59:24.635]             `[[` <- base::`[[`
[17:59:24.635]             `+` <- base::`+`
[17:59:24.635]             `<<-` <- base::`<<-`
[17:59:24.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.635]                   3L)]
[17:59:24.635]             }
[17:59:24.635]             function(cond) {
[17:59:24.635]                 is_error <- inherits(cond, "error")
[17:59:24.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.635]                   NULL)
[17:59:24.635]                 if (is_error) {
[17:59:24.635]                   sessionInformation <- function() {
[17:59:24.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.635]                       search = base::search(), system = base::Sys.info())
[17:59:24.635]                   }
[17:59:24.635]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.635]                     cond$call), session = sessionInformation(), 
[17:59:24.635]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.635]                   signalCondition(cond)
[17:59:24.635]                 }
[17:59:24.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.635]                 "immediateCondition"))) {
[17:59:24.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.635]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.635]                   if (TRUE && !signal) {
[17:59:24.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.635]                     {
[17:59:24.635]                       inherits <- base::inherits
[17:59:24.635]                       invokeRestart <- base::invokeRestart
[17:59:24.635]                       is.null <- base::is.null
[17:59:24.635]                       muffled <- FALSE
[17:59:24.635]                       if (inherits(cond, "message")) {
[17:59:24.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.635]                         if (muffled) 
[17:59:24.635]                           invokeRestart("muffleMessage")
[17:59:24.635]                       }
[17:59:24.635]                       else if (inherits(cond, "warning")) {
[17:59:24.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.635]                         if (muffled) 
[17:59:24.635]                           invokeRestart("muffleWarning")
[17:59:24.635]                       }
[17:59:24.635]                       else if (inherits(cond, "condition")) {
[17:59:24.635]                         if (!is.null(pattern)) {
[17:59:24.635]                           computeRestarts <- base::computeRestarts
[17:59:24.635]                           grepl <- base::grepl
[17:59:24.635]                           restarts <- computeRestarts(cond)
[17:59:24.635]                           for (restart in restarts) {
[17:59:24.635]                             name <- restart$name
[17:59:24.635]                             if (is.null(name)) 
[17:59:24.635]                               next
[17:59:24.635]                             if (!grepl(pattern, name)) 
[17:59:24.635]                               next
[17:59:24.635]                             invokeRestart(restart)
[17:59:24.635]                             muffled <- TRUE
[17:59:24.635]                             break
[17:59:24.635]                           }
[17:59:24.635]                         }
[17:59:24.635]                       }
[17:59:24.635]                       invisible(muffled)
[17:59:24.635]                     }
[17:59:24.635]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.635]                   }
[17:59:24.635]                 }
[17:59:24.635]                 else {
[17:59:24.635]                   if (TRUE) {
[17:59:24.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.635]                     {
[17:59:24.635]                       inherits <- base::inherits
[17:59:24.635]                       invokeRestart <- base::invokeRestart
[17:59:24.635]                       is.null <- base::is.null
[17:59:24.635]                       muffled <- FALSE
[17:59:24.635]                       if (inherits(cond, "message")) {
[17:59:24.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.635]                         if (muffled) 
[17:59:24.635]                           invokeRestart("muffleMessage")
[17:59:24.635]                       }
[17:59:24.635]                       else if (inherits(cond, "warning")) {
[17:59:24.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.635]                         if (muffled) 
[17:59:24.635]                           invokeRestart("muffleWarning")
[17:59:24.635]                       }
[17:59:24.635]                       else if (inherits(cond, "condition")) {
[17:59:24.635]                         if (!is.null(pattern)) {
[17:59:24.635]                           computeRestarts <- base::computeRestarts
[17:59:24.635]                           grepl <- base::grepl
[17:59:24.635]                           restarts <- computeRestarts(cond)
[17:59:24.635]                           for (restart in restarts) {
[17:59:24.635]                             name <- restart$name
[17:59:24.635]                             if (is.null(name)) 
[17:59:24.635]                               next
[17:59:24.635]                             if (!grepl(pattern, name)) 
[17:59:24.635]                               next
[17:59:24.635]                             invokeRestart(restart)
[17:59:24.635]                             muffled <- TRUE
[17:59:24.635]                             break
[17:59:24.635]                           }
[17:59:24.635]                         }
[17:59:24.635]                       }
[17:59:24.635]                       invisible(muffled)
[17:59:24.635]                     }
[17:59:24.635]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.635]                   }
[17:59:24.635]                 }
[17:59:24.635]             }
[17:59:24.635]         }))
[17:59:24.635]     }, error = function(ex) {
[17:59:24.635]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.635]                 ...future.rng), started = ...future.startTime, 
[17:59:24.635]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.635]             version = "1.8"), class = "FutureResult")
[17:59:24.635]     }, finally = {
[17:59:24.635]         if (!identical(...future.workdir, getwd())) 
[17:59:24.635]             setwd(...future.workdir)
[17:59:24.635]         {
[17:59:24.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.635]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.635]             }
[17:59:24.635]             base::options(...future.oldOptions)
[17:59:24.635]             if (.Platform$OS.type == "windows") {
[17:59:24.635]                 old_names <- names(...future.oldEnvVars)
[17:59:24.635]                 envs <- base::Sys.getenv()
[17:59:24.635]                 names <- names(envs)
[17:59:24.635]                 common <- intersect(names, old_names)
[17:59:24.635]                 added <- setdiff(names, old_names)
[17:59:24.635]                 removed <- setdiff(old_names, names)
[17:59:24.635]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.635]                   envs[common]]
[17:59:24.635]                 NAMES <- toupper(changed)
[17:59:24.635]                 args <- list()
[17:59:24.635]                 for (kk in seq_along(NAMES)) {
[17:59:24.635]                   name <- changed[[kk]]
[17:59:24.635]                   NAME <- NAMES[[kk]]
[17:59:24.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.635]                     next
[17:59:24.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.635]                 }
[17:59:24.635]                 NAMES <- toupper(added)
[17:59:24.635]                 for (kk in seq_along(NAMES)) {
[17:59:24.635]                   name <- added[[kk]]
[17:59:24.635]                   NAME <- NAMES[[kk]]
[17:59:24.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.635]                     next
[17:59:24.635]                   args[[name]] <- ""
[17:59:24.635]                 }
[17:59:24.635]                 NAMES <- toupper(removed)
[17:59:24.635]                 for (kk in seq_along(NAMES)) {
[17:59:24.635]                   name <- removed[[kk]]
[17:59:24.635]                   NAME <- NAMES[[kk]]
[17:59:24.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.635]                     next
[17:59:24.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.635]                 }
[17:59:24.635]                 if (length(args) > 0) 
[17:59:24.635]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.635]             }
[17:59:24.635]             else {
[17:59:24.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.635]             }
[17:59:24.635]             {
[17:59:24.635]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.635]                   0L) {
[17:59:24.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.635]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.635]                   base::options(opts)
[17:59:24.635]                 }
[17:59:24.635]                 {
[17:59:24.635]                   {
[17:59:24.635]                     NULL
[17:59:24.635]                     RNGkind("Mersenne-Twister")
[17:59:24.635]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.635]                       inherits = FALSE)
[17:59:24.635]                   }
[17:59:24.635]                   options(future.plan = NULL)
[17:59:24.635]                   if (is.na(NA_character_)) 
[17:59:24.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.635]                     .init = FALSE)
[17:59:24.635]                 }
[17:59:24.635]             }
[17:59:24.635]         }
[17:59:24.635]     })
[17:59:24.635]     if (TRUE) {
[17:59:24.635]         base::sink(type = "output", split = FALSE)
[17:59:24.635]         if (TRUE) {
[17:59:24.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.635]         }
[17:59:24.635]         else {
[17:59:24.635]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.635]         }
[17:59:24.635]         base::close(...future.stdout)
[17:59:24.635]         ...future.stdout <- NULL
[17:59:24.635]     }
[17:59:24.635]     ...future.result$conditions <- ...future.conditions
[17:59:24.635]     ...future.result$finished <- base::Sys.time()
[17:59:24.635]     ...future.result
[17:59:24.635] }
[17:59:24.638] assign_globals() ...
[17:59:24.639] List of 7
[17:59:24.639]  $ ...future.FUN            :function (x)  
[17:59:24.639]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:24.639]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.639]  $ future.call.arguments    : list()
[17:59:24.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.639]  $ ...future.elements_ii    :List of 3
[17:59:24.639]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.639]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.639]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.639]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.639]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.639]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.639]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.639]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:24.639]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.639]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.639]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.639]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:24.639]  $ ...future.seeds_ii       : NULL
[17:59:24.639]  $ ...future.globals.maxSize: NULL
[17:59:24.639]  - attr(*, "where")=List of 7
[17:59:24.639]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.639]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:59:24.639]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:59:24.639]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.639]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.639]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.639]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.639]  - attr(*, "resolved")= logi FALSE
[17:59:24.639]  - attr(*, "total_size")= num 2320
[17:59:24.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.639]  - attr(*, "already-done")= logi TRUE
[17:59:24.660] - reassign environment for ‘...future.FUN’
[17:59:24.660] - copied ‘...future.FUN’ to environment
[17:59:24.660] - copied ‘breaks’ to environment
[17:59:24.661] - copied ‘wool’ to environment
[17:59:24.661] - copied ‘future.call.arguments’ to environment
[17:59:24.661] - copied ‘...future.elements_ii’ to environment
[17:59:24.661] - copied ‘...future.seeds_ii’ to environment
[17:59:24.661] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.662] assign_globals() ... done
[17:59:24.662] plan(): Setting new future strategy stack:
[17:59:24.663] List of future strategies:
[17:59:24.663] 1. sequential:
[17:59:24.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.663]    - tweaked: FALSE
[17:59:24.663]    - call: NULL
[17:59:24.664] plan(): nbrOfWorkers() = 1
[17:59:24.669] plan(): Setting new future strategy stack:
[17:59:24.669] List of future strategies:
[17:59:24.669] 1. multicore:
[17:59:24.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.669]    - tweaked: FALSE
[17:59:24.669]    - call: plan(strategy)
[17:59:24.675] plan(): nbrOfWorkers() = 1
[17:59:24.676] SequentialFuture started (and completed)
[17:59:24.676] - Launch lazy future ... done
[17:59:24.676] run() for ‘SequentialFuture’ ... done
[17:59:24.676] Created future:
[17:59:24.677] SequentialFuture:
[17:59:24.677] Label: ‘future_by-1’
[17:59:24.677] Expression:
[17:59:24.677] {
[17:59:24.677]     do.call(function(...) {
[17:59:24.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.677]             on.exit(options(oopts), add = TRUE)
[17:59:24.677]         }
[17:59:24.677]         {
[17:59:24.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.677]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.677]             })
[17:59:24.677]         }
[17:59:24.677]     }, args = future.call.arguments)
[17:59:24.677] }
[17:59:24.677] Lazy evaluation: FALSE
[17:59:24.677] Asynchronous evaluation: FALSE
[17:59:24.677] Local evaluation: TRUE
[17:59:24.677] Environment: 0x62649e8f6740
[17:59:24.677] Capture standard output: TRUE
[17:59:24.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.677] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:59:24.677] Packages: 1 packages (‘stats’)
[17:59:24.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.677] Resolved: TRUE
[17:59:24.677] Value: 25.57 KiB of class ‘list’
[17:59:24.677] Early signaling: FALSE
[17:59:24.677] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.677] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.682] Chunk #1 of 1 ... DONE
[17:59:24.683] Launching 1 futures (chunks) ... DONE
[17:59:24.683] Resolving 1 futures (chunks) ...
[17:59:24.683] resolve() on list ...
[17:59:24.683]  recursive: 0
[17:59:24.683]  length: 1
[17:59:24.684] 
[17:59:24.684] resolved() for ‘SequentialFuture’ ...
[17:59:24.684] - state: ‘finished’
[17:59:24.684] - run: TRUE
[17:59:24.684] - result: ‘FutureResult’
[17:59:24.685] resolved() for ‘SequentialFuture’ ... done
[17:59:24.685] Future #1
[17:59:24.685] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.685] - nx: 1
[17:59:24.685] - relay: TRUE
[17:59:24.686] - stdout: TRUE
[17:59:24.686] - signal: TRUE
[17:59:24.686] - resignal: FALSE
[17:59:24.686] - force: TRUE
[17:59:24.686] - relayed: [n=1] FALSE
[17:59:24.687] - queued futures: [n=1] FALSE
[17:59:24.687]  - until=1
[17:59:24.687]  - relaying element #1
[17:59:24.687] - relayed: [n=1] TRUE
[17:59:24.688] - queued futures: [n=1] TRUE
[17:59:24.688] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.688]  length: 0 (resolved future 1)
[17:59:24.688] Relaying remaining futures
[17:59:24.688] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.688] - nx: 1
[17:59:24.689] - relay: TRUE
[17:59:24.689] - stdout: TRUE
[17:59:24.689] - signal: TRUE
[17:59:24.689] - resignal: FALSE
[17:59:24.689] - force: TRUE
[17:59:24.689] - relayed: [n=1] TRUE
[17:59:24.690] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.690] - relayed: [n=1] TRUE
[17:59:24.690] - queued futures: [n=1] TRUE
[17:59:24.690] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.691] resolve() on list ... DONE
[17:59:24.691]  - Number of value chunks collected: 1
[17:59:24.691] Resolving 1 futures (chunks) ... DONE
[17:59:24.691] Reducing values from 1 chunks ...
[17:59:24.691]  - Number of values collected after concatenation: 3
[17:59:24.692]  - Number of values expected: 3
[17:59:24.692] Reducing values from 1 chunks ... DONE
[17:59:24.692] future_lapply() ... DONE
[17:59:24.692] future_by_internal() ... DONE
[17:59:24.693] future_by_internal() ...
[17:59:24.694] future_lapply() ...
[17:59:24.700] Number of chunks: 1
[17:59:24.700] getGlobalsAndPackagesXApply() ...
[17:59:24.700]  - future.globals: TRUE
[17:59:24.700] getGlobalsAndPackages() ...
[17:59:24.701] Searching for globals...
[17:59:24.703] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.703] Searching for globals ... DONE
[17:59:24.703] Resolving globals: FALSE
[17:59:24.704] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.704] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.705] - globals: [1] ‘FUN’
[17:59:24.705] 
[17:59:24.705] getGlobalsAndPackages() ... DONE
[17:59:24.705]  - globals found/used: [n=1] ‘FUN’
[17:59:24.706]  - needed namespaces: [n=0] 
[17:59:24.706] Finding globals ... DONE
[17:59:24.706]  - use_args: TRUE
[17:59:24.706]  - Getting '...' globals ...
[17:59:24.707] resolve() on list ...
[17:59:24.707]  recursive: 0
[17:59:24.707]  length: 1
[17:59:24.707]  elements: ‘...’
[17:59:24.708]  length: 0 (resolved future 1)
[17:59:24.708] resolve() on list ... DONE
[17:59:24.708]    - '...' content: [n=0] 
[17:59:24.708] List of 1
[17:59:24.708]  $ ...: list()
[17:59:24.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.708]  - attr(*, "where")=List of 1
[17:59:24.708]   ..$ ...:<environment: 0x62649db4db28> 
[17:59:24.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.708]  - attr(*, "resolved")= logi TRUE
[17:59:24.708]  - attr(*, "total_size")= num NA
[17:59:24.713]  - Getting '...' globals ... DONE
[17:59:24.714] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.714] List of 2
[17:59:24.714]  $ ...future.FUN:function (object, ...)  
[17:59:24.714]  $ ...          : list()
[17:59:24.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.714]  - attr(*, "where")=List of 2
[17:59:24.714]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.714]   ..$ ...          :<environment: 0x62649db4db28> 
[17:59:24.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.714]  - attr(*, "resolved")= logi FALSE
[17:59:24.714]  - attr(*, "total_size")= num 1240
[17:59:24.719] Packages to be attached in all futures: [n=0] 
[17:59:24.719] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.720] Number of futures (= number of chunks): 1
[17:59:24.720] Launching 1 futures (chunks) ...
[17:59:24.720] Chunk #1 of 1 ...
[17:59:24.721]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.721] getGlobalsAndPackages() ...
[17:59:24.721] Searching for globals...
[17:59:24.722] 
[17:59:24.722] Searching for globals ... DONE
[17:59:24.722] - globals: [0] <none>
[17:59:24.722] getGlobalsAndPackages() ... DONE
[17:59:24.723]    + additional globals found: [n=0] 
[17:59:24.723]    + additional namespaces needed: [n=0] 
[17:59:24.723]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.723]  - seeds: <none>
[17:59:24.723]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.724] getGlobalsAndPackages() ...
[17:59:24.724] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.724] Resolving globals: FALSE
[17:59:24.724] Tweak future expression to call with '...' arguments ...
[17:59:24.725] {
[17:59:24.725]     do.call(function(...) {
[17:59:24.725]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.725]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.725]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.725]             on.exit(options(oopts), add = TRUE)
[17:59:24.725]         }
[17:59:24.725]         {
[17:59:24.725]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.725]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.725]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.725]             })
[17:59:24.725]         }
[17:59:24.725]     }, args = future.call.arguments)
[17:59:24.725] }
[17:59:24.725] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.726] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.726] 
[17:59:24.726] getGlobalsAndPackages() ... DONE
[17:59:24.727] run() for ‘Future’ ...
[17:59:24.727] - state: ‘created’
[17:59:24.727] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.736] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.736]   - Field: ‘label’
[17:59:24.737]   - Field: ‘local’
[17:59:24.737]   - Field: ‘owner’
[17:59:24.737]   - Field: ‘envir’
[17:59:24.737]   - Field: ‘packages’
[17:59:24.737]   - Field: ‘gc’
[17:59:24.738]   - Field: ‘conditions’
[17:59:24.738]   - Field: ‘expr’
[17:59:24.738]   - Field: ‘uuid’
[17:59:24.738]   - Field: ‘seed’
[17:59:24.738]   - Field: ‘version’
[17:59:24.739]   - Field: ‘result’
[17:59:24.739]   - Field: ‘asynchronous’
[17:59:24.739]   - Field: ‘calls’
[17:59:24.739]   - Field: ‘globals’
[17:59:24.740]   - Field: ‘stdout’
[17:59:24.740]   - Field: ‘earlySignal’
[17:59:24.740]   - Field: ‘lazy’
[17:59:24.740]   - Field: ‘state’
[17:59:24.740] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.741] - Launch lazy future ...
[17:59:24.741] Packages needed by the future expression (n = 0): <none>
[17:59:24.741] Packages needed by future strategies (n = 0): <none>
[17:59:24.742] {
[17:59:24.742]     {
[17:59:24.742]         {
[17:59:24.742]             ...future.startTime <- base::Sys.time()
[17:59:24.742]             {
[17:59:24.742]                 {
[17:59:24.742]                   {
[17:59:24.742]                     base::local({
[17:59:24.742]                       has_future <- base::requireNamespace("future", 
[17:59:24.742]                         quietly = TRUE)
[17:59:24.742]                       if (has_future) {
[17:59:24.742]                         ns <- base::getNamespace("future")
[17:59:24.742]                         version <- ns[[".package"]][["version"]]
[17:59:24.742]                         if (is.null(version)) 
[17:59:24.742]                           version <- utils::packageVersion("future")
[17:59:24.742]                       }
[17:59:24.742]                       else {
[17:59:24.742]                         version <- NULL
[17:59:24.742]                       }
[17:59:24.742]                       if (!has_future || version < "1.8.0") {
[17:59:24.742]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.742]                           "", base::R.version$version.string), 
[17:59:24.742]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.742]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.742]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.742]                             "release", "version")], collapse = " "), 
[17:59:24.742]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.742]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.742]                           info)
[17:59:24.742]                         info <- base::paste(info, collapse = "; ")
[17:59:24.742]                         if (!has_future) {
[17:59:24.742]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.742]                             info)
[17:59:24.742]                         }
[17:59:24.742]                         else {
[17:59:24.742]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.742]                             info, version)
[17:59:24.742]                         }
[17:59:24.742]                         base::stop(msg)
[17:59:24.742]                       }
[17:59:24.742]                     })
[17:59:24.742]                   }
[17:59:24.742]                   ...future.strategy.old <- future::plan("list")
[17:59:24.742]                   options(future.plan = NULL)
[17:59:24.742]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.742]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.742]                 }
[17:59:24.742]                 ...future.workdir <- getwd()
[17:59:24.742]             }
[17:59:24.742]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.742]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.742]         }
[17:59:24.742]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.742]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.742]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.742]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.742]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.742]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.742]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.742]             base::names(...future.oldOptions))
[17:59:24.742]     }
[17:59:24.742]     if (FALSE) {
[17:59:24.742]     }
[17:59:24.742]     else {
[17:59:24.742]         if (TRUE) {
[17:59:24.742]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.742]                 open = "w")
[17:59:24.742]         }
[17:59:24.742]         else {
[17:59:24.742]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.742]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.742]         }
[17:59:24.742]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.742]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.742]             base::sink(type = "output", split = FALSE)
[17:59:24.742]             base::close(...future.stdout)
[17:59:24.742]         }, add = TRUE)
[17:59:24.742]     }
[17:59:24.742]     ...future.frame <- base::sys.nframe()
[17:59:24.742]     ...future.conditions <- base::list()
[17:59:24.742]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.742]     if (FALSE) {
[17:59:24.742]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.742]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.742]     }
[17:59:24.742]     ...future.result <- base::tryCatch({
[17:59:24.742]         base::withCallingHandlers({
[17:59:24.742]             ...future.value <- base::withVisible(base::local({
[17:59:24.742]                 do.call(function(...) {
[17:59:24.742]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.742]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.742]                     ...future.globals.maxSize)) {
[17:59:24.742]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.742]                     on.exit(options(oopts), add = TRUE)
[17:59:24.742]                   }
[17:59:24.742]                   {
[17:59:24.742]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.742]                       FUN = function(jj) {
[17:59:24.742]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.742]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.742]                       })
[17:59:24.742]                   }
[17:59:24.742]                 }, args = future.call.arguments)
[17:59:24.742]             }))
[17:59:24.742]             future::FutureResult(value = ...future.value$value, 
[17:59:24.742]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.742]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.742]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.742]                     ...future.globalenv.names))
[17:59:24.742]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.742]         }, condition = base::local({
[17:59:24.742]             c <- base::c
[17:59:24.742]             inherits <- base::inherits
[17:59:24.742]             invokeRestart <- base::invokeRestart
[17:59:24.742]             length <- base::length
[17:59:24.742]             list <- base::list
[17:59:24.742]             seq.int <- base::seq.int
[17:59:24.742]             signalCondition <- base::signalCondition
[17:59:24.742]             sys.calls <- base::sys.calls
[17:59:24.742]             `[[` <- base::`[[`
[17:59:24.742]             `+` <- base::`+`
[17:59:24.742]             `<<-` <- base::`<<-`
[17:59:24.742]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.742]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.742]                   3L)]
[17:59:24.742]             }
[17:59:24.742]             function(cond) {
[17:59:24.742]                 is_error <- inherits(cond, "error")
[17:59:24.742]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.742]                   NULL)
[17:59:24.742]                 if (is_error) {
[17:59:24.742]                   sessionInformation <- function() {
[17:59:24.742]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.742]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.742]                       search = base::search(), system = base::Sys.info())
[17:59:24.742]                   }
[17:59:24.742]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.742]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.742]                     cond$call), session = sessionInformation(), 
[17:59:24.742]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.742]                   signalCondition(cond)
[17:59:24.742]                 }
[17:59:24.742]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.742]                 "immediateCondition"))) {
[17:59:24.742]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.742]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.742]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.742]                   if (TRUE && !signal) {
[17:59:24.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.742]                     {
[17:59:24.742]                       inherits <- base::inherits
[17:59:24.742]                       invokeRestart <- base::invokeRestart
[17:59:24.742]                       is.null <- base::is.null
[17:59:24.742]                       muffled <- FALSE
[17:59:24.742]                       if (inherits(cond, "message")) {
[17:59:24.742]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.742]                         if (muffled) 
[17:59:24.742]                           invokeRestart("muffleMessage")
[17:59:24.742]                       }
[17:59:24.742]                       else if (inherits(cond, "warning")) {
[17:59:24.742]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.742]                         if (muffled) 
[17:59:24.742]                           invokeRestart("muffleWarning")
[17:59:24.742]                       }
[17:59:24.742]                       else if (inherits(cond, "condition")) {
[17:59:24.742]                         if (!is.null(pattern)) {
[17:59:24.742]                           computeRestarts <- base::computeRestarts
[17:59:24.742]                           grepl <- base::grepl
[17:59:24.742]                           restarts <- computeRestarts(cond)
[17:59:24.742]                           for (restart in restarts) {
[17:59:24.742]                             name <- restart$name
[17:59:24.742]                             if (is.null(name)) 
[17:59:24.742]                               next
[17:59:24.742]                             if (!grepl(pattern, name)) 
[17:59:24.742]                               next
[17:59:24.742]                             invokeRestart(restart)
[17:59:24.742]                             muffled <- TRUE
[17:59:24.742]                             break
[17:59:24.742]                           }
[17:59:24.742]                         }
[17:59:24.742]                       }
[17:59:24.742]                       invisible(muffled)
[17:59:24.742]                     }
[17:59:24.742]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.742]                   }
[17:59:24.742]                 }
[17:59:24.742]                 else {
[17:59:24.742]                   if (TRUE) {
[17:59:24.742]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.742]                     {
[17:59:24.742]                       inherits <- base::inherits
[17:59:24.742]                       invokeRestart <- base::invokeRestart
[17:59:24.742]                       is.null <- base::is.null
[17:59:24.742]                       muffled <- FALSE
[17:59:24.742]                       if (inherits(cond, "message")) {
[17:59:24.742]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.742]                         if (muffled) 
[17:59:24.742]                           invokeRestart("muffleMessage")
[17:59:24.742]                       }
[17:59:24.742]                       else if (inherits(cond, "warning")) {
[17:59:24.742]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.742]                         if (muffled) 
[17:59:24.742]                           invokeRestart("muffleWarning")
[17:59:24.742]                       }
[17:59:24.742]                       else if (inherits(cond, "condition")) {
[17:59:24.742]                         if (!is.null(pattern)) {
[17:59:24.742]                           computeRestarts <- base::computeRestarts
[17:59:24.742]                           grepl <- base::grepl
[17:59:24.742]                           restarts <- computeRestarts(cond)
[17:59:24.742]                           for (restart in restarts) {
[17:59:24.742]                             name <- restart$name
[17:59:24.742]                             if (is.null(name)) 
[17:59:24.742]                               next
[17:59:24.742]                             if (!grepl(pattern, name)) 
[17:59:24.742]                               next
[17:59:24.742]                             invokeRestart(restart)
[17:59:24.742]                             muffled <- TRUE
[17:59:24.742]                             break
[17:59:24.742]                           }
[17:59:24.742]                         }
[17:59:24.742]                       }
[17:59:24.742]                       invisible(muffled)
[17:59:24.742]                     }
[17:59:24.742]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.742]                   }
[17:59:24.742]                 }
[17:59:24.742]             }
[17:59:24.742]         }))
[17:59:24.742]     }, error = function(ex) {
[17:59:24.742]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.742]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.742]                 ...future.rng), started = ...future.startTime, 
[17:59:24.742]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.742]             version = "1.8"), class = "FutureResult")
[17:59:24.742]     }, finally = {
[17:59:24.742]         if (!identical(...future.workdir, getwd())) 
[17:59:24.742]             setwd(...future.workdir)
[17:59:24.742]         {
[17:59:24.742]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.742]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.742]             }
[17:59:24.742]             base::options(...future.oldOptions)
[17:59:24.742]             if (.Platform$OS.type == "windows") {
[17:59:24.742]                 old_names <- names(...future.oldEnvVars)
[17:59:24.742]                 envs <- base::Sys.getenv()
[17:59:24.742]                 names <- names(envs)
[17:59:24.742]                 common <- intersect(names, old_names)
[17:59:24.742]                 added <- setdiff(names, old_names)
[17:59:24.742]                 removed <- setdiff(old_names, names)
[17:59:24.742]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.742]                   envs[common]]
[17:59:24.742]                 NAMES <- toupper(changed)
[17:59:24.742]                 args <- list()
[17:59:24.742]                 for (kk in seq_along(NAMES)) {
[17:59:24.742]                   name <- changed[[kk]]
[17:59:24.742]                   NAME <- NAMES[[kk]]
[17:59:24.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.742]                     next
[17:59:24.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.742]                 }
[17:59:24.742]                 NAMES <- toupper(added)
[17:59:24.742]                 for (kk in seq_along(NAMES)) {
[17:59:24.742]                   name <- added[[kk]]
[17:59:24.742]                   NAME <- NAMES[[kk]]
[17:59:24.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.742]                     next
[17:59:24.742]                   args[[name]] <- ""
[17:59:24.742]                 }
[17:59:24.742]                 NAMES <- toupper(removed)
[17:59:24.742]                 for (kk in seq_along(NAMES)) {
[17:59:24.742]                   name <- removed[[kk]]
[17:59:24.742]                   NAME <- NAMES[[kk]]
[17:59:24.742]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.742]                     next
[17:59:24.742]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.742]                 }
[17:59:24.742]                 if (length(args) > 0) 
[17:59:24.742]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.742]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.742]             }
[17:59:24.742]             else {
[17:59:24.742]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.742]             }
[17:59:24.742]             {
[17:59:24.742]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.742]                   0L) {
[17:59:24.742]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.742]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.742]                   base::options(opts)
[17:59:24.742]                 }
[17:59:24.742]                 {
[17:59:24.742]                   {
[17:59:24.742]                     NULL
[17:59:24.742]                     RNGkind("Mersenne-Twister")
[17:59:24.742]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.742]                       inherits = FALSE)
[17:59:24.742]                   }
[17:59:24.742]                   options(future.plan = NULL)
[17:59:24.742]                   if (is.na(NA_character_)) 
[17:59:24.742]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.742]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.742]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.742]                     .init = FALSE)
[17:59:24.742]                 }
[17:59:24.742]             }
[17:59:24.742]         }
[17:59:24.742]     })
[17:59:24.742]     if (TRUE) {
[17:59:24.742]         base::sink(type = "output", split = FALSE)
[17:59:24.742]         if (TRUE) {
[17:59:24.742]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.742]         }
[17:59:24.742]         else {
[17:59:24.742]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.742]         }
[17:59:24.742]         base::close(...future.stdout)
[17:59:24.742]         ...future.stdout <- NULL
[17:59:24.742]     }
[17:59:24.742]     ...future.result$conditions <- ...future.conditions
[17:59:24.742]     ...future.result$finished <- base::Sys.time()
[17:59:24.742]     ...future.result
[17:59:24.742] }
[17:59:24.745] assign_globals() ...
[17:59:24.745] List of 5
[17:59:24.745]  $ ...future.FUN            :function (object, ...)  
[17:59:24.745]  $ future.call.arguments    : list()
[17:59:24.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.745]  $ ...future.elements_ii    :List of 3
[17:59:24.745]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.745]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.745]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.745]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.745]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.745]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.745]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.745]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:24.745]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.745]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.745]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.745]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:24.745]  $ ...future.seeds_ii       : NULL
[17:59:24.745]  $ ...future.globals.maxSize: NULL
[17:59:24.745]  - attr(*, "where")=List of 5
[17:59:24.745]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.745]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.745]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.745]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.745]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.745]  - attr(*, "resolved")= logi FALSE
[17:59:24.745]  - attr(*, "total_size")= num 1240
[17:59:24.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.745]  - attr(*, "already-done")= logi TRUE
[17:59:24.762] - copied ‘...future.FUN’ to environment
[17:59:24.763] - copied ‘future.call.arguments’ to environment
[17:59:24.763] - copied ‘...future.elements_ii’ to environment
[17:59:24.763] - copied ‘...future.seeds_ii’ to environment
[17:59:24.763] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.763] assign_globals() ... done
[17:59:24.764] plan(): Setting new future strategy stack:
[17:59:24.764] List of future strategies:
[17:59:24.764] 1. sequential:
[17:59:24.764]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.764]    - tweaked: FALSE
[17:59:24.764]    - call: NULL
[17:59:24.765] plan(): nbrOfWorkers() = 1
[17:59:24.769] plan(): Setting new future strategy stack:
[17:59:24.770] List of future strategies:
[17:59:24.770] 1. multicore:
[17:59:24.770]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.770]    - tweaked: FALSE
[17:59:24.770]    - call: plan(strategy)
[17:59:24.776] plan(): nbrOfWorkers() = 1
[17:59:24.776] SequentialFuture started (and completed)
[17:59:24.777] - Launch lazy future ... done
[17:59:24.777] run() for ‘SequentialFuture’ ... done
[17:59:24.777] Created future:
[17:59:24.777] SequentialFuture:
[17:59:24.777] Label: ‘future_by-1’
[17:59:24.777] Expression:
[17:59:24.777] {
[17:59:24.777]     do.call(function(...) {
[17:59:24.777]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.777]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.777]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.777]             on.exit(options(oopts), add = TRUE)
[17:59:24.777]         }
[17:59:24.777]         {
[17:59:24.777]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.777]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.777]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.777]             })
[17:59:24.777]         }
[17:59:24.777]     }, args = future.call.arguments)
[17:59:24.777] }
[17:59:24.777] Lazy evaluation: FALSE
[17:59:24.777] Asynchronous evaluation: FALSE
[17:59:24.777] Local evaluation: TRUE
[17:59:24.777] Environment: 0x62649da2c548
[17:59:24.777] Capture standard output: TRUE
[17:59:24.777] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.777] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.777] Packages: <none>
[17:59:24.777] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.777] Resolved: TRUE
[17:59:24.777] Value: 5.37 KiB of class ‘list’
[17:59:24.777] Early signaling: FALSE
[17:59:24.777] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.777] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.780] Chunk #1 of 1 ... DONE
[17:59:24.780] Launching 1 futures (chunks) ... DONE
[17:59:24.780] Resolving 1 futures (chunks) ...
[17:59:24.781] resolve() on list ...
[17:59:24.781]  recursive: 0
[17:59:24.781]  length: 1
[17:59:24.781] 
[17:59:24.781] resolved() for ‘SequentialFuture’ ...
[17:59:24.782] - state: ‘finished’
[17:59:24.782] - run: TRUE
[17:59:24.782] - result: ‘FutureResult’
[17:59:24.782] resolved() for ‘SequentialFuture’ ... done
[17:59:24.782] Future #1
[17:59:24.783] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.783] - nx: 1
[17:59:24.783] - relay: TRUE
[17:59:24.783] - stdout: TRUE
[17:59:24.783] - signal: TRUE
[17:59:24.784] - resignal: FALSE
[17:59:24.784] - force: TRUE
[17:59:24.784] - relayed: [n=1] FALSE
[17:59:24.784] - queued futures: [n=1] FALSE
[17:59:24.784]  - until=1
[17:59:24.785]  - relaying element #1
[17:59:24.785] - relayed: [n=1] TRUE
[17:59:24.785] - queued futures: [n=1] TRUE
[17:59:24.785] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.788]  length: 0 (resolved future 1)
[17:59:24.788] Relaying remaining futures
[17:59:24.788] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.788] - nx: 1
[17:59:24.788] - relay: TRUE
[17:59:24.789] - stdout: TRUE
[17:59:24.789] - signal: TRUE
[17:59:24.789] - resignal: FALSE
[17:59:24.789] - force: TRUE
[17:59:24.789] - relayed: [n=1] TRUE
[17:59:24.790] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.790] - relayed: [n=1] TRUE
[17:59:24.790] - queued futures: [n=1] TRUE
[17:59:24.790] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.791] resolve() on list ... DONE
[17:59:24.791]  - Number of value chunks collected: 1
[17:59:24.791] Resolving 1 futures (chunks) ... DONE
[17:59:24.791] Reducing values from 1 chunks ...
[17:59:24.791]  - Number of values collected after concatenation: 3
[17:59:24.792]  - Number of values expected: 3
[17:59:24.792] Reducing values from 1 chunks ... DONE
[17:59:24.792] future_lapply() ... DONE
[17:59:24.792] future_by_internal() ... DONE
[17:59:24.794] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:59:24.795] future_lapply() ...
[17:59:24.802] Number of chunks: 1
[17:59:24.802] getGlobalsAndPackagesXApply() ...
[17:59:24.802]  - future.globals: TRUE
[17:59:24.803] getGlobalsAndPackages() ...
[17:59:24.803] Searching for globals...
[17:59:24.805] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.805] Searching for globals ... DONE
[17:59:24.805] Resolving globals: FALSE
[17:59:24.806] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.807] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.807] - globals: [1] ‘FUN’
[17:59:24.807] 
[17:59:24.807] getGlobalsAndPackages() ... DONE
[17:59:24.808]  - globals found/used: [n=1] ‘FUN’
[17:59:24.808]  - needed namespaces: [n=0] 
[17:59:24.808] Finding globals ... DONE
[17:59:24.808]  - use_args: TRUE
[17:59:24.808]  - Getting '...' globals ...
[17:59:24.809] resolve() on list ...
[17:59:24.809]  recursive: 0
[17:59:24.809]  length: 1
[17:59:24.810]  elements: ‘...’
[17:59:24.810]  length: 0 (resolved future 1)
[17:59:24.810] resolve() on list ... DONE
[17:59:24.810]    - '...' content: [n=0] 
[17:59:24.810] List of 1
[17:59:24.810]  $ ...: list()
[17:59:24.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.810]  - attr(*, "where")=List of 1
[17:59:24.810]   ..$ ...:<environment: 0x62649f06b3f0> 
[17:59:24.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.810]  - attr(*, "resolved")= logi TRUE
[17:59:24.810]  - attr(*, "total_size")= num NA
[17:59:24.815]  - Getting '...' globals ... DONE
[17:59:24.816] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.816] List of 2
[17:59:24.816]  $ ...future.FUN:function (object, ...)  
[17:59:24.816]  $ ...          : list()
[17:59:24.816]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.816]  - attr(*, "where")=List of 2
[17:59:24.816]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.816]   ..$ ...          :<environment: 0x62649f06b3f0> 
[17:59:24.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.816]  - attr(*, "resolved")= logi FALSE
[17:59:24.816]  - attr(*, "total_size")= num 1240
[17:59:24.821] Packages to be attached in all futures: [n=0] 
[17:59:24.822] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.822] Number of futures (= number of chunks): 1
[17:59:24.822] Launching 1 futures (chunks) ...
[17:59:24.822] Chunk #1 of 1 ...
[17:59:24.823]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.823] getGlobalsAndPackages() ...
[17:59:24.823] Searching for globals...
[17:59:24.824] 
[17:59:24.824] Searching for globals ... DONE
[17:59:24.824] - globals: [0] <none>
[17:59:24.825] getGlobalsAndPackages() ... DONE
[17:59:24.825]    + additional globals found: [n=0] 
[17:59:24.825]    + additional namespaces needed: [n=0] 
[17:59:24.825]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.825]  - seeds: <none>
[17:59:24.826]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.826] getGlobalsAndPackages() ...
[17:59:24.826] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.826] Resolving globals: FALSE
[17:59:24.826] Tweak future expression to call with '...' arguments ...
[17:59:24.827] {
[17:59:24.827]     do.call(function(...) {
[17:59:24.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.827]             on.exit(options(oopts), add = TRUE)
[17:59:24.827]         }
[17:59:24.827]         {
[17:59:24.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.827]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.827]             })
[17:59:24.827]         }
[17:59:24.827]     }, args = future.call.arguments)
[17:59:24.827] }
[17:59:24.827] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.828] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.828] 
[17:59:24.828] getGlobalsAndPackages() ... DONE
[17:59:24.829] run() for ‘Future’ ...
[17:59:24.829] - state: ‘created’
[17:59:24.829] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.836] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.836]   - Field: ‘label’
[17:59:24.837]   - Field: ‘local’
[17:59:24.837]   - Field: ‘owner’
[17:59:24.837]   - Field: ‘envir’
[17:59:24.837]   - Field: ‘packages’
[17:59:24.838]   - Field: ‘gc’
[17:59:24.838]   - Field: ‘conditions’
[17:59:24.838]   - Field: ‘expr’
[17:59:24.838]   - Field: ‘uuid’
[17:59:24.839]   - Field: ‘seed’
[17:59:24.839]   - Field: ‘version’
[17:59:24.839]   - Field: ‘result’
[17:59:24.839]   - Field: ‘asynchronous’
[17:59:24.839]   - Field: ‘calls’
[17:59:24.840]   - Field: ‘globals’
[17:59:24.840]   - Field: ‘stdout’
[17:59:24.840]   - Field: ‘earlySignal’
[17:59:24.840]   - Field: ‘lazy’
[17:59:24.840]   - Field: ‘state’
[17:59:24.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.843] - Launch lazy future ...
[17:59:24.844] Packages needed by the future expression (n = 0): <none>
[17:59:24.844] Packages needed by future strategies (n = 0): <none>
[17:59:24.845] {
[17:59:24.845]     {
[17:59:24.845]         {
[17:59:24.845]             ...future.startTime <- base::Sys.time()
[17:59:24.845]             {
[17:59:24.845]                 {
[17:59:24.845]                   {
[17:59:24.845]                     base::local({
[17:59:24.845]                       has_future <- base::requireNamespace("future", 
[17:59:24.845]                         quietly = TRUE)
[17:59:24.845]                       if (has_future) {
[17:59:24.845]                         ns <- base::getNamespace("future")
[17:59:24.845]                         version <- ns[[".package"]][["version"]]
[17:59:24.845]                         if (is.null(version)) 
[17:59:24.845]                           version <- utils::packageVersion("future")
[17:59:24.845]                       }
[17:59:24.845]                       else {
[17:59:24.845]                         version <- NULL
[17:59:24.845]                       }
[17:59:24.845]                       if (!has_future || version < "1.8.0") {
[17:59:24.845]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.845]                           "", base::R.version$version.string), 
[17:59:24.845]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.845]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.845]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.845]                             "release", "version")], collapse = " "), 
[17:59:24.845]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.845]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.845]                           info)
[17:59:24.845]                         info <- base::paste(info, collapse = "; ")
[17:59:24.845]                         if (!has_future) {
[17:59:24.845]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.845]                             info)
[17:59:24.845]                         }
[17:59:24.845]                         else {
[17:59:24.845]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.845]                             info, version)
[17:59:24.845]                         }
[17:59:24.845]                         base::stop(msg)
[17:59:24.845]                       }
[17:59:24.845]                     })
[17:59:24.845]                   }
[17:59:24.845]                   ...future.strategy.old <- future::plan("list")
[17:59:24.845]                   options(future.plan = NULL)
[17:59:24.845]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.845]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.845]                 }
[17:59:24.845]                 ...future.workdir <- getwd()
[17:59:24.845]             }
[17:59:24.845]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.845]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.845]         }
[17:59:24.845]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.845]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.845]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.845]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.845]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.845]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.845]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.845]             base::names(...future.oldOptions))
[17:59:24.845]     }
[17:59:24.845]     if (FALSE) {
[17:59:24.845]     }
[17:59:24.845]     else {
[17:59:24.845]         if (TRUE) {
[17:59:24.845]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.845]                 open = "w")
[17:59:24.845]         }
[17:59:24.845]         else {
[17:59:24.845]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.845]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.845]         }
[17:59:24.845]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.845]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.845]             base::sink(type = "output", split = FALSE)
[17:59:24.845]             base::close(...future.stdout)
[17:59:24.845]         }, add = TRUE)
[17:59:24.845]     }
[17:59:24.845]     ...future.frame <- base::sys.nframe()
[17:59:24.845]     ...future.conditions <- base::list()
[17:59:24.845]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.845]     if (FALSE) {
[17:59:24.845]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.845]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.845]     }
[17:59:24.845]     ...future.result <- base::tryCatch({
[17:59:24.845]         base::withCallingHandlers({
[17:59:24.845]             ...future.value <- base::withVisible(base::local({
[17:59:24.845]                 do.call(function(...) {
[17:59:24.845]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.845]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.845]                     ...future.globals.maxSize)) {
[17:59:24.845]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.845]                     on.exit(options(oopts), add = TRUE)
[17:59:24.845]                   }
[17:59:24.845]                   {
[17:59:24.845]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.845]                       FUN = function(jj) {
[17:59:24.845]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.845]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.845]                       })
[17:59:24.845]                   }
[17:59:24.845]                 }, args = future.call.arguments)
[17:59:24.845]             }))
[17:59:24.845]             future::FutureResult(value = ...future.value$value, 
[17:59:24.845]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.845]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.845]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.845]                     ...future.globalenv.names))
[17:59:24.845]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.845]         }, condition = base::local({
[17:59:24.845]             c <- base::c
[17:59:24.845]             inherits <- base::inherits
[17:59:24.845]             invokeRestart <- base::invokeRestart
[17:59:24.845]             length <- base::length
[17:59:24.845]             list <- base::list
[17:59:24.845]             seq.int <- base::seq.int
[17:59:24.845]             signalCondition <- base::signalCondition
[17:59:24.845]             sys.calls <- base::sys.calls
[17:59:24.845]             `[[` <- base::`[[`
[17:59:24.845]             `+` <- base::`+`
[17:59:24.845]             `<<-` <- base::`<<-`
[17:59:24.845]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.845]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.845]                   3L)]
[17:59:24.845]             }
[17:59:24.845]             function(cond) {
[17:59:24.845]                 is_error <- inherits(cond, "error")
[17:59:24.845]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.845]                   NULL)
[17:59:24.845]                 if (is_error) {
[17:59:24.845]                   sessionInformation <- function() {
[17:59:24.845]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.845]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.845]                       search = base::search(), system = base::Sys.info())
[17:59:24.845]                   }
[17:59:24.845]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.845]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.845]                     cond$call), session = sessionInformation(), 
[17:59:24.845]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.845]                   signalCondition(cond)
[17:59:24.845]                 }
[17:59:24.845]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.845]                 "immediateCondition"))) {
[17:59:24.845]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.845]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.845]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.845]                   if (TRUE && !signal) {
[17:59:24.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.845]                     {
[17:59:24.845]                       inherits <- base::inherits
[17:59:24.845]                       invokeRestart <- base::invokeRestart
[17:59:24.845]                       is.null <- base::is.null
[17:59:24.845]                       muffled <- FALSE
[17:59:24.845]                       if (inherits(cond, "message")) {
[17:59:24.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.845]                         if (muffled) 
[17:59:24.845]                           invokeRestart("muffleMessage")
[17:59:24.845]                       }
[17:59:24.845]                       else if (inherits(cond, "warning")) {
[17:59:24.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.845]                         if (muffled) 
[17:59:24.845]                           invokeRestart("muffleWarning")
[17:59:24.845]                       }
[17:59:24.845]                       else if (inherits(cond, "condition")) {
[17:59:24.845]                         if (!is.null(pattern)) {
[17:59:24.845]                           computeRestarts <- base::computeRestarts
[17:59:24.845]                           grepl <- base::grepl
[17:59:24.845]                           restarts <- computeRestarts(cond)
[17:59:24.845]                           for (restart in restarts) {
[17:59:24.845]                             name <- restart$name
[17:59:24.845]                             if (is.null(name)) 
[17:59:24.845]                               next
[17:59:24.845]                             if (!grepl(pattern, name)) 
[17:59:24.845]                               next
[17:59:24.845]                             invokeRestart(restart)
[17:59:24.845]                             muffled <- TRUE
[17:59:24.845]                             break
[17:59:24.845]                           }
[17:59:24.845]                         }
[17:59:24.845]                       }
[17:59:24.845]                       invisible(muffled)
[17:59:24.845]                     }
[17:59:24.845]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.845]                   }
[17:59:24.845]                 }
[17:59:24.845]                 else {
[17:59:24.845]                   if (TRUE) {
[17:59:24.845]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.845]                     {
[17:59:24.845]                       inherits <- base::inherits
[17:59:24.845]                       invokeRestart <- base::invokeRestart
[17:59:24.845]                       is.null <- base::is.null
[17:59:24.845]                       muffled <- FALSE
[17:59:24.845]                       if (inherits(cond, "message")) {
[17:59:24.845]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.845]                         if (muffled) 
[17:59:24.845]                           invokeRestart("muffleMessage")
[17:59:24.845]                       }
[17:59:24.845]                       else if (inherits(cond, "warning")) {
[17:59:24.845]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.845]                         if (muffled) 
[17:59:24.845]                           invokeRestart("muffleWarning")
[17:59:24.845]                       }
[17:59:24.845]                       else if (inherits(cond, "condition")) {
[17:59:24.845]                         if (!is.null(pattern)) {
[17:59:24.845]                           computeRestarts <- base::computeRestarts
[17:59:24.845]                           grepl <- base::grepl
[17:59:24.845]                           restarts <- computeRestarts(cond)
[17:59:24.845]                           for (restart in restarts) {
[17:59:24.845]                             name <- restart$name
[17:59:24.845]                             if (is.null(name)) 
[17:59:24.845]                               next
[17:59:24.845]                             if (!grepl(pattern, name)) 
[17:59:24.845]                               next
[17:59:24.845]                             invokeRestart(restart)
[17:59:24.845]                             muffled <- TRUE
[17:59:24.845]                             break
[17:59:24.845]                           }
[17:59:24.845]                         }
[17:59:24.845]                       }
[17:59:24.845]                       invisible(muffled)
[17:59:24.845]                     }
[17:59:24.845]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.845]                   }
[17:59:24.845]                 }
[17:59:24.845]             }
[17:59:24.845]         }))
[17:59:24.845]     }, error = function(ex) {
[17:59:24.845]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.845]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.845]                 ...future.rng), started = ...future.startTime, 
[17:59:24.845]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.845]             version = "1.8"), class = "FutureResult")
[17:59:24.845]     }, finally = {
[17:59:24.845]         if (!identical(...future.workdir, getwd())) 
[17:59:24.845]             setwd(...future.workdir)
[17:59:24.845]         {
[17:59:24.845]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.845]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.845]             }
[17:59:24.845]             base::options(...future.oldOptions)
[17:59:24.845]             if (.Platform$OS.type == "windows") {
[17:59:24.845]                 old_names <- names(...future.oldEnvVars)
[17:59:24.845]                 envs <- base::Sys.getenv()
[17:59:24.845]                 names <- names(envs)
[17:59:24.845]                 common <- intersect(names, old_names)
[17:59:24.845]                 added <- setdiff(names, old_names)
[17:59:24.845]                 removed <- setdiff(old_names, names)
[17:59:24.845]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.845]                   envs[common]]
[17:59:24.845]                 NAMES <- toupper(changed)
[17:59:24.845]                 args <- list()
[17:59:24.845]                 for (kk in seq_along(NAMES)) {
[17:59:24.845]                   name <- changed[[kk]]
[17:59:24.845]                   NAME <- NAMES[[kk]]
[17:59:24.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.845]                     next
[17:59:24.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.845]                 }
[17:59:24.845]                 NAMES <- toupper(added)
[17:59:24.845]                 for (kk in seq_along(NAMES)) {
[17:59:24.845]                   name <- added[[kk]]
[17:59:24.845]                   NAME <- NAMES[[kk]]
[17:59:24.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.845]                     next
[17:59:24.845]                   args[[name]] <- ""
[17:59:24.845]                 }
[17:59:24.845]                 NAMES <- toupper(removed)
[17:59:24.845]                 for (kk in seq_along(NAMES)) {
[17:59:24.845]                   name <- removed[[kk]]
[17:59:24.845]                   NAME <- NAMES[[kk]]
[17:59:24.845]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.845]                     next
[17:59:24.845]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.845]                 }
[17:59:24.845]                 if (length(args) > 0) 
[17:59:24.845]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.845]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.845]             }
[17:59:24.845]             else {
[17:59:24.845]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.845]             }
[17:59:24.845]             {
[17:59:24.845]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.845]                   0L) {
[17:59:24.845]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.845]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.845]                   base::options(opts)
[17:59:24.845]                 }
[17:59:24.845]                 {
[17:59:24.845]                   {
[17:59:24.845]                     NULL
[17:59:24.845]                     RNGkind("Mersenne-Twister")
[17:59:24.845]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.845]                       inherits = FALSE)
[17:59:24.845]                   }
[17:59:24.845]                   options(future.plan = NULL)
[17:59:24.845]                   if (is.na(NA_character_)) 
[17:59:24.845]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.845]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.845]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.845]                     .init = FALSE)
[17:59:24.845]                 }
[17:59:24.845]             }
[17:59:24.845]         }
[17:59:24.845]     })
[17:59:24.845]     if (TRUE) {
[17:59:24.845]         base::sink(type = "output", split = FALSE)
[17:59:24.845]         if (TRUE) {
[17:59:24.845]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.845]         }
[17:59:24.845]         else {
[17:59:24.845]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.845]         }
[17:59:24.845]         base::close(...future.stdout)
[17:59:24.845]         ...future.stdout <- NULL
[17:59:24.845]     }
[17:59:24.845]     ...future.result$conditions <- ...future.conditions
[17:59:24.845]     ...future.result$finished <- base::Sys.time()
[17:59:24.845]     ...future.result
[17:59:24.845] }
[17:59:24.849] assign_globals() ...
[17:59:24.849] List of 5
[17:59:24.849]  $ ...future.FUN            :function (object, ...)  
[17:59:24.849]  $ future.call.arguments    : list()
[17:59:24.849]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.849]  $ ...future.elements_ii    :List of 3
[17:59:24.849]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.849]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.849]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.849]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:24.849]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.849]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.849]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.849]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:24.849]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:24.849]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.849]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.849]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:24.849]  $ ...future.seeds_ii       : NULL
[17:59:24.849]  $ ...future.globals.maxSize: NULL
[17:59:24.849]  - attr(*, "where")=List of 5
[17:59:24.849]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.849]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.849]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.849]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.849]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.849]  - attr(*, "resolved")= logi FALSE
[17:59:24.849]  - attr(*, "total_size")= num 1240
[17:59:24.849]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.849]  - attr(*, "already-done")= logi TRUE
[17:59:24.868] - copied ‘...future.FUN’ to environment
[17:59:24.868] - copied ‘future.call.arguments’ to environment
[17:59:24.868] - copied ‘...future.elements_ii’ to environment
[17:59:24.869] - copied ‘...future.seeds_ii’ to environment
[17:59:24.869] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.869] assign_globals() ... done
[17:59:24.870] plan(): Setting new future strategy stack:
[17:59:24.870] List of future strategies:
[17:59:24.870] 1. sequential:
[17:59:24.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.870]    - tweaked: FALSE
[17:59:24.870]    - call: NULL
[17:59:24.871] plan(): nbrOfWorkers() = 1
[17:59:24.876] plan(): Setting new future strategy stack:
[17:59:24.876] List of future strategies:
[17:59:24.876] 1. multicore:
[17:59:24.876]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:24.876]    - tweaked: FALSE
[17:59:24.876]    - call: plan(strategy)
[17:59:24.882] plan(): nbrOfWorkers() = 1
[17:59:24.883] SequentialFuture started (and completed)
[17:59:24.883] - Launch lazy future ... done
[17:59:24.884] run() for ‘SequentialFuture’ ... done
[17:59:24.884] Created future:
[17:59:24.884] SequentialFuture:
[17:59:24.884] Label: ‘future_by-1’
[17:59:24.884] Expression:
[17:59:24.884] {
[17:59:24.884]     do.call(function(...) {
[17:59:24.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.884]             on.exit(options(oopts), add = TRUE)
[17:59:24.884]         }
[17:59:24.884]         {
[17:59:24.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.884]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.884]             })
[17:59:24.884]         }
[17:59:24.884]     }, args = future.call.arguments)
[17:59:24.884] }
[17:59:24.884] Lazy evaluation: FALSE
[17:59:24.884] Asynchronous evaluation: FALSE
[17:59:24.884] Local evaluation: TRUE
[17:59:24.884] Environment: 0x62649f0ce2e8
[17:59:24.884] Capture standard output: TRUE
[17:59:24.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:24.884] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:24.884] Packages: <none>
[17:59:24.884] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:24.884] Resolved: TRUE
[17:59:24.884] Value: 5.37 KiB of class ‘list’
[17:59:24.884] Early signaling: FALSE
[17:59:24.884] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:24.884] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.887] Chunk #1 of 1 ... DONE
[17:59:24.887] Launching 1 futures (chunks) ... DONE
[17:59:24.887] Resolving 1 futures (chunks) ...
[17:59:24.888] resolve() on list ...
[17:59:24.888]  recursive: 0
[17:59:24.888]  length: 1
[17:59:24.888] 
[17:59:24.889] resolved() for ‘SequentialFuture’ ...
[17:59:24.889] - state: ‘finished’
[17:59:24.889] - run: TRUE
[17:59:24.889] - result: ‘FutureResult’
[17:59:24.889] resolved() for ‘SequentialFuture’ ... done
[17:59:24.890] Future #1
[17:59:24.890] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:24.890] - nx: 1
[17:59:24.890] - relay: TRUE
[17:59:24.890] - stdout: TRUE
[17:59:24.891] - signal: TRUE
[17:59:24.891] - resignal: FALSE
[17:59:24.891] - force: TRUE
[17:59:24.891] - relayed: [n=1] FALSE
[17:59:24.891] - queued futures: [n=1] FALSE
[17:59:24.892]  - until=1
[17:59:24.892]  - relaying element #1
[17:59:24.892] - relayed: [n=1] TRUE
[17:59:24.892] - queued futures: [n=1] TRUE
[17:59:24.893] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:24.893]  length: 0 (resolved future 1)
[17:59:24.893] Relaying remaining futures
[17:59:24.893] signalConditionsASAP(NULL, pos=0) ...
[17:59:24.893] - nx: 1
[17:59:24.894] - relay: TRUE
[17:59:24.894] - stdout: TRUE
[17:59:24.894] - signal: TRUE
[17:59:24.894] - resignal: FALSE
[17:59:24.894] - force: TRUE
[17:59:24.894] - relayed: [n=1] TRUE
[17:59:24.895] - queued futures: [n=1] TRUE
 - flush all
[17:59:24.895] - relayed: [n=1] TRUE
[17:59:24.895] - queued futures: [n=1] TRUE
[17:59:24.895] signalConditionsASAP(NULL, pos=0) ... done
[17:59:24.896] resolve() on list ... DONE
[17:59:24.896]  - Number of value chunks collected: 1
[17:59:24.896] Resolving 1 futures (chunks) ... DONE
[17:59:24.896] Reducing values from 1 chunks ...
[17:59:24.896]  - Number of values collected after concatenation: 3
[17:59:24.897]  - Number of values expected: 3
[17:59:24.897] Reducing values from 1 chunks ... DONE
[17:59:24.897] future_lapply() ... DONE
[17:59:24.897] future_by_internal() ... DONE
[17:59:24.901] future_by_internal() ...
- plan('multisession') ...
[17:59:24.902] plan(): Setting new future strategy stack:
[17:59:24.903] List of future strategies:
[17:59:24.903] 1. multisession:
[17:59:24.903]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:24.903]    - tweaked: FALSE
[17:59:24.903]    - call: plan(strategy)
[17:59:24.903] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:59:24.904] multisession:
[17:59:24.904] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:24.904] - tweaked: FALSE
[17:59:24.904] - call: plan(strategy)
[17:59:24.910] getGlobalsAndPackages() ...
[17:59:24.910] Not searching for globals
[17:59:24.910] - globals: [0] <none>
[17:59:24.910] getGlobalsAndPackages() ... DONE
[17:59:24.911] Packages needed by the future expression (n = 0): <none>
[17:59:24.911] Packages needed by future strategies (n = 0): <none>
[17:59:24.912] {
[17:59:24.912]     {
[17:59:24.912]         {
[17:59:24.912]             ...future.startTime <- base::Sys.time()
[17:59:24.912]             {
[17:59:24.912]                 {
[17:59:24.912]                   {
[17:59:24.912]                     base::local({
[17:59:24.912]                       has_future <- base::requireNamespace("future", 
[17:59:24.912]                         quietly = TRUE)
[17:59:24.912]                       if (has_future) {
[17:59:24.912]                         ns <- base::getNamespace("future")
[17:59:24.912]                         version <- ns[[".package"]][["version"]]
[17:59:24.912]                         if (is.null(version)) 
[17:59:24.912]                           version <- utils::packageVersion("future")
[17:59:24.912]                       }
[17:59:24.912]                       else {
[17:59:24.912]                         version <- NULL
[17:59:24.912]                       }
[17:59:24.912]                       if (!has_future || version < "1.8.0") {
[17:59:24.912]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.912]                           "", base::R.version$version.string), 
[17:59:24.912]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.912]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.912]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.912]                             "release", "version")], collapse = " "), 
[17:59:24.912]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.912]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.912]                           info)
[17:59:24.912]                         info <- base::paste(info, collapse = "; ")
[17:59:24.912]                         if (!has_future) {
[17:59:24.912]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.912]                             info)
[17:59:24.912]                         }
[17:59:24.912]                         else {
[17:59:24.912]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.912]                             info, version)
[17:59:24.912]                         }
[17:59:24.912]                         base::stop(msg)
[17:59:24.912]                       }
[17:59:24.912]                     })
[17:59:24.912]                   }
[17:59:24.912]                   ...future.strategy.old <- future::plan("list")
[17:59:24.912]                   options(future.plan = NULL)
[17:59:24.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.912]                 }
[17:59:24.912]                 ...future.workdir <- getwd()
[17:59:24.912]             }
[17:59:24.912]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.912]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.912]         }
[17:59:24.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.912]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.912]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.912]             base::names(...future.oldOptions))
[17:59:24.912]     }
[17:59:24.912]     if (FALSE) {
[17:59:24.912]     }
[17:59:24.912]     else {
[17:59:24.912]         if (TRUE) {
[17:59:24.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.912]                 open = "w")
[17:59:24.912]         }
[17:59:24.912]         else {
[17:59:24.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.912]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.912]         }
[17:59:24.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.912]             base::sink(type = "output", split = FALSE)
[17:59:24.912]             base::close(...future.stdout)
[17:59:24.912]         }, add = TRUE)
[17:59:24.912]     }
[17:59:24.912]     ...future.frame <- base::sys.nframe()
[17:59:24.912]     ...future.conditions <- base::list()
[17:59:24.912]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.912]     if (FALSE) {
[17:59:24.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.912]     }
[17:59:24.912]     ...future.result <- base::tryCatch({
[17:59:24.912]         base::withCallingHandlers({
[17:59:24.912]             ...future.value <- base::withVisible(base::local(NA))
[17:59:24.912]             future::FutureResult(value = ...future.value$value, 
[17:59:24.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.912]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.912]                     ...future.globalenv.names))
[17:59:24.912]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.912]         }, condition = base::local({
[17:59:24.912]             c <- base::c
[17:59:24.912]             inherits <- base::inherits
[17:59:24.912]             invokeRestart <- base::invokeRestart
[17:59:24.912]             length <- base::length
[17:59:24.912]             list <- base::list
[17:59:24.912]             seq.int <- base::seq.int
[17:59:24.912]             signalCondition <- base::signalCondition
[17:59:24.912]             sys.calls <- base::sys.calls
[17:59:24.912]             `[[` <- base::`[[`
[17:59:24.912]             `+` <- base::`+`
[17:59:24.912]             `<<-` <- base::`<<-`
[17:59:24.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.912]                   3L)]
[17:59:24.912]             }
[17:59:24.912]             function(cond) {
[17:59:24.912]                 is_error <- inherits(cond, "error")
[17:59:24.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.912]                   NULL)
[17:59:24.912]                 if (is_error) {
[17:59:24.912]                   sessionInformation <- function() {
[17:59:24.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.912]                       search = base::search(), system = base::Sys.info())
[17:59:24.912]                   }
[17:59:24.912]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.912]                     cond$call), session = sessionInformation(), 
[17:59:24.912]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.912]                   signalCondition(cond)
[17:59:24.912]                 }
[17:59:24.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.912]                 "immediateCondition"))) {
[17:59:24.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.912]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.912]                   if (TRUE && !signal) {
[17:59:24.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.912]                     {
[17:59:24.912]                       inherits <- base::inherits
[17:59:24.912]                       invokeRestart <- base::invokeRestart
[17:59:24.912]                       is.null <- base::is.null
[17:59:24.912]                       muffled <- FALSE
[17:59:24.912]                       if (inherits(cond, "message")) {
[17:59:24.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.912]                         if (muffled) 
[17:59:24.912]                           invokeRestart("muffleMessage")
[17:59:24.912]                       }
[17:59:24.912]                       else if (inherits(cond, "warning")) {
[17:59:24.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.912]                         if (muffled) 
[17:59:24.912]                           invokeRestart("muffleWarning")
[17:59:24.912]                       }
[17:59:24.912]                       else if (inherits(cond, "condition")) {
[17:59:24.912]                         if (!is.null(pattern)) {
[17:59:24.912]                           computeRestarts <- base::computeRestarts
[17:59:24.912]                           grepl <- base::grepl
[17:59:24.912]                           restarts <- computeRestarts(cond)
[17:59:24.912]                           for (restart in restarts) {
[17:59:24.912]                             name <- restart$name
[17:59:24.912]                             if (is.null(name)) 
[17:59:24.912]                               next
[17:59:24.912]                             if (!grepl(pattern, name)) 
[17:59:24.912]                               next
[17:59:24.912]                             invokeRestart(restart)
[17:59:24.912]                             muffled <- TRUE
[17:59:24.912]                             break
[17:59:24.912]                           }
[17:59:24.912]                         }
[17:59:24.912]                       }
[17:59:24.912]                       invisible(muffled)
[17:59:24.912]                     }
[17:59:24.912]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.912]                   }
[17:59:24.912]                 }
[17:59:24.912]                 else {
[17:59:24.912]                   if (TRUE) {
[17:59:24.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.912]                     {
[17:59:24.912]                       inherits <- base::inherits
[17:59:24.912]                       invokeRestart <- base::invokeRestart
[17:59:24.912]                       is.null <- base::is.null
[17:59:24.912]                       muffled <- FALSE
[17:59:24.912]                       if (inherits(cond, "message")) {
[17:59:24.912]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.912]                         if (muffled) 
[17:59:24.912]                           invokeRestart("muffleMessage")
[17:59:24.912]                       }
[17:59:24.912]                       else if (inherits(cond, "warning")) {
[17:59:24.912]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.912]                         if (muffled) 
[17:59:24.912]                           invokeRestart("muffleWarning")
[17:59:24.912]                       }
[17:59:24.912]                       else if (inherits(cond, "condition")) {
[17:59:24.912]                         if (!is.null(pattern)) {
[17:59:24.912]                           computeRestarts <- base::computeRestarts
[17:59:24.912]                           grepl <- base::grepl
[17:59:24.912]                           restarts <- computeRestarts(cond)
[17:59:24.912]                           for (restart in restarts) {
[17:59:24.912]                             name <- restart$name
[17:59:24.912]                             if (is.null(name)) 
[17:59:24.912]                               next
[17:59:24.912]                             if (!grepl(pattern, name)) 
[17:59:24.912]                               next
[17:59:24.912]                             invokeRestart(restart)
[17:59:24.912]                             muffled <- TRUE
[17:59:24.912]                             break
[17:59:24.912]                           }
[17:59:24.912]                         }
[17:59:24.912]                       }
[17:59:24.912]                       invisible(muffled)
[17:59:24.912]                     }
[17:59:24.912]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.912]                   }
[17:59:24.912]                 }
[17:59:24.912]             }
[17:59:24.912]         }))
[17:59:24.912]     }, error = function(ex) {
[17:59:24.912]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.912]                 ...future.rng), started = ...future.startTime, 
[17:59:24.912]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.912]             version = "1.8"), class = "FutureResult")
[17:59:24.912]     }, finally = {
[17:59:24.912]         if (!identical(...future.workdir, getwd())) 
[17:59:24.912]             setwd(...future.workdir)
[17:59:24.912]         {
[17:59:24.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.912]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.912]             }
[17:59:24.912]             base::options(...future.oldOptions)
[17:59:24.912]             if (.Platform$OS.type == "windows") {
[17:59:24.912]                 old_names <- names(...future.oldEnvVars)
[17:59:24.912]                 envs <- base::Sys.getenv()
[17:59:24.912]                 names <- names(envs)
[17:59:24.912]                 common <- intersect(names, old_names)
[17:59:24.912]                 added <- setdiff(names, old_names)
[17:59:24.912]                 removed <- setdiff(old_names, names)
[17:59:24.912]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.912]                   envs[common]]
[17:59:24.912]                 NAMES <- toupper(changed)
[17:59:24.912]                 args <- list()
[17:59:24.912]                 for (kk in seq_along(NAMES)) {
[17:59:24.912]                   name <- changed[[kk]]
[17:59:24.912]                   NAME <- NAMES[[kk]]
[17:59:24.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.912]                     next
[17:59:24.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.912]                 }
[17:59:24.912]                 NAMES <- toupper(added)
[17:59:24.912]                 for (kk in seq_along(NAMES)) {
[17:59:24.912]                   name <- added[[kk]]
[17:59:24.912]                   NAME <- NAMES[[kk]]
[17:59:24.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.912]                     next
[17:59:24.912]                   args[[name]] <- ""
[17:59:24.912]                 }
[17:59:24.912]                 NAMES <- toupper(removed)
[17:59:24.912]                 for (kk in seq_along(NAMES)) {
[17:59:24.912]                   name <- removed[[kk]]
[17:59:24.912]                   NAME <- NAMES[[kk]]
[17:59:24.912]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.912]                     next
[17:59:24.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.912]                 }
[17:59:24.912]                 if (length(args) > 0) 
[17:59:24.912]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.912]             }
[17:59:24.912]             else {
[17:59:24.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.912]             }
[17:59:24.912]             {
[17:59:24.912]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.912]                   0L) {
[17:59:24.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.912]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.912]                   base::options(opts)
[17:59:24.912]                 }
[17:59:24.912]                 {
[17:59:24.912]                   {
[17:59:24.912]                     NULL
[17:59:24.912]                     RNGkind("Mersenne-Twister")
[17:59:24.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.912]                       inherits = FALSE)
[17:59:24.912]                   }
[17:59:24.912]                   options(future.plan = NULL)
[17:59:24.912]                   if (is.na(NA_character_)) 
[17:59:24.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.912]                     .init = FALSE)
[17:59:24.912]                 }
[17:59:24.912]             }
[17:59:24.912]         }
[17:59:24.912]     })
[17:59:24.912]     if (TRUE) {
[17:59:24.912]         base::sink(type = "output", split = FALSE)
[17:59:24.912]         if (TRUE) {
[17:59:24.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.912]         }
[17:59:24.912]         else {
[17:59:24.912]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.912]         }
[17:59:24.912]         base::close(...future.stdout)
[17:59:24.912]         ...future.stdout <- NULL
[17:59:24.912]     }
[17:59:24.912]     ...future.result$conditions <- ...future.conditions
[17:59:24.912]     ...future.result$finished <- base::Sys.time()
[17:59:24.912]     ...future.result
[17:59:24.912] }
[17:59:24.916] plan(): Setting new future strategy stack:
[17:59:24.916] List of future strategies:
[17:59:24.916] 1. sequential:
[17:59:24.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:24.916]    - tweaked: FALSE
[17:59:24.916]    - call: NULL
[17:59:24.917] plan(): nbrOfWorkers() = 1
[17:59:24.918] plan(): Setting new future strategy stack:
[17:59:24.918] List of future strategies:
[17:59:24.918] 1. multisession:
[17:59:24.918]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:24.918]    - tweaked: FALSE
[17:59:24.918]    - call: plan(strategy)
[17:59:24.924] plan(): nbrOfWorkers() = 1
[17:59:24.925] SequentialFuture started (and completed)
[17:59:24.925] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:59:24.930] plan(): nbrOfWorkers() = 1
[17:59:24.931] future_by_internal() ...
[17:59:24.931] future_lapply() ...
[17:59:24.937] Number of chunks: 1
[17:59:24.938] getGlobalsAndPackagesXApply() ...
[17:59:24.938]  - future.globals: TRUE
[17:59:24.938] getGlobalsAndPackages() ...
[17:59:24.938] Searching for globals...
[17:59:24.940] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:24.941] Searching for globals ... DONE
[17:59:24.941] Resolving globals: FALSE
[17:59:24.942] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:24.942] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:24.942] - globals: [1] ‘FUN’
[17:59:24.943] 
[17:59:24.943] getGlobalsAndPackages() ... DONE
[17:59:24.943]  - globals found/used: [n=1] ‘FUN’
[17:59:24.943]  - needed namespaces: [n=0] 
[17:59:24.943] Finding globals ... DONE
[17:59:24.944]  - use_args: TRUE
[17:59:24.944]  - Getting '...' globals ...
[17:59:24.944] resolve() on list ...
[17:59:24.945]  recursive: 0
[17:59:24.945]  length: 1
[17:59:24.945]  elements: ‘...’
[17:59:24.945]  length: 0 (resolved future 1)
[17:59:24.946] resolve() on list ... DONE
[17:59:24.946]    - '...' content: [n=0] 
[17:59:24.946] List of 1
[17:59:24.946]  $ ...: list()
[17:59:24.946]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.946]  - attr(*, "where")=List of 1
[17:59:24.946]   ..$ ...:<environment: 0x62649f392cf0> 
[17:59:24.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.946]  - attr(*, "resolved")= logi TRUE
[17:59:24.946]  - attr(*, "total_size")= num NA
[17:59:24.951]  - Getting '...' globals ... DONE
[17:59:24.951] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:24.951] List of 2
[17:59:24.951]  $ ...future.FUN:function (object, ...)  
[17:59:24.951]  $ ...          : list()
[17:59:24.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.951]  - attr(*, "where")=List of 2
[17:59:24.951]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:24.951]   ..$ ...          :<environment: 0x62649f392cf0> 
[17:59:24.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.951]  - attr(*, "resolved")= logi FALSE
[17:59:24.951]  - attr(*, "total_size")= num 1240
[17:59:24.957] Packages to be attached in all futures: [n=0] 
[17:59:24.957] getGlobalsAndPackagesXApply() ... DONE
[17:59:24.957] Number of futures (= number of chunks): 1
[17:59:24.958] Launching 1 futures (chunks) ...
[17:59:24.958] Chunk #1 of 1 ...
[17:59:24.958]  - Finding globals in 'X' for chunk #1 ...
[17:59:24.958] getGlobalsAndPackages() ...
[17:59:24.958] Searching for globals...
[17:59:24.959] 
[17:59:24.960] Searching for globals ... DONE
[17:59:24.960] - globals: [0] <none>
[17:59:24.960] getGlobalsAndPackages() ... DONE
[17:59:24.960]    + additional globals found: [n=0] 
[17:59:24.960]    + additional namespaces needed: [n=0] 
[17:59:24.963]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:24.964]  - seeds: <none>
[17:59:24.964]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.964] getGlobalsAndPackages() ...
[17:59:24.964] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.964] Resolving globals: FALSE
[17:59:24.965] Tweak future expression to call with '...' arguments ...
[17:59:24.965] {
[17:59:24.965]     do.call(function(...) {
[17:59:24.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:24.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.965]             on.exit(options(oopts), add = TRUE)
[17:59:24.965]         }
[17:59:24.965]         {
[17:59:24.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:24.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.965]                 ...future.FUN(...future.X_jj, ...)
[17:59:24.965]             })
[17:59:24.965]         }
[17:59:24.965]     }, args = future.call.arguments)
[17:59:24.965] }
[17:59:24.966] Tweak future expression to call with '...' arguments ... DONE
[17:59:24.966] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:24.967] 
[17:59:24.967] getGlobalsAndPackages() ... DONE
[17:59:24.967] run() for ‘Future’ ...
[17:59:24.967] - state: ‘created’
[17:59:24.968] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:24.974] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:24.974] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:24.974]   - Field: ‘label’
[17:59:24.975]   - Field: ‘local’
[17:59:24.975]   - Field: ‘owner’
[17:59:24.975]   - Field: ‘envir’
[17:59:24.975]   - Field: ‘packages’
[17:59:24.975]   - Field: ‘gc’
[17:59:24.976]   - Field: ‘conditions’
[17:59:24.976]   - Field: ‘expr’
[17:59:24.976]   - Field: ‘uuid’
[17:59:24.976]   - Field: ‘seed’
[17:59:24.976]   - Field: ‘version’
[17:59:24.977]   - Field: ‘result’
[17:59:24.977]   - Field: ‘asynchronous’
[17:59:24.977]   - Field: ‘calls’
[17:59:24.977]   - Field: ‘globals’
[17:59:24.977]   - Field: ‘stdout’
[17:59:24.978]   - Field: ‘earlySignal’
[17:59:24.978]   - Field: ‘lazy’
[17:59:24.978]   - Field: ‘state’
[17:59:24.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:24.978] - Launch lazy future ...
[17:59:24.979] Packages needed by the future expression (n = 0): <none>
[17:59:24.979] Packages needed by future strategies (n = 0): <none>
[17:59:24.980] {
[17:59:24.980]     {
[17:59:24.980]         {
[17:59:24.980]             ...future.startTime <- base::Sys.time()
[17:59:24.980]             {
[17:59:24.980]                 {
[17:59:24.980]                   {
[17:59:24.980]                     base::local({
[17:59:24.980]                       has_future <- base::requireNamespace("future", 
[17:59:24.980]                         quietly = TRUE)
[17:59:24.980]                       if (has_future) {
[17:59:24.980]                         ns <- base::getNamespace("future")
[17:59:24.980]                         version <- ns[[".package"]][["version"]]
[17:59:24.980]                         if (is.null(version)) 
[17:59:24.980]                           version <- utils::packageVersion("future")
[17:59:24.980]                       }
[17:59:24.980]                       else {
[17:59:24.980]                         version <- NULL
[17:59:24.980]                       }
[17:59:24.980]                       if (!has_future || version < "1.8.0") {
[17:59:24.980]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:24.980]                           "", base::R.version$version.string), 
[17:59:24.980]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:24.980]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:24.980]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:24.980]                             "release", "version")], collapse = " "), 
[17:59:24.980]                           hostname = base::Sys.info()[["nodename"]])
[17:59:24.980]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:24.980]                           info)
[17:59:24.980]                         info <- base::paste(info, collapse = "; ")
[17:59:24.980]                         if (!has_future) {
[17:59:24.980]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:24.980]                             info)
[17:59:24.980]                         }
[17:59:24.980]                         else {
[17:59:24.980]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:24.980]                             info, version)
[17:59:24.980]                         }
[17:59:24.980]                         base::stop(msg)
[17:59:24.980]                       }
[17:59:24.980]                     })
[17:59:24.980]                   }
[17:59:24.980]                   ...future.strategy.old <- future::plan("list")
[17:59:24.980]                   options(future.plan = NULL)
[17:59:24.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:24.980]                 }
[17:59:24.980]                 ...future.workdir <- getwd()
[17:59:24.980]             }
[17:59:24.980]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:24.980]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:24.980]         }
[17:59:24.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:24.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:24.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:24.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:24.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:24.980]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:24.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:24.980]             base::names(...future.oldOptions))
[17:59:24.980]     }
[17:59:24.980]     if (FALSE) {
[17:59:24.980]     }
[17:59:24.980]     else {
[17:59:24.980]         if (TRUE) {
[17:59:24.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:24.980]                 open = "w")
[17:59:24.980]         }
[17:59:24.980]         else {
[17:59:24.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:24.980]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:24.980]         }
[17:59:24.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:24.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:24.980]             base::sink(type = "output", split = FALSE)
[17:59:24.980]             base::close(...future.stdout)
[17:59:24.980]         }, add = TRUE)
[17:59:24.980]     }
[17:59:24.980]     ...future.frame <- base::sys.nframe()
[17:59:24.980]     ...future.conditions <- base::list()
[17:59:24.980]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:24.980]     if (FALSE) {
[17:59:24.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:24.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:24.980]     }
[17:59:24.980]     ...future.result <- base::tryCatch({
[17:59:24.980]         base::withCallingHandlers({
[17:59:24.980]             ...future.value <- base::withVisible(base::local({
[17:59:24.980]                 do.call(function(...) {
[17:59:24.980]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:24.980]                   if (!identical(...future.globals.maxSize.org, 
[17:59:24.980]                     ...future.globals.maxSize)) {
[17:59:24.980]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:24.980]                     on.exit(options(oopts), add = TRUE)
[17:59:24.980]                   }
[17:59:24.980]                   {
[17:59:24.980]                     lapply(seq_along(...future.elements_ii), 
[17:59:24.980]                       FUN = function(jj) {
[17:59:24.980]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:24.980]                         ...future.FUN(...future.X_jj, ...)
[17:59:24.980]                       })
[17:59:24.980]                   }
[17:59:24.980]                 }, args = future.call.arguments)
[17:59:24.980]             }))
[17:59:24.980]             future::FutureResult(value = ...future.value$value, 
[17:59:24.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.980]                   ...future.rng), globalenv = if (FALSE) 
[17:59:24.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:24.980]                     ...future.globalenv.names))
[17:59:24.980]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:24.980]         }, condition = base::local({
[17:59:24.980]             c <- base::c
[17:59:24.980]             inherits <- base::inherits
[17:59:24.980]             invokeRestart <- base::invokeRestart
[17:59:24.980]             length <- base::length
[17:59:24.980]             list <- base::list
[17:59:24.980]             seq.int <- base::seq.int
[17:59:24.980]             signalCondition <- base::signalCondition
[17:59:24.980]             sys.calls <- base::sys.calls
[17:59:24.980]             `[[` <- base::`[[`
[17:59:24.980]             `+` <- base::`+`
[17:59:24.980]             `<<-` <- base::`<<-`
[17:59:24.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:24.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:24.980]                   3L)]
[17:59:24.980]             }
[17:59:24.980]             function(cond) {
[17:59:24.980]                 is_error <- inherits(cond, "error")
[17:59:24.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:24.980]                   NULL)
[17:59:24.980]                 if (is_error) {
[17:59:24.980]                   sessionInformation <- function() {
[17:59:24.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:24.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:24.980]                       search = base::search(), system = base::Sys.info())
[17:59:24.980]                   }
[17:59:24.980]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:24.980]                     cond$call), session = sessionInformation(), 
[17:59:24.980]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:24.980]                   signalCondition(cond)
[17:59:24.980]                 }
[17:59:24.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:24.980]                 "immediateCondition"))) {
[17:59:24.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:24.980]                   ...future.conditions[[length(...future.conditions) + 
[17:59:24.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:24.980]                   if (TRUE && !signal) {
[17:59:24.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.980]                     {
[17:59:24.980]                       inherits <- base::inherits
[17:59:24.980]                       invokeRestart <- base::invokeRestart
[17:59:24.980]                       is.null <- base::is.null
[17:59:24.980]                       muffled <- FALSE
[17:59:24.980]                       if (inherits(cond, "message")) {
[17:59:24.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.980]                         if (muffled) 
[17:59:24.980]                           invokeRestart("muffleMessage")
[17:59:24.980]                       }
[17:59:24.980]                       else if (inherits(cond, "warning")) {
[17:59:24.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.980]                         if (muffled) 
[17:59:24.980]                           invokeRestart("muffleWarning")
[17:59:24.980]                       }
[17:59:24.980]                       else if (inherits(cond, "condition")) {
[17:59:24.980]                         if (!is.null(pattern)) {
[17:59:24.980]                           computeRestarts <- base::computeRestarts
[17:59:24.980]                           grepl <- base::grepl
[17:59:24.980]                           restarts <- computeRestarts(cond)
[17:59:24.980]                           for (restart in restarts) {
[17:59:24.980]                             name <- restart$name
[17:59:24.980]                             if (is.null(name)) 
[17:59:24.980]                               next
[17:59:24.980]                             if (!grepl(pattern, name)) 
[17:59:24.980]                               next
[17:59:24.980]                             invokeRestart(restart)
[17:59:24.980]                             muffled <- TRUE
[17:59:24.980]                             break
[17:59:24.980]                           }
[17:59:24.980]                         }
[17:59:24.980]                       }
[17:59:24.980]                       invisible(muffled)
[17:59:24.980]                     }
[17:59:24.980]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.980]                   }
[17:59:24.980]                 }
[17:59:24.980]                 else {
[17:59:24.980]                   if (TRUE) {
[17:59:24.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:24.980]                     {
[17:59:24.980]                       inherits <- base::inherits
[17:59:24.980]                       invokeRestart <- base::invokeRestart
[17:59:24.980]                       is.null <- base::is.null
[17:59:24.980]                       muffled <- FALSE
[17:59:24.980]                       if (inherits(cond, "message")) {
[17:59:24.980]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:24.980]                         if (muffled) 
[17:59:24.980]                           invokeRestart("muffleMessage")
[17:59:24.980]                       }
[17:59:24.980]                       else if (inherits(cond, "warning")) {
[17:59:24.980]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:24.980]                         if (muffled) 
[17:59:24.980]                           invokeRestart("muffleWarning")
[17:59:24.980]                       }
[17:59:24.980]                       else if (inherits(cond, "condition")) {
[17:59:24.980]                         if (!is.null(pattern)) {
[17:59:24.980]                           computeRestarts <- base::computeRestarts
[17:59:24.980]                           grepl <- base::grepl
[17:59:24.980]                           restarts <- computeRestarts(cond)
[17:59:24.980]                           for (restart in restarts) {
[17:59:24.980]                             name <- restart$name
[17:59:24.980]                             if (is.null(name)) 
[17:59:24.980]                               next
[17:59:24.980]                             if (!grepl(pattern, name)) 
[17:59:24.980]                               next
[17:59:24.980]                             invokeRestart(restart)
[17:59:24.980]                             muffled <- TRUE
[17:59:24.980]                             break
[17:59:24.980]                           }
[17:59:24.980]                         }
[17:59:24.980]                       }
[17:59:24.980]                       invisible(muffled)
[17:59:24.980]                     }
[17:59:24.980]                     muffleCondition(cond, pattern = "^muffle")
[17:59:24.980]                   }
[17:59:24.980]                 }
[17:59:24.980]             }
[17:59:24.980]         }))
[17:59:24.980]     }, error = function(ex) {
[17:59:24.980]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:24.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:24.980]                 ...future.rng), started = ...future.startTime, 
[17:59:24.980]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:24.980]             version = "1.8"), class = "FutureResult")
[17:59:24.980]     }, finally = {
[17:59:24.980]         if (!identical(...future.workdir, getwd())) 
[17:59:24.980]             setwd(...future.workdir)
[17:59:24.980]         {
[17:59:24.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:24.980]                 ...future.oldOptions$nwarnings <- NULL
[17:59:24.980]             }
[17:59:24.980]             base::options(...future.oldOptions)
[17:59:24.980]             if (.Platform$OS.type == "windows") {
[17:59:24.980]                 old_names <- names(...future.oldEnvVars)
[17:59:24.980]                 envs <- base::Sys.getenv()
[17:59:24.980]                 names <- names(envs)
[17:59:24.980]                 common <- intersect(names, old_names)
[17:59:24.980]                 added <- setdiff(names, old_names)
[17:59:24.980]                 removed <- setdiff(old_names, names)
[17:59:24.980]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:24.980]                   envs[common]]
[17:59:24.980]                 NAMES <- toupper(changed)
[17:59:24.980]                 args <- list()
[17:59:24.980]                 for (kk in seq_along(NAMES)) {
[17:59:24.980]                   name <- changed[[kk]]
[17:59:24.980]                   NAME <- NAMES[[kk]]
[17:59:24.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.980]                     next
[17:59:24.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.980]                 }
[17:59:24.980]                 NAMES <- toupper(added)
[17:59:24.980]                 for (kk in seq_along(NAMES)) {
[17:59:24.980]                   name <- added[[kk]]
[17:59:24.980]                   NAME <- NAMES[[kk]]
[17:59:24.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.980]                     next
[17:59:24.980]                   args[[name]] <- ""
[17:59:24.980]                 }
[17:59:24.980]                 NAMES <- toupper(removed)
[17:59:24.980]                 for (kk in seq_along(NAMES)) {
[17:59:24.980]                   name <- removed[[kk]]
[17:59:24.980]                   NAME <- NAMES[[kk]]
[17:59:24.980]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:24.980]                     next
[17:59:24.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:24.980]                 }
[17:59:24.980]                 if (length(args) > 0) 
[17:59:24.980]                   base::do.call(base::Sys.setenv, args = args)
[17:59:24.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:24.980]             }
[17:59:24.980]             else {
[17:59:24.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:24.980]             }
[17:59:24.980]             {
[17:59:24.980]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:24.980]                   0L) {
[17:59:24.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:24.980]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:24.980]                   base::options(opts)
[17:59:24.980]                 }
[17:59:24.980]                 {
[17:59:24.980]                   {
[17:59:24.980]                     NULL
[17:59:24.980]                     RNGkind("Mersenne-Twister")
[17:59:24.980]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:24.980]                       inherits = FALSE)
[17:59:24.980]                   }
[17:59:24.980]                   options(future.plan = NULL)
[17:59:24.980]                   if (is.na(NA_character_)) 
[17:59:24.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:24.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:24.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:24.980]                     .init = FALSE)
[17:59:24.980]                 }
[17:59:24.980]             }
[17:59:24.980]         }
[17:59:24.980]     })
[17:59:24.980]     if (TRUE) {
[17:59:24.980]         base::sink(type = "output", split = FALSE)
[17:59:24.980]         if (TRUE) {
[17:59:24.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:24.980]         }
[17:59:24.980]         else {
[17:59:24.980]             ...future.result["stdout"] <- base::list(NULL)
[17:59:24.980]         }
[17:59:24.980]         base::close(...future.stdout)
[17:59:24.980]         ...future.stdout <- NULL
[17:59:24.980]     }
[17:59:24.980]     ...future.result$conditions <- ...future.conditions
[17:59:24.980]     ...future.result$finished <- base::Sys.time()
[17:59:24.980]     ...future.result
[17:59:24.980] }
[17:59:24.983] assign_globals() ...
[17:59:24.983] List of 5
[17:59:24.983]  $ ...future.FUN            :function (object, ...)  
[17:59:24.983]  $ future.call.arguments    : list()
[17:59:24.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:24.983]  $ ...future.elements_ii    :List of 3
[17:59:24.983]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:24.983]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:24.983]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.983]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:24.983]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:24.983]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.983]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:24.983]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:24.983]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:24.983]  $ ...future.seeds_ii       : NULL
[17:59:24.983]  $ ...future.globals.maxSize: NULL
[17:59:24.983]  - attr(*, "where")=List of 5
[17:59:24.983]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:24.983]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:24.983]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:24.983]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:24.983]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:24.983]  - attr(*, "resolved")= logi FALSE
[17:59:24.983]  - attr(*, "total_size")= num 1240
[17:59:24.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:24.983]  - attr(*, "already-done")= logi TRUE
[17:59:24.998] - copied ‘...future.FUN’ to environment
[17:59:24.998] - copied ‘future.call.arguments’ to environment
[17:59:24.998] - copied ‘...future.elements_ii’ to environment
[17:59:24.999] - copied ‘...future.seeds_ii’ to environment
[17:59:24.999] - copied ‘...future.globals.maxSize’ to environment
[17:59:24.999] assign_globals() ... done
[17:59:25.000] plan(): Setting new future strategy stack:
[17:59:25.000] List of future strategies:
[17:59:25.000] 1. sequential:
[17:59:25.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.000]    - tweaked: FALSE
[17:59:25.000]    - call: NULL
[17:59:25.001] plan(): nbrOfWorkers() = 1
[17:59:25.004] plan(): Setting new future strategy stack:
[17:59:25.005] List of future strategies:
[17:59:25.005] 1. multisession:
[17:59:25.005]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:25.005]    - tweaked: FALSE
[17:59:25.005]    - call: plan(strategy)
[17:59:25.011] plan(): nbrOfWorkers() = 1
[17:59:25.011] SequentialFuture started (and completed)
[17:59:25.011] - Launch lazy future ... done
[17:59:25.011] run() for ‘SequentialFuture’ ... done
[17:59:25.012] Created future:
[17:59:25.012] SequentialFuture:
[17:59:25.012] Label: ‘future_by-1’
[17:59:25.012] Expression:
[17:59:25.012] {
[17:59:25.012]     do.call(function(...) {
[17:59:25.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.012]             on.exit(options(oopts), add = TRUE)
[17:59:25.012]         }
[17:59:25.012]         {
[17:59:25.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.012]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.012]             })
[17:59:25.012]         }
[17:59:25.012]     }, args = future.call.arguments)
[17:59:25.012] }
[17:59:25.012] Lazy evaluation: FALSE
[17:59:25.012] Asynchronous evaluation: FALSE
[17:59:25.012] Local evaluation: TRUE
[17:59:25.012] Environment: R_GlobalEnv
[17:59:25.012] Capture standard output: TRUE
[17:59:25.012] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.012] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.012] Packages: <none>
[17:59:25.012] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.012] Resolved: TRUE
[17:59:25.012] Value: 4.62 KiB of class ‘list’
[17:59:25.012] Early signaling: FALSE
[17:59:25.012] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.012] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.014] Chunk #1 of 1 ... DONE
[17:59:25.015] Launching 1 futures (chunks) ... DONE
[17:59:25.015] Resolving 1 futures (chunks) ...
[17:59:25.015] resolve() on list ...
[17:59:25.015]  recursive: 0
[17:59:25.015]  length: 1
[17:59:25.016] 
[17:59:25.016] resolved() for ‘SequentialFuture’ ...
[17:59:25.016] - state: ‘finished’
[17:59:25.016] - run: TRUE
[17:59:25.016] - result: ‘FutureResult’
[17:59:25.017] resolved() for ‘SequentialFuture’ ... done
[17:59:25.017] Future #1
[17:59:25.017] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.017] - nx: 1
[17:59:25.020] - relay: TRUE
[17:59:25.020] - stdout: TRUE
[17:59:25.020] - signal: TRUE
[17:59:25.020] - resignal: FALSE
[17:59:25.021] - force: TRUE
[17:59:25.021] - relayed: [n=1] FALSE
[17:59:25.021] - queued futures: [n=1] FALSE
[17:59:25.021]  - until=1
[17:59:25.021]  - relaying element #1
[17:59:25.022] - relayed: [n=1] TRUE
[17:59:25.022] - queued futures: [n=1] TRUE
[17:59:25.022] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.022]  length: 0 (resolved future 1)
[17:59:25.023] Relaying remaining futures
[17:59:25.023] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.023] - nx: 1
[17:59:25.023] - relay: TRUE
[17:59:25.023] - stdout: TRUE
[17:59:25.024] - signal: TRUE
[17:59:25.024] - resignal: FALSE
[17:59:25.024] - force: TRUE
[17:59:25.024] - relayed: [n=1] TRUE
[17:59:25.024] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.025] - relayed: [n=1] TRUE
[17:59:25.025] - queued futures: [n=1] TRUE
[17:59:25.025] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.025] resolve() on list ... DONE
[17:59:25.026]  - Number of value chunks collected: 1
[17:59:25.026] Resolving 1 futures (chunks) ... DONE
[17:59:25.026] Reducing values from 1 chunks ...
[17:59:25.026]  - Number of values collected after concatenation: 3
[17:59:25.026]  - Number of values expected: 3
[17:59:25.026] Reducing values from 1 chunks ... DONE
[17:59:25.027] future_lapply() ... DONE
[17:59:25.027] future_by_internal() ... DONE
[17:59:25.027] future_by_internal() ...
[17:59:25.028] future_lapply() ...
[17:59:25.034] Number of chunks: 1
[17:59:25.035] getGlobalsAndPackagesXApply() ...
[17:59:25.035]  - future.globals: TRUE
[17:59:25.035] getGlobalsAndPackages() ...
[17:59:25.035] Searching for globals...
[17:59:25.038] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:25.038] Searching for globals ... DONE
[17:59:25.038] Resolving globals: FALSE
[17:59:25.039] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:25.039] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:25.040] - globals: [1] ‘FUN’
[17:59:25.040] 
[17:59:25.040] getGlobalsAndPackages() ... DONE
[17:59:25.040]  - globals found/used: [n=1] ‘FUN’
[17:59:25.040]  - needed namespaces: [n=0] 
[17:59:25.041] Finding globals ... DONE
[17:59:25.041]  - use_args: TRUE
[17:59:25.041]  - Getting '...' globals ...
[17:59:25.042] resolve() on list ...
[17:59:25.042]  recursive: 0
[17:59:25.042]  length: 1
[17:59:25.042]  elements: ‘...’
[17:59:25.042]  length: 0 (resolved future 1)
[17:59:25.043] resolve() on list ... DONE
[17:59:25.043]    - '...' content: [n=1] ‘digits’
[17:59:25.043] List of 1
[17:59:25.043]  $ ...:List of 1
[17:59:25.043]   ..$ digits: int 2
[17:59:25.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.043]  - attr(*, "where")=List of 1
[17:59:25.043]   ..$ ...:<environment: 0x62649f0245b8> 
[17:59:25.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.043]  - attr(*, "resolved")= logi TRUE
[17:59:25.043]  - attr(*, "total_size")= num NA
[17:59:25.049]  - Getting '...' globals ... DONE
[17:59:25.049] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.049] List of 2
[17:59:25.049]  $ ...future.FUN:function (object, ...)  
[17:59:25.049]  $ ...          :List of 1
[17:59:25.049]   ..$ digits: int 2
[17:59:25.049]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.049]  - attr(*, "where")=List of 2
[17:59:25.049]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.049]   ..$ ...          :<environment: 0x62649f0245b8> 
[17:59:25.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.049]  - attr(*, "resolved")= logi FALSE
[17:59:25.049]  - attr(*, "total_size")= num 1296
[17:59:25.056] Packages to be attached in all futures: [n=0] 
[17:59:25.056] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.056] Number of futures (= number of chunks): 1
[17:59:25.056] Launching 1 futures (chunks) ...
[17:59:25.057] Chunk #1 of 1 ...
[17:59:25.057]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.057] getGlobalsAndPackages() ...
[17:59:25.057] Searching for globals...
[17:59:25.058] 
[17:59:25.058] Searching for globals ... DONE
[17:59:25.058] - globals: [0] <none>
[17:59:25.058] getGlobalsAndPackages() ... DONE
[17:59:25.059]    + additional globals found: [n=0] 
[17:59:25.059]    + additional namespaces needed: [n=0] 
[17:59:25.059]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.059]  - seeds: <none>
[17:59:25.059]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.060] getGlobalsAndPackages() ...
[17:59:25.060] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.060] Resolving globals: FALSE
[17:59:25.060] Tweak future expression to call with '...' arguments ...
[17:59:25.060] {
[17:59:25.060]     do.call(function(...) {
[17:59:25.060]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.060]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.060]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.060]             on.exit(options(oopts), add = TRUE)
[17:59:25.060]         }
[17:59:25.060]         {
[17:59:25.060]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.060]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.060]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.060]             })
[17:59:25.060]         }
[17:59:25.060]     }, args = future.call.arguments)
[17:59:25.060] }
[17:59:25.061] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.062] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.062] 
[17:59:25.062] getGlobalsAndPackages() ... DONE
[17:59:25.063] run() for ‘Future’ ...
[17:59:25.063] - state: ‘created’
[17:59:25.063] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:25.069] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.070]   - Field: ‘label’
[17:59:25.070]   - Field: ‘local’
[17:59:25.070]   - Field: ‘owner’
[17:59:25.070]   - Field: ‘envir’
[17:59:25.071]   - Field: ‘packages’
[17:59:25.073]   - Field: ‘gc’
[17:59:25.073]   - Field: ‘conditions’
[17:59:25.074]   - Field: ‘expr’
[17:59:25.074]   - Field: ‘uuid’
[17:59:25.074]   - Field: ‘seed’
[17:59:25.074]   - Field: ‘version’
[17:59:25.074]   - Field: ‘result’
[17:59:25.075]   - Field: ‘asynchronous’
[17:59:25.075]   - Field: ‘calls’
[17:59:25.075]   - Field: ‘globals’
[17:59:25.075]   - Field: ‘stdout’
[17:59:25.076]   - Field: ‘earlySignal’
[17:59:25.076]   - Field: ‘lazy’
[17:59:25.076]   - Field: ‘state’
[17:59:25.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.076] - Launch lazy future ...
[17:59:25.077] Packages needed by the future expression (n = 0): <none>
[17:59:25.077] Packages needed by future strategies (n = 0): <none>
[17:59:25.078] {
[17:59:25.078]     {
[17:59:25.078]         {
[17:59:25.078]             ...future.startTime <- base::Sys.time()
[17:59:25.078]             {
[17:59:25.078]                 {
[17:59:25.078]                   {
[17:59:25.078]                     base::local({
[17:59:25.078]                       has_future <- base::requireNamespace("future", 
[17:59:25.078]                         quietly = TRUE)
[17:59:25.078]                       if (has_future) {
[17:59:25.078]                         ns <- base::getNamespace("future")
[17:59:25.078]                         version <- ns[[".package"]][["version"]]
[17:59:25.078]                         if (is.null(version)) 
[17:59:25.078]                           version <- utils::packageVersion("future")
[17:59:25.078]                       }
[17:59:25.078]                       else {
[17:59:25.078]                         version <- NULL
[17:59:25.078]                       }
[17:59:25.078]                       if (!has_future || version < "1.8.0") {
[17:59:25.078]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.078]                           "", base::R.version$version.string), 
[17:59:25.078]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:25.078]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.078]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.078]                             "release", "version")], collapse = " "), 
[17:59:25.078]                           hostname = base::Sys.info()[["nodename"]])
[17:59:25.078]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.078]                           info)
[17:59:25.078]                         info <- base::paste(info, collapse = "; ")
[17:59:25.078]                         if (!has_future) {
[17:59:25.078]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.078]                             info)
[17:59:25.078]                         }
[17:59:25.078]                         else {
[17:59:25.078]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.078]                             info, version)
[17:59:25.078]                         }
[17:59:25.078]                         base::stop(msg)
[17:59:25.078]                       }
[17:59:25.078]                     })
[17:59:25.078]                   }
[17:59:25.078]                   ...future.strategy.old <- future::plan("list")
[17:59:25.078]                   options(future.plan = NULL)
[17:59:25.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.078]                 }
[17:59:25.078]                 ...future.workdir <- getwd()
[17:59:25.078]             }
[17:59:25.078]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.078]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.078]         }
[17:59:25.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.078]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.078]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.078]             base::names(...future.oldOptions))
[17:59:25.078]     }
[17:59:25.078]     if (FALSE) {
[17:59:25.078]     }
[17:59:25.078]     else {
[17:59:25.078]         if (TRUE) {
[17:59:25.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.078]                 open = "w")
[17:59:25.078]         }
[17:59:25.078]         else {
[17:59:25.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.078]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.078]         }
[17:59:25.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.078]             base::sink(type = "output", split = FALSE)
[17:59:25.078]             base::close(...future.stdout)
[17:59:25.078]         }, add = TRUE)
[17:59:25.078]     }
[17:59:25.078]     ...future.frame <- base::sys.nframe()
[17:59:25.078]     ...future.conditions <- base::list()
[17:59:25.078]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.078]     if (FALSE) {
[17:59:25.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.078]     }
[17:59:25.078]     ...future.result <- base::tryCatch({
[17:59:25.078]         base::withCallingHandlers({
[17:59:25.078]             ...future.value <- base::withVisible(base::local({
[17:59:25.078]                 do.call(function(...) {
[17:59:25.078]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.078]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.078]                     ...future.globals.maxSize)) {
[17:59:25.078]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.078]                     on.exit(options(oopts), add = TRUE)
[17:59:25.078]                   }
[17:59:25.078]                   {
[17:59:25.078]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.078]                       FUN = function(jj) {
[17:59:25.078]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.078]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.078]                       })
[17:59:25.078]                   }
[17:59:25.078]                 }, args = future.call.arguments)
[17:59:25.078]             }))
[17:59:25.078]             future::FutureResult(value = ...future.value$value, 
[17:59:25.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.078]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.078]                     ...future.globalenv.names))
[17:59:25.078]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.078]         }, condition = base::local({
[17:59:25.078]             c <- base::c
[17:59:25.078]             inherits <- base::inherits
[17:59:25.078]             invokeRestart <- base::invokeRestart
[17:59:25.078]             length <- base::length
[17:59:25.078]             list <- base::list
[17:59:25.078]             seq.int <- base::seq.int
[17:59:25.078]             signalCondition <- base::signalCondition
[17:59:25.078]             sys.calls <- base::sys.calls
[17:59:25.078]             `[[` <- base::`[[`
[17:59:25.078]             `+` <- base::`+`
[17:59:25.078]             `<<-` <- base::`<<-`
[17:59:25.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.078]                   3L)]
[17:59:25.078]             }
[17:59:25.078]             function(cond) {
[17:59:25.078]                 is_error <- inherits(cond, "error")
[17:59:25.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.078]                   NULL)
[17:59:25.078]                 if (is_error) {
[17:59:25.078]                   sessionInformation <- function() {
[17:59:25.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.078]                       search = base::search(), system = base::Sys.info())
[17:59:25.078]                   }
[17:59:25.078]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.078]                     cond$call), session = sessionInformation(), 
[17:59:25.078]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.078]                   signalCondition(cond)
[17:59:25.078]                 }
[17:59:25.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.078]                 "immediateCondition"))) {
[17:59:25.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.078]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.078]                   if (TRUE && !signal) {
[17:59:25.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.078]                     {
[17:59:25.078]                       inherits <- base::inherits
[17:59:25.078]                       invokeRestart <- base::invokeRestart
[17:59:25.078]                       is.null <- base::is.null
[17:59:25.078]                       muffled <- FALSE
[17:59:25.078]                       if (inherits(cond, "message")) {
[17:59:25.078]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.078]                         if (muffled) 
[17:59:25.078]                           invokeRestart("muffleMessage")
[17:59:25.078]                       }
[17:59:25.078]                       else if (inherits(cond, "warning")) {
[17:59:25.078]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.078]                         if (muffled) 
[17:59:25.078]                           invokeRestart("muffleWarning")
[17:59:25.078]                       }
[17:59:25.078]                       else if (inherits(cond, "condition")) {
[17:59:25.078]                         if (!is.null(pattern)) {
[17:59:25.078]                           computeRestarts <- base::computeRestarts
[17:59:25.078]                           grepl <- base::grepl
[17:59:25.078]                           restarts <- computeRestarts(cond)
[17:59:25.078]                           for (restart in restarts) {
[17:59:25.078]                             name <- restart$name
[17:59:25.078]                             if (is.null(name)) 
[17:59:25.078]                               next
[17:59:25.078]                             if (!grepl(pattern, name)) 
[17:59:25.078]                               next
[17:59:25.078]                             invokeRestart(restart)
[17:59:25.078]                             muffled <- TRUE
[17:59:25.078]                             break
[17:59:25.078]                           }
[17:59:25.078]                         }
[17:59:25.078]                       }
[17:59:25.078]                       invisible(muffled)
[17:59:25.078]                     }
[17:59:25.078]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.078]                   }
[17:59:25.078]                 }
[17:59:25.078]                 else {
[17:59:25.078]                   if (TRUE) {
[17:59:25.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.078]                     {
[17:59:25.078]                       inherits <- base::inherits
[17:59:25.078]                       invokeRestart <- base::invokeRestart
[17:59:25.078]                       is.null <- base::is.null
[17:59:25.078]                       muffled <- FALSE
[17:59:25.078]                       if (inherits(cond, "message")) {
[17:59:25.078]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.078]                         if (muffled) 
[17:59:25.078]                           invokeRestart("muffleMessage")
[17:59:25.078]                       }
[17:59:25.078]                       else if (inherits(cond, "warning")) {
[17:59:25.078]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.078]                         if (muffled) 
[17:59:25.078]                           invokeRestart("muffleWarning")
[17:59:25.078]                       }
[17:59:25.078]                       else if (inherits(cond, "condition")) {
[17:59:25.078]                         if (!is.null(pattern)) {
[17:59:25.078]                           computeRestarts <- base::computeRestarts
[17:59:25.078]                           grepl <- base::grepl
[17:59:25.078]                           restarts <- computeRestarts(cond)
[17:59:25.078]                           for (restart in restarts) {
[17:59:25.078]                             name <- restart$name
[17:59:25.078]                             if (is.null(name)) 
[17:59:25.078]                               next
[17:59:25.078]                             if (!grepl(pattern, name)) 
[17:59:25.078]                               next
[17:59:25.078]                             invokeRestart(restart)
[17:59:25.078]                             muffled <- TRUE
[17:59:25.078]                             break
[17:59:25.078]                           }
[17:59:25.078]                         }
[17:59:25.078]                       }
[17:59:25.078]                       invisible(muffled)
[17:59:25.078]                     }
[17:59:25.078]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.078]                   }
[17:59:25.078]                 }
[17:59:25.078]             }
[17:59:25.078]         }))
[17:59:25.078]     }, error = function(ex) {
[17:59:25.078]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.078]                 ...future.rng), started = ...future.startTime, 
[17:59:25.078]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.078]             version = "1.8"), class = "FutureResult")
[17:59:25.078]     }, finally = {
[17:59:25.078]         if (!identical(...future.workdir, getwd())) 
[17:59:25.078]             setwd(...future.workdir)
[17:59:25.078]         {
[17:59:25.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.078]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.078]             }
[17:59:25.078]             base::options(...future.oldOptions)
[17:59:25.078]             if (.Platform$OS.type == "windows") {
[17:59:25.078]                 old_names <- names(...future.oldEnvVars)
[17:59:25.078]                 envs <- base::Sys.getenv()
[17:59:25.078]                 names <- names(envs)
[17:59:25.078]                 common <- intersect(names, old_names)
[17:59:25.078]                 added <- setdiff(names, old_names)
[17:59:25.078]                 removed <- setdiff(old_names, names)
[17:59:25.078]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.078]                   envs[common]]
[17:59:25.078]                 NAMES <- toupper(changed)
[17:59:25.078]                 args <- list()
[17:59:25.078]                 for (kk in seq_along(NAMES)) {
[17:59:25.078]                   name <- changed[[kk]]
[17:59:25.078]                   NAME <- NAMES[[kk]]
[17:59:25.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.078]                     next
[17:59:25.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.078]                 }
[17:59:25.078]                 NAMES <- toupper(added)
[17:59:25.078]                 for (kk in seq_along(NAMES)) {
[17:59:25.078]                   name <- added[[kk]]
[17:59:25.078]                   NAME <- NAMES[[kk]]
[17:59:25.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.078]                     next
[17:59:25.078]                   args[[name]] <- ""
[17:59:25.078]                 }
[17:59:25.078]                 NAMES <- toupper(removed)
[17:59:25.078]                 for (kk in seq_along(NAMES)) {
[17:59:25.078]                   name <- removed[[kk]]
[17:59:25.078]                   NAME <- NAMES[[kk]]
[17:59:25.078]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.078]                     next
[17:59:25.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.078]                 }
[17:59:25.078]                 if (length(args) > 0) 
[17:59:25.078]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.078]             }
[17:59:25.078]             else {
[17:59:25.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.078]             }
[17:59:25.078]             {
[17:59:25.078]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.078]                   0L) {
[17:59:25.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.078]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.078]                   base::options(opts)
[17:59:25.078]                 }
[17:59:25.078]                 {
[17:59:25.078]                   {
[17:59:25.078]                     NULL
[17:59:25.078]                     RNGkind("Mersenne-Twister")
[17:59:25.078]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.078]                       inherits = FALSE)
[17:59:25.078]                   }
[17:59:25.078]                   options(future.plan = NULL)
[17:59:25.078]                   if (is.na(NA_character_)) 
[17:59:25.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.078]                     .init = FALSE)
[17:59:25.078]                 }
[17:59:25.078]             }
[17:59:25.078]         }
[17:59:25.078]     })
[17:59:25.078]     if (TRUE) {
[17:59:25.078]         base::sink(type = "output", split = FALSE)
[17:59:25.078]         if (TRUE) {
[17:59:25.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.078]         }
[17:59:25.078]         else {
[17:59:25.078]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.078]         }
[17:59:25.078]         base::close(...future.stdout)
[17:59:25.078]         ...future.stdout <- NULL
[17:59:25.078]     }
[17:59:25.078]     ...future.result$conditions <- ...future.conditions
[17:59:25.078]     ...future.result$finished <- base::Sys.time()
[17:59:25.078]     ...future.result
[17:59:25.078] }
[17:59:25.081] assign_globals() ...
[17:59:25.081] List of 5
[17:59:25.081]  $ ...future.FUN            :function (object, ...)  
[17:59:25.081]  $ future.call.arguments    :List of 1
[17:59:25.081]   ..$ digits: int 2
[17:59:25.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.081]  $ ...future.elements_ii    :List of 6
[17:59:25.081]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:59:25.081]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:59:25.081]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:59:25.081]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:59:25.081]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:59:25.081]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:59:25.081]  $ ...future.seeds_ii       : NULL
[17:59:25.081]  $ ...future.globals.maxSize: NULL
[17:59:25.081]  - attr(*, "where")=List of 5
[17:59:25.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.081]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.081]  - attr(*, "resolved")= logi FALSE
[17:59:25.081]  - attr(*, "total_size")= num 1296
[17:59:25.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.081]  - attr(*, "already-done")= logi TRUE
[17:59:25.095] - copied ‘...future.FUN’ to environment
[17:59:25.095] - copied ‘future.call.arguments’ to environment
[17:59:25.095] - copied ‘...future.elements_ii’ to environment
[17:59:25.095] - copied ‘...future.seeds_ii’ to environment
[17:59:25.096] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.096] assign_globals() ... done
[17:59:25.096] plan(): Setting new future strategy stack:
[17:59:25.096] List of future strategies:
[17:59:25.096] 1. sequential:
[17:59:25.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.096]    - tweaked: FALSE
[17:59:25.096]    - call: NULL
[17:59:25.097] plan(): nbrOfWorkers() = 1
[17:59:25.100] plan(): Setting new future strategy stack:
[17:59:25.100] List of future strategies:
[17:59:25.100] 1. multisession:
[17:59:25.100]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:25.100]    - tweaked: FALSE
[17:59:25.100]    - call: plan(strategy)
[17:59:25.106] plan(): nbrOfWorkers() = 1
[17:59:25.107] SequentialFuture started (and completed)
[17:59:25.107] - Launch lazy future ... done
[17:59:25.107] run() for ‘SequentialFuture’ ... done
[17:59:25.108] Created future:
[17:59:25.108] SequentialFuture:
[17:59:25.108] Label: ‘future_by-1’
[17:59:25.108] Expression:
[17:59:25.108] {
[17:59:25.108]     do.call(function(...) {
[17:59:25.108]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.108]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.108]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.108]             on.exit(options(oopts), add = TRUE)
[17:59:25.108]         }
[17:59:25.108]         {
[17:59:25.108]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.108]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.108]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.108]             })
[17:59:25.108]         }
[17:59:25.108]     }, args = future.call.arguments)
[17:59:25.108] }
[17:59:25.108] Lazy evaluation: FALSE
[17:59:25.108] Asynchronous evaluation: FALSE
[17:59:25.108] Local evaluation: TRUE
[17:59:25.108] Environment: R_GlobalEnv
[17:59:25.108] Capture standard output: TRUE
[17:59:25.108] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.108] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.108] Packages: <none>
[17:59:25.108] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.108] Resolved: TRUE
[17:59:25.108] Value: 5.48 KiB of class ‘list’
[17:59:25.108] Early signaling: FALSE
[17:59:25.108] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.108] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.110] Chunk #1 of 1 ... DONE
[17:59:25.110] Launching 1 futures (chunks) ... DONE
[17:59:25.111] Resolving 1 futures (chunks) ...
[17:59:25.111] resolve() on list ...
[17:59:25.111]  recursive: 0
[17:59:25.111]  length: 1
[17:59:25.112] 
[17:59:25.112] resolved() for ‘SequentialFuture’ ...
[17:59:25.112] - state: ‘finished’
[17:59:25.112] - run: TRUE
[17:59:25.112] - result: ‘FutureResult’
[17:59:25.113] resolved() for ‘SequentialFuture’ ... done
[17:59:25.113] Future #1
[17:59:25.113] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.113] - nx: 1
[17:59:25.114] - relay: TRUE
[17:59:25.114] - stdout: TRUE
[17:59:25.114] - signal: TRUE
[17:59:25.114] - resignal: FALSE
[17:59:25.114] - force: TRUE
[17:59:25.114] - relayed: [n=1] FALSE
[17:59:25.115] - queued futures: [n=1] FALSE
[17:59:25.115]  - until=1
[17:59:25.116]  - relaying element #1
[17:59:25.116] - relayed: [n=1] TRUE
[17:59:25.117] - queued futures: [n=1] TRUE
[17:59:25.117] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.117]  length: 0 (resolved future 1)
[17:59:25.117] Relaying remaining futures
[17:59:25.117] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.118] - nx: 1
[17:59:25.118] - relay: TRUE
[17:59:25.118] - stdout: TRUE
[17:59:25.118] - signal: TRUE
[17:59:25.118] - resignal: FALSE
[17:59:25.119] - force: TRUE
[17:59:25.119] - relayed: [n=1] TRUE
[17:59:25.119] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.119] - relayed: [n=1] TRUE
[17:59:25.119] - queued futures: [n=1] TRUE
[17:59:25.120] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.120] resolve() on list ... DONE
[17:59:25.120]  - Number of value chunks collected: 1
[17:59:25.120] Resolving 1 futures (chunks) ... DONE
[17:59:25.121] Reducing values from 1 chunks ...
[17:59:25.121]  - Number of values collected after concatenation: 6
[17:59:25.121]  - Number of values expected: 6
[17:59:25.121] Reducing values from 1 chunks ... DONE
[17:59:25.121] future_lapply() ... DONE
[17:59:25.122] future_by_internal() ... DONE
[17:59:25.126] future_by_internal() ...
[17:59:25.127] future_lapply() ...
[17:59:25.135] Number of chunks: 1
[17:59:25.135] getGlobalsAndPackagesXApply() ...
[17:59:25.135]  - future.globals: TRUE
[17:59:25.136] getGlobalsAndPackages() ...
[17:59:25.136] Searching for globals...
[17:59:25.139] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:25.140] Searching for globals ... DONE
[17:59:25.140] Resolving globals: FALSE
[17:59:25.141] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:59:25.142] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:59:25.142] - globals: [1] ‘FUN’
[17:59:25.142] - packages: [1] ‘stats’
[17:59:25.143] getGlobalsAndPackages() ... DONE
[17:59:25.143]  - globals found/used: [n=1] ‘FUN’
[17:59:25.143]  - needed namespaces: [n=1] ‘stats’
[17:59:25.143] Finding globals ... DONE
[17:59:25.144]  - use_args: TRUE
[17:59:25.144]  - Getting '...' globals ...
[17:59:25.144] resolve() on list ...
[17:59:25.145]  recursive: 0
[17:59:25.145]  length: 1
[17:59:25.145]  elements: ‘...’
[17:59:25.145]  length: 0 (resolved future 1)
[17:59:25.146] resolve() on list ... DONE
[17:59:25.146]    - '...' content: [n=1] ‘singular.ok’
[17:59:25.146] List of 1
[17:59:25.146]  $ ...:List of 1
[17:59:25.146]   ..$ singular.ok: logi FALSE
[17:59:25.146]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.146]  - attr(*, "where")=List of 1
[17:59:25.146]   ..$ ...:<environment: 0x62649fee66c0> 
[17:59:25.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.146]  - attr(*, "resolved")= logi TRUE
[17:59:25.146]  - attr(*, "total_size")= num NA
[17:59:25.153]  - Getting '...' globals ... DONE
[17:59:25.153] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.154] List of 2
[17:59:25.154]  $ ...future.FUN:function (x, ...)  
[17:59:25.154]  $ ...          :List of 1
[17:59:25.154]   ..$ singular.ok: logi FALSE
[17:59:25.154]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.154]  - attr(*, "where")=List of 2
[17:59:25.154]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.154]   ..$ ...          :<environment: 0x62649fee66c0> 
[17:59:25.154]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.154]  - attr(*, "resolved")= logi FALSE
[17:59:25.154]  - attr(*, "total_size")= num 5384
[17:59:25.161] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:25.161] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.161] Number of futures (= number of chunks): 1
[17:59:25.162] Launching 1 futures (chunks) ...
[17:59:25.162] Chunk #1 of 1 ...
[17:59:25.162]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.162] getGlobalsAndPackages() ...
[17:59:25.163] Searching for globals...
[17:59:25.164] 
[17:59:25.164] Searching for globals ... DONE
[17:59:25.164] - globals: [0] <none>
[17:59:25.164] getGlobalsAndPackages() ... DONE
[17:59:25.165]    + additional globals found: [n=0] 
[17:59:25.165]    + additional namespaces needed: [n=0] 
[17:59:25.165]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.165]  - seeds: <none>
[17:59:25.165]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.166] getGlobalsAndPackages() ...
[17:59:25.166] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.166] Resolving globals: FALSE
[17:59:25.166] Tweak future expression to call with '...' arguments ...
[17:59:25.167] {
[17:59:25.167]     do.call(function(...) {
[17:59:25.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.167]             on.exit(options(oopts), add = TRUE)
[17:59:25.167]         }
[17:59:25.167]         {
[17:59:25.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.167]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.167]             })
[17:59:25.167]         }
[17:59:25.167]     }, args = future.call.arguments)
[17:59:25.167] }
[17:59:25.167] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.168] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.168] 
[17:59:25.169] getGlobalsAndPackages() ... DONE
[17:59:25.171] run() for ‘Future’ ...
[17:59:25.171] - state: ‘created’
[17:59:25.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:25.177] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.178] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.178]   - Field: ‘label’
[17:59:25.178]   - Field: ‘local’
[17:59:25.178]   - Field: ‘owner’
[17:59:25.179]   - Field: ‘envir’
[17:59:25.179]   - Field: ‘packages’
[17:59:25.179]   - Field: ‘gc’
[17:59:25.179]   - Field: ‘conditions’
[17:59:25.180]   - Field: ‘expr’
[17:59:25.180]   - Field: ‘uuid’
[17:59:25.180]   - Field: ‘seed’
[17:59:25.180]   - Field: ‘version’
[17:59:25.180]   - Field: ‘result’
[17:59:25.181]   - Field: ‘asynchronous’
[17:59:25.181]   - Field: ‘calls’
[17:59:25.181]   - Field: ‘globals’
[17:59:25.181]   - Field: ‘stdout’
[17:59:25.181]   - Field: ‘earlySignal’
[17:59:25.182]   - Field: ‘lazy’
[17:59:25.182]   - Field: ‘state’
[17:59:25.182] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.182] - Launch lazy future ...
[17:59:25.185] Packages needed by the future expression (n = 1): ‘stats’
[17:59:25.185] Packages needed by future strategies (n = 0): <none>
[17:59:25.187] {
[17:59:25.187]     {
[17:59:25.187]         {
[17:59:25.187]             ...future.startTime <- base::Sys.time()
[17:59:25.187]             {
[17:59:25.187]                 {
[17:59:25.187]                   {
[17:59:25.187]                     {
[17:59:25.187]                       base::local({
[17:59:25.187]                         has_future <- base::requireNamespace("future", 
[17:59:25.187]                           quietly = TRUE)
[17:59:25.187]                         if (has_future) {
[17:59:25.187]                           ns <- base::getNamespace("future")
[17:59:25.187]                           version <- ns[[".package"]][["version"]]
[17:59:25.187]                           if (is.null(version)) 
[17:59:25.187]                             version <- utils::packageVersion("future")
[17:59:25.187]                         }
[17:59:25.187]                         else {
[17:59:25.187]                           version <- NULL
[17:59:25.187]                         }
[17:59:25.187]                         if (!has_future || version < "1.8.0") {
[17:59:25.187]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.187]                             "", base::R.version$version.string), 
[17:59:25.187]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:25.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.187]                               "release", "version")], collapse = " "), 
[17:59:25.187]                             hostname = base::Sys.info()[["nodename"]])
[17:59:25.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.187]                             info)
[17:59:25.187]                           info <- base::paste(info, collapse = "; ")
[17:59:25.187]                           if (!has_future) {
[17:59:25.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.187]                               info)
[17:59:25.187]                           }
[17:59:25.187]                           else {
[17:59:25.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.187]                               info, version)
[17:59:25.187]                           }
[17:59:25.187]                           base::stop(msg)
[17:59:25.187]                         }
[17:59:25.187]                       })
[17:59:25.187]                     }
[17:59:25.187]                     base::local({
[17:59:25.187]                       for (pkg in "stats") {
[17:59:25.187]                         base::loadNamespace(pkg)
[17:59:25.187]                         base::library(pkg, character.only = TRUE)
[17:59:25.187]                       }
[17:59:25.187]                     })
[17:59:25.187]                   }
[17:59:25.187]                   ...future.strategy.old <- future::plan("list")
[17:59:25.187]                   options(future.plan = NULL)
[17:59:25.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.187]                 }
[17:59:25.187]                 ...future.workdir <- getwd()
[17:59:25.187]             }
[17:59:25.187]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.187]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.187]         }
[17:59:25.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.187]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.187]             base::names(...future.oldOptions))
[17:59:25.187]     }
[17:59:25.187]     if (FALSE) {
[17:59:25.187]     }
[17:59:25.187]     else {
[17:59:25.187]         if (TRUE) {
[17:59:25.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.187]                 open = "w")
[17:59:25.187]         }
[17:59:25.187]         else {
[17:59:25.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.187]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.187]         }
[17:59:25.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.187]             base::sink(type = "output", split = FALSE)
[17:59:25.187]             base::close(...future.stdout)
[17:59:25.187]         }, add = TRUE)
[17:59:25.187]     }
[17:59:25.187]     ...future.frame <- base::sys.nframe()
[17:59:25.187]     ...future.conditions <- base::list()
[17:59:25.187]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.187]     if (FALSE) {
[17:59:25.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.187]     }
[17:59:25.187]     ...future.result <- base::tryCatch({
[17:59:25.187]         base::withCallingHandlers({
[17:59:25.187]             ...future.value <- base::withVisible(base::local({
[17:59:25.187]                 do.call(function(...) {
[17:59:25.187]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.187]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.187]                     ...future.globals.maxSize)) {
[17:59:25.187]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.187]                     on.exit(options(oopts), add = TRUE)
[17:59:25.187]                   }
[17:59:25.187]                   {
[17:59:25.187]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.187]                       FUN = function(jj) {
[17:59:25.187]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.187]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.187]                       })
[17:59:25.187]                   }
[17:59:25.187]                 }, args = future.call.arguments)
[17:59:25.187]             }))
[17:59:25.187]             future::FutureResult(value = ...future.value$value, 
[17:59:25.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.187]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.187]                     ...future.globalenv.names))
[17:59:25.187]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.187]         }, condition = base::local({
[17:59:25.187]             c <- base::c
[17:59:25.187]             inherits <- base::inherits
[17:59:25.187]             invokeRestart <- base::invokeRestart
[17:59:25.187]             length <- base::length
[17:59:25.187]             list <- base::list
[17:59:25.187]             seq.int <- base::seq.int
[17:59:25.187]             signalCondition <- base::signalCondition
[17:59:25.187]             sys.calls <- base::sys.calls
[17:59:25.187]             `[[` <- base::`[[`
[17:59:25.187]             `+` <- base::`+`
[17:59:25.187]             `<<-` <- base::`<<-`
[17:59:25.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.187]                   3L)]
[17:59:25.187]             }
[17:59:25.187]             function(cond) {
[17:59:25.187]                 is_error <- inherits(cond, "error")
[17:59:25.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.187]                   NULL)
[17:59:25.187]                 if (is_error) {
[17:59:25.187]                   sessionInformation <- function() {
[17:59:25.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.187]                       search = base::search(), system = base::Sys.info())
[17:59:25.187]                   }
[17:59:25.187]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.187]                     cond$call), session = sessionInformation(), 
[17:59:25.187]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.187]                   signalCondition(cond)
[17:59:25.187]                 }
[17:59:25.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.187]                 "immediateCondition"))) {
[17:59:25.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.187]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.187]                   if (TRUE && !signal) {
[17:59:25.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.187]                     {
[17:59:25.187]                       inherits <- base::inherits
[17:59:25.187]                       invokeRestart <- base::invokeRestart
[17:59:25.187]                       is.null <- base::is.null
[17:59:25.187]                       muffled <- FALSE
[17:59:25.187]                       if (inherits(cond, "message")) {
[17:59:25.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.187]                         if (muffled) 
[17:59:25.187]                           invokeRestart("muffleMessage")
[17:59:25.187]                       }
[17:59:25.187]                       else if (inherits(cond, "warning")) {
[17:59:25.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.187]                         if (muffled) 
[17:59:25.187]                           invokeRestart("muffleWarning")
[17:59:25.187]                       }
[17:59:25.187]                       else if (inherits(cond, "condition")) {
[17:59:25.187]                         if (!is.null(pattern)) {
[17:59:25.187]                           computeRestarts <- base::computeRestarts
[17:59:25.187]                           grepl <- base::grepl
[17:59:25.187]                           restarts <- computeRestarts(cond)
[17:59:25.187]                           for (restart in restarts) {
[17:59:25.187]                             name <- restart$name
[17:59:25.187]                             if (is.null(name)) 
[17:59:25.187]                               next
[17:59:25.187]                             if (!grepl(pattern, name)) 
[17:59:25.187]                               next
[17:59:25.187]                             invokeRestart(restart)
[17:59:25.187]                             muffled <- TRUE
[17:59:25.187]                             break
[17:59:25.187]                           }
[17:59:25.187]                         }
[17:59:25.187]                       }
[17:59:25.187]                       invisible(muffled)
[17:59:25.187]                     }
[17:59:25.187]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.187]                   }
[17:59:25.187]                 }
[17:59:25.187]                 else {
[17:59:25.187]                   if (TRUE) {
[17:59:25.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.187]                     {
[17:59:25.187]                       inherits <- base::inherits
[17:59:25.187]                       invokeRestart <- base::invokeRestart
[17:59:25.187]                       is.null <- base::is.null
[17:59:25.187]                       muffled <- FALSE
[17:59:25.187]                       if (inherits(cond, "message")) {
[17:59:25.187]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.187]                         if (muffled) 
[17:59:25.187]                           invokeRestart("muffleMessage")
[17:59:25.187]                       }
[17:59:25.187]                       else if (inherits(cond, "warning")) {
[17:59:25.187]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.187]                         if (muffled) 
[17:59:25.187]                           invokeRestart("muffleWarning")
[17:59:25.187]                       }
[17:59:25.187]                       else if (inherits(cond, "condition")) {
[17:59:25.187]                         if (!is.null(pattern)) {
[17:59:25.187]                           computeRestarts <- base::computeRestarts
[17:59:25.187]                           grepl <- base::grepl
[17:59:25.187]                           restarts <- computeRestarts(cond)
[17:59:25.187]                           for (restart in restarts) {
[17:59:25.187]                             name <- restart$name
[17:59:25.187]                             if (is.null(name)) 
[17:59:25.187]                               next
[17:59:25.187]                             if (!grepl(pattern, name)) 
[17:59:25.187]                               next
[17:59:25.187]                             invokeRestart(restart)
[17:59:25.187]                             muffled <- TRUE
[17:59:25.187]                             break
[17:59:25.187]                           }
[17:59:25.187]                         }
[17:59:25.187]                       }
[17:59:25.187]                       invisible(muffled)
[17:59:25.187]                     }
[17:59:25.187]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.187]                   }
[17:59:25.187]                 }
[17:59:25.187]             }
[17:59:25.187]         }))
[17:59:25.187]     }, error = function(ex) {
[17:59:25.187]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.187]                 ...future.rng), started = ...future.startTime, 
[17:59:25.187]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.187]             version = "1.8"), class = "FutureResult")
[17:59:25.187]     }, finally = {
[17:59:25.187]         if (!identical(...future.workdir, getwd())) 
[17:59:25.187]             setwd(...future.workdir)
[17:59:25.187]         {
[17:59:25.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.187]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.187]             }
[17:59:25.187]             base::options(...future.oldOptions)
[17:59:25.187]             if (.Platform$OS.type == "windows") {
[17:59:25.187]                 old_names <- names(...future.oldEnvVars)
[17:59:25.187]                 envs <- base::Sys.getenv()
[17:59:25.187]                 names <- names(envs)
[17:59:25.187]                 common <- intersect(names, old_names)
[17:59:25.187]                 added <- setdiff(names, old_names)
[17:59:25.187]                 removed <- setdiff(old_names, names)
[17:59:25.187]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.187]                   envs[common]]
[17:59:25.187]                 NAMES <- toupper(changed)
[17:59:25.187]                 args <- list()
[17:59:25.187]                 for (kk in seq_along(NAMES)) {
[17:59:25.187]                   name <- changed[[kk]]
[17:59:25.187]                   NAME <- NAMES[[kk]]
[17:59:25.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.187]                     next
[17:59:25.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.187]                 }
[17:59:25.187]                 NAMES <- toupper(added)
[17:59:25.187]                 for (kk in seq_along(NAMES)) {
[17:59:25.187]                   name <- added[[kk]]
[17:59:25.187]                   NAME <- NAMES[[kk]]
[17:59:25.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.187]                     next
[17:59:25.187]                   args[[name]] <- ""
[17:59:25.187]                 }
[17:59:25.187]                 NAMES <- toupper(removed)
[17:59:25.187]                 for (kk in seq_along(NAMES)) {
[17:59:25.187]                   name <- removed[[kk]]
[17:59:25.187]                   NAME <- NAMES[[kk]]
[17:59:25.187]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.187]                     next
[17:59:25.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.187]                 }
[17:59:25.187]                 if (length(args) > 0) 
[17:59:25.187]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.187]             }
[17:59:25.187]             else {
[17:59:25.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.187]             }
[17:59:25.187]             {
[17:59:25.187]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.187]                   0L) {
[17:59:25.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.187]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.187]                   base::options(opts)
[17:59:25.187]                 }
[17:59:25.187]                 {
[17:59:25.187]                   {
[17:59:25.187]                     NULL
[17:59:25.187]                     RNGkind("Mersenne-Twister")
[17:59:25.187]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.187]                       inherits = FALSE)
[17:59:25.187]                   }
[17:59:25.187]                   options(future.plan = NULL)
[17:59:25.187]                   if (is.na(NA_character_)) 
[17:59:25.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.187]                     .init = FALSE)
[17:59:25.187]                 }
[17:59:25.187]             }
[17:59:25.187]         }
[17:59:25.187]     })
[17:59:25.187]     if (TRUE) {
[17:59:25.187]         base::sink(type = "output", split = FALSE)
[17:59:25.187]         if (TRUE) {
[17:59:25.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.187]         }
[17:59:25.187]         else {
[17:59:25.187]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.187]         }
[17:59:25.187]         base::close(...future.stdout)
[17:59:25.187]         ...future.stdout <- NULL
[17:59:25.187]     }
[17:59:25.187]     ...future.result$conditions <- ...future.conditions
[17:59:25.187]     ...future.result$finished <- base::Sys.time()
[17:59:25.187]     ...future.result
[17:59:25.187] }
[17:59:25.190] assign_globals() ...
[17:59:25.191] List of 5
[17:59:25.191]  $ ...future.FUN            :function (x, ...)  
[17:59:25.191]  $ future.call.arguments    :List of 1
[17:59:25.191]   ..$ singular.ok: logi FALSE
[17:59:25.191]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.191]  $ ...future.elements_ii    :List of 3
[17:59:25.191]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.191]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:25.191]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.191]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.191]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.191]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:25.191]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.191]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:25.191]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.191]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:25.191]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.191]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:25.191]  $ ...future.seeds_ii       : NULL
[17:59:25.191]  $ ...future.globals.maxSize: NULL
[17:59:25.191]  - attr(*, "where")=List of 5
[17:59:25.191]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.191]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.191]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.191]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.191]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.191]  - attr(*, "resolved")= logi FALSE
[17:59:25.191]  - attr(*, "total_size")= num 5384
[17:59:25.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.191]  - attr(*, "already-done")= logi TRUE
[17:59:25.210] - reassign environment for ‘...future.FUN’
[17:59:25.210] - copied ‘...future.FUN’ to environment
[17:59:25.211] - copied ‘future.call.arguments’ to environment
[17:59:25.211] - copied ‘...future.elements_ii’ to environment
[17:59:25.211] - copied ‘...future.seeds_ii’ to environment
[17:59:25.211] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.211] assign_globals() ... done
[17:59:25.212] plan(): Setting new future strategy stack:
[17:59:25.212] List of future strategies:
[17:59:25.212] 1. sequential:
[17:59:25.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.212]    - tweaked: FALSE
[17:59:25.212]    - call: NULL
[17:59:25.213] plan(): nbrOfWorkers() = 1
[17:59:25.219] plan(): Setting new future strategy stack:
[17:59:25.219] List of future strategies:
[17:59:25.219] 1. multisession:
[17:59:25.219]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:25.219]    - tweaked: FALSE
[17:59:25.219]    - call: plan(strategy)
[17:59:25.225] plan(): nbrOfWorkers() = 1
[17:59:25.225] SequentialFuture started (and completed)
[17:59:25.226] - Launch lazy future ... done
[17:59:25.226] run() for ‘SequentialFuture’ ... done
[17:59:25.226] Created future:
[17:59:25.226] SequentialFuture:
[17:59:25.226] Label: ‘future_by-1’
[17:59:25.226] Expression:
[17:59:25.226] {
[17:59:25.226]     do.call(function(...) {
[17:59:25.226]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.226]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.226]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.226]             on.exit(options(oopts), add = TRUE)
[17:59:25.226]         }
[17:59:25.226]         {
[17:59:25.226]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.226]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.226]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.226]             })
[17:59:25.226]         }
[17:59:25.226]     }, args = future.call.arguments)
[17:59:25.226] }
[17:59:25.226] Lazy evaluation: FALSE
[17:59:25.226] Asynchronous evaluation: FALSE
[17:59:25.226] Local evaluation: TRUE
[17:59:25.226] Environment: R_GlobalEnv
[17:59:25.226] Capture standard output: TRUE
[17:59:25.226] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.226] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.226] Packages: 1 packages (‘stats’)
[17:59:25.226] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.226] Resolved: TRUE
[17:59:25.226] Value: 26.06 KiB of class ‘list’
[17:59:25.226] Early signaling: FALSE
[17:59:25.226] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.226] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.229] Chunk #1 of 1 ... DONE
[17:59:25.230] Launching 1 futures (chunks) ... DONE
[17:59:25.230] Resolving 1 futures (chunks) ...
[17:59:25.230] resolve() on list ...
[17:59:25.230]  recursive: 0
[17:59:25.230]  length: 1
[17:59:25.231] 
[17:59:25.231] resolved() for ‘SequentialFuture’ ...
[17:59:25.231] - state: ‘finished’
[17:59:25.231] - run: TRUE
[17:59:25.231] - result: ‘FutureResult’
[17:59:25.232] resolved() for ‘SequentialFuture’ ... done
[17:59:25.232] Future #1
[17:59:25.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.232] - nx: 1
[17:59:25.233] - relay: TRUE
[17:59:25.233] - stdout: TRUE
[17:59:25.233] - signal: TRUE
[17:59:25.233] - resignal: FALSE
[17:59:25.233] - force: TRUE
[17:59:25.233] - relayed: [n=1] FALSE
[17:59:25.234] - queued futures: [n=1] FALSE
[17:59:25.234]  - until=1
[17:59:25.234]  - relaying element #1
[17:59:25.234] - relayed: [n=1] TRUE
[17:59:25.235] - queued futures: [n=1] TRUE
[17:59:25.235] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.235]  length: 0 (resolved future 1)
[17:59:25.235] Relaying remaining futures
[17:59:25.235] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.238] - nx: 1
[17:59:25.238] - relay: TRUE
[17:59:25.238] - stdout: TRUE
[17:59:25.238] - signal: TRUE
[17:59:25.239] - resignal: FALSE
[17:59:25.239] - force: TRUE
[17:59:25.239] - relayed: [n=1] TRUE
[17:59:25.239] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.240] - relayed: [n=1] TRUE
[17:59:25.240] - queued futures: [n=1] TRUE
[17:59:25.240] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.240] resolve() on list ... DONE
[17:59:25.241]  - Number of value chunks collected: 1
[17:59:25.241] Resolving 1 futures (chunks) ... DONE
[17:59:25.241] Reducing values from 1 chunks ...
[17:59:25.241]  - Number of values collected after concatenation: 3
[17:59:25.241]  - Number of values expected: 3
[17:59:25.242] Reducing values from 1 chunks ... DONE
[17:59:25.242] future_lapply() ... DONE
[17:59:25.242] future_by_internal() ... DONE
[17:59:25.251] future_by_internal() ...
[17:59:25.252] future_lapply() ...
[17:59:25.259] Number of chunks: 1
[17:59:25.259] getGlobalsAndPackagesXApply() ...
[17:59:25.259]  - future.globals: TRUE
[17:59:25.260] getGlobalsAndPackages() ...
[17:59:25.260] Searching for globals...
[17:59:25.264] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:25.264] Searching for globals ... DONE
[17:59:25.264] Resolving globals: FALSE
[17:59:25.265] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:59:25.266] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:59:25.267] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:25.267] - packages: [1] ‘stats’
[17:59:25.267] getGlobalsAndPackages() ... DONE
[17:59:25.267]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:25.268]  - needed namespaces: [n=1] ‘stats’
[17:59:25.268] Finding globals ... DONE
[17:59:25.268]  - use_args: TRUE
[17:59:25.268]  - Getting '...' globals ...
[17:59:25.269] resolve() on list ...
[17:59:25.269]  recursive: 0
[17:59:25.269]  length: 1
[17:59:25.270]  elements: ‘...’
[17:59:25.270]  length: 0 (resolved future 1)
[17:59:25.270] resolve() on list ... DONE
[17:59:25.270]    - '...' content: [n=0] 
[17:59:25.270] List of 1
[17:59:25.270]  $ ...: list()
[17:59:25.270]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.270]  - attr(*, "where")=List of 1
[17:59:25.270]   ..$ ...:<environment: 0x62649f364660> 
[17:59:25.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.270]  - attr(*, "resolved")= logi TRUE
[17:59:25.270]  - attr(*, "total_size")= num NA
[17:59:25.276]  - Getting '...' globals ... DONE
[17:59:25.276] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:59:25.277] List of 4
[17:59:25.277]  $ ...future.FUN:function (x)  
[17:59:25.277]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:25.277]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.277]  $ ...          : list()
[17:59:25.277]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.277]  - attr(*, "where")=List of 4
[17:59:25.277]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.277]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:59:25.277]   ..$ wool         :<environment: R_EmptyEnv> 
[17:59:25.277]   ..$ ...          :<environment: 0x62649f364660> 
[17:59:25.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.277]  - attr(*, "resolved")= logi FALSE
[17:59:25.277]  - attr(*, "total_size")= num 2320
[17:59:25.287] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:25.288] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.288] Number of futures (= number of chunks): 1
[17:59:25.288] Launching 1 futures (chunks) ...
[17:59:25.289] Chunk #1 of 1 ...
[17:59:25.289]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.289] getGlobalsAndPackages() ...
[17:59:25.289] Searching for globals...
[17:59:25.290] 
[17:59:25.290] Searching for globals ... DONE
[17:59:25.291] - globals: [0] <none>
[17:59:25.291] getGlobalsAndPackages() ... DONE
[17:59:25.291]    + additional globals found: [n=0] 
[17:59:25.291]    + additional namespaces needed: [n=0] 
[17:59:25.291]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.292]  - seeds: <none>
[17:59:25.292]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.292] getGlobalsAndPackages() ...
[17:59:25.292] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.292] Resolving globals: FALSE
[17:59:25.293] Tweak future expression to call with '...' arguments ...
[17:59:25.293] {
[17:59:25.293]     do.call(function(...) {
[17:59:25.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.293]             on.exit(options(oopts), add = TRUE)
[17:59:25.293]         }
[17:59:25.293]         {
[17:59:25.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.293]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.293]             })
[17:59:25.293]         }
[17:59:25.293]     }, args = future.call.arguments)
[17:59:25.293] }
[17:59:25.293] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.294] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.294] 
[17:59:25.295] getGlobalsAndPackages() ... DONE
[17:59:25.295] run() for ‘Future’ ...
[17:59:25.295] - state: ‘created’
[17:59:25.296] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:25.302] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.302]   - Field: ‘label’
[17:59:25.302]   - Field: ‘local’
[17:59:25.303]   - Field: ‘owner’
[17:59:25.303]   - Field: ‘envir’
[17:59:25.303]   - Field: ‘packages’
[17:59:25.303]   - Field: ‘gc’
[17:59:25.303]   - Field: ‘conditions’
[17:59:25.304]   - Field: ‘expr’
[17:59:25.304]   - Field: ‘uuid’
[17:59:25.304]   - Field: ‘seed’
[17:59:25.304]   - Field: ‘version’
[17:59:25.304]   - Field: ‘result’
[17:59:25.305]   - Field: ‘asynchronous’
[17:59:25.305]   - Field: ‘calls’
[17:59:25.305]   - Field: ‘globals’
[17:59:25.305]   - Field: ‘stdout’
[17:59:25.305]   - Field: ‘earlySignal’
[17:59:25.306]   - Field: ‘lazy’
[17:59:25.306]   - Field: ‘state’
[17:59:25.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.306] - Launch lazy future ...
[17:59:25.307] Packages needed by the future expression (n = 1): ‘stats’
[17:59:25.307] Packages needed by future strategies (n = 0): <none>
[17:59:25.308] {
[17:59:25.308]     {
[17:59:25.308]         {
[17:59:25.308]             ...future.startTime <- base::Sys.time()
[17:59:25.308]             {
[17:59:25.308]                 {
[17:59:25.308]                   {
[17:59:25.308]                     {
[17:59:25.308]                       base::local({
[17:59:25.308]                         has_future <- base::requireNamespace("future", 
[17:59:25.308]                           quietly = TRUE)
[17:59:25.308]                         if (has_future) {
[17:59:25.308]                           ns <- base::getNamespace("future")
[17:59:25.308]                           version <- ns[[".package"]][["version"]]
[17:59:25.308]                           if (is.null(version)) 
[17:59:25.308]                             version <- utils::packageVersion("future")
[17:59:25.308]                         }
[17:59:25.308]                         else {
[17:59:25.308]                           version <- NULL
[17:59:25.308]                         }
[17:59:25.308]                         if (!has_future || version < "1.8.0") {
[17:59:25.308]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.308]                             "", base::R.version$version.string), 
[17:59:25.308]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:25.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.308]                               "release", "version")], collapse = " "), 
[17:59:25.308]                             hostname = base::Sys.info()[["nodename"]])
[17:59:25.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.308]                             info)
[17:59:25.308]                           info <- base::paste(info, collapse = "; ")
[17:59:25.308]                           if (!has_future) {
[17:59:25.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.308]                               info)
[17:59:25.308]                           }
[17:59:25.308]                           else {
[17:59:25.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.308]                               info, version)
[17:59:25.308]                           }
[17:59:25.308]                           base::stop(msg)
[17:59:25.308]                         }
[17:59:25.308]                       })
[17:59:25.308]                     }
[17:59:25.308]                     base::local({
[17:59:25.308]                       for (pkg in "stats") {
[17:59:25.308]                         base::loadNamespace(pkg)
[17:59:25.308]                         base::library(pkg, character.only = TRUE)
[17:59:25.308]                       }
[17:59:25.308]                     })
[17:59:25.308]                   }
[17:59:25.308]                   ...future.strategy.old <- future::plan("list")
[17:59:25.308]                   options(future.plan = NULL)
[17:59:25.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.308]                 }
[17:59:25.308]                 ...future.workdir <- getwd()
[17:59:25.308]             }
[17:59:25.308]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.308]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.308]         }
[17:59:25.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.308]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.308]             base::names(...future.oldOptions))
[17:59:25.308]     }
[17:59:25.308]     if (FALSE) {
[17:59:25.308]     }
[17:59:25.308]     else {
[17:59:25.308]         if (TRUE) {
[17:59:25.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.308]                 open = "w")
[17:59:25.308]         }
[17:59:25.308]         else {
[17:59:25.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.308]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.308]         }
[17:59:25.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.308]             base::sink(type = "output", split = FALSE)
[17:59:25.308]             base::close(...future.stdout)
[17:59:25.308]         }, add = TRUE)
[17:59:25.308]     }
[17:59:25.308]     ...future.frame <- base::sys.nframe()
[17:59:25.308]     ...future.conditions <- base::list()
[17:59:25.308]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.308]     if (FALSE) {
[17:59:25.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.308]     }
[17:59:25.308]     ...future.result <- base::tryCatch({
[17:59:25.308]         base::withCallingHandlers({
[17:59:25.308]             ...future.value <- base::withVisible(base::local({
[17:59:25.308]                 do.call(function(...) {
[17:59:25.308]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.308]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.308]                     ...future.globals.maxSize)) {
[17:59:25.308]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.308]                     on.exit(options(oopts), add = TRUE)
[17:59:25.308]                   }
[17:59:25.308]                   {
[17:59:25.308]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.308]                       FUN = function(jj) {
[17:59:25.308]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.308]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.308]                       })
[17:59:25.308]                   }
[17:59:25.308]                 }, args = future.call.arguments)
[17:59:25.308]             }))
[17:59:25.308]             future::FutureResult(value = ...future.value$value, 
[17:59:25.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.308]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.308]                     ...future.globalenv.names))
[17:59:25.308]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.308]         }, condition = base::local({
[17:59:25.308]             c <- base::c
[17:59:25.308]             inherits <- base::inherits
[17:59:25.308]             invokeRestart <- base::invokeRestart
[17:59:25.308]             length <- base::length
[17:59:25.308]             list <- base::list
[17:59:25.308]             seq.int <- base::seq.int
[17:59:25.308]             signalCondition <- base::signalCondition
[17:59:25.308]             sys.calls <- base::sys.calls
[17:59:25.308]             `[[` <- base::`[[`
[17:59:25.308]             `+` <- base::`+`
[17:59:25.308]             `<<-` <- base::`<<-`
[17:59:25.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.308]                   3L)]
[17:59:25.308]             }
[17:59:25.308]             function(cond) {
[17:59:25.308]                 is_error <- inherits(cond, "error")
[17:59:25.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.308]                   NULL)
[17:59:25.308]                 if (is_error) {
[17:59:25.308]                   sessionInformation <- function() {
[17:59:25.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.308]                       search = base::search(), system = base::Sys.info())
[17:59:25.308]                   }
[17:59:25.308]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.308]                     cond$call), session = sessionInformation(), 
[17:59:25.308]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.308]                   signalCondition(cond)
[17:59:25.308]                 }
[17:59:25.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.308]                 "immediateCondition"))) {
[17:59:25.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.308]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.308]                   if (TRUE && !signal) {
[17:59:25.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.308]                     {
[17:59:25.308]                       inherits <- base::inherits
[17:59:25.308]                       invokeRestart <- base::invokeRestart
[17:59:25.308]                       is.null <- base::is.null
[17:59:25.308]                       muffled <- FALSE
[17:59:25.308]                       if (inherits(cond, "message")) {
[17:59:25.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.308]                         if (muffled) 
[17:59:25.308]                           invokeRestart("muffleMessage")
[17:59:25.308]                       }
[17:59:25.308]                       else if (inherits(cond, "warning")) {
[17:59:25.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.308]                         if (muffled) 
[17:59:25.308]                           invokeRestart("muffleWarning")
[17:59:25.308]                       }
[17:59:25.308]                       else if (inherits(cond, "condition")) {
[17:59:25.308]                         if (!is.null(pattern)) {
[17:59:25.308]                           computeRestarts <- base::computeRestarts
[17:59:25.308]                           grepl <- base::grepl
[17:59:25.308]                           restarts <- computeRestarts(cond)
[17:59:25.308]                           for (restart in restarts) {
[17:59:25.308]                             name <- restart$name
[17:59:25.308]                             if (is.null(name)) 
[17:59:25.308]                               next
[17:59:25.308]                             if (!grepl(pattern, name)) 
[17:59:25.308]                               next
[17:59:25.308]                             invokeRestart(restart)
[17:59:25.308]                             muffled <- TRUE
[17:59:25.308]                             break
[17:59:25.308]                           }
[17:59:25.308]                         }
[17:59:25.308]                       }
[17:59:25.308]                       invisible(muffled)
[17:59:25.308]                     }
[17:59:25.308]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.308]                   }
[17:59:25.308]                 }
[17:59:25.308]                 else {
[17:59:25.308]                   if (TRUE) {
[17:59:25.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.308]                     {
[17:59:25.308]                       inherits <- base::inherits
[17:59:25.308]                       invokeRestart <- base::invokeRestart
[17:59:25.308]                       is.null <- base::is.null
[17:59:25.308]                       muffled <- FALSE
[17:59:25.308]                       if (inherits(cond, "message")) {
[17:59:25.308]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.308]                         if (muffled) 
[17:59:25.308]                           invokeRestart("muffleMessage")
[17:59:25.308]                       }
[17:59:25.308]                       else if (inherits(cond, "warning")) {
[17:59:25.308]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.308]                         if (muffled) 
[17:59:25.308]                           invokeRestart("muffleWarning")
[17:59:25.308]                       }
[17:59:25.308]                       else if (inherits(cond, "condition")) {
[17:59:25.308]                         if (!is.null(pattern)) {
[17:59:25.308]                           computeRestarts <- base::computeRestarts
[17:59:25.308]                           grepl <- base::grepl
[17:59:25.308]                           restarts <- computeRestarts(cond)
[17:59:25.308]                           for (restart in restarts) {
[17:59:25.308]                             name <- restart$name
[17:59:25.308]                             if (is.null(name)) 
[17:59:25.308]                               next
[17:59:25.308]                             if (!grepl(pattern, name)) 
[17:59:25.308]                               next
[17:59:25.308]                             invokeRestart(restart)
[17:59:25.308]                             muffled <- TRUE
[17:59:25.308]                             break
[17:59:25.308]                           }
[17:59:25.308]                         }
[17:59:25.308]                       }
[17:59:25.308]                       invisible(muffled)
[17:59:25.308]                     }
[17:59:25.308]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.308]                   }
[17:59:25.308]                 }
[17:59:25.308]             }
[17:59:25.308]         }))
[17:59:25.308]     }, error = function(ex) {
[17:59:25.308]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.308]                 ...future.rng), started = ...future.startTime, 
[17:59:25.308]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.308]             version = "1.8"), class = "FutureResult")
[17:59:25.308]     }, finally = {
[17:59:25.308]         if (!identical(...future.workdir, getwd())) 
[17:59:25.308]             setwd(...future.workdir)
[17:59:25.308]         {
[17:59:25.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.308]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.308]             }
[17:59:25.308]             base::options(...future.oldOptions)
[17:59:25.308]             if (.Platform$OS.type == "windows") {
[17:59:25.308]                 old_names <- names(...future.oldEnvVars)
[17:59:25.308]                 envs <- base::Sys.getenv()
[17:59:25.308]                 names <- names(envs)
[17:59:25.308]                 common <- intersect(names, old_names)
[17:59:25.308]                 added <- setdiff(names, old_names)
[17:59:25.308]                 removed <- setdiff(old_names, names)
[17:59:25.308]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.308]                   envs[common]]
[17:59:25.308]                 NAMES <- toupper(changed)
[17:59:25.308]                 args <- list()
[17:59:25.308]                 for (kk in seq_along(NAMES)) {
[17:59:25.308]                   name <- changed[[kk]]
[17:59:25.308]                   NAME <- NAMES[[kk]]
[17:59:25.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.308]                     next
[17:59:25.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.308]                 }
[17:59:25.308]                 NAMES <- toupper(added)
[17:59:25.308]                 for (kk in seq_along(NAMES)) {
[17:59:25.308]                   name <- added[[kk]]
[17:59:25.308]                   NAME <- NAMES[[kk]]
[17:59:25.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.308]                     next
[17:59:25.308]                   args[[name]] <- ""
[17:59:25.308]                 }
[17:59:25.308]                 NAMES <- toupper(removed)
[17:59:25.308]                 for (kk in seq_along(NAMES)) {
[17:59:25.308]                   name <- removed[[kk]]
[17:59:25.308]                   NAME <- NAMES[[kk]]
[17:59:25.308]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.308]                     next
[17:59:25.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.308]                 }
[17:59:25.308]                 if (length(args) > 0) 
[17:59:25.308]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.308]             }
[17:59:25.308]             else {
[17:59:25.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.308]             }
[17:59:25.308]             {
[17:59:25.308]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.308]                   0L) {
[17:59:25.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.308]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.308]                   base::options(opts)
[17:59:25.308]                 }
[17:59:25.308]                 {
[17:59:25.308]                   {
[17:59:25.308]                     NULL
[17:59:25.308]                     RNGkind("Mersenne-Twister")
[17:59:25.308]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.308]                       inherits = FALSE)
[17:59:25.308]                   }
[17:59:25.308]                   options(future.plan = NULL)
[17:59:25.308]                   if (is.na(NA_character_)) 
[17:59:25.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.308]                     .init = FALSE)
[17:59:25.308]                 }
[17:59:25.308]             }
[17:59:25.308]         }
[17:59:25.308]     })
[17:59:25.308]     if (TRUE) {
[17:59:25.308]         base::sink(type = "output", split = FALSE)
[17:59:25.308]         if (TRUE) {
[17:59:25.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.308]         }
[17:59:25.308]         else {
[17:59:25.308]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.308]         }
[17:59:25.308]         base::close(...future.stdout)
[17:59:25.308]         ...future.stdout <- NULL
[17:59:25.308]     }
[17:59:25.308]     ...future.result$conditions <- ...future.conditions
[17:59:25.308]     ...future.result$finished <- base::Sys.time()
[17:59:25.308]     ...future.result
[17:59:25.308] }
[17:59:25.311] assign_globals() ...
[17:59:25.311] List of 7
[17:59:25.311]  $ ...future.FUN            :function (x)  
[17:59:25.311]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:25.311]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.311]  $ future.call.arguments    : list()
[17:59:25.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.311]  $ ...future.elements_ii    :List of 3
[17:59:25.311]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.311]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:25.311]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.311]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.311]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.311]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:25.311]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.311]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:25.311]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.311]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:25.311]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.311]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:25.311]  $ ...future.seeds_ii       : NULL
[17:59:25.311]  $ ...future.globals.maxSize: NULL
[17:59:25.311]  - attr(*, "where")=List of 7
[17:59:25.311]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.311]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:59:25.311]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:59:25.311]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.311]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.311]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.311]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.311]  - attr(*, "resolved")= logi FALSE
[17:59:25.311]  - attr(*, "total_size")= num 2320
[17:59:25.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.311]  - attr(*, "already-done")= logi TRUE
[17:59:25.331] - reassign environment for ‘...future.FUN’
[17:59:25.331] - copied ‘...future.FUN’ to environment
[17:59:25.331] - copied ‘breaks’ to environment
[17:59:25.331] - copied ‘wool’ to environment
[17:59:25.332] - copied ‘future.call.arguments’ to environment
[17:59:25.334] - copied ‘...future.elements_ii’ to environment
[17:59:25.334] - copied ‘...future.seeds_ii’ to environment
[17:59:25.335] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.335] assign_globals() ... done
[17:59:25.336] plan(): Setting new future strategy stack:
[17:59:25.336] List of future strategies:
[17:59:25.336] 1. sequential:
[17:59:25.336]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.336]    - tweaked: FALSE
[17:59:25.336]    - call: NULL
[17:59:25.337] plan(): nbrOfWorkers() = 1
[17:59:25.343] plan(): Setting new future strategy stack:
[17:59:25.343] List of future strategies:
[17:59:25.343] 1. multisession:
[17:59:25.343]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:25.343]    - tweaked: FALSE
[17:59:25.343]    - call: plan(strategy)
[17:59:25.349] plan(): nbrOfWorkers() = 1
[17:59:25.350] SequentialFuture started (and completed)
[17:59:25.350] - Launch lazy future ... done
[17:59:25.350] run() for ‘SequentialFuture’ ... done
[17:59:25.350] Created future:
[17:59:25.351] SequentialFuture:
[17:59:25.351] Label: ‘future_by-1’
[17:59:25.351] Expression:
[17:59:25.351] {
[17:59:25.351]     do.call(function(...) {
[17:59:25.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.351]             on.exit(options(oopts), add = TRUE)
[17:59:25.351]         }
[17:59:25.351]         {
[17:59:25.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.351]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.351]             })
[17:59:25.351]         }
[17:59:25.351]     }, args = future.call.arguments)
[17:59:25.351] }
[17:59:25.351] Lazy evaluation: FALSE
[17:59:25.351] Asynchronous evaluation: FALSE
[17:59:25.351] Local evaluation: TRUE
[17:59:25.351] Environment: 0x62649e430fd8
[17:59:25.351] Capture standard output: TRUE
[17:59:25.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.351] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:59:25.351] Packages: 1 packages (‘stats’)
[17:59:25.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.351] Resolved: TRUE
[17:59:25.351] Value: 25.57 KiB of class ‘list’
[17:59:25.351] Early signaling: FALSE
[17:59:25.351] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.351] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.354] Chunk #1 of 1 ... DONE
[17:59:25.354] Launching 1 futures (chunks) ... DONE
[17:59:25.354] Resolving 1 futures (chunks) ...
[17:59:25.355] resolve() on list ...
[17:59:25.355]  recursive: 0
[17:59:25.355]  length: 1
[17:59:25.355] 
[17:59:25.355] resolved() for ‘SequentialFuture’ ...
[17:59:25.356] - state: ‘finished’
[17:59:25.356] - run: TRUE
[17:59:25.356] - result: ‘FutureResult’
[17:59:25.356] resolved() for ‘SequentialFuture’ ... done
[17:59:25.356] Future #1
[17:59:25.357] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.357] - nx: 1
[17:59:25.357] - relay: TRUE
[17:59:25.357] - stdout: TRUE
[17:59:25.357] - signal: TRUE
[17:59:25.358] - resignal: FALSE
[17:59:25.358] - force: TRUE
[17:59:25.358] - relayed: [n=1] FALSE
[17:59:25.358] - queued futures: [n=1] FALSE
[17:59:25.358]  - until=1
[17:59:25.359]  - relaying element #1
[17:59:25.359] - relayed: [n=1] TRUE
[17:59:25.359] - queued futures: [n=1] TRUE
[17:59:25.359] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.360]  length: 0 (resolved future 1)
[17:59:25.360] Relaying remaining futures
[17:59:25.360] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.360] - nx: 1
[17:59:25.360] - relay: TRUE
[17:59:25.360] - stdout: TRUE
[17:59:25.361] - signal: TRUE
[17:59:25.361] - resignal: FALSE
[17:59:25.361] - force: TRUE
[17:59:25.361] - relayed: [n=1] TRUE
[17:59:25.361] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.362] - relayed: [n=1] TRUE
[17:59:25.362] - queued futures: [n=1] TRUE
[17:59:25.362] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.362] resolve() on list ... DONE
[17:59:25.363]  - Number of value chunks collected: 1
[17:59:25.363] Resolving 1 futures (chunks) ... DONE
[17:59:25.363] Reducing values from 1 chunks ...
[17:59:25.363]  - Number of values collected after concatenation: 3
[17:59:25.363]  - Number of values expected: 3
[17:59:25.363] Reducing values from 1 chunks ... DONE
[17:59:25.364] future_lapply() ... DONE
[17:59:25.364] future_by_internal() ... DONE
[17:59:25.365] future_by_internal() ...
[17:59:25.365] future_lapply() ...
[17:59:25.373] Number of chunks: 1
[17:59:25.373] getGlobalsAndPackagesXApply() ...
[17:59:25.373]  - future.globals: TRUE
[17:59:25.373] getGlobalsAndPackages() ...
[17:59:25.374] Searching for globals...
[17:59:25.376] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:25.376] Searching for globals ... DONE
[17:59:25.376] Resolving globals: FALSE
[17:59:25.377] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:25.378] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:25.378] - globals: [1] ‘FUN’
[17:59:25.378] 
[17:59:25.379] getGlobalsAndPackages() ... DONE
[17:59:25.379]  - globals found/used: [n=1] ‘FUN’
[17:59:25.379]  - needed namespaces: [n=0] 
[17:59:25.379] Finding globals ... DONE
[17:59:25.379]  - use_args: TRUE
[17:59:25.380]  - Getting '...' globals ...
[17:59:25.380] resolve() on list ...
[17:59:25.380]  recursive: 0
[17:59:25.381]  length: 1
[17:59:25.381]  elements: ‘...’
[17:59:25.381]  length: 0 (resolved future 1)
[17:59:25.381] resolve() on list ... DONE
[17:59:25.381]    - '...' content: [n=0] 
[17:59:25.382] List of 1
[17:59:25.382]  $ ...: list()
[17:59:25.382]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.382]  - attr(*, "where")=List of 1
[17:59:25.382]   ..$ ...:<environment: 0x62649fba8710> 
[17:59:25.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.382]  - attr(*, "resolved")= logi TRUE
[17:59:25.382]  - attr(*, "total_size")= num NA
[17:59:25.389]  - Getting '...' globals ... DONE
[17:59:25.390] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.390] List of 2
[17:59:25.390]  $ ...future.FUN:function (object, ...)  
[17:59:25.390]  $ ...          : list()
[17:59:25.390]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.390]  - attr(*, "where")=List of 2
[17:59:25.390]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.390]   ..$ ...          :<environment: 0x62649fba8710> 
[17:59:25.390]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.390]  - attr(*, "resolved")= logi FALSE
[17:59:25.390]  - attr(*, "total_size")= num 1240
[17:59:25.395] Packages to be attached in all futures: [n=0] 
[17:59:25.396] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.396] Number of futures (= number of chunks): 1
[17:59:25.396] Launching 1 futures (chunks) ...
[17:59:25.397] Chunk #1 of 1 ...
[17:59:25.397]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.397] getGlobalsAndPackages() ...
[17:59:25.397] Searching for globals...
[17:59:25.398] 
[17:59:25.398] Searching for globals ... DONE
[17:59:25.399] - globals: [0] <none>
[17:59:25.399] getGlobalsAndPackages() ... DONE
[17:59:25.399]    + additional globals found: [n=0] 
[17:59:25.399]    + additional namespaces needed: [n=0] 
[17:59:25.399]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.400]  - seeds: <none>
[17:59:25.400]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.400] getGlobalsAndPackages() ...
[17:59:25.400] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.400] Resolving globals: FALSE
[17:59:25.401] Tweak future expression to call with '...' arguments ...
[17:59:25.401] {
[17:59:25.401]     do.call(function(...) {
[17:59:25.401]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.401]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.401]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.401]             on.exit(options(oopts), add = TRUE)
[17:59:25.401]         }
[17:59:25.401]         {
[17:59:25.401]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.401]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.401]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.401]             })
[17:59:25.401]         }
[17:59:25.401]     }, args = future.call.arguments)
[17:59:25.401] }
[17:59:25.401] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.402] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.402] 
[17:59:25.403] getGlobalsAndPackages() ... DONE
[17:59:25.403] run() for ‘Future’ ...
[17:59:25.403] - state: ‘created’
[17:59:25.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:25.410] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.410]   - Field: ‘label’
[17:59:25.411]   - Field: ‘local’
[17:59:25.411]   - Field: ‘owner’
[17:59:25.411]   - Field: ‘envir’
[17:59:25.411]   - Field: ‘packages’
[17:59:25.411]   - Field: ‘gc’
[17:59:25.412]   - Field: ‘conditions’
[17:59:25.412]   - Field: ‘expr’
[17:59:25.412]   - Field: ‘uuid’
[17:59:25.412]   - Field: ‘seed’
[17:59:25.412]   - Field: ‘version’
[17:59:25.413]   - Field: ‘result’
[17:59:25.413]   - Field: ‘asynchronous’
[17:59:25.413]   - Field: ‘calls’
[17:59:25.413]   - Field: ‘globals’
[17:59:25.413]   - Field: ‘stdout’
[17:59:25.414]   - Field: ‘earlySignal’
[17:59:25.414]   - Field: ‘lazy’
[17:59:25.414]   - Field: ‘state’
[17:59:25.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.414] - Launch lazy future ...
[17:59:25.415] Packages needed by the future expression (n = 0): <none>
[17:59:25.415] Packages needed by future strategies (n = 0): <none>
[17:59:25.416] {
[17:59:25.416]     {
[17:59:25.416]         {
[17:59:25.416]             ...future.startTime <- base::Sys.time()
[17:59:25.416]             {
[17:59:25.416]                 {
[17:59:25.416]                   {
[17:59:25.416]                     base::local({
[17:59:25.416]                       has_future <- base::requireNamespace("future", 
[17:59:25.416]                         quietly = TRUE)
[17:59:25.416]                       if (has_future) {
[17:59:25.416]                         ns <- base::getNamespace("future")
[17:59:25.416]                         version <- ns[[".package"]][["version"]]
[17:59:25.416]                         if (is.null(version)) 
[17:59:25.416]                           version <- utils::packageVersion("future")
[17:59:25.416]                       }
[17:59:25.416]                       else {
[17:59:25.416]                         version <- NULL
[17:59:25.416]                       }
[17:59:25.416]                       if (!has_future || version < "1.8.0") {
[17:59:25.416]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.416]                           "", base::R.version$version.string), 
[17:59:25.416]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:25.416]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.416]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.416]                             "release", "version")], collapse = " "), 
[17:59:25.416]                           hostname = base::Sys.info()[["nodename"]])
[17:59:25.416]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.416]                           info)
[17:59:25.416]                         info <- base::paste(info, collapse = "; ")
[17:59:25.416]                         if (!has_future) {
[17:59:25.416]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.416]                             info)
[17:59:25.416]                         }
[17:59:25.416]                         else {
[17:59:25.416]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.416]                             info, version)
[17:59:25.416]                         }
[17:59:25.416]                         base::stop(msg)
[17:59:25.416]                       }
[17:59:25.416]                     })
[17:59:25.416]                   }
[17:59:25.416]                   ...future.strategy.old <- future::plan("list")
[17:59:25.416]                   options(future.plan = NULL)
[17:59:25.416]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.416]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.416]                 }
[17:59:25.416]                 ...future.workdir <- getwd()
[17:59:25.416]             }
[17:59:25.416]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.416]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.416]         }
[17:59:25.416]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.416]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.416]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.416]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.416]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.416]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.416]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.416]             base::names(...future.oldOptions))
[17:59:25.416]     }
[17:59:25.416]     if (FALSE) {
[17:59:25.416]     }
[17:59:25.416]     else {
[17:59:25.416]         if (TRUE) {
[17:59:25.416]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.416]                 open = "w")
[17:59:25.416]         }
[17:59:25.416]         else {
[17:59:25.416]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.416]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.416]         }
[17:59:25.416]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.416]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.416]             base::sink(type = "output", split = FALSE)
[17:59:25.416]             base::close(...future.stdout)
[17:59:25.416]         }, add = TRUE)
[17:59:25.416]     }
[17:59:25.416]     ...future.frame <- base::sys.nframe()
[17:59:25.416]     ...future.conditions <- base::list()
[17:59:25.416]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.416]     if (FALSE) {
[17:59:25.416]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.416]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.416]     }
[17:59:25.416]     ...future.result <- base::tryCatch({
[17:59:25.416]         base::withCallingHandlers({
[17:59:25.416]             ...future.value <- base::withVisible(base::local({
[17:59:25.416]                 do.call(function(...) {
[17:59:25.416]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.416]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.416]                     ...future.globals.maxSize)) {
[17:59:25.416]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.416]                     on.exit(options(oopts), add = TRUE)
[17:59:25.416]                   }
[17:59:25.416]                   {
[17:59:25.416]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.416]                       FUN = function(jj) {
[17:59:25.416]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.416]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.416]                       })
[17:59:25.416]                   }
[17:59:25.416]                 }, args = future.call.arguments)
[17:59:25.416]             }))
[17:59:25.416]             future::FutureResult(value = ...future.value$value, 
[17:59:25.416]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.416]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.416]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.416]                     ...future.globalenv.names))
[17:59:25.416]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.416]         }, condition = base::local({
[17:59:25.416]             c <- base::c
[17:59:25.416]             inherits <- base::inherits
[17:59:25.416]             invokeRestart <- base::invokeRestart
[17:59:25.416]             length <- base::length
[17:59:25.416]             list <- base::list
[17:59:25.416]             seq.int <- base::seq.int
[17:59:25.416]             signalCondition <- base::signalCondition
[17:59:25.416]             sys.calls <- base::sys.calls
[17:59:25.416]             `[[` <- base::`[[`
[17:59:25.416]             `+` <- base::`+`
[17:59:25.416]             `<<-` <- base::`<<-`
[17:59:25.416]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.416]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.416]                   3L)]
[17:59:25.416]             }
[17:59:25.416]             function(cond) {
[17:59:25.416]                 is_error <- inherits(cond, "error")
[17:59:25.416]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.416]                   NULL)
[17:59:25.416]                 if (is_error) {
[17:59:25.416]                   sessionInformation <- function() {
[17:59:25.416]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.416]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.416]                       search = base::search(), system = base::Sys.info())
[17:59:25.416]                   }
[17:59:25.416]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.416]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.416]                     cond$call), session = sessionInformation(), 
[17:59:25.416]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.416]                   signalCondition(cond)
[17:59:25.416]                 }
[17:59:25.416]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.416]                 "immediateCondition"))) {
[17:59:25.416]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.416]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.416]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.416]                   if (TRUE && !signal) {
[17:59:25.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.416]                     {
[17:59:25.416]                       inherits <- base::inherits
[17:59:25.416]                       invokeRestart <- base::invokeRestart
[17:59:25.416]                       is.null <- base::is.null
[17:59:25.416]                       muffled <- FALSE
[17:59:25.416]                       if (inherits(cond, "message")) {
[17:59:25.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.416]                         if (muffled) 
[17:59:25.416]                           invokeRestart("muffleMessage")
[17:59:25.416]                       }
[17:59:25.416]                       else if (inherits(cond, "warning")) {
[17:59:25.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.416]                         if (muffled) 
[17:59:25.416]                           invokeRestart("muffleWarning")
[17:59:25.416]                       }
[17:59:25.416]                       else if (inherits(cond, "condition")) {
[17:59:25.416]                         if (!is.null(pattern)) {
[17:59:25.416]                           computeRestarts <- base::computeRestarts
[17:59:25.416]                           grepl <- base::grepl
[17:59:25.416]                           restarts <- computeRestarts(cond)
[17:59:25.416]                           for (restart in restarts) {
[17:59:25.416]                             name <- restart$name
[17:59:25.416]                             if (is.null(name)) 
[17:59:25.416]                               next
[17:59:25.416]                             if (!grepl(pattern, name)) 
[17:59:25.416]                               next
[17:59:25.416]                             invokeRestart(restart)
[17:59:25.416]                             muffled <- TRUE
[17:59:25.416]                             break
[17:59:25.416]                           }
[17:59:25.416]                         }
[17:59:25.416]                       }
[17:59:25.416]                       invisible(muffled)
[17:59:25.416]                     }
[17:59:25.416]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.416]                   }
[17:59:25.416]                 }
[17:59:25.416]                 else {
[17:59:25.416]                   if (TRUE) {
[17:59:25.416]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.416]                     {
[17:59:25.416]                       inherits <- base::inherits
[17:59:25.416]                       invokeRestart <- base::invokeRestart
[17:59:25.416]                       is.null <- base::is.null
[17:59:25.416]                       muffled <- FALSE
[17:59:25.416]                       if (inherits(cond, "message")) {
[17:59:25.416]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.416]                         if (muffled) 
[17:59:25.416]                           invokeRestart("muffleMessage")
[17:59:25.416]                       }
[17:59:25.416]                       else if (inherits(cond, "warning")) {
[17:59:25.416]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.416]                         if (muffled) 
[17:59:25.416]                           invokeRestart("muffleWarning")
[17:59:25.416]                       }
[17:59:25.416]                       else if (inherits(cond, "condition")) {
[17:59:25.416]                         if (!is.null(pattern)) {
[17:59:25.416]                           computeRestarts <- base::computeRestarts
[17:59:25.416]                           grepl <- base::grepl
[17:59:25.416]                           restarts <- computeRestarts(cond)
[17:59:25.416]                           for (restart in restarts) {
[17:59:25.416]                             name <- restart$name
[17:59:25.416]                             if (is.null(name)) 
[17:59:25.416]                               next
[17:59:25.416]                             if (!grepl(pattern, name)) 
[17:59:25.416]                               next
[17:59:25.416]                             invokeRestart(restart)
[17:59:25.416]                             muffled <- TRUE
[17:59:25.416]                             break
[17:59:25.416]                           }
[17:59:25.416]                         }
[17:59:25.416]                       }
[17:59:25.416]                       invisible(muffled)
[17:59:25.416]                     }
[17:59:25.416]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.416]                   }
[17:59:25.416]                 }
[17:59:25.416]             }
[17:59:25.416]         }))
[17:59:25.416]     }, error = function(ex) {
[17:59:25.416]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.416]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.416]                 ...future.rng), started = ...future.startTime, 
[17:59:25.416]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.416]             version = "1.8"), class = "FutureResult")
[17:59:25.416]     }, finally = {
[17:59:25.416]         if (!identical(...future.workdir, getwd())) 
[17:59:25.416]             setwd(...future.workdir)
[17:59:25.416]         {
[17:59:25.416]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.416]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.416]             }
[17:59:25.416]             base::options(...future.oldOptions)
[17:59:25.416]             if (.Platform$OS.type == "windows") {
[17:59:25.416]                 old_names <- names(...future.oldEnvVars)
[17:59:25.416]                 envs <- base::Sys.getenv()
[17:59:25.416]                 names <- names(envs)
[17:59:25.416]                 common <- intersect(names, old_names)
[17:59:25.416]                 added <- setdiff(names, old_names)
[17:59:25.416]                 removed <- setdiff(old_names, names)
[17:59:25.416]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.416]                   envs[common]]
[17:59:25.416]                 NAMES <- toupper(changed)
[17:59:25.416]                 args <- list()
[17:59:25.416]                 for (kk in seq_along(NAMES)) {
[17:59:25.416]                   name <- changed[[kk]]
[17:59:25.416]                   NAME <- NAMES[[kk]]
[17:59:25.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.416]                     next
[17:59:25.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.416]                 }
[17:59:25.416]                 NAMES <- toupper(added)
[17:59:25.416]                 for (kk in seq_along(NAMES)) {
[17:59:25.416]                   name <- added[[kk]]
[17:59:25.416]                   NAME <- NAMES[[kk]]
[17:59:25.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.416]                     next
[17:59:25.416]                   args[[name]] <- ""
[17:59:25.416]                 }
[17:59:25.416]                 NAMES <- toupper(removed)
[17:59:25.416]                 for (kk in seq_along(NAMES)) {
[17:59:25.416]                   name <- removed[[kk]]
[17:59:25.416]                   NAME <- NAMES[[kk]]
[17:59:25.416]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.416]                     next
[17:59:25.416]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.416]                 }
[17:59:25.416]                 if (length(args) > 0) 
[17:59:25.416]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.416]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.416]             }
[17:59:25.416]             else {
[17:59:25.416]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.416]             }
[17:59:25.416]             {
[17:59:25.416]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.416]                   0L) {
[17:59:25.416]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.416]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.416]                   base::options(opts)
[17:59:25.416]                 }
[17:59:25.416]                 {
[17:59:25.416]                   {
[17:59:25.416]                     NULL
[17:59:25.416]                     RNGkind("Mersenne-Twister")
[17:59:25.416]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.416]                       inherits = FALSE)
[17:59:25.416]                   }
[17:59:25.416]                   options(future.plan = NULL)
[17:59:25.416]                   if (is.na(NA_character_)) 
[17:59:25.416]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.416]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.416]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.416]                     .init = FALSE)
[17:59:25.416]                 }
[17:59:25.416]             }
[17:59:25.416]         }
[17:59:25.416]     })
[17:59:25.416]     if (TRUE) {
[17:59:25.416]         base::sink(type = "output", split = FALSE)
[17:59:25.416]         if (TRUE) {
[17:59:25.416]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.416]         }
[17:59:25.416]         else {
[17:59:25.416]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.416]         }
[17:59:25.416]         base::close(...future.stdout)
[17:59:25.416]         ...future.stdout <- NULL
[17:59:25.416]     }
[17:59:25.416]     ...future.result$conditions <- ...future.conditions
[17:59:25.416]     ...future.result$finished <- base::Sys.time()
[17:59:25.416]     ...future.result
[17:59:25.416] }
[17:59:25.420] assign_globals() ...
[17:59:25.420] List of 5
[17:59:25.420]  $ ...future.FUN            :function (object, ...)  
[17:59:25.420]  $ future.call.arguments    : list()
[17:59:25.420]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.420]  $ ...future.elements_ii    :List of 3
[17:59:25.420]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.420]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:25.420]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.420]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.420]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.420]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:25.420]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.420]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:25.420]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.420]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:25.420]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.420]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:25.420]  $ ...future.seeds_ii       : NULL
[17:59:25.420]  $ ...future.globals.maxSize: NULL
[17:59:25.420]  - attr(*, "where")=List of 5
[17:59:25.420]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.420]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.420]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.420]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.420]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.420]  - attr(*, "resolved")= logi FALSE
[17:59:25.420]  - attr(*, "total_size")= num 1240
[17:59:25.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.420]  - attr(*, "already-done")= logi TRUE
[17:59:25.441] - copied ‘...future.FUN’ to environment
[17:59:25.441] - copied ‘future.call.arguments’ to environment
[17:59:25.441] - copied ‘...future.elements_ii’ to environment
[17:59:25.442] - copied ‘...future.seeds_ii’ to environment
[17:59:25.442] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.442] assign_globals() ... done
[17:59:25.443] plan(): Setting new future strategy stack:
[17:59:25.443] List of future strategies:
[17:59:25.443] 1. sequential:
[17:59:25.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.443]    - tweaked: FALSE
[17:59:25.443]    - call: NULL
[17:59:25.444] plan(): nbrOfWorkers() = 1
[17:59:25.448] plan(): Setting new future strategy stack:
[17:59:25.449] List of future strategies:
[17:59:25.449] 1. multisession:
[17:59:25.449]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:25.449]    - tweaked: FALSE
[17:59:25.449]    - call: plan(strategy)
[17:59:25.455] plan(): nbrOfWorkers() = 1
[17:59:25.455] SequentialFuture started (and completed)
[17:59:25.456] - Launch lazy future ... done
[17:59:25.456] run() for ‘SequentialFuture’ ... done
[17:59:25.456] Created future:
[17:59:25.456] SequentialFuture:
[17:59:25.456] Label: ‘future_by-1’
[17:59:25.456] Expression:
[17:59:25.456] {
[17:59:25.456]     do.call(function(...) {
[17:59:25.456]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.456]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.456]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.456]             on.exit(options(oopts), add = TRUE)
[17:59:25.456]         }
[17:59:25.456]         {
[17:59:25.456]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.456]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.456]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.456]             })
[17:59:25.456]         }
[17:59:25.456]     }, args = future.call.arguments)
[17:59:25.456] }
[17:59:25.456] Lazy evaluation: FALSE
[17:59:25.456] Asynchronous evaluation: FALSE
[17:59:25.456] Local evaluation: TRUE
[17:59:25.456] Environment: 0x62649fb6b7e0
[17:59:25.456] Capture standard output: TRUE
[17:59:25.456] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.456] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.456] Packages: <none>
[17:59:25.456] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.456] Resolved: TRUE
[17:59:25.456] Value: 5.37 KiB of class ‘list’
[17:59:25.456] Early signaling: FALSE
[17:59:25.456] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.456] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.459] Chunk #1 of 1 ... DONE
[17:59:25.459] Launching 1 futures (chunks) ... DONE
[17:59:25.460] Resolving 1 futures (chunks) ...
[17:59:25.460] resolve() on list ...
[17:59:25.460]  recursive: 0
[17:59:25.461]  length: 1
[17:59:25.461] 
[17:59:25.461] resolved() for ‘SequentialFuture’ ...
[17:59:25.461] - state: ‘finished’
[17:59:25.462] - run: TRUE
[17:59:25.462] - result: ‘FutureResult’
[17:59:25.462] resolved() for ‘SequentialFuture’ ... done
[17:59:25.462] Future #1
[17:59:25.463] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.463] - nx: 1
[17:59:25.463] - relay: TRUE
[17:59:25.463] - stdout: TRUE
[17:59:25.463] - signal: TRUE
[17:59:25.463] - resignal: FALSE
[17:59:25.464] - force: TRUE
[17:59:25.464] - relayed: [n=1] FALSE
[17:59:25.464] - queued futures: [n=1] FALSE
[17:59:25.464]  - until=1
[17:59:25.464]  - relaying element #1
[17:59:25.465] - relayed: [n=1] TRUE
[17:59:25.465] - queued futures: [n=1] TRUE
[17:59:25.465] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.466]  length: 0 (resolved future 1)
[17:59:25.466] Relaying remaining futures
[17:59:25.466] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.466] - nx: 1
[17:59:25.466] - relay: TRUE
[17:59:25.466] - stdout: TRUE
[17:59:25.467] - signal: TRUE
[17:59:25.467] - resignal: FALSE
[17:59:25.467] - force: TRUE
[17:59:25.467] - relayed: [n=1] TRUE
[17:59:25.467] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.468] - relayed: [n=1] TRUE
[17:59:25.468] - queued futures: [n=1] TRUE
[17:59:25.468] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.468] resolve() on list ... DONE
[17:59:25.469]  - Number of value chunks collected: 1
[17:59:25.469] Resolving 1 futures (chunks) ... DONE
[17:59:25.469] Reducing values from 1 chunks ...
[17:59:25.469]  - Number of values collected after concatenation: 3
[17:59:25.469]  - Number of values expected: 3
[17:59:25.470] Reducing values from 1 chunks ... DONE
[17:59:25.470] future_lapply() ... DONE
[17:59:25.470] future_by_internal() ... DONE
[17:59:25.472] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:59:25.473] future_lapply() ...
[17:59:25.480] Number of chunks: 1
[17:59:25.480] getGlobalsAndPackagesXApply() ...
[17:59:25.481]  - future.globals: TRUE
[17:59:25.481] getGlobalsAndPackages() ...
[17:59:25.481] Searching for globals...
[17:59:25.484] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:25.484] Searching for globals ... DONE
[17:59:25.484] Resolving globals: FALSE
[17:59:25.485] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:25.486] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:25.486] - globals: [1] ‘FUN’
[17:59:25.486] 
[17:59:25.486] getGlobalsAndPackages() ... DONE
[17:59:25.487]  - globals found/used: [n=1] ‘FUN’
[17:59:25.487]  - needed namespaces: [n=0] 
[17:59:25.487] Finding globals ... DONE
[17:59:25.487]  - use_args: TRUE
[17:59:25.487]  - Getting '...' globals ...
[17:59:25.488] resolve() on list ...
[17:59:25.489]  recursive: 0
[17:59:25.489]  length: 1
[17:59:25.489]  elements: ‘...’
[17:59:25.489]  length: 0 (resolved future 1)
[17:59:25.489] resolve() on list ... DONE
[17:59:25.490]    - '...' content: [n=0] 
[17:59:25.490] List of 1
[17:59:25.490]  $ ...: list()
[17:59:25.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.490]  - attr(*, "where")=List of 1
[17:59:25.490]   ..$ ...:<environment: 0x62649fc008b0> 
[17:59:25.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.490]  - attr(*, "resolved")= logi TRUE
[17:59:25.490]  - attr(*, "total_size")= num NA
[17:59:25.499]  - Getting '...' globals ... DONE
[17:59:25.499] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.500] List of 2
[17:59:25.500]  $ ...future.FUN:function (object, ...)  
[17:59:25.500]  $ ...          : list()
[17:59:25.500]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.500]  - attr(*, "where")=List of 2
[17:59:25.500]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.500]   ..$ ...          :<environment: 0x62649fc008b0> 
[17:59:25.500]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.500]  - attr(*, "resolved")= logi FALSE
[17:59:25.500]  - attr(*, "total_size")= num 1240
[17:59:25.506] Packages to be attached in all futures: [n=0] 
[17:59:25.506] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.507] Number of futures (= number of chunks): 1
[17:59:25.507] Launching 1 futures (chunks) ...
[17:59:25.507] Chunk #1 of 1 ...
[17:59:25.507]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.508] getGlobalsAndPackages() ...
[17:59:25.508] Searching for globals...
[17:59:25.509] 
[17:59:25.509] Searching for globals ... DONE
[17:59:25.509] - globals: [0] <none>
[17:59:25.510] getGlobalsAndPackages() ... DONE
[17:59:25.510]    + additional globals found: [n=0] 
[17:59:25.510]    + additional namespaces needed: [n=0] 
[17:59:25.510]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.510]  - seeds: <none>
[17:59:25.511]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.511] getGlobalsAndPackages() ...
[17:59:25.511] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.511] Resolving globals: FALSE
[17:59:25.512] Tweak future expression to call with '...' arguments ...
[17:59:25.512] {
[17:59:25.512]     do.call(function(...) {
[17:59:25.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.512]             on.exit(options(oopts), add = TRUE)
[17:59:25.512]         }
[17:59:25.512]         {
[17:59:25.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.512]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.512]             })
[17:59:25.512]         }
[17:59:25.512]     }, args = future.call.arguments)
[17:59:25.512] }
[17:59:25.512] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.513] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.514] 
[17:59:25.514] getGlobalsAndPackages() ... DONE
[17:59:25.514] run() for ‘Future’ ...
[17:59:25.515] - state: ‘created’
[17:59:25.515] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:25.521] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.522]   - Field: ‘label’
[17:59:25.522]   - Field: ‘local’
[17:59:25.522]   - Field: ‘owner’
[17:59:25.523]   - Field: ‘envir’
[17:59:25.523]   - Field: ‘packages’
[17:59:25.523]   - Field: ‘gc’
[17:59:25.523]   - Field: ‘conditions’
[17:59:25.524]   - Field: ‘expr’
[17:59:25.524]   - Field: ‘uuid’
[17:59:25.524]   - Field: ‘seed’
[17:59:25.524]   - Field: ‘version’
[17:59:25.524]   - Field: ‘result’
[17:59:25.525]   - Field: ‘asynchronous’
[17:59:25.525]   - Field: ‘calls’
[17:59:25.525]   - Field: ‘globals’
[17:59:25.525]   - Field: ‘stdout’
[17:59:25.526]   - Field: ‘earlySignal’
[17:59:25.526]   - Field: ‘lazy’
[17:59:25.526]   - Field: ‘state’
[17:59:25.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.526] - Launch lazy future ...
[17:59:25.527] Packages needed by the future expression (n = 0): <none>
[17:59:25.527] Packages needed by future strategies (n = 0): <none>
[17:59:25.528] {
[17:59:25.528]     {
[17:59:25.528]         {
[17:59:25.528]             ...future.startTime <- base::Sys.time()
[17:59:25.528]             {
[17:59:25.528]                 {
[17:59:25.528]                   {
[17:59:25.528]                     base::local({
[17:59:25.528]                       has_future <- base::requireNamespace("future", 
[17:59:25.528]                         quietly = TRUE)
[17:59:25.528]                       if (has_future) {
[17:59:25.528]                         ns <- base::getNamespace("future")
[17:59:25.528]                         version <- ns[[".package"]][["version"]]
[17:59:25.528]                         if (is.null(version)) 
[17:59:25.528]                           version <- utils::packageVersion("future")
[17:59:25.528]                       }
[17:59:25.528]                       else {
[17:59:25.528]                         version <- NULL
[17:59:25.528]                       }
[17:59:25.528]                       if (!has_future || version < "1.8.0") {
[17:59:25.528]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.528]                           "", base::R.version$version.string), 
[17:59:25.528]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:25.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.528]                             "release", "version")], collapse = " "), 
[17:59:25.528]                           hostname = base::Sys.info()[["nodename"]])
[17:59:25.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.528]                           info)
[17:59:25.528]                         info <- base::paste(info, collapse = "; ")
[17:59:25.528]                         if (!has_future) {
[17:59:25.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.528]                             info)
[17:59:25.528]                         }
[17:59:25.528]                         else {
[17:59:25.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.528]                             info, version)
[17:59:25.528]                         }
[17:59:25.528]                         base::stop(msg)
[17:59:25.528]                       }
[17:59:25.528]                     })
[17:59:25.528]                   }
[17:59:25.528]                   ...future.strategy.old <- future::plan("list")
[17:59:25.528]                   options(future.plan = NULL)
[17:59:25.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.528]                 }
[17:59:25.528]                 ...future.workdir <- getwd()
[17:59:25.528]             }
[17:59:25.528]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.528]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.528]         }
[17:59:25.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.528]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.528]             base::names(...future.oldOptions))
[17:59:25.528]     }
[17:59:25.528]     if (FALSE) {
[17:59:25.528]     }
[17:59:25.528]     else {
[17:59:25.528]         if (TRUE) {
[17:59:25.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.528]                 open = "w")
[17:59:25.528]         }
[17:59:25.528]         else {
[17:59:25.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.528]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.528]         }
[17:59:25.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.528]             base::sink(type = "output", split = FALSE)
[17:59:25.528]             base::close(...future.stdout)
[17:59:25.528]         }, add = TRUE)
[17:59:25.528]     }
[17:59:25.528]     ...future.frame <- base::sys.nframe()
[17:59:25.528]     ...future.conditions <- base::list()
[17:59:25.528]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.528]     if (FALSE) {
[17:59:25.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.528]     }
[17:59:25.528]     ...future.result <- base::tryCatch({
[17:59:25.528]         base::withCallingHandlers({
[17:59:25.528]             ...future.value <- base::withVisible(base::local({
[17:59:25.528]                 do.call(function(...) {
[17:59:25.528]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.528]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.528]                     ...future.globals.maxSize)) {
[17:59:25.528]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.528]                     on.exit(options(oopts), add = TRUE)
[17:59:25.528]                   }
[17:59:25.528]                   {
[17:59:25.528]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.528]                       FUN = function(jj) {
[17:59:25.528]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.528]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.528]                       })
[17:59:25.528]                   }
[17:59:25.528]                 }, args = future.call.arguments)
[17:59:25.528]             }))
[17:59:25.528]             future::FutureResult(value = ...future.value$value, 
[17:59:25.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.528]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.528]                     ...future.globalenv.names))
[17:59:25.528]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.528]         }, condition = base::local({
[17:59:25.528]             c <- base::c
[17:59:25.528]             inherits <- base::inherits
[17:59:25.528]             invokeRestart <- base::invokeRestart
[17:59:25.528]             length <- base::length
[17:59:25.528]             list <- base::list
[17:59:25.528]             seq.int <- base::seq.int
[17:59:25.528]             signalCondition <- base::signalCondition
[17:59:25.528]             sys.calls <- base::sys.calls
[17:59:25.528]             `[[` <- base::`[[`
[17:59:25.528]             `+` <- base::`+`
[17:59:25.528]             `<<-` <- base::`<<-`
[17:59:25.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.528]                   3L)]
[17:59:25.528]             }
[17:59:25.528]             function(cond) {
[17:59:25.528]                 is_error <- inherits(cond, "error")
[17:59:25.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.528]                   NULL)
[17:59:25.528]                 if (is_error) {
[17:59:25.528]                   sessionInformation <- function() {
[17:59:25.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.528]                       search = base::search(), system = base::Sys.info())
[17:59:25.528]                   }
[17:59:25.528]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.528]                     cond$call), session = sessionInformation(), 
[17:59:25.528]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.528]                   signalCondition(cond)
[17:59:25.528]                 }
[17:59:25.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.528]                 "immediateCondition"))) {
[17:59:25.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.528]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.528]                   if (TRUE && !signal) {
[17:59:25.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.528]                     {
[17:59:25.528]                       inherits <- base::inherits
[17:59:25.528]                       invokeRestart <- base::invokeRestart
[17:59:25.528]                       is.null <- base::is.null
[17:59:25.528]                       muffled <- FALSE
[17:59:25.528]                       if (inherits(cond, "message")) {
[17:59:25.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.528]                         if (muffled) 
[17:59:25.528]                           invokeRestart("muffleMessage")
[17:59:25.528]                       }
[17:59:25.528]                       else if (inherits(cond, "warning")) {
[17:59:25.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.528]                         if (muffled) 
[17:59:25.528]                           invokeRestart("muffleWarning")
[17:59:25.528]                       }
[17:59:25.528]                       else if (inherits(cond, "condition")) {
[17:59:25.528]                         if (!is.null(pattern)) {
[17:59:25.528]                           computeRestarts <- base::computeRestarts
[17:59:25.528]                           grepl <- base::grepl
[17:59:25.528]                           restarts <- computeRestarts(cond)
[17:59:25.528]                           for (restart in restarts) {
[17:59:25.528]                             name <- restart$name
[17:59:25.528]                             if (is.null(name)) 
[17:59:25.528]                               next
[17:59:25.528]                             if (!grepl(pattern, name)) 
[17:59:25.528]                               next
[17:59:25.528]                             invokeRestart(restart)
[17:59:25.528]                             muffled <- TRUE
[17:59:25.528]                             break
[17:59:25.528]                           }
[17:59:25.528]                         }
[17:59:25.528]                       }
[17:59:25.528]                       invisible(muffled)
[17:59:25.528]                     }
[17:59:25.528]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.528]                   }
[17:59:25.528]                 }
[17:59:25.528]                 else {
[17:59:25.528]                   if (TRUE) {
[17:59:25.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.528]                     {
[17:59:25.528]                       inherits <- base::inherits
[17:59:25.528]                       invokeRestart <- base::invokeRestart
[17:59:25.528]                       is.null <- base::is.null
[17:59:25.528]                       muffled <- FALSE
[17:59:25.528]                       if (inherits(cond, "message")) {
[17:59:25.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.528]                         if (muffled) 
[17:59:25.528]                           invokeRestart("muffleMessage")
[17:59:25.528]                       }
[17:59:25.528]                       else if (inherits(cond, "warning")) {
[17:59:25.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.528]                         if (muffled) 
[17:59:25.528]                           invokeRestart("muffleWarning")
[17:59:25.528]                       }
[17:59:25.528]                       else if (inherits(cond, "condition")) {
[17:59:25.528]                         if (!is.null(pattern)) {
[17:59:25.528]                           computeRestarts <- base::computeRestarts
[17:59:25.528]                           grepl <- base::grepl
[17:59:25.528]                           restarts <- computeRestarts(cond)
[17:59:25.528]                           for (restart in restarts) {
[17:59:25.528]                             name <- restart$name
[17:59:25.528]                             if (is.null(name)) 
[17:59:25.528]                               next
[17:59:25.528]                             if (!grepl(pattern, name)) 
[17:59:25.528]                               next
[17:59:25.528]                             invokeRestart(restart)
[17:59:25.528]                             muffled <- TRUE
[17:59:25.528]                             break
[17:59:25.528]                           }
[17:59:25.528]                         }
[17:59:25.528]                       }
[17:59:25.528]                       invisible(muffled)
[17:59:25.528]                     }
[17:59:25.528]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.528]                   }
[17:59:25.528]                 }
[17:59:25.528]             }
[17:59:25.528]         }))
[17:59:25.528]     }, error = function(ex) {
[17:59:25.528]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.528]                 ...future.rng), started = ...future.startTime, 
[17:59:25.528]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.528]             version = "1.8"), class = "FutureResult")
[17:59:25.528]     }, finally = {
[17:59:25.528]         if (!identical(...future.workdir, getwd())) 
[17:59:25.528]             setwd(...future.workdir)
[17:59:25.528]         {
[17:59:25.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.528]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.528]             }
[17:59:25.528]             base::options(...future.oldOptions)
[17:59:25.528]             if (.Platform$OS.type == "windows") {
[17:59:25.528]                 old_names <- names(...future.oldEnvVars)
[17:59:25.528]                 envs <- base::Sys.getenv()
[17:59:25.528]                 names <- names(envs)
[17:59:25.528]                 common <- intersect(names, old_names)
[17:59:25.528]                 added <- setdiff(names, old_names)
[17:59:25.528]                 removed <- setdiff(old_names, names)
[17:59:25.528]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.528]                   envs[common]]
[17:59:25.528]                 NAMES <- toupper(changed)
[17:59:25.528]                 args <- list()
[17:59:25.528]                 for (kk in seq_along(NAMES)) {
[17:59:25.528]                   name <- changed[[kk]]
[17:59:25.528]                   NAME <- NAMES[[kk]]
[17:59:25.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.528]                     next
[17:59:25.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.528]                 }
[17:59:25.528]                 NAMES <- toupper(added)
[17:59:25.528]                 for (kk in seq_along(NAMES)) {
[17:59:25.528]                   name <- added[[kk]]
[17:59:25.528]                   NAME <- NAMES[[kk]]
[17:59:25.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.528]                     next
[17:59:25.528]                   args[[name]] <- ""
[17:59:25.528]                 }
[17:59:25.528]                 NAMES <- toupper(removed)
[17:59:25.528]                 for (kk in seq_along(NAMES)) {
[17:59:25.528]                   name <- removed[[kk]]
[17:59:25.528]                   NAME <- NAMES[[kk]]
[17:59:25.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.528]                     next
[17:59:25.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.528]                 }
[17:59:25.528]                 if (length(args) > 0) 
[17:59:25.528]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.528]             }
[17:59:25.528]             else {
[17:59:25.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.528]             }
[17:59:25.528]             {
[17:59:25.528]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.528]                   0L) {
[17:59:25.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.528]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.528]                   base::options(opts)
[17:59:25.528]                 }
[17:59:25.528]                 {
[17:59:25.528]                   {
[17:59:25.528]                     NULL
[17:59:25.528]                     RNGkind("Mersenne-Twister")
[17:59:25.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.528]                       inherits = FALSE)
[17:59:25.528]                   }
[17:59:25.528]                   options(future.plan = NULL)
[17:59:25.528]                   if (is.na(NA_character_)) 
[17:59:25.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.528]                     .init = FALSE)
[17:59:25.528]                 }
[17:59:25.528]             }
[17:59:25.528]         }
[17:59:25.528]     })
[17:59:25.528]     if (TRUE) {
[17:59:25.528]         base::sink(type = "output", split = FALSE)
[17:59:25.528]         if (TRUE) {
[17:59:25.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.528]         }
[17:59:25.528]         else {
[17:59:25.528]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.528]         }
[17:59:25.528]         base::close(...future.stdout)
[17:59:25.528]         ...future.stdout <- NULL
[17:59:25.528]     }
[17:59:25.528]     ...future.result$conditions <- ...future.conditions
[17:59:25.528]     ...future.result$finished <- base::Sys.time()
[17:59:25.528]     ...future.result
[17:59:25.528] }
[17:59:25.532] assign_globals() ...
[17:59:25.532] List of 5
[17:59:25.532]  $ ...future.FUN            :function (object, ...)  
[17:59:25.532]  $ future.call.arguments    : list()
[17:59:25.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.532]  $ ...future.elements_ii    :List of 3
[17:59:25.532]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.532]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:25.532]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.532]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.532]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.532]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:25.532]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.532]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:25.532]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.532]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:25.532]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.532]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:25.532]  $ ...future.seeds_ii       : NULL
[17:59:25.532]  $ ...future.globals.maxSize: NULL
[17:59:25.532]  - attr(*, "where")=List of 5
[17:59:25.532]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.532]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.532]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.532]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.532]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.532]  - attr(*, "resolved")= logi FALSE
[17:59:25.532]  - attr(*, "total_size")= num 1240
[17:59:25.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.532]  - attr(*, "already-done")= logi TRUE
[17:59:25.554] - copied ‘...future.FUN’ to environment
[17:59:25.554] - copied ‘future.call.arguments’ to environment
[17:59:25.555] - copied ‘...future.elements_ii’ to environment
[17:59:25.555] - copied ‘...future.seeds_ii’ to environment
[17:59:25.555] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.555] assign_globals() ... done
[17:59:25.556] plan(): Setting new future strategy stack:
[17:59:25.556] List of future strategies:
[17:59:25.556] 1. sequential:
[17:59:25.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.556]    - tweaked: FALSE
[17:59:25.556]    - call: NULL
[17:59:25.557] plan(): nbrOfWorkers() = 1
[17:59:25.561] plan(): Setting new future strategy stack:
[17:59:25.561] List of future strategies:
[17:59:25.561] 1. multisession:
[17:59:25.561]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:25.561]    - tweaked: FALSE
[17:59:25.561]    - call: plan(strategy)
[17:59:25.567] plan(): nbrOfWorkers() = 1
[17:59:25.568] SequentialFuture started (and completed)
[17:59:25.568] - Launch lazy future ... done
[17:59:25.568] run() for ‘SequentialFuture’ ... done
[17:59:25.568] Created future:
[17:59:25.569] SequentialFuture:
[17:59:25.569] Label: ‘future_by-1’
[17:59:25.569] Expression:
[17:59:25.569] {
[17:59:25.569]     do.call(function(...) {
[17:59:25.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.569]             on.exit(options(oopts), add = TRUE)
[17:59:25.569]         }
[17:59:25.569]         {
[17:59:25.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.569]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.569]             })
[17:59:25.569]         }
[17:59:25.569]     }, args = future.call.arguments)
[17:59:25.569] }
[17:59:25.569] Lazy evaluation: FALSE
[17:59:25.569] Asynchronous evaluation: FALSE
[17:59:25.569] Local evaluation: TRUE
[17:59:25.569] Environment: 0x62649fbaebe0
[17:59:25.569] Capture standard output: TRUE
[17:59:25.569] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.569] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.569] Packages: <none>
[17:59:25.569] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.569] Resolved: TRUE
[17:59:25.569] Value: 5.37 KiB of class ‘list’
[17:59:25.569] Early signaling: FALSE
[17:59:25.569] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.569] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.571] Chunk #1 of 1 ... DONE
[17:59:25.572] Launching 1 futures (chunks) ... DONE
[17:59:25.572] Resolving 1 futures (chunks) ...
[17:59:25.572] resolve() on list ...
[17:59:25.572]  recursive: 0
[17:59:25.572]  length: 1
[17:59:25.573] 
[17:59:25.573] resolved() for ‘SequentialFuture’ ...
[17:59:25.573] - state: ‘finished’
[17:59:25.573] - run: TRUE
[17:59:25.573] - result: ‘FutureResult’
[17:59:25.574] resolved() for ‘SequentialFuture’ ... done
[17:59:25.574] Future #1
[17:59:25.574] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.574] - nx: 1
[17:59:25.574] - relay: TRUE
[17:59:25.575] - stdout: TRUE
[17:59:25.575] - signal: TRUE
[17:59:25.575] - resignal: FALSE
[17:59:25.575] - force: TRUE
[17:59:25.575] - relayed: [n=1] FALSE
[17:59:25.576] - queued futures: [n=1] FALSE
[17:59:25.576]  - until=1
[17:59:25.576]  - relaying element #1
[17:59:25.576] - relayed: [n=1] TRUE
[17:59:25.577] - queued futures: [n=1] TRUE
[17:59:25.577] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.577]  length: 0 (resolved future 1)
[17:59:25.577] Relaying remaining futures
[17:59:25.577] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.578] - nx: 1
[17:59:25.578] - relay: TRUE
[17:59:25.578] - stdout: TRUE
[17:59:25.578] - signal: TRUE
[17:59:25.578] - resignal: FALSE
[17:59:25.578] - force: TRUE
[17:59:25.579] - relayed: [n=1] TRUE
[17:59:25.579] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.579] - relayed: [n=1] TRUE
[17:59:25.579] - queued futures: [n=1] TRUE
[17:59:25.579] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.580] resolve() on list ... DONE
[17:59:25.580]  - Number of value chunks collected: 1
[17:59:25.580] Resolving 1 futures (chunks) ... DONE
[17:59:25.580] Reducing values from 1 chunks ...
[17:59:25.581]  - Number of values collected after concatenation: 3
[17:59:25.581]  - Number of values expected: 3
[17:59:25.581] Reducing values from 1 chunks ... DONE
[17:59:25.581] future_lapply() ... DONE
[17:59:25.581] future_by_internal() ... DONE
[17:59:25.583] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[17:59:25.585] plan(): Setting new future strategy stack:
[17:59:25.585] List of future strategies:
[17:59:25.585] 1. sequential:
[17:59:25.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.585]    - tweaked: FALSE
[17:59:25.585]    - call: plan(strategy)
[17:59:25.586] plan(): nbrOfWorkers() = 1
[17:59:25.586] future_by_internal() ...
[17:59:25.587] future_lapply() ...
[17:59:25.588] Number of chunks: 1
[17:59:25.588] getGlobalsAndPackagesXApply() ...
[17:59:25.588]  - future.globals: TRUE
[17:59:25.588] getGlobalsAndPackages() ...
[17:59:25.589] Searching for globals...
[17:59:25.593] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:25.593] Searching for globals ... DONE
[17:59:25.593] Resolving globals: FALSE
[17:59:25.594] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:25.595] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:25.595] - globals: [1] ‘FUN’
[17:59:25.595] 
[17:59:25.595] getGlobalsAndPackages() ... DONE
[17:59:25.596]  - globals found/used: [n=1] ‘FUN’
[17:59:25.596]  - needed namespaces: [n=0] 
[17:59:25.596] Finding globals ... DONE
[17:59:25.596]  - use_args: TRUE
[17:59:25.597]  - Getting '...' globals ...
[17:59:25.597] resolve() on list ...
[17:59:25.597]  recursive: 0
[17:59:25.598]  length: 1
[17:59:25.598]  elements: ‘...’
[17:59:25.601]  length: 0 (resolved future 1)
[17:59:25.601] resolve() on list ... DONE
[17:59:25.601]    - '...' content: [n=0] 
[17:59:25.601] List of 1
[17:59:25.601]  $ ...: list()
[17:59:25.601]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.601]  - attr(*, "where")=List of 1
[17:59:25.601]   ..$ ...:<environment: 0x62649fdbde20> 
[17:59:25.601]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.601]  - attr(*, "resolved")= logi TRUE
[17:59:25.601]  - attr(*, "total_size")= num NA
[17:59:25.608]  - Getting '...' globals ... DONE
[17:59:25.608] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.608] List of 2
[17:59:25.608]  $ ...future.FUN:function (object, ...)  
[17:59:25.608]  $ ...          : list()
[17:59:25.608]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.608]  - attr(*, "where")=List of 2
[17:59:25.608]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.608]   ..$ ...          :<environment: 0x62649fdbde20> 
[17:59:25.608]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.608]  - attr(*, "resolved")= logi FALSE
[17:59:25.608]  - attr(*, "total_size")= num 1240
[17:59:25.631] Packages to be attached in all futures: [n=0] 
[17:59:25.631] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.632] Number of futures (= number of chunks): 1
[17:59:25.632] Launching 1 futures (chunks) ...
[17:59:25.632] Chunk #1 of 1 ...
[17:59:25.632]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.633] getGlobalsAndPackages() ...
[17:59:25.633] Searching for globals...
[17:59:25.634] 
[17:59:25.634] Searching for globals ... DONE
[17:59:25.634] - globals: [0] <none>
[17:59:25.635] getGlobalsAndPackages() ... DONE
[17:59:25.635]    + additional globals found: [n=0] 
[17:59:25.635]    + additional namespaces needed: [n=0] 
[17:59:25.635]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.635]  - seeds: <none>
[17:59:25.636]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.636] getGlobalsAndPackages() ...
[17:59:25.636] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.636] Resolving globals: FALSE
[17:59:25.636] Tweak future expression to call with '...' arguments ...
[17:59:25.637] {
[17:59:25.637]     do.call(function(...) {
[17:59:25.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.637]             on.exit(options(oopts), add = TRUE)
[17:59:25.637]         }
[17:59:25.637]         {
[17:59:25.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.637]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.637]             })
[17:59:25.637]         }
[17:59:25.637]     }, args = future.call.arguments)
[17:59:25.637] }
[17:59:25.637] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.638] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.638] 
[17:59:25.638] getGlobalsAndPackages() ... DONE
[17:59:25.639] run() for ‘Future’ ...
[17:59:25.639] - state: ‘created’
[17:59:25.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:25.640] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.640] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.640]   - Field: ‘label’
[17:59:25.641]   - Field: ‘local’
[17:59:25.641]   - Field: ‘owner’
[17:59:25.641]   - Field: ‘envir’
[17:59:25.641]   - Field: ‘packages’
[17:59:25.641]   - Field: ‘gc’
[17:59:25.642]   - Field: ‘conditions’
[17:59:25.642]   - Field: ‘expr’
[17:59:25.642]   - Field: ‘uuid’
[17:59:25.642]   - Field: ‘seed’
[17:59:25.642]   - Field: ‘version’
[17:59:25.643]   - Field: ‘result’
[17:59:25.643]   - Field: ‘asynchronous’
[17:59:25.643]   - Field: ‘calls’
[17:59:25.643]   - Field: ‘globals’
[17:59:25.643]   - Field: ‘stdout’
[17:59:25.644]   - Field: ‘earlySignal’
[17:59:25.644]   - Field: ‘lazy’
[17:59:25.644]   - Field: ‘state’
[17:59:25.644] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.644] - Launch lazy future ...
[17:59:25.645] Packages needed by the future expression (n = 0): <none>
[17:59:25.645] Packages needed by future strategies (n = 0): <none>
[17:59:25.646] {
[17:59:25.646]     {
[17:59:25.646]         {
[17:59:25.646]             ...future.startTime <- base::Sys.time()
[17:59:25.646]             {
[17:59:25.646]                 {
[17:59:25.646]                   {
[17:59:25.646]                     base::local({
[17:59:25.646]                       has_future <- base::requireNamespace("future", 
[17:59:25.646]                         quietly = TRUE)
[17:59:25.646]                       if (has_future) {
[17:59:25.646]                         ns <- base::getNamespace("future")
[17:59:25.646]                         version <- ns[[".package"]][["version"]]
[17:59:25.646]                         if (is.null(version)) 
[17:59:25.646]                           version <- utils::packageVersion("future")
[17:59:25.646]                       }
[17:59:25.646]                       else {
[17:59:25.646]                         version <- NULL
[17:59:25.646]                       }
[17:59:25.646]                       if (!has_future || version < "1.8.0") {
[17:59:25.646]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.646]                           "", base::R.version$version.string), 
[17:59:25.646]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:25.646]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.646]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.646]                             "release", "version")], collapse = " "), 
[17:59:25.646]                           hostname = base::Sys.info()[["nodename"]])
[17:59:25.646]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.646]                           info)
[17:59:25.646]                         info <- base::paste(info, collapse = "; ")
[17:59:25.646]                         if (!has_future) {
[17:59:25.646]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.646]                             info)
[17:59:25.646]                         }
[17:59:25.646]                         else {
[17:59:25.646]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.646]                             info, version)
[17:59:25.646]                         }
[17:59:25.646]                         base::stop(msg)
[17:59:25.646]                       }
[17:59:25.646]                     })
[17:59:25.646]                   }
[17:59:25.646]                   ...future.strategy.old <- future::plan("list")
[17:59:25.646]                   options(future.plan = NULL)
[17:59:25.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.646]                 }
[17:59:25.646]                 ...future.workdir <- getwd()
[17:59:25.646]             }
[17:59:25.646]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.646]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.646]         }
[17:59:25.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.646]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.646]             base::names(...future.oldOptions))
[17:59:25.646]     }
[17:59:25.646]     if (FALSE) {
[17:59:25.646]     }
[17:59:25.646]     else {
[17:59:25.646]         if (TRUE) {
[17:59:25.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.646]                 open = "w")
[17:59:25.646]         }
[17:59:25.646]         else {
[17:59:25.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.646]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.646]         }
[17:59:25.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.646]             base::sink(type = "output", split = FALSE)
[17:59:25.646]             base::close(...future.stdout)
[17:59:25.646]         }, add = TRUE)
[17:59:25.646]     }
[17:59:25.646]     ...future.frame <- base::sys.nframe()
[17:59:25.646]     ...future.conditions <- base::list()
[17:59:25.646]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.646]     if (FALSE) {
[17:59:25.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.646]     }
[17:59:25.646]     ...future.result <- base::tryCatch({
[17:59:25.646]         base::withCallingHandlers({
[17:59:25.646]             ...future.value <- base::withVisible(base::local({
[17:59:25.646]                 do.call(function(...) {
[17:59:25.646]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.646]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.646]                     ...future.globals.maxSize)) {
[17:59:25.646]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.646]                     on.exit(options(oopts), add = TRUE)
[17:59:25.646]                   }
[17:59:25.646]                   {
[17:59:25.646]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.646]                       FUN = function(jj) {
[17:59:25.646]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.646]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.646]                       })
[17:59:25.646]                   }
[17:59:25.646]                 }, args = future.call.arguments)
[17:59:25.646]             }))
[17:59:25.646]             future::FutureResult(value = ...future.value$value, 
[17:59:25.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.646]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.646]                     ...future.globalenv.names))
[17:59:25.646]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.646]         }, condition = base::local({
[17:59:25.646]             c <- base::c
[17:59:25.646]             inherits <- base::inherits
[17:59:25.646]             invokeRestart <- base::invokeRestart
[17:59:25.646]             length <- base::length
[17:59:25.646]             list <- base::list
[17:59:25.646]             seq.int <- base::seq.int
[17:59:25.646]             signalCondition <- base::signalCondition
[17:59:25.646]             sys.calls <- base::sys.calls
[17:59:25.646]             `[[` <- base::`[[`
[17:59:25.646]             `+` <- base::`+`
[17:59:25.646]             `<<-` <- base::`<<-`
[17:59:25.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.646]                   3L)]
[17:59:25.646]             }
[17:59:25.646]             function(cond) {
[17:59:25.646]                 is_error <- inherits(cond, "error")
[17:59:25.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.646]                   NULL)
[17:59:25.646]                 if (is_error) {
[17:59:25.646]                   sessionInformation <- function() {
[17:59:25.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.646]                       search = base::search(), system = base::Sys.info())
[17:59:25.646]                   }
[17:59:25.646]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.646]                     cond$call), session = sessionInformation(), 
[17:59:25.646]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.646]                   signalCondition(cond)
[17:59:25.646]                 }
[17:59:25.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.646]                 "immediateCondition"))) {
[17:59:25.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.646]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.646]                   if (TRUE && !signal) {
[17:59:25.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.646]                     {
[17:59:25.646]                       inherits <- base::inherits
[17:59:25.646]                       invokeRestart <- base::invokeRestart
[17:59:25.646]                       is.null <- base::is.null
[17:59:25.646]                       muffled <- FALSE
[17:59:25.646]                       if (inherits(cond, "message")) {
[17:59:25.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.646]                         if (muffled) 
[17:59:25.646]                           invokeRestart("muffleMessage")
[17:59:25.646]                       }
[17:59:25.646]                       else if (inherits(cond, "warning")) {
[17:59:25.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.646]                         if (muffled) 
[17:59:25.646]                           invokeRestart("muffleWarning")
[17:59:25.646]                       }
[17:59:25.646]                       else if (inherits(cond, "condition")) {
[17:59:25.646]                         if (!is.null(pattern)) {
[17:59:25.646]                           computeRestarts <- base::computeRestarts
[17:59:25.646]                           grepl <- base::grepl
[17:59:25.646]                           restarts <- computeRestarts(cond)
[17:59:25.646]                           for (restart in restarts) {
[17:59:25.646]                             name <- restart$name
[17:59:25.646]                             if (is.null(name)) 
[17:59:25.646]                               next
[17:59:25.646]                             if (!grepl(pattern, name)) 
[17:59:25.646]                               next
[17:59:25.646]                             invokeRestart(restart)
[17:59:25.646]                             muffled <- TRUE
[17:59:25.646]                             break
[17:59:25.646]                           }
[17:59:25.646]                         }
[17:59:25.646]                       }
[17:59:25.646]                       invisible(muffled)
[17:59:25.646]                     }
[17:59:25.646]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.646]                   }
[17:59:25.646]                 }
[17:59:25.646]                 else {
[17:59:25.646]                   if (TRUE) {
[17:59:25.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.646]                     {
[17:59:25.646]                       inherits <- base::inherits
[17:59:25.646]                       invokeRestart <- base::invokeRestart
[17:59:25.646]                       is.null <- base::is.null
[17:59:25.646]                       muffled <- FALSE
[17:59:25.646]                       if (inherits(cond, "message")) {
[17:59:25.646]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.646]                         if (muffled) 
[17:59:25.646]                           invokeRestart("muffleMessage")
[17:59:25.646]                       }
[17:59:25.646]                       else if (inherits(cond, "warning")) {
[17:59:25.646]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.646]                         if (muffled) 
[17:59:25.646]                           invokeRestart("muffleWarning")
[17:59:25.646]                       }
[17:59:25.646]                       else if (inherits(cond, "condition")) {
[17:59:25.646]                         if (!is.null(pattern)) {
[17:59:25.646]                           computeRestarts <- base::computeRestarts
[17:59:25.646]                           grepl <- base::grepl
[17:59:25.646]                           restarts <- computeRestarts(cond)
[17:59:25.646]                           for (restart in restarts) {
[17:59:25.646]                             name <- restart$name
[17:59:25.646]                             if (is.null(name)) 
[17:59:25.646]                               next
[17:59:25.646]                             if (!grepl(pattern, name)) 
[17:59:25.646]                               next
[17:59:25.646]                             invokeRestart(restart)
[17:59:25.646]                             muffled <- TRUE
[17:59:25.646]                             break
[17:59:25.646]                           }
[17:59:25.646]                         }
[17:59:25.646]                       }
[17:59:25.646]                       invisible(muffled)
[17:59:25.646]                     }
[17:59:25.646]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.646]                   }
[17:59:25.646]                 }
[17:59:25.646]             }
[17:59:25.646]         }))
[17:59:25.646]     }, error = function(ex) {
[17:59:25.646]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.646]                 ...future.rng), started = ...future.startTime, 
[17:59:25.646]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.646]             version = "1.8"), class = "FutureResult")
[17:59:25.646]     }, finally = {
[17:59:25.646]         if (!identical(...future.workdir, getwd())) 
[17:59:25.646]             setwd(...future.workdir)
[17:59:25.646]         {
[17:59:25.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.646]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.646]             }
[17:59:25.646]             base::options(...future.oldOptions)
[17:59:25.646]             if (.Platform$OS.type == "windows") {
[17:59:25.646]                 old_names <- names(...future.oldEnvVars)
[17:59:25.646]                 envs <- base::Sys.getenv()
[17:59:25.646]                 names <- names(envs)
[17:59:25.646]                 common <- intersect(names, old_names)
[17:59:25.646]                 added <- setdiff(names, old_names)
[17:59:25.646]                 removed <- setdiff(old_names, names)
[17:59:25.646]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.646]                   envs[common]]
[17:59:25.646]                 NAMES <- toupper(changed)
[17:59:25.646]                 args <- list()
[17:59:25.646]                 for (kk in seq_along(NAMES)) {
[17:59:25.646]                   name <- changed[[kk]]
[17:59:25.646]                   NAME <- NAMES[[kk]]
[17:59:25.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.646]                     next
[17:59:25.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.646]                 }
[17:59:25.646]                 NAMES <- toupper(added)
[17:59:25.646]                 for (kk in seq_along(NAMES)) {
[17:59:25.646]                   name <- added[[kk]]
[17:59:25.646]                   NAME <- NAMES[[kk]]
[17:59:25.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.646]                     next
[17:59:25.646]                   args[[name]] <- ""
[17:59:25.646]                 }
[17:59:25.646]                 NAMES <- toupper(removed)
[17:59:25.646]                 for (kk in seq_along(NAMES)) {
[17:59:25.646]                   name <- removed[[kk]]
[17:59:25.646]                   NAME <- NAMES[[kk]]
[17:59:25.646]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.646]                     next
[17:59:25.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.646]                 }
[17:59:25.646]                 if (length(args) > 0) 
[17:59:25.646]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.646]             }
[17:59:25.646]             else {
[17:59:25.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.646]             }
[17:59:25.646]             {
[17:59:25.646]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.646]                   0L) {
[17:59:25.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.646]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.646]                   base::options(opts)
[17:59:25.646]                 }
[17:59:25.646]                 {
[17:59:25.646]                   {
[17:59:25.646]                     NULL
[17:59:25.646]                     RNGkind("Mersenne-Twister")
[17:59:25.646]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.646]                       inherits = FALSE)
[17:59:25.646]                   }
[17:59:25.646]                   options(future.plan = NULL)
[17:59:25.646]                   if (is.na(NA_character_)) 
[17:59:25.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.646]                     .init = FALSE)
[17:59:25.646]                 }
[17:59:25.646]             }
[17:59:25.646]         }
[17:59:25.646]     })
[17:59:25.646]     if (TRUE) {
[17:59:25.646]         base::sink(type = "output", split = FALSE)
[17:59:25.646]         if (TRUE) {
[17:59:25.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.646]         }
[17:59:25.646]         else {
[17:59:25.646]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.646]         }
[17:59:25.646]         base::close(...future.stdout)
[17:59:25.646]         ...future.stdout <- NULL
[17:59:25.646]     }
[17:59:25.646]     ...future.result$conditions <- ...future.conditions
[17:59:25.646]     ...future.result$finished <- base::Sys.time()
[17:59:25.646]     ...future.result
[17:59:25.646] }
[17:59:25.649] assign_globals() ...
[17:59:25.649] List of 5
[17:59:25.649]  $ ...future.FUN            :function (object, ...)  
[17:59:25.649]  $ future.call.arguments    : list()
[17:59:25.649]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.649]  $ ...future.elements_ii    :List of 3
[17:59:25.649]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:25.649]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:25.649]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.649]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:25.649]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:25.649]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.649]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:25.649]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:25.649]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.649]  $ ...future.seeds_ii       : NULL
[17:59:25.649]  $ ...future.globals.maxSize: NULL
[17:59:25.649]  - attr(*, "where")=List of 5
[17:59:25.649]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.649]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.649]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.649]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.649]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.649]  - attr(*, "resolved")= logi FALSE
[17:59:25.649]  - attr(*, "total_size")= num 1240
[17:59:25.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.649]  - attr(*, "already-done")= logi TRUE
[17:59:25.672] - copied ‘...future.FUN’ to environment
[17:59:25.673] - copied ‘future.call.arguments’ to environment
[17:59:25.673] - copied ‘...future.elements_ii’ to environment
[17:59:25.673] - copied ‘...future.seeds_ii’ to environment
[17:59:25.673] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.674] assign_globals() ... done
[17:59:25.674] plan(): Setting new future strategy stack:
[17:59:25.674] List of future strategies:
[17:59:25.674] 1. sequential:
[17:59:25.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.674]    - tweaked: FALSE
[17:59:25.674]    - call: NULL
[17:59:25.675] plan(): nbrOfWorkers() = 1
[17:59:25.680] plan(): Setting new future strategy stack:
[17:59:25.680] List of future strategies:
[17:59:25.680] 1. sequential:
[17:59:25.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.680]    - tweaked: FALSE
[17:59:25.680]    - call: plan(strategy)
[17:59:25.681] plan(): nbrOfWorkers() = 1
[17:59:25.681] SequentialFuture started (and completed)
[17:59:25.681] - Launch lazy future ... done
[17:59:25.682] run() for ‘SequentialFuture’ ... done
[17:59:25.682] Created future:
[17:59:25.682] SequentialFuture:
[17:59:25.682] Label: ‘future_by-1’
[17:59:25.682] Expression:
[17:59:25.682] {
[17:59:25.682]     do.call(function(...) {
[17:59:25.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.682]             on.exit(options(oopts), add = TRUE)
[17:59:25.682]         }
[17:59:25.682]         {
[17:59:25.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.682]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.682]             })
[17:59:25.682]         }
[17:59:25.682]     }, args = future.call.arguments)
[17:59:25.682] }
[17:59:25.682] Lazy evaluation: FALSE
[17:59:25.682] Asynchronous evaluation: FALSE
[17:59:25.682] Local evaluation: TRUE
[17:59:25.682] Environment: R_GlobalEnv
[17:59:25.682] Capture standard output: TRUE
[17:59:25.682] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.682] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.682] Packages: <none>
[17:59:25.682] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.682] Resolved: TRUE
[17:59:25.682] Value: 4.62 KiB of class ‘list’
[17:59:25.682] Early signaling: FALSE
[17:59:25.682] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.682] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.685] Chunk #1 of 1 ... DONE
[17:59:25.685] Launching 1 futures (chunks) ... DONE
[17:59:25.685] Resolving 1 futures (chunks) ...
[17:59:25.685] resolve() on list ...
[17:59:25.686]  recursive: 0
[17:59:25.686]  length: 1
[17:59:25.686] 
[17:59:25.686] resolved() for ‘SequentialFuture’ ...
[17:59:25.686] - state: ‘finished’
[17:59:25.687] - run: TRUE
[17:59:25.687] - result: ‘FutureResult’
[17:59:25.687] resolved() for ‘SequentialFuture’ ... done
[17:59:25.687] Future #1
[17:59:25.687] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.688] - nx: 1
[17:59:25.688] - relay: TRUE
[17:59:25.688] - stdout: TRUE
[17:59:25.688] - signal: TRUE
[17:59:25.688] - resignal: FALSE
[17:59:25.689] - force: TRUE
[17:59:25.689] - relayed: [n=1] FALSE
[17:59:25.689] - queued futures: [n=1] FALSE
[17:59:25.689]  - until=1
[17:59:25.689]  - relaying element #1
[17:59:25.690] - relayed: [n=1] TRUE
[17:59:25.690] - queued futures: [n=1] TRUE
[17:59:25.690] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.690]  length: 0 (resolved future 1)
[17:59:25.691] Relaying remaining futures
[17:59:25.691] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.691] - nx: 1
[17:59:25.691] - relay: TRUE
[17:59:25.691] - stdout: TRUE
[17:59:25.691] - signal: TRUE
[17:59:25.692] - resignal: FALSE
[17:59:25.692] - force: TRUE
[17:59:25.692] - relayed: [n=1] TRUE
[17:59:25.692] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.693] - relayed: [n=1] TRUE
[17:59:25.693] - queued futures: [n=1] TRUE
[17:59:25.693] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.693] resolve() on list ... DONE
[17:59:25.693]  - Number of value chunks collected: 1
[17:59:25.694] Resolving 1 futures (chunks) ... DONE
[17:59:25.694] Reducing values from 1 chunks ...
[17:59:25.694]  - Number of values collected after concatenation: 3
[17:59:25.694]  - Number of values expected: 3
[17:59:25.694] Reducing values from 1 chunks ... DONE
[17:59:25.695] future_lapply() ... DONE
[17:59:25.695] future_by_internal() ... DONE
[17:59:25.695] future_by_internal() ...
[17:59:25.696] future_lapply() ...
[17:59:25.697] Number of chunks: 1
[17:59:25.697] getGlobalsAndPackagesXApply() ...
[17:59:25.698]  - future.globals: TRUE
[17:59:25.698] getGlobalsAndPackages() ...
[17:59:25.698] Searching for globals...
[17:59:25.700] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:25.701] Searching for globals ... DONE
[17:59:25.701] Resolving globals: FALSE
[17:59:25.701] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:25.702] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:25.702] - globals: [1] ‘FUN’
[17:59:25.703] 
[17:59:25.703] getGlobalsAndPackages() ... DONE
[17:59:25.703]  - globals found/used: [n=1] ‘FUN’
[17:59:25.703]  - needed namespaces: [n=0] 
[17:59:25.703] Finding globals ... DONE
[17:59:25.704]  - use_args: TRUE
[17:59:25.704]  - Getting '...' globals ...
[17:59:25.705] resolve() on list ...
[17:59:25.705]  recursive: 0
[17:59:25.705]  length: 1
[17:59:25.705]  elements: ‘...’
[17:59:25.706]  length: 0 (resolved future 1)
[17:59:25.706] resolve() on list ... DONE
[17:59:25.706]    - '...' content: [n=1] ‘digits’
[17:59:25.706] List of 1
[17:59:25.706]  $ ...:List of 1
[17:59:25.706]   ..$ digits: int 2
[17:59:25.706]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.706]  - attr(*, "where")=List of 1
[17:59:25.706]   ..$ ...:<environment: 0x62649f985c20> 
[17:59:25.706]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.706]  - attr(*, "resolved")= logi TRUE
[17:59:25.706]  - attr(*, "total_size")= num NA
[17:59:25.713]  - Getting '...' globals ... DONE
[17:59:25.713] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.713] List of 2
[17:59:25.713]  $ ...future.FUN:function (object, ...)  
[17:59:25.713]  $ ...          :List of 1
[17:59:25.713]   ..$ digits: int 2
[17:59:25.713]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.713]  - attr(*, "where")=List of 2
[17:59:25.713]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.713]   ..$ ...          :<environment: 0x62649f985c20> 
[17:59:25.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.713]  - attr(*, "resolved")= logi FALSE
[17:59:25.713]  - attr(*, "total_size")= num 1296
[17:59:25.724] Packages to be attached in all futures: [n=0] 
[17:59:25.724] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.724] Number of futures (= number of chunks): 1
[17:59:25.724] Launching 1 futures (chunks) ...
[17:59:25.725] Chunk #1 of 1 ...
[17:59:25.725]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.725] getGlobalsAndPackages() ...
[17:59:25.725] Searching for globals...
[17:59:25.726] 
[17:59:25.726] Searching for globals ... DONE
[17:59:25.727] - globals: [0] <none>
[17:59:25.727] getGlobalsAndPackages() ... DONE
[17:59:25.727]    + additional globals found: [n=0] 
[17:59:25.727]    + additional namespaces needed: [n=0] 
[17:59:25.727]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.728]  - seeds: <none>
[17:59:25.728]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.728] getGlobalsAndPackages() ...
[17:59:25.728] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.728] Resolving globals: FALSE
[17:59:25.729] Tweak future expression to call with '...' arguments ...
[17:59:25.729] {
[17:59:25.729]     do.call(function(...) {
[17:59:25.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.729]             on.exit(options(oopts), add = TRUE)
[17:59:25.729]         }
[17:59:25.729]         {
[17:59:25.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.729]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.729]             })
[17:59:25.729]         }
[17:59:25.729]     }, args = future.call.arguments)
[17:59:25.729] }
[17:59:25.730] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.730] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.731] 
[17:59:25.731] getGlobalsAndPackages() ... DONE
[17:59:25.732] run() for ‘Future’ ...
[17:59:25.732] - state: ‘created’
[17:59:25.732] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:25.733] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.733] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.733]   - Field: ‘label’
[17:59:25.733]   - Field: ‘local’
[17:59:25.734]   - Field: ‘owner’
[17:59:25.734]   - Field: ‘envir’
[17:59:25.734]   - Field: ‘packages’
[17:59:25.734]   - Field: ‘gc’
[17:59:25.734]   - Field: ‘conditions’
[17:59:25.735]   - Field: ‘expr’
[17:59:25.735]   - Field: ‘uuid’
[17:59:25.735]   - Field: ‘seed’
[17:59:25.735]   - Field: ‘version’
[17:59:25.735]   - Field: ‘result’
[17:59:25.736]   - Field: ‘asynchronous’
[17:59:25.736]   - Field: ‘calls’
[17:59:25.736]   - Field: ‘globals’
[17:59:25.736]   - Field: ‘stdout’
[17:59:25.736]   - Field: ‘earlySignal’
[17:59:25.737]   - Field: ‘lazy’
[17:59:25.737]   - Field: ‘state’
[17:59:25.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.737] - Launch lazy future ...
[17:59:25.738] Packages needed by the future expression (n = 0): <none>
[17:59:25.738] Packages needed by future strategies (n = 0): <none>
[17:59:25.739] {
[17:59:25.739]     {
[17:59:25.739]         {
[17:59:25.739]             ...future.startTime <- base::Sys.time()
[17:59:25.739]             {
[17:59:25.739]                 {
[17:59:25.739]                   {
[17:59:25.739]                     base::local({
[17:59:25.739]                       has_future <- base::requireNamespace("future", 
[17:59:25.739]                         quietly = TRUE)
[17:59:25.739]                       if (has_future) {
[17:59:25.739]                         ns <- base::getNamespace("future")
[17:59:25.739]                         version <- ns[[".package"]][["version"]]
[17:59:25.739]                         if (is.null(version)) 
[17:59:25.739]                           version <- utils::packageVersion("future")
[17:59:25.739]                       }
[17:59:25.739]                       else {
[17:59:25.739]                         version <- NULL
[17:59:25.739]                       }
[17:59:25.739]                       if (!has_future || version < "1.8.0") {
[17:59:25.739]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.739]                           "", base::R.version$version.string), 
[17:59:25.739]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:25.739]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.739]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.739]                             "release", "version")], collapse = " "), 
[17:59:25.739]                           hostname = base::Sys.info()[["nodename"]])
[17:59:25.739]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.739]                           info)
[17:59:25.739]                         info <- base::paste(info, collapse = "; ")
[17:59:25.739]                         if (!has_future) {
[17:59:25.739]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.739]                             info)
[17:59:25.739]                         }
[17:59:25.739]                         else {
[17:59:25.739]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.739]                             info, version)
[17:59:25.739]                         }
[17:59:25.739]                         base::stop(msg)
[17:59:25.739]                       }
[17:59:25.739]                     })
[17:59:25.739]                   }
[17:59:25.739]                   ...future.strategy.old <- future::plan("list")
[17:59:25.739]                   options(future.plan = NULL)
[17:59:25.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.739]                 }
[17:59:25.739]                 ...future.workdir <- getwd()
[17:59:25.739]             }
[17:59:25.739]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.739]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.739]         }
[17:59:25.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.739]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.739]             base::names(...future.oldOptions))
[17:59:25.739]     }
[17:59:25.739]     if (FALSE) {
[17:59:25.739]     }
[17:59:25.739]     else {
[17:59:25.739]         if (TRUE) {
[17:59:25.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.739]                 open = "w")
[17:59:25.739]         }
[17:59:25.739]         else {
[17:59:25.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.739]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.739]         }
[17:59:25.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.739]             base::sink(type = "output", split = FALSE)
[17:59:25.739]             base::close(...future.stdout)
[17:59:25.739]         }, add = TRUE)
[17:59:25.739]     }
[17:59:25.739]     ...future.frame <- base::sys.nframe()
[17:59:25.739]     ...future.conditions <- base::list()
[17:59:25.739]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.739]     if (FALSE) {
[17:59:25.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.739]     }
[17:59:25.739]     ...future.result <- base::tryCatch({
[17:59:25.739]         base::withCallingHandlers({
[17:59:25.739]             ...future.value <- base::withVisible(base::local({
[17:59:25.739]                 do.call(function(...) {
[17:59:25.739]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.739]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.739]                     ...future.globals.maxSize)) {
[17:59:25.739]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.739]                     on.exit(options(oopts), add = TRUE)
[17:59:25.739]                   }
[17:59:25.739]                   {
[17:59:25.739]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.739]                       FUN = function(jj) {
[17:59:25.739]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.739]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.739]                       })
[17:59:25.739]                   }
[17:59:25.739]                 }, args = future.call.arguments)
[17:59:25.739]             }))
[17:59:25.739]             future::FutureResult(value = ...future.value$value, 
[17:59:25.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.739]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.739]                     ...future.globalenv.names))
[17:59:25.739]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.739]         }, condition = base::local({
[17:59:25.739]             c <- base::c
[17:59:25.739]             inherits <- base::inherits
[17:59:25.739]             invokeRestart <- base::invokeRestart
[17:59:25.739]             length <- base::length
[17:59:25.739]             list <- base::list
[17:59:25.739]             seq.int <- base::seq.int
[17:59:25.739]             signalCondition <- base::signalCondition
[17:59:25.739]             sys.calls <- base::sys.calls
[17:59:25.739]             `[[` <- base::`[[`
[17:59:25.739]             `+` <- base::`+`
[17:59:25.739]             `<<-` <- base::`<<-`
[17:59:25.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.739]                   3L)]
[17:59:25.739]             }
[17:59:25.739]             function(cond) {
[17:59:25.739]                 is_error <- inherits(cond, "error")
[17:59:25.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.739]                   NULL)
[17:59:25.739]                 if (is_error) {
[17:59:25.739]                   sessionInformation <- function() {
[17:59:25.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.739]                       search = base::search(), system = base::Sys.info())
[17:59:25.739]                   }
[17:59:25.739]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.739]                     cond$call), session = sessionInformation(), 
[17:59:25.739]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.739]                   signalCondition(cond)
[17:59:25.739]                 }
[17:59:25.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.739]                 "immediateCondition"))) {
[17:59:25.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.739]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.739]                   if (TRUE && !signal) {
[17:59:25.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.739]                     {
[17:59:25.739]                       inherits <- base::inherits
[17:59:25.739]                       invokeRestart <- base::invokeRestart
[17:59:25.739]                       is.null <- base::is.null
[17:59:25.739]                       muffled <- FALSE
[17:59:25.739]                       if (inherits(cond, "message")) {
[17:59:25.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.739]                         if (muffled) 
[17:59:25.739]                           invokeRestart("muffleMessage")
[17:59:25.739]                       }
[17:59:25.739]                       else if (inherits(cond, "warning")) {
[17:59:25.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.739]                         if (muffled) 
[17:59:25.739]                           invokeRestart("muffleWarning")
[17:59:25.739]                       }
[17:59:25.739]                       else if (inherits(cond, "condition")) {
[17:59:25.739]                         if (!is.null(pattern)) {
[17:59:25.739]                           computeRestarts <- base::computeRestarts
[17:59:25.739]                           grepl <- base::grepl
[17:59:25.739]                           restarts <- computeRestarts(cond)
[17:59:25.739]                           for (restart in restarts) {
[17:59:25.739]                             name <- restart$name
[17:59:25.739]                             if (is.null(name)) 
[17:59:25.739]                               next
[17:59:25.739]                             if (!grepl(pattern, name)) 
[17:59:25.739]                               next
[17:59:25.739]                             invokeRestart(restart)
[17:59:25.739]                             muffled <- TRUE
[17:59:25.739]                             break
[17:59:25.739]                           }
[17:59:25.739]                         }
[17:59:25.739]                       }
[17:59:25.739]                       invisible(muffled)
[17:59:25.739]                     }
[17:59:25.739]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.739]                   }
[17:59:25.739]                 }
[17:59:25.739]                 else {
[17:59:25.739]                   if (TRUE) {
[17:59:25.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.739]                     {
[17:59:25.739]                       inherits <- base::inherits
[17:59:25.739]                       invokeRestart <- base::invokeRestart
[17:59:25.739]                       is.null <- base::is.null
[17:59:25.739]                       muffled <- FALSE
[17:59:25.739]                       if (inherits(cond, "message")) {
[17:59:25.739]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.739]                         if (muffled) 
[17:59:25.739]                           invokeRestart("muffleMessage")
[17:59:25.739]                       }
[17:59:25.739]                       else if (inherits(cond, "warning")) {
[17:59:25.739]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.739]                         if (muffled) 
[17:59:25.739]                           invokeRestart("muffleWarning")
[17:59:25.739]                       }
[17:59:25.739]                       else if (inherits(cond, "condition")) {
[17:59:25.739]                         if (!is.null(pattern)) {
[17:59:25.739]                           computeRestarts <- base::computeRestarts
[17:59:25.739]                           grepl <- base::grepl
[17:59:25.739]                           restarts <- computeRestarts(cond)
[17:59:25.739]                           for (restart in restarts) {
[17:59:25.739]                             name <- restart$name
[17:59:25.739]                             if (is.null(name)) 
[17:59:25.739]                               next
[17:59:25.739]                             if (!grepl(pattern, name)) 
[17:59:25.739]                               next
[17:59:25.739]                             invokeRestart(restart)
[17:59:25.739]                             muffled <- TRUE
[17:59:25.739]                             break
[17:59:25.739]                           }
[17:59:25.739]                         }
[17:59:25.739]                       }
[17:59:25.739]                       invisible(muffled)
[17:59:25.739]                     }
[17:59:25.739]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.739]                   }
[17:59:25.739]                 }
[17:59:25.739]             }
[17:59:25.739]         }))
[17:59:25.739]     }, error = function(ex) {
[17:59:25.739]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.739]                 ...future.rng), started = ...future.startTime, 
[17:59:25.739]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.739]             version = "1.8"), class = "FutureResult")
[17:59:25.739]     }, finally = {
[17:59:25.739]         if (!identical(...future.workdir, getwd())) 
[17:59:25.739]             setwd(...future.workdir)
[17:59:25.739]         {
[17:59:25.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.739]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.739]             }
[17:59:25.739]             base::options(...future.oldOptions)
[17:59:25.739]             if (.Platform$OS.type == "windows") {
[17:59:25.739]                 old_names <- names(...future.oldEnvVars)
[17:59:25.739]                 envs <- base::Sys.getenv()
[17:59:25.739]                 names <- names(envs)
[17:59:25.739]                 common <- intersect(names, old_names)
[17:59:25.739]                 added <- setdiff(names, old_names)
[17:59:25.739]                 removed <- setdiff(old_names, names)
[17:59:25.739]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.739]                   envs[common]]
[17:59:25.739]                 NAMES <- toupper(changed)
[17:59:25.739]                 args <- list()
[17:59:25.739]                 for (kk in seq_along(NAMES)) {
[17:59:25.739]                   name <- changed[[kk]]
[17:59:25.739]                   NAME <- NAMES[[kk]]
[17:59:25.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.739]                     next
[17:59:25.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.739]                 }
[17:59:25.739]                 NAMES <- toupper(added)
[17:59:25.739]                 for (kk in seq_along(NAMES)) {
[17:59:25.739]                   name <- added[[kk]]
[17:59:25.739]                   NAME <- NAMES[[kk]]
[17:59:25.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.739]                     next
[17:59:25.739]                   args[[name]] <- ""
[17:59:25.739]                 }
[17:59:25.739]                 NAMES <- toupper(removed)
[17:59:25.739]                 for (kk in seq_along(NAMES)) {
[17:59:25.739]                   name <- removed[[kk]]
[17:59:25.739]                   NAME <- NAMES[[kk]]
[17:59:25.739]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.739]                     next
[17:59:25.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.739]                 }
[17:59:25.739]                 if (length(args) > 0) 
[17:59:25.739]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.739]             }
[17:59:25.739]             else {
[17:59:25.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.739]             }
[17:59:25.739]             {
[17:59:25.739]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.739]                   0L) {
[17:59:25.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.739]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.739]                   base::options(opts)
[17:59:25.739]                 }
[17:59:25.739]                 {
[17:59:25.739]                   {
[17:59:25.739]                     NULL
[17:59:25.739]                     RNGkind("Mersenne-Twister")
[17:59:25.739]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.739]                       inherits = FALSE)
[17:59:25.739]                   }
[17:59:25.739]                   options(future.plan = NULL)
[17:59:25.739]                   if (is.na(NA_character_)) 
[17:59:25.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.739]                     .init = FALSE)
[17:59:25.739]                 }
[17:59:25.739]             }
[17:59:25.739]         }
[17:59:25.739]     })
[17:59:25.739]     if (TRUE) {
[17:59:25.739]         base::sink(type = "output", split = FALSE)
[17:59:25.739]         if (TRUE) {
[17:59:25.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.739]         }
[17:59:25.739]         else {
[17:59:25.739]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.739]         }
[17:59:25.739]         base::close(...future.stdout)
[17:59:25.739]         ...future.stdout <- NULL
[17:59:25.739]     }
[17:59:25.739]     ...future.result$conditions <- ...future.conditions
[17:59:25.739]     ...future.result$finished <- base::Sys.time()
[17:59:25.739]     ...future.result
[17:59:25.739] }
[17:59:25.742] assign_globals() ...
[17:59:25.743] List of 5
[17:59:25.743]  $ ...future.FUN            :function (object, ...)  
[17:59:25.743]  $ future.call.arguments    :List of 1
[17:59:25.743]   ..$ digits: int 2
[17:59:25.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.743]  $ ...future.elements_ii    :List of 6
[17:59:25.743]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:59:25.743]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:59:25.743]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:59:25.743]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:59:25.743]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:59:25.743]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:59:25.743]  $ ...future.seeds_ii       : NULL
[17:59:25.743]  $ ...future.globals.maxSize: NULL
[17:59:25.743]  - attr(*, "where")=List of 5
[17:59:25.743]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.743]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.743]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.743]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.743]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.743]  - attr(*, "resolved")= logi FALSE
[17:59:25.743]  - attr(*, "total_size")= num 1296
[17:59:25.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.743]  - attr(*, "already-done")= logi TRUE
[17:59:25.758] - copied ‘...future.FUN’ to environment
[17:59:25.758] - copied ‘future.call.arguments’ to environment
[17:59:25.758] - copied ‘...future.elements_ii’ to environment
[17:59:25.759] - copied ‘...future.seeds_ii’ to environment
[17:59:25.759] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.759] assign_globals() ... done
[17:59:25.760] plan(): Setting new future strategy stack:
[17:59:25.760] List of future strategies:
[17:59:25.760] 1. sequential:
[17:59:25.760]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.760]    - tweaked: FALSE
[17:59:25.760]    - call: NULL
[17:59:25.761] plan(): nbrOfWorkers() = 1
[17:59:25.764] plan(): Setting new future strategy stack:
[17:59:25.764] List of future strategies:
[17:59:25.764] 1. sequential:
[17:59:25.764]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.764]    - tweaked: FALSE
[17:59:25.764]    - call: plan(strategy)
[17:59:25.765] plan(): nbrOfWorkers() = 1
[17:59:25.766] SequentialFuture started (and completed)
[17:59:25.766] - Launch lazy future ... done
[17:59:25.766] run() for ‘SequentialFuture’ ... done
[17:59:25.766] Created future:
[17:59:25.767] SequentialFuture:
[17:59:25.767] Label: ‘future_by-1’
[17:59:25.767] Expression:
[17:59:25.767] {
[17:59:25.767]     do.call(function(...) {
[17:59:25.767]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.767]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.767]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.767]             on.exit(options(oopts), add = TRUE)
[17:59:25.767]         }
[17:59:25.767]         {
[17:59:25.767]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.767]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.767]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.767]             })
[17:59:25.767]         }
[17:59:25.767]     }, args = future.call.arguments)
[17:59:25.767] }
[17:59:25.767] Lazy evaluation: FALSE
[17:59:25.767] Asynchronous evaluation: FALSE
[17:59:25.767] Local evaluation: TRUE
[17:59:25.767] Environment: R_GlobalEnv
[17:59:25.767] Capture standard output: TRUE
[17:59:25.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.767] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.767] Packages: <none>
[17:59:25.767] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.767] Resolved: TRUE
[17:59:25.767] Value: 5.48 KiB of class ‘list’
[17:59:25.767] Early signaling: FALSE
[17:59:25.767] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.767] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.769] Chunk #1 of 1 ... DONE
[17:59:25.769] Launching 1 futures (chunks) ... DONE
[17:59:25.770] Resolving 1 futures (chunks) ...
[17:59:25.770] resolve() on list ...
[17:59:25.773]  recursive: 0
[17:59:25.773]  length: 1
[17:59:25.773] 
[17:59:25.773] resolved() for ‘SequentialFuture’ ...
[17:59:25.774] - state: ‘finished’
[17:59:25.774] - run: TRUE
[17:59:25.774] - result: ‘FutureResult’
[17:59:25.774] resolved() for ‘SequentialFuture’ ... done
[17:59:25.775] Future #1
[17:59:25.775] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.775] - nx: 1
[17:59:25.775] - relay: TRUE
[17:59:25.776] - stdout: TRUE
[17:59:25.776] - signal: TRUE
[17:59:25.776] - resignal: FALSE
[17:59:25.776] - force: TRUE
[17:59:25.776] - relayed: [n=1] FALSE
[17:59:25.777] - queued futures: [n=1] FALSE
[17:59:25.777]  - until=1
[17:59:25.777]  - relaying element #1
[17:59:25.778] - relayed: [n=1] TRUE
[17:59:25.778] - queued futures: [n=1] TRUE
[17:59:25.778] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.778]  length: 0 (resolved future 1)
[17:59:25.778] Relaying remaining futures
[17:59:25.779] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.779] - nx: 1
[17:59:25.779] - relay: TRUE
[17:59:25.779] - stdout: TRUE
[17:59:25.779] - signal: TRUE
[17:59:25.780] - resignal: FALSE
[17:59:25.780] - force: TRUE
[17:59:25.780] - relayed: [n=1] TRUE
[17:59:25.780] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.780] - relayed: [n=1] TRUE
[17:59:25.781] - queued futures: [n=1] TRUE
[17:59:25.781] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.781] resolve() on list ... DONE
[17:59:25.781]  - Number of value chunks collected: 1
[17:59:25.782] Resolving 1 futures (chunks) ... DONE
[17:59:25.782] Reducing values from 1 chunks ...
[17:59:25.782]  - Number of values collected after concatenation: 6
[17:59:25.782]  - Number of values expected: 6
[17:59:25.783] Reducing values from 1 chunks ... DONE
[17:59:25.783] future_lapply() ... DONE
[17:59:25.783] future_by_internal() ... DONE
[17:59:25.785] future_by_internal() ...
[17:59:25.786] future_lapply() ...
[17:59:25.788] Number of chunks: 1
[17:59:25.788] getGlobalsAndPackagesXApply() ...
[17:59:25.789]  - future.globals: TRUE
[17:59:25.789] getGlobalsAndPackages() ...
[17:59:25.789] Searching for globals...
[17:59:25.793] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:25.793] Searching for globals ... DONE
[17:59:25.793] Resolving globals: FALSE
[17:59:25.796] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:59:25.797] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:59:25.798] - globals: [1] ‘FUN’
[17:59:25.800] - packages: [1] ‘stats’
[17:59:25.800] getGlobalsAndPackages() ... DONE
[17:59:25.800]  - globals found/used: [n=1] ‘FUN’
[17:59:25.801]  - needed namespaces: [n=1] ‘stats’
[17:59:25.801] Finding globals ... DONE
[17:59:25.801]  - use_args: TRUE
[17:59:25.801]  - Getting '...' globals ...
[17:59:25.804] resolve() on list ...
[17:59:25.804]  recursive: 0
[17:59:25.805]  length: 1
[17:59:25.805]  elements: ‘...’
[17:59:25.805]  length: 0 (resolved future 1)
[17:59:25.805] resolve() on list ... DONE
[17:59:25.805]    - '...' content: [n=1] ‘singular.ok’
[17:59:25.806] List of 1
[17:59:25.806]  $ ...:List of 1
[17:59:25.806]   ..$ singular.ok: logi FALSE
[17:59:25.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.806]  - attr(*, "where")=List of 1
[17:59:25.806]   ..$ ...:<environment: 0x62649e683ac0> 
[17:59:25.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.806]  - attr(*, "resolved")= logi TRUE
[17:59:25.806]  - attr(*, "total_size")= num NA
[17:59:25.821]  - Getting '...' globals ... DONE
[17:59:25.822] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:25.824] List of 2
[17:59:25.824]  $ ...future.FUN:function (x, ...)  
[17:59:25.824]  $ ...          :List of 1
[17:59:25.824]   ..$ singular.ok: logi FALSE
[17:59:25.824]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.824]  - attr(*, "where")=List of 2
[17:59:25.824]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:25.824]   ..$ ...          :<environment: 0x62649e683ac0> 
[17:59:25.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.824]  - attr(*, "resolved")= logi FALSE
[17:59:25.824]  - attr(*, "total_size")= num 5384
[17:59:25.841] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:25.841] getGlobalsAndPackagesXApply() ... DONE
[17:59:25.841] Number of futures (= number of chunks): 1
[17:59:25.844] Launching 1 futures (chunks) ...
[17:59:25.844] Chunk #1 of 1 ...
[17:59:25.844]  - Finding globals in 'X' for chunk #1 ...
[17:59:25.845] getGlobalsAndPackages() ...
[17:59:25.845] Searching for globals...
[17:59:25.848] 
[17:59:25.848] Searching for globals ... DONE
[17:59:25.849] - globals: [0] <none>
[17:59:25.849] getGlobalsAndPackages() ... DONE
[17:59:25.849]    + additional globals found: [n=0] 
[17:59:25.849]    + additional namespaces needed: [n=0] 
[17:59:25.849]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:25.850]  - seeds: <none>
[17:59:25.852]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.857] getGlobalsAndPackages() ...
[17:59:25.857] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.857] Resolving globals: FALSE
[17:59:25.858] Tweak future expression to call with '...' arguments ...
[17:59:25.860] {
[17:59:25.860]     do.call(function(...) {
[17:59:25.860]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.860]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.860]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.860]             on.exit(options(oopts), add = TRUE)
[17:59:25.860]         }
[17:59:25.860]         {
[17:59:25.860]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.860]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.860]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.860]             })
[17:59:25.860]         }
[17:59:25.860]     }, args = future.call.arguments)
[17:59:25.860] }
[17:59:25.861] Tweak future expression to call with '...' arguments ... DONE
[17:59:25.861] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:25.864] 
[17:59:25.864] getGlobalsAndPackages() ... DONE
[17:59:25.865] run() for ‘Future’ ...
[17:59:25.865] - state: ‘created’
[17:59:25.865] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:25.868] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:25.869]   - Field: ‘label’
[17:59:25.869]   - Field: ‘local’
[17:59:25.870]   - Field: ‘owner’
[17:59:25.872]   - Field: ‘envir’
[17:59:25.872]   - Field: ‘packages’
[17:59:25.873]   - Field: ‘gc’
[17:59:25.873]   - Field: ‘conditions’
[17:59:25.873]   - Field: ‘expr’
[17:59:25.873]   - Field: ‘uuid’
[17:59:25.873]   - Field: ‘seed’
[17:59:25.874]   - Field: ‘version’
[17:59:25.876]   - Field: ‘result’
[17:59:25.876]   - Field: ‘asynchronous’
[17:59:25.877]   - Field: ‘calls’
[17:59:25.877]   - Field: ‘globals’
[17:59:25.877]   - Field: ‘stdout’
[17:59:25.877]   - Field: ‘earlySignal’
[17:59:25.877]   - Field: ‘lazy’
[17:59:25.878]   - Field: ‘state’
[17:59:25.880] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:25.880] - Launch lazy future ...
[17:59:25.881] Packages needed by the future expression (n = 1): ‘stats’
[17:59:25.881] Packages needed by future strategies (n = 0): <none>
[17:59:25.884] {
[17:59:25.884]     {
[17:59:25.884]         {
[17:59:25.884]             ...future.startTime <- base::Sys.time()
[17:59:25.884]             {
[17:59:25.884]                 {
[17:59:25.884]                   {
[17:59:25.884]                     {
[17:59:25.884]                       base::local({
[17:59:25.884]                         has_future <- base::requireNamespace("future", 
[17:59:25.884]                           quietly = TRUE)
[17:59:25.884]                         if (has_future) {
[17:59:25.884]                           ns <- base::getNamespace("future")
[17:59:25.884]                           version <- ns[[".package"]][["version"]]
[17:59:25.884]                           if (is.null(version)) 
[17:59:25.884]                             version <- utils::packageVersion("future")
[17:59:25.884]                         }
[17:59:25.884]                         else {
[17:59:25.884]                           version <- NULL
[17:59:25.884]                         }
[17:59:25.884]                         if (!has_future || version < "1.8.0") {
[17:59:25.884]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:25.884]                             "", base::R.version$version.string), 
[17:59:25.884]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:25.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:25.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:25.884]                               "release", "version")], collapse = " "), 
[17:59:25.884]                             hostname = base::Sys.info()[["nodename"]])
[17:59:25.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:25.884]                             info)
[17:59:25.884]                           info <- base::paste(info, collapse = "; ")
[17:59:25.884]                           if (!has_future) {
[17:59:25.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:25.884]                               info)
[17:59:25.884]                           }
[17:59:25.884]                           else {
[17:59:25.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:25.884]                               info, version)
[17:59:25.884]                           }
[17:59:25.884]                           base::stop(msg)
[17:59:25.884]                         }
[17:59:25.884]                       })
[17:59:25.884]                     }
[17:59:25.884]                     base::local({
[17:59:25.884]                       for (pkg in "stats") {
[17:59:25.884]                         base::loadNamespace(pkg)
[17:59:25.884]                         base::library(pkg, character.only = TRUE)
[17:59:25.884]                       }
[17:59:25.884]                     })
[17:59:25.884]                   }
[17:59:25.884]                   ...future.strategy.old <- future::plan("list")
[17:59:25.884]                   options(future.plan = NULL)
[17:59:25.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:25.884]                 }
[17:59:25.884]                 ...future.workdir <- getwd()
[17:59:25.884]             }
[17:59:25.884]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:25.884]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:25.884]         }
[17:59:25.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:25.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:25.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:25.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:25.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:25.884]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:25.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:25.884]             base::names(...future.oldOptions))
[17:59:25.884]     }
[17:59:25.884]     if (FALSE) {
[17:59:25.884]     }
[17:59:25.884]     else {
[17:59:25.884]         if (TRUE) {
[17:59:25.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:25.884]                 open = "w")
[17:59:25.884]         }
[17:59:25.884]         else {
[17:59:25.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:25.884]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:25.884]         }
[17:59:25.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:25.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:25.884]             base::sink(type = "output", split = FALSE)
[17:59:25.884]             base::close(...future.stdout)
[17:59:25.884]         }, add = TRUE)
[17:59:25.884]     }
[17:59:25.884]     ...future.frame <- base::sys.nframe()
[17:59:25.884]     ...future.conditions <- base::list()
[17:59:25.884]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:25.884]     if (FALSE) {
[17:59:25.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:25.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:25.884]     }
[17:59:25.884]     ...future.result <- base::tryCatch({
[17:59:25.884]         base::withCallingHandlers({
[17:59:25.884]             ...future.value <- base::withVisible(base::local({
[17:59:25.884]                 do.call(function(...) {
[17:59:25.884]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.884]                   if (!identical(...future.globals.maxSize.org, 
[17:59:25.884]                     ...future.globals.maxSize)) {
[17:59:25.884]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.884]                     on.exit(options(oopts), add = TRUE)
[17:59:25.884]                   }
[17:59:25.884]                   {
[17:59:25.884]                     lapply(seq_along(...future.elements_ii), 
[17:59:25.884]                       FUN = function(jj) {
[17:59:25.884]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.884]                         ...future.FUN(...future.X_jj, ...)
[17:59:25.884]                       })
[17:59:25.884]                   }
[17:59:25.884]                 }, args = future.call.arguments)
[17:59:25.884]             }))
[17:59:25.884]             future::FutureResult(value = ...future.value$value, 
[17:59:25.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.884]                   ...future.rng), globalenv = if (FALSE) 
[17:59:25.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:25.884]                     ...future.globalenv.names))
[17:59:25.884]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:25.884]         }, condition = base::local({
[17:59:25.884]             c <- base::c
[17:59:25.884]             inherits <- base::inherits
[17:59:25.884]             invokeRestart <- base::invokeRestart
[17:59:25.884]             length <- base::length
[17:59:25.884]             list <- base::list
[17:59:25.884]             seq.int <- base::seq.int
[17:59:25.884]             signalCondition <- base::signalCondition
[17:59:25.884]             sys.calls <- base::sys.calls
[17:59:25.884]             `[[` <- base::`[[`
[17:59:25.884]             `+` <- base::`+`
[17:59:25.884]             `<<-` <- base::`<<-`
[17:59:25.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:25.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:25.884]                   3L)]
[17:59:25.884]             }
[17:59:25.884]             function(cond) {
[17:59:25.884]                 is_error <- inherits(cond, "error")
[17:59:25.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:25.884]                   NULL)
[17:59:25.884]                 if (is_error) {
[17:59:25.884]                   sessionInformation <- function() {
[17:59:25.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:25.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:25.884]                       search = base::search(), system = base::Sys.info())
[17:59:25.884]                   }
[17:59:25.884]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:25.884]                     cond$call), session = sessionInformation(), 
[17:59:25.884]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:25.884]                   signalCondition(cond)
[17:59:25.884]                 }
[17:59:25.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:25.884]                 "immediateCondition"))) {
[17:59:25.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:25.884]                   ...future.conditions[[length(...future.conditions) + 
[17:59:25.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:25.884]                   if (TRUE && !signal) {
[17:59:25.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.884]                     {
[17:59:25.884]                       inherits <- base::inherits
[17:59:25.884]                       invokeRestart <- base::invokeRestart
[17:59:25.884]                       is.null <- base::is.null
[17:59:25.884]                       muffled <- FALSE
[17:59:25.884]                       if (inherits(cond, "message")) {
[17:59:25.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.884]                         if (muffled) 
[17:59:25.884]                           invokeRestart("muffleMessage")
[17:59:25.884]                       }
[17:59:25.884]                       else if (inherits(cond, "warning")) {
[17:59:25.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.884]                         if (muffled) 
[17:59:25.884]                           invokeRestart("muffleWarning")
[17:59:25.884]                       }
[17:59:25.884]                       else if (inherits(cond, "condition")) {
[17:59:25.884]                         if (!is.null(pattern)) {
[17:59:25.884]                           computeRestarts <- base::computeRestarts
[17:59:25.884]                           grepl <- base::grepl
[17:59:25.884]                           restarts <- computeRestarts(cond)
[17:59:25.884]                           for (restart in restarts) {
[17:59:25.884]                             name <- restart$name
[17:59:25.884]                             if (is.null(name)) 
[17:59:25.884]                               next
[17:59:25.884]                             if (!grepl(pattern, name)) 
[17:59:25.884]                               next
[17:59:25.884]                             invokeRestart(restart)
[17:59:25.884]                             muffled <- TRUE
[17:59:25.884]                             break
[17:59:25.884]                           }
[17:59:25.884]                         }
[17:59:25.884]                       }
[17:59:25.884]                       invisible(muffled)
[17:59:25.884]                     }
[17:59:25.884]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.884]                   }
[17:59:25.884]                 }
[17:59:25.884]                 else {
[17:59:25.884]                   if (TRUE) {
[17:59:25.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:25.884]                     {
[17:59:25.884]                       inherits <- base::inherits
[17:59:25.884]                       invokeRestart <- base::invokeRestart
[17:59:25.884]                       is.null <- base::is.null
[17:59:25.884]                       muffled <- FALSE
[17:59:25.884]                       if (inherits(cond, "message")) {
[17:59:25.884]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:25.884]                         if (muffled) 
[17:59:25.884]                           invokeRestart("muffleMessage")
[17:59:25.884]                       }
[17:59:25.884]                       else if (inherits(cond, "warning")) {
[17:59:25.884]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:25.884]                         if (muffled) 
[17:59:25.884]                           invokeRestart("muffleWarning")
[17:59:25.884]                       }
[17:59:25.884]                       else if (inherits(cond, "condition")) {
[17:59:25.884]                         if (!is.null(pattern)) {
[17:59:25.884]                           computeRestarts <- base::computeRestarts
[17:59:25.884]                           grepl <- base::grepl
[17:59:25.884]                           restarts <- computeRestarts(cond)
[17:59:25.884]                           for (restart in restarts) {
[17:59:25.884]                             name <- restart$name
[17:59:25.884]                             if (is.null(name)) 
[17:59:25.884]                               next
[17:59:25.884]                             if (!grepl(pattern, name)) 
[17:59:25.884]                               next
[17:59:25.884]                             invokeRestart(restart)
[17:59:25.884]                             muffled <- TRUE
[17:59:25.884]                             break
[17:59:25.884]                           }
[17:59:25.884]                         }
[17:59:25.884]                       }
[17:59:25.884]                       invisible(muffled)
[17:59:25.884]                     }
[17:59:25.884]                     muffleCondition(cond, pattern = "^muffle")
[17:59:25.884]                   }
[17:59:25.884]                 }
[17:59:25.884]             }
[17:59:25.884]         }))
[17:59:25.884]     }, error = function(ex) {
[17:59:25.884]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:25.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:25.884]                 ...future.rng), started = ...future.startTime, 
[17:59:25.884]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:25.884]             version = "1.8"), class = "FutureResult")
[17:59:25.884]     }, finally = {
[17:59:25.884]         if (!identical(...future.workdir, getwd())) 
[17:59:25.884]             setwd(...future.workdir)
[17:59:25.884]         {
[17:59:25.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:25.884]                 ...future.oldOptions$nwarnings <- NULL
[17:59:25.884]             }
[17:59:25.884]             base::options(...future.oldOptions)
[17:59:25.884]             if (.Platform$OS.type == "windows") {
[17:59:25.884]                 old_names <- names(...future.oldEnvVars)
[17:59:25.884]                 envs <- base::Sys.getenv()
[17:59:25.884]                 names <- names(envs)
[17:59:25.884]                 common <- intersect(names, old_names)
[17:59:25.884]                 added <- setdiff(names, old_names)
[17:59:25.884]                 removed <- setdiff(old_names, names)
[17:59:25.884]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:25.884]                   envs[common]]
[17:59:25.884]                 NAMES <- toupper(changed)
[17:59:25.884]                 args <- list()
[17:59:25.884]                 for (kk in seq_along(NAMES)) {
[17:59:25.884]                   name <- changed[[kk]]
[17:59:25.884]                   NAME <- NAMES[[kk]]
[17:59:25.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.884]                     next
[17:59:25.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.884]                 }
[17:59:25.884]                 NAMES <- toupper(added)
[17:59:25.884]                 for (kk in seq_along(NAMES)) {
[17:59:25.884]                   name <- added[[kk]]
[17:59:25.884]                   NAME <- NAMES[[kk]]
[17:59:25.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.884]                     next
[17:59:25.884]                   args[[name]] <- ""
[17:59:25.884]                 }
[17:59:25.884]                 NAMES <- toupper(removed)
[17:59:25.884]                 for (kk in seq_along(NAMES)) {
[17:59:25.884]                   name <- removed[[kk]]
[17:59:25.884]                   NAME <- NAMES[[kk]]
[17:59:25.884]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:25.884]                     next
[17:59:25.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:25.884]                 }
[17:59:25.884]                 if (length(args) > 0) 
[17:59:25.884]                   base::do.call(base::Sys.setenv, args = args)
[17:59:25.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:25.884]             }
[17:59:25.884]             else {
[17:59:25.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:25.884]             }
[17:59:25.884]             {
[17:59:25.884]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:25.884]                   0L) {
[17:59:25.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:25.884]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:25.884]                   base::options(opts)
[17:59:25.884]                 }
[17:59:25.884]                 {
[17:59:25.884]                   {
[17:59:25.884]                     NULL
[17:59:25.884]                     RNGkind("Mersenne-Twister")
[17:59:25.884]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:25.884]                       inherits = FALSE)
[17:59:25.884]                   }
[17:59:25.884]                   options(future.plan = NULL)
[17:59:25.884]                   if (is.na(NA_character_)) 
[17:59:25.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:25.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:25.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:25.884]                     .init = FALSE)
[17:59:25.884]                 }
[17:59:25.884]             }
[17:59:25.884]         }
[17:59:25.884]     })
[17:59:25.884]     if (TRUE) {
[17:59:25.884]         base::sink(type = "output", split = FALSE)
[17:59:25.884]         if (TRUE) {
[17:59:25.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:25.884]         }
[17:59:25.884]         else {
[17:59:25.884]             ...future.result["stdout"] <- base::list(NULL)
[17:59:25.884]         }
[17:59:25.884]         base::close(...future.stdout)
[17:59:25.884]         ...future.stdout <- NULL
[17:59:25.884]     }
[17:59:25.884]     ...future.result$conditions <- ...future.conditions
[17:59:25.884]     ...future.result$finished <- base::Sys.time()
[17:59:25.884]     ...future.result
[17:59:25.884] }
[17:59:25.892] assign_globals() ...
[17:59:25.892] List of 5
[17:59:25.892]  $ ...future.FUN            :function (x, ...)  
[17:59:25.892]  $ future.call.arguments    :List of 1
[17:59:25.892]   ..$ singular.ok: logi FALSE
[17:59:25.892]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:25.892]  $ ...future.elements_ii    :List of 3
[17:59:25.892]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.892]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:25.892]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.892]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:25.892]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.892]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:25.892]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.892]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:25.892]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:25.892]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:25.892]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:25.892]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:25.892]  $ ...future.seeds_ii       : NULL
[17:59:25.892]  $ ...future.globals.maxSize: NULL
[17:59:25.892]  - attr(*, "where")=List of 5
[17:59:25.892]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:25.892]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:25.892]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:25.892]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:25.892]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:25.892]  - attr(*, "resolved")= logi FALSE
[17:59:25.892]  - attr(*, "total_size")= num 5384
[17:59:25.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:25.892]  - attr(*, "already-done")= logi TRUE
[17:59:25.927] - reassign environment for ‘...future.FUN’
[17:59:25.927] - copied ‘...future.FUN’ to environment
[17:59:25.927] - copied ‘future.call.arguments’ to environment
[17:59:25.927] - copied ‘...future.elements_ii’ to environment
[17:59:25.927] - copied ‘...future.seeds_ii’ to environment
[17:59:25.928] - copied ‘...future.globals.maxSize’ to environment
[17:59:25.928] assign_globals() ... done
[17:59:25.929] plan(): Setting new future strategy stack:
[17:59:25.929] List of future strategies:
[17:59:25.929] 1. sequential:
[17:59:25.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.929]    - tweaked: FALSE
[17:59:25.929]    - call: NULL
[17:59:25.930] plan(): nbrOfWorkers() = 1
[17:59:25.941] plan(): Setting new future strategy stack:
[17:59:25.943] List of future strategies:
[17:59:25.943] 1. sequential:
[17:59:25.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:25.943]    - tweaked: FALSE
[17:59:25.943]    - call: plan(strategy)
[17:59:25.944] plan(): nbrOfWorkers() = 1
[17:59:25.945] SequentialFuture started (and completed)
[17:59:25.947] - Launch lazy future ... done
[17:59:25.947] run() for ‘SequentialFuture’ ... done
[17:59:25.948] Created future:
[17:59:25.948] SequentialFuture:
[17:59:25.948] Label: ‘future_by-1’
[17:59:25.948] Expression:
[17:59:25.948] {
[17:59:25.948]     do.call(function(...) {
[17:59:25.948]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:25.948]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:25.948]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:25.948]             on.exit(options(oopts), add = TRUE)
[17:59:25.948]         }
[17:59:25.948]         {
[17:59:25.948]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:25.948]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:25.948]                 ...future.FUN(...future.X_jj, ...)
[17:59:25.948]             })
[17:59:25.948]         }
[17:59:25.948]     }, args = future.call.arguments)
[17:59:25.948] }
[17:59:25.948] Lazy evaluation: FALSE
[17:59:25.948] Asynchronous evaluation: FALSE
[17:59:25.948] Local evaluation: TRUE
[17:59:25.948] Environment: R_GlobalEnv
[17:59:25.948] Capture standard output: TRUE
[17:59:25.948] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:25.948] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:25.948] Packages: 1 packages (‘stats’)
[17:59:25.948] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:25.948] Resolved: TRUE
[17:59:25.948] Value: 26.06 KiB of class ‘list’
[17:59:25.948] Early signaling: FALSE
[17:59:25.948] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:25.948] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:25.961] Chunk #1 of 1 ... DONE
[17:59:25.962] Launching 1 futures (chunks) ... DONE
[17:59:25.962] Resolving 1 futures (chunks) ...
[17:59:25.962] resolve() on list ...
[17:59:25.962]  recursive: 0
[17:59:25.963]  length: 1
[17:59:25.963] 
[17:59:25.963] resolved() for ‘SequentialFuture’ ...
[17:59:25.963] - state: ‘finished’
[17:59:25.964] - run: TRUE
[17:59:25.968] - result: ‘FutureResult’
[17:59:25.968] resolved() for ‘SequentialFuture’ ... done
[17:59:25.968] Future #1
[17:59:25.969] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:25.969] - nx: 1
[17:59:25.969] - relay: TRUE
[17:59:25.969] - stdout: TRUE
[17:59:25.970] - signal: TRUE
[17:59:25.972] - resignal: FALSE
[17:59:25.972] - force: TRUE
[17:59:25.972] - relayed: [n=1] FALSE
[17:59:25.973] - queued futures: [n=1] FALSE
[17:59:25.973]  - until=1
[17:59:25.973]  - relaying element #1
[17:59:25.974] - relayed: [n=1] TRUE
[17:59:25.975] - queued futures: [n=1] TRUE
[17:59:25.976] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:25.976]  length: 0 (resolved future 1)
[17:59:25.976] Relaying remaining futures
[17:59:25.977] signalConditionsASAP(NULL, pos=0) ...
[17:59:25.978] - nx: 1
[17:59:25.978] - relay: TRUE
[17:59:25.979] - stdout: TRUE
[17:59:25.979] - signal: TRUE
[17:59:25.979] - resignal: FALSE
[17:59:25.979] - force: TRUE
[17:59:25.982] - relayed: [n=1] TRUE
[17:59:25.982] - queued futures: [n=1] TRUE
 - flush all
[17:59:25.983] - relayed: [n=1] TRUE
[17:59:25.983] - queued futures: [n=1] TRUE
[17:59:25.983] signalConditionsASAP(NULL, pos=0) ... done
[17:59:25.984] resolve() on list ... DONE
[17:59:25.984]  - Number of value chunks collected: 1
[17:59:25.984] Resolving 1 futures (chunks) ... DONE
[17:59:25.984] Reducing values from 1 chunks ...
[17:59:25.984]  - Number of values collected after concatenation: 3
[17:59:25.985]  - Number of values expected: 3
[17:59:25.985] Reducing values from 1 chunks ... DONE
[17:59:25.985] future_lapply() ... DONE
[17:59:25.985] future_by_internal() ... DONE
[17:59:25.996] future_by_internal() ...
[17:59:25.997] future_lapply() ...
[17:59:25.998] Number of chunks: 1
[17:59:25.998] getGlobalsAndPackagesXApply() ...
[17:59:25.999]  - future.globals: TRUE
[17:59:25.999] getGlobalsAndPackages() ...
[17:59:25.999] Searching for globals...
[17:59:26.002] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:26.003] Searching for globals ... DONE
[17:59:26.003] Resolving globals: FALSE
[17:59:26.004] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:59:26.005] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:59:26.005] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:26.005] - packages: [1] ‘stats’
[17:59:26.005] getGlobalsAndPackages() ... DONE
[17:59:26.006]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:26.006]  - needed namespaces: [n=1] ‘stats’
[17:59:26.006] Finding globals ... DONE
[17:59:26.006]  - use_args: TRUE
[17:59:26.006]  - Getting '...' globals ...
[17:59:26.007] resolve() on list ...
[17:59:26.007]  recursive: 0
[17:59:26.007]  length: 1
[17:59:26.008]  elements: ‘...’
[17:59:26.008]  length: 0 (resolved future 1)
[17:59:26.008] resolve() on list ... DONE
[17:59:26.008]    - '...' content: [n=0] 
[17:59:26.009] List of 1
[17:59:26.009]  $ ...: list()
[17:59:26.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.009]  - attr(*, "where")=List of 1
[17:59:26.009]   ..$ ...:<environment: 0x62649f810c08> 
[17:59:26.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.009]  - attr(*, "resolved")= logi TRUE
[17:59:26.009]  - attr(*, "total_size")= num NA
[17:59:26.014]  - Getting '...' globals ... DONE
[17:59:26.014] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:59:26.016] List of 4
[17:59:26.016]  $ ...future.FUN:function (x)  
[17:59:26.016]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:26.016]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:26.016]  $ ...          : list()
[17:59:26.016]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.016]  - attr(*, "where")=List of 4
[17:59:26.016]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:26.016]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:59:26.016]   ..$ wool         :<environment: R_EmptyEnv> 
[17:59:26.016]   ..$ ...          :<environment: 0x62649f810c08> 
[17:59:26.016]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.016]  - attr(*, "resolved")= logi FALSE
[17:59:26.016]  - attr(*, "total_size")= num 2320
[17:59:26.025] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:26.025] getGlobalsAndPackagesXApply() ... DONE
[17:59:26.026] Number of futures (= number of chunks): 1
[17:59:26.026] Launching 1 futures (chunks) ...
[17:59:26.026] Chunk #1 of 1 ...
[17:59:26.026]  - Finding globals in 'X' for chunk #1 ...
[17:59:26.027] getGlobalsAndPackages() ...
[17:59:26.027] Searching for globals...
[17:59:26.028] 
[17:59:26.028] Searching for globals ... DONE
[17:59:26.028] - globals: [0] <none>
[17:59:26.028] getGlobalsAndPackages() ... DONE
[17:59:26.028]    + additional globals found: [n=0] 
[17:59:26.029]    + additional namespaces needed: [n=0] 
[17:59:26.029]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:26.029]  - seeds: <none>
[17:59:26.029]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.029] getGlobalsAndPackages() ...
[17:59:26.030] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.030] Resolving globals: FALSE
[17:59:26.030] Tweak future expression to call with '...' arguments ...
[17:59:26.030] {
[17:59:26.030]     do.call(function(...) {
[17:59:26.030]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.030]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.030]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.030]             on.exit(options(oopts), add = TRUE)
[17:59:26.030]         }
[17:59:26.030]         {
[17:59:26.030]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.030]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.030]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.030]             })
[17:59:26.030]         }
[17:59:26.030]     }, args = future.call.arguments)
[17:59:26.030] }
[17:59:26.031] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.032] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.032] 
[17:59:26.032] getGlobalsAndPackages() ... DONE
[17:59:26.033] run() for ‘Future’ ...
[17:59:26.033] - state: ‘created’
[17:59:26.033] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:26.034] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:26.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:26.034]   - Field: ‘label’
[17:59:26.034]   - Field: ‘local’
[17:59:26.035]   - Field: ‘owner’
[17:59:26.035]   - Field: ‘envir’
[17:59:26.035]   - Field: ‘packages’
[17:59:26.035]   - Field: ‘gc’
[17:59:26.035]   - Field: ‘conditions’
[17:59:26.036]   - Field: ‘expr’
[17:59:26.036]   - Field: ‘uuid’
[17:59:26.036]   - Field: ‘seed’
[17:59:26.036]   - Field: ‘version’
[17:59:26.036]   - Field: ‘result’
[17:59:26.036]   - Field: ‘asynchronous’
[17:59:26.037]   - Field: ‘calls’
[17:59:26.037]   - Field: ‘globals’
[17:59:26.037]   - Field: ‘stdout’
[17:59:26.037]   - Field: ‘earlySignal’
[17:59:26.037]   - Field: ‘lazy’
[17:59:26.038]   - Field: ‘state’
[17:59:26.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:26.038] - Launch lazy future ...
[17:59:26.038] Packages needed by the future expression (n = 1): ‘stats’
[17:59:26.039] Packages needed by future strategies (n = 0): <none>
[17:59:26.040] {
[17:59:26.040]     {
[17:59:26.040]         {
[17:59:26.040]             ...future.startTime <- base::Sys.time()
[17:59:26.040]             {
[17:59:26.040]                 {
[17:59:26.040]                   {
[17:59:26.040]                     {
[17:59:26.040]                       base::local({
[17:59:26.040]                         has_future <- base::requireNamespace("future", 
[17:59:26.040]                           quietly = TRUE)
[17:59:26.040]                         if (has_future) {
[17:59:26.040]                           ns <- base::getNamespace("future")
[17:59:26.040]                           version <- ns[[".package"]][["version"]]
[17:59:26.040]                           if (is.null(version)) 
[17:59:26.040]                             version <- utils::packageVersion("future")
[17:59:26.040]                         }
[17:59:26.040]                         else {
[17:59:26.040]                           version <- NULL
[17:59:26.040]                         }
[17:59:26.040]                         if (!has_future || version < "1.8.0") {
[17:59:26.040]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.040]                             "", base::R.version$version.string), 
[17:59:26.040]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:26.040]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.040]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.040]                               "release", "version")], collapse = " "), 
[17:59:26.040]                             hostname = base::Sys.info()[["nodename"]])
[17:59:26.040]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.040]                             info)
[17:59:26.040]                           info <- base::paste(info, collapse = "; ")
[17:59:26.040]                           if (!has_future) {
[17:59:26.040]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.040]                               info)
[17:59:26.040]                           }
[17:59:26.040]                           else {
[17:59:26.040]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.040]                               info, version)
[17:59:26.040]                           }
[17:59:26.040]                           base::stop(msg)
[17:59:26.040]                         }
[17:59:26.040]                       })
[17:59:26.040]                     }
[17:59:26.040]                     base::local({
[17:59:26.040]                       for (pkg in "stats") {
[17:59:26.040]                         base::loadNamespace(pkg)
[17:59:26.040]                         base::library(pkg, character.only = TRUE)
[17:59:26.040]                       }
[17:59:26.040]                     })
[17:59:26.040]                   }
[17:59:26.040]                   ...future.strategy.old <- future::plan("list")
[17:59:26.040]                   options(future.plan = NULL)
[17:59:26.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.040]                 }
[17:59:26.040]                 ...future.workdir <- getwd()
[17:59:26.040]             }
[17:59:26.040]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.040]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.040]         }
[17:59:26.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:26.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.040]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.040]             base::names(...future.oldOptions))
[17:59:26.040]     }
[17:59:26.040]     if (FALSE) {
[17:59:26.040]     }
[17:59:26.040]     else {
[17:59:26.040]         if (TRUE) {
[17:59:26.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.040]                 open = "w")
[17:59:26.040]         }
[17:59:26.040]         else {
[17:59:26.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.040]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.040]         }
[17:59:26.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.040]             base::sink(type = "output", split = FALSE)
[17:59:26.040]             base::close(...future.stdout)
[17:59:26.040]         }, add = TRUE)
[17:59:26.040]     }
[17:59:26.040]     ...future.frame <- base::sys.nframe()
[17:59:26.040]     ...future.conditions <- base::list()
[17:59:26.040]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.040]     if (FALSE) {
[17:59:26.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.040]     }
[17:59:26.040]     ...future.result <- base::tryCatch({
[17:59:26.040]         base::withCallingHandlers({
[17:59:26.040]             ...future.value <- base::withVisible(base::local({
[17:59:26.040]                 do.call(function(...) {
[17:59:26.040]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.040]                   if (!identical(...future.globals.maxSize.org, 
[17:59:26.040]                     ...future.globals.maxSize)) {
[17:59:26.040]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.040]                     on.exit(options(oopts), add = TRUE)
[17:59:26.040]                   }
[17:59:26.040]                   {
[17:59:26.040]                     lapply(seq_along(...future.elements_ii), 
[17:59:26.040]                       FUN = function(jj) {
[17:59:26.040]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.040]                         ...future.FUN(...future.X_jj, ...)
[17:59:26.040]                       })
[17:59:26.040]                   }
[17:59:26.040]                 }, args = future.call.arguments)
[17:59:26.040]             }))
[17:59:26.040]             future::FutureResult(value = ...future.value$value, 
[17:59:26.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.040]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.040]                     ...future.globalenv.names))
[17:59:26.040]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.040]         }, condition = base::local({
[17:59:26.040]             c <- base::c
[17:59:26.040]             inherits <- base::inherits
[17:59:26.040]             invokeRestart <- base::invokeRestart
[17:59:26.040]             length <- base::length
[17:59:26.040]             list <- base::list
[17:59:26.040]             seq.int <- base::seq.int
[17:59:26.040]             signalCondition <- base::signalCondition
[17:59:26.040]             sys.calls <- base::sys.calls
[17:59:26.040]             `[[` <- base::`[[`
[17:59:26.040]             `+` <- base::`+`
[17:59:26.040]             `<<-` <- base::`<<-`
[17:59:26.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.040]                   3L)]
[17:59:26.040]             }
[17:59:26.040]             function(cond) {
[17:59:26.040]                 is_error <- inherits(cond, "error")
[17:59:26.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.040]                   NULL)
[17:59:26.040]                 if (is_error) {
[17:59:26.040]                   sessionInformation <- function() {
[17:59:26.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.040]                       search = base::search(), system = base::Sys.info())
[17:59:26.040]                   }
[17:59:26.040]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.040]                     cond$call), session = sessionInformation(), 
[17:59:26.040]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.040]                   signalCondition(cond)
[17:59:26.040]                 }
[17:59:26.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.040]                 "immediateCondition"))) {
[17:59:26.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.040]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.040]                   if (TRUE && !signal) {
[17:59:26.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.040]                     {
[17:59:26.040]                       inherits <- base::inherits
[17:59:26.040]                       invokeRestart <- base::invokeRestart
[17:59:26.040]                       is.null <- base::is.null
[17:59:26.040]                       muffled <- FALSE
[17:59:26.040]                       if (inherits(cond, "message")) {
[17:59:26.040]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.040]                         if (muffled) 
[17:59:26.040]                           invokeRestart("muffleMessage")
[17:59:26.040]                       }
[17:59:26.040]                       else if (inherits(cond, "warning")) {
[17:59:26.040]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.040]                         if (muffled) 
[17:59:26.040]                           invokeRestart("muffleWarning")
[17:59:26.040]                       }
[17:59:26.040]                       else if (inherits(cond, "condition")) {
[17:59:26.040]                         if (!is.null(pattern)) {
[17:59:26.040]                           computeRestarts <- base::computeRestarts
[17:59:26.040]                           grepl <- base::grepl
[17:59:26.040]                           restarts <- computeRestarts(cond)
[17:59:26.040]                           for (restart in restarts) {
[17:59:26.040]                             name <- restart$name
[17:59:26.040]                             if (is.null(name)) 
[17:59:26.040]                               next
[17:59:26.040]                             if (!grepl(pattern, name)) 
[17:59:26.040]                               next
[17:59:26.040]                             invokeRestart(restart)
[17:59:26.040]                             muffled <- TRUE
[17:59:26.040]                             break
[17:59:26.040]                           }
[17:59:26.040]                         }
[17:59:26.040]                       }
[17:59:26.040]                       invisible(muffled)
[17:59:26.040]                     }
[17:59:26.040]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.040]                   }
[17:59:26.040]                 }
[17:59:26.040]                 else {
[17:59:26.040]                   if (TRUE) {
[17:59:26.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.040]                     {
[17:59:26.040]                       inherits <- base::inherits
[17:59:26.040]                       invokeRestart <- base::invokeRestart
[17:59:26.040]                       is.null <- base::is.null
[17:59:26.040]                       muffled <- FALSE
[17:59:26.040]                       if (inherits(cond, "message")) {
[17:59:26.040]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.040]                         if (muffled) 
[17:59:26.040]                           invokeRestart("muffleMessage")
[17:59:26.040]                       }
[17:59:26.040]                       else if (inherits(cond, "warning")) {
[17:59:26.040]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.040]                         if (muffled) 
[17:59:26.040]                           invokeRestart("muffleWarning")
[17:59:26.040]                       }
[17:59:26.040]                       else if (inherits(cond, "condition")) {
[17:59:26.040]                         if (!is.null(pattern)) {
[17:59:26.040]                           computeRestarts <- base::computeRestarts
[17:59:26.040]                           grepl <- base::grepl
[17:59:26.040]                           restarts <- computeRestarts(cond)
[17:59:26.040]                           for (restart in restarts) {
[17:59:26.040]                             name <- restart$name
[17:59:26.040]                             if (is.null(name)) 
[17:59:26.040]                               next
[17:59:26.040]                             if (!grepl(pattern, name)) 
[17:59:26.040]                               next
[17:59:26.040]                             invokeRestart(restart)
[17:59:26.040]                             muffled <- TRUE
[17:59:26.040]                             break
[17:59:26.040]                           }
[17:59:26.040]                         }
[17:59:26.040]                       }
[17:59:26.040]                       invisible(muffled)
[17:59:26.040]                     }
[17:59:26.040]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.040]                   }
[17:59:26.040]                 }
[17:59:26.040]             }
[17:59:26.040]         }))
[17:59:26.040]     }, error = function(ex) {
[17:59:26.040]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.040]                 ...future.rng), started = ...future.startTime, 
[17:59:26.040]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.040]             version = "1.8"), class = "FutureResult")
[17:59:26.040]     }, finally = {
[17:59:26.040]         if (!identical(...future.workdir, getwd())) 
[17:59:26.040]             setwd(...future.workdir)
[17:59:26.040]         {
[17:59:26.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.040]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.040]             }
[17:59:26.040]             base::options(...future.oldOptions)
[17:59:26.040]             if (.Platform$OS.type == "windows") {
[17:59:26.040]                 old_names <- names(...future.oldEnvVars)
[17:59:26.040]                 envs <- base::Sys.getenv()
[17:59:26.040]                 names <- names(envs)
[17:59:26.040]                 common <- intersect(names, old_names)
[17:59:26.040]                 added <- setdiff(names, old_names)
[17:59:26.040]                 removed <- setdiff(old_names, names)
[17:59:26.040]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.040]                   envs[common]]
[17:59:26.040]                 NAMES <- toupper(changed)
[17:59:26.040]                 args <- list()
[17:59:26.040]                 for (kk in seq_along(NAMES)) {
[17:59:26.040]                   name <- changed[[kk]]
[17:59:26.040]                   NAME <- NAMES[[kk]]
[17:59:26.040]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.040]                     next
[17:59:26.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.040]                 }
[17:59:26.040]                 NAMES <- toupper(added)
[17:59:26.040]                 for (kk in seq_along(NAMES)) {
[17:59:26.040]                   name <- added[[kk]]
[17:59:26.040]                   NAME <- NAMES[[kk]]
[17:59:26.040]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.040]                     next
[17:59:26.040]                   args[[name]] <- ""
[17:59:26.040]                 }
[17:59:26.040]                 NAMES <- toupper(removed)
[17:59:26.040]                 for (kk in seq_along(NAMES)) {
[17:59:26.040]                   name <- removed[[kk]]
[17:59:26.040]                   NAME <- NAMES[[kk]]
[17:59:26.040]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.040]                     next
[17:59:26.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.040]                 }
[17:59:26.040]                 if (length(args) > 0) 
[17:59:26.040]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.040]             }
[17:59:26.040]             else {
[17:59:26.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.040]             }
[17:59:26.040]             {
[17:59:26.040]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.040]                   0L) {
[17:59:26.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.040]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.040]                   base::options(opts)
[17:59:26.040]                 }
[17:59:26.040]                 {
[17:59:26.040]                   {
[17:59:26.040]                     NULL
[17:59:26.040]                     RNGkind("Mersenne-Twister")
[17:59:26.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:26.040]                       inherits = FALSE)
[17:59:26.040]                   }
[17:59:26.040]                   options(future.plan = NULL)
[17:59:26.040]                   if (is.na(NA_character_)) 
[17:59:26.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.040]                     .init = FALSE)
[17:59:26.040]                 }
[17:59:26.040]             }
[17:59:26.040]         }
[17:59:26.040]     })
[17:59:26.040]     if (TRUE) {
[17:59:26.040]         base::sink(type = "output", split = FALSE)
[17:59:26.040]         if (TRUE) {
[17:59:26.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.040]         }
[17:59:26.040]         else {
[17:59:26.040]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.040]         }
[17:59:26.040]         base::close(...future.stdout)
[17:59:26.040]         ...future.stdout <- NULL
[17:59:26.040]     }
[17:59:26.040]     ...future.result$conditions <- ...future.conditions
[17:59:26.040]     ...future.result$finished <- base::Sys.time()
[17:59:26.040]     ...future.result
[17:59:26.040] }
[17:59:26.044] assign_globals() ...
[17:59:26.044] List of 7
[17:59:26.044]  $ ...future.FUN            :function (x)  
[17:59:26.044]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:26.044]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:26.044]  $ future.call.arguments    : list()
[17:59:26.044]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.044]  $ ...future.elements_ii    :List of 3
[17:59:26.044]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.044]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:26.044]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.044]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:26.044]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.044]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:26.044]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.044]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:26.044]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.044]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:26.044]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.044]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:26.044]  $ ...future.seeds_ii       : NULL
[17:59:26.044]  $ ...future.globals.maxSize: NULL
[17:59:26.044]  - attr(*, "where")=List of 7
[17:59:26.044]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.044]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:59:26.044]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:59:26.044]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.044]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.044]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.044]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.044]  - attr(*, "resolved")= logi FALSE
[17:59:26.044]  - attr(*, "total_size")= num 2320
[17:59:26.044]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.044]  - attr(*, "already-done")= logi TRUE
[17:59:26.066] - reassign environment for ‘...future.FUN’
[17:59:26.067] - copied ‘...future.FUN’ to environment
[17:59:26.067] - copied ‘breaks’ to environment
[17:59:26.067] - copied ‘wool’ to environment
[17:59:26.067] - copied ‘future.call.arguments’ to environment
[17:59:26.068] - copied ‘...future.elements_ii’ to environment
[17:59:26.068] - copied ‘...future.seeds_ii’ to environment
[17:59:26.068] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.068] assign_globals() ... done
[17:59:26.069] plan(): Setting new future strategy stack:
[17:59:26.069] List of future strategies:
[17:59:26.069] 1. sequential:
[17:59:26.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.069]    - tweaked: FALSE
[17:59:26.069]    - call: NULL
[17:59:26.070] plan(): nbrOfWorkers() = 1
[17:59:26.076] plan(): Setting new future strategy stack:
[17:59:26.076] List of future strategies:
[17:59:26.076] 1. sequential:
[17:59:26.076]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.076]    - tweaked: FALSE
[17:59:26.076]    - call: plan(strategy)
[17:59:26.077] plan(): nbrOfWorkers() = 1
[17:59:26.077] SequentialFuture started (and completed)
[17:59:26.077] - Launch lazy future ... done
[17:59:26.078] run() for ‘SequentialFuture’ ... done
[17:59:26.078] Created future:
[17:59:26.078] SequentialFuture:
[17:59:26.078] Label: ‘future_by-1’
[17:59:26.078] Expression:
[17:59:26.078] {
[17:59:26.078]     do.call(function(...) {
[17:59:26.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.078]             on.exit(options(oopts), add = TRUE)
[17:59:26.078]         }
[17:59:26.078]         {
[17:59:26.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.078]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.078]             })
[17:59:26.078]         }
[17:59:26.078]     }, args = future.call.arguments)
[17:59:26.078] }
[17:59:26.078] Lazy evaluation: FALSE
[17:59:26.078] Asynchronous evaluation: FALSE
[17:59:26.078] Local evaluation: TRUE
[17:59:26.078] Environment: 0x62649f520bf8
[17:59:26.078] Capture standard output: TRUE
[17:59:26.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.078] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[17:59:26.078] Packages: 1 packages (‘stats’)
[17:59:26.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.078] Resolved: TRUE
[17:59:26.078] Value: 25.57 KiB of class ‘list’
[17:59:26.078] Early signaling: FALSE
[17:59:26.078] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.078] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:26.081] Chunk #1 of 1 ... DONE
[17:59:26.082] Launching 1 futures (chunks) ... DONE
[17:59:26.082] Resolving 1 futures (chunks) ...
[17:59:26.082] resolve() on list ...
[17:59:26.082]  recursive: 0
[17:59:26.082]  length: 1
[17:59:26.083] 
[17:59:26.083] resolved() for ‘SequentialFuture’ ...
[17:59:26.083] - state: ‘finished’
[17:59:26.083] - run: TRUE
[17:59:26.083] - result: ‘FutureResult’
[17:59:26.084] resolved() for ‘SequentialFuture’ ... done
[17:59:26.084] Future #1
[17:59:26.084] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:26.084] - nx: 1
[17:59:26.084] - relay: TRUE
[17:59:26.085] - stdout: TRUE
[17:59:26.085] - signal: TRUE
[17:59:26.085] - resignal: FALSE
[17:59:26.085] - force: TRUE
[17:59:26.085] - relayed: [n=1] FALSE
[17:59:26.085] - queued futures: [n=1] FALSE
[17:59:26.086]  - until=1
[17:59:26.086]  - relaying element #1
[17:59:26.086] - relayed: [n=1] TRUE
[17:59:26.086] - queued futures: [n=1] TRUE
[17:59:26.087] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:26.087]  length: 0 (resolved future 1)
[17:59:26.087] Relaying remaining futures
[17:59:26.087] signalConditionsASAP(NULL, pos=0) ...
[17:59:26.087] - nx: 1
[17:59:26.088] - relay: TRUE
[17:59:26.088] - stdout: TRUE
[17:59:26.088] - signal: TRUE
[17:59:26.088] - resignal: FALSE
[17:59:26.088] - force: TRUE
[17:59:26.088] - relayed: [n=1] TRUE
[17:59:26.089] - queued futures: [n=1] TRUE
 - flush all
[17:59:26.089] - relayed: [n=1] TRUE
[17:59:26.089] - queued futures: [n=1] TRUE
[17:59:26.089] signalConditionsASAP(NULL, pos=0) ... done
[17:59:26.089] resolve() on list ... DONE
[17:59:26.090]  - Number of value chunks collected: 1
[17:59:26.090] Resolving 1 futures (chunks) ... DONE
[17:59:26.090] Reducing values from 1 chunks ...
[17:59:26.090]  - Number of values collected after concatenation: 3
[17:59:26.091]  - Number of values expected: 3
[17:59:26.091] Reducing values from 1 chunks ... DONE
[17:59:26.091] future_lapply() ... DONE
[17:59:26.091] future_by_internal() ... DONE
[17:59:26.092] future_by_internal() ...
[17:59:26.093] future_lapply() ...
[17:59:26.094] Number of chunks: 1
[17:59:26.095] getGlobalsAndPackagesXApply() ...
[17:59:26.095]  - future.globals: TRUE
[17:59:26.095] getGlobalsAndPackages() ...
[17:59:26.095] Searching for globals...
[17:59:26.097] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:26.097] Searching for globals ... DONE
[17:59:26.098] Resolving globals: FALSE
[17:59:26.098] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:26.099] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:26.099] - globals: [1] ‘FUN’
[17:59:26.099] 
[17:59:26.100] getGlobalsAndPackages() ... DONE
[17:59:26.100]  - globals found/used: [n=1] ‘FUN’
[17:59:26.100]  - needed namespaces: [n=0] 
[17:59:26.100] Finding globals ... DONE
[17:59:26.100]  - use_args: TRUE
[17:59:26.101]  - Getting '...' globals ...
[17:59:26.101] resolve() on list ...
[17:59:26.101]  recursive: 0
[17:59:26.102]  length: 1
[17:59:26.102]  elements: ‘...’
[17:59:26.102]  length: 0 (resolved future 1)
[17:59:26.102] resolve() on list ... DONE
[17:59:26.102]    - '...' content: [n=0] 
[17:59:26.103] List of 1
[17:59:26.103]  $ ...: list()
[17:59:26.103]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.103]  - attr(*, "where")=List of 1
[17:59:26.103]   ..$ ...:<environment: 0x62649fbc6110> 
[17:59:26.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.103]  - attr(*, "resolved")= logi TRUE
[17:59:26.103]  - attr(*, "total_size")= num NA
[17:59:26.110]  - Getting '...' globals ... DONE
[17:59:26.111] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:26.111] List of 2
[17:59:26.111]  $ ...future.FUN:function (object, ...)  
[17:59:26.111]  $ ...          : list()
[17:59:26.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.111]  - attr(*, "where")=List of 2
[17:59:26.111]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:26.111]   ..$ ...          :<environment: 0x62649fbc6110> 
[17:59:26.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.111]  - attr(*, "resolved")= logi FALSE
[17:59:26.111]  - attr(*, "total_size")= num 1240
[17:59:26.119] Packages to be attached in all futures: [n=0] 
[17:59:26.119] getGlobalsAndPackagesXApply() ... DONE
[17:59:26.120] Number of futures (= number of chunks): 1
[17:59:26.120] Launching 1 futures (chunks) ...
[17:59:26.120] Chunk #1 of 1 ...
[17:59:26.120]  - Finding globals in 'X' for chunk #1 ...
[17:59:26.121] getGlobalsAndPackages() ...
[17:59:26.121] Searching for globals...
[17:59:26.122] 
[17:59:26.122] Searching for globals ... DONE
[17:59:26.123] - globals: [0] <none>
[17:59:26.123] getGlobalsAndPackages() ... DONE
[17:59:26.123]    + additional globals found: [n=0] 
[17:59:26.123]    + additional namespaces needed: [n=0] 
[17:59:26.124]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:26.124]  - seeds: <none>
[17:59:26.124]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.124] getGlobalsAndPackages() ...
[17:59:26.124] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.125] Resolving globals: FALSE
[17:59:26.125] Tweak future expression to call with '...' arguments ...
[17:59:26.125] {
[17:59:26.125]     do.call(function(...) {
[17:59:26.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.125]             on.exit(options(oopts), add = TRUE)
[17:59:26.125]         }
[17:59:26.125]         {
[17:59:26.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.125]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.125]             })
[17:59:26.125]         }
[17:59:26.125]     }, args = future.call.arguments)
[17:59:26.125] }
[17:59:26.126] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.127] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.127] 
[17:59:26.127] getGlobalsAndPackages() ... DONE
[17:59:26.130] run() for ‘Future’ ...
[17:59:26.130] - state: ‘created’
[17:59:26.130] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:26.131] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:26.131] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:26.132]   - Field: ‘label’
[17:59:26.132]   - Field: ‘local’
[17:59:26.133]   - Field: ‘owner’
[17:59:26.133]   - Field: ‘envir’
[17:59:26.133]   - Field: ‘packages’
[17:59:26.133]   - Field: ‘gc’
[17:59:26.133]   - Field: ‘conditions’
[17:59:26.134]   - Field: ‘expr’
[17:59:26.134]   - Field: ‘uuid’
[17:59:26.134]   - Field: ‘seed’
[17:59:26.134]   - Field: ‘version’
[17:59:26.134]   - Field: ‘result’
[17:59:26.135]   - Field: ‘asynchronous’
[17:59:26.135]   - Field: ‘calls’
[17:59:26.135]   - Field: ‘globals’
[17:59:26.136]   - Field: ‘stdout’
[17:59:26.136]   - Field: ‘earlySignal’
[17:59:26.136]   - Field: ‘lazy’
[17:59:26.137]   - Field: ‘state’
[17:59:26.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:26.137] - Launch lazy future ...
[17:59:26.137] Packages needed by the future expression (n = 0): <none>
[17:59:26.138] Packages needed by future strategies (n = 0): <none>
[17:59:26.138] {
[17:59:26.138]     {
[17:59:26.138]         {
[17:59:26.138]             ...future.startTime <- base::Sys.time()
[17:59:26.138]             {
[17:59:26.138]                 {
[17:59:26.138]                   {
[17:59:26.138]                     base::local({
[17:59:26.138]                       has_future <- base::requireNamespace("future", 
[17:59:26.138]                         quietly = TRUE)
[17:59:26.138]                       if (has_future) {
[17:59:26.138]                         ns <- base::getNamespace("future")
[17:59:26.138]                         version <- ns[[".package"]][["version"]]
[17:59:26.138]                         if (is.null(version)) 
[17:59:26.138]                           version <- utils::packageVersion("future")
[17:59:26.138]                       }
[17:59:26.138]                       else {
[17:59:26.138]                         version <- NULL
[17:59:26.138]                       }
[17:59:26.138]                       if (!has_future || version < "1.8.0") {
[17:59:26.138]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.138]                           "", base::R.version$version.string), 
[17:59:26.138]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:26.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.138]                             "release", "version")], collapse = " "), 
[17:59:26.138]                           hostname = base::Sys.info()[["nodename"]])
[17:59:26.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.138]                           info)
[17:59:26.138]                         info <- base::paste(info, collapse = "; ")
[17:59:26.138]                         if (!has_future) {
[17:59:26.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.138]                             info)
[17:59:26.138]                         }
[17:59:26.138]                         else {
[17:59:26.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.138]                             info, version)
[17:59:26.138]                         }
[17:59:26.138]                         base::stop(msg)
[17:59:26.138]                       }
[17:59:26.138]                     })
[17:59:26.138]                   }
[17:59:26.138]                   ...future.strategy.old <- future::plan("list")
[17:59:26.138]                   options(future.plan = NULL)
[17:59:26.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.138]                 }
[17:59:26.138]                 ...future.workdir <- getwd()
[17:59:26.138]             }
[17:59:26.138]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.138]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.138]         }
[17:59:26.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:26.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.138]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.138]             base::names(...future.oldOptions))
[17:59:26.138]     }
[17:59:26.138]     if (FALSE) {
[17:59:26.138]     }
[17:59:26.138]     else {
[17:59:26.138]         if (TRUE) {
[17:59:26.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.138]                 open = "w")
[17:59:26.138]         }
[17:59:26.138]         else {
[17:59:26.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.138]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.138]         }
[17:59:26.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.138]             base::sink(type = "output", split = FALSE)
[17:59:26.138]             base::close(...future.stdout)
[17:59:26.138]         }, add = TRUE)
[17:59:26.138]     }
[17:59:26.138]     ...future.frame <- base::sys.nframe()
[17:59:26.138]     ...future.conditions <- base::list()
[17:59:26.138]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.138]     if (FALSE) {
[17:59:26.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.138]     }
[17:59:26.138]     ...future.result <- base::tryCatch({
[17:59:26.138]         base::withCallingHandlers({
[17:59:26.138]             ...future.value <- base::withVisible(base::local({
[17:59:26.138]                 do.call(function(...) {
[17:59:26.138]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.138]                   if (!identical(...future.globals.maxSize.org, 
[17:59:26.138]                     ...future.globals.maxSize)) {
[17:59:26.138]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.138]                     on.exit(options(oopts), add = TRUE)
[17:59:26.138]                   }
[17:59:26.138]                   {
[17:59:26.138]                     lapply(seq_along(...future.elements_ii), 
[17:59:26.138]                       FUN = function(jj) {
[17:59:26.138]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.138]                         ...future.FUN(...future.X_jj, ...)
[17:59:26.138]                       })
[17:59:26.138]                   }
[17:59:26.138]                 }, args = future.call.arguments)
[17:59:26.138]             }))
[17:59:26.138]             future::FutureResult(value = ...future.value$value, 
[17:59:26.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.138]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.138]                     ...future.globalenv.names))
[17:59:26.138]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.138]         }, condition = base::local({
[17:59:26.138]             c <- base::c
[17:59:26.138]             inherits <- base::inherits
[17:59:26.138]             invokeRestart <- base::invokeRestart
[17:59:26.138]             length <- base::length
[17:59:26.138]             list <- base::list
[17:59:26.138]             seq.int <- base::seq.int
[17:59:26.138]             signalCondition <- base::signalCondition
[17:59:26.138]             sys.calls <- base::sys.calls
[17:59:26.138]             `[[` <- base::`[[`
[17:59:26.138]             `+` <- base::`+`
[17:59:26.138]             `<<-` <- base::`<<-`
[17:59:26.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.138]                   3L)]
[17:59:26.138]             }
[17:59:26.138]             function(cond) {
[17:59:26.138]                 is_error <- inherits(cond, "error")
[17:59:26.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.138]                   NULL)
[17:59:26.138]                 if (is_error) {
[17:59:26.138]                   sessionInformation <- function() {
[17:59:26.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.138]                       search = base::search(), system = base::Sys.info())
[17:59:26.138]                   }
[17:59:26.138]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.138]                     cond$call), session = sessionInformation(), 
[17:59:26.138]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.138]                   signalCondition(cond)
[17:59:26.138]                 }
[17:59:26.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.138]                 "immediateCondition"))) {
[17:59:26.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.138]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.138]                   if (TRUE && !signal) {
[17:59:26.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.138]                     {
[17:59:26.138]                       inherits <- base::inherits
[17:59:26.138]                       invokeRestart <- base::invokeRestart
[17:59:26.138]                       is.null <- base::is.null
[17:59:26.138]                       muffled <- FALSE
[17:59:26.138]                       if (inherits(cond, "message")) {
[17:59:26.138]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.138]                         if (muffled) 
[17:59:26.138]                           invokeRestart("muffleMessage")
[17:59:26.138]                       }
[17:59:26.138]                       else if (inherits(cond, "warning")) {
[17:59:26.138]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.138]                         if (muffled) 
[17:59:26.138]                           invokeRestart("muffleWarning")
[17:59:26.138]                       }
[17:59:26.138]                       else if (inherits(cond, "condition")) {
[17:59:26.138]                         if (!is.null(pattern)) {
[17:59:26.138]                           computeRestarts <- base::computeRestarts
[17:59:26.138]                           grepl <- base::grepl
[17:59:26.138]                           restarts <- computeRestarts(cond)
[17:59:26.138]                           for (restart in restarts) {
[17:59:26.138]                             name <- restart$name
[17:59:26.138]                             if (is.null(name)) 
[17:59:26.138]                               next
[17:59:26.138]                             if (!grepl(pattern, name)) 
[17:59:26.138]                               next
[17:59:26.138]                             invokeRestart(restart)
[17:59:26.138]                             muffled <- TRUE
[17:59:26.138]                             break
[17:59:26.138]                           }
[17:59:26.138]                         }
[17:59:26.138]                       }
[17:59:26.138]                       invisible(muffled)
[17:59:26.138]                     }
[17:59:26.138]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.138]                   }
[17:59:26.138]                 }
[17:59:26.138]                 else {
[17:59:26.138]                   if (TRUE) {
[17:59:26.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.138]                     {
[17:59:26.138]                       inherits <- base::inherits
[17:59:26.138]                       invokeRestart <- base::invokeRestart
[17:59:26.138]                       is.null <- base::is.null
[17:59:26.138]                       muffled <- FALSE
[17:59:26.138]                       if (inherits(cond, "message")) {
[17:59:26.138]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.138]                         if (muffled) 
[17:59:26.138]                           invokeRestart("muffleMessage")
[17:59:26.138]                       }
[17:59:26.138]                       else if (inherits(cond, "warning")) {
[17:59:26.138]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.138]                         if (muffled) 
[17:59:26.138]                           invokeRestart("muffleWarning")
[17:59:26.138]                       }
[17:59:26.138]                       else if (inherits(cond, "condition")) {
[17:59:26.138]                         if (!is.null(pattern)) {
[17:59:26.138]                           computeRestarts <- base::computeRestarts
[17:59:26.138]                           grepl <- base::grepl
[17:59:26.138]                           restarts <- computeRestarts(cond)
[17:59:26.138]                           for (restart in restarts) {
[17:59:26.138]                             name <- restart$name
[17:59:26.138]                             if (is.null(name)) 
[17:59:26.138]                               next
[17:59:26.138]                             if (!grepl(pattern, name)) 
[17:59:26.138]                               next
[17:59:26.138]                             invokeRestart(restart)
[17:59:26.138]                             muffled <- TRUE
[17:59:26.138]                             break
[17:59:26.138]                           }
[17:59:26.138]                         }
[17:59:26.138]                       }
[17:59:26.138]                       invisible(muffled)
[17:59:26.138]                     }
[17:59:26.138]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.138]                   }
[17:59:26.138]                 }
[17:59:26.138]             }
[17:59:26.138]         }))
[17:59:26.138]     }, error = function(ex) {
[17:59:26.138]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.138]                 ...future.rng), started = ...future.startTime, 
[17:59:26.138]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.138]             version = "1.8"), class = "FutureResult")
[17:59:26.138]     }, finally = {
[17:59:26.138]         if (!identical(...future.workdir, getwd())) 
[17:59:26.138]             setwd(...future.workdir)
[17:59:26.138]         {
[17:59:26.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.138]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.138]             }
[17:59:26.138]             base::options(...future.oldOptions)
[17:59:26.138]             if (.Platform$OS.type == "windows") {
[17:59:26.138]                 old_names <- names(...future.oldEnvVars)
[17:59:26.138]                 envs <- base::Sys.getenv()
[17:59:26.138]                 names <- names(envs)
[17:59:26.138]                 common <- intersect(names, old_names)
[17:59:26.138]                 added <- setdiff(names, old_names)
[17:59:26.138]                 removed <- setdiff(old_names, names)
[17:59:26.138]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.138]                   envs[common]]
[17:59:26.138]                 NAMES <- toupper(changed)
[17:59:26.138]                 args <- list()
[17:59:26.138]                 for (kk in seq_along(NAMES)) {
[17:59:26.138]                   name <- changed[[kk]]
[17:59:26.138]                   NAME <- NAMES[[kk]]
[17:59:26.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.138]                     next
[17:59:26.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.138]                 }
[17:59:26.138]                 NAMES <- toupper(added)
[17:59:26.138]                 for (kk in seq_along(NAMES)) {
[17:59:26.138]                   name <- added[[kk]]
[17:59:26.138]                   NAME <- NAMES[[kk]]
[17:59:26.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.138]                     next
[17:59:26.138]                   args[[name]] <- ""
[17:59:26.138]                 }
[17:59:26.138]                 NAMES <- toupper(removed)
[17:59:26.138]                 for (kk in seq_along(NAMES)) {
[17:59:26.138]                   name <- removed[[kk]]
[17:59:26.138]                   NAME <- NAMES[[kk]]
[17:59:26.138]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.138]                     next
[17:59:26.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.138]                 }
[17:59:26.138]                 if (length(args) > 0) 
[17:59:26.138]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.138]             }
[17:59:26.138]             else {
[17:59:26.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.138]             }
[17:59:26.138]             {
[17:59:26.138]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.138]                   0L) {
[17:59:26.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.138]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.138]                   base::options(opts)
[17:59:26.138]                 }
[17:59:26.138]                 {
[17:59:26.138]                   {
[17:59:26.138]                     NULL
[17:59:26.138]                     RNGkind("Mersenne-Twister")
[17:59:26.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:26.138]                       inherits = FALSE)
[17:59:26.138]                   }
[17:59:26.138]                   options(future.plan = NULL)
[17:59:26.138]                   if (is.na(NA_character_)) 
[17:59:26.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.138]                     .init = FALSE)
[17:59:26.138]                 }
[17:59:26.138]             }
[17:59:26.138]         }
[17:59:26.138]     })
[17:59:26.138]     if (TRUE) {
[17:59:26.138]         base::sink(type = "output", split = FALSE)
[17:59:26.138]         if (TRUE) {
[17:59:26.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.138]         }
[17:59:26.138]         else {
[17:59:26.138]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.138]         }
[17:59:26.138]         base::close(...future.stdout)
[17:59:26.138]         ...future.stdout <- NULL
[17:59:26.138]     }
[17:59:26.138]     ...future.result$conditions <- ...future.conditions
[17:59:26.138]     ...future.result$finished <- base::Sys.time()
[17:59:26.138]     ...future.result
[17:59:26.138] }
[17:59:26.143] assign_globals() ...
[17:59:26.143] List of 5
[17:59:26.143]  $ ...future.FUN            :function (object, ...)  
[17:59:26.143]  $ future.call.arguments    : list()
[17:59:26.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.143]  $ ...future.elements_ii    :List of 3
[17:59:26.143]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.143]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:26.143]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.143]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:26.143]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.143]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:26.143]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.143]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:26.143]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.143]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:26.143]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.143]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:26.143]  $ ...future.seeds_ii       : NULL
[17:59:26.143]  $ ...future.globals.maxSize: NULL
[17:59:26.143]  - attr(*, "where")=List of 5
[17:59:26.143]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.143]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.143]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.143]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.143]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.143]  - attr(*, "resolved")= logi FALSE
[17:59:26.143]  - attr(*, "total_size")= num 1240
[17:59:26.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.143]  - attr(*, "already-done")= logi TRUE
[17:59:26.169] - copied ‘...future.FUN’ to environment
[17:59:26.169] - copied ‘future.call.arguments’ to environment
[17:59:26.169] - copied ‘...future.elements_ii’ to environment
[17:59:26.169] - copied ‘...future.seeds_ii’ to environment
[17:59:26.170] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.170] assign_globals() ... done
[17:59:26.171] plan(): Setting new future strategy stack:
[17:59:26.171] List of future strategies:
[17:59:26.171] 1. sequential:
[17:59:26.171]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.171]    - tweaked: FALSE
[17:59:26.171]    - call: NULL
[17:59:26.172] plan(): nbrOfWorkers() = 1
[17:59:26.178] plan(): Setting new future strategy stack:
[17:59:26.178] List of future strategies:
[17:59:26.178] 1. sequential:
[17:59:26.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.178]    - tweaked: FALSE
[17:59:26.178]    - call: plan(strategy)
[17:59:26.180] plan(): nbrOfWorkers() = 1
[17:59:26.180] SequentialFuture started (and completed)
[17:59:26.181] - Launch lazy future ... done
[17:59:26.181] run() for ‘SequentialFuture’ ... done
[17:59:26.181] Created future:
[17:59:26.181] SequentialFuture:
[17:59:26.181] Label: ‘future_by-1’
[17:59:26.181] Expression:
[17:59:26.181] {
[17:59:26.181]     do.call(function(...) {
[17:59:26.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.181]             on.exit(options(oopts), add = TRUE)
[17:59:26.181]         }
[17:59:26.181]         {
[17:59:26.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.181]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.181]             })
[17:59:26.181]         }
[17:59:26.181]     }, args = future.call.arguments)
[17:59:26.181] }
[17:59:26.181] Lazy evaluation: FALSE
[17:59:26.181] Asynchronous evaluation: FALSE
[17:59:26.181] Local evaluation: TRUE
[17:59:26.181] Environment: 0x62649fb84070
[17:59:26.181] Capture standard output: TRUE
[17:59:26.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.181] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.181] Packages: <none>
[17:59:26.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.181] Resolved: TRUE
[17:59:26.181] Value: 5.37 KiB of class ‘list’
[17:59:26.181] Early signaling: FALSE
[17:59:26.181] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.181] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:26.184] Chunk #1 of 1 ... DONE
[17:59:26.184] Launching 1 futures (chunks) ... DONE
[17:59:26.185] Resolving 1 futures (chunks) ...
[17:59:26.185] resolve() on list ...
[17:59:26.185]  recursive: 0
[17:59:26.185]  length: 1
[17:59:26.186] 
[17:59:26.186] resolved() for ‘SequentialFuture’ ...
[17:59:26.186] - state: ‘finished’
[17:59:26.186] - run: TRUE
[17:59:26.187] - result: ‘FutureResult’
[17:59:26.187] resolved() for ‘SequentialFuture’ ... done
[17:59:26.187] Future #1
[17:59:26.187] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:26.187] - nx: 1
[17:59:26.188] - relay: TRUE
[17:59:26.188] - stdout: TRUE
[17:59:26.188] - signal: TRUE
[17:59:26.188] - resignal: FALSE
[17:59:26.188] - force: TRUE
[17:59:26.189] - relayed: [n=1] FALSE
[17:59:26.189] - queued futures: [n=1] FALSE
[17:59:26.189]  - until=1
[17:59:26.189]  - relaying element #1
[17:59:26.190] - relayed: [n=1] TRUE
[17:59:26.190] - queued futures: [n=1] TRUE
[17:59:26.190] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:26.190]  length: 0 (resolved future 1)
[17:59:26.190] Relaying remaining futures
[17:59:26.191] signalConditionsASAP(NULL, pos=0) ...
[17:59:26.191] - nx: 1
[17:59:26.191] - relay: TRUE
[17:59:26.191] - stdout: TRUE
[17:59:26.191] - signal: TRUE
[17:59:26.192] - resignal: FALSE
[17:59:26.192] - force: TRUE
[17:59:26.192] - relayed: [n=1] TRUE
[17:59:26.192] - queued futures: [n=1] TRUE
 - flush all
[17:59:26.192] - relayed: [n=1] TRUE
[17:59:26.193] - queued futures: [n=1] TRUE
[17:59:26.193] signalConditionsASAP(NULL, pos=0) ... done
[17:59:26.193] resolve() on list ... DONE
[17:59:26.193]  - Number of value chunks collected: 1
[17:59:26.194] Resolving 1 futures (chunks) ... DONE
[17:59:26.194] Reducing values from 1 chunks ...
[17:59:26.194]  - Number of values collected after concatenation: 3
[17:59:26.194]  - Number of values expected: 3
[17:59:26.194] Reducing values from 1 chunks ... DONE
[17:59:26.195] future_lapply() ... DONE
[17:59:26.195] future_by_internal() ... DONE
[17:59:26.197] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:59:26.198] future_lapply() ...
[17:59:26.199] Number of chunks: 1
[17:59:26.199] getGlobalsAndPackagesXApply() ...
[17:59:26.199]  - future.globals: TRUE
[17:59:26.200] getGlobalsAndPackages() ...
[17:59:26.200] Searching for globals...
[17:59:26.202] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:26.203] Searching for globals ... DONE
[17:59:26.203] Resolving globals: FALSE
[17:59:26.204] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:26.204] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:26.205] - globals: [1] ‘FUN’
[17:59:26.205] 
[17:59:26.205] getGlobalsAndPackages() ... DONE
[17:59:26.205]  - globals found/used: [n=1] ‘FUN’
[17:59:26.205]  - needed namespaces: [n=0] 
[17:59:26.206] Finding globals ... DONE
[17:59:26.206]  - use_args: TRUE
[17:59:26.206]  - Getting '...' globals ...
[17:59:26.207] resolve() on list ...
[17:59:26.207]  recursive: 0
[17:59:26.207]  length: 1
[17:59:26.207]  elements: ‘...’
[17:59:26.208]  length: 0 (resolved future 1)
[17:59:26.208] resolve() on list ... DONE
[17:59:26.208]    - '...' content: [n=0] 
[17:59:26.208] List of 1
[17:59:26.208]  $ ...: list()
[17:59:26.208]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.208]  - attr(*, "where")=List of 1
[17:59:26.208]   ..$ ...:<environment: 0x62649f9e28a0> 
[17:59:26.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.208]  - attr(*, "resolved")= logi TRUE
[17:59:26.208]  - attr(*, "total_size")= num NA
[17:59:26.214]  - Getting '...' globals ... DONE
[17:59:26.214] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:26.215] List of 2
[17:59:26.215]  $ ...future.FUN:function (object, ...)  
[17:59:26.215]  $ ...          : list()
[17:59:26.215]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.215]  - attr(*, "where")=List of 2
[17:59:26.215]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:26.215]   ..$ ...          :<environment: 0x62649f9e28a0> 
[17:59:26.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.215]  - attr(*, "resolved")= logi FALSE
[17:59:26.215]  - attr(*, "total_size")= num 1240
[17:59:26.224] Packages to be attached in all futures: [n=0] 
[17:59:26.225] getGlobalsAndPackagesXApply() ... DONE
[17:59:26.225] Number of futures (= number of chunks): 1
[17:59:26.225] Launching 1 futures (chunks) ...
[17:59:26.225] Chunk #1 of 1 ...
[17:59:26.226]  - Finding globals in 'X' for chunk #1 ...
[17:59:26.226] getGlobalsAndPackages() ...
[17:59:26.226] Searching for globals...
[17:59:26.227] 
[17:59:26.228] Searching for globals ... DONE
[17:59:26.228] - globals: [0] <none>
[17:59:26.228] getGlobalsAndPackages() ... DONE
[17:59:26.228]    + additional globals found: [n=0] 
[17:59:26.228]    + additional namespaces needed: [n=0] 
[17:59:26.229]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:26.229]  - seeds: <none>
[17:59:26.229]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.229] getGlobalsAndPackages() ...
[17:59:26.230] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.230] Resolving globals: FALSE
[17:59:26.230] Tweak future expression to call with '...' arguments ...
[17:59:26.230] {
[17:59:26.230]     do.call(function(...) {
[17:59:26.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.230]             on.exit(options(oopts), add = TRUE)
[17:59:26.230]         }
[17:59:26.230]         {
[17:59:26.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.230]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.230]             })
[17:59:26.230]         }
[17:59:26.230]     }, args = future.call.arguments)
[17:59:26.230] }
[17:59:26.231] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.231] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.232] 
[17:59:26.232] getGlobalsAndPackages() ... DONE
[17:59:26.233] run() for ‘Future’ ...
[17:59:26.233] - state: ‘created’
[17:59:26.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:59:26.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:26.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:59:26.234]   - Field: ‘label’
[17:59:26.234]   - Field: ‘local’
[17:59:26.235]   - Field: ‘owner’
[17:59:26.235]   - Field: ‘envir’
[17:59:26.235]   - Field: ‘packages’
[17:59:26.235]   - Field: ‘gc’
[17:59:26.235]   - Field: ‘conditions’
[17:59:26.236]   - Field: ‘expr’
[17:59:26.236]   - Field: ‘uuid’
[17:59:26.236]   - Field: ‘seed’
[17:59:26.236]   - Field: ‘version’
[17:59:26.236]   - Field: ‘result’
[17:59:26.237]   - Field: ‘asynchronous’
[17:59:26.237]   - Field: ‘calls’
[17:59:26.237]   - Field: ‘globals’
[17:59:26.237]   - Field: ‘stdout’
[17:59:26.237]   - Field: ‘earlySignal’
[17:59:26.238]   - Field: ‘lazy’
[17:59:26.238]   - Field: ‘state’
[17:59:26.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:59:26.238] - Launch lazy future ...
[17:59:26.239] Packages needed by the future expression (n = 0): <none>
[17:59:26.239] Packages needed by future strategies (n = 0): <none>
[17:59:26.241] {
[17:59:26.241]     {
[17:59:26.241]         {
[17:59:26.241]             ...future.startTime <- base::Sys.time()
[17:59:26.241]             {
[17:59:26.241]                 {
[17:59:26.241]                   {
[17:59:26.241]                     base::local({
[17:59:26.241]                       has_future <- base::requireNamespace("future", 
[17:59:26.241]                         quietly = TRUE)
[17:59:26.241]                       if (has_future) {
[17:59:26.241]                         ns <- base::getNamespace("future")
[17:59:26.241]                         version <- ns[[".package"]][["version"]]
[17:59:26.241]                         if (is.null(version)) 
[17:59:26.241]                           version <- utils::packageVersion("future")
[17:59:26.241]                       }
[17:59:26.241]                       else {
[17:59:26.241]                         version <- NULL
[17:59:26.241]                       }
[17:59:26.241]                       if (!has_future || version < "1.8.0") {
[17:59:26.241]                         info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.241]                           "", base::R.version$version.string), 
[17:59:26.241]                           platform = base::sprintf("%s (%s-bit)", 
[17:59:26.241]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.241]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.241]                             "release", "version")], collapse = " "), 
[17:59:26.241]                           hostname = base::Sys.info()[["nodename"]])
[17:59:26.241]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.241]                           info)
[17:59:26.241]                         info <- base::paste(info, collapse = "; ")
[17:59:26.241]                         if (!has_future) {
[17:59:26.241]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.241]                             info)
[17:59:26.241]                         }
[17:59:26.241]                         else {
[17:59:26.241]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.241]                             info, version)
[17:59:26.241]                         }
[17:59:26.241]                         base::stop(msg)
[17:59:26.241]                       }
[17:59:26.241]                     })
[17:59:26.241]                   }
[17:59:26.241]                   ...future.strategy.old <- future::plan("list")
[17:59:26.241]                   options(future.plan = NULL)
[17:59:26.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.241]                 }
[17:59:26.241]                 ...future.workdir <- getwd()
[17:59:26.241]             }
[17:59:26.241]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.241]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.241]         }
[17:59:26.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:26.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.241]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.241]             base::names(...future.oldOptions))
[17:59:26.241]     }
[17:59:26.241]     if (FALSE) {
[17:59:26.241]     }
[17:59:26.241]     else {
[17:59:26.241]         if (TRUE) {
[17:59:26.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.241]                 open = "w")
[17:59:26.241]         }
[17:59:26.241]         else {
[17:59:26.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.241]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.241]         }
[17:59:26.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.241]             base::sink(type = "output", split = FALSE)
[17:59:26.241]             base::close(...future.stdout)
[17:59:26.241]         }, add = TRUE)
[17:59:26.241]     }
[17:59:26.241]     ...future.frame <- base::sys.nframe()
[17:59:26.241]     ...future.conditions <- base::list()
[17:59:26.241]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.241]     if (FALSE) {
[17:59:26.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.241]     }
[17:59:26.241]     ...future.result <- base::tryCatch({
[17:59:26.241]         base::withCallingHandlers({
[17:59:26.241]             ...future.value <- base::withVisible(base::local({
[17:59:26.241]                 do.call(function(...) {
[17:59:26.241]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.241]                   if (!identical(...future.globals.maxSize.org, 
[17:59:26.241]                     ...future.globals.maxSize)) {
[17:59:26.241]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.241]                     on.exit(options(oopts), add = TRUE)
[17:59:26.241]                   }
[17:59:26.241]                   {
[17:59:26.241]                     lapply(seq_along(...future.elements_ii), 
[17:59:26.241]                       FUN = function(jj) {
[17:59:26.241]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.241]                         ...future.FUN(...future.X_jj, ...)
[17:59:26.241]                       })
[17:59:26.241]                   }
[17:59:26.241]                 }, args = future.call.arguments)
[17:59:26.241]             }))
[17:59:26.241]             future::FutureResult(value = ...future.value$value, 
[17:59:26.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.241]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.241]                     ...future.globalenv.names))
[17:59:26.241]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.241]         }, condition = base::local({
[17:59:26.241]             c <- base::c
[17:59:26.241]             inherits <- base::inherits
[17:59:26.241]             invokeRestart <- base::invokeRestart
[17:59:26.241]             length <- base::length
[17:59:26.241]             list <- base::list
[17:59:26.241]             seq.int <- base::seq.int
[17:59:26.241]             signalCondition <- base::signalCondition
[17:59:26.241]             sys.calls <- base::sys.calls
[17:59:26.241]             `[[` <- base::`[[`
[17:59:26.241]             `+` <- base::`+`
[17:59:26.241]             `<<-` <- base::`<<-`
[17:59:26.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.241]                   3L)]
[17:59:26.241]             }
[17:59:26.241]             function(cond) {
[17:59:26.241]                 is_error <- inherits(cond, "error")
[17:59:26.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.241]                   NULL)
[17:59:26.241]                 if (is_error) {
[17:59:26.241]                   sessionInformation <- function() {
[17:59:26.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.241]                       search = base::search(), system = base::Sys.info())
[17:59:26.241]                   }
[17:59:26.241]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.241]                     cond$call), session = sessionInformation(), 
[17:59:26.241]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.241]                   signalCondition(cond)
[17:59:26.241]                 }
[17:59:26.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.241]                 "immediateCondition"))) {
[17:59:26.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.241]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.241]                   if (TRUE && !signal) {
[17:59:26.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.241]                     {
[17:59:26.241]                       inherits <- base::inherits
[17:59:26.241]                       invokeRestart <- base::invokeRestart
[17:59:26.241]                       is.null <- base::is.null
[17:59:26.241]                       muffled <- FALSE
[17:59:26.241]                       if (inherits(cond, "message")) {
[17:59:26.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.241]                         if (muffled) 
[17:59:26.241]                           invokeRestart("muffleMessage")
[17:59:26.241]                       }
[17:59:26.241]                       else if (inherits(cond, "warning")) {
[17:59:26.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.241]                         if (muffled) 
[17:59:26.241]                           invokeRestart("muffleWarning")
[17:59:26.241]                       }
[17:59:26.241]                       else if (inherits(cond, "condition")) {
[17:59:26.241]                         if (!is.null(pattern)) {
[17:59:26.241]                           computeRestarts <- base::computeRestarts
[17:59:26.241]                           grepl <- base::grepl
[17:59:26.241]                           restarts <- computeRestarts(cond)
[17:59:26.241]                           for (restart in restarts) {
[17:59:26.241]                             name <- restart$name
[17:59:26.241]                             if (is.null(name)) 
[17:59:26.241]                               next
[17:59:26.241]                             if (!grepl(pattern, name)) 
[17:59:26.241]                               next
[17:59:26.241]                             invokeRestart(restart)
[17:59:26.241]                             muffled <- TRUE
[17:59:26.241]                             break
[17:59:26.241]                           }
[17:59:26.241]                         }
[17:59:26.241]                       }
[17:59:26.241]                       invisible(muffled)
[17:59:26.241]                     }
[17:59:26.241]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.241]                   }
[17:59:26.241]                 }
[17:59:26.241]                 else {
[17:59:26.241]                   if (TRUE) {
[17:59:26.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.241]                     {
[17:59:26.241]                       inherits <- base::inherits
[17:59:26.241]                       invokeRestart <- base::invokeRestart
[17:59:26.241]                       is.null <- base::is.null
[17:59:26.241]                       muffled <- FALSE
[17:59:26.241]                       if (inherits(cond, "message")) {
[17:59:26.241]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.241]                         if (muffled) 
[17:59:26.241]                           invokeRestart("muffleMessage")
[17:59:26.241]                       }
[17:59:26.241]                       else if (inherits(cond, "warning")) {
[17:59:26.241]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.241]                         if (muffled) 
[17:59:26.241]                           invokeRestart("muffleWarning")
[17:59:26.241]                       }
[17:59:26.241]                       else if (inherits(cond, "condition")) {
[17:59:26.241]                         if (!is.null(pattern)) {
[17:59:26.241]                           computeRestarts <- base::computeRestarts
[17:59:26.241]                           grepl <- base::grepl
[17:59:26.241]                           restarts <- computeRestarts(cond)
[17:59:26.241]                           for (restart in restarts) {
[17:59:26.241]                             name <- restart$name
[17:59:26.241]                             if (is.null(name)) 
[17:59:26.241]                               next
[17:59:26.241]                             if (!grepl(pattern, name)) 
[17:59:26.241]                               next
[17:59:26.241]                             invokeRestart(restart)
[17:59:26.241]                             muffled <- TRUE
[17:59:26.241]                             break
[17:59:26.241]                           }
[17:59:26.241]                         }
[17:59:26.241]                       }
[17:59:26.241]                       invisible(muffled)
[17:59:26.241]                     }
[17:59:26.241]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.241]                   }
[17:59:26.241]                 }
[17:59:26.241]             }
[17:59:26.241]         }))
[17:59:26.241]     }, error = function(ex) {
[17:59:26.241]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.241]                 ...future.rng), started = ...future.startTime, 
[17:59:26.241]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.241]             version = "1.8"), class = "FutureResult")
[17:59:26.241]     }, finally = {
[17:59:26.241]         if (!identical(...future.workdir, getwd())) 
[17:59:26.241]             setwd(...future.workdir)
[17:59:26.241]         {
[17:59:26.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.241]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.241]             }
[17:59:26.241]             base::options(...future.oldOptions)
[17:59:26.241]             if (.Platform$OS.type == "windows") {
[17:59:26.241]                 old_names <- names(...future.oldEnvVars)
[17:59:26.241]                 envs <- base::Sys.getenv()
[17:59:26.241]                 names <- names(envs)
[17:59:26.241]                 common <- intersect(names, old_names)
[17:59:26.241]                 added <- setdiff(names, old_names)
[17:59:26.241]                 removed <- setdiff(old_names, names)
[17:59:26.241]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.241]                   envs[common]]
[17:59:26.241]                 NAMES <- toupper(changed)
[17:59:26.241]                 args <- list()
[17:59:26.241]                 for (kk in seq_along(NAMES)) {
[17:59:26.241]                   name <- changed[[kk]]
[17:59:26.241]                   NAME <- NAMES[[kk]]
[17:59:26.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.241]                     next
[17:59:26.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.241]                 }
[17:59:26.241]                 NAMES <- toupper(added)
[17:59:26.241]                 for (kk in seq_along(NAMES)) {
[17:59:26.241]                   name <- added[[kk]]
[17:59:26.241]                   NAME <- NAMES[[kk]]
[17:59:26.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.241]                     next
[17:59:26.241]                   args[[name]] <- ""
[17:59:26.241]                 }
[17:59:26.241]                 NAMES <- toupper(removed)
[17:59:26.241]                 for (kk in seq_along(NAMES)) {
[17:59:26.241]                   name <- removed[[kk]]
[17:59:26.241]                   NAME <- NAMES[[kk]]
[17:59:26.241]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.241]                     next
[17:59:26.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.241]                 }
[17:59:26.241]                 if (length(args) > 0) 
[17:59:26.241]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.241]             }
[17:59:26.241]             else {
[17:59:26.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.241]             }
[17:59:26.241]             {
[17:59:26.241]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.241]                   0L) {
[17:59:26.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.241]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.241]                   base::options(opts)
[17:59:26.241]                 }
[17:59:26.241]                 {
[17:59:26.241]                   {
[17:59:26.241]                     NULL
[17:59:26.241]                     RNGkind("Mersenne-Twister")
[17:59:26.241]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:59:26.241]                       inherits = FALSE)
[17:59:26.241]                   }
[17:59:26.241]                   options(future.plan = NULL)
[17:59:26.241]                   if (is.na(NA_character_)) 
[17:59:26.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.241]                     .init = FALSE)
[17:59:26.241]                 }
[17:59:26.241]             }
[17:59:26.241]         }
[17:59:26.241]     })
[17:59:26.241]     if (TRUE) {
[17:59:26.241]         base::sink(type = "output", split = FALSE)
[17:59:26.241]         if (TRUE) {
[17:59:26.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.241]         }
[17:59:26.241]         else {
[17:59:26.241]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.241]         }
[17:59:26.241]         base::close(...future.stdout)
[17:59:26.241]         ...future.stdout <- NULL
[17:59:26.241]     }
[17:59:26.241]     ...future.result$conditions <- ...future.conditions
[17:59:26.241]     ...future.result$finished <- base::Sys.time()
[17:59:26.241]     ...future.result
[17:59:26.241] }
[17:59:26.244] assign_globals() ...
[17:59:26.245] List of 5
[17:59:26.245]  $ ...future.FUN            :function (object, ...)  
[17:59:26.245]  $ future.call.arguments    : list()
[17:59:26.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.245]  $ ...future.elements_ii    :List of 3
[17:59:26.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.245]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:26.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:26.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.245]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:26.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:26.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.245]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:26.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:26.245]  $ ...future.seeds_ii       : NULL
[17:59:26.245]  $ ...future.globals.maxSize: NULL
[17:59:26.245]  - attr(*, "where")=List of 5
[17:59:26.245]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.245]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.245]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.245]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.245]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.245]  - attr(*, "resolved")= logi FALSE
[17:59:26.245]  - attr(*, "total_size")= num 1240
[17:59:26.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.245]  - attr(*, "already-done")= logi TRUE
[17:59:26.281] - copied ‘...future.FUN’ to environment
[17:59:26.282] - copied ‘future.call.arguments’ to environment
[17:59:26.282] - copied ‘...future.elements_ii’ to environment
[17:59:26.282] - copied ‘...future.seeds_ii’ to environment
[17:59:26.282] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.282] assign_globals() ... done
[17:59:26.283] plan(): Setting new future strategy stack:
[17:59:26.283] List of future strategies:
[17:59:26.283] 1. sequential:
[17:59:26.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.283]    - tweaked: FALSE
[17:59:26.283]    - call: NULL
[17:59:26.287] plan(): nbrOfWorkers() = 1
[17:59:26.293] plan(): Setting new future strategy stack:
[17:59:26.293] List of future strategies:
[17:59:26.293] 1. sequential:
[17:59:26.293]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.293]    - tweaked: FALSE
[17:59:26.293]    - call: plan(strategy)
[17:59:26.294] plan(): nbrOfWorkers() = 1
[17:59:26.295] SequentialFuture started (and completed)
[17:59:26.295] - Launch lazy future ... done
[17:59:26.295] run() for ‘SequentialFuture’ ... done
[17:59:26.295] Created future:
[17:59:26.296] SequentialFuture:
[17:59:26.296] Label: ‘future_by-1’
[17:59:26.296] Expression:
[17:59:26.296] {
[17:59:26.296]     do.call(function(...) {
[17:59:26.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.296]             on.exit(options(oopts), add = TRUE)
[17:59:26.296]         }
[17:59:26.296]         {
[17:59:26.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.296]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.296]             })
[17:59:26.296]         }
[17:59:26.296]     }, args = future.call.arguments)
[17:59:26.296] }
[17:59:26.296] Lazy evaluation: FALSE
[17:59:26.296] Asynchronous evaluation: FALSE
[17:59:26.296] Local evaluation: TRUE
[17:59:26.296] Environment: 0x62649f933ca0
[17:59:26.296] Capture standard output: TRUE
[17:59:26.296] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.296] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.296] Packages: <none>
[17:59:26.296] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.296] Resolved: TRUE
[17:59:26.296] Value: 5.37 KiB of class ‘list’
[17:59:26.296] Early signaling: FALSE
[17:59:26.296] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.296] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:59:26.299] Chunk #1 of 1 ... DONE
[17:59:26.299] Launching 1 futures (chunks) ... DONE
[17:59:26.299] Resolving 1 futures (chunks) ...
[17:59:26.299] resolve() on list ...
[17:59:26.300]  recursive: 0
[17:59:26.300]  length: 1
[17:59:26.300] 
[17:59:26.300] resolved() for ‘SequentialFuture’ ...
[17:59:26.300] - state: ‘finished’
[17:59:26.301] - run: TRUE
[17:59:26.301] - result: ‘FutureResult’
[17:59:26.301] resolved() for ‘SequentialFuture’ ... done
[17:59:26.301] Future #1
[17:59:26.302] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:59:26.302] - nx: 1
[17:59:26.302] - relay: TRUE
[17:59:26.302] - stdout: TRUE
[17:59:26.302] - signal: TRUE
[17:59:26.302] - resignal: FALSE
[17:59:26.303] - force: TRUE
[17:59:26.303] - relayed: [n=1] FALSE
[17:59:26.303] - queued futures: [n=1] FALSE
[17:59:26.303]  - until=1
[17:59:26.304]  - relaying element #1
[17:59:26.304] - relayed: [n=1] TRUE
[17:59:26.304] - queued futures: [n=1] TRUE
[17:59:26.304] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:59:26.305]  length: 0 (resolved future 1)
[17:59:26.305] Relaying remaining futures
[17:59:26.305] signalConditionsASAP(NULL, pos=0) ...
[17:59:26.305] - nx: 1
[17:59:26.305] - relay: TRUE
[17:59:26.306] - stdout: TRUE
[17:59:26.306] - signal: TRUE
[17:59:26.306] - resignal: FALSE
[17:59:26.306] - force: TRUE
[17:59:26.306] - relayed: [n=1] TRUE
[17:59:26.306] - queued futures: [n=1] TRUE
 - flush all
[17:59:26.307] - relayed: [n=1] TRUE
[17:59:26.307] - queued futures: [n=1] TRUE
[17:59:26.307] signalConditionsASAP(NULL, pos=0) ... done
[17:59:26.307] resolve() on list ... DONE
[17:59:26.308]  - Number of value chunks collected: 1
[17:59:26.308] Resolving 1 futures (chunks) ... DONE
[17:59:26.308] Reducing values from 1 chunks ...
[17:59:26.308]  - Number of values collected after concatenation: 3
[17:59:26.308]  - Number of values expected: 3
[17:59:26.309] Reducing values from 1 chunks ... DONE
[17:59:26.309] future_lapply() ... DONE
[17:59:26.309] future_by_internal() ... DONE
[17:59:26.311] future_by_internal() ...
- plan('multicore') ...
[17:59:26.312] plan(): Setting new future strategy stack:
[17:59:26.312] List of future strategies:
[17:59:26.312] 1. multicore:
[17:59:26.312]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:26.312]    - tweaked: FALSE
[17:59:26.312]    - call: plan(strategy)
[17:59:26.318] plan(): nbrOfWorkers() = 2
[17:59:26.319] future_by_internal() ...
[17:59:26.320] future_lapply() ...
[17:59:26.328] Number of chunks: 2
[17:59:26.328] getGlobalsAndPackagesXApply() ...
[17:59:26.328]  - future.globals: TRUE
[17:59:26.329] getGlobalsAndPackages() ...
[17:59:26.329] Searching for globals...
[17:59:26.331] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:26.331] Searching for globals ... DONE
[17:59:26.332] Resolving globals: FALSE
[17:59:26.332] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:26.333] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:26.333] - globals: [1] ‘FUN’
[17:59:26.334] 
[17:59:26.334] getGlobalsAndPackages() ... DONE
[17:59:26.334]  - globals found/used: [n=1] ‘FUN’
[17:59:26.334]  - needed namespaces: [n=0] 
[17:59:26.334] Finding globals ... DONE
[17:59:26.335]  - use_args: TRUE
[17:59:26.335]  - Getting '...' globals ...
[17:59:26.336] resolve() on list ...
[17:59:26.336]  recursive: 0
[17:59:26.336]  length: 1
[17:59:26.336]  elements: ‘...’
[17:59:26.336]  length: 0 (resolved future 1)
[17:59:26.337] resolve() on list ... DONE
[17:59:26.337]    - '...' content: [n=0] 
[17:59:26.337] List of 1
[17:59:26.337]  $ ...: list()
[17:59:26.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.337]  - attr(*, "where")=List of 1
[17:59:26.337]   ..$ ...:<environment: 0x62649fa84ae0> 
[17:59:26.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.337]  - attr(*, "resolved")= logi TRUE
[17:59:26.337]  - attr(*, "total_size")= num NA
[17:59:26.349]  - Getting '...' globals ... DONE
[17:59:26.349] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:26.350] List of 2
[17:59:26.350]  $ ...future.FUN:function (object, ...)  
[17:59:26.350]  $ ...          : list()
[17:59:26.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.350]  - attr(*, "where")=List of 2
[17:59:26.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:26.350]   ..$ ...          :<environment: 0x62649fa84ae0> 
[17:59:26.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.350]  - attr(*, "resolved")= logi FALSE
[17:59:26.350]  - attr(*, "total_size")= num 1240
[17:59:26.356] Packages to be attached in all futures: [n=0] 
[17:59:26.356] getGlobalsAndPackagesXApply() ... DONE
[17:59:26.357] Number of futures (= number of chunks): 2
[17:59:26.357] Launching 2 futures (chunks) ...
[17:59:26.357] Chunk #1 of 2 ...
[17:59:26.357]  - Finding globals in 'X' for chunk #1 ...
[17:59:26.357] getGlobalsAndPackages() ...
[17:59:26.358] Searching for globals...
[17:59:26.358] 
[17:59:26.359] Searching for globals ... DONE
[17:59:26.359] - globals: [0] <none>
[17:59:26.359] getGlobalsAndPackages() ... DONE
[17:59:26.359]    + additional globals found: [n=0] 
[17:59:26.360]    + additional namespaces needed: [n=0] 
[17:59:26.360]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:26.360]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:26.360]  - seeds: <none>
[17:59:26.360]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.361] getGlobalsAndPackages() ...
[17:59:26.361] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.361] Resolving globals: FALSE
[17:59:26.361] Tweak future expression to call with '...' arguments ...
[17:59:26.361] {
[17:59:26.361]     do.call(function(...) {
[17:59:26.361]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.361]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.361]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.361]             on.exit(options(oopts), add = TRUE)
[17:59:26.361]         }
[17:59:26.361]         {
[17:59:26.361]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.361]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.361]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.361]             })
[17:59:26.361]         }
[17:59:26.361]     }, args = future.call.arguments)
[17:59:26.361] }
[17:59:26.362] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.363] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.363] 
[17:59:26.363] getGlobalsAndPackages() ... DONE
[17:59:26.364] run() for ‘Future’ ...
[17:59:26.364] - state: ‘created’
[17:59:26.364] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:26.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:26.371]   - Field: ‘label’
[17:59:26.372]   - Field: ‘local’
[17:59:26.372]   - Field: ‘owner’
[17:59:26.372]   - Field: ‘envir’
[17:59:26.372]   - Field: ‘workers’
[17:59:26.372]   - Field: ‘packages’
[17:59:26.373]   - Field: ‘gc’
[17:59:26.373]   - Field: ‘job’
[17:59:26.373]   - Field: ‘conditions’
[17:59:26.373]   - Field: ‘expr’
[17:59:26.374]   - Field: ‘uuid’
[17:59:26.374]   - Field: ‘seed’
[17:59:26.374]   - Field: ‘version’
[17:59:26.374]   - Field: ‘result’
[17:59:26.374]   - Field: ‘asynchronous’
[17:59:26.375]   - Field: ‘calls’
[17:59:26.375]   - Field: ‘globals’
[17:59:26.375]   - Field: ‘stdout’
[17:59:26.375]   - Field: ‘earlySignal’
[17:59:26.375]   - Field: ‘lazy’
[17:59:26.376]   - Field: ‘state’
[17:59:26.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:26.376] - Launch lazy future ...
[17:59:26.378] Packages needed by the future expression (n = 0): <none>
[17:59:26.378] Packages needed by future strategies (n = 0): <none>
[17:59:26.379] {
[17:59:26.379]     {
[17:59:26.379]         {
[17:59:26.379]             ...future.startTime <- base::Sys.time()
[17:59:26.379]             {
[17:59:26.379]                 {
[17:59:26.379]                   {
[17:59:26.379]                     {
[17:59:26.379]                       base::local({
[17:59:26.379]                         has_future <- base::requireNamespace("future", 
[17:59:26.379]                           quietly = TRUE)
[17:59:26.379]                         if (has_future) {
[17:59:26.379]                           ns <- base::getNamespace("future")
[17:59:26.379]                           version <- ns[[".package"]][["version"]]
[17:59:26.379]                           if (is.null(version)) 
[17:59:26.379]                             version <- utils::packageVersion("future")
[17:59:26.379]                         }
[17:59:26.379]                         else {
[17:59:26.379]                           version <- NULL
[17:59:26.379]                         }
[17:59:26.379]                         if (!has_future || version < "1.8.0") {
[17:59:26.379]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.379]                             "", base::R.version$version.string), 
[17:59:26.379]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:26.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.379]                               "release", "version")], collapse = " "), 
[17:59:26.379]                             hostname = base::Sys.info()[["nodename"]])
[17:59:26.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.379]                             info)
[17:59:26.379]                           info <- base::paste(info, collapse = "; ")
[17:59:26.379]                           if (!has_future) {
[17:59:26.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.379]                               info)
[17:59:26.379]                           }
[17:59:26.379]                           else {
[17:59:26.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.379]                               info, version)
[17:59:26.379]                           }
[17:59:26.379]                           base::stop(msg)
[17:59:26.379]                         }
[17:59:26.379]                       })
[17:59:26.379]                     }
[17:59:26.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:26.379]                     base::options(mc.cores = 1L)
[17:59:26.379]                   }
[17:59:26.379]                   ...future.strategy.old <- future::plan("list")
[17:59:26.379]                   options(future.plan = NULL)
[17:59:26.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.379]                 }
[17:59:26.379]                 ...future.workdir <- getwd()
[17:59:26.379]             }
[17:59:26.379]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.379]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.379]         }
[17:59:26.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.379]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:26.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.379]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.379]             base::names(...future.oldOptions))
[17:59:26.379]     }
[17:59:26.379]     if (FALSE) {
[17:59:26.379]     }
[17:59:26.379]     else {
[17:59:26.379]         if (TRUE) {
[17:59:26.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.379]                 open = "w")
[17:59:26.379]         }
[17:59:26.379]         else {
[17:59:26.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.379]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.379]         }
[17:59:26.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.379]             base::sink(type = "output", split = FALSE)
[17:59:26.379]             base::close(...future.stdout)
[17:59:26.379]         }, add = TRUE)
[17:59:26.379]     }
[17:59:26.379]     ...future.frame <- base::sys.nframe()
[17:59:26.379]     ...future.conditions <- base::list()
[17:59:26.379]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.379]     if (FALSE) {
[17:59:26.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.379]     }
[17:59:26.379]     ...future.result <- base::tryCatch({
[17:59:26.379]         base::withCallingHandlers({
[17:59:26.379]             ...future.value <- base::withVisible(base::local({
[17:59:26.379]                 withCallingHandlers({
[17:59:26.379]                   {
[17:59:26.379]                     do.call(function(...) {
[17:59:26.379]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.379]                       if (!identical(...future.globals.maxSize.org, 
[17:59:26.379]                         ...future.globals.maxSize)) {
[17:59:26.379]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.379]                         on.exit(options(oopts), add = TRUE)
[17:59:26.379]                       }
[17:59:26.379]                       {
[17:59:26.379]                         lapply(seq_along(...future.elements_ii), 
[17:59:26.379]                           FUN = function(jj) {
[17:59:26.379]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.379]                             ...future.FUN(...future.X_jj, ...)
[17:59:26.379]                           })
[17:59:26.379]                       }
[17:59:26.379]                     }, args = future.call.arguments)
[17:59:26.379]                   }
[17:59:26.379]                 }, immediateCondition = function(cond) {
[17:59:26.379]                   save_rds <- function (object, pathname, ...) 
[17:59:26.379]                   {
[17:59:26.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:26.379]                     if (file_test("-f", pathname_tmp)) {
[17:59:26.379]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:26.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.379]                         fi_tmp[["mtime"]])
[17:59:26.379]                     }
[17:59:26.379]                     tryCatch({
[17:59:26.379]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:26.379]                     }, error = function(ex) {
[17:59:26.379]                       msg <- conditionMessage(ex)
[17:59:26.379]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:26.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.379]                         fi_tmp[["mtime"]], msg)
[17:59:26.379]                       ex$message <- msg
[17:59:26.379]                       stop(ex)
[17:59:26.379]                     })
[17:59:26.379]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:26.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:26.379]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:26.379]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.379]                       fi <- file.info(pathname)
[17:59:26.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:26.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:26.379]                         fi[["size"]], fi[["mtime"]])
[17:59:26.379]                       stop(msg)
[17:59:26.379]                     }
[17:59:26.379]                     invisible(pathname)
[17:59:26.379]                   }
[17:59:26.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:26.379]                     rootPath = tempdir()) 
[17:59:26.379]                   {
[17:59:26.379]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:26.379]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:26.379]                       tmpdir = path, fileext = ".rds")
[17:59:26.379]                     save_rds(obj, file)
[17:59:26.379]                   }
[17:59:26.379]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:26.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.379]                   {
[17:59:26.379]                     inherits <- base::inherits
[17:59:26.379]                     invokeRestart <- base::invokeRestart
[17:59:26.379]                     is.null <- base::is.null
[17:59:26.379]                     muffled <- FALSE
[17:59:26.379]                     if (inherits(cond, "message")) {
[17:59:26.379]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:26.379]                       if (muffled) 
[17:59:26.379]                         invokeRestart("muffleMessage")
[17:59:26.379]                     }
[17:59:26.379]                     else if (inherits(cond, "warning")) {
[17:59:26.379]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:26.379]                       if (muffled) 
[17:59:26.379]                         invokeRestart("muffleWarning")
[17:59:26.379]                     }
[17:59:26.379]                     else if (inherits(cond, "condition")) {
[17:59:26.379]                       if (!is.null(pattern)) {
[17:59:26.379]                         computeRestarts <- base::computeRestarts
[17:59:26.379]                         grepl <- base::grepl
[17:59:26.379]                         restarts <- computeRestarts(cond)
[17:59:26.379]                         for (restart in restarts) {
[17:59:26.379]                           name <- restart$name
[17:59:26.379]                           if (is.null(name)) 
[17:59:26.379]                             next
[17:59:26.379]                           if (!grepl(pattern, name)) 
[17:59:26.379]                             next
[17:59:26.379]                           invokeRestart(restart)
[17:59:26.379]                           muffled <- TRUE
[17:59:26.379]                           break
[17:59:26.379]                         }
[17:59:26.379]                       }
[17:59:26.379]                     }
[17:59:26.379]                     invisible(muffled)
[17:59:26.379]                   }
[17:59:26.379]                   muffleCondition(cond)
[17:59:26.379]                 })
[17:59:26.379]             }))
[17:59:26.379]             future::FutureResult(value = ...future.value$value, 
[17:59:26.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.379]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.379]                     ...future.globalenv.names))
[17:59:26.379]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.379]         }, condition = base::local({
[17:59:26.379]             c <- base::c
[17:59:26.379]             inherits <- base::inherits
[17:59:26.379]             invokeRestart <- base::invokeRestart
[17:59:26.379]             length <- base::length
[17:59:26.379]             list <- base::list
[17:59:26.379]             seq.int <- base::seq.int
[17:59:26.379]             signalCondition <- base::signalCondition
[17:59:26.379]             sys.calls <- base::sys.calls
[17:59:26.379]             `[[` <- base::`[[`
[17:59:26.379]             `+` <- base::`+`
[17:59:26.379]             `<<-` <- base::`<<-`
[17:59:26.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.379]                   3L)]
[17:59:26.379]             }
[17:59:26.379]             function(cond) {
[17:59:26.379]                 is_error <- inherits(cond, "error")
[17:59:26.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.379]                   NULL)
[17:59:26.379]                 if (is_error) {
[17:59:26.379]                   sessionInformation <- function() {
[17:59:26.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.379]                       search = base::search(), system = base::Sys.info())
[17:59:26.379]                   }
[17:59:26.379]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.379]                     cond$call), session = sessionInformation(), 
[17:59:26.379]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.379]                   signalCondition(cond)
[17:59:26.379]                 }
[17:59:26.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.379]                 "immediateCondition"))) {
[17:59:26.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.379]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.379]                   if (TRUE && !signal) {
[17:59:26.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.379]                     {
[17:59:26.379]                       inherits <- base::inherits
[17:59:26.379]                       invokeRestart <- base::invokeRestart
[17:59:26.379]                       is.null <- base::is.null
[17:59:26.379]                       muffled <- FALSE
[17:59:26.379]                       if (inherits(cond, "message")) {
[17:59:26.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.379]                         if (muffled) 
[17:59:26.379]                           invokeRestart("muffleMessage")
[17:59:26.379]                       }
[17:59:26.379]                       else if (inherits(cond, "warning")) {
[17:59:26.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.379]                         if (muffled) 
[17:59:26.379]                           invokeRestart("muffleWarning")
[17:59:26.379]                       }
[17:59:26.379]                       else if (inherits(cond, "condition")) {
[17:59:26.379]                         if (!is.null(pattern)) {
[17:59:26.379]                           computeRestarts <- base::computeRestarts
[17:59:26.379]                           grepl <- base::grepl
[17:59:26.379]                           restarts <- computeRestarts(cond)
[17:59:26.379]                           for (restart in restarts) {
[17:59:26.379]                             name <- restart$name
[17:59:26.379]                             if (is.null(name)) 
[17:59:26.379]                               next
[17:59:26.379]                             if (!grepl(pattern, name)) 
[17:59:26.379]                               next
[17:59:26.379]                             invokeRestart(restart)
[17:59:26.379]                             muffled <- TRUE
[17:59:26.379]                             break
[17:59:26.379]                           }
[17:59:26.379]                         }
[17:59:26.379]                       }
[17:59:26.379]                       invisible(muffled)
[17:59:26.379]                     }
[17:59:26.379]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.379]                   }
[17:59:26.379]                 }
[17:59:26.379]                 else {
[17:59:26.379]                   if (TRUE) {
[17:59:26.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.379]                     {
[17:59:26.379]                       inherits <- base::inherits
[17:59:26.379]                       invokeRestart <- base::invokeRestart
[17:59:26.379]                       is.null <- base::is.null
[17:59:26.379]                       muffled <- FALSE
[17:59:26.379]                       if (inherits(cond, "message")) {
[17:59:26.379]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.379]                         if (muffled) 
[17:59:26.379]                           invokeRestart("muffleMessage")
[17:59:26.379]                       }
[17:59:26.379]                       else if (inherits(cond, "warning")) {
[17:59:26.379]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.379]                         if (muffled) 
[17:59:26.379]                           invokeRestart("muffleWarning")
[17:59:26.379]                       }
[17:59:26.379]                       else if (inherits(cond, "condition")) {
[17:59:26.379]                         if (!is.null(pattern)) {
[17:59:26.379]                           computeRestarts <- base::computeRestarts
[17:59:26.379]                           grepl <- base::grepl
[17:59:26.379]                           restarts <- computeRestarts(cond)
[17:59:26.379]                           for (restart in restarts) {
[17:59:26.379]                             name <- restart$name
[17:59:26.379]                             if (is.null(name)) 
[17:59:26.379]                               next
[17:59:26.379]                             if (!grepl(pattern, name)) 
[17:59:26.379]                               next
[17:59:26.379]                             invokeRestart(restart)
[17:59:26.379]                             muffled <- TRUE
[17:59:26.379]                             break
[17:59:26.379]                           }
[17:59:26.379]                         }
[17:59:26.379]                       }
[17:59:26.379]                       invisible(muffled)
[17:59:26.379]                     }
[17:59:26.379]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.379]                   }
[17:59:26.379]                 }
[17:59:26.379]             }
[17:59:26.379]         }))
[17:59:26.379]     }, error = function(ex) {
[17:59:26.379]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.379]                 ...future.rng), started = ...future.startTime, 
[17:59:26.379]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.379]             version = "1.8"), class = "FutureResult")
[17:59:26.379]     }, finally = {
[17:59:26.379]         if (!identical(...future.workdir, getwd())) 
[17:59:26.379]             setwd(...future.workdir)
[17:59:26.379]         {
[17:59:26.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.379]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.379]             }
[17:59:26.379]             base::options(...future.oldOptions)
[17:59:26.379]             if (.Platform$OS.type == "windows") {
[17:59:26.379]                 old_names <- names(...future.oldEnvVars)
[17:59:26.379]                 envs <- base::Sys.getenv()
[17:59:26.379]                 names <- names(envs)
[17:59:26.379]                 common <- intersect(names, old_names)
[17:59:26.379]                 added <- setdiff(names, old_names)
[17:59:26.379]                 removed <- setdiff(old_names, names)
[17:59:26.379]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.379]                   envs[common]]
[17:59:26.379]                 NAMES <- toupper(changed)
[17:59:26.379]                 args <- list()
[17:59:26.379]                 for (kk in seq_along(NAMES)) {
[17:59:26.379]                   name <- changed[[kk]]
[17:59:26.379]                   NAME <- NAMES[[kk]]
[17:59:26.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.379]                     next
[17:59:26.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.379]                 }
[17:59:26.379]                 NAMES <- toupper(added)
[17:59:26.379]                 for (kk in seq_along(NAMES)) {
[17:59:26.379]                   name <- added[[kk]]
[17:59:26.379]                   NAME <- NAMES[[kk]]
[17:59:26.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.379]                     next
[17:59:26.379]                   args[[name]] <- ""
[17:59:26.379]                 }
[17:59:26.379]                 NAMES <- toupper(removed)
[17:59:26.379]                 for (kk in seq_along(NAMES)) {
[17:59:26.379]                   name <- removed[[kk]]
[17:59:26.379]                   NAME <- NAMES[[kk]]
[17:59:26.379]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.379]                     next
[17:59:26.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.379]                 }
[17:59:26.379]                 if (length(args) > 0) 
[17:59:26.379]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.379]             }
[17:59:26.379]             else {
[17:59:26.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.379]             }
[17:59:26.379]             {
[17:59:26.379]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.379]                   0L) {
[17:59:26.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.379]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.379]                   base::options(opts)
[17:59:26.379]                 }
[17:59:26.379]                 {
[17:59:26.379]                   {
[17:59:26.379]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:26.379]                     NULL
[17:59:26.379]                   }
[17:59:26.379]                   options(future.plan = NULL)
[17:59:26.379]                   if (is.na(NA_character_)) 
[17:59:26.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.379]                     .init = FALSE)
[17:59:26.379]                 }
[17:59:26.379]             }
[17:59:26.379]         }
[17:59:26.379]     })
[17:59:26.379]     if (TRUE) {
[17:59:26.379]         base::sink(type = "output", split = FALSE)
[17:59:26.379]         if (TRUE) {
[17:59:26.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.379]         }
[17:59:26.379]         else {
[17:59:26.379]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.379]         }
[17:59:26.379]         base::close(...future.stdout)
[17:59:26.379]         ...future.stdout <- NULL
[17:59:26.379]     }
[17:59:26.379]     ...future.result$conditions <- ...future.conditions
[17:59:26.379]     ...future.result$finished <- base::Sys.time()
[17:59:26.379]     ...future.result
[17:59:26.379] }
[17:59:26.384] assign_globals() ...
[17:59:26.384] List of 5
[17:59:26.384]  $ ...future.FUN            :function (object, ...)  
[17:59:26.384]  $ future.call.arguments    : list()
[17:59:26.384]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.384]  $ ...future.elements_ii    :List of 1
[17:59:26.384]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:26.384]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:26.384]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.384]  $ ...future.seeds_ii       : NULL
[17:59:26.384]  $ ...future.globals.maxSize: NULL
[17:59:26.384]  - attr(*, "where")=List of 5
[17:59:26.384]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.384]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.384]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.384]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.384]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.384]  - attr(*, "resolved")= logi FALSE
[17:59:26.384]  - attr(*, "total_size")= num 1240
[17:59:26.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.384]  - attr(*, "already-done")= logi TRUE
[17:59:26.395] - copied ‘...future.FUN’ to environment
[17:59:26.398] - copied ‘future.call.arguments’ to environment
[17:59:26.398] - copied ‘...future.elements_ii’ to environment
[17:59:26.398] - copied ‘...future.seeds_ii’ to environment
[17:59:26.399] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.399] assign_globals() ... done
[17:59:26.399] requestCore(): workers = 2
[17:59:26.405] MulticoreFuture started
[17:59:26.406] - Launch lazy future ... done
[17:59:26.407] plan(): Setting new future strategy stack:
[17:59:26.407] run() for ‘MulticoreFuture’ ... done
[17:59:26.408] Created future:
[17:59:26.407] List of future strategies:
[17:59:26.407] 1. sequential:
[17:59:26.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.407]    - tweaked: FALSE
[17:59:26.407]    - call: NULL
[17:59:26.412] plan(): nbrOfWorkers() = 1
[17:59:26.420] plan(): Setting new future strategy stack:
[17:59:26.420] List of future strategies:
[17:59:26.420] 1. multicore:
[17:59:26.420]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:26.420]    - tweaked: FALSE
[17:59:26.420]    - call: plan(strategy)
[17:59:26.409] MulticoreFuture:
[17:59:26.409] Label: ‘future_by-1’
[17:59:26.409] Expression:
[17:59:26.409] {
[17:59:26.409]     do.call(function(...) {
[17:59:26.409]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.409]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.409]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.409]             on.exit(options(oopts), add = TRUE)
[17:59:26.409]         }
[17:59:26.409]         {
[17:59:26.409]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.409]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.409]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.409]             })
[17:59:26.409]         }
[17:59:26.409]     }, args = future.call.arguments)
[17:59:26.409] }
[17:59:26.409] Lazy evaluation: FALSE
[17:59:26.409] Asynchronous evaluation: TRUE
[17:59:26.409] Local evaluation: TRUE
[17:59:26.409] Environment: R_GlobalEnv
[17:59:26.409] Capture standard output: TRUE
[17:59:26.409] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.409] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.409] Packages: <none>
[17:59:26.409] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.409] Resolved: FALSE
[17:59:26.409] Value: <not collected>
[17:59:26.409] Conditions captured: <none>
[17:59:26.409] Early signaling: FALSE
[17:59:26.409] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.409] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.430] Chunk #1 of 2 ... DONE
[17:59:26.431] Chunk #2 of 2 ...
[17:59:26.431] plan(): nbrOfWorkers() = 2
[17:59:26.431]  - Finding globals in 'X' for chunk #2 ...
[17:59:26.431] getGlobalsAndPackages() ...
[17:59:26.432] Searching for globals...
[17:59:26.433] 
[17:59:26.434] Searching for globals ... DONE
[17:59:26.434] - globals: [0] <none>
[17:59:26.434] getGlobalsAndPackages() ... DONE
[17:59:26.435]    + additional globals found: [n=0] 
[17:59:26.435]    + additional namespaces needed: [n=0] 
[17:59:26.435]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:26.436]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:26.436]  - seeds: <none>
[17:59:26.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.437] getGlobalsAndPackages() ...
[17:59:26.437] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.437] Resolving globals: FALSE
[17:59:26.438] Tweak future expression to call with '...' arguments ...
[17:59:26.438] {
[17:59:26.438]     do.call(function(...) {
[17:59:26.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.438]             on.exit(options(oopts), add = TRUE)
[17:59:26.438]         }
[17:59:26.438]         {
[17:59:26.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.438]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.438]             })
[17:59:26.438]         }
[17:59:26.438]     }, args = future.call.arguments)
[17:59:26.438] }
[17:59:26.439] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.440] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.441] 
[17:59:26.441] getGlobalsAndPackages() ... DONE
[17:59:26.442] run() for ‘Future’ ...
[17:59:26.443] - state: ‘created’
[17:59:26.443] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:26.451] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.451] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:26.452]   - Field: ‘label’
[17:59:26.452]   - Field: ‘local’
[17:59:26.452]   - Field: ‘owner’
[17:59:26.452]   - Field: ‘envir’
[17:59:26.453]   - Field: ‘workers’
[17:59:26.453]   - Field: ‘packages’
[17:59:26.453]   - Field: ‘gc’
[17:59:26.454]   - Field: ‘job’
[17:59:26.454]   - Field: ‘conditions’
[17:59:26.454]   - Field: ‘expr’
[17:59:26.454]   - Field: ‘uuid’
[17:59:26.455]   - Field: ‘seed’
[17:59:26.455]   - Field: ‘version’
[17:59:26.455]   - Field: ‘result’
[17:59:26.455]   - Field: ‘asynchronous’
[17:59:26.456]   - Field: ‘calls’
[17:59:26.456]   - Field: ‘globals’
[17:59:26.456]   - Field: ‘stdout’
[17:59:26.457]   - Field: ‘earlySignal’
[17:59:26.457]   - Field: ‘lazy’
[17:59:26.457]   - Field: ‘state’
[17:59:26.458] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:26.458] - Launch lazy future ...
[17:59:26.459] Packages needed by the future expression (n = 0): <none>
[17:59:26.459] Packages needed by future strategies (n = 0): <none>
[17:59:26.460] {
[17:59:26.460]     {
[17:59:26.460]         {
[17:59:26.460]             ...future.startTime <- base::Sys.time()
[17:59:26.460]             {
[17:59:26.460]                 {
[17:59:26.460]                   {
[17:59:26.460]                     {
[17:59:26.460]                       base::local({
[17:59:26.460]                         has_future <- base::requireNamespace("future", 
[17:59:26.460]                           quietly = TRUE)
[17:59:26.460]                         if (has_future) {
[17:59:26.460]                           ns <- base::getNamespace("future")
[17:59:26.460]                           version <- ns[[".package"]][["version"]]
[17:59:26.460]                           if (is.null(version)) 
[17:59:26.460]                             version <- utils::packageVersion("future")
[17:59:26.460]                         }
[17:59:26.460]                         else {
[17:59:26.460]                           version <- NULL
[17:59:26.460]                         }
[17:59:26.460]                         if (!has_future || version < "1.8.0") {
[17:59:26.460]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.460]                             "", base::R.version$version.string), 
[17:59:26.460]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:26.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.460]                               "release", "version")], collapse = " "), 
[17:59:26.460]                             hostname = base::Sys.info()[["nodename"]])
[17:59:26.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.460]                             info)
[17:59:26.460]                           info <- base::paste(info, collapse = "; ")
[17:59:26.460]                           if (!has_future) {
[17:59:26.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.460]                               info)
[17:59:26.460]                           }
[17:59:26.460]                           else {
[17:59:26.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.460]                               info, version)
[17:59:26.460]                           }
[17:59:26.460]                           base::stop(msg)
[17:59:26.460]                         }
[17:59:26.460]                       })
[17:59:26.460]                     }
[17:59:26.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:26.460]                     base::options(mc.cores = 1L)
[17:59:26.460]                   }
[17:59:26.460]                   ...future.strategy.old <- future::plan("list")
[17:59:26.460]                   options(future.plan = NULL)
[17:59:26.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.460]                 }
[17:59:26.460]                 ...future.workdir <- getwd()
[17:59:26.460]             }
[17:59:26.460]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.460]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.460]         }
[17:59:26.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.460]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:26.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.460]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.460]             base::names(...future.oldOptions))
[17:59:26.460]     }
[17:59:26.460]     if (FALSE) {
[17:59:26.460]     }
[17:59:26.460]     else {
[17:59:26.460]         if (TRUE) {
[17:59:26.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.460]                 open = "w")
[17:59:26.460]         }
[17:59:26.460]         else {
[17:59:26.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.460]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.460]         }
[17:59:26.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.460]             base::sink(type = "output", split = FALSE)
[17:59:26.460]             base::close(...future.stdout)
[17:59:26.460]         }, add = TRUE)
[17:59:26.460]     }
[17:59:26.460]     ...future.frame <- base::sys.nframe()
[17:59:26.460]     ...future.conditions <- base::list()
[17:59:26.460]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.460]     if (FALSE) {
[17:59:26.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.460]     }
[17:59:26.460]     ...future.result <- base::tryCatch({
[17:59:26.460]         base::withCallingHandlers({
[17:59:26.460]             ...future.value <- base::withVisible(base::local({
[17:59:26.460]                 withCallingHandlers({
[17:59:26.460]                   {
[17:59:26.460]                     do.call(function(...) {
[17:59:26.460]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.460]                       if (!identical(...future.globals.maxSize.org, 
[17:59:26.460]                         ...future.globals.maxSize)) {
[17:59:26.460]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.460]                         on.exit(options(oopts), add = TRUE)
[17:59:26.460]                       }
[17:59:26.460]                       {
[17:59:26.460]                         lapply(seq_along(...future.elements_ii), 
[17:59:26.460]                           FUN = function(jj) {
[17:59:26.460]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.460]                             ...future.FUN(...future.X_jj, ...)
[17:59:26.460]                           })
[17:59:26.460]                       }
[17:59:26.460]                     }, args = future.call.arguments)
[17:59:26.460]                   }
[17:59:26.460]                 }, immediateCondition = function(cond) {
[17:59:26.460]                   save_rds <- function (object, pathname, ...) 
[17:59:26.460]                   {
[17:59:26.460]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:26.460]                     if (file_test("-f", pathname_tmp)) {
[17:59:26.460]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.460]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:26.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.460]                         fi_tmp[["mtime"]])
[17:59:26.460]                     }
[17:59:26.460]                     tryCatch({
[17:59:26.460]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:26.460]                     }, error = function(ex) {
[17:59:26.460]                       msg <- conditionMessage(ex)
[17:59:26.460]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.460]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:26.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.460]                         fi_tmp[["mtime"]], msg)
[17:59:26.460]                       ex$message <- msg
[17:59:26.460]                       stop(ex)
[17:59:26.460]                     })
[17:59:26.460]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:26.460]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:26.460]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:26.460]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.460]                       fi <- file.info(pathname)
[17:59:26.460]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:26.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.460]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:26.460]                         fi[["size"]], fi[["mtime"]])
[17:59:26.460]                       stop(msg)
[17:59:26.460]                     }
[17:59:26.460]                     invisible(pathname)
[17:59:26.460]                   }
[17:59:26.460]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:26.460]                     rootPath = tempdir()) 
[17:59:26.460]                   {
[17:59:26.460]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:26.460]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:26.460]                       tmpdir = path, fileext = ".rds")
[17:59:26.460]                     save_rds(obj, file)
[17:59:26.460]                   }
[17:59:26.460]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:26.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.460]                   {
[17:59:26.460]                     inherits <- base::inherits
[17:59:26.460]                     invokeRestart <- base::invokeRestart
[17:59:26.460]                     is.null <- base::is.null
[17:59:26.460]                     muffled <- FALSE
[17:59:26.460]                     if (inherits(cond, "message")) {
[17:59:26.460]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:26.460]                       if (muffled) 
[17:59:26.460]                         invokeRestart("muffleMessage")
[17:59:26.460]                     }
[17:59:26.460]                     else if (inherits(cond, "warning")) {
[17:59:26.460]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:26.460]                       if (muffled) 
[17:59:26.460]                         invokeRestart("muffleWarning")
[17:59:26.460]                     }
[17:59:26.460]                     else if (inherits(cond, "condition")) {
[17:59:26.460]                       if (!is.null(pattern)) {
[17:59:26.460]                         computeRestarts <- base::computeRestarts
[17:59:26.460]                         grepl <- base::grepl
[17:59:26.460]                         restarts <- computeRestarts(cond)
[17:59:26.460]                         for (restart in restarts) {
[17:59:26.460]                           name <- restart$name
[17:59:26.460]                           if (is.null(name)) 
[17:59:26.460]                             next
[17:59:26.460]                           if (!grepl(pattern, name)) 
[17:59:26.460]                             next
[17:59:26.460]                           invokeRestart(restart)
[17:59:26.460]                           muffled <- TRUE
[17:59:26.460]                           break
[17:59:26.460]                         }
[17:59:26.460]                       }
[17:59:26.460]                     }
[17:59:26.460]                     invisible(muffled)
[17:59:26.460]                   }
[17:59:26.460]                   muffleCondition(cond)
[17:59:26.460]                 })
[17:59:26.460]             }))
[17:59:26.460]             future::FutureResult(value = ...future.value$value, 
[17:59:26.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.460]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.460]                     ...future.globalenv.names))
[17:59:26.460]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.460]         }, condition = base::local({
[17:59:26.460]             c <- base::c
[17:59:26.460]             inherits <- base::inherits
[17:59:26.460]             invokeRestart <- base::invokeRestart
[17:59:26.460]             length <- base::length
[17:59:26.460]             list <- base::list
[17:59:26.460]             seq.int <- base::seq.int
[17:59:26.460]             signalCondition <- base::signalCondition
[17:59:26.460]             sys.calls <- base::sys.calls
[17:59:26.460]             `[[` <- base::`[[`
[17:59:26.460]             `+` <- base::`+`
[17:59:26.460]             `<<-` <- base::`<<-`
[17:59:26.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.460]                   3L)]
[17:59:26.460]             }
[17:59:26.460]             function(cond) {
[17:59:26.460]                 is_error <- inherits(cond, "error")
[17:59:26.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.460]                   NULL)
[17:59:26.460]                 if (is_error) {
[17:59:26.460]                   sessionInformation <- function() {
[17:59:26.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.460]                       search = base::search(), system = base::Sys.info())
[17:59:26.460]                   }
[17:59:26.460]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.460]                     cond$call), session = sessionInformation(), 
[17:59:26.460]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.460]                   signalCondition(cond)
[17:59:26.460]                 }
[17:59:26.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.460]                 "immediateCondition"))) {
[17:59:26.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.460]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.460]                   if (TRUE && !signal) {
[17:59:26.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.460]                     {
[17:59:26.460]                       inherits <- base::inherits
[17:59:26.460]                       invokeRestart <- base::invokeRestart
[17:59:26.460]                       is.null <- base::is.null
[17:59:26.460]                       muffled <- FALSE
[17:59:26.460]                       if (inherits(cond, "message")) {
[17:59:26.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.460]                         if (muffled) 
[17:59:26.460]                           invokeRestart("muffleMessage")
[17:59:26.460]                       }
[17:59:26.460]                       else if (inherits(cond, "warning")) {
[17:59:26.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.460]                         if (muffled) 
[17:59:26.460]                           invokeRestart("muffleWarning")
[17:59:26.460]                       }
[17:59:26.460]                       else if (inherits(cond, "condition")) {
[17:59:26.460]                         if (!is.null(pattern)) {
[17:59:26.460]                           computeRestarts <- base::computeRestarts
[17:59:26.460]                           grepl <- base::grepl
[17:59:26.460]                           restarts <- computeRestarts(cond)
[17:59:26.460]                           for (restart in restarts) {
[17:59:26.460]                             name <- restart$name
[17:59:26.460]                             if (is.null(name)) 
[17:59:26.460]                               next
[17:59:26.460]                             if (!grepl(pattern, name)) 
[17:59:26.460]                               next
[17:59:26.460]                             invokeRestart(restart)
[17:59:26.460]                             muffled <- TRUE
[17:59:26.460]                             break
[17:59:26.460]                           }
[17:59:26.460]                         }
[17:59:26.460]                       }
[17:59:26.460]                       invisible(muffled)
[17:59:26.460]                     }
[17:59:26.460]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.460]                   }
[17:59:26.460]                 }
[17:59:26.460]                 else {
[17:59:26.460]                   if (TRUE) {
[17:59:26.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.460]                     {
[17:59:26.460]                       inherits <- base::inherits
[17:59:26.460]                       invokeRestart <- base::invokeRestart
[17:59:26.460]                       is.null <- base::is.null
[17:59:26.460]                       muffled <- FALSE
[17:59:26.460]                       if (inherits(cond, "message")) {
[17:59:26.460]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.460]                         if (muffled) 
[17:59:26.460]                           invokeRestart("muffleMessage")
[17:59:26.460]                       }
[17:59:26.460]                       else if (inherits(cond, "warning")) {
[17:59:26.460]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.460]                         if (muffled) 
[17:59:26.460]                           invokeRestart("muffleWarning")
[17:59:26.460]                       }
[17:59:26.460]                       else if (inherits(cond, "condition")) {
[17:59:26.460]                         if (!is.null(pattern)) {
[17:59:26.460]                           computeRestarts <- base::computeRestarts
[17:59:26.460]                           grepl <- base::grepl
[17:59:26.460]                           restarts <- computeRestarts(cond)
[17:59:26.460]                           for (restart in restarts) {
[17:59:26.460]                             name <- restart$name
[17:59:26.460]                             if (is.null(name)) 
[17:59:26.460]                               next
[17:59:26.460]                             if (!grepl(pattern, name)) 
[17:59:26.460]                               next
[17:59:26.460]                             invokeRestart(restart)
[17:59:26.460]                             muffled <- TRUE
[17:59:26.460]                             break
[17:59:26.460]                           }
[17:59:26.460]                         }
[17:59:26.460]                       }
[17:59:26.460]                       invisible(muffled)
[17:59:26.460]                     }
[17:59:26.460]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.460]                   }
[17:59:26.460]                 }
[17:59:26.460]             }
[17:59:26.460]         }))
[17:59:26.460]     }, error = function(ex) {
[17:59:26.460]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.460]                 ...future.rng), started = ...future.startTime, 
[17:59:26.460]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.460]             version = "1.8"), class = "FutureResult")
[17:59:26.460]     }, finally = {
[17:59:26.460]         if (!identical(...future.workdir, getwd())) 
[17:59:26.460]             setwd(...future.workdir)
[17:59:26.460]         {
[17:59:26.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.460]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.460]             }
[17:59:26.460]             base::options(...future.oldOptions)
[17:59:26.460]             if (.Platform$OS.type == "windows") {
[17:59:26.460]                 old_names <- names(...future.oldEnvVars)
[17:59:26.460]                 envs <- base::Sys.getenv()
[17:59:26.460]                 names <- names(envs)
[17:59:26.460]                 common <- intersect(names, old_names)
[17:59:26.460]                 added <- setdiff(names, old_names)
[17:59:26.460]                 removed <- setdiff(old_names, names)
[17:59:26.460]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.460]                   envs[common]]
[17:59:26.460]                 NAMES <- toupper(changed)
[17:59:26.460]                 args <- list()
[17:59:26.460]                 for (kk in seq_along(NAMES)) {
[17:59:26.460]                   name <- changed[[kk]]
[17:59:26.460]                   NAME <- NAMES[[kk]]
[17:59:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.460]                     next
[17:59:26.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.460]                 }
[17:59:26.460]                 NAMES <- toupper(added)
[17:59:26.460]                 for (kk in seq_along(NAMES)) {
[17:59:26.460]                   name <- added[[kk]]
[17:59:26.460]                   NAME <- NAMES[[kk]]
[17:59:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.460]                     next
[17:59:26.460]                   args[[name]] <- ""
[17:59:26.460]                 }
[17:59:26.460]                 NAMES <- toupper(removed)
[17:59:26.460]                 for (kk in seq_along(NAMES)) {
[17:59:26.460]                   name <- removed[[kk]]
[17:59:26.460]                   NAME <- NAMES[[kk]]
[17:59:26.460]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.460]                     next
[17:59:26.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.460]                 }
[17:59:26.460]                 if (length(args) > 0) 
[17:59:26.460]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.460]             }
[17:59:26.460]             else {
[17:59:26.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.460]             }
[17:59:26.460]             {
[17:59:26.460]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.460]                   0L) {
[17:59:26.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.460]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.460]                   base::options(opts)
[17:59:26.460]                 }
[17:59:26.460]                 {
[17:59:26.460]                   {
[17:59:26.460]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:26.460]                     NULL
[17:59:26.460]                   }
[17:59:26.460]                   options(future.plan = NULL)
[17:59:26.460]                   if (is.na(NA_character_)) 
[17:59:26.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.460]                     .init = FALSE)
[17:59:26.460]                 }
[17:59:26.460]             }
[17:59:26.460]         }
[17:59:26.460]     })
[17:59:26.460]     if (TRUE) {
[17:59:26.460]         base::sink(type = "output", split = FALSE)
[17:59:26.460]         if (TRUE) {
[17:59:26.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.460]         }
[17:59:26.460]         else {
[17:59:26.460]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.460]         }
[17:59:26.460]         base::close(...future.stdout)
[17:59:26.460]         ...future.stdout <- NULL
[17:59:26.460]     }
[17:59:26.460]     ...future.result$conditions <- ...future.conditions
[17:59:26.460]     ...future.result$finished <- base::Sys.time()
[17:59:26.460]     ...future.result
[17:59:26.460] }
[17:59:26.467] assign_globals() ...
[17:59:26.467] List of 5
[17:59:26.467]  $ ...future.FUN            :function (object, ...)  
[17:59:26.467]  $ future.call.arguments    : list()
[17:59:26.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.467]  $ ...future.elements_ii    :List of 2
[17:59:26.467]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:26.467]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:26.467]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.467]   ..$ :'data.frame':	18 obs. of  2 variables:
[17:59:26.467]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:26.467]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.467]  $ ...future.seeds_ii       : NULL
[17:59:26.467]  $ ...future.globals.maxSize: NULL
[17:59:26.467]  - attr(*, "where")=List of 5
[17:59:26.467]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.467]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.467]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.467]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.467]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.467]  - attr(*, "resolved")= logi FALSE
[17:59:26.467]  - attr(*, "total_size")= num 1240
[17:59:26.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.467]  - attr(*, "already-done")= logi TRUE
[17:59:26.484] - copied ‘...future.FUN’ to environment
[17:59:26.484] - copied ‘future.call.arguments’ to environment
[17:59:26.484] - copied ‘...future.elements_ii’ to environment
[17:59:26.485] - copied ‘...future.seeds_ii’ to environment
[17:59:26.485] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.485] assign_globals() ... done
[17:59:26.485] requestCore(): workers = 2
[17:59:26.498] MulticoreFuture started
[17:59:26.499] - Launch lazy future ... done
[17:59:26.500] plan(): Setting new future strategy stack:
[17:59:26.500] run() for ‘MulticoreFuture’ ... done
[17:59:26.502] Created future:
[17:59:26.501] List of future strategies:
[17:59:26.501] 1. sequential:
[17:59:26.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.501]    - tweaked: FALSE
[17:59:26.501]    - call: NULL
[17:59:26.505] plan(): nbrOfWorkers() = 1
[17:59:26.514] plan(): Setting new future strategy stack:
[17:59:26.514] List of future strategies:
[17:59:26.514] 1. multicore:
[17:59:26.514]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:26.514]    - tweaked: FALSE
[17:59:26.514]    - call: plan(strategy)
[17:59:26.502] MulticoreFuture:
[17:59:26.502] Label: ‘future_by-2’
[17:59:26.502] Expression:
[17:59:26.502] {
[17:59:26.502]     do.call(function(...) {
[17:59:26.502]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.502]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.502]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.502]             on.exit(options(oopts), add = TRUE)
[17:59:26.502]         }
[17:59:26.502]         {
[17:59:26.502]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.502]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.502]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.502]             })
[17:59:26.502]         }
[17:59:26.502]     }, args = future.call.arguments)
[17:59:26.502] }
[17:59:26.502] Lazy evaluation: FALSE
[17:59:26.502] Asynchronous evaluation: TRUE
[17:59:26.502] Local evaluation: TRUE
[17:59:26.502] Environment: R_GlobalEnv
[17:59:26.502] Capture standard output: TRUE
[17:59:26.502] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.502] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.502] Packages: <none>
[17:59:26.502] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.502] Resolved: FALSE
[17:59:26.502] Value: <not collected>
[17:59:26.502] Conditions captured: <none>
[17:59:26.502] Early signaling: FALSE
[17:59:26.502] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.502] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.521] Chunk #2 of 2 ... DONE
[17:59:26.521] Launching 2 futures (chunks) ... DONE
[17:59:26.521] Resolving 2 futures (chunks) ...
[17:59:26.522] resolve() on list ...
[17:59:26.522]  recursive: 0
[17:59:26.522]  length: 2
[17:59:26.522] 
[17:59:26.523] Future #1
[17:59:26.525] result() for MulticoreFuture ...
[17:59:26.528] plan(): nbrOfWorkers() = 2
[17:59:26.528] result() for MulticoreFuture ...
[17:59:26.529] result() for MulticoreFuture ... done
[17:59:26.529] result() for MulticoreFuture ... done
[17:59:26.529] result() for MulticoreFuture ...
[17:59:26.529] result() for MulticoreFuture ... done
[17:59:26.530] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:26.530] - nx: 2
[17:59:26.531] - relay: TRUE
[17:59:26.531] - stdout: TRUE
[17:59:26.531] - signal: TRUE
[17:59:26.532] - resignal: FALSE
[17:59:26.532] - force: TRUE
[17:59:26.532] - relayed: [n=2] FALSE, FALSE
[17:59:26.533] - queued futures: [n=2] FALSE, FALSE
[17:59:26.533]  - until=1
[17:59:26.533]  - relaying element #1
[17:59:26.533] result() for MulticoreFuture ...
[17:59:26.534] result() for MulticoreFuture ... done
[17:59:26.534] result() for MulticoreFuture ...
[17:59:26.534] result() for MulticoreFuture ... done
[17:59:26.535] result() for MulticoreFuture ...
[17:59:26.535] result() for MulticoreFuture ... done
[17:59:26.536] result() for MulticoreFuture ...
[17:59:26.536] result() for MulticoreFuture ... done
[17:59:26.536] - relayed: [n=2] TRUE, FALSE
[17:59:26.536] - queued futures: [n=2] TRUE, FALSE
[17:59:26.537] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:26.537]  length: 1 (resolved future 1)
[17:59:26.538] Future #2
[17:59:26.538] result() for MulticoreFuture ...
[17:59:26.540] result() for MulticoreFuture ...
[17:59:26.540] result() for MulticoreFuture ... done
[17:59:26.541] result() for MulticoreFuture ... done
[17:59:26.541] result() for MulticoreFuture ...
[17:59:26.541] result() for MulticoreFuture ... done
[17:59:26.542] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:26.542] - nx: 2
[17:59:26.542] - relay: TRUE
[17:59:26.542] - stdout: TRUE
[17:59:26.543] - signal: TRUE
[17:59:26.543] - resignal: FALSE
[17:59:26.543] - force: TRUE
[17:59:26.543] - relayed: [n=2] TRUE, FALSE
[17:59:26.544] - queued futures: [n=2] TRUE, FALSE
[17:59:26.544]  - until=2
[17:59:26.544]  - relaying element #2
[17:59:26.544] result() for MulticoreFuture ...
[17:59:26.545] result() for MulticoreFuture ... done
[17:59:26.545] result() for MulticoreFuture ...
[17:59:26.545] result() for MulticoreFuture ... done
[17:59:26.546] result() for MulticoreFuture ...
[17:59:26.546] result() for MulticoreFuture ... done
[17:59:26.546] result() for MulticoreFuture ...
[17:59:26.546] result() for MulticoreFuture ... done
[17:59:26.547] - relayed: [n=2] TRUE, TRUE
[17:59:26.547] - queued futures: [n=2] TRUE, TRUE
[17:59:26.547] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:26.547]  length: 0 (resolved future 2)
[17:59:26.548] Relaying remaining futures
[17:59:26.548] signalConditionsASAP(NULL, pos=0) ...
[17:59:26.548] - nx: 2
[17:59:26.548] - relay: TRUE
[17:59:26.548] - stdout: TRUE
[17:59:26.549] - signal: TRUE
[17:59:26.549] - resignal: FALSE
[17:59:26.549] - force: TRUE
[17:59:26.549] - relayed: [n=2] TRUE, TRUE
[17:59:26.549] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:26.550] - relayed: [n=2] TRUE, TRUE
[17:59:26.550] - queued futures: [n=2] TRUE, TRUE
[17:59:26.550] signalConditionsASAP(NULL, pos=0) ... done
[17:59:26.551] resolve() on list ... DONE
[17:59:26.551] result() for MulticoreFuture ...
[17:59:26.551] result() for MulticoreFuture ... done
[17:59:26.551] result() for MulticoreFuture ...
[17:59:26.552] result() for MulticoreFuture ... done
[17:59:26.552] result() for MulticoreFuture ...
[17:59:26.552] result() for MulticoreFuture ... done
[17:59:26.552] result() for MulticoreFuture ...
[17:59:26.553] result() for MulticoreFuture ... done
[17:59:26.553]  - Number of value chunks collected: 2
[17:59:26.553] Resolving 2 futures (chunks) ... DONE
[17:59:26.553] Reducing values from 2 chunks ...
[17:59:26.554]  - Number of values collected after concatenation: 3
[17:59:26.554]  - Number of values expected: 3
[17:59:26.554] Reducing values from 2 chunks ... DONE
[17:59:26.554] future_lapply() ... DONE
[17:59:26.554] future_by_internal() ... DONE
[17:59:26.555] future_by_internal() ...
[17:59:26.556] future_lapply() ...
[17:59:26.564] Number of chunks: 2
[17:59:26.564] getGlobalsAndPackagesXApply() ...
[17:59:26.565]  - future.globals: TRUE
[17:59:26.565] getGlobalsAndPackages() ...
[17:59:26.565] Searching for globals...
[17:59:26.568] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:26.568] Searching for globals ... DONE
[17:59:26.568] Resolving globals: FALSE
[17:59:26.572] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:26.573] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:26.574] - globals: [1] ‘FUN’
[17:59:26.574] 
[17:59:26.574] getGlobalsAndPackages() ... DONE
[17:59:26.574]  - globals found/used: [n=1] ‘FUN’
[17:59:26.575]  - needed namespaces: [n=0] 
[17:59:26.575] Finding globals ... DONE
[17:59:26.575]  - use_args: TRUE
[17:59:26.575]  - Getting '...' globals ...
[17:59:26.576] resolve() on list ...
[17:59:26.577]  recursive: 0
[17:59:26.577]  length: 1
[17:59:26.577]  elements: ‘...’
[17:59:26.578]  length: 0 (resolved future 1)
[17:59:26.578] resolve() on list ... DONE
[17:59:26.578]    - '...' content: [n=1] ‘digits’
[17:59:26.578] List of 1
[17:59:26.578]  $ ...:List of 1
[17:59:26.578]   ..$ digits: int 2
[17:59:26.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.578]  - attr(*, "where")=List of 1
[17:59:26.578]   ..$ ...:<environment: 0x62649fd65b88> 
[17:59:26.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.578]  - attr(*, "resolved")= logi TRUE
[17:59:26.578]  - attr(*, "total_size")= num NA
[17:59:26.585]  - Getting '...' globals ... DONE
[17:59:26.586] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:26.586] List of 2
[17:59:26.586]  $ ...future.FUN:function (object, ...)  
[17:59:26.586]  $ ...          :List of 1
[17:59:26.586]   ..$ digits: int 2
[17:59:26.586]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.586]  - attr(*, "where")=List of 2
[17:59:26.586]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:26.586]   ..$ ...          :<environment: 0x62649fd65b88> 
[17:59:26.586]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.586]  - attr(*, "resolved")= logi FALSE
[17:59:26.586]  - attr(*, "total_size")= num 1296
[17:59:26.593] Packages to be attached in all futures: [n=0] 
[17:59:26.594] getGlobalsAndPackagesXApply() ... DONE
[17:59:26.594] Number of futures (= number of chunks): 2
[17:59:26.595] Launching 2 futures (chunks) ...
[17:59:26.595] Chunk #1 of 2 ...
[17:59:26.595]  - Finding globals in 'X' for chunk #1 ...
[17:59:26.595] getGlobalsAndPackages() ...
[17:59:26.595] Searching for globals...
[17:59:26.596] 
[17:59:26.596] Searching for globals ... DONE
[17:59:26.596] - globals: [0] <none>
[17:59:26.597] getGlobalsAndPackages() ... DONE
[17:59:26.597]    + additional globals found: [n=0] 
[17:59:26.597]    + additional namespaces needed: [n=0] 
[17:59:26.597]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:26.598]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:26.598]  - seeds: <none>
[17:59:26.598]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.598] getGlobalsAndPackages() ...
[17:59:26.598] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.599] Resolving globals: FALSE
[17:59:26.599] Tweak future expression to call with '...' arguments ...
[17:59:26.599] {
[17:59:26.599]     do.call(function(...) {
[17:59:26.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.599]             on.exit(options(oopts), add = TRUE)
[17:59:26.599]         }
[17:59:26.599]         {
[17:59:26.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.599]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.599]             })
[17:59:26.599]         }
[17:59:26.599]     }, args = future.call.arguments)
[17:59:26.599] }
[17:59:26.600] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.601] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.601] 
[17:59:26.601] getGlobalsAndPackages() ... DONE
[17:59:26.602] run() for ‘Future’ ...
[17:59:26.602] - state: ‘created’
[17:59:26.602] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:26.609] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:26.610]   - Field: ‘label’
[17:59:26.610]   - Field: ‘local’
[17:59:26.610]   - Field: ‘owner’
[17:59:26.610]   - Field: ‘envir’
[17:59:26.610]   - Field: ‘workers’
[17:59:26.611]   - Field: ‘packages’
[17:59:26.611]   - Field: ‘gc’
[17:59:26.611]   - Field: ‘job’
[17:59:26.611]   - Field: ‘conditions’
[17:59:26.612]   - Field: ‘expr’
[17:59:26.612]   - Field: ‘uuid’
[17:59:26.612]   - Field: ‘seed’
[17:59:26.612]   - Field: ‘version’
[17:59:26.612]   - Field: ‘result’
[17:59:26.613]   - Field: ‘asynchronous’
[17:59:26.613]   - Field: ‘calls’
[17:59:26.613]   - Field: ‘globals’
[17:59:26.613]   - Field: ‘stdout’
[17:59:26.613]   - Field: ‘earlySignal’
[17:59:26.614]   - Field: ‘lazy’
[17:59:26.614]   - Field: ‘state’
[17:59:26.614] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:26.614] - Launch lazy future ...
[17:59:26.615] Packages needed by the future expression (n = 0): <none>
[17:59:26.615] Packages needed by future strategies (n = 0): <none>
[17:59:26.616] {
[17:59:26.616]     {
[17:59:26.616]         {
[17:59:26.616]             ...future.startTime <- base::Sys.time()
[17:59:26.616]             {
[17:59:26.616]                 {
[17:59:26.616]                   {
[17:59:26.616]                     {
[17:59:26.616]                       base::local({
[17:59:26.616]                         has_future <- base::requireNamespace("future", 
[17:59:26.616]                           quietly = TRUE)
[17:59:26.616]                         if (has_future) {
[17:59:26.616]                           ns <- base::getNamespace("future")
[17:59:26.616]                           version <- ns[[".package"]][["version"]]
[17:59:26.616]                           if (is.null(version)) 
[17:59:26.616]                             version <- utils::packageVersion("future")
[17:59:26.616]                         }
[17:59:26.616]                         else {
[17:59:26.616]                           version <- NULL
[17:59:26.616]                         }
[17:59:26.616]                         if (!has_future || version < "1.8.0") {
[17:59:26.616]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.616]                             "", base::R.version$version.string), 
[17:59:26.616]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:26.616]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.616]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.616]                               "release", "version")], collapse = " "), 
[17:59:26.616]                             hostname = base::Sys.info()[["nodename"]])
[17:59:26.616]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.616]                             info)
[17:59:26.616]                           info <- base::paste(info, collapse = "; ")
[17:59:26.616]                           if (!has_future) {
[17:59:26.616]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.616]                               info)
[17:59:26.616]                           }
[17:59:26.616]                           else {
[17:59:26.616]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.616]                               info, version)
[17:59:26.616]                           }
[17:59:26.616]                           base::stop(msg)
[17:59:26.616]                         }
[17:59:26.616]                       })
[17:59:26.616]                     }
[17:59:26.616]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:26.616]                     base::options(mc.cores = 1L)
[17:59:26.616]                   }
[17:59:26.616]                   ...future.strategy.old <- future::plan("list")
[17:59:26.616]                   options(future.plan = NULL)
[17:59:26.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.616]                 }
[17:59:26.616]                 ...future.workdir <- getwd()
[17:59:26.616]             }
[17:59:26.616]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.616]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.616]         }
[17:59:26.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.616]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:26.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.616]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.616]             base::names(...future.oldOptions))
[17:59:26.616]     }
[17:59:26.616]     if (FALSE) {
[17:59:26.616]     }
[17:59:26.616]     else {
[17:59:26.616]         if (TRUE) {
[17:59:26.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.616]                 open = "w")
[17:59:26.616]         }
[17:59:26.616]         else {
[17:59:26.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.616]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.616]         }
[17:59:26.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.616]             base::sink(type = "output", split = FALSE)
[17:59:26.616]             base::close(...future.stdout)
[17:59:26.616]         }, add = TRUE)
[17:59:26.616]     }
[17:59:26.616]     ...future.frame <- base::sys.nframe()
[17:59:26.616]     ...future.conditions <- base::list()
[17:59:26.616]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.616]     if (FALSE) {
[17:59:26.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.616]     }
[17:59:26.616]     ...future.result <- base::tryCatch({
[17:59:26.616]         base::withCallingHandlers({
[17:59:26.616]             ...future.value <- base::withVisible(base::local({
[17:59:26.616]                 withCallingHandlers({
[17:59:26.616]                   {
[17:59:26.616]                     do.call(function(...) {
[17:59:26.616]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.616]                       if (!identical(...future.globals.maxSize.org, 
[17:59:26.616]                         ...future.globals.maxSize)) {
[17:59:26.616]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.616]                         on.exit(options(oopts), add = TRUE)
[17:59:26.616]                       }
[17:59:26.616]                       {
[17:59:26.616]                         lapply(seq_along(...future.elements_ii), 
[17:59:26.616]                           FUN = function(jj) {
[17:59:26.616]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.616]                             ...future.FUN(...future.X_jj, ...)
[17:59:26.616]                           })
[17:59:26.616]                       }
[17:59:26.616]                     }, args = future.call.arguments)
[17:59:26.616]                   }
[17:59:26.616]                 }, immediateCondition = function(cond) {
[17:59:26.616]                   save_rds <- function (object, pathname, ...) 
[17:59:26.616]                   {
[17:59:26.616]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:26.616]                     if (file_test("-f", pathname_tmp)) {
[17:59:26.616]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.616]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:26.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.616]                         fi_tmp[["mtime"]])
[17:59:26.616]                     }
[17:59:26.616]                     tryCatch({
[17:59:26.616]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:26.616]                     }, error = function(ex) {
[17:59:26.616]                       msg <- conditionMessage(ex)
[17:59:26.616]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.616]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:26.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.616]                         fi_tmp[["mtime"]], msg)
[17:59:26.616]                       ex$message <- msg
[17:59:26.616]                       stop(ex)
[17:59:26.616]                     })
[17:59:26.616]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:26.616]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:26.616]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:26.616]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.616]                       fi <- file.info(pathname)
[17:59:26.616]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:26.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.616]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:26.616]                         fi[["size"]], fi[["mtime"]])
[17:59:26.616]                       stop(msg)
[17:59:26.616]                     }
[17:59:26.616]                     invisible(pathname)
[17:59:26.616]                   }
[17:59:26.616]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:26.616]                     rootPath = tempdir()) 
[17:59:26.616]                   {
[17:59:26.616]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:26.616]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:26.616]                       tmpdir = path, fileext = ".rds")
[17:59:26.616]                     save_rds(obj, file)
[17:59:26.616]                   }
[17:59:26.616]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:26.616]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.616]                   {
[17:59:26.616]                     inherits <- base::inherits
[17:59:26.616]                     invokeRestart <- base::invokeRestart
[17:59:26.616]                     is.null <- base::is.null
[17:59:26.616]                     muffled <- FALSE
[17:59:26.616]                     if (inherits(cond, "message")) {
[17:59:26.616]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:26.616]                       if (muffled) 
[17:59:26.616]                         invokeRestart("muffleMessage")
[17:59:26.616]                     }
[17:59:26.616]                     else if (inherits(cond, "warning")) {
[17:59:26.616]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:26.616]                       if (muffled) 
[17:59:26.616]                         invokeRestart("muffleWarning")
[17:59:26.616]                     }
[17:59:26.616]                     else if (inherits(cond, "condition")) {
[17:59:26.616]                       if (!is.null(pattern)) {
[17:59:26.616]                         computeRestarts <- base::computeRestarts
[17:59:26.616]                         grepl <- base::grepl
[17:59:26.616]                         restarts <- computeRestarts(cond)
[17:59:26.616]                         for (restart in restarts) {
[17:59:26.616]                           name <- restart$name
[17:59:26.616]                           if (is.null(name)) 
[17:59:26.616]                             next
[17:59:26.616]                           if (!grepl(pattern, name)) 
[17:59:26.616]                             next
[17:59:26.616]                           invokeRestart(restart)
[17:59:26.616]                           muffled <- TRUE
[17:59:26.616]                           break
[17:59:26.616]                         }
[17:59:26.616]                       }
[17:59:26.616]                     }
[17:59:26.616]                     invisible(muffled)
[17:59:26.616]                   }
[17:59:26.616]                   muffleCondition(cond)
[17:59:26.616]                 })
[17:59:26.616]             }))
[17:59:26.616]             future::FutureResult(value = ...future.value$value, 
[17:59:26.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.616]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.616]                     ...future.globalenv.names))
[17:59:26.616]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.616]         }, condition = base::local({
[17:59:26.616]             c <- base::c
[17:59:26.616]             inherits <- base::inherits
[17:59:26.616]             invokeRestart <- base::invokeRestart
[17:59:26.616]             length <- base::length
[17:59:26.616]             list <- base::list
[17:59:26.616]             seq.int <- base::seq.int
[17:59:26.616]             signalCondition <- base::signalCondition
[17:59:26.616]             sys.calls <- base::sys.calls
[17:59:26.616]             `[[` <- base::`[[`
[17:59:26.616]             `+` <- base::`+`
[17:59:26.616]             `<<-` <- base::`<<-`
[17:59:26.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.616]                   3L)]
[17:59:26.616]             }
[17:59:26.616]             function(cond) {
[17:59:26.616]                 is_error <- inherits(cond, "error")
[17:59:26.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.616]                   NULL)
[17:59:26.616]                 if (is_error) {
[17:59:26.616]                   sessionInformation <- function() {
[17:59:26.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.616]                       search = base::search(), system = base::Sys.info())
[17:59:26.616]                   }
[17:59:26.616]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.616]                     cond$call), session = sessionInformation(), 
[17:59:26.616]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.616]                   signalCondition(cond)
[17:59:26.616]                 }
[17:59:26.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.616]                 "immediateCondition"))) {
[17:59:26.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.616]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.616]                   if (TRUE && !signal) {
[17:59:26.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.616]                     {
[17:59:26.616]                       inherits <- base::inherits
[17:59:26.616]                       invokeRestart <- base::invokeRestart
[17:59:26.616]                       is.null <- base::is.null
[17:59:26.616]                       muffled <- FALSE
[17:59:26.616]                       if (inherits(cond, "message")) {
[17:59:26.616]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.616]                         if (muffled) 
[17:59:26.616]                           invokeRestart("muffleMessage")
[17:59:26.616]                       }
[17:59:26.616]                       else if (inherits(cond, "warning")) {
[17:59:26.616]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.616]                         if (muffled) 
[17:59:26.616]                           invokeRestart("muffleWarning")
[17:59:26.616]                       }
[17:59:26.616]                       else if (inherits(cond, "condition")) {
[17:59:26.616]                         if (!is.null(pattern)) {
[17:59:26.616]                           computeRestarts <- base::computeRestarts
[17:59:26.616]                           grepl <- base::grepl
[17:59:26.616]                           restarts <- computeRestarts(cond)
[17:59:26.616]                           for (restart in restarts) {
[17:59:26.616]                             name <- restart$name
[17:59:26.616]                             if (is.null(name)) 
[17:59:26.616]                               next
[17:59:26.616]                             if (!grepl(pattern, name)) 
[17:59:26.616]                               next
[17:59:26.616]                             invokeRestart(restart)
[17:59:26.616]                             muffled <- TRUE
[17:59:26.616]                             break
[17:59:26.616]                           }
[17:59:26.616]                         }
[17:59:26.616]                       }
[17:59:26.616]                       invisible(muffled)
[17:59:26.616]                     }
[17:59:26.616]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.616]                   }
[17:59:26.616]                 }
[17:59:26.616]                 else {
[17:59:26.616]                   if (TRUE) {
[17:59:26.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.616]                     {
[17:59:26.616]                       inherits <- base::inherits
[17:59:26.616]                       invokeRestart <- base::invokeRestart
[17:59:26.616]                       is.null <- base::is.null
[17:59:26.616]                       muffled <- FALSE
[17:59:26.616]                       if (inherits(cond, "message")) {
[17:59:26.616]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.616]                         if (muffled) 
[17:59:26.616]                           invokeRestart("muffleMessage")
[17:59:26.616]                       }
[17:59:26.616]                       else if (inherits(cond, "warning")) {
[17:59:26.616]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.616]                         if (muffled) 
[17:59:26.616]                           invokeRestart("muffleWarning")
[17:59:26.616]                       }
[17:59:26.616]                       else if (inherits(cond, "condition")) {
[17:59:26.616]                         if (!is.null(pattern)) {
[17:59:26.616]                           computeRestarts <- base::computeRestarts
[17:59:26.616]                           grepl <- base::grepl
[17:59:26.616]                           restarts <- computeRestarts(cond)
[17:59:26.616]                           for (restart in restarts) {
[17:59:26.616]                             name <- restart$name
[17:59:26.616]                             if (is.null(name)) 
[17:59:26.616]                               next
[17:59:26.616]                             if (!grepl(pattern, name)) 
[17:59:26.616]                               next
[17:59:26.616]                             invokeRestart(restart)
[17:59:26.616]                             muffled <- TRUE
[17:59:26.616]                             break
[17:59:26.616]                           }
[17:59:26.616]                         }
[17:59:26.616]                       }
[17:59:26.616]                       invisible(muffled)
[17:59:26.616]                     }
[17:59:26.616]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.616]                   }
[17:59:26.616]                 }
[17:59:26.616]             }
[17:59:26.616]         }))
[17:59:26.616]     }, error = function(ex) {
[17:59:26.616]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.616]                 ...future.rng), started = ...future.startTime, 
[17:59:26.616]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.616]             version = "1.8"), class = "FutureResult")
[17:59:26.616]     }, finally = {
[17:59:26.616]         if (!identical(...future.workdir, getwd())) 
[17:59:26.616]             setwd(...future.workdir)
[17:59:26.616]         {
[17:59:26.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.616]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.616]             }
[17:59:26.616]             base::options(...future.oldOptions)
[17:59:26.616]             if (.Platform$OS.type == "windows") {
[17:59:26.616]                 old_names <- names(...future.oldEnvVars)
[17:59:26.616]                 envs <- base::Sys.getenv()
[17:59:26.616]                 names <- names(envs)
[17:59:26.616]                 common <- intersect(names, old_names)
[17:59:26.616]                 added <- setdiff(names, old_names)
[17:59:26.616]                 removed <- setdiff(old_names, names)
[17:59:26.616]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.616]                   envs[common]]
[17:59:26.616]                 NAMES <- toupper(changed)
[17:59:26.616]                 args <- list()
[17:59:26.616]                 for (kk in seq_along(NAMES)) {
[17:59:26.616]                   name <- changed[[kk]]
[17:59:26.616]                   NAME <- NAMES[[kk]]
[17:59:26.616]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.616]                     next
[17:59:26.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.616]                 }
[17:59:26.616]                 NAMES <- toupper(added)
[17:59:26.616]                 for (kk in seq_along(NAMES)) {
[17:59:26.616]                   name <- added[[kk]]
[17:59:26.616]                   NAME <- NAMES[[kk]]
[17:59:26.616]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.616]                     next
[17:59:26.616]                   args[[name]] <- ""
[17:59:26.616]                 }
[17:59:26.616]                 NAMES <- toupper(removed)
[17:59:26.616]                 for (kk in seq_along(NAMES)) {
[17:59:26.616]                   name <- removed[[kk]]
[17:59:26.616]                   NAME <- NAMES[[kk]]
[17:59:26.616]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.616]                     next
[17:59:26.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.616]                 }
[17:59:26.616]                 if (length(args) > 0) 
[17:59:26.616]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.616]             }
[17:59:26.616]             else {
[17:59:26.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.616]             }
[17:59:26.616]             {
[17:59:26.616]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.616]                   0L) {
[17:59:26.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.616]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.616]                   base::options(opts)
[17:59:26.616]                 }
[17:59:26.616]                 {
[17:59:26.616]                   {
[17:59:26.616]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:26.616]                     NULL
[17:59:26.616]                   }
[17:59:26.616]                   options(future.plan = NULL)
[17:59:26.616]                   if (is.na(NA_character_)) 
[17:59:26.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.616]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.616]                     .init = FALSE)
[17:59:26.616]                 }
[17:59:26.616]             }
[17:59:26.616]         }
[17:59:26.616]     })
[17:59:26.616]     if (TRUE) {
[17:59:26.616]         base::sink(type = "output", split = FALSE)
[17:59:26.616]         if (TRUE) {
[17:59:26.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.616]         }
[17:59:26.616]         else {
[17:59:26.616]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.616]         }
[17:59:26.616]         base::close(...future.stdout)
[17:59:26.616]         ...future.stdout <- NULL
[17:59:26.616]     }
[17:59:26.616]     ...future.result$conditions <- ...future.conditions
[17:59:26.616]     ...future.result$finished <- base::Sys.time()
[17:59:26.616]     ...future.result
[17:59:26.616] }
[17:59:26.621] assign_globals() ...
[17:59:26.621] List of 5
[17:59:26.621]  $ ...future.FUN            :function (object, ...)  
[17:59:26.621]  $ future.call.arguments    :List of 1
[17:59:26.621]   ..$ digits: int 2
[17:59:26.621]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.621]  $ ...future.elements_ii    :List of 3
[17:59:26.621]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[17:59:26.621]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[17:59:26.621]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[17:59:26.621]  $ ...future.seeds_ii       : NULL
[17:59:26.621]  $ ...future.globals.maxSize: NULL
[17:59:26.621]  - attr(*, "where")=List of 5
[17:59:26.621]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.621]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.621]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.621]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.621]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.621]  - attr(*, "resolved")= logi FALSE
[17:59:26.621]  - attr(*, "total_size")= num 1296
[17:59:26.621]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.621]  - attr(*, "already-done")= logi TRUE
[17:59:26.638] - copied ‘...future.FUN’ to environment
[17:59:26.638] - copied ‘future.call.arguments’ to environment
[17:59:26.638] - copied ‘...future.elements_ii’ to environment
[17:59:26.638] - copied ‘...future.seeds_ii’ to environment
[17:59:26.638] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.639] assign_globals() ... done
[17:59:26.639] requestCore(): workers = 2
[17:59:26.642] MulticoreFuture started
[17:59:26.643] - Launch lazy future ... done
[17:59:26.644] run() for ‘MulticoreFuture’ ... done
[17:59:26.644] Created future:
[17:59:26.648] plan(): Setting new future strategy stack:
[17:59:26.649] List of future strategies:
[17:59:26.649] 1. sequential:
[17:59:26.649]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.649]    - tweaked: FALSE
[17:59:26.649]    - call: NULL
[17:59:26.651] plan(): nbrOfWorkers() = 1
[17:59:26.657] plan(): Setting new future strategy stack:
[17:59:26.658] List of future strategies:
[17:59:26.658] 1. multicore:
[17:59:26.658]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:26.658]    - tweaked: FALSE
[17:59:26.658]    - call: plan(strategy)
[17:59:26.645] MulticoreFuture:
[17:59:26.645] Label: ‘future_by-1’
[17:59:26.645] Expression:
[17:59:26.645] {
[17:59:26.645]     do.call(function(...) {
[17:59:26.645]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.645]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.645]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.645]             on.exit(options(oopts), add = TRUE)
[17:59:26.645]         }
[17:59:26.645]         {
[17:59:26.645]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.645]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.645]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.645]             })
[17:59:26.645]         }
[17:59:26.645]     }, args = future.call.arguments)
[17:59:26.645] }
[17:59:26.645] Lazy evaluation: FALSE
[17:59:26.645] Asynchronous evaluation: TRUE
[17:59:26.645] Local evaluation: TRUE
[17:59:26.645] Environment: R_GlobalEnv
[17:59:26.645] Capture standard output: TRUE
[17:59:26.645] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.645] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.645] Packages: <none>
[17:59:26.645] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.645] Resolved: FALSE
[17:59:26.645] Value: <not collected>
[17:59:26.645] Conditions captured: <none>
[17:59:26.645] Early signaling: FALSE
[17:59:26.645] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.645] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.661] Chunk #1 of 2 ... DONE
[17:59:26.663] Chunk #2 of 2 ...
[17:59:26.663]  - Finding globals in 'X' for chunk #2 ...
[17:59:26.664] getGlobalsAndPackages() ...
[17:59:26.664] Searching for globals...
[17:59:26.666] 
[17:59:26.666] Searching for globals ... DONE
[17:59:26.667] - globals: [0] <none>
[17:59:26.667] getGlobalsAndPackages() ... DONE
[17:59:26.667]    + additional globals found: [n=0] 
[17:59:26.668]    + additional namespaces needed: [n=0] 
[17:59:26.668]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:26.668]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:26.669]  - seeds: <none>
[17:59:26.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.672] getGlobalsAndPackages() ...
[17:59:26.673] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.673] Resolving globals: FALSE
[17:59:26.674] Tweak future expression to call with '...' arguments ...
[17:59:26.676] {
[17:59:26.676]     do.call(function(...) {
[17:59:26.676]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.676]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.676]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.676]             on.exit(options(oopts), add = TRUE)
[17:59:26.676]         }
[17:59:26.676]         {
[17:59:26.676]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.676]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.676]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.676]             })
[17:59:26.676]         }
[17:59:26.676]     }, args = future.call.arguments)
[17:59:26.676] }
[17:59:26.677] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.675] plan(): nbrOfWorkers() = 2
[17:59:26.679] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.679] 
[17:59:26.680] getGlobalsAndPackages() ... DONE
[17:59:26.681] run() for ‘Future’ ...
[17:59:26.681] - state: ‘created’
[17:59:26.682] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:26.690] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:26.691]   - Field: ‘label’
[17:59:26.691]   - Field: ‘local’
[17:59:26.691]   - Field: ‘owner’
[17:59:26.692]   - Field: ‘envir’
[17:59:26.692]   - Field: ‘workers’
[17:59:26.692]   - Field: ‘packages’
[17:59:26.693]   - Field: ‘gc’
[17:59:26.693]   - Field: ‘job’
[17:59:26.693]   - Field: ‘conditions’
[17:59:26.694]   - Field: ‘expr’
[17:59:26.694]   - Field: ‘uuid’
[17:59:26.694]   - Field: ‘seed’
[17:59:26.695]   - Field: ‘version’
[17:59:26.695]   - Field: ‘result’
[17:59:26.695]   - Field: ‘asynchronous’
[17:59:26.695]   - Field: ‘calls’
[17:59:26.696]   - Field: ‘globals’
[17:59:26.696]   - Field: ‘stdout’
[17:59:26.696]   - Field: ‘earlySignal’
[17:59:26.697]   - Field: ‘lazy’
[17:59:26.697]   - Field: ‘state’
[17:59:26.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:26.698] - Launch lazy future ...
[17:59:26.698] Packages needed by the future expression (n = 0): <none>
[17:59:26.699] Packages needed by future strategies (n = 0): <none>
[17:59:26.700] {
[17:59:26.700]     {
[17:59:26.700]         {
[17:59:26.700]             ...future.startTime <- base::Sys.time()
[17:59:26.700]             {
[17:59:26.700]                 {
[17:59:26.700]                   {
[17:59:26.700]                     {
[17:59:26.700]                       base::local({
[17:59:26.700]                         has_future <- base::requireNamespace("future", 
[17:59:26.700]                           quietly = TRUE)
[17:59:26.700]                         if (has_future) {
[17:59:26.700]                           ns <- base::getNamespace("future")
[17:59:26.700]                           version <- ns[[".package"]][["version"]]
[17:59:26.700]                           if (is.null(version)) 
[17:59:26.700]                             version <- utils::packageVersion("future")
[17:59:26.700]                         }
[17:59:26.700]                         else {
[17:59:26.700]                           version <- NULL
[17:59:26.700]                         }
[17:59:26.700]                         if (!has_future || version < "1.8.0") {
[17:59:26.700]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.700]                             "", base::R.version$version.string), 
[17:59:26.700]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:26.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:26.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.700]                               "release", "version")], collapse = " "), 
[17:59:26.700]                             hostname = base::Sys.info()[["nodename"]])
[17:59:26.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.700]                             info)
[17:59:26.700]                           info <- base::paste(info, collapse = "; ")
[17:59:26.700]                           if (!has_future) {
[17:59:26.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.700]                               info)
[17:59:26.700]                           }
[17:59:26.700]                           else {
[17:59:26.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.700]                               info, version)
[17:59:26.700]                           }
[17:59:26.700]                           base::stop(msg)
[17:59:26.700]                         }
[17:59:26.700]                       })
[17:59:26.700]                     }
[17:59:26.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:26.700]                     base::options(mc.cores = 1L)
[17:59:26.700]                   }
[17:59:26.700]                   ...future.strategy.old <- future::plan("list")
[17:59:26.700]                   options(future.plan = NULL)
[17:59:26.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.700]                 }
[17:59:26.700]                 ...future.workdir <- getwd()
[17:59:26.700]             }
[17:59:26.700]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.700]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.700]         }
[17:59:26.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.700]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:26.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.700]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.700]             base::names(...future.oldOptions))
[17:59:26.700]     }
[17:59:26.700]     if (FALSE) {
[17:59:26.700]     }
[17:59:26.700]     else {
[17:59:26.700]         if (TRUE) {
[17:59:26.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.700]                 open = "w")
[17:59:26.700]         }
[17:59:26.700]         else {
[17:59:26.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.700]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.700]         }
[17:59:26.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.700]             base::sink(type = "output", split = FALSE)
[17:59:26.700]             base::close(...future.stdout)
[17:59:26.700]         }, add = TRUE)
[17:59:26.700]     }
[17:59:26.700]     ...future.frame <- base::sys.nframe()
[17:59:26.700]     ...future.conditions <- base::list()
[17:59:26.700]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.700]     if (FALSE) {
[17:59:26.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.700]     }
[17:59:26.700]     ...future.result <- base::tryCatch({
[17:59:26.700]         base::withCallingHandlers({
[17:59:26.700]             ...future.value <- base::withVisible(base::local({
[17:59:26.700]                 withCallingHandlers({
[17:59:26.700]                   {
[17:59:26.700]                     do.call(function(...) {
[17:59:26.700]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.700]                       if (!identical(...future.globals.maxSize.org, 
[17:59:26.700]                         ...future.globals.maxSize)) {
[17:59:26.700]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.700]                         on.exit(options(oopts), add = TRUE)
[17:59:26.700]                       }
[17:59:26.700]                       {
[17:59:26.700]                         lapply(seq_along(...future.elements_ii), 
[17:59:26.700]                           FUN = function(jj) {
[17:59:26.700]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.700]                             ...future.FUN(...future.X_jj, ...)
[17:59:26.700]                           })
[17:59:26.700]                       }
[17:59:26.700]                     }, args = future.call.arguments)
[17:59:26.700]                   }
[17:59:26.700]                 }, immediateCondition = function(cond) {
[17:59:26.700]                   save_rds <- function (object, pathname, ...) 
[17:59:26.700]                   {
[17:59:26.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:26.700]                     if (file_test("-f", pathname_tmp)) {
[17:59:26.700]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:26.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.700]                         fi_tmp[["mtime"]])
[17:59:26.700]                     }
[17:59:26.700]                     tryCatch({
[17:59:26.700]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:26.700]                     }, error = function(ex) {
[17:59:26.700]                       msg <- conditionMessage(ex)
[17:59:26.700]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:26.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.700]                         fi_tmp[["mtime"]], msg)
[17:59:26.700]                       ex$message <- msg
[17:59:26.700]                       stop(ex)
[17:59:26.700]                     })
[17:59:26.700]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:26.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:26.700]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:26.700]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.700]                       fi <- file.info(pathname)
[17:59:26.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:26.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:26.700]                         fi[["size"]], fi[["mtime"]])
[17:59:26.700]                       stop(msg)
[17:59:26.700]                     }
[17:59:26.700]                     invisible(pathname)
[17:59:26.700]                   }
[17:59:26.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:26.700]                     rootPath = tempdir()) 
[17:59:26.700]                   {
[17:59:26.700]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:26.700]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:26.700]                       tmpdir = path, fileext = ".rds")
[17:59:26.700]                     save_rds(obj, file)
[17:59:26.700]                   }
[17:59:26.700]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:26.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.700]                   {
[17:59:26.700]                     inherits <- base::inherits
[17:59:26.700]                     invokeRestart <- base::invokeRestart
[17:59:26.700]                     is.null <- base::is.null
[17:59:26.700]                     muffled <- FALSE
[17:59:26.700]                     if (inherits(cond, "message")) {
[17:59:26.700]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:26.700]                       if (muffled) 
[17:59:26.700]                         invokeRestart("muffleMessage")
[17:59:26.700]                     }
[17:59:26.700]                     else if (inherits(cond, "warning")) {
[17:59:26.700]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:26.700]                       if (muffled) 
[17:59:26.700]                         invokeRestart("muffleWarning")
[17:59:26.700]                     }
[17:59:26.700]                     else if (inherits(cond, "condition")) {
[17:59:26.700]                       if (!is.null(pattern)) {
[17:59:26.700]                         computeRestarts <- base::computeRestarts
[17:59:26.700]                         grepl <- base::grepl
[17:59:26.700]                         restarts <- computeRestarts(cond)
[17:59:26.700]                         for (restart in restarts) {
[17:59:26.700]                           name <- restart$name
[17:59:26.700]                           if (is.null(name)) 
[17:59:26.700]                             next
[17:59:26.700]                           if (!grepl(pattern, name)) 
[17:59:26.700]                             next
[17:59:26.700]                           invokeRestart(restart)
[17:59:26.700]                           muffled <- TRUE
[17:59:26.700]                           break
[17:59:26.700]                         }
[17:59:26.700]                       }
[17:59:26.700]                     }
[17:59:26.700]                     invisible(muffled)
[17:59:26.700]                   }
[17:59:26.700]                   muffleCondition(cond)
[17:59:26.700]                 })
[17:59:26.700]             }))
[17:59:26.700]             future::FutureResult(value = ...future.value$value, 
[17:59:26.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.700]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.700]                     ...future.globalenv.names))
[17:59:26.700]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.700]         }, condition = base::local({
[17:59:26.700]             c <- base::c
[17:59:26.700]             inherits <- base::inherits
[17:59:26.700]             invokeRestart <- base::invokeRestart
[17:59:26.700]             length <- base::length
[17:59:26.700]             list <- base::list
[17:59:26.700]             seq.int <- base::seq.int
[17:59:26.700]             signalCondition <- base::signalCondition
[17:59:26.700]             sys.calls <- base::sys.calls
[17:59:26.700]             `[[` <- base::`[[`
[17:59:26.700]             `+` <- base::`+`
[17:59:26.700]             `<<-` <- base::`<<-`
[17:59:26.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.700]                   3L)]
[17:59:26.700]             }
[17:59:26.700]             function(cond) {
[17:59:26.700]                 is_error <- inherits(cond, "error")
[17:59:26.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.700]                   NULL)
[17:59:26.700]                 if (is_error) {
[17:59:26.700]                   sessionInformation <- function() {
[17:59:26.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.700]                       search = base::search(), system = base::Sys.info())
[17:59:26.700]                   }
[17:59:26.700]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.700]                     cond$call), session = sessionInformation(), 
[17:59:26.700]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.700]                   signalCondition(cond)
[17:59:26.700]                 }
[17:59:26.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.700]                 "immediateCondition"))) {
[17:59:26.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.700]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.700]                   if (TRUE && !signal) {
[17:59:26.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.700]                     {
[17:59:26.700]                       inherits <- base::inherits
[17:59:26.700]                       invokeRestart <- base::invokeRestart
[17:59:26.700]                       is.null <- base::is.null
[17:59:26.700]                       muffled <- FALSE
[17:59:26.700]                       if (inherits(cond, "message")) {
[17:59:26.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.700]                         if (muffled) 
[17:59:26.700]                           invokeRestart("muffleMessage")
[17:59:26.700]                       }
[17:59:26.700]                       else if (inherits(cond, "warning")) {
[17:59:26.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.700]                         if (muffled) 
[17:59:26.700]                           invokeRestart("muffleWarning")
[17:59:26.700]                       }
[17:59:26.700]                       else if (inherits(cond, "condition")) {
[17:59:26.700]                         if (!is.null(pattern)) {
[17:59:26.700]                           computeRestarts <- base::computeRestarts
[17:59:26.700]                           grepl <- base::grepl
[17:59:26.700]                           restarts <- computeRestarts(cond)
[17:59:26.700]                           for (restart in restarts) {
[17:59:26.700]                             name <- restart$name
[17:59:26.700]                             if (is.null(name)) 
[17:59:26.700]                               next
[17:59:26.700]                             if (!grepl(pattern, name)) 
[17:59:26.700]                               next
[17:59:26.700]                             invokeRestart(restart)
[17:59:26.700]                             muffled <- TRUE
[17:59:26.700]                             break
[17:59:26.700]                           }
[17:59:26.700]                         }
[17:59:26.700]                       }
[17:59:26.700]                       invisible(muffled)
[17:59:26.700]                     }
[17:59:26.700]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.700]                   }
[17:59:26.700]                 }
[17:59:26.700]                 else {
[17:59:26.700]                   if (TRUE) {
[17:59:26.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.700]                     {
[17:59:26.700]                       inherits <- base::inherits
[17:59:26.700]                       invokeRestart <- base::invokeRestart
[17:59:26.700]                       is.null <- base::is.null
[17:59:26.700]                       muffled <- FALSE
[17:59:26.700]                       if (inherits(cond, "message")) {
[17:59:26.700]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.700]                         if (muffled) 
[17:59:26.700]                           invokeRestart("muffleMessage")
[17:59:26.700]                       }
[17:59:26.700]                       else if (inherits(cond, "warning")) {
[17:59:26.700]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.700]                         if (muffled) 
[17:59:26.700]                           invokeRestart("muffleWarning")
[17:59:26.700]                       }
[17:59:26.700]                       else if (inherits(cond, "condition")) {
[17:59:26.700]                         if (!is.null(pattern)) {
[17:59:26.700]                           computeRestarts <- base::computeRestarts
[17:59:26.700]                           grepl <- base::grepl
[17:59:26.700]                           restarts <- computeRestarts(cond)
[17:59:26.700]                           for (restart in restarts) {
[17:59:26.700]                             name <- restart$name
[17:59:26.700]                             if (is.null(name)) 
[17:59:26.700]                               next
[17:59:26.700]                             if (!grepl(pattern, name)) 
[17:59:26.700]                               next
[17:59:26.700]                             invokeRestart(restart)
[17:59:26.700]                             muffled <- TRUE
[17:59:26.700]                             break
[17:59:26.700]                           }
[17:59:26.700]                         }
[17:59:26.700]                       }
[17:59:26.700]                       invisible(muffled)
[17:59:26.700]                     }
[17:59:26.700]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.700]                   }
[17:59:26.700]                 }
[17:59:26.700]             }
[17:59:26.700]         }))
[17:59:26.700]     }, error = function(ex) {
[17:59:26.700]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.700]                 ...future.rng), started = ...future.startTime, 
[17:59:26.700]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.700]             version = "1.8"), class = "FutureResult")
[17:59:26.700]     }, finally = {
[17:59:26.700]         if (!identical(...future.workdir, getwd())) 
[17:59:26.700]             setwd(...future.workdir)
[17:59:26.700]         {
[17:59:26.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.700]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.700]             }
[17:59:26.700]             base::options(...future.oldOptions)
[17:59:26.700]             if (.Platform$OS.type == "windows") {
[17:59:26.700]                 old_names <- names(...future.oldEnvVars)
[17:59:26.700]                 envs <- base::Sys.getenv()
[17:59:26.700]                 names <- names(envs)
[17:59:26.700]                 common <- intersect(names, old_names)
[17:59:26.700]                 added <- setdiff(names, old_names)
[17:59:26.700]                 removed <- setdiff(old_names, names)
[17:59:26.700]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.700]                   envs[common]]
[17:59:26.700]                 NAMES <- toupper(changed)
[17:59:26.700]                 args <- list()
[17:59:26.700]                 for (kk in seq_along(NAMES)) {
[17:59:26.700]                   name <- changed[[kk]]
[17:59:26.700]                   NAME <- NAMES[[kk]]
[17:59:26.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.700]                     next
[17:59:26.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.700]                 }
[17:59:26.700]                 NAMES <- toupper(added)
[17:59:26.700]                 for (kk in seq_along(NAMES)) {
[17:59:26.700]                   name <- added[[kk]]
[17:59:26.700]                   NAME <- NAMES[[kk]]
[17:59:26.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.700]                     next
[17:59:26.700]                   args[[name]] <- ""
[17:59:26.700]                 }
[17:59:26.700]                 NAMES <- toupper(removed)
[17:59:26.700]                 for (kk in seq_along(NAMES)) {
[17:59:26.700]                   name <- removed[[kk]]
[17:59:26.700]                   NAME <- NAMES[[kk]]
[17:59:26.700]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.700]                     next
[17:59:26.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.700]                 }
[17:59:26.700]                 if (length(args) > 0) 
[17:59:26.700]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.700]             }
[17:59:26.700]             else {
[17:59:26.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.700]             }
[17:59:26.700]             {
[17:59:26.700]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.700]                   0L) {
[17:59:26.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.700]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.700]                   base::options(opts)
[17:59:26.700]                 }
[17:59:26.700]                 {
[17:59:26.700]                   {
[17:59:26.700]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:26.700]                     NULL
[17:59:26.700]                   }
[17:59:26.700]                   options(future.plan = NULL)
[17:59:26.700]                   if (is.na(NA_character_)) 
[17:59:26.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.700]                     .init = FALSE)
[17:59:26.700]                 }
[17:59:26.700]             }
[17:59:26.700]         }
[17:59:26.700]     })
[17:59:26.700]     if (TRUE) {
[17:59:26.700]         base::sink(type = "output", split = FALSE)
[17:59:26.700]         if (TRUE) {
[17:59:26.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.700]         }
[17:59:26.700]         else {
[17:59:26.700]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.700]         }
[17:59:26.700]         base::close(...future.stdout)
[17:59:26.700]         ...future.stdout <- NULL
[17:59:26.700]     }
[17:59:26.700]     ...future.result$conditions <- ...future.conditions
[17:59:26.700]     ...future.result$finished <- base::Sys.time()
[17:59:26.700]     ...future.result
[17:59:26.700] }
[17:59:26.707] assign_globals() ...
[17:59:26.707] List of 5
[17:59:26.707]  $ ...future.FUN            :function (object, ...)  
[17:59:26.707]  $ future.call.arguments    :List of 1
[17:59:26.707]   ..$ digits: int 2
[17:59:26.707]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.707]  $ ...future.elements_ii    :List of 3
[17:59:26.707]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[17:59:26.707]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[17:59:26.707]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[17:59:26.707]  $ ...future.seeds_ii       : NULL
[17:59:26.707]  $ ...future.globals.maxSize: NULL
[17:59:26.707]  - attr(*, "where")=List of 5
[17:59:26.707]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.707]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.707]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.707]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.707]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.707]  - attr(*, "resolved")= logi FALSE
[17:59:26.707]  - attr(*, "total_size")= num 1296
[17:59:26.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.707]  - attr(*, "already-done")= logi TRUE
[17:59:26.733] - copied ‘...future.FUN’ to environment
[17:59:26.733] - copied ‘future.call.arguments’ to environment
[17:59:26.733] - copied ‘...future.elements_ii’ to environment
[17:59:26.734] - copied ‘...future.seeds_ii’ to environment
[17:59:26.734] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.734] assign_globals() ... done
[17:59:26.735] requestCore(): workers = 2
[17:59:26.738] MulticoreFuture started
[17:59:26.739] - Launch lazy future ... done
[17:59:26.740] run() for ‘MulticoreFuture’ ... done
[17:59:26.740] Created future:
[17:59:26.740] plan(): Setting new future strategy stack:
[17:59:26.741] List of future strategies:
[17:59:26.741] 1. sequential:
[17:59:26.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.741]    - tweaked: FALSE
[17:59:26.741]    - call: NULL
[17:59:26.744] plan(): nbrOfWorkers() = 1
[17:59:26.751] plan(): Setting new future strategy stack:
[17:59:26.751] List of future strategies:
[17:59:26.751] 1. multicore:
[17:59:26.751]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:26.751]    - tweaked: FALSE
[17:59:26.751]    - call: plan(strategy)
[17:59:26.741] MulticoreFuture:
[17:59:26.741] Label: ‘future_by-2’
[17:59:26.741] Expression:
[17:59:26.741] {
[17:59:26.741]     do.call(function(...) {
[17:59:26.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.741]             on.exit(options(oopts), add = TRUE)
[17:59:26.741]         }
[17:59:26.741]         {
[17:59:26.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.741]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.741]             })
[17:59:26.741]         }
[17:59:26.741]     }, args = future.call.arguments)
[17:59:26.741] }
[17:59:26.741] Lazy evaluation: FALSE
[17:59:26.741] Asynchronous evaluation: TRUE
[17:59:26.741] Local evaluation: TRUE
[17:59:26.741] Environment: R_GlobalEnv
[17:59:26.741] Capture standard output: TRUE
[17:59:26.741] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.741] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.741] Packages: <none>
[17:59:26.741] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.741] Resolved: FALSE
[17:59:26.741] Value: <not collected>
[17:59:26.741] Conditions captured: <none>
[17:59:26.741] Early signaling: FALSE
[17:59:26.741] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.741] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.758] Chunk #2 of 2 ... DONE
[17:59:26.759] Launching 2 futures (chunks) ... DONE
[17:59:26.759] Resolving 2 futures (chunks) ...
[17:59:26.760] resolve() on list ...
[17:59:26.760]  recursive: 0
[17:59:26.760]  length: 2
[17:59:26.761] 
[17:59:26.761] plan(): nbrOfWorkers() = 2
[17:59:26.761] Future #1
[17:59:26.762] result() for MulticoreFuture ...
[17:59:26.764] result() for MulticoreFuture ...
[17:59:26.765] result() for MulticoreFuture ... done
[17:59:26.765] result() for MulticoreFuture ... done
[17:59:26.765] result() for MulticoreFuture ...
[17:59:26.766] result() for MulticoreFuture ... done
[17:59:26.766] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:26.767] - nx: 2
[17:59:26.767] - relay: TRUE
[17:59:26.767] - stdout: TRUE
[17:59:26.767] - signal: TRUE
[17:59:26.768] - resignal: FALSE
[17:59:26.768] - force: TRUE
[17:59:26.768] - relayed: [n=2] FALSE, FALSE
[17:59:26.769] - queued futures: [n=2] FALSE, FALSE
[17:59:26.769]  - until=1
[17:59:26.769]  - relaying element #1
[17:59:26.770] result() for MulticoreFuture ...
[17:59:26.770] result() for MulticoreFuture ... done
[17:59:26.771] result() for MulticoreFuture ...
[17:59:26.771] result() for MulticoreFuture ... done
[17:59:26.771] result() for MulticoreFuture ...
[17:59:26.772] result() for MulticoreFuture ... done
[17:59:26.772] result() for MulticoreFuture ...
[17:59:26.772] result() for MulticoreFuture ... done
[17:59:26.773] - relayed: [n=2] TRUE, FALSE
[17:59:26.773] - queued futures: [n=2] TRUE, FALSE
[17:59:26.773] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:26.773]  length: 1 (resolved future 1)
[17:59:26.774] Future #2
[17:59:26.775] result() for MulticoreFuture ...
[17:59:26.776] result() for MulticoreFuture ...
[17:59:26.776] result() for MulticoreFuture ... done
[17:59:26.777] result() for MulticoreFuture ... done
[17:59:26.777] result() for MulticoreFuture ...
[17:59:26.777] result() for MulticoreFuture ... done
[17:59:26.778] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:26.778] - nx: 2
[17:59:26.778] - relay: TRUE
[17:59:26.779] - stdout: TRUE
[17:59:26.779] - signal: TRUE
[17:59:26.779] - resignal: FALSE
[17:59:26.779] - force: TRUE
[17:59:26.779] - relayed: [n=2] TRUE, FALSE
[17:59:26.780] - queued futures: [n=2] TRUE, FALSE
[17:59:26.780]  - until=2
[17:59:26.780]  - relaying element #2
[17:59:26.780] result() for MulticoreFuture ...
[17:59:26.781] result() for MulticoreFuture ... done
[17:59:26.781] result() for MulticoreFuture ...
[17:59:26.781] result() for MulticoreFuture ... done
[17:59:26.781] result() for MulticoreFuture ...
[17:59:26.782] result() for MulticoreFuture ... done
[17:59:26.782] result() for MulticoreFuture ...
[17:59:26.782] result() for MulticoreFuture ... done
[17:59:26.782] - relayed: [n=2] TRUE, TRUE
[17:59:26.783] - queued futures: [n=2] TRUE, TRUE
[17:59:26.783] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:26.783]  length: 0 (resolved future 2)
[17:59:26.783] Relaying remaining futures
[17:59:26.783] signalConditionsASAP(NULL, pos=0) ...
[17:59:26.784] - nx: 2
[17:59:26.784] - relay: TRUE
[17:59:26.784] - stdout: TRUE
[17:59:26.784] - signal: TRUE
[17:59:26.785] - resignal: FALSE
[17:59:26.785] - force: TRUE
[17:59:26.785] - relayed: [n=2] TRUE, TRUE
[17:59:26.785] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:26.786] - relayed: [n=2] TRUE, TRUE
[17:59:26.786] - queued futures: [n=2] TRUE, TRUE
[17:59:26.786] signalConditionsASAP(NULL, pos=0) ... done
[17:59:26.786] resolve() on list ... DONE
[17:59:26.786] result() for MulticoreFuture ...
[17:59:26.787] result() for MulticoreFuture ... done
[17:59:26.787] result() for MulticoreFuture ...
[17:59:26.787] result() for MulticoreFuture ... done
[17:59:26.787] result() for MulticoreFuture ...
[17:59:26.788] result() for MulticoreFuture ... done
[17:59:26.788] result() for MulticoreFuture ...
[17:59:26.788] result() for MulticoreFuture ... done
[17:59:26.788]  - Number of value chunks collected: 2
[17:59:26.789] Resolving 2 futures (chunks) ... DONE
[17:59:26.789] Reducing values from 2 chunks ...
[17:59:26.790]  - Number of values collected after concatenation: 6
[17:59:26.790]  - Number of values expected: 6
[17:59:26.790] Reducing values from 2 chunks ... DONE
[17:59:26.790] future_lapply() ... DONE
[17:59:26.790] future_by_internal() ... DONE
[17:59:26.796] future_by_internal() ...
[17:59:26.797] future_lapply() ...
[17:59:26.807] Number of chunks: 2
[17:59:26.808] getGlobalsAndPackagesXApply() ...
[17:59:26.808]  - future.globals: TRUE
[17:59:26.808] getGlobalsAndPackages() ...
[17:59:26.808] Searching for globals...
[17:59:26.812] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:26.812] Searching for globals ... DONE
[17:59:26.813] Resolving globals: FALSE
[17:59:26.813] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:59:26.814] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:59:26.814] - globals: [1] ‘FUN’
[17:59:26.815] - packages: [1] ‘stats’
[17:59:26.815] getGlobalsAndPackages() ... DONE
[17:59:26.815]  - globals found/used: [n=1] ‘FUN’
[17:59:26.815]  - needed namespaces: [n=1] ‘stats’
[17:59:26.816] Finding globals ... DONE
[17:59:26.816]  - use_args: TRUE
[17:59:26.816]  - Getting '...' globals ...
[17:59:26.817] resolve() on list ...
[17:59:26.817]  recursive: 0
[17:59:26.817]  length: 1
[17:59:26.817]  elements: ‘...’
[17:59:26.818]  length: 0 (resolved future 1)
[17:59:26.818] resolve() on list ... DONE
[17:59:26.818]    - '...' content: [n=1] ‘singular.ok’
[17:59:26.818] List of 1
[17:59:26.818]  $ ...:List of 1
[17:59:26.818]   ..$ singular.ok: logi FALSE
[17:59:26.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.818]  - attr(*, "where")=List of 1
[17:59:26.818]   ..$ ...:<environment: 0x6264a00fe158> 
[17:59:26.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.818]  - attr(*, "resolved")= logi TRUE
[17:59:26.818]  - attr(*, "total_size")= num NA
[17:59:26.824]  - Getting '...' globals ... DONE
[17:59:26.825] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:26.825] List of 2
[17:59:26.825]  $ ...future.FUN:function (x, ...)  
[17:59:26.825]  $ ...          :List of 1
[17:59:26.825]   ..$ singular.ok: logi FALSE
[17:59:26.825]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.825]  - attr(*, "where")=List of 2
[17:59:26.825]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:26.825]   ..$ ...          :<environment: 0x6264a00fe158> 
[17:59:26.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.825]  - attr(*, "resolved")= logi FALSE
[17:59:26.825]  - attr(*, "total_size")= num 5384
[17:59:26.831] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:26.831] getGlobalsAndPackagesXApply() ... DONE
[17:59:26.832] Number of futures (= number of chunks): 2
[17:59:26.832] Launching 2 futures (chunks) ...
[17:59:26.832] Chunk #1 of 2 ...
[17:59:26.832]  - Finding globals in 'X' for chunk #1 ...
[17:59:26.833] getGlobalsAndPackages() ...
[17:59:26.833] Searching for globals...
[17:59:26.834] 
[17:59:26.834] Searching for globals ... DONE
[17:59:26.834] - globals: [0] <none>
[17:59:26.834] getGlobalsAndPackages() ... DONE
[17:59:26.834]    + additional globals found: [n=0] 
[17:59:26.834]    + additional namespaces needed: [n=0] 
[17:59:26.835]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:26.835]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:26.835]  - seeds: <none>
[17:59:26.835]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.836] getGlobalsAndPackages() ...
[17:59:26.836] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.836] Resolving globals: FALSE
[17:59:26.836] Tweak future expression to call with '...' arguments ...
[17:59:26.836] {
[17:59:26.836]     do.call(function(...) {
[17:59:26.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.836]             on.exit(options(oopts), add = TRUE)
[17:59:26.836]         }
[17:59:26.836]         {
[17:59:26.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.836]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.836]             })
[17:59:26.836]         }
[17:59:26.836]     }, args = future.call.arguments)
[17:59:26.836] }
[17:59:26.837] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.838] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.838] 
[17:59:26.841] getGlobalsAndPackages() ... DONE
[17:59:26.842] run() for ‘Future’ ...
[17:59:26.842] - state: ‘created’
[17:59:26.842] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:26.849] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:26.850]   - Field: ‘label’
[17:59:26.850]   - Field: ‘local’
[17:59:26.850]   - Field: ‘owner’
[17:59:26.850]   - Field: ‘envir’
[17:59:26.851]   - Field: ‘workers’
[17:59:26.851]   - Field: ‘packages’
[17:59:26.851]   - Field: ‘gc’
[17:59:26.851]   - Field: ‘job’
[17:59:26.851]   - Field: ‘conditions’
[17:59:26.852]   - Field: ‘expr’
[17:59:26.852]   - Field: ‘uuid’
[17:59:26.852]   - Field: ‘seed’
[17:59:26.852]   - Field: ‘version’
[17:59:26.852]   - Field: ‘result’
[17:59:26.853]   - Field: ‘asynchronous’
[17:59:26.853]   - Field: ‘calls’
[17:59:26.853]   - Field: ‘globals’
[17:59:26.853]   - Field: ‘stdout’
[17:59:26.854]   - Field: ‘earlySignal’
[17:59:26.854]   - Field: ‘lazy’
[17:59:26.854]   - Field: ‘state’
[17:59:26.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:26.854] - Launch lazy future ...
[17:59:26.855] Packages needed by the future expression (n = 1): ‘stats’
[17:59:26.855] Packages needed by future strategies (n = 0): <none>
[17:59:26.856] {
[17:59:26.856]     {
[17:59:26.856]         {
[17:59:26.856]             ...future.startTime <- base::Sys.time()
[17:59:26.856]             {
[17:59:26.856]                 {
[17:59:26.856]                   {
[17:59:26.856]                     {
[17:59:26.856]                       {
[17:59:26.856]                         base::local({
[17:59:26.856]                           has_future <- base::requireNamespace("future", 
[17:59:26.856]                             quietly = TRUE)
[17:59:26.856]                           if (has_future) {
[17:59:26.856]                             ns <- base::getNamespace("future")
[17:59:26.856]                             version <- ns[[".package"]][["version"]]
[17:59:26.856]                             if (is.null(version)) 
[17:59:26.856]                               version <- utils::packageVersion("future")
[17:59:26.856]                           }
[17:59:26.856]                           else {
[17:59:26.856]                             version <- NULL
[17:59:26.856]                           }
[17:59:26.856]                           if (!has_future || version < "1.8.0") {
[17:59:26.856]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.856]                               "", base::R.version$version.string), 
[17:59:26.856]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:26.856]                                 base::R.version$platform, 8 * 
[17:59:26.856]                                   base::.Machine$sizeof.pointer), 
[17:59:26.856]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.856]                                 "release", "version")], collapse = " "), 
[17:59:26.856]                               hostname = base::Sys.info()[["nodename"]])
[17:59:26.856]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.856]                               info)
[17:59:26.856]                             info <- base::paste(info, collapse = "; ")
[17:59:26.856]                             if (!has_future) {
[17:59:26.856]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.856]                                 info)
[17:59:26.856]                             }
[17:59:26.856]                             else {
[17:59:26.856]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.856]                                 info, version)
[17:59:26.856]                             }
[17:59:26.856]                             base::stop(msg)
[17:59:26.856]                           }
[17:59:26.856]                         })
[17:59:26.856]                       }
[17:59:26.856]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:26.856]                       base::options(mc.cores = 1L)
[17:59:26.856]                     }
[17:59:26.856]                     base::local({
[17:59:26.856]                       for (pkg in "stats") {
[17:59:26.856]                         base::loadNamespace(pkg)
[17:59:26.856]                         base::library(pkg, character.only = TRUE)
[17:59:26.856]                       }
[17:59:26.856]                     })
[17:59:26.856]                   }
[17:59:26.856]                   ...future.strategy.old <- future::plan("list")
[17:59:26.856]                   options(future.plan = NULL)
[17:59:26.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.856]                 }
[17:59:26.856]                 ...future.workdir <- getwd()
[17:59:26.856]             }
[17:59:26.856]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.856]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.856]         }
[17:59:26.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.856]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:26.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.856]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.856]             base::names(...future.oldOptions))
[17:59:26.856]     }
[17:59:26.856]     if (FALSE) {
[17:59:26.856]     }
[17:59:26.856]     else {
[17:59:26.856]         if (TRUE) {
[17:59:26.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.856]                 open = "w")
[17:59:26.856]         }
[17:59:26.856]         else {
[17:59:26.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.856]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.856]         }
[17:59:26.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.856]             base::sink(type = "output", split = FALSE)
[17:59:26.856]             base::close(...future.stdout)
[17:59:26.856]         }, add = TRUE)
[17:59:26.856]     }
[17:59:26.856]     ...future.frame <- base::sys.nframe()
[17:59:26.856]     ...future.conditions <- base::list()
[17:59:26.856]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.856]     if (FALSE) {
[17:59:26.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.856]     }
[17:59:26.856]     ...future.result <- base::tryCatch({
[17:59:26.856]         base::withCallingHandlers({
[17:59:26.856]             ...future.value <- base::withVisible(base::local({
[17:59:26.856]                 withCallingHandlers({
[17:59:26.856]                   {
[17:59:26.856]                     do.call(function(...) {
[17:59:26.856]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.856]                       if (!identical(...future.globals.maxSize.org, 
[17:59:26.856]                         ...future.globals.maxSize)) {
[17:59:26.856]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.856]                         on.exit(options(oopts), add = TRUE)
[17:59:26.856]                       }
[17:59:26.856]                       {
[17:59:26.856]                         lapply(seq_along(...future.elements_ii), 
[17:59:26.856]                           FUN = function(jj) {
[17:59:26.856]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.856]                             ...future.FUN(...future.X_jj, ...)
[17:59:26.856]                           })
[17:59:26.856]                       }
[17:59:26.856]                     }, args = future.call.arguments)
[17:59:26.856]                   }
[17:59:26.856]                 }, immediateCondition = function(cond) {
[17:59:26.856]                   save_rds <- function (object, pathname, ...) 
[17:59:26.856]                   {
[17:59:26.856]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:26.856]                     if (file_test("-f", pathname_tmp)) {
[17:59:26.856]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.856]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:26.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.856]                         fi_tmp[["mtime"]])
[17:59:26.856]                     }
[17:59:26.856]                     tryCatch({
[17:59:26.856]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:26.856]                     }, error = function(ex) {
[17:59:26.856]                       msg <- conditionMessage(ex)
[17:59:26.856]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.856]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:26.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.856]                         fi_tmp[["mtime"]], msg)
[17:59:26.856]                       ex$message <- msg
[17:59:26.856]                       stop(ex)
[17:59:26.856]                     })
[17:59:26.856]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:26.856]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:26.856]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:26.856]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.856]                       fi <- file.info(pathname)
[17:59:26.856]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:26.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.856]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:26.856]                         fi[["size"]], fi[["mtime"]])
[17:59:26.856]                       stop(msg)
[17:59:26.856]                     }
[17:59:26.856]                     invisible(pathname)
[17:59:26.856]                   }
[17:59:26.856]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:26.856]                     rootPath = tempdir()) 
[17:59:26.856]                   {
[17:59:26.856]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:26.856]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:26.856]                       tmpdir = path, fileext = ".rds")
[17:59:26.856]                     save_rds(obj, file)
[17:59:26.856]                   }
[17:59:26.856]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:26.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.856]                   {
[17:59:26.856]                     inherits <- base::inherits
[17:59:26.856]                     invokeRestart <- base::invokeRestart
[17:59:26.856]                     is.null <- base::is.null
[17:59:26.856]                     muffled <- FALSE
[17:59:26.856]                     if (inherits(cond, "message")) {
[17:59:26.856]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:26.856]                       if (muffled) 
[17:59:26.856]                         invokeRestart("muffleMessage")
[17:59:26.856]                     }
[17:59:26.856]                     else if (inherits(cond, "warning")) {
[17:59:26.856]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:26.856]                       if (muffled) 
[17:59:26.856]                         invokeRestart("muffleWarning")
[17:59:26.856]                     }
[17:59:26.856]                     else if (inherits(cond, "condition")) {
[17:59:26.856]                       if (!is.null(pattern)) {
[17:59:26.856]                         computeRestarts <- base::computeRestarts
[17:59:26.856]                         grepl <- base::grepl
[17:59:26.856]                         restarts <- computeRestarts(cond)
[17:59:26.856]                         for (restart in restarts) {
[17:59:26.856]                           name <- restart$name
[17:59:26.856]                           if (is.null(name)) 
[17:59:26.856]                             next
[17:59:26.856]                           if (!grepl(pattern, name)) 
[17:59:26.856]                             next
[17:59:26.856]                           invokeRestart(restart)
[17:59:26.856]                           muffled <- TRUE
[17:59:26.856]                           break
[17:59:26.856]                         }
[17:59:26.856]                       }
[17:59:26.856]                     }
[17:59:26.856]                     invisible(muffled)
[17:59:26.856]                   }
[17:59:26.856]                   muffleCondition(cond)
[17:59:26.856]                 })
[17:59:26.856]             }))
[17:59:26.856]             future::FutureResult(value = ...future.value$value, 
[17:59:26.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.856]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.856]                     ...future.globalenv.names))
[17:59:26.856]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.856]         }, condition = base::local({
[17:59:26.856]             c <- base::c
[17:59:26.856]             inherits <- base::inherits
[17:59:26.856]             invokeRestart <- base::invokeRestart
[17:59:26.856]             length <- base::length
[17:59:26.856]             list <- base::list
[17:59:26.856]             seq.int <- base::seq.int
[17:59:26.856]             signalCondition <- base::signalCondition
[17:59:26.856]             sys.calls <- base::sys.calls
[17:59:26.856]             `[[` <- base::`[[`
[17:59:26.856]             `+` <- base::`+`
[17:59:26.856]             `<<-` <- base::`<<-`
[17:59:26.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.856]                   3L)]
[17:59:26.856]             }
[17:59:26.856]             function(cond) {
[17:59:26.856]                 is_error <- inherits(cond, "error")
[17:59:26.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.856]                   NULL)
[17:59:26.856]                 if (is_error) {
[17:59:26.856]                   sessionInformation <- function() {
[17:59:26.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.856]                       search = base::search(), system = base::Sys.info())
[17:59:26.856]                   }
[17:59:26.856]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.856]                     cond$call), session = sessionInformation(), 
[17:59:26.856]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.856]                   signalCondition(cond)
[17:59:26.856]                 }
[17:59:26.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.856]                 "immediateCondition"))) {
[17:59:26.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.856]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.856]                   if (TRUE && !signal) {
[17:59:26.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.856]                     {
[17:59:26.856]                       inherits <- base::inherits
[17:59:26.856]                       invokeRestart <- base::invokeRestart
[17:59:26.856]                       is.null <- base::is.null
[17:59:26.856]                       muffled <- FALSE
[17:59:26.856]                       if (inherits(cond, "message")) {
[17:59:26.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.856]                         if (muffled) 
[17:59:26.856]                           invokeRestart("muffleMessage")
[17:59:26.856]                       }
[17:59:26.856]                       else if (inherits(cond, "warning")) {
[17:59:26.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.856]                         if (muffled) 
[17:59:26.856]                           invokeRestart("muffleWarning")
[17:59:26.856]                       }
[17:59:26.856]                       else if (inherits(cond, "condition")) {
[17:59:26.856]                         if (!is.null(pattern)) {
[17:59:26.856]                           computeRestarts <- base::computeRestarts
[17:59:26.856]                           grepl <- base::grepl
[17:59:26.856]                           restarts <- computeRestarts(cond)
[17:59:26.856]                           for (restart in restarts) {
[17:59:26.856]                             name <- restart$name
[17:59:26.856]                             if (is.null(name)) 
[17:59:26.856]                               next
[17:59:26.856]                             if (!grepl(pattern, name)) 
[17:59:26.856]                               next
[17:59:26.856]                             invokeRestart(restart)
[17:59:26.856]                             muffled <- TRUE
[17:59:26.856]                             break
[17:59:26.856]                           }
[17:59:26.856]                         }
[17:59:26.856]                       }
[17:59:26.856]                       invisible(muffled)
[17:59:26.856]                     }
[17:59:26.856]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.856]                   }
[17:59:26.856]                 }
[17:59:26.856]                 else {
[17:59:26.856]                   if (TRUE) {
[17:59:26.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.856]                     {
[17:59:26.856]                       inherits <- base::inherits
[17:59:26.856]                       invokeRestart <- base::invokeRestart
[17:59:26.856]                       is.null <- base::is.null
[17:59:26.856]                       muffled <- FALSE
[17:59:26.856]                       if (inherits(cond, "message")) {
[17:59:26.856]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.856]                         if (muffled) 
[17:59:26.856]                           invokeRestart("muffleMessage")
[17:59:26.856]                       }
[17:59:26.856]                       else if (inherits(cond, "warning")) {
[17:59:26.856]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.856]                         if (muffled) 
[17:59:26.856]                           invokeRestart("muffleWarning")
[17:59:26.856]                       }
[17:59:26.856]                       else if (inherits(cond, "condition")) {
[17:59:26.856]                         if (!is.null(pattern)) {
[17:59:26.856]                           computeRestarts <- base::computeRestarts
[17:59:26.856]                           grepl <- base::grepl
[17:59:26.856]                           restarts <- computeRestarts(cond)
[17:59:26.856]                           for (restart in restarts) {
[17:59:26.856]                             name <- restart$name
[17:59:26.856]                             if (is.null(name)) 
[17:59:26.856]                               next
[17:59:26.856]                             if (!grepl(pattern, name)) 
[17:59:26.856]                               next
[17:59:26.856]                             invokeRestart(restart)
[17:59:26.856]                             muffled <- TRUE
[17:59:26.856]                             break
[17:59:26.856]                           }
[17:59:26.856]                         }
[17:59:26.856]                       }
[17:59:26.856]                       invisible(muffled)
[17:59:26.856]                     }
[17:59:26.856]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.856]                   }
[17:59:26.856]                 }
[17:59:26.856]             }
[17:59:26.856]         }))
[17:59:26.856]     }, error = function(ex) {
[17:59:26.856]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.856]                 ...future.rng), started = ...future.startTime, 
[17:59:26.856]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.856]             version = "1.8"), class = "FutureResult")
[17:59:26.856]     }, finally = {
[17:59:26.856]         if (!identical(...future.workdir, getwd())) 
[17:59:26.856]             setwd(...future.workdir)
[17:59:26.856]         {
[17:59:26.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.856]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.856]             }
[17:59:26.856]             base::options(...future.oldOptions)
[17:59:26.856]             if (.Platform$OS.type == "windows") {
[17:59:26.856]                 old_names <- names(...future.oldEnvVars)
[17:59:26.856]                 envs <- base::Sys.getenv()
[17:59:26.856]                 names <- names(envs)
[17:59:26.856]                 common <- intersect(names, old_names)
[17:59:26.856]                 added <- setdiff(names, old_names)
[17:59:26.856]                 removed <- setdiff(old_names, names)
[17:59:26.856]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.856]                   envs[common]]
[17:59:26.856]                 NAMES <- toupper(changed)
[17:59:26.856]                 args <- list()
[17:59:26.856]                 for (kk in seq_along(NAMES)) {
[17:59:26.856]                   name <- changed[[kk]]
[17:59:26.856]                   NAME <- NAMES[[kk]]
[17:59:26.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.856]                     next
[17:59:26.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.856]                 }
[17:59:26.856]                 NAMES <- toupper(added)
[17:59:26.856]                 for (kk in seq_along(NAMES)) {
[17:59:26.856]                   name <- added[[kk]]
[17:59:26.856]                   NAME <- NAMES[[kk]]
[17:59:26.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.856]                     next
[17:59:26.856]                   args[[name]] <- ""
[17:59:26.856]                 }
[17:59:26.856]                 NAMES <- toupper(removed)
[17:59:26.856]                 for (kk in seq_along(NAMES)) {
[17:59:26.856]                   name <- removed[[kk]]
[17:59:26.856]                   NAME <- NAMES[[kk]]
[17:59:26.856]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.856]                     next
[17:59:26.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.856]                 }
[17:59:26.856]                 if (length(args) > 0) 
[17:59:26.856]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.856]             }
[17:59:26.856]             else {
[17:59:26.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.856]             }
[17:59:26.856]             {
[17:59:26.856]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.856]                   0L) {
[17:59:26.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.856]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.856]                   base::options(opts)
[17:59:26.856]                 }
[17:59:26.856]                 {
[17:59:26.856]                   {
[17:59:26.856]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:26.856]                     NULL
[17:59:26.856]                   }
[17:59:26.856]                   options(future.plan = NULL)
[17:59:26.856]                   if (is.na(NA_character_)) 
[17:59:26.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.856]                     .init = FALSE)
[17:59:26.856]                 }
[17:59:26.856]             }
[17:59:26.856]         }
[17:59:26.856]     })
[17:59:26.856]     if (TRUE) {
[17:59:26.856]         base::sink(type = "output", split = FALSE)
[17:59:26.856]         if (TRUE) {
[17:59:26.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.856]         }
[17:59:26.856]         else {
[17:59:26.856]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.856]         }
[17:59:26.856]         base::close(...future.stdout)
[17:59:26.856]         ...future.stdout <- NULL
[17:59:26.856]     }
[17:59:26.856]     ...future.result$conditions <- ...future.conditions
[17:59:26.856]     ...future.result$finished <- base::Sys.time()
[17:59:26.856]     ...future.result
[17:59:26.856] }
[17:59:26.861] assign_globals() ...
[17:59:26.861] List of 5
[17:59:26.861]  $ ...future.FUN            :function (x, ...)  
[17:59:26.861]  $ future.call.arguments    :List of 1
[17:59:26.861]   ..$ singular.ok: logi FALSE
[17:59:26.861]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.861]  $ ...future.elements_ii    :List of 1
[17:59:26.861]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.861]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:26.861]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.861]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:26.861]  $ ...future.seeds_ii       : NULL
[17:59:26.861]  $ ...future.globals.maxSize: NULL
[17:59:26.861]  - attr(*, "where")=List of 5
[17:59:26.861]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.861]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.861]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.861]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.861]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.861]  - attr(*, "resolved")= logi FALSE
[17:59:26.861]  - attr(*, "total_size")= num 5384
[17:59:26.861]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.861]  - attr(*, "already-done")= logi TRUE
[17:59:26.874] - reassign environment for ‘...future.FUN’
[17:59:26.874] - copied ‘...future.FUN’ to environment
[17:59:26.874] - copied ‘future.call.arguments’ to environment
[17:59:26.875] - copied ‘...future.elements_ii’ to environment
[17:59:26.875] - copied ‘...future.seeds_ii’ to environment
[17:59:26.875] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.875] assign_globals() ... done
[17:59:26.876] requestCore(): workers = 2
[17:59:26.879] MulticoreFuture started
[17:59:26.880] - Launch lazy future ... done
[17:59:26.880] run() for ‘MulticoreFuture’ ... done
[17:59:26.882] plan(): Setting new future strategy stack:
[17:59:26.881] Created future:
[17:59:26.882] List of future strategies:
[17:59:26.882] 1. sequential:
[17:59:26.882]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.882]    - tweaked: FALSE
[17:59:26.882]    - call: NULL
[17:59:26.885] plan(): nbrOfWorkers() = 1
[17:59:26.894] plan(): Setting new future strategy stack:
[17:59:26.895] List of future strategies:
[17:59:26.895] 1. multicore:
[17:59:26.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:26.895]    - tweaked: FALSE
[17:59:26.895]    - call: plan(strategy)
[17:59:26.883] MulticoreFuture:
[17:59:26.883] Label: ‘future_by-1’
[17:59:26.883] Expression:
[17:59:26.883] {
[17:59:26.883]     do.call(function(...) {
[17:59:26.883]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.883]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.883]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.883]             on.exit(options(oopts), add = TRUE)
[17:59:26.883]         }
[17:59:26.883]         {
[17:59:26.883]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.883]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.883]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.883]             })
[17:59:26.883]         }
[17:59:26.883]     }, args = future.call.arguments)
[17:59:26.883] }
[17:59:26.883] Lazy evaluation: FALSE
[17:59:26.883] Asynchronous evaluation: TRUE
[17:59:26.883] Local evaluation: TRUE
[17:59:26.883] Environment: R_GlobalEnv
[17:59:26.883] Capture standard output: TRUE
[17:59:26.883] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.883] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.883] Packages: 1 packages (‘stats’)
[17:59:26.883] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.883] Resolved: FALSE
[17:59:26.883] Value: <not collected>
[17:59:26.883] Conditions captured: <none>
[17:59:26.883] Early signaling: FALSE
[17:59:26.883] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.883] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.904] Chunk #1 of 2 ... DONE
[17:59:26.904] Chunk #2 of 2 ...
[17:59:26.905] plan(): nbrOfWorkers() = 2
[17:59:26.907]  - Finding globals in 'X' for chunk #2 ...
[17:59:26.907] getGlobalsAndPackages() ...
[17:59:26.908] Searching for globals...
[17:59:26.909] 
[17:59:26.909] Searching for globals ... DONE
[17:59:26.910] - globals: [0] <none>
[17:59:26.910] getGlobalsAndPackages() ... DONE
[17:59:26.910]    + additional globals found: [n=0] 
[17:59:26.911]    + additional namespaces needed: [n=0] 
[17:59:26.911]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:26.911]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:26.911]  - seeds: <none>
[17:59:26.912]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.912] getGlobalsAndPackages() ...
[17:59:26.912] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.913] Resolving globals: FALSE
[17:59:26.913] Tweak future expression to call with '...' arguments ...
[17:59:26.913] {
[17:59:26.913]     do.call(function(...) {
[17:59:26.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.913]             on.exit(options(oopts), add = TRUE)
[17:59:26.913]         }
[17:59:26.913]         {
[17:59:26.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.913]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.913]             })
[17:59:26.913]         }
[17:59:26.913]     }, args = future.call.arguments)
[17:59:26.913] }
[17:59:26.914] Tweak future expression to call with '...' arguments ... DONE
[17:59:26.915] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:26.916] 
[17:59:26.921] getGlobalsAndPackages() ... DONE
[17:59:26.923] run() for ‘Future’ ...
[17:59:26.924] - state: ‘created’
[17:59:26.925] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:26.937] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:26.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:26.938]   - Field: ‘label’
[17:59:26.939]   - Field: ‘local’
[17:59:26.939]   - Field: ‘owner’
[17:59:26.940]   - Field: ‘envir’
[17:59:26.940]   - Field: ‘workers’
[17:59:26.941]   - Field: ‘packages’
[17:59:26.941]   - Field: ‘gc’
[17:59:26.941]   - Field: ‘job’
[17:59:26.942]   - Field: ‘conditions’
[17:59:26.942]   - Field: ‘expr’
[17:59:26.943]   - Field: ‘uuid’
[17:59:26.943]   - Field: ‘seed’
[17:59:26.943]   - Field: ‘version’
[17:59:26.944]   - Field: ‘result’
[17:59:26.944]   - Field: ‘asynchronous’
[17:59:26.944]   - Field: ‘calls’
[17:59:26.945]   - Field: ‘globals’
[17:59:26.945]   - Field: ‘stdout’
[17:59:26.945]   - Field: ‘earlySignal’
[17:59:26.946]   - Field: ‘lazy’
[17:59:26.946]   - Field: ‘state’
[17:59:26.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:26.947] - Launch lazy future ...
[17:59:26.947] Packages needed by the future expression (n = 1): ‘stats’
[17:59:26.948] Packages needed by future strategies (n = 0): <none>
[17:59:26.950] {
[17:59:26.950]     {
[17:59:26.950]         {
[17:59:26.950]             ...future.startTime <- base::Sys.time()
[17:59:26.950]             {
[17:59:26.950]                 {
[17:59:26.950]                   {
[17:59:26.950]                     {
[17:59:26.950]                       {
[17:59:26.950]                         base::local({
[17:59:26.950]                           has_future <- base::requireNamespace("future", 
[17:59:26.950]                             quietly = TRUE)
[17:59:26.950]                           if (has_future) {
[17:59:26.950]                             ns <- base::getNamespace("future")
[17:59:26.950]                             version <- ns[[".package"]][["version"]]
[17:59:26.950]                             if (is.null(version)) 
[17:59:26.950]                               version <- utils::packageVersion("future")
[17:59:26.950]                           }
[17:59:26.950]                           else {
[17:59:26.950]                             version <- NULL
[17:59:26.950]                           }
[17:59:26.950]                           if (!has_future || version < "1.8.0") {
[17:59:26.950]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:26.950]                               "", base::R.version$version.string), 
[17:59:26.950]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:26.950]                                 base::R.version$platform, 8 * 
[17:59:26.950]                                   base::.Machine$sizeof.pointer), 
[17:59:26.950]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:26.950]                                 "release", "version")], collapse = " "), 
[17:59:26.950]                               hostname = base::Sys.info()[["nodename"]])
[17:59:26.950]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:26.950]                               info)
[17:59:26.950]                             info <- base::paste(info, collapse = "; ")
[17:59:26.950]                             if (!has_future) {
[17:59:26.950]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:26.950]                                 info)
[17:59:26.950]                             }
[17:59:26.950]                             else {
[17:59:26.950]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:26.950]                                 info, version)
[17:59:26.950]                             }
[17:59:26.950]                             base::stop(msg)
[17:59:26.950]                           }
[17:59:26.950]                         })
[17:59:26.950]                       }
[17:59:26.950]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:26.950]                       base::options(mc.cores = 1L)
[17:59:26.950]                     }
[17:59:26.950]                     base::local({
[17:59:26.950]                       for (pkg in "stats") {
[17:59:26.950]                         base::loadNamespace(pkg)
[17:59:26.950]                         base::library(pkg, character.only = TRUE)
[17:59:26.950]                       }
[17:59:26.950]                     })
[17:59:26.950]                   }
[17:59:26.950]                   ...future.strategy.old <- future::plan("list")
[17:59:26.950]                   options(future.plan = NULL)
[17:59:26.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:26.950]                 }
[17:59:26.950]                 ...future.workdir <- getwd()
[17:59:26.950]             }
[17:59:26.950]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:26.950]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:26.950]         }
[17:59:26.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:26.950]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:26.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:26.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:26.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:26.950]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:26.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:26.950]             base::names(...future.oldOptions))
[17:59:26.950]     }
[17:59:26.950]     if (FALSE) {
[17:59:26.950]     }
[17:59:26.950]     else {
[17:59:26.950]         if (TRUE) {
[17:59:26.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:26.950]                 open = "w")
[17:59:26.950]         }
[17:59:26.950]         else {
[17:59:26.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:26.950]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:26.950]         }
[17:59:26.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:26.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:26.950]             base::sink(type = "output", split = FALSE)
[17:59:26.950]             base::close(...future.stdout)
[17:59:26.950]         }, add = TRUE)
[17:59:26.950]     }
[17:59:26.950]     ...future.frame <- base::sys.nframe()
[17:59:26.950]     ...future.conditions <- base::list()
[17:59:26.950]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:26.950]     if (FALSE) {
[17:59:26.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:26.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:26.950]     }
[17:59:26.950]     ...future.result <- base::tryCatch({
[17:59:26.950]         base::withCallingHandlers({
[17:59:26.950]             ...future.value <- base::withVisible(base::local({
[17:59:26.950]                 withCallingHandlers({
[17:59:26.950]                   {
[17:59:26.950]                     do.call(function(...) {
[17:59:26.950]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.950]                       if (!identical(...future.globals.maxSize.org, 
[17:59:26.950]                         ...future.globals.maxSize)) {
[17:59:26.950]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.950]                         on.exit(options(oopts), add = TRUE)
[17:59:26.950]                       }
[17:59:26.950]                       {
[17:59:26.950]                         lapply(seq_along(...future.elements_ii), 
[17:59:26.950]                           FUN = function(jj) {
[17:59:26.950]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.950]                             ...future.FUN(...future.X_jj, ...)
[17:59:26.950]                           })
[17:59:26.950]                       }
[17:59:26.950]                     }, args = future.call.arguments)
[17:59:26.950]                   }
[17:59:26.950]                 }, immediateCondition = function(cond) {
[17:59:26.950]                   save_rds <- function (object, pathname, ...) 
[17:59:26.950]                   {
[17:59:26.950]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:26.950]                     if (file_test("-f", pathname_tmp)) {
[17:59:26.950]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.950]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:26.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.950]                         fi_tmp[["mtime"]])
[17:59:26.950]                     }
[17:59:26.950]                     tryCatch({
[17:59:26.950]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:26.950]                     }, error = function(ex) {
[17:59:26.950]                       msg <- conditionMessage(ex)
[17:59:26.950]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.950]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:26.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.950]                         fi_tmp[["mtime"]], msg)
[17:59:26.950]                       ex$message <- msg
[17:59:26.950]                       stop(ex)
[17:59:26.950]                     })
[17:59:26.950]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:26.950]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:26.950]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:26.950]                       fi_tmp <- file.info(pathname_tmp)
[17:59:26.950]                       fi <- file.info(pathname)
[17:59:26.950]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:26.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:26.950]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:26.950]                         fi[["size"]], fi[["mtime"]])
[17:59:26.950]                       stop(msg)
[17:59:26.950]                     }
[17:59:26.950]                     invisible(pathname)
[17:59:26.950]                   }
[17:59:26.950]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:26.950]                     rootPath = tempdir()) 
[17:59:26.950]                   {
[17:59:26.950]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:26.950]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:26.950]                       tmpdir = path, fileext = ".rds")
[17:59:26.950]                     save_rds(obj, file)
[17:59:26.950]                   }
[17:59:26.950]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:26.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.950]                   {
[17:59:26.950]                     inherits <- base::inherits
[17:59:26.950]                     invokeRestart <- base::invokeRestart
[17:59:26.950]                     is.null <- base::is.null
[17:59:26.950]                     muffled <- FALSE
[17:59:26.950]                     if (inherits(cond, "message")) {
[17:59:26.950]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:26.950]                       if (muffled) 
[17:59:26.950]                         invokeRestart("muffleMessage")
[17:59:26.950]                     }
[17:59:26.950]                     else if (inherits(cond, "warning")) {
[17:59:26.950]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:26.950]                       if (muffled) 
[17:59:26.950]                         invokeRestart("muffleWarning")
[17:59:26.950]                     }
[17:59:26.950]                     else if (inherits(cond, "condition")) {
[17:59:26.950]                       if (!is.null(pattern)) {
[17:59:26.950]                         computeRestarts <- base::computeRestarts
[17:59:26.950]                         grepl <- base::grepl
[17:59:26.950]                         restarts <- computeRestarts(cond)
[17:59:26.950]                         for (restart in restarts) {
[17:59:26.950]                           name <- restart$name
[17:59:26.950]                           if (is.null(name)) 
[17:59:26.950]                             next
[17:59:26.950]                           if (!grepl(pattern, name)) 
[17:59:26.950]                             next
[17:59:26.950]                           invokeRestart(restart)
[17:59:26.950]                           muffled <- TRUE
[17:59:26.950]                           break
[17:59:26.950]                         }
[17:59:26.950]                       }
[17:59:26.950]                     }
[17:59:26.950]                     invisible(muffled)
[17:59:26.950]                   }
[17:59:26.950]                   muffleCondition(cond)
[17:59:26.950]                 })
[17:59:26.950]             }))
[17:59:26.950]             future::FutureResult(value = ...future.value$value, 
[17:59:26.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.950]                   ...future.rng), globalenv = if (FALSE) 
[17:59:26.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:26.950]                     ...future.globalenv.names))
[17:59:26.950]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:26.950]         }, condition = base::local({
[17:59:26.950]             c <- base::c
[17:59:26.950]             inherits <- base::inherits
[17:59:26.950]             invokeRestart <- base::invokeRestart
[17:59:26.950]             length <- base::length
[17:59:26.950]             list <- base::list
[17:59:26.950]             seq.int <- base::seq.int
[17:59:26.950]             signalCondition <- base::signalCondition
[17:59:26.950]             sys.calls <- base::sys.calls
[17:59:26.950]             `[[` <- base::`[[`
[17:59:26.950]             `+` <- base::`+`
[17:59:26.950]             `<<-` <- base::`<<-`
[17:59:26.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:26.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:26.950]                   3L)]
[17:59:26.950]             }
[17:59:26.950]             function(cond) {
[17:59:26.950]                 is_error <- inherits(cond, "error")
[17:59:26.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:26.950]                   NULL)
[17:59:26.950]                 if (is_error) {
[17:59:26.950]                   sessionInformation <- function() {
[17:59:26.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:26.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:26.950]                       search = base::search(), system = base::Sys.info())
[17:59:26.950]                   }
[17:59:26.950]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:26.950]                     cond$call), session = sessionInformation(), 
[17:59:26.950]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:26.950]                   signalCondition(cond)
[17:59:26.950]                 }
[17:59:26.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:26.950]                 "immediateCondition"))) {
[17:59:26.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:26.950]                   ...future.conditions[[length(...future.conditions) + 
[17:59:26.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:26.950]                   if (TRUE && !signal) {
[17:59:26.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.950]                     {
[17:59:26.950]                       inherits <- base::inherits
[17:59:26.950]                       invokeRestart <- base::invokeRestart
[17:59:26.950]                       is.null <- base::is.null
[17:59:26.950]                       muffled <- FALSE
[17:59:26.950]                       if (inherits(cond, "message")) {
[17:59:26.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.950]                         if (muffled) 
[17:59:26.950]                           invokeRestart("muffleMessage")
[17:59:26.950]                       }
[17:59:26.950]                       else if (inherits(cond, "warning")) {
[17:59:26.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.950]                         if (muffled) 
[17:59:26.950]                           invokeRestart("muffleWarning")
[17:59:26.950]                       }
[17:59:26.950]                       else if (inherits(cond, "condition")) {
[17:59:26.950]                         if (!is.null(pattern)) {
[17:59:26.950]                           computeRestarts <- base::computeRestarts
[17:59:26.950]                           grepl <- base::grepl
[17:59:26.950]                           restarts <- computeRestarts(cond)
[17:59:26.950]                           for (restart in restarts) {
[17:59:26.950]                             name <- restart$name
[17:59:26.950]                             if (is.null(name)) 
[17:59:26.950]                               next
[17:59:26.950]                             if (!grepl(pattern, name)) 
[17:59:26.950]                               next
[17:59:26.950]                             invokeRestart(restart)
[17:59:26.950]                             muffled <- TRUE
[17:59:26.950]                             break
[17:59:26.950]                           }
[17:59:26.950]                         }
[17:59:26.950]                       }
[17:59:26.950]                       invisible(muffled)
[17:59:26.950]                     }
[17:59:26.950]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.950]                   }
[17:59:26.950]                 }
[17:59:26.950]                 else {
[17:59:26.950]                   if (TRUE) {
[17:59:26.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:26.950]                     {
[17:59:26.950]                       inherits <- base::inherits
[17:59:26.950]                       invokeRestart <- base::invokeRestart
[17:59:26.950]                       is.null <- base::is.null
[17:59:26.950]                       muffled <- FALSE
[17:59:26.950]                       if (inherits(cond, "message")) {
[17:59:26.950]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:26.950]                         if (muffled) 
[17:59:26.950]                           invokeRestart("muffleMessage")
[17:59:26.950]                       }
[17:59:26.950]                       else if (inherits(cond, "warning")) {
[17:59:26.950]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:26.950]                         if (muffled) 
[17:59:26.950]                           invokeRestart("muffleWarning")
[17:59:26.950]                       }
[17:59:26.950]                       else if (inherits(cond, "condition")) {
[17:59:26.950]                         if (!is.null(pattern)) {
[17:59:26.950]                           computeRestarts <- base::computeRestarts
[17:59:26.950]                           grepl <- base::grepl
[17:59:26.950]                           restarts <- computeRestarts(cond)
[17:59:26.950]                           for (restart in restarts) {
[17:59:26.950]                             name <- restart$name
[17:59:26.950]                             if (is.null(name)) 
[17:59:26.950]                               next
[17:59:26.950]                             if (!grepl(pattern, name)) 
[17:59:26.950]                               next
[17:59:26.950]                             invokeRestart(restart)
[17:59:26.950]                             muffled <- TRUE
[17:59:26.950]                             break
[17:59:26.950]                           }
[17:59:26.950]                         }
[17:59:26.950]                       }
[17:59:26.950]                       invisible(muffled)
[17:59:26.950]                     }
[17:59:26.950]                     muffleCondition(cond, pattern = "^muffle")
[17:59:26.950]                   }
[17:59:26.950]                 }
[17:59:26.950]             }
[17:59:26.950]         }))
[17:59:26.950]     }, error = function(ex) {
[17:59:26.950]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:26.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:26.950]                 ...future.rng), started = ...future.startTime, 
[17:59:26.950]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:26.950]             version = "1.8"), class = "FutureResult")
[17:59:26.950]     }, finally = {
[17:59:26.950]         if (!identical(...future.workdir, getwd())) 
[17:59:26.950]             setwd(...future.workdir)
[17:59:26.950]         {
[17:59:26.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:26.950]                 ...future.oldOptions$nwarnings <- NULL
[17:59:26.950]             }
[17:59:26.950]             base::options(...future.oldOptions)
[17:59:26.950]             if (.Platform$OS.type == "windows") {
[17:59:26.950]                 old_names <- names(...future.oldEnvVars)
[17:59:26.950]                 envs <- base::Sys.getenv()
[17:59:26.950]                 names <- names(envs)
[17:59:26.950]                 common <- intersect(names, old_names)
[17:59:26.950]                 added <- setdiff(names, old_names)
[17:59:26.950]                 removed <- setdiff(old_names, names)
[17:59:26.950]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:26.950]                   envs[common]]
[17:59:26.950]                 NAMES <- toupper(changed)
[17:59:26.950]                 args <- list()
[17:59:26.950]                 for (kk in seq_along(NAMES)) {
[17:59:26.950]                   name <- changed[[kk]]
[17:59:26.950]                   NAME <- NAMES[[kk]]
[17:59:26.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.950]                     next
[17:59:26.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.950]                 }
[17:59:26.950]                 NAMES <- toupper(added)
[17:59:26.950]                 for (kk in seq_along(NAMES)) {
[17:59:26.950]                   name <- added[[kk]]
[17:59:26.950]                   NAME <- NAMES[[kk]]
[17:59:26.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.950]                     next
[17:59:26.950]                   args[[name]] <- ""
[17:59:26.950]                 }
[17:59:26.950]                 NAMES <- toupper(removed)
[17:59:26.950]                 for (kk in seq_along(NAMES)) {
[17:59:26.950]                   name <- removed[[kk]]
[17:59:26.950]                   NAME <- NAMES[[kk]]
[17:59:26.950]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:26.950]                     next
[17:59:26.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:26.950]                 }
[17:59:26.950]                 if (length(args) > 0) 
[17:59:26.950]                   base::do.call(base::Sys.setenv, args = args)
[17:59:26.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:26.950]             }
[17:59:26.950]             else {
[17:59:26.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:26.950]             }
[17:59:26.950]             {
[17:59:26.950]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:26.950]                   0L) {
[17:59:26.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:26.950]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:26.950]                   base::options(opts)
[17:59:26.950]                 }
[17:59:26.950]                 {
[17:59:26.950]                   {
[17:59:26.950]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:26.950]                     NULL
[17:59:26.950]                   }
[17:59:26.950]                   options(future.plan = NULL)
[17:59:26.950]                   if (is.na(NA_character_)) 
[17:59:26.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:26.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:26.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:26.950]                     .init = FALSE)
[17:59:26.950]                 }
[17:59:26.950]             }
[17:59:26.950]         }
[17:59:26.950]     })
[17:59:26.950]     if (TRUE) {
[17:59:26.950]         base::sink(type = "output", split = FALSE)
[17:59:26.950]         if (TRUE) {
[17:59:26.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:26.950]         }
[17:59:26.950]         else {
[17:59:26.950]             ...future.result["stdout"] <- base::list(NULL)
[17:59:26.950]         }
[17:59:26.950]         base::close(...future.stdout)
[17:59:26.950]         ...future.stdout <- NULL
[17:59:26.950]     }
[17:59:26.950]     ...future.result$conditions <- ...future.conditions
[17:59:26.950]     ...future.result$finished <- base::Sys.time()
[17:59:26.950]     ...future.result
[17:59:26.950] }
[17:59:26.956] assign_globals() ...
[17:59:26.956] List of 5
[17:59:26.956]  $ ...future.FUN            :function (x, ...)  
[17:59:26.956]  $ future.call.arguments    :List of 1
[17:59:26.956]   ..$ singular.ok: logi FALSE
[17:59:26.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:26.956]  $ ...future.elements_ii    :List of 2
[17:59:26.956]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.956]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:26.956]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.956]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:26.956]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:26.956]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:26.956]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:26.956]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:26.956]  $ ...future.seeds_ii       : NULL
[17:59:26.956]  $ ...future.globals.maxSize: NULL
[17:59:26.956]  - attr(*, "where")=List of 5
[17:59:26.956]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:26.956]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:26.956]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:26.956]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:26.956]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:26.956]  - attr(*, "resolved")= logi FALSE
[17:59:26.956]  - attr(*, "total_size")= num 5384
[17:59:26.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:26.956]  - attr(*, "already-done")= logi TRUE
[17:59:26.977] - reassign environment for ‘...future.FUN’
[17:59:26.978] - copied ‘...future.FUN’ to environment
[17:59:26.978] - copied ‘future.call.arguments’ to environment
[17:59:26.978] - copied ‘...future.elements_ii’ to environment
[17:59:26.978] - copied ‘...future.seeds_ii’ to environment
[17:59:26.978] - copied ‘...future.globals.maxSize’ to environment
[17:59:26.979] assign_globals() ... done
[17:59:26.979] requestCore(): workers = 2
[17:59:26.982] MulticoreFuture started
[17:59:26.983] - Launch lazy future ... done
[17:59:26.983] run() for ‘MulticoreFuture’ ... done
[17:59:26.984] Created future:
[17:59:26.985] plan(): Setting new future strategy stack:
[17:59:26.985] List of future strategies:
[17:59:26.985] 1. sequential:
[17:59:26.985]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:26.985]    - tweaked: FALSE
[17:59:26.985]    - call: NULL
[17:59:26.987] plan(): nbrOfWorkers() = 1
[17:59:26.984] MulticoreFuture:
[17:59:26.984] Label: ‘future_by-2’
[17:59:26.984] Expression:
[17:59:26.984] {
[17:59:26.984]     do.call(function(...) {
[17:59:26.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:26.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:26.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:26.984]             on.exit(options(oopts), add = TRUE)
[17:59:26.984]         }
[17:59:26.984]         {
[17:59:26.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:26.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:26.984]                 ...future.FUN(...future.X_jj, ...)
[17:59:26.984]             })
[17:59:26.984]         }
[17:59:26.984]     }, args = future.call.arguments)
[17:59:26.984] }
[17:59:26.984] Lazy evaluation: FALSE
[17:59:26.984] Asynchronous evaluation: TRUE
[17:59:26.984] Local evaluation: TRUE
[17:59:26.984] Environment: R_GlobalEnv
[17:59:26.984] Capture standard output: TRUE
[17:59:26.984] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:26.984] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:26.984] Packages: 1 packages (‘stats’)
[17:59:26.984] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:26.984] Resolved: FALSE
[17:59:26.984] Value: <not collected>
[17:59:26.984] Conditions captured: <none>
[17:59:26.984] Early signaling: FALSE
[17:59:26.984] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:26.984] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.001] Chunk #2 of 2 ... DONE
[17:59:27.001] Launching 2 futures (chunks) ... DONE
[17:59:27.001] Resolving 2 futures (chunks) ...
[17:59:27.002] resolve() on list ...
[17:59:27.002]  recursive: 0
[17:59:27.003]  length: 2
[17:59:27.003] 
[17:59:27.004] Future #1
[17:59:27.004] result() for MulticoreFuture ...
[17:59:27.005] plan(): Setting new future strategy stack:
[17:59:27.006] List of future strategies:
[17:59:27.006] 1. multicore:
[17:59:27.006]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.006]    - tweaked: FALSE
[17:59:27.006]    - call: plan(strategy)
[17:59:27.011] result() for MulticoreFuture ...
[17:59:27.011] result() for MulticoreFuture ... done
[17:59:27.012] result() for MulticoreFuture ... done
[17:59:27.012] result() for MulticoreFuture ...
[17:59:27.013] result() for MulticoreFuture ... done
[17:59:27.013] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:27.014] - nx: 2
[17:59:27.014] - relay: TRUE
[17:59:27.015] - stdout: TRUE
[17:59:27.016] - signal: TRUE
[17:59:27.017] - resignal: FALSE
[17:59:27.017] - force: TRUE
[17:59:27.018] - relayed: [n=2] FALSE, FALSE
[17:59:27.018] - queued futures: [n=2] FALSE, FALSE
[17:59:27.019]  - until=1
[17:59:27.019]  - relaying element #1
[17:59:27.020] plan(): nbrOfWorkers() = 2
[17:59:27.020] result() for MulticoreFuture ...
[17:59:27.021] result() for MulticoreFuture ... done
[17:59:27.022] result() for MulticoreFuture ...
[17:59:27.022] result() for MulticoreFuture ... done
[17:59:27.023] result() for MulticoreFuture ...
[17:59:27.023] result() for MulticoreFuture ... done
[17:59:27.024] result() for MulticoreFuture ...
[17:59:27.024] result() for MulticoreFuture ... done
[17:59:27.024] - relayed: [n=2] TRUE, FALSE
[17:59:27.025] - queued futures: [n=2] TRUE, FALSE
[17:59:27.025] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:27.026]  length: 1 (resolved future 1)
[17:59:27.026] Future #2
[17:59:27.027] result() for MulticoreFuture ...
[17:59:27.030] result() for MulticoreFuture ...
[17:59:27.030] result() for MulticoreFuture ... done
[17:59:27.030] result() for MulticoreFuture ... done
[17:59:27.031] result() for MulticoreFuture ...
[17:59:27.031] result() for MulticoreFuture ... done
[17:59:27.031] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:27.031] - nx: 2
[17:59:27.032] - relay: TRUE
[17:59:27.032] - stdout: TRUE
[17:59:27.032] - signal: TRUE
[17:59:27.032] - resignal: FALSE
[17:59:27.032] - force: TRUE
[17:59:27.033] - relayed: [n=2] TRUE, FALSE
[17:59:27.033] - queued futures: [n=2] TRUE, FALSE
[17:59:27.033]  - until=2
[17:59:27.033]  - relaying element #2
[17:59:27.034] result() for MulticoreFuture ...
[17:59:27.034] result() for MulticoreFuture ... done
[17:59:27.034] result() for MulticoreFuture ...
[17:59:27.034] result() for MulticoreFuture ... done
[17:59:27.035] result() for MulticoreFuture ...
[17:59:27.035] result() for MulticoreFuture ... done
[17:59:27.035] result() for MulticoreFuture ...
[17:59:27.035] result() for MulticoreFuture ... done
[17:59:27.036] - relayed: [n=2] TRUE, TRUE
[17:59:27.036] - queued futures: [n=2] TRUE, TRUE
[17:59:27.036] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:27.036]  length: 0 (resolved future 2)
[17:59:27.036] Relaying remaining futures
[17:59:27.037] signalConditionsASAP(NULL, pos=0) ...
[17:59:27.037] - nx: 2
[17:59:27.037] - relay: TRUE
[17:59:27.037] - stdout: TRUE
[17:59:27.037] - signal: TRUE
[17:59:27.038] - resignal: FALSE
[17:59:27.038] - force: TRUE
[17:59:27.038] - relayed: [n=2] TRUE, TRUE
[17:59:27.038] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:27.039] - relayed: [n=2] TRUE, TRUE
[17:59:27.039] - queued futures: [n=2] TRUE, TRUE
[17:59:27.039] signalConditionsASAP(NULL, pos=0) ... done
[17:59:27.039] resolve() on list ... DONE
[17:59:27.039] result() for MulticoreFuture ...
[17:59:27.040] result() for MulticoreFuture ... done
[17:59:27.040] result() for MulticoreFuture ...
[17:59:27.040] result() for MulticoreFuture ... done
[17:59:27.040] result() for MulticoreFuture ...
[17:59:27.040] result() for MulticoreFuture ... done
[17:59:27.041] result() for MulticoreFuture ...
[17:59:27.041] result() for MulticoreFuture ... done
[17:59:27.041]  - Number of value chunks collected: 2
[17:59:27.041] Resolving 2 futures (chunks) ... DONE
[17:59:27.042] Reducing values from 2 chunks ...
[17:59:27.042]  - Number of values collected after concatenation: 3
[17:59:27.042]  - Number of values expected: 3
[17:59:27.042] Reducing values from 2 chunks ... DONE
[17:59:27.042] future_lapply() ... DONE
[17:59:27.043] future_by_internal() ... DONE
[17:59:27.052] future_by_internal() ...
[17:59:27.053] future_lapply() ...
[17:59:27.068] Number of chunks: 2
[17:59:27.069] getGlobalsAndPackagesXApply() ...
[17:59:27.069]  - future.globals: TRUE
[17:59:27.069] getGlobalsAndPackages() ...
[17:59:27.069] Searching for globals...
[17:59:27.075] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:27.075] Searching for globals ... DONE
[17:59:27.075] Resolving globals: FALSE
[17:59:27.076] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:59:27.077] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:59:27.077] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:27.078] - packages: [1] ‘stats’
[17:59:27.078] getGlobalsAndPackages() ... DONE
[17:59:27.078]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:27.078]  - needed namespaces: [n=1] ‘stats’
[17:59:27.079] Finding globals ... DONE
[17:59:27.079]  - use_args: TRUE
[17:59:27.079]  - Getting '...' globals ...
[17:59:27.080] resolve() on list ...
[17:59:27.080]  recursive: 0
[17:59:27.080]  length: 1
[17:59:27.080]  elements: ‘...’
[17:59:27.081]  length: 0 (resolved future 1)
[17:59:27.081] resolve() on list ... DONE
[17:59:27.081]    - '...' content: [n=0] 
[17:59:27.081] List of 1
[17:59:27.081]  $ ...: list()
[17:59:27.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.081]  - attr(*, "where")=List of 1
[17:59:27.081]   ..$ ...:<environment: 0x62649fde6018> 
[17:59:27.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.081]  - attr(*, "resolved")= logi TRUE
[17:59:27.081]  - attr(*, "total_size")= num NA
[17:59:27.086]  - Getting '...' globals ... DONE
[17:59:27.087] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:59:27.087] List of 4
[17:59:27.087]  $ ...future.FUN:function (x)  
[17:59:27.087]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:27.087]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:27.087]  $ ...          : list()
[17:59:27.087]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.087]  - attr(*, "where")=List of 4
[17:59:27.087]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:27.087]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:59:27.087]   ..$ wool         :<environment: R_EmptyEnv> 
[17:59:27.087]   ..$ ...          :<environment: 0x62649fde6018> 
[17:59:27.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.087]  - attr(*, "resolved")= logi FALSE
[17:59:27.087]  - attr(*, "total_size")= num 2320
[17:59:27.095] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:27.095] getGlobalsAndPackagesXApply() ... DONE
[17:59:27.095] Number of futures (= number of chunks): 2
[17:59:27.096] Launching 2 futures (chunks) ...
[17:59:27.096] Chunk #1 of 2 ...
[17:59:27.096]  - Finding globals in 'X' for chunk #1 ...
[17:59:27.096] getGlobalsAndPackages() ...
[17:59:27.096] Searching for globals...
[17:59:27.097] 
[17:59:27.097] Searching for globals ... DONE
[17:59:27.098] - globals: [0] <none>
[17:59:27.098] getGlobalsAndPackages() ... DONE
[17:59:27.098]    + additional globals found: [n=0] 
[17:59:27.098]    + additional namespaces needed: [n=0] 
[17:59:27.098]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:27.099]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:27.099]  - seeds: <none>
[17:59:27.099]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.099] getGlobalsAndPackages() ...
[17:59:27.099] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.100] Resolving globals: FALSE
[17:59:27.100] Tweak future expression to call with '...' arguments ...
[17:59:27.100] {
[17:59:27.100]     do.call(function(...) {
[17:59:27.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.100]             on.exit(options(oopts), add = TRUE)
[17:59:27.100]         }
[17:59:27.100]         {
[17:59:27.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.100]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.100]             })
[17:59:27.100]         }
[17:59:27.100]     }, args = future.call.arguments)
[17:59:27.100] }
[17:59:27.101] Tweak future expression to call with '...' arguments ... DONE
[17:59:27.101] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.102] 
[17:59:27.102] getGlobalsAndPackages() ... DONE
[17:59:27.102] run() for ‘Future’ ...
[17:59:27.103] - state: ‘created’
[17:59:27.103] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:27.109] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:27.110]   - Field: ‘label’
[17:59:27.110]   - Field: ‘local’
[17:59:27.110]   - Field: ‘owner’
[17:59:27.110]   - Field: ‘envir’
[17:59:27.111]   - Field: ‘workers’
[17:59:27.111]   - Field: ‘packages’
[17:59:27.114]   - Field: ‘gc’
[17:59:27.114]   - Field: ‘job’
[17:59:27.114]   - Field: ‘conditions’
[17:59:27.114]   - Field: ‘expr’
[17:59:27.115]   - Field: ‘uuid’
[17:59:27.115]   - Field: ‘seed’
[17:59:27.115]   - Field: ‘version’
[17:59:27.115]   - Field: ‘result’
[17:59:27.115]   - Field: ‘asynchronous’
[17:59:27.116]   - Field: ‘calls’
[17:59:27.116]   - Field: ‘globals’
[17:59:27.116]   - Field: ‘stdout’
[17:59:27.116]   - Field: ‘earlySignal’
[17:59:27.116]   - Field: ‘lazy’
[17:59:27.117]   - Field: ‘state’
[17:59:27.117] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:27.117] - Launch lazy future ...
[17:59:27.118] Packages needed by the future expression (n = 1): ‘stats’
[17:59:27.118] Packages needed by future strategies (n = 0): <none>
[17:59:27.119] {
[17:59:27.119]     {
[17:59:27.119]         {
[17:59:27.119]             ...future.startTime <- base::Sys.time()
[17:59:27.119]             {
[17:59:27.119]                 {
[17:59:27.119]                   {
[17:59:27.119]                     {
[17:59:27.119]                       {
[17:59:27.119]                         base::local({
[17:59:27.119]                           has_future <- base::requireNamespace("future", 
[17:59:27.119]                             quietly = TRUE)
[17:59:27.119]                           if (has_future) {
[17:59:27.119]                             ns <- base::getNamespace("future")
[17:59:27.119]                             version <- ns[[".package"]][["version"]]
[17:59:27.119]                             if (is.null(version)) 
[17:59:27.119]                               version <- utils::packageVersion("future")
[17:59:27.119]                           }
[17:59:27.119]                           else {
[17:59:27.119]                             version <- NULL
[17:59:27.119]                           }
[17:59:27.119]                           if (!has_future || version < "1.8.0") {
[17:59:27.119]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:27.119]                               "", base::R.version$version.string), 
[17:59:27.119]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:27.119]                                 base::R.version$platform, 8 * 
[17:59:27.119]                                   base::.Machine$sizeof.pointer), 
[17:59:27.119]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:27.119]                                 "release", "version")], collapse = " "), 
[17:59:27.119]                               hostname = base::Sys.info()[["nodename"]])
[17:59:27.119]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:27.119]                               info)
[17:59:27.119]                             info <- base::paste(info, collapse = "; ")
[17:59:27.119]                             if (!has_future) {
[17:59:27.119]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:27.119]                                 info)
[17:59:27.119]                             }
[17:59:27.119]                             else {
[17:59:27.119]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:27.119]                                 info, version)
[17:59:27.119]                             }
[17:59:27.119]                             base::stop(msg)
[17:59:27.119]                           }
[17:59:27.119]                         })
[17:59:27.119]                       }
[17:59:27.119]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:27.119]                       base::options(mc.cores = 1L)
[17:59:27.119]                     }
[17:59:27.119]                     base::local({
[17:59:27.119]                       for (pkg in "stats") {
[17:59:27.119]                         base::loadNamespace(pkg)
[17:59:27.119]                         base::library(pkg, character.only = TRUE)
[17:59:27.119]                       }
[17:59:27.119]                     })
[17:59:27.119]                   }
[17:59:27.119]                   ...future.strategy.old <- future::plan("list")
[17:59:27.119]                   options(future.plan = NULL)
[17:59:27.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:27.119]                 }
[17:59:27.119]                 ...future.workdir <- getwd()
[17:59:27.119]             }
[17:59:27.119]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:27.119]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:27.119]         }
[17:59:27.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:27.119]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:27.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:27.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:27.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:27.119]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:27.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:27.119]             base::names(...future.oldOptions))
[17:59:27.119]     }
[17:59:27.119]     if (FALSE) {
[17:59:27.119]     }
[17:59:27.119]     else {
[17:59:27.119]         if (TRUE) {
[17:59:27.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:27.119]                 open = "w")
[17:59:27.119]         }
[17:59:27.119]         else {
[17:59:27.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:27.119]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:27.119]         }
[17:59:27.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:27.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:27.119]             base::sink(type = "output", split = FALSE)
[17:59:27.119]             base::close(...future.stdout)
[17:59:27.119]         }, add = TRUE)
[17:59:27.119]     }
[17:59:27.119]     ...future.frame <- base::sys.nframe()
[17:59:27.119]     ...future.conditions <- base::list()
[17:59:27.119]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:27.119]     if (FALSE) {
[17:59:27.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:27.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:27.119]     }
[17:59:27.119]     ...future.result <- base::tryCatch({
[17:59:27.119]         base::withCallingHandlers({
[17:59:27.119]             ...future.value <- base::withVisible(base::local({
[17:59:27.119]                 withCallingHandlers({
[17:59:27.119]                   {
[17:59:27.119]                     do.call(function(...) {
[17:59:27.119]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.119]                       if (!identical(...future.globals.maxSize.org, 
[17:59:27.119]                         ...future.globals.maxSize)) {
[17:59:27.119]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.119]                         on.exit(options(oopts), add = TRUE)
[17:59:27.119]                       }
[17:59:27.119]                       {
[17:59:27.119]                         lapply(seq_along(...future.elements_ii), 
[17:59:27.119]                           FUN = function(jj) {
[17:59:27.119]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.119]                             ...future.FUN(...future.X_jj, ...)
[17:59:27.119]                           })
[17:59:27.119]                       }
[17:59:27.119]                     }, args = future.call.arguments)
[17:59:27.119]                   }
[17:59:27.119]                 }, immediateCondition = function(cond) {
[17:59:27.119]                   save_rds <- function (object, pathname, ...) 
[17:59:27.119]                   {
[17:59:27.119]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:27.119]                     if (file_test("-f", pathname_tmp)) {
[17:59:27.119]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.119]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:27.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.119]                         fi_tmp[["mtime"]])
[17:59:27.119]                     }
[17:59:27.119]                     tryCatch({
[17:59:27.119]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:27.119]                     }, error = function(ex) {
[17:59:27.119]                       msg <- conditionMessage(ex)
[17:59:27.119]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.119]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:27.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.119]                         fi_tmp[["mtime"]], msg)
[17:59:27.119]                       ex$message <- msg
[17:59:27.119]                       stop(ex)
[17:59:27.119]                     })
[17:59:27.119]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:27.119]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:27.119]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:27.119]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.119]                       fi <- file.info(pathname)
[17:59:27.119]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:27.119]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.119]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:27.119]                         fi[["size"]], fi[["mtime"]])
[17:59:27.119]                       stop(msg)
[17:59:27.119]                     }
[17:59:27.119]                     invisible(pathname)
[17:59:27.119]                   }
[17:59:27.119]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:27.119]                     rootPath = tempdir()) 
[17:59:27.119]                   {
[17:59:27.119]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:27.119]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:27.119]                       tmpdir = path, fileext = ".rds")
[17:59:27.119]                     save_rds(obj, file)
[17:59:27.119]                   }
[17:59:27.119]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:27.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.119]                   {
[17:59:27.119]                     inherits <- base::inherits
[17:59:27.119]                     invokeRestart <- base::invokeRestart
[17:59:27.119]                     is.null <- base::is.null
[17:59:27.119]                     muffled <- FALSE
[17:59:27.119]                     if (inherits(cond, "message")) {
[17:59:27.119]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:27.119]                       if (muffled) 
[17:59:27.119]                         invokeRestart("muffleMessage")
[17:59:27.119]                     }
[17:59:27.119]                     else if (inherits(cond, "warning")) {
[17:59:27.119]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:27.119]                       if (muffled) 
[17:59:27.119]                         invokeRestart("muffleWarning")
[17:59:27.119]                     }
[17:59:27.119]                     else if (inherits(cond, "condition")) {
[17:59:27.119]                       if (!is.null(pattern)) {
[17:59:27.119]                         computeRestarts <- base::computeRestarts
[17:59:27.119]                         grepl <- base::grepl
[17:59:27.119]                         restarts <- computeRestarts(cond)
[17:59:27.119]                         for (restart in restarts) {
[17:59:27.119]                           name <- restart$name
[17:59:27.119]                           if (is.null(name)) 
[17:59:27.119]                             next
[17:59:27.119]                           if (!grepl(pattern, name)) 
[17:59:27.119]                             next
[17:59:27.119]                           invokeRestart(restart)
[17:59:27.119]                           muffled <- TRUE
[17:59:27.119]                           break
[17:59:27.119]                         }
[17:59:27.119]                       }
[17:59:27.119]                     }
[17:59:27.119]                     invisible(muffled)
[17:59:27.119]                   }
[17:59:27.119]                   muffleCondition(cond)
[17:59:27.119]                 })
[17:59:27.119]             }))
[17:59:27.119]             future::FutureResult(value = ...future.value$value, 
[17:59:27.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.119]                   ...future.rng), globalenv = if (FALSE) 
[17:59:27.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:27.119]                     ...future.globalenv.names))
[17:59:27.119]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:27.119]         }, condition = base::local({
[17:59:27.119]             c <- base::c
[17:59:27.119]             inherits <- base::inherits
[17:59:27.119]             invokeRestart <- base::invokeRestart
[17:59:27.119]             length <- base::length
[17:59:27.119]             list <- base::list
[17:59:27.119]             seq.int <- base::seq.int
[17:59:27.119]             signalCondition <- base::signalCondition
[17:59:27.119]             sys.calls <- base::sys.calls
[17:59:27.119]             `[[` <- base::`[[`
[17:59:27.119]             `+` <- base::`+`
[17:59:27.119]             `<<-` <- base::`<<-`
[17:59:27.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:27.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:27.119]                   3L)]
[17:59:27.119]             }
[17:59:27.119]             function(cond) {
[17:59:27.119]                 is_error <- inherits(cond, "error")
[17:59:27.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:27.119]                   NULL)
[17:59:27.119]                 if (is_error) {
[17:59:27.119]                   sessionInformation <- function() {
[17:59:27.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:27.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:27.119]                       search = base::search(), system = base::Sys.info())
[17:59:27.119]                   }
[17:59:27.119]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:27.119]                     cond$call), session = sessionInformation(), 
[17:59:27.119]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:27.119]                   signalCondition(cond)
[17:59:27.119]                 }
[17:59:27.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:27.119]                 "immediateCondition"))) {
[17:59:27.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:27.119]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:27.119]                   if (TRUE && !signal) {
[17:59:27.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.119]                     {
[17:59:27.119]                       inherits <- base::inherits
[17:59:27.119]                       invokeRestart <- base::invokeRestart
[17:59:27.119]                       is.null <- base::is.null
[17:59:27.119]                       muffled <- FALSE
[17:59:27.119]                       if (inherits(cond, "message")) {
[17:59:27.119]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.119]                         if (muffled) 
[17:59:27.119]                           invokeRestart("muffleMessage")
[17:59:27.119]                       }
[17:59:27.119]                       else if (inherits(cond, "warning")) {
[17:59:27.119]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.119]                         if (muffled) 
[17:59:27.119]                           invokeRestart("muffleWarning")
[17:59:27.119]                       }
[17:59:27.119]                       else if (inherits(cond, "condition")) {
[17:59:27.119]                         if (!is.null(pattern)) {
[17:59:27.119]                           computeRestarts <- base::computeRestarts
[17:59:27.119]                           grepl <- base::grepl
[17:59:27.119]                           restarts <- computeRestarts(cond)
[17:59:27.119]                           for (restart in restarts) {
[17:59:27.119]                             name <- restart$name
[17:59:27.119]                             if (is.null(name)) 
[17:59:27.119]                               next
[17:59:27.119]                             if (!grepl(pattern, name)) 
[17:59:27.119]                               next
[17:59:27.119]                             invokeRestart(restart)
[17:59:27.119]                             muffled <- TRUE
[17:59:27.119]                             break
[17:59:27.119]                           }
[17:59:27.119]                         }
[17:59:27.119]                       }
[17:59:27.119]                       invisible(muffled)
[17:59:27.119]                     }
[17:59:27.119]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.119]                   }
[17:59:27.119]                 }
[17:59:27.119]                 else {
[17:59:27.119]                   if (TRUE) {
[17:59:27.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.119]                     {
[17:59:27.119]                       inherits <- base::inherits
[17:59:27.119]                       invokeRestart <- base::invokeRestart
[17:59:27.119]                       is.null <- base::is.null
[17:59:27.119]                       muffled <- FALSE
[17:59:27.119]                       if (inherits(cond, "message")) {
[17:59:27.119]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.119]                         if (muffled) 
[17:59:27.119]                           invokeRestart("muffleMessage")
[17:59:27.119]                       }
[17:59:27.119]                       else if (inherits(cond, "warning")) {
[17:59:27.119]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.119]                         if (muffled) 
[17:59:27.119]                           invokeRestart("muffleWarning")
[17:59:27.119]                       }
[17:59:27.119]                       else if (inherits(cond, "condition")) {
[17:59:27.119]                         if (!is.null(pattern)) {
[17:59:27.119]                           computeRestarts <- base::computeRestarts
[17:59:27.119]                           grepl <- base::grepl
[17:59:27.119]                           restarts <- computeRestarts(cond)
[17:59:27.119]                           for (restart in restarts) {
[17:59:27.119]                             name <- restart$name
[17:59:27.119]                             if (is.null(name)) 
[17:59:27.119]                               next
[17:59:27.119]                             if (!grepl(pattern, name)) 
[17:59:27.119]                               next
[17:59:27.119]                             invokeRestart(restart)
[17:59:27.119]                             muffled <- TRUE
[17:59:27.119]                             break
[17:59:27.119]                           }
[17:59:27.119]                         }
[17:59:27.119]                       }
[17:59:27.119]                       invisible(muffled)
[17:59:27.119]                     }
[17:59:27.119]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.119]                   }
[17:59:27.119]                 }
[17:59:27.119]             }
[17:59:27.119]         }))
[17:59:27.119]     }, error = function(ex) {
[17:59:27.119]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:27.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.119]                 ...future.rng), started = ...future.startTime, 
[17:59:27.119]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:27.119]             version = "1.8"), class = "FutureResult")
[17:59:27.119]     }, finally = {
[17:59:27.119]         if (!identical(...future.workdir, getwd())) 
[17:59:27.119]             setwd(...future.workdir)
[17:59:27.119]         {
[17:59:27.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:27.119]                 ...future.oldOptions$nwarnings <- NULL
[17:59:27.119]             }
[17:59:27.119]             base::options(...future.oldOptions)
[17:59:27.119]             if (.Platform$OS.type == "windows") {
[17:59:27.119]                 old_names <- names(...future.oldEnvVars)
[17:59:27.119]                 envs <- base::Sys.getenv()
[17:59:27.119]                 names <- names(envs)
[17:59:27.119]                 common <- intersect(names, old_names)
[17:59:27.119]                 added <- setdiff(names, old_names)
[17:59:27.119]                 removed <- setdiff(old_names, names)
[17:59:27.119]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:27.119]                   envs[common]]
[17:59:27.119]                 NAMES <- toupper(changed)
[17:59:27.119]                 args <- list()
[17:59:27.119]                 for (kk in seq_along(NAMES)) {
[17:59:27.119]                   name <- changed[[kk]]
[17:59:27.119]                   NAME <- NAMES[[kk]]
[17:59:27.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.119]                     next
[17:59:27.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.119]                 }
[17:59:27.119]                 NAMES <- toupper(added)
[17:59:27.119]                 for (kk in seq_along(NAMES)) {
[17:59:27.119]                   name <- added[[kk]]
[17:59:27.119]                   NAME <- NAMES[[kk]]
[17:59:27.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.119]                     next
[17:59:27.119]                   args[[name]] <- ""
[17:59:27.119]                 }
[17:59:27.119]                 NAMES <- toupper(removed)
[17:59:27.119]                 for (kk in seq_along(NAMES)) {
[17:59:27.119]                   name <- removed[[kk]]
[17:59:27.119]                   NAME <- NAMES[[kk]]
[17:59:27.119]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.119]                     next
[17:59:27.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.119]                 }
[17:59:27.119]                 if (length(args) > 0) 
[17:59:27.119]                   base::do.call(base::Sys.setenv, args = args)
[17:59:27.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:27.119]             }
[17:59:27.119]             else {
[17:59:27.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:27.119]             }
[17:59:27.119]             {
[17:59:27.119]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:27.119]                   0L) {
[17:59:27.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:27.119]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:27.119]                   base::options(opts)
[17:59:27.119]                 }
[17:59:27.119]                 {
[17:59:27.119]                   {
[17:59:27.119]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:27.119]                     NULL
[17:59:27.119]                   }
[17:59:27.119]                   options(future.plan = NULL)
[17:59:27.119]                   if (is.na(NA_character_)) 
[17:59:27.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:27.119]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:27.119]                     .init = FALSE)
[17:59:27.119]                 }
[17:59:27.119]             }
[17:59:27.119]         }
[17:59:27.119]     })
[17:59:27.119]     if (TRUE) {
[17:59:27.119]         base::sink(type = "output", split = FALSE)
[17:59:27.119]         if (TRUE) {
[17:59:27.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:27.119]         }
[17:59:27.119]         else {
[17:59:27.119]             ...future.result["stdout"] <- base::list(NULL)
[17:59:27.119]         }
[17:59:27.119]         base::close(...future.stdout)
[17:59:27.119]         ...future.stdout <- NULL
[17:59:27.119]     }
[17:59:27.119]     ...future.result$conditions <- ...future.conditions
[17:59:27.119]     ...future.result$finished <- base::Sys.time()
[17:59:27.119]     ...future.result
[17:59:27.119] }
[17:59:27.124] assign_globals() ...
[17:59:27.124] List of 7
[17:59:27.124]  $ ...future.FUN            :function (x)  
[17:59:27.124]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:27.124]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:27.124]  $ future.call.arguments    : list()
[17:59:27.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.124]  $ ...future.elements_ii    :List of 1
[17:59:27.124]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.124]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:27.124]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.124]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:27.124]  $ ...future.seeds_ii       : NULL
[17:59:27.124]  $ ...future.globals.maxSize: NULL
[17:59:27.124]  - attr(*, "where")=List of 7
[17:59:27.124]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:27.124]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:59:27.124]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:59:27.124]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:27.124]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:27.124]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:27.124]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:27.124]  - attr(*, "resolved")= logi FALSE
[17:59:27.124]  - attr(*, "total_size")= num 2320
[17:59:27.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.124]  - attr(*, "already-done")= logi TRUE
[17:59:27.138] - reassign environment for ‘...future.FUN’
[17:59:27.138] - copied ‘...future.FUN’ to environment
[17:59:27.139] - copied ‘breaks’ to environment
[17:59:27.139] - copied ‘wool’ to environment
[17:59:27.139] - copied ‘future.call.arguments’ to environment
[17:59:27.139] - copied ‘...future.elements_ii’ to environment
[17:59:27.139] - copied ‘...future.seeds_ii’ to environment
[17:59:27.140] - copied ‘...future.globals.maxSize’ to environment
[17:59:27.140] assign_globals() ... done
[17:59:27.140] requestCore(): workers = 2
[17:59:27.143] MulticoreFuture started
[17:59:27.144] - Launch lazy future ... done
[17:59:27.145] run() for ‘MulticoreFuture’ ... done
[17:59:27.145] Created future:
[17:59:27.146] plan(): Setting new future strategy stack:
[17:59:27.147] List of future strategies:
[17:59:27.147] 1. sequential:
[17:59:27.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:27.147]    - tweaked: FALSE
[17:59:27.147]    - call: NULL
[17:59:27.149] plan(): nbrOfWorkers() = 1
[17:59:27.157] plan(): Setting new future strategy stack:
[17:59:27.157] List of future strategies:
[17:59:27.157] 1. multicore:
[17:59:27.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.157]    - tweaked: FALSE
[17:59:27.157]    - call: plan(strategy)
[17:59:27.146] MulticoreFuture:
[17:59:27.146] Label: ‘future_by-1’
[17:59:27.146] Expression:
[17:59:27.146] {
[17:59:27.146]     do.call(function(...) {
[17:59:27.146]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.146]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.146]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.146]             on.exit(options(oopts), add = TRUE)
[17:59:27.146]         }
[17:59:27.146]         {
[17:59:27.146]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.146]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.146]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.146]             })
[17:59:27.146]         }
[17:59:27.146]     }, args = future.call.arguments)
[17:59:27.146] }
[17:59:27.146] Lazy evaluation: FALSE
[17:59:27.146] Asynchronous evaluation: TRUE
[17:59:27.146] Local evaluation: TRUE
[17:59:27.146] Environment: 0x62649fdaa018
[17:59:27.146] Capture standard output: TRUE
[17:59:27.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:27.146] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:59:27.146] Packages: 1 packages (‘stats’)
[17:59:27.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:27.146] Resolved: FALSE
[17:59:27.146] Value: <not collected>
[17:59:27.146] Conditions captured: <none>
[17:59:27.146] Early signaling: FALSE
[17:59:27.146] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:27.146] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.162] Chunk #1 of 2 ... DONE
[17:59:27.163] Chunk #2 of 2 ...
[17:59:27.164]  - Finding globals in 'X' for chunk #2 ...
[17:59:27.164] getGlobalsAndPackages() ...
[17:59:27.164] Searching for globals...
[17:59:27.166] 
[17:59:27.166] Searching for globals ... DONE
[17:59:27.166] - globals: [0] <none>
[17:59:27.167] getGlobalsAndPackages() ... DONE
[17:59:27.167] plan(): nbrOfWorkers() = 2
[17:59:27.167]    + additional globals found: [n=0] 
[17:59:27.167]    + additional namespaces needed: [n=0] 
[17:59:27.167]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:27.168]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:27.168]  - seeds: <none>
[17:59:27.168]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.169] getGlobalsAndPackages() ...
[17:59:27.169] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.169] Resolving globals: FALSE
[17:59:27.170] Tweak future expression to call with '...' arguments ...
[17:59:27.170] {
[17:59:27.170]     do.call(function(...) {
[17:59:27.170]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.170]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.170]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.170]             on.exit(options(oopts), add = TRUE)
[17:59:27.170]         }
[17:59:27.170]         {
[17:59:27.170]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.170]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.170]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.170]             })
[17:59:27.170]         }
[17:59:27.170]     }, args = future.call.arguments)
[17:59:27.170] }
[17:59:27.171] Tweak future expression to call with '...' arguments ... DONE
[17:59:27.172] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.172] 
[17:59:27.173] getGlobalsAndPackages() ... DONE
[17:59:27.174] run() for ‘Future’ ...
[17:59:27.174] - state: ‘created’
[17:59:27.175] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:27.183] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:27.184]   - Field: ‘label’
[17:59:27.184]   - Field: ‘local’
[17:59:27.184]   - Field: ‘owner’
[17:59:27.185]   - Field: ‘envir’
[17:59:27.185]   - Field: ‘workers’
[17:59:27.185]   - Field: ‘packages’
[17:59:27.186]   - Field: ‘gc’
[17:59:27.191]   - Field: ‘job’
[17:59:27.192]   - Field: ‘conditions’
[17:59:27.192]   - Field: ‘expr’
[17:59:27.193]   - Field: ‘uuid’
[17:59:27.194]   - Field: ‘seed’
[17:59:27.195]   - Field: ‘version’
[17:59:27.195]   - Field: ‘result’
[17:59:27.196]   - Field: ‘asynchronous’
[17:59:27.196]   - Field: ‘calls’
[17:59:27.197]   - Field: ‘globals’
[17:59:27.197]   - Field: ‘stdout’
[17:59:27.198]   - Field: ‘earlySignal’
[17:59:27.199]   - Field: ‘lazy’
[17:59:27.199]   - Field: ‘state’
[17:59:27.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:27.200] - Launch lazy future ...
[17:59:27.201] Packages needed by the future expression (n = 1): ‘stats’
[17:59:27.202] Packages needed by future strategies (n = 0): <none>
[17:59:27.205] {
[17:59:27.205]     {
[17:59:27.205]         {
[17:59:27.205]             ...future.startTime <- base::Sys.time()
[17:59:27.205]             {
[17:59:27.205]                 {
[17:59:27.205]                   {
[17:59:27.205]                     {
[17:59:27.205]                       {
[17:59:27.205]                         base::local({
[17:59:27.205]                           has_future <- base::requireNamespace("future", 
[17:59:27.205]                             quietly = TRUE)
[17:59:27.205]                           if (has_future) {
[17:59:27.205]                             ns <- base::getNamespace("future")
[17:59:27.205]                             version <- ns[[".package"]][["version"]]
[17:59:27.205]                             if (is.null(version)) 
[17:59:27.205]                               version <- utils::packageVersion("future")
[17:59:27.205]                           }
[17:59:27.205]                           else {
[17:59:27.205]                             version <- NULL
[17:59:27.205]                           }
[17:59:27.205]                           if (!has_future || version < "1.8.0") {
[17:59:27.205]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:27.205]                               "", base::R.version$version.string), 
[17:59:27.205]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:27.205]                                 base::R.version$platform, 8 * 
[17:59:27.205]                                   base::.Machine$sizeof.pointer), 
[17:59:27.205]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:27.205]                                 "release", "version")], collapse = " "), 
[17:59:27.205]                               hostname = base::Sys.info()[["nodename"]])
[17:59:27.205]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:27.205]                               info)
[17:59:27.205]                             info <- base::paste(info, collapse = "; ")
[17:59:27.205]                             if (!has_future) {
[17:59:27.205]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:27.205]                                 info)
[17:59:27.205]                             }
[17:59:27.205]                             else {
[17:59:27.205]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:27.205]                                 info, version)
[17:59:27.205]                             }
[17:59:27.205]                             base::stop(msg)
[17:59:27.205]                           }
[17:59:27.205]                         })
[17:59:27.205]                       }
[17:59:27.205]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:27.205]                       base::options(mc.cores = 1L)
[17:59:27.205]                     }
[17:59:27.205]                     base::local({
[17:59:27.205]                       for (pkg in "stats") {
[17:59:27.205]                         base::loadNamespace(pkg)
[17:59:27.205]                         base::library(pkg, character.only = TRUE)
[17:59:27.205]                       }
[17:59:27.205]                     })
[17:59:27.205]                   }
[17:59:27.205]                   ...future.strategy.old <- future::plan("list")
[17:59:27.205]                   options(future.plan = NULL)
[17:59:27.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:27.205]                 }
[17:59:27.205]                 ...future.workdir <- getwd()
[17:59:27.205]             }
[17:59:27.205]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:27.205]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:27.205]         }
[17:59:27.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:27.205]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:27.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:27.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:27.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:27.205]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:27.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:27.205]             base::names(...future.oldOptions))
[17:59:27.205]     }
[17:59:27.205]     if (FALSE) {
[17:59:27.205]     }
[17:59:27.205]     else {
[17:59:27.205]         if (TRUE) {
[17:59:27.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:27.205]                 open = "w")
[17:59:27.205]         }
[17:59:27.205]         else {
[17:59:27.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:27.205]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:27.205]         }
[17:59:27.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:27.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:27.205]             base::sink(type = "output", split = FALSE)
[17:59:27.205]             base::close(...future.stdout)
[17:59:27.205]         }, add = TRUE)
[17:59:27.205]     }
[17:59:27.205]     ...future.frame <- base::sys.nframe()
[17:59:27.205]     ...future.conditions <- base::list()
[17:59:27.205]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:27.205]     if (FALSE) {
[17:59:27.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:27.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:27.205]     }
[17:59:27.205]     ...future.result <- base::tryCatch({
[17:59:27.205]         base::withCallingHandlers({
[17:59:27.205]             ...future.value <- base::withVisible(base::local({
[17:59:27.205]                 withCallingHandlers({
[17:59:27.205]                   {
[17:59:27.205]                     do.call(function(...) {
[17:59:27.205]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.205]                       if (!identical(...future.globals.maxSize.org, 
[17:59:27.205]                         ...future.globals.maxSize)) {
[17:59:27.205]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.205]                         on.exit(options(oopts), add = TRUE)
[17:59:27.205]                       }
[17:59:27.205]                       {
[17:59:27.205]                         lapply(seq_along(...future.elements_ii), 
[17:59:27.205]                           FUN = function(jj) {
[17:59:27.205]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.205]                             ...future.FUN(...future.X_jj, ...)
[17:59:27.205]                           })
[17:59:27.205]                       }
[17:59:27.205]                     }, args = future.call.arguments)
[17:59:27.205]                   }
[17:59:27.205]                 }, immediateCondition = function(cond) {
[17:59:27.205]                   save_rds <- function (object, pathname, ...) 
[17:59:27.205]                   {
[17:59:27.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:27.205]                     if (file_test("-f", pathname_tmp)) {
[17:59:27.205]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:27.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.205]                         fi_tmp[["mtime"]])
[17:59:27.205]                     }
[17:59:27.205]                     tryCatch({
[17:59:27.205]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:27.205]                     }, error = function(ex) {
[17:59:27.205]                       msg <- conditionMessage(ex)
[17:59:27.205]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:27.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.205]                         fi_tmp[["mtime"]], msg)
[17:59:27.205]                       ex$message <- msg
[17:59:27.205]                       stop(ex)
[17:59:27.205]                     })
[17:59:27.205]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:27.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:27.205]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:27.205]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.205]                       fi <- file.info(pathname)
[17:59:27.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:27.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:27.205]                         fi[["size"]], fi[["mtime"]])
[17:59:27.205]                       stop(msg)
[17:59:27.205]                     }
[17:59:27.205]                     invisible(pathname)
[17:59:27.205]                   }
[17:59:27.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:27.205]                     rootPath = tempdir()) 
[17:59:27.205]                   {
[17:59:27.205]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:27.205]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:27.205]                       tmpdir = path, fileext = ".rds")
[17:59:27.205]                     save_rds(obj, file)
[17:59:27.205]                   }
[17:59:27.205]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:27.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.205]                   {
[17:59:27.205]                     inherits <- base::inherits
[17:59:27.205]                     invokeRestart <- base::invokeRestart
[17:59:27.205]                     is.null <- base::is.null
[17:59:27.205]                     muffled <- FALSE
[17:59:27.205]                     if (inherits(cond, "message")) {
[17:59:27.205]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:27.205]                       if (muffled) 
[17:59:27.205]                         invokeRestart("muffleMessage")
[17:59:27.205]                     }
[17:59:27.205]                     else if (inherits(cond, "warning")) {
[17:59:27.205]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:27.205]                       if (muffled) 
[17:59:27.205]                         invokeRestart("muffleWarning")
[17:59:27.205]                     }
[17:59:27.205]                     else if (inherits(cond, "condition")) {
[17:59:27.205]                       if (!is.null(pattern)) {
[17:59:27.205]                         computeRestarts <- base::computeRestarts
[17:59:27.205]                         grepl <- base::grepl
[17:59:27.205]                         restarts <- computeRestarts(cond)
[17:59:27.205]                         for (restart in restarts) {
[17:59:27.205]                           name <- restart$name
[17:59:27.205]                           if (is.null(name)) 
[17:59:27.205]                             next
[17:59:27.205]                           if (!grepl(pattern, name)) 
[17:59:27.205]                             next
[17:59:27.205]                           invokeRestart(restart)
[17:59:27.205]                           muffled <- TRUE
[17:59:27.205]                           break
[17:59:27.205]                         }
[17:59:27.205]                       }
[17:59:27.205]                     }
[17:59:27.205]                     invisible(muffled)
[17:59:27.205]                   }
[17:59:27.205]                   muffleCondition(cond)
[17:59:27.205]                 })
[17:59:27.205]             }))
[17:59:27.205]             future::FutureResult(value = ...future.value$value, 
[17:59:27.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.205]                   ...future.rng), globalenv = if (FALSE) 
[17:59:27.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:27.205]                     ...future.globalenv.names))
[17:59:27.205]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:27.205]         }, condition = base::local({
[17:59:27.205]             c <- base::c
[17:59:27.205]             inherits <- base::inherits
[17:59:27.205]             invokeRestart <- base::invokeRestart
[17:59:27.205]             length <- base::length
[17:59:27.205]             list <- base::list
[17:59:27.205]             seq.int <- base::seq.int
[17:59:27.205]             signalCondition <- base::signalCondition
[17:59:27.205]             sys.calls <- base::sys.calls
[17:59:27.205]             `[[` <- base::`[[`
[17:59:27.205]             `+` <- base::`+`
[17:59:27.205]             `<<-` <- base::`<<-`
[17:59:27.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:27.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:27.205]                   3L)]
[17:59:27.205]             }
[17:59:27.205]             function(cond) {
[17:59:27.205]                 is_error <- inherits(cond, "error")
[17:59:27.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:27.205]                   NULL)
[17:59:27.205]                 if (is_error) {
[17:59:27.205]                   sessionInformation <- function() {
[17:59:27.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:27.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:27.205]                       search = base::search(), system = base::Sys.info())
[17:59:27.205]                   }
[17:59:27.205]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:27.205]                     cond$call), session = sessionInformation(), 
[17:59:27.205]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:27.205]                   signalCondition(cond)
[17:59:27.205]                 }
[17:59:27.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:27.205]                 "immediateCondition"))) {
[17:59:27.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:27.205]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:27.205]                   if (TRUE && !signal) {
[17:59:27.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.205]                     {
[17:59:27.205]                       inherits <- base::inherits
[17:59:27.205]                       invokeRestart <- base::invokeRestart
[17:59:27.205]                       is.null <- base::is.null
[17:59:27.205]                       muffled <- FALSE
[17:59:27.205]                       if (inherits(cond, "message")) {
[17:59:27.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.205]                         if (muffled) 
[17:59:27.205]                           invokeRestart("muffleMessage")
[17:59:27.205]                       }
[17:59:27.205]                       else if (inherits(cond, "warning")) {
[17:59:27.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.205]                         if (muffled) 
[17:59:27.205]                           invokeRestart("muffleWarning")
[17:59:27.205]                       }
[17:59:27.205]                       else if (inherits(cond, "condition")) {
[17:59:27.205]                         if (!is.null(pattern)) {
[17:59:27.205]                           computeRestarts <- base::computeRestarts
[17:59:27.205]                           grepl <- base::grepl
[17:59:27.205]                           restarts <- computeRestarts(cond)
[17:59:27.205]                           for (restart in restarts) {
[17:59:27.205]                             name <- restart$name
[17:59:27.205]                             if (is.null(name)) 
[17:59:27.205]                               next
[17:59:27.205]                             if (!grepl(pattern, name)) 
[17:59:27.205]                               next
[17:59:27.205]                             invokeRestart(restart)
[17:59:27.205]                             muffled <- TRUE
[17:59:27.205]                             break
[17:59:27.205]                           }
[17:59:27.205]                         }
[17:59:27.205]                       }
[17:59:27.205]                       invisible(muffled)
[17:59:27.205]                     }
[17:59:27.205]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.205]                   }
[17:59:27.205]                 }
[17:59:27.205]                 else {
[17:59:27.205]                   if (TRUE) {
[17:59:27.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.205]                     {
[17:59:27.205]                       inherits <- base::inherits
[17:59:27.205]                       invokeRestart <- base::invokeRestart
[17:59:27.205]                       is.null <- base::is.null
[17:59:27.205]                       muffled <- FALSE
[17:59:27.205]                       if (inherits(cond, "message")) {
[17:59:27.205]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.205]                         if (muffled) 
[17:59:27.205]                           invokeRestart("muffleMessage")
[17:59:27.205]                       }
[17:59:27.205]                       else if (inherits(cond, "warning")) {
[17:59:27.205]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.205]                         if (muffled) 
[17:59:27.205]                           invokeRestart("muffleWarning")
[17:59:27.205]                       }
[17:59:27.205]                       else if (inherits(cond, "condition")) {
[17:59:27.205]                         if (!is.null(pattern)) {
[17:59:27.205]                           computeRestarts <- base::computeRestarts
[17:59:27.205]                           grepl <- base::grepl
[17:59:27.205]                           restarts <- computeRestarts(cond)
[17:59:27.205]                           for (restart in restarts) {
[17:59:27.205]                             name <- restart$name
[17:59:27.205]                             if (is.null(name)) 
[17:59:27.205]                               next
[17:59:27.205]                             if (!grepl(pattern, name)) 
[17:59:27.205]                               next
[17:59:27.205]                             invokeRestart(restart)
[17:59:27.205]                             muffled <- TRUE
[17:59:27.205]                             break
[17:59:27.205]                           }
[17:59:27.205]                         }
[17:59:27.205]                       }
[17:59:27.205]                       invisible(muffled)
[17:59:27.205]                     }
[17:59:27.205]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.205]                   }
[17:59:27.205]                 }
[17:59:27.205]             }
[17:59:27.205]         }))
[17:59:27.205]     }, error = function(ex) {
[17:59:27.205]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:27.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.205]                 ...future.rng), started = ...future.startTime, 
[17:59:27.205]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:27.205]             version = "1.8"), class = "FutureResult")
[17:59:27.205]     }, finally = {
[17:59:27.205]         if (!identical(...future.workdir, getwd())) 
[17:59:27.205]             setwd(...future.workdir)
[17:59:27.205]         {
[17:59:27.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:27.205]                 ...future.oldOptions$nwarnings <- NULL
[17:59:27.205]             }
[17:59:27.205]             base::options(...future.oldOptions)
[17:59:27.205]             if (.Platform$OS.type == "windows") {
[17:59:27.205]                 old_names <- names(...future.oldEnvVars)
[17:59:27.205]                 envs <- base::Sys.getenv()
[17:59:27.205]                 names <- names(envs)
[17:59:27.205]                 common <- intersect(names, old_names)
[17:59:27.205]                 added <- setdiff(names, old_names)
[17:59:27.205]                 removed <- setdiff(old_names, names)
[17:59:27.205]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:27.205]                   envs[common]]
[17:59:27.205]                 NAMES <- toupper(changed)
[17:59:27.205]                 args <- list()
[17:59:27.205]                 for (kk in seq_along(NAMES)) {
[17:59:27.205]                   name <- changed[[kk]]
[17:59:27.205]                   NAME <- NAMES[[kk]]
[17:59:27.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.205]                     next
[17:59:27.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.205]                 }
[17:59:27.205]                 NAMES <- toupper(added)
[17:59:27.205]                 for (kk in seq_along(NAMES)) {
[17:59:27.205]                   name <- added[[kk]]
[17:59:27.205]                   NAME <- NAMES[[kk]]
[17:59:27.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.205]                     next
[17:59:27.205]                   args[[name]] <- ""
[17:59:27.205]                 }
[17:59:27.205]                 NAMES <- toupper(removed)
[17:59:27.205]                 for (kk in seq_along(NAMES)) {
[17:59:27.205]                   name <- removed[[kk]]
[17:59:27.205]                   NAME <- NAMES[[kk]]
[17:59:27.205]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.205]                     next
[17:59:27.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.205]                 }
[17:59:27.205]                 if (length(args) > 0) 
[17:59:27.205]                   base::do.call(base::Sys.setenv, args = args)
[17:59:27.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:27.205]             }
[17:59:27.205]             else {
[17:59:27.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:27.205]             }
[17:59:27.205]             {
[17:59:27.205]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:27.205]                   0L) {
[17:59:27.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:27.205]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:27.205]                   base::options(opts)
[17:59:27.205]                 }
[17:59:27.205]                 {
[17:59:27.205]                   {
[17:59:27.205]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:27.205]                     NULL
[17:59:27.205]                   }
[17:59:27.205]                   options(future.plan = NULL)
[17:59:27.205]                   if (is.na(NA_character_)) 
[17:59:27.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:27.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:27.205]                     .init = FALSE)
[17:59:27.205]                 }
[17:59:27.205]             }
[17:59:27.205]         }
[17:59:27.205]     })
[17:59:27.205]     if (TRUE) {
[17:59:27.205]         base::sink(type = "output", split = FALSE)
[17:59:27.205]         if (TRUE) {
[17:59:27.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:27.205]         }
[17:59:27.205]         else {
[17:59:27.205]             ...future.result["stdout"] <- base::list(NULL)
[17:59:27.205]         }
[17:59:27.205]         base::close(...future.stdout)
[17:59:27.205]         ...future.stdout <- NULL
[17:59:27.205]     }
[17:59:27.205]     ...future.result$conditions <- ...future.conditions
[17:59:27.205]     ...future.result$finished <- base::Sys.time()
[17:59:27.205]     ...future.result
[17:59:27.205] }
[17:59:27.211] assign_globals() ...
[17:59:27.211] List of 7
[17:59:27.211]  $ ...future.FUN            :function (x)  
[17:59:27.211]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:27.211]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:27.211]  $ future.call.arguments    : list()
[17:59:27.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.211]  $ ...future.elements_ii    :List of 2
[17:59:27.211]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.211]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:27.211]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.211]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:27.211]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.211]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:27.211]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.211]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:27.211]  $ ...future.seeds_ii       : NULL
[17:59:27.211]  $ ...future.globals.maxSize: NULL
[17:59:27.211]  - attr(*, "where")=List of 7
[17:59:27.211]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:27.211]   ..$ breaks                   :<environment: R_EmptyEnv> 
[17:59:27.211]   ..$ wool                     :<environment: R_EmptyEnv> 
[17:59:27.211]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:27.211]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:27.211]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:27.211]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:27.211]  - attr(*, "resolved")= logi FALSE
[17:59:27.211]  - attr(*, "total_size")= num 2320
[17:59:27.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.211]  - attr(*, "already-done")= logi TRUE
[17:59:27.238] - reassign environment for ‘...future.FUN’
[17:59:27.238] - copied ‘...future.FUN’ to environment
[17:59:27.238] - copied ‘breaks’ to environment
[17:59:27.238] - copied ‘wool’ to environment
[17:59:27.239] - copied ‘future.call.arguments’ to environment
[17:59:27.239] - copied ‘...future.elements_ii’ to environment
[17:59:27.239] - copied ‘...future.seeds_ii’ to environment
[17:59:27.239] - copied ‘...future.globals.maxSize’ to environment
[17:59:27.239] assign_globals() ... done
[17:59:27.240] requestCore(): workers = 2
[17:59:27.243] MulticoreFuture started
[17:59:27.244] - Launch lazy future ... done
[17:59:27.245] run() for ‘MulticoreFuture’ ... done
[17:59:27.245] Created future:
[17:59:27.246] plan(): Setting new future strategy stack:
[17:59:27.246] List of future strategies:
[17:59:27.246] 1. sequential:
[17:59:27.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:27.246]    - tweaked: FALSE
[17:59:27.246]    - call: NULL
[17:59:27.248] plan(): nbrOfWorkers() = 1
[17:59:27.258] plan(): Setting new future strategy stack:
[17:59:27.258] List of future strategies:
[17:59:27.258] 1. multicore:
[17:59:27.258]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.258]    - tweaked: FALSE
[17:59:27.258]    - call: plan(strategy)
[17:59:27.245] MulticoreFuture:
[17:59:27.245] Label: ‘future_by-2’
[17:59:27.245] Expression:
[17:59:27.245] {
[17:59:27.245]     do.call(function(...) {
[17:59:27.245]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.245]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.245]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.245]             on.exit(options(oopts), add = TRUE)
[17:59:27.245]         }
[17:59:27.245]         {
[17:59:27.245]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.245]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.245]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.245]             })
[17:59:27.245]         }
[17:59:27.245]     }, args = future.call.arguments)
[17:59:27.245] }
[17:59:27.245] Lazy evaluation: FALSE
[17:59:27.245] Asynchronous evaluation: TRUE
[17:59:27.245] Local evaluation: TRUE
[17:59:27.245] Environment: 0x62649fdaa018
[17:59:27.245] Capture standard output: TRUE
[17:59:27.245] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:27.245] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:59:27.245] Packages: 1 packages (‘stats’)
[17:59:27.245] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:27.245] Resolved: FALSE
[17:59:27.245] Value: <not collected>
[17:59:27.245] Conditions captured: <none>
[17:59:27.245] Early signaling: FALSE
[17:59:27.245] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:27.245] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.262] Chunk #2 of 2 ... DONE
[17:59:27.262] Launching 2 futures (chunks) ... DONE
[17:59:27.262] Resolving 2 futures (chunks) ...
[17:59:27.263] resolve() on list ...
[17:59:27.263]  recursive: 0
[17:59:27.263]  length: 2
[17:59:27.264] 
[17:59:27.264] Future #1
[17:59:27.265] result() for MulticoreFuture ...
[17:59:27.268] plan(): nbrOfWorkers() = 2
[17:59:27.269] result() for MulticoreFuture ...
[17:59:27.270] result() for MulticoreFuture ... done
[17:59:27.270] result() for MulticoreFuture ... done
[17:59:27.270] result() for MulticoreFuture ...
[17:59:27.271] result() for MulticoreFuture ... done
[17:59:27.271] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:27.271] - nx: 2
[17:59:27.272] - relay: TRUE
[17:59:27.272] - stdout: TRUE
[17:59:27.272] - signal: TRUE
[17:59:27.272] - resignal: FALSE
[17:59:27.273] - force: TRUE
[17:59:27.273] - relayed: [n=2] FALSE, FALSE
[17:59:27.273] - queued futures: [n=2] FALSE, FALSE
[17:59:27.274]  - until=1
[17:59:27.274]  - relaying element #1
[17:59:27.275] result() for MulticoreFuture ...
[17:59:27.275] result() for MulticoreFuture ... done
[17:59:27.275] result() for MulticoreFuture ...
[17:59:27.276] result() for MulticoreFuture ... done
[17:59:27.276] result() for MulticoreFuture ...
[17:59:27.276] result() for MulticoreFuture ... done
[17:59:27.277] result() for MulticoreFuture ...
[17:59:27.277] result() for MulticoreFuture ... done
[17:59:27.277] - relayed: [n=2] TRUE, FALSE
[17:59:27.278] - queued futures: [n=2] TRUE, FALSE
[17:59:27.283] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:27.284]  length: 1 (resolved future 1)
[17:59:27.286] Future #2
[17:59:27.286] result() for MulticoreFuture ...
[17:59:27.293] result() for MulticoreFuture ...
[17:59:27.294] result() for MulticoreFuture ... done
[17:59:27.294] result() for MulticoreFuture ... done
[17:59:27.295] result() for MulticoreFuture ...
[17:59:27.297] result() for MulticoreFuture ... done
[17:59:27.297] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:27.297] - nx: 2
[17:59:27.298] - relay: TRUE
[17:59:27.298] - stdout: TRUE
[17:59:27.298] - signal: TRUE
[17:59:27.299] - resignal: FALSE
[17:59:27.299] - force: TRUE
[17:59:27.299] - relayed: [n=2] TRUE, FALSE
[17:59:27.299] - queued futures: [n=2] TRUE, FALSE
[17:59:27.300]  - until=2
[17:59:27.300]  - relaying element #2
[17:59:27.300] result() for MulticoreFuture ...
[17:59:27.301] result() for MulticoreFuture ... done
[17:59:27.301] result() for MulticoreFuture ...
[17:59:27.301] result() for MulticoreFuture ... done
[17:59:27.302] result() for MulticoreFuture ...
[17:59:27.302] result() for MulticoreFuture ... done
[17:59:27.302] result() for MulticoreFuture ...
[17:59:27.302] result() for MulticoreFuture ... done
[17:59:27.303] - relayed: [n=2] TRUE, TRUE
[17:59:27.303] - queued futures: [n=2] TRUE, TRUE
[17:59:27.303] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:27.304]  length: 0 (resolved future 2)
[17:59:27.304] Relaying remaining futures
[17:59:27.304] signalConditionsASAP(NULL, pos=0) ...
[17:59:27.305] - nx: 2
[17:59:27.305] - relay: TRUE
[17:59:27.305] - stdout: TRUE
[17:59:27.305] - signal: TRUE
[17:59:27.305] - resignal: FALSE
[17:59:27.306] - force: TRUE
[17:59:27.306] - relayed: [n=2] TRUE, TRUE
[17:59:27.306] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:27.306] - relayed: [n=2] TRUE, TRUE
[17:59:27.307] - queued futures: [n=2] TRUE, TRUE
[17:59:27.307] signalConditionsASAP(NULL, pos=0) ... done
[17:59:27.307] resolve() on list ... DONE
[17:59:27.307] result() for MulticoreFuture ...
[17:59:27.308] result() for MulticoreFuture ... done
[17:59:27.308] result() for MulticoreFuture ...
[17:59:27.308] result() for MulticoreFuture ... done
[17:59:27.308] result() for MulticoreFuture ...
[17:59:27.309] result() for MulticoreFuture ... done
[17:59:27.309] result() for MulticoreFuture ...
[17:59:27.309] result() for MulticoreFuture ... done
[17:59:27.309]  - Number of value chunks collected: 2
[17:59:27.310] Resolving 2 futures (chunks) ... DONE
[17:59:27.310] Reducing values from 2 chunks ...
[17:59:27.310]  - Number of values collected after concatenation: 3
[17:59:27.310]  - Number of values expected: 3
[17:59:27.310] Reducing values from 2 chunks ... DONE
[17:59:27.311] future_lapply() ... DONE
[17:59:27.311] future_by_internal() ... DONE
[17:59:27.312] future_by_internal() ...
[17:59:27.313] future_lapply() ...
[17:59:27.320] Number of chunks: 2
[17:59:27.321] getGlobalsAndPackagesXApply() ...
[17:59:27.321]  - future.globals: TRUE
[17:59:27.321] getGlobalsAndPackages() ...
[17:59:27.321] Searching for globals...
[17:59:27.324] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:27.324] Searching for globals ... DONE
[17:59:27.324] Resolving globals: FALSE
[17:59:27.325] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:27.326] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:27.326] - globals: [1] ‘FUN’
[17:59:27.326] 
[17:59:27.326] getGlobalsAndPackages() ... DONE
[17:59:27.326]  - globals found/used: [n=1] ‘FUN’
[17:59:27.327]  - needed namespaces: [n=0] 
[17:59:27.327] Finding globals ... DONE
[17:59:27.327]  - use_args: TRUE
[17:59:27.327]  - Getting '...' globals ...
[17:59:27.328] resolve() on list ...
[17:59:27.328]  recursive: 0
[17:59:27.328]  length: 1
[17:59:27.329]  elements: ‘...’
[17:59:27.329]  length: 0 (resolved future 1)
[17:59:27.329] resolve() on list ... DONE
[17:59:27.329]    - '...' content: [n=0] 
[17:59:27.329] List of 1
[17:59:27.329]  $ ...: list()
[17:59:27.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.329]  - attr(*, "where")=List of 1
[17:59:27.329]   ..$ ...:<environment: 0x62649e6be880> 
[17:59:27.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.329]  - attr(*, "resolved")= logi TRUE
[17:59:27.329]  - attr(*, "total_size")= num NA
[17:59:27.335]  - Getting '...' globals ... DONE
[17:59:27.335] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:27.335] List of 2
[17:59:27.335]  $ ...future.FUN:function (object, ...)  
[17:59:27.335]  $ ...          : list()
[17:59:27.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.335]  - attr(*, "where")=List of 2
[17:59:27.335]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:27.335]   ..$ ...          :<environment: 0x62649e6be880> 
[17:59:27.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.335]  - attr(*, "resolved")= logi FALSE
[17:59:27.335]  - attr(*, "total_size")= num 1240
[17:59:27.346] Packages to be attached in all futures: [n=0] 
[17:59:27.346] getGlobalsAndPackagesXApply() ... DONE
[17:59:27.346] Number of futures (= number of chunks): 2
[17:59:27.347] Launching 2 futures (chunks) ...
[17:59:27.347] Chunk #1 of 2 ...
[17:59:27.347]  - Finding globals in 'X' for chunk #1 ...
[17:59:27.347] getGlobalsAndPackages() ...
[17:59:27.348] Searching for globals...
[17:59:27.348] 
[17:59:27.349] Searching for globals ... DONE
[17:59:27.349] - globals: [0] <none>
[17:59:27.349] getGlobalsAndPackages() ... DONE
[17:59:27.349]    + additional globals found: [n=0] 
[17:59:27.349]    + additional namespaces needed: [n=0] 
[17:59:27.350]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:27.350]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:27.350]  - seeds: <none>
[17:59:27.350]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.351] getGlobalsAndPackages() ...
[17:59:27.351] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.351] Resolving globals: FALSE
[17:59:27.351] Tweak future expression to call with '...' arguments ...
[17:59:27.352] {
[17:59:27.352]     do.call(function(...) {
[17:59:27.352]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.352]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.352]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.352]             on.exit(options(oopts), add = TRUE)
[17:59:27.352]         }
[17:59:27.352]         {
[17:59:27.352]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.352]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.352]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.352]             })
[17:59:27.352]         }
[17:59:27.352]     }, args = future.call.arguments)
[17:59:27.352] }
[17:59:27.352] Tweak future expression to call with '...' arguments ... DONE
[17:59:27.353] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.353] 
[17:59:27.353] getGlobalsAndPackages() ... DONE
[17:59:27.354] run() for ‘Future’ ...
[17:59:27.354] - state: ‘created’
[17:59:27.354] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:27.361] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.361] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:27.362]   - Field: ‘label’
[17:59:27.362]   - Field: ‘local’
[17:59:27.362]   - Field: ‘owner’
[17:59:27.362]   - Field: ‘envir’
[17:59:27.363]   - Field: ‘workers’
[17:59:27.363]   - Field: ‘packages’
[17:59:27.363]   - Field: ‘gc’
[17:59:27.363]   - Field: ‘job’
[17:59:27.363]   - Field: ‘conditions’
[17:59:27.364]   - Field: ‘expr’
[17:59:27.364]   - Field: ‘uuid’
[17:59:27.364]   - Field: ‘seed’
[17:59:27.364]   - Field: ‘version’
[17:59:27.364]   - Field: ‘result’
[17:59:27.365]   - Field: ‘asynchronous’
[17:59:27.365]   - Field: ‘calls’
[17:59:27.365]   - Field: ‘globals’
[17:59:27.365]   - Field: ‘stdout’
[17:59:27.365]   - Field: ‘earlySignal’
[17:59:27.366]   - Field: ‘lazy’
[17:59:27.366]   - Field: ‘state’
[17:59:27.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:27.366] - Launch lazy future ...
[17:59:27.367] Packages needed by the future expression (n = 0): <none>
[17:59:27.367] Packages needed by future strategies (n = 0): <none>
[17:59:27.368] {
[17:59:27.368]     {
[17:59:27.368]         {
[17:59:27.368]             ...future.startTime <- base::Sys.time()
[17:59:27.368]             {
[17:59:27.368]                 {
[17:59:27.368]                   {
[17:59:27.368]                     {
[17:59:27.368]                       base::local({
[17:59:27.368]                         has_future <- base::requireNamespace("future", 
[17:59:27.368]                           quietly = TRUE)
[17:59:27.368]                         if (has_future) {
[17:59:27.368]                           ns <- base::getNamespace("future")
[17:59:27.368]                           version <- ns[[".package"]][["version"]]
[17:59:27.368]                           if (is.null(version)) 
[17:59:27.368]                             version <- utils::packageVersion("future")
[17:59:27.368]                         }
[17:59:27.368]                         else {
[17:59:27.368]                           version <- NULL
[17:59:27.368]                         }
[17:59:27.368]                         if (!has_future || version < "1.8.0") {
[17:59:27.368]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:27.368]                             "", base::R.version$version.string), 
[17:59:27.368]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:27.368]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:27.368]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:27.368]                               "release", "version")], collapse = " "), 
[17:59:27.368]                             hostname = base::Sys.info()[["nodename"]])
[17:59:27.368]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:27.368]                             info)
[17:59:27.368]                           info <- base::paste(info, collapse = "; ")
[17:59:27.368]                           if (!has_future) {
[17:59:27.368]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:27.368]                               info)
[17:59:27.368]                           }
[17:59:27.368]                           else {
[17:59:27.368]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:27.368]                               info, version)
[17:59:27.368]                           }
[17:59:27.368]                           base::stop(msg)
[17:59:27.368]                         }
[17:59:27.368]                       })
[17:59:27.368]                     }
[17:59:27.368]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:27.368]                     base::options(mc.cores = 1L)
[17:59:27.368]                   }
[17:59:27.368]                   ...future.strategy.old <- future::plan("list")
[17:59:27.368]                   options(future.plan = NULL)
[17:59:27.368]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.368]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:27.368]                 }
[17:59:27.368]                 ...future.workdir <- getwd()
[17:59:27.368]             }
[17:59:27.368]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:27.368]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:27.368]         }
[17:59:27.368]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:27.368]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:27.368]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:27.368]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:27.368]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:27.368]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:27.368]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:27.368]             base::names(...future.oldOptions))
[17:59:27.368]     }
[17:59:27.368]     if (FALSE) {
[17:59:27.368]     }
[17:59:27.368]     else {
[17:59:27.368]         if (TRUE) {
[17:59:27.368]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:27.368]                 open = "w")
[17:59:27.368]         }
[17:59:27.368]         else {
[17:59:27.368]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:27.368]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:27.368]         }
[17:59:27.368]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:27.368]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:27.368]             base::sink(type = "output", split = FALSE)
[17:59:27.368]             base::close(...future.stdout)
[17:59:27.368]         }, add = TRUE)
[17:59:27.368]     }
[17:59:27.368]     ...future.frame <- base::sys.nframe()
[17:59:27.368]     ...future.conditions <- base::list()
[17:59:27.368]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:27.368]     if (FALSE) {
[17:59:27.368]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:27.368]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:27.368]     }
[17:59:27.368]     ...future.result <- base::tryCatch({
[17:59:27.368]         base::withCallingHandlers({
[17:59:27.368]             ...future.value <- base::withVisible(base::local({
[17:59:27.368]                 withCallingHandlers({
[17:59:27.368]                   {
[17:59:27.368]                     do.call(function(...) {
[17:59:27.368]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.368]                       if (!identical(...future.globals.maxSize.org, 
[17:59:27.368]                         ...future.globals.maxSize)) {
[17:59:27.368]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.368]                         on.exit(options(oopts), add = TRUE)
[17:59:27.368]                       }
[17:59:27.368]                       {
[17:59:27.368]                         lapply(seq_along(...future.elements_ii), 
[17:59:27.368]                           FUN = function(jj) {
[17:59:27.368]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.368]                             ...future.FUN(...future.X_jj, ...)
[17:59:27.368]                           })
[17:59:27.368]                       }
[17:59:27.368]                     }, args = future.call.arguments)
[17:59:27.368]                   }
[17:59:27.368]                 }, immediateCondition = function(cond) {
[17:59:27.368]                   save_rds <- function (object, pathname, ...) 
[17:59:27.368]                   {
[17:59:27.368]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:27.368]                     if (file_test("-f", pathname_tmp)) {
[17:59:27.368]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.368]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:27.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.368]                         fi_tmp[["mtime"]])
[17:59:27.368]                     }
[17:59:27.368]                     tryCatch({
[17:59:27.368]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:27.368]                     }, error = function(ex) {
[17:59:27.368]                       msg <- conditionMessage(ex)
[17:59:27.368]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.368]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:27.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.368]                         fi_tmp[["mtime"]], msg)
[17:59:27.368]                       ex$message <- msg
[17:59:27.368]                       stop(ex)
[17:59:27.368]                     })
[17:59:27.368]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:27.368]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:27.368]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:27.368]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.368]                       fi <- file.info(pathname)
[17:59:27.368]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:27.368]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.368]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:27.368]                         fi[["size"]], fi[["mtime"]])
[17:59:27.368]                       stop(msg)
[17:59:27.368]                     }
[17:59:27.368]                     invisible(pathname)
[17:59:27.368]                   }
[17:59:27.368]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:27.368]                     rootPath = tempdir()) 
[17:59:27.368]                   {
[17:59:27.368]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:27.368]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:27.368]                       tmpdir = path, fileext = ".rds")
[17:59:27.368]                     save_rds(obj, file)
[17:59:27.368]                   }
[17:59:27.368]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:27.368]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.368]                   {
[17:59:27.368]                     inherits <- base::inherits
[17:59:27.368]                     invokeRestart <- base::invokeRestart
[17:59:27.368]                     is.null <- base::is.null
[17:59:27.368]                     muffled <- FALSE
[17:59:27.368]                     if (inherits(cond, "message")) {
[17:59:27.368]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:27.368]                       if (muffled) 
[17:59:27.368]                         invokeRestart("muffleMessage")
[17:59:27.368]                     }
[17:59:27.368]                     else if (inherits(cond, "warning")) {
[17:59:27.368]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:27.368]                       if (muffled) 
[17:59:27.368]                         invokeRestart("muffleWarning")
[17:59:27.368]                     }
[17:59:27.368]                     else if (inherits(cond, "condition")) {
[17:59:27.368]                       if (!is.null(pattern)) {
[17:59:27.368]                         computeRestarts <- base::computeRestarts
[17:59:27.368]                         grepl <- base::grepl
[17:59:27.368]                         restarts <- computeRestarts(cond)
[17:59:27.368]                         for (restart in restarts) {
[17:59:27.368]                           name <- restart$name
[17:59:27.368]                           if (is.null(name)) 
[17:59:27.368]                             next
[17:59:27.368]                           if (!grepl(pattern, name)) 
[17:59:27.368]                             next
[17:59:27.368]                           invokeRestart(restart)
[17:59:27.368]                           muffled <- TRUE
[17:59:27.368]                           break
[17:59:27.368]                         }
[17:59:27.368]                       }
[17:59:27.368]                     }
[17:59:27.368]                     invisible(muffled)
[17:59:27.368]                   }
[17:59:27.368]                   muffleCondition(cond)
[17:59:27.368]                 })
[17:59:27.368]             }))
[17:59:27.368]             future::FutureResult(value = ...future.value$value, 
[17:59:27.368]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.368]                   ...future.rng), globalenv = if (FALSE) 
[17:59:27.368]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:27.368]                     ...future.globalenv.names))
[17:59:27.368]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:27.368]         }, condition = base::local({
[17:59:27.368]             c <- base::c
[17:59:27.368]             inherits <- base::inherits
[17:59:27.368]             invokeRestart <- base::invokeRestart
[17:59:27.368]             length <- base::length
[17:59:27.368]             list <- base::list
[17:59:27.368]             seq.int <- base::seq.int
[17:59:27.368]             signalCondition <- base::signalCondition
[17:59:27.368]             sys.calls <- base::sys.calls
[17:59:27.368]             `[[` <- base::`[[`
[17:59:27.368]             `+` <- base::`+`
[17:59:27.368]             `<<-` <- base::`<<-`
[17:59:27.368]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:27.368]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:27.368]                   3L)]
[17:59:27.368]             }
[17:59:27.368]             function(cond) {
[17:59:27.368]                 is_error <- inherits(cond, "error")
[17:59:27.368]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:27.368]                   NULL)
[17:59:27.368]                 if (is_error) {
[17:59:27.368]                   sessionInformation <- function() {
[17:59:27.368]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:27.368]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:27.368]                       search = base::search(), system = base::Sys.info())
[17:59:27.368]                   }
[17:59:27.368]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.368]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:27.368]                     cond$call), session = sessionInformation(), 
[17:59:27.368]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:27.368]                   signalCondition(cond)
[17:59:27.368]                 }
[17:59:27.368]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:27.368]                 "immediateCondition"))) {
[17:59:27.368]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:27.368]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.368]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:27.368]                   if (TRUE && !signal) {
[17:59:27.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.368]                     {
[17:59:27.368]                       inherits <- base::inherits
[17:59:27.368]                       invokeRestart <- base::invokeRestart
[17:59:27.368]                       is.null <- base::is.null
[17:59:27.368]                       muffled <- FALSE
[17:59:27.368]                       if (inherits(cond, "message")) {
[17:59:27.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.368]                         if (muffled) 
[17:59:27.368]                           invokeRestart("muffleMessage")
[17:59:27.368]                       }
[17:59:27.368]                       else if (inherits(cond, "warning")) {
[17:59:27.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.368]                         if (muffled) 
[17:59:27.368]                           invokeRestart("muffleWarning")
[17:59:27.368]                       }
[17:59:27.368]                       else if (inherits(cond, "condition")) {
[17:59:27.368]                         if (!is.null(pattern)) {
[17:59:27.368]                           computeRestarts <- base::computeRestarts
[17:59:27.368]                           grepl <- base::grepl
[17:59:27.368]                           restarts <- computeRestarts(cond)
[17:59:27.368]                           for (restart in restarts) {
[17:59:27.368]                             name <- restart$name
[17:59:27.368]                             if (is.null(name)) 
[17:59:27.368]                               next
[17:59:27.368]                             if (!grepl(pattern, name)) 
[17:59:27.368]                               next
[17:59:27.368]                             invokeRestart(restart)
[17:59:27.368]                             muffled <- TRUE
[17:59:27.368]                             break
[17:59:27.368]                           }
[17:59:27.368]                         }
[17:59:27.368]                       }
[17:59:27.368]                       invisible(muffled)
[17:59:27.368]                     }
[17:59:27.368]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.368]                   }
[17:59:27.368]                 }
[17:59:27.368]                 else {
[17:59:27.368]                   if (TRUE) {
[17:59:27.368]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.368]                     {
[17:59:27.368]                       inherits <- base::inherits
[17:59:27.368]                       invokeRestart <- base::invokeRestart
[17:59:27.368]                       is.null <- base::is.null
[17:59:27.368]                       muffled <- FALSE
[17:59:27.368]                       if (inherits(cond, "message")) {
[17:59:27.368]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.368]                         if (muffled) 
[17:59:27.368]                           invokeRestart("muffleMessage")
[17:59:27.368]                       }
[17:59:27.368]                       else if (inherits(cond, "warning")) {
[17:59:27.368]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.368]                         if (muffled) 
[17:59:27.368]                           invokeRestart("muffleWarning")
[17:59:27.368]                       }
[17:59:27.368]                       else if (inherits(cond, "condition")) {
[17:59:27.368]                         if (!is.null(pattern)) {
[17:59:27.368]                           computeRestarts <- base::computeRestarts
[17:59:27.368]                           grepl <- base::grepl
[17:59:27.368]                           restarts <- computeRestarts(cond)
[17:59:27.368]                           for (restart in restarts) {
[17:59:27.368]                             name <- restart$name
[17:59:27.368]                             if (is.null(name)) 
[17:59:27.368]                               next
[17:59:27.368]                             if (!grepl(pattern, name)) 
[17:59:27.368]                               next
[17:59:27.368]                             invokeRestart(restart)
[17:59:27.368]                             muffled <- TRUE
[17:59:27.368]                             break
[17:59:27.368]                           }
[17:59:27.368]                         }
[17:59:27.368]                       }
[17:59:27.368]                       invisible(muffled)
[17:59:27.368]                     }
[17:59:27.368]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.368]                   }
[17:59:27.368]                 }
[17:59:27.368]             }
[17:59:27.368]         }))
[17:59:27.368]     }, error = function(ex) {
[17:59:27.368]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:27.368]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.368]                 ...future.rng), started = ...future.startTime, 
[17:59:27.368]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:27.368]             version = "1.8"), class = "FutureResult")
[17:59:27.368]     }, finally = {
[17:59:27.368]         if (!identical(...future.workdir, getwd())) 
[17:59:27.368]             setwd(...future.workdir)
[17:59:27.368]         {
[17:59:27.368]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:27.368]                 ...future.oldOptions$nwarnings <- NULL
[17:59:27.368]             }
[17:59:27.368]             base::options(...future.oldOptions)
[17:59:27.368]             if (.Platform$OS.type == "windows") {
[17:59:27.368]                 old_names <- names(...future.oldEnvVars)
[17:59:27.368]                 envs <- base::Sys.getenv()
[17:59:27.368]                 names <- names(envs)
[17:59:27.368]                 common <- intersect(names, old_names)
[17:59:27.368]                 added <- setdiff(names, old_names)
[17:59:27.368]                 removed <- setdiff(old_names, names)
[17:59:27.368]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:27.368]                   envs[common]]
[17:59:27.368]                 NAMES <- toupper(changed)
[17:59:27.368]                 args <- list()
[17:59:27.368]                 for (kk in seq_along(NAMES)) {
[17:59:27.368]                   name <- changed[[kk]]
[17:59:27.368]                   NAME <- NAMES[[kk]]
[17:59:27.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.368]                     next
[17:59:27.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.368]                 }
[17:59:27.368]                 NAMES <- toupper(added)
[17:59:27.368]                 for (kk in seq_along(NAMES)) {
[17:59:27.368]                   name <- added[[kk]]
[17:59:27.368]                   NAME <- NAMES[[kk]]
[17:59:27.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.368]                     next
[17:59:27.368]                   args[[name]] <- ""
[17:59:27.368]                 }
[17:59:27.368]                 NAMES <- toupper(removed)
[17:59:27.368]                 for (kk in seq_along(NAMES)) {
[17:59:27.368]                   name <- removed[[kk]]
[17:59:27.368]                   NAME <- NAMES[[kk]]
[17:59:27.368]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.368]                     next
[17:59:27.368]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.368]                 }
[17:59:27.368]                 if (length(args) > 0) 
[17:59:27.368]                   base::do.call(base::Sys.setenv, args = args)
[17:59:27.368]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:27.368]             }
[17:59:27.368]             else {
[17:59:27.368]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:27.368]             }
[17:59:27.368]             {
[17:59:27.368]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:27.368]                   0L) {
[17:59:27.368]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:27.368]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:27.368]                   base::options(opts)
[17:59:27.368]                 }
[17:59:27.368]                 {
[17:59:27.368]                   {
[17:59:27.368]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:27.368]                     NULL
[17:59:27.368]                   }
[17:59:27.368]                   options(future.plan = NULL)
[17:59:27.368]                   if (is.na(NA_character_)) 
[17:59:27.368]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.368]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:27.368]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:27.368]                     .init = FALSE)
[17:59:27.368]                 }
[17:59:27.368]             }
[17:59:27.368]         }
[17:59:27.368]     })
[17:59:27.368]     if (TRUE) {
[17:59:27.368]         base::sink(type = "output", split = FALSE)
[17:59:27.368]         if (TRUE) {
[17:59:27.368]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:27.368]         }
[17:59:27.368]         else {
[17:59:27.368]             ...future.result["stdout"] <- base::list(NULL)
[17:59:27.368]         }
[17:59:27.368]         base::close(...future.stdout)
[17:59:27.368]         ...future.stdout <- NULL
[17:59:27.368]     }
[17:59:27.368]     ...future.result$conditions <- ...future.conditions
[17:59:27.368]     ...future.result$finished <- base::Sys.time()
[17:59:27.368]     ...future.result
[17:59:27.368] }
[17:59:27.373] assign_globals() ...
[17:59:27.373] List of 5
[17:59:27.373]  $ ...future.FUN            :function (object, ...)  
[17:59:27.373]  $ future.call.arguments    : list()
[17:59:27.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.373]  $ ...future.elements_ii    :List of 1
[17:59:27.373]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.373]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:27.373]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.373]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:27.373]  $ ...future.seeds_ii       : NULL
[17:59:27.373]  $ ...future.globals.maxSize: NULL
[17:59:27.373]  - attr(*, "where")=List of 5
[17:59:27.373]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:27.373]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:27.373]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:27.373]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:27.373]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:27.373]  - attr(*, "resolved")= logi FALSE
[17:59:27.373]  - attr(*, "total_size")= num 1240
[17:59:27.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.373]  - attr(*, "already-done")= logi TRUE
[17:59:27.385] - copied ‘...future.FUN’ to environment
[17:59:27.385] - copied ‘future.call.arguments’ to environment
[17:59:27.385] - copied ‘...future.elements_ii’ to environment
[17:59:27.385] - copied ‘...future.seeds_ii’ to environment
[17:59:27.385] - copied ‘...future.globals.maxSize’ to environment
[17:59:27.386] assign_globals() ... done
[17:59:27.386] requestCore(): workers = 2
[17:59:27.389] MulticoreFuture started
[17:59:27.390] - Launch lazy future ... done
[17:59:27.390] run() for ‘MulticoreFuture’ ... done
[17:59:27.391] Created future:
[17:59:27.391] plan(): Setting new future strategy stack:
[17:59:27.392] List of future strategies:
[17:59:27.392] 1. sequential:
[17:59:27.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:27.392]    - tweaked: FALSE
[17:59:27.392]    - call: NULL
[17:59:27.394] plan(): nbrOfWorkers() = 1
[17:59:27.391] MulticoreFuture:
[17:59:27.391] Label: ‘future_by-1’
[17:59:27.391] Expression:
[17:59:27.391] {
[17:59:27.391]     do.call(function(...) {
[17:59:27.391]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.391]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.391]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.391]             on.exit(options(oopts), add = TRUE)
[17:59:27.391]         }
[17:59:27.391]         {
[17:59:27.391]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.391]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.391]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.391]             })
[17:59:27.391]         }
[17:59:27.391]     }, args = future.call.arguments)
[17:59:27.391] }
[17:59:27.391] Lazy evaluation: FALSE
[17:59:27.391] Asynchronous evaluation: TRUE
[17:59:27.391] Local evaluation: TRUE
[17:59:27.391] Environment: 0x62649eb0a7a8
[17:59:27.391] Capture standard output: TRUE
[17:59:27.391] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:27.391] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:27.391] Packages: <none>
[17:59:27.391] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:27.391] Resolved: FALSE
[17:59:27.391] Value: <not collected>
[17:59:27.391] Conditions captured: <none>
[17:59:27.391] Early signaling: FALSE
[17:59:27.391] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:27.391] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.408] Chunk #1 of 2 ... DONE
[17:59:27.407] plan(): Setting new future strategy stack:
[17:59:27.408] List of future strategies:
[17:59:27.408] 1. multicore:
[17:59:27.408]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.408]    - tweaked: FALSE
[17:59:27.408]    - call: plan(strategy)
[17:59:27.408] Chunk #2 of 2 ...
[17:59:27.412]  - Finding globals in 'X' for chunk #2 ...
[17:59:27.413] getGlobalsAndPackages() ...
[17:59:27.413] Searching for globals...
[17:59:27.416] 
[17:59:27.416] Searching for globals ... DONE
[17:59:27.417] - globals: [0] <none>
[17:59:27.417] getGlobalsAndPackages() ... DONE
[17:59:27.418]    + additional globals found: [n=0] 
[17:59:27.418]    + additional namespaces needed: [n=0] 
[17:59:27.419]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:27.419]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:27.420]  - seeds: <none>
[17:59:27.420] plan(): nbrOfWorkers() = 2
[17:59:27.420]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.421] getGlobalsAndPackages() ...
[17:59:27.421] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.422] Resolving globals: FALSE
[17:59:27.422] Tweak future expression to call with '...' arguments ...
[17:59:27.423] {
[17:59:27.423]     do.call(function(...) {
[17:59:27.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.423]             on.exit(options(oopts), add = TRUE)
[17:59:27.423]         }
[17:59:27.423]         {
[17:59:27.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.423]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.423]             })
[17:59:27.423]         }
[17:59:27.423]     }, args = future.call.arguments)
[17:59:27.423] }
[17:59:27.424] Tweak future expression to call with '...' arguments ... DONE
[17:59:27.426] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.426] 
[17:59:27.427] getGlobalsAndPackages() ... DONE
[17:59:27.428] run() for ‘Future’ ...
[17:59:27.428] - state: ‘created’
[17:59:27.429] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:27.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:27.438]   - Field: ‘label’
[17:59:27.439]   - Field: ‘local’
[17:59:27.439]   - Field: ‘owner’
[17:59:27.440]   - Field: ‘envir’
[17:59:27.440]   - Field: ‘workers’
[17:59:27.440]   - Field: ‘packages’
[17:59:27.441]   - Field: ‘gc’
[17:59:27.441]   - Field: ‘job’
[17:59:27.441]   - Field: ‘conditions’
[17:59:27.441]   - Field: ‘expr’
[17:59:27.442]   - Field: ‘uuid’
[17:59:27.442]   - Field: ‘seed’
[17:59:27.442]   - Field: ‘version’
[17:59:27.442]   - Field: ‘result’
[17:59:27.443]   - Field: ‘asynchronous’
[17:59:27.443]   - Field: ‘calls’
[17:59:27.443]   - Field: ‘globals’
[17:59:27.443]   - Field: ‘stdout’
[17:59:27.444]   - Field: ‘earlySignal’
[17:59:27.444]   - Field: ‘lazy’
[17:59:27.444]   - Field: ‘state’
[17:59:27.445] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:27.445] - Launch lazy future ...
[17:59:27.446] Packages needed by the future expression (n = 0): <none>
[17:59:27.446] Packages needed by future strategies (n = 0): <none>
[17:59:27.447] {
[17:59:27.447]     {
[17:59:27.447]         {
[17:59:27.447]             ...future.startTime <- base::Sys.time()
[17:59:27.447]             {
[17:59:27.447]                 {
[17:59:27.447]                   {
[17:59:27.447]                     {
[17:59:27.447]                       base::local({
[17:59:27.447]                         has_future <- base::requireNamespace("future", 
[17:59:27.447]                           quietly = TRUE)
[17:59:27.447]                         if (has_future) {
[17:59:27.447]                           ns <- base::getNamespace("future")
[17:59:27.447]                           version <- ns[[".package"]][["version"]]
[17:59:27.447]                           if (is.null(version)) 
[17:59:27.447]                             version <- utils::packageVersion("future")
[17:59:27.447]                         }
[17:59:27.447]                         else {
[17:59:27.447]                           version <- NULL
[17:59:27.447]                         }
[17:59:27.447]                         if (!has_future || version < "1.8.0") {
[17:59:27.447]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:27.447]                             "", base::R.version$version.string), 
[17:59:27.447]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:27.447]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:27.447]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:27.447]                               "release", "version")], collapse = " "), 
[17:59:27.447]                             hostname = base::Sys.info()[["nodename"]])
[17:59:27.447]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:27.447]                             info)
[17:59:27.447]                           info <- base::paste(info, collapse = "; ")
[17:59:27.447]                           if (!has_future) {
[17:59:27.447]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:27.447]                               info)
[17:59:27.447]                           }
[17:59:27.447]                           else {
[17:59:27.447]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:27.447]                               info, version)
[17:59:27.447]                           }
[17:59:27.447]                           base::stop(msg)
[17:59:27.447]                         }
[17:59:27.447]                       })
[17:59:27.447]                     }
[17:59:27.447]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:27.447]                     base::options(mc.cores = 1L)
[17:59:27.447]                   }
[17:59:27.447]                   ...future.strategy.old <- future::plan("list")
[17:59:27.447]                   options(future.plan = NULL)
[17:59:27.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:27.447]                 }
[17:59:27.447]                 ...future.workdir <- getwd()
[17:59:27.447]             }
[17:59:27.447]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:27.447]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:27.447]         }
[17:59:27.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:27.447]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:27.447]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:27.447]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:27.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:27.447]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:27.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:27.447]             base::names(...future.oldOptions))
[17:59:27.447]     }
[17:59:27.447]     if (FALSE) {
[17:59:27.447]     }
[17:59:27.447]     else {
[17:59:27.447]         if (TRUE) {
[17:59:27.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:27.447]                 open = "w")
[17:59:27.447]         }
[17:59:27.447]         else {
[17:59:27.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:27.447]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:27.447]         }
[17:59:27.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:27.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:27.447]             base::sink(type = "output", split = FALSE)
[17:59:27.447]             base::close(...future.stdout)
[17:59:27.447]         }, add = TRUE)
[17:59:27.447]     }
[17:59:27.447]     ...future.frame <- base::sys.nframe()
[17:59:27.447]     ...future.conditions <- base::list()
[17:59:27.447]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:27.447]     if (FALSE) {
[17:59:27.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:27.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:27.447]     }
[17:59:27.447]     ...future.result <- base::tryCatch({
[17:59:27.447]         base::withCallingHandlers({
[17:59:27.447]             ...future.value <- base::withVisible(base::local({
[17:59:27.447]                 withCallingHandlers({
[17:59:27.447]                   {
[17:59:27.447]                     do.call(function(...) {
[17:59:27.447]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.447]                       if (!identical(...future.globals.maxSize.org, 
[17:59:27.447]                         ...future.globals.maxSize)) {
[17:59:27.447]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.447]                         on.exit(options(oopts), add = TRUE)
[17:59:27.447]                       }
[17:59:27.447]                       {
[17:59:27.447]                         lapply(seq_along(...future.elements_ii), 
[17:59:27.447]                           FUN = function(jj) {
[17:59:27.447]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.447]                             ...future.FUN(...future.X_jj, ...)
[17:59:27.447]                           })
[17:59:27.447]                       }
[17:59:27.447]                     }, args = future.call.arguments)
[17:59:27.447]                   }
[17:59:27.447]                 }, immediateCondition = function(cond) {
[17:59:27.447]                   save_rds <- function (object, pathname, ...) 
[17:59:27.447]                   {
[17:59:27.447]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:27.447]                     if (file_test("-f", pathname_tmp)) {
[17:59:27.447]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.447]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:27.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.447]                         fi_tmp[["mtime"]])
[17:59:27.447]                     }
[17:59:27.447]                     tryCatch({
[17:59:27.447]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:27.447]                     }, error = function(ex) {
[17:59:27.447]                       msg <- conditionMessage(ex)
[17:59:27.447]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.447]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:27.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.447]                         fi_tmp[["mtime"]], msg)
[17:59:27.447]                       ex$message <- msg
[17:59:27.447]                       stop(ex)
[17:59:27.447]                     })
[17:59:27.447]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:27.447]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:27.447]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:27.447]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.447]                       fi <- file.info(pathname)
[17:59:27.447]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:27.447]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.447]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:27.447]                         fi[["size"]], fi[["mtime"]])
[17:59:27.447]                       stop(msg)
[17:59:27.447]                     }
[17:59:27.447]                     invisible(pathname)
[17:59:27.447]                   }
[17:59:27.447]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:27.447]                     rootPath = tempdir()) 
[17:59:27.447]                   {
[17:59:27.447]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:27.447]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:27.447]                       tmpdir = path, fileext = ".rds")
[17:59:27.447]                     save_rds(obj, file)
[17:59:27.447]                   }
[17:59:27.447]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:27.447]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.447]                   {
[17:59:27.447]                     inherits <- base::inherits
[17:59:27.447]                     invokeRestart <- base::invokeRestart
[17:59:27.447]                     is.null <- base::is.null
[17:59:27.447]                     muffled <- FALSE
[17:59:27.447]                     if (inherits(cond, "message")) {
[17:59:27.447]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:27.447]                       if (muffled) 
[17:59:27.447]                         invokeRestart("muffleMessage")
[17:59:27.447]                     }
[17:59:27.447]                     else if (inherits(cond, "warning")) {
[17:59:27.447]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:27.447]                       if (muffled) 
[17:59:27.447]                         invokeRestart("muffleWarning")
[17:59:27.447]                     }
[17:59:27.447]                     else if (inherits(cond, "condition")) {
[17:59:27.447]                       if (!is.null(pattern)) {
[17:59:27.447]                         computeRestarts <- base::computeRestarts
[17:59:27.447]                         grepl <- base::grepl
[17:59:27.447]                         restarts <- computeRestarts(cond)
[17:59:27.447]                         for (restart in restarts) {
[17:59:27.447]                           name <- restart$name
[17:59:27.447]                           if (is.null(name)) 
[17:59:27.447]                             next
[17:59:27.447]                           if (!grepl(pattern, name)) 
[17:59:27.447]                             next
[17:59:27.447]                           invokeRestart(restart)
[17:59:27.447]                           muffled <- TRUE
[17:59:27.447]                           break
[17:59:27.447]                         }
[17:59:27.447]                       }
[17:59:27.447]                     }
[17:59:27.447]                     invisible(muffled)
[17:59:27.447]                   }
[17:59:27.447]                   muffleCondition(cond)
[17:59:27.447]                 })
[17:59:27.447]             }))
[17:59:27.447]             future::FutureResult(value = ...future.value$value, 
[17:59:27.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.447]                   ...future.rng), globalenv = if (FALSE) 
[17:59:27.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:27.447]                     ...future.globalenv.names))
[17:59:27.447]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:27.447]         }, condition = base::local({
[17:59:27.447]             c <- base::c
[17:59:27.447]             inherits <- base::inherits
[17:59:27.447]             invokeRestart <- base::invokeRestart
[17:59:27.447]             length <- base::length
[17:59:27.447]             list <- base::list
[17:59:27.447]             seq.int <- base::seq.int
[17:59:27.447]             signalCondition <- base::signalCondition
[17:59:27.447]             sys.calls <- base::sys.calls
[17:59:27.447]             `[[` <- base::`[[`
[17:59:27.447]             `+` <- base::`+`
[17:59:27.447]             `<<-` <- base::`<<-`
[17:59:27.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:27.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:27.447]                   3L)]
[17:59:27.447]             }
[17:59:27.447]             function(cond) {
[17:59:27.447]                 is_error <- inherits(cond, "error")
[17:59:27.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:27.447]                   NULL)
[17:59:27.447]                 if (is_error) {
[17:59:27.447]                   sessionInformation <- function() {
[17:59:27.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:27.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:27.447]                       search = base::search(), system = base::Sys.info())
[17:59:27.447]                   }
[17:59:27.447]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:27.447]                     cond$call), session = sessionInformation(), 
[17:59:27.447]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:27.447]                   signalCondition(cond)
[17:59:27.447]                 }
[17:59:27.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:27.447]                 "immediateCondition"))) {
[17:59:27.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:27.447]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:27.447]                   if (TRUE && !signal) {
[17:59:27.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.447]                     {
[17:59:27.447]                       inherits <- base::inherits
[17:59:27.447]                       invokeRestart <- base::invokeRestart
[17:59:27.447]                       is.null <- base::is.null
[17:59:27.447]                       muffled <- FALSE
[17:59:27.447]                       if (inherits(cond, "message")) {
[17:59:27.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.447]                         if (muffled) 
[17:59:27.447]                           invokeRestart("muffleMessage")
[17:59:27.447]                       }
[17:59:27.447]                       else if (inherits(cond, "warning")) {
[17:59:27.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.447]                         if (muffled) 
[17:59:27.447]                           invokeRestart("muffleWarning")
[17:59:27.447]                       }
[17:59:27.447]                       else if (inherits(cond, "condition")) {
[17:59:27.447]                         if (!is.null(pattern)) {
[17:59:27.447]                           computeRestarts <- base::computeRestarts
[17:59:27.447]                           grepl <- base::grepl
[17:59:27.447]                           restarts <- computeRestarts(cond)
[17:59:27.447]                           for (restart in restarts) {
[17:59:27.447]                             name <- restart$name
[17:59:27.447]                             if (is.null(name)) 
[17:59:27.447]                               next
[17:59:27.447]                             if (!grepl(pattern, name)) 
[17:59:27.447]                               next
[17:59:27.447]                             invokeRestart(restart)
[17:59:27.447]                             muffled <- TRUE
[17:59:27.447]                             break
[17:59:27.447]                           }
[17:59:27.447]                         }
[17:59:27.447]                       }
[17:59:27.447]                       invisible(muffled)
[17:59:27.447]                     }
[17:59:27.447]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.447]                   }
[17:59:27.447]                 }
[17:59:27.447]                 else {
[17:59:27.447]                   if (TRUE) {
[17:59:27.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.447]                     {
[17:59:27.447]                       inherits <- base::inherits
[17:59:27.447]                       invokeRestart <- base::invokeRestart
[17:59:27.447]                       is.null <- base::is.null
[17:59:27.447]                       muffled <- FALSE
[17:59:27.447]                       if (inherits(cond, "message")) {
[17:59:27.447]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.447]                         if (muffled) 
[17:59:27.447]                           invokeRestart("muffleMessage")
[17:59:27.447]                       }
[17:59:27.447]                       else if (inherits(cond, "warning")) {
[17:59:27.447]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.447]                         if (muffled) 
[17:59:27.447]                           invokeRestart("muffleWarning")
[17:59:27.447]                       }
[17:59:27.447]                       else if (inherits(cond, "condition")) {
[17:59:27.447]                         if (!is.null(pattern)) {
[17:59:27.447]                           computeRestarts <- base::computeRestarts
[17:59:27.447]                           grepl <- base::grepl
[17:59:27.447]                           restarts <- computeRestarts(cond)
[17:59:27.447]                           for (restart in restarts) {
[17:59:27.447]                             name <- restart$name
[17:59:27.447]                             if (is.null(name)) 
[17:59:27.447]                               next
[17:59:27.447]                             if (!grepl(pattern, name)) 
[17:59:27.447]                               next
[17:59:27.447]                             invokeRestart(restart)
[17:59:27.447]                             muffled <- TRUE
[17:59:27.447]                             break
[17:59:27.447]                           }
[17:59:27.447]                         }
[17:59:27.447]                       }
[17:59:27.447]                       invisible(muffled)
[17:59:27.447]                     }
[17:59:27.447]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.447]                   }
[17:59:27.447]                 }
[17:59:27.447]             }
[17:59:27.447]         }))
[17:59:27.447]     }, error = function(ex) {
[17:59:27.447]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:27.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.447]                 ...future.rng), started = ...future.startTime, 
[17:59:27.447]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:27.447]             version = "1.8"), class = "FutureResult")
[17:59:27.447]     }, finally = {
[17:59:27.447]         if (!identical(...future.workdir, getwd())) 
[17:59:27.447]             setwd(...future.workdir)
[17:59:27.447]         {
[17:59:27.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:27.447]                 ...future.oldOptions$nwarnings <- NULL
[17:59:27.447]             }
[17:59:27.447]             base::options(...future.oldOptions)
[17:59:27.447]             if (.Platform$OS.type == "windows") {
[17:59:27.447]                 old_names <- names(...future.oldEnvVars)
[17:59:27.447]                 envs <- base::Sys.getenv()
[17:59:27.447]                 names <- names(envs)
[17:59:27.447]                 common <- intersect(names, old_names)
[17:59:27.447]                 added <- setdiff(names, old_names)
[17:59:27.447]                 removed <- setdiff(old_names, names)
[17:59:27.447]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:27.447]                   envs[common]]
[17:59:27.447]                 NAMES <- toupper(changed)
[17:59:27.447]                 args <- list()
[17:59:27.447]                 for (kk in seq_along(NAMES)) {
[17:59:27.447]                   name <- changed[[kk]]
[17:59:27.447]                   NAME <- NAMES[[kk]]
[17:59:27.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.447]                     next
[17:59:27.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.447]                 }
[17:59:27.447]                 NAMES <- toupper(added)
[17:59:27.447]                 for (kk in seq_along(NAMES)) {
[17:59:27.447]                   name <- added[[kk]]
[17:59:27.447]                   NAME <- NAMES[[kk]]
[17:59:27.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.447]                     next
[17:59:27.447]                   args[[name]] <- ""
[17:59:27.447]                 }
[17:59:27.447]                 NAMES <- toupper(removed)
[17:59:27.447]                 for (kk in seq_along(NAMES)) {
[17:59:27.447]                   name <- removed[[kk]]
[17:59:27.447]                   NAME <- NAMES[[kk]]
[17:59:27.447]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.447]                     next
[17:59:27.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.447]                 }
[17:59:27.447]                 if (length(args) > 0) 
[17:59:27.447]                   base::do.call(base::Sys.setenv, args = args)
[17:59:27.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:27.447]             }
[17:59:27.447]             else {
[17:59:27.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:27.447]             }
[17:59:27.447]             {
[17:59:27.447]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:27.447]                   0L) {
[17:59:27.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:27.447]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:27.447]                   base::options(opts)
[17:59:27.447]                 }
[17:59:27.447]                 {
[17:59:27.447]                   {
[17:59:27.447]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:27.447]                     NULL
[17:59:27.447]                   }
[17:59:27.447]                   options(future.plan = NULL)
[17:59:27.447]                   if (is.na(NA_character_)) 
[17:59:27.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:27.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:27.447]                     .init = FALSE)
[17:59:27.447]                 }
[17:59:27.447]             }
[17:59:27.447]         }
[17:59:27.447]     })
[17:59:27.447]     if (TRUE) {
[17:59:27.447]         base::sink(type = "output", split = FALSE)
[17:59:27.447]         if (TRUE) {
[17:59:27.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:27.447]         }
[17:59:27.447]         else {
[17:59:27.447]             ...future.result["stdout"] <- base::list(NULL)
[17:59:27.447]         }
[17:59:27.447]         base::close(...future.stdout)
[17:59:27.447]         ...future.stdout <- NULL
[17:59:27.447]     }
[17:59:27.447]     ...future.result$conditions <- ...future.conditions
[17:59:27.447]     ...future.result$finished <- base::Sys.time()
[17:59:27.447]     ...future.result
[17:59:27.447] }
[17:59:27.452] assign_globals() ...
[17:59:27.453] List of 5
[17:59:27.453]  $ ...future.FUN            :function (object, ...)  
[17:59:27.453]  $ future.call.arguments    : list()
[17:59:27.453]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.453]  $ ...future.elements_ii    :List of 2
[17:59:27.453]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.453]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:27.453]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.453]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:27.453]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.453]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:27.453]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.453]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:27.453]  $ ...future.seeds_ii       : NULL
[17:59:27.453]  $ ...future.globals.maxSize: NULL
[17:59:27.453]  - attr(*, "where")=List of 5
[17:59:27.453]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:27.453]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:27.453]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:27.453]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:27.453]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:27.453]  - attr(*, "resolved")= logi FALSE
[17:59:27.453]  - attr(*, "total_size")= num 1240
[17:59:27.453]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.453]  - attr(*, "already-done")= logi TRUE
[17:59:27.470] - copied ‘...future.FUN’ to environment
[17:59:27.470] - copied ‘future.call.arguments’ to environment
[17:59:27.471] - copied ‘...future.elements_ii’ to environment
[17:59:27.471] - copied ‘...future.seeds_ii’ to environment
[17:59:27.471] - copied ‘...future.globals.maxSize’ to environment
[17:59:27.471] assign_globals() ... done
[17:59:27.472] requestCore(): workers = 2
[17:59:27.475] MulticoreFuture started
[17:59:27.476] - Launch lazy future ... done
[17:59:27.477] run() for ‘MulticoreFuture’ ... done
[17:59:27.477] Created future:
[17:59:27.480] plan(): Setting new future strategy stack:
[17:59:27.481] List of future strategies:
[17:59:27.481] 1. sequential:
[17:59:27.481]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:27.481]    - tweaked: FALSE
[17:59:27.481]    - call: NULL
[17:59:27.485] plan(): nbrOfWorkers() = 1
[17:59:27.478] MulticoreFuture:
[17:59:27.478] Label: ‘future_by-2’
[17:59:27.478] Expression:
[17:59:27.478] {
[17:59:27.478]     do.call(function(...) {
[17:59:27.478]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.478]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.478]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.478]             on.exit(options(oopts), add = TRUE)
[17:59:27.478]         }
[17:59:27.478]         {
[17:59:27.478]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.478]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.478]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.478]             })
[17:59:27.478]         }
[17:59:27.478]     }, args = future.call.arguments)
[17:59:27.478] }
[17:59:27.478] Lazy evaluation: FALSE
[17:59:27.478] Asynchronous evaluation: TRUE
[17:59:27.478] Local evaluation: TRUE
[17:59:27.478] Environment: 0x62649eb0a7a8
[17:59:27.478] Capture standard output: TRUE
[17:59:27.478] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:27.478] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:27.478] Packages: <none>
[17:59:27.478] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:27.478] Resolved: FALSE
[17:59:27.478] Value: <not collected>
[17:59:27.478] Conditions captured: <none>
[17:59:27.478] Early signaling: FALSE
[17:59:27.478] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:27.478] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.502] Chunk #2 of 2 ... DONE
[17:59:27.502] Launching 2 futures (chunks) ... DONE
[17:59:27.503] Resolving 2 futures (chunks) ...
[17:59:27.503] resolve() on list ...
[17:59:27.504]  recursive: 0
[17:59:27.504]  length: 2
[17:59:27.505] 
[17:59:27.506] plan(): Setting new future strategy stack:
[17:59:27.506] Future #1
[17:59:27.506] result() for MulticoreFuture ...
[17:59:27.506] List of future strategies:
[17:59:27.506] 1. multicore:
[17:59:27.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.506]    - tweaked: FALSE
[17:59:27.506]    - call: plan(strategy)
[17:59:27.508] result() for MulticoreFuture ...
[17:59:27.509] result() for MulticoreFuture ... done
[17:59:27.509] result() for MulticoreFuture ... done
[17:59:27.512] result() for MulticoreFuture ...
[17:59:27.513] result() for MulticoreFuture ... done
[17:59:27.515] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:27.516] - nx: 2
[17:59:27.516] - relay: TRUE
[17:59:27.517] - stdout: TRUE
[17:59:27.517] - signal: TRUE
[17:59:27.517] - resignal: FALSE
[17:59:27.518] - force: TRUE
[17:59:27.518] - relayed: [n=2] FALSE, FALSE
[17:59:27.519] - queued futures: [n=2] FALSE, FALSE
[17:59:27.519]  - until=1
[17:59:27.520]  - relaying element #1
[17:59:27.520] result() for MulticoreFuture ...
[17:59:27.521] result() for MulticoreFuture ... done
[17:59:27.521] result() for MulticoreFuture ...
[17:59:27.522] result() for MulticoreFuture ... done
[17:59:27.522] plan(): nbrOfWorkers() = 2
[17:59:27.523] result() for MulticoreFuture ...
[17:59:27.523] result() for MulticoreFuture ... done
[17:59:27.523] result() for MulticoreFuture ...
[17:59:27.524] result() for MulticoreFuture ... done
[17:59:27.524] - relayed: [n=2] TRUE, FALSE
[17:59:27.524] - queued futures: [n=2] TRUE, FALSE
[17:59:27.525] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:27.525]  length: 1 (resolved future 1)
[17:59:27.526] Future #2
[17:59:27.526] result() for MulticoreFuture ...
[17:59:27.528] result() for MulticoreFuture ...
[17:59:27.528] result() for MulticoreFuture ... done
[17:59:27.529] result() for MulticoreFuture ... done
[17:59:27.529] result() for MulticoreFuture ...
[17:59:27.529] result() for MulticoreFuture ... done
[17:59:27.529] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:27.530] - nx: 2
[17:59:27.530] - relay: TRUE
[17:59:27.530] - stdout: TRUE
[17:59:27.530] - signal: TRUE
[17:59:27.530] - resignal: FALSE
[17:59:27.531] - force: TRUE
[17:59:27.531] - relayed: [n=2] TRUE, FALSE
[17:59:27.531] - queued futures: [n=2] TRUE, FALSE
[17:59:27.531]  - until=2
[17:59:27.532]  - relaying element #2
[17:59:27.532] result() for MulticoreFuture ...
[17:59:27.532] result() for MulticoreFuture ... done
[17:59:27.532] result() for MulticoreFuture ...
[17:59:27.533] result() for MulticoreFuture ... done
[17:59:27.533] result() for MulticoreFuture ...
[17:59:27.533] result() for MulticoreFuture ... done
[17:59:27.533] result() for MulticoreFuture ...
[17:59:27.534] result() for MulticoreFuture ... done
[17:59:27.534] - relayed: [n=2] TRUE, TRUE
[17:59:27.534] - queued futures: [n=2] TRUE, TRUE
[17:59:27.534] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:27.535]  length: 0 (resolved future 2)
[17:59:27.535] Relaying remaining futures
[17:59:27.535] signalConditionsASAP(NULL, pos=0) ...
[17:59:27.535] - nx: 2
[17:59:27.535] - relay: TRUE
[17:59:27.536] - stdout: TRUE
[17:59:27.536] - signal: TRUE
[17:59:27.536] - resignal: FALSE
[17:59:27.536] - force: TRUE
[17:59:27.536] - relayed: [n=2] TRUE, TRUE
[17:59:27.537] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:27.537] - relayed: [n=2] TRUE, TRUE
[17:59:27.537] - queued futures: [n=2] TRUE, TRUE
[17:59:27.538] signalConditionsASAP(NULL, pos=0) ... done
[17:59:27.538] resolve() on list ... DONE
[17:59:27.538] result() for MulticoreFuture ...
[17:59:27.539] result() for MulticoreFuture ... done
[17:59:27.539] result() for MulticoreFuture ...
[17:59:27.539] result() for MulticoreFuture ... done
[17:59:27.539] result() for MulticoreFuture ...
[17:59:27.539] result() for MulticoreFuture ... done
[17:59:27.540] result() for MulticoreFuture ...
[17:59:27.540] result() for MulticoreFuture ... done
[17:59:27.540]  - Number of value chunks collected: 2
[17:59:27.540] Resolving 2 futures (chunks) ... DONE
[17:59:27.541] Reducing values from 2 chunks ...
[17:59:27.541]  - Number of values collected after concatenation: 3
[17:59:27.541]  - Number of values expected: 3
[17:59:27.541] Reducing values from 2 chunks ... DONE
[17:59:27.542] future_lapply() ... DONE
[17:59:27.542] future_by_internal() ... DONE
[17:59:27.544] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:59:27.545] future_lapply() ...
[17:59:27.553] Number of chunks: 2
[17:59:27.553] getGlobalsAndPackagesXApply() ...
[17:59:27.553]  - future.globals: TRUE
[17:59:27.553] getGlobalsAndPackages() ...
[17:59:27.553] Searching for globals...
[17:59:27.556] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:27.556] Searching for globals ... DONE
[17:59:27.556] Resolving globals: FALSE
[17:59:27.557] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:27.558] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:27.558] - globals: [1] ‘FUN’
[17:59:27.558] 
[17:59:27.558] getGlobalsAndPackages() ... DONE
[17:59:27.559]  - globals found/used: [n=1] ‘FUN’
[17:59:27.559]  - needed namespaces: [n=0] 
[17:59:27.559] Finding globals ... DONE
[17:59:27.559]  - use_args: TRUE
[17:59:27.559]  - Getting '...' globals ...
[17:59:27.560] resolve() on list ...
[17:59:27.560]  recursive: 0
[17:59:27.560]  length: 1
[17:59:27.561]  elements: ‘...’
[17:59:27.561]  length: 0 (resolved future 1)
[17:59:27.561] resolve() on list ... DONE
[17:59:27.564]    - '...' content: [n=0] 
[17:59:27.564] List of 1
[17:59:27.564]  $ ...: list()
[17:59:27.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.564]  - attr(*, "where")=List of 1
[17:59:27.564]   ..$ ...:<environment: 0x62649f807e40> 
[17:59:27.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.564]  - attr(*, "resolved")= logi TRUE
[17:59:27.564]  - attr(*, "total_size")= num NA
[17:59:27.570]  - Getting '...' globals ... DONE
[17:59:27.570] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:27.571] List of 2
[17:59:27.571]  $ ...future.FUN:function (object, ...)  
[17:59:27.571]  $ ...          : list()
[17:59:27.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.571]  - attr(*, "where")=List of 2
[17:59:27.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:27.571]   ..$ ...          :<environment: 0x62649f807e40> 
[17:59:27.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.571]  - attr(*, "resolved")= logi FALSE
[17:59:27.571]  - attr(*, "total_size")= num 1240
[17:59:27.576] Packages to be attached in all futures: [n=0] 
[17:59:27.577] getGlobalsAndPackagesXApply() ... DONE
[17:59:27.577] Number of futures (= number of chunks): 2
[17:59:27.577] Launching 2 futures (chunks) ...
[17:59:27.577] Chunk #1 of 2 ...
[17:59:27.578]  - Finding globals in 'X' for chunk #1 ...
[17:59:27.578] getGlobalsAndPackages() ...
[17:59:27.578] Searching for globals...
[17:59:27.579] 
[17:59:27.579] Searching for globals ... DONE
[17:59:27.579] - globals: [0] <none>
[17:59:27.579] getGlobalsAndPackages() ... DONE
[17:59:27.580]    + additional globals found: [n=0] 
[17:59:27.580]    + additional namespaces needed: [n=0] 
[17:59:27.580]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:27.580]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:27.580]  - seeds: <none>
[17:59:27.580]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.581] getGlobalsAndPackages() ...
[17:59:27.581] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.581] Resolving globals: FALSE
[17:59:27.581] Tweak future expression to call with '...' arguments ...
[17:59:27.582] {
[17:59:27.582]     do.call(function(...) {
[17:59:27.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.582]             on.exit(options(oopts), add = TRUE)
[17:59:27.582]         }
[17:59:27.582]         {
[17:59:27.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.582]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.582]             })
[17:59:27.582]         }
[17:59:27.582]     }, args = future.call.arguments)
[17:59:27.582] }
[17:59:27.582] Tweak future expression to call with '...' arguments ... DONE
[17:59:27.583] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.583] 
[17:59:27.583] getGlobalsAndPackages() ... DONE
[17:59:27.584] run() for ‘Future’ ...
[17:59:27.584] - state: ‘created’
[17:59:27.584] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:27.591] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:27.592]   - Field: ‘label’
[17:59:27.592]   - Field: ‘local’
[17:59:27.592]   - Field: ‘owner’
[17:59:27.592]   - Field: ‘envir’
[17:59:27.592]   - Field: ‘workers’
[17:59:27.593]   - Field: ‘packages’
[17:59:27.593]   - Field: ‘gc’
[17:59:27.593]   - Field: ‘job’
[17:59:27.593]   - Field: ‘conditions’
[17:59:27.593]   - Field: ‘expr’
[17:59:27.594]   - Field: ‘uuid’
[17:59:27.594]   - Field: ‘seed’
[17:59:27.594]   - Field: ‘version’
[17:59:27.594]   - Field: ‘result’
[17:59:27.594]   - Field: ‘asynchronous’
[17:59:27.595]   - Field: ‘calls’
[17:59:27.595]   - Field: ‘globals’
[17:59:27.595]   - Field: ‘stdout’
[17:59:27.595]   - Field: ‘earlySignal’
[17:59:27.595]   - Field: ‘lazy’
[17:59:27.596]   - Field: ‘state’
[17:59:27.596] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:27.596] - Launch lazy future ...
[17:59:27.597] Packages needed by the future expression (n = 0): <none>
[17:59:27.597] Packages needed by future strategies (n = 0): <none>
[17:59:27.598] {
[17:59:27.598]     {
[17:59:27.598]         {
[17:59:27.598]             ...future.startTime <- base::Sys.time()
[17:59:27.598]             {
[17:59:27.598]                 {
[17:59:27.598]                   {
[17:59:27.598]                     {
[17:59:27.598]                       base::local({
[17:59:27.598]                         has_future <- base::requireNamespace("future", 
[17:59:27.598]                           quietly = TRUE)
[17:59:27.598]                         if (has_future) {
[17:59:27.598]                           ns <- base::getNamespace("future")
[17:59:27.598]                           version <- ns[[".package"]][["version"]]
[17:59:27.598]                           if (is.null(version)) 
[17:59:27.598]                             version <- utils::packageVersion("future")
[17:59:27.598]                         }
[17:59:27.598]                         else {
[17:59:27.598]                           version <- NULL
[17:59:27.598]                         }
[17:59:27.598]                         if (!has_future || version < "1.8.0") {
[17:59:27.598]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:27.598]                             "", base::R.version$version.string), 
[17:59:27.598]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:27.598]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:27.598]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:27.598]                               "release", "version")], collapse = " "), 
[17:59:27.598]                             hostname = base::Sys.info()[["nodename"]])
[17:59:27.598]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:27.598]                             info)
[17:59:27.598]                           info <- base::paste(info, collapse = "; ")
[17:59:27.598]                           if (!has_future) {
[17:59:27.598]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:27.598]                               info)
[17:59:27.598]                           }
[17:59:27.598]                           else {
[17:59:27.598]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:27.598]                               info, version)
[17:59:27.598]                           }
[17:59:27.598]                           base::stop(msg)
[17:59:27.598]                         }
[17:59:27.598]                       })
[17:59:27.598]                     }
[17:59:27.598]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:27.598]                     base::options(mc.cores = 1L)
[17:59:27.598]                   }
[17:59:27.598]                   ...future.strategy.old <- future::plan("list")
[17:59:27.598]                   options(future.plan = NULL)
[17:59:27.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:27.598]                 }
[17:59:27.598]                 ...future.workdir <- getwd()
[17:59:27.598]             }
[17:59:27.598]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:27.598]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:27.598]         }
[17:59:27.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:27.598]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:27.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:27.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:27.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:27.598]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:27.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:27.598]             base::names(...future.oldOptions))
[17:59:27.598]     }
[17:59:27.598]     if (FALSE) {
[17:59:27.598]     }
[17:59:27.598]     else {
[17:59:27.598]         if (TRUE) {
[17:59:27.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:27.598]                 open = "w")
[17:59:27.598]         }
[17:59:27.598]         else {
[17:59:27.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:27.598]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:27.598]         }
[17:59:27.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:27.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:27.598]             base::sink(type = "output", split = FALSE)
[17:59:27.598]             base::close(...future.stdout)
[17:59:27.598]         }, add = TRUE)
[17:59:27.598]     }
[17:59:27.598]     ...future.frame <- base::sys.nframe()
[17:59:27.598]     ...future.conditions <- base::list()
[17:59:27.598]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:27.598]     if (FALSE) {
[17:59:27.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:27.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:27.598]     }
[17:59:27.598]     ...future.result <- base::tryCatch({
[17:59:27.598]         base::withCallingHandlers({
[17:59:27.598]             ...future.value <- base::withVisible(base::local({
[17:59:27.598]                 withCallingHandlers({
[17:59:27.598]                   {
[17:59:27.598]                     do.call(function(...) {
[17:59:27.598]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.598]                       if (!identical(...future.globals.maxSize.org, 
[17:59:27.598]                         ...future.globals.maxSize)) {
[17:59:27.598]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.598]                         on.exit(options(oopts), add = TRUE)
[17:59:27.598]                       }
[17:59:27.598]                       {
[17:59:27.598]                         lapply(seq_along(...future.elements_ii), 
[17:59:27.598]                           FUN = function(jj) {
[17:59:27.598]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.598]                             ...future.FUN(...future.X_jj, ...)
[17:59:27.598]                           })
[17:59:27.598]                       }
[17:59:27.598]                     }, args = future.call.arguments)
[17:59:27.598]                   }
[17:59:27.598]                 }, immediateCondition = function(cond) {
[17:59:27.598]                   save_rds <- function (object, pathname, ...) 
[17:59:27.598]                   {
[17:59:27.598]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:27.598]                     if (file_test("-f", pathname_tmp)) {
[17:59:27.598]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.598]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:27.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.598]                         fi_tmp[["mtime"]])
[17:59:27.598]                     }
[17:59:27.598]                     tryCatch({
[17:59:27.598]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:27.598]                     }, error = function(ex) {
[17:59:27.598]                       msg <- conditionMessage(ex)
[17:59:27.598]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.598]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:27.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.598]                         fi_tmp[["mtime"]], msg)
[17:59:27.598]                       ex$message <- msg
[17:59:27.598]                       stop(ex)
[17:59:27.598]                     })
[17:59:27.598]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:27.598]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:27.598]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:27.598]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.598]                       fi <- file.info(pathname)
[17:59:27.598]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:27.598]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.598]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:27.598]                         fi[["size"]], fi[["mtime"]])
[17:59:27.598]                       stop(msg)
[17:59:27.598]                     }
[17:59:27.598]                     invisible(pathname)
[17:59:27.598]                   }
[17:59:27.598]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:27.598]                     rootPath = tempdir()) 
[17:59:27.598]                   {
[17:59:27.598]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:27.598]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:27.598]                       tmpdir = path, fileext = ".rds")
[17:59:27.598]                     save_rds(obj, file)
[17:59:27.598]                   }
[17:59:27.598]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:27.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.598]                   {
[17:59:27.598]                     inherits <- base::inherits
[17:59:27.598]                     invokeRestart <- base::invokeRestart
[17:59:27.598]                     is.null <- base::is.null
[17:59:27.598]                     muffled <- FALSE
[17:59:27.598]                     if (inherits(cond, "message")) {
[17:59:27.598]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:27.598]                       if (muffled) 
[17:59:27.598]                         invokeRestart("muffleMessage")
[17:59:27.598]                     }
[17:59:27.598]                     else if (inherits(cond, "warning")) {
[17:59:27.598]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:27.598]                       if (muffled) 
[17:59:27.598]                         invokeRestart("muffleWarning")
[17:59:27.598]                     }
[17:59:27.598]                     else if (inherits(cond, "condition")) {
[17:59:27.598]                       if (!is.null(pattern)) {
[17:59:27.598]                         computeRestarts <- base::computeRestarts
[17:59:27.598]                         grepl <- base::grepl
[17:59:27.598]                         restarts <- computeRestarts(cond)
[17:59:27.598]                         for (restart in restarts) {
[17:59:27.598]                           name <- restart$name
[17:59:27.598]                           if (is.null(name)) 
[17:59:27.598]                             next
[17:59:27.598]                           if (!grepl(pattern, name)) 
[17:59:27.598]                             next
[17:59:27.598]                           invokeRestart(restart)
[17:59:27.598]                           muffled <- TRUE
[17:59:27.598]                           break
[17:59:27.598]                         }
[17:59:27.598]                       }
[17:59:27.598]                     }
[17:59:27.598]                     invisible(muffled)
[17:59:27.598]                   }
[17:59:27.598]                   muffleCondition(cond)
[17:59:27.598]                 })
[17:59:27.598]             }))
[17:59:27.598]             future::FutureResult(value = ...future.value$value, 
[17:59:27.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.598]                   ...future.rng), globalenv = if (FALSE) 
[17:59:27.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:27.598]                     ...future.globalenv.names))
[17:59:27.598]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:27.598]         }, condition = base::local({
[17:59:27.598]             c <- base::c
[17:59:27.598]             inherits <- base::inherits
[17:59:27.598]             invokeRestart <- base::invokeRestart
[17:59:27.598]             length <- base::length
[17:59:27.598]             list <- base::list
[17:59:27.598]             seq.int <- base::seq.int
[17:59:27.598]             signalCondition <- base::signalCondition
[17:59:27.598]             sys.calls <- base::sys.calls
[17:59:27.598]             `[[` <- base::`[[`
[17:59:27.598]             `+` <- base::`+`
[17:59:27.598]             `<<-` <- base::`<<-`
[17:59:27.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:27.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:27.598]                   3L)]
[17:59:27.598]             }
[17:59:27.598]             function(cond) {
[17:59:27.598]                 is_error <- inherits(cond, "error")
[17:59:27.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:27.598]                   NULL)
[17:59:27.598]                 if (is_error) {
[17:59:27.598]                   sessionInformation <- function() {
[17:59:27.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:27.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:27.598]                       search = base::search(), system = base::Sys.info())
[17:59:27.598]                   }
[17:59:27.598]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:27.598]                     cond$call), session = sessionInformation(), 
[17:59:27.598]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:27.598]                   signalCondition(cond)
[17:59:27.598]                 }
[17:59:27.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:27.598]                 "immediateCondition"))) {
[17:59:27.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:27.598]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:27.598]                   if (TRUE && !signal) {
[17:59:27.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.598]                     {
[17:59:27.598]                       inherits <- base::inherits
[17:59:27.598]                       invokeRestart <- base::invokeRestart
[17:59:27.598]                       is.null <- base::is.null
[17:59:27.598]                       muffled <- FALSE
[17:59:27.598]                       if (inherits(cond, "message")) {
[17:59:27.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.598]                         if (muffled) 
[17:59:27.598]                           invokeRestart("muffleMessage")
[17:59:27.598]                       }
[17:59:27.598]                       else if (inherits(cond, "warning")) {
[17:59:27.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.598]                         if (muffled) 
[17:59:27.598]                           invokeRestart("muffleWarning")
[17:59:27.598]                       }
[17:59:27.598]                       else if (inherits(cond, "condition")) {
[17:59:27.598]                         if (!is.null(pattern)) {
[17:59:27.598]                           computeRestarts <- base::computeRestarts
[17:59:27.598]                           grepl <- base::grepl
[17:59:27.598]                           restarts <- computeRestarts(cond)
[17:59:27.598]                           for (restart in restarts) {
[17:59:27.598]                             name <- restart$name
[17:59:27.598]                             if (is.null(name)) 
[17:59:27.598]                               next
[17:59:27.598]                             if (!grepl(pattern, name)) 
[17:59:27.598]                               next
[17:59:27.598]                             invokeRestart(restart)
[17:59:27.598]                             muffled <- TRUE
[17:59:27.598]                             break
[17:59:27.598]                           }
[17:59:27.598]                         }
[17:59:27.598]                       }
[17:59:27.598]                       invisible(muffled)
[17:59:27.598]                     }
[17:59:27.598]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.598]                   }
[17:59:27.598]                 }
[17:59:27.598]                 else {
[17:59:27.598]                   if (TRUE) {
[17:59:27.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.598]                     {
[17:59:27.598]                       inherits <- base::inherits
[17:59:27.598]                       invokeRestart <- base::invokeRestart
[17:59:27.598]                       is.null <- base::is.null
[17:59:27.598]                       muffled <- FALSE
[17:59:27.598]                       if (inherits(cond, "message")) {
[17:59:27.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.598]                         if (muffled) 
[17:59:27.598]                           invokeRestart("muffleMessage")
[17:59:27.598]                       }
[17:59:27.598]                       else if (inherits(cond, "warning")) {
[17:59:27.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.598]                         if (muffled) 
[17:59:27.598]                           invokeRestart("muffleWarning")
[17:59:27.598]                       }
[17:59:27.598]                       else if (inherits(cond, "condition")) {
[17:59:27.598]                         if (!is.null(pattern)) {
[17:59:27.598]                           computeRestarts <- base::computeRestarts
[17:59:27.598]                           grepl <- base::grepl
[17:59:27.598]                           restarts <- computeRestarts(cond)
[17:59:27.598]                           for (restart in restarts) {
[17:59:27.598]                             name <- restart$name
[17:59:27.598]                             if (is.null(name)) 
[17:59:27.598]                               next
[17:59:27.598]                             if (!grepl(pattern, name)) 
[17:59:27.598]                               next
[17:59:27.598]                             invokeRestart(restart)
[17:59:27.598]                             muffled <- TRUE
[17:59:27.598]                             break
[17:59:27.598]                           }
[17:59:27.598]                         }
[17:59:27.598]                       }
[17:59:27.598]                       invisible(muffled)
[17:59:27.598]                     }
[17:59:27.598]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.598]                   }
[17:59:27.598]                 }
[17:59:27.598]             }
[17:59:27.598]         }))
[17:59:27.598]     }, error = function(ex) {
[17:59:27.598]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:27.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.598]                 ...future.rng), started = ...future.startTime, 
[17:59:27.598]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:27.598]             version = "1.8"), class = "FutureResult")
[17:59:27.598]     }, finally = {
[17:59:27.598]         if (!identical(...future.workdir, getwd())) 
[17:59:27.598]             setwd(...future.workdir)
[17:59:27.598]         {
[17:59:27.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:27.598]                 ...future.oldOptions$nwarnings <- NULL
[17:59:27.598]             }
[17:59:27.598]             base::options(...future.oldOptions)
[17:59:27.598]             if (.Platform$OS.type == "windows") {
[17:59:27.598]                 old_names <- names(...future.oldEnvVars)
[17:59:27.598]                 envs <- base::Sys.getenv()
[17:59:27.598]                 names <- names(envs)
[17:59:27.598]                 common <- intersect(names, old_names)
[17:59:27.598]                 added <- setdiff(names, old_names)
[17:59:27.598]                 removed <- setdiff(old_names, names)
[17:59:27.598]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:27.598]                   envs[common]]
[17:59:27.598]                 NAMES <- toupper(changed)
[17:59:27.598]                 args <- list()
[17:59:27.598]                 for (kk in seq_along(NAMES)) {
[17:59:27.598]                   name <- changed[[kk]]
[17:59:27.598]                   NAME <- NAMES[[kk]]
[17:59:27.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.598]                     next
[17:59:27.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.598]                 }
[17:59:27.598]                 NAMES <- toupper(added)
[17:59:27.598]                 for (kk in seq_along(NAMES)) {
[17:59:27.598]                   name <- added[[kk]]
[17:59:27.598]                   NAME <- NAMES[[kk]]
[17:59:27.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.598]                     next
[17:59:27.598]                   args[[name]] <- ""
[17:59:27.598]                 }
[17:59:27.598]                 NAMES <- toupper(removed)
[17:59:27.598]                 for (kk in seq_along(NAMES)) {
[17:59:27.598]                   name <- removed[[kk]]
[17:59:27.598]                   NAME <- NAMES[[kk]]
[17:59:27.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.598]                     next
[17:59:27.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.598]                 }
[17:59:27.598]                 if (length(args) > 0) 
[17:59:27.598]                   base::do.call(base::Sys.setenv, args = args)
[17:59:27.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:27.598]             }
[17:59:27.598]             else {
[17:59:27.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:27.598]             }
[17:59:27.598]             {
[17:59:27.598]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:27.598]                   0L) {
[17:59:27.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:27.598]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:27.598]                   base::options(opts)
[17:59:27.598]                 }
[17:59:27.598]                 {
[17:59:27.598]                   {
[17:59:27.598]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:27.598]                     NULL
[17:59:27.598]                   }
[17:59:27.598]                   options(future.plan = NULL)
[17:59:27.598]                   if (is.na(NA_character_)) 
[17:59:27.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:27.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:27.598]                     .init = FALSE)
[17:59:27.598]                 }
[17:59:27.598]             }
[17:59:27.598]         }
[17:59:27.598]     })
[17:59:27.598]     if (TRUE) {
[17:59:27.598]         base::sink(type = "output", split = FALSE)
[17:59:27.598]         if (TRUE) {
[17:59:27.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:27.598]         }
[17:59:27.598]         else {
[17:59:27.598]             ...future.result["stdout"] <- base::list(NULL)
[17:59:27.598]         }
[17:59:27.598]         base::close(...future.stdout)
[17:59:27.598]         ...future.stdout <- NULL
[17:59:27.598]     }
[17:59:27.598]     ...future.result$conditions <- ...future.conditions
[17:59:27.598]     ...future.result$finished <- base::Sys.time()
[17:59:27.598]     ...future.result
[17:59:27.598] }
[17:59:27.603] assign_globals() ...
[17:59:27.603] List of 5
[17:59:27.603]  $ ...future.FUN            :function (object, ...)  
[17:59:27.603]  $ future.call.arguments    : list()
[17:59:27.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.603]  $ ...future.elements_ii    :List of 1
[17:59:27.603]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.603]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[17:59:27.603]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.603]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:27.603]  $ ...future.seeds_ii       : NULL
[17:59:27.603]  $ ...future.globals.maxSize: NULL
[17:59:27.603]  - attr(*, "where")=List of 5
[17:59:27.603]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:27.603]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:27.603]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:27.603]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:27.603]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:27.603]  - attr(*, "resolved")= logi FALSE
[17:59:27.603]  - attr(*, "total_size")= num 1240
[17:59:27.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.603]  - attr(*, "already-done")= logi TRUE
[17:59:27.618] - copied ‘...future.FUN’ to environment
[17:59:27.618] - copied ‘future.call.arguments’ to environment
[17:59:27.619] - copied ‘...future.elements_ii’ to environment
[17:59:27.619] - copied ‘...future.seeds_ii’ to environment
[17:59:27.619] - copied ‘...future.globals.maxSize’ to environment
[17:59:27.619] assign_globals() ... done
[17:59:27.620] requestCore(): workers = 2
[17:59:27.623] MulticoreFuture started
[17:59:27.624] - Launch lazy future ... done
[17:59:27.625] run() for ‘MulticoreFuture’ ... done
[17:59:27.625] plan(): Setting new future strategy stack:
[17:59:27.626] Created future:
[17:59:27.626] List of future strategies:
[17:59:27.626] 1. sequential:
[17:59:27.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:27.626]    - tweaked: FALSE
[17:59:27.626]    - call: NULL
[17:59:27.630] plan(): nbrOfWorkers() = 1
[17:59:27.637] plan(): Setting new future strategy stack:
[17:59:27.638] List of future strategies:
[17:59:27.638] 1. multicore:
[17:59:27.638]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.638]    - tweaked: FALSE
[17:59:27.638]    - call: plan(strategy)
[17:59:27.627] MulticoreFuture:
[17:59:27.627] Label: ‘future_by-1’
[17:59:27.627] Expression:
[17:59:27.627] {
[17:59:27.627]     do.call(function(...) {
[17:59:27.627]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.627]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.627]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.627]             on.exit(options(oopts), add = TRUE)
[17:59:27.627]         }
[17:59:27.627]         {
[17:59:27.627]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.627]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.627]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.627]             })
[17:59:27.627]         }
[17:59:27.627]     }, args = future.call.arguments)
[17:59:27.627] }
[17:59:27.627] Lazy evaluation: FALSE
[17:59:27.627] Asynchronous evaluation: TRUE
[17:59:27.627] Local evaluation: TRUE
[17:59:27.627] Environment: 0x62649f4a9e38
[17:59:27.627] Capture standard output: TRUE
[17:59:27.627] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:27.627] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:27.627] Packages: <none>
[17:59:27.627] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:27.627] Resolved: FALSE
[17:59:27.627] Value: <not collected>
[17:59:27.627] Conditions captured: <none>
[17:59:27.627] Early signaling: FALSE
[17:59:27.627] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:27.627] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.645] Chunk #1 of 2 ... DONE
[17:59:27.645] Chunk #2 of 2 ...
[17:59:27.646]  - Finding globals in 'X' for chunk #2 ...
[17:59:27.646] getGlobalsAndPackages() ...
[17:59:27.646] Searching for globals...
[17:59:27.648] plan(): nbrOfWorkers() = 2
[17:59:27.648] 
[17:59:27.648] Searching for globals ... DONE
[17:59:27.649] - globals: [0] <none>
[17:59:27.649] getGlobalsAndPackages() ... DONE
[17:59:27.649]    + additional globals found: [n=0] 
[17:59:27.650]    + additional namespaces needed: [n=0] 
[17:59:27.650]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:27.650]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:27.650]  - seeds: <none>
[17:59:27.651]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.651] getGlobalsAndPackages() ...
[17:59:27.651] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.652] Resolving globals: FALSE
[17:59:27.652] Tweak future expression to call with '...' arguments ...
[17:59:27.653] {
[17:59:27.653]     do.call(function(...) {
[17:59:27.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.653]             on.exit(options(oopts), add = TRUE)
[17:59:27.653]         }
[17:59:27.653]         {
[17:59:27.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.653]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.653]             })
[17:59:27.653]         }
[17:59:27.653]     }, args = future.call.arguments)
[17:59:27.653] }
[17:59:27.654] Tweak future expression to call with '...' arguments ... DONE
[17:59:27.655] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:27.655] 
[17:59:27.655] getGlobalsAndPackages() ... DONE
[17:59:27.656] run() for ‘Future’ ...
[17:59:27.657] - state: ‘created’
[17:59:27.657] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:59:27.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:59:27.666]   - Field: ‘label’
[17:59:27.666]   - Field: ‘local’
[17:59:27.666]   - Field: ‘owner’
[17:59:27.667]   - Field: ‘envir’
[17:59:27.667]   - Field: ‘workers’
[17:59:27.667]   - Field: ‘packages’
[17:59:27.667]   - Field: ‘gc’
[17:59:27.668]   - Field: ‘job’
[17:59:27.668]   - Field: ‘conditions’
[17:59:27.668]   - Field: ‘expr’
[17:59:27.669]   - Field: ‘uuid’
[17:59:27.669]   - Field: ‘seed’
[17:59:27.669]   - Field: ‘version’
[17:59:27.670]   - Field: ‘result’
[17:59:27.670]   - Field: ‘asynchronous’
[17:59:27.670]   - Field: ‘calls’
[17:59:27.671]   - Field: ‘globals’
[17:59:27.671]   - Field: ‘stdout’
[17:59:27.671]   - Field: ‘earlySignal’
[17:59:27.671]   - Field: ‘lazy’
[17:59:27.672]   - Field: ‘state’
[17:59:27.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:59:27.672] - Launch lazy future ...
[17:59:27.673] Packages needed by the future expression (n = 0): <none>
[17:59:27.674] Packages needed by future strategies (n = 0): <none>
[17:59:27.675] {
[17:59:27.675]     {
[17:59:27.675]         {
[17:59:27.675]             ...future.startTime <- base::Sys.time()
[17:59:27.675]             {
[17:59:27.675]                 {
[17:59:27.675]                   {
[17:59:27.675]                     {
[17:59:27.675]                       base::local({
[17:59:27.675]                         has_future <- base::requireNamespace("future", 
[17:59:27.675]                           quietly = TRUE)
[17:59:27.675]                         if (has_future) {
[17:59:27.675]                           ns <- base::getNamespace("future")
[17:59:27.675]                           version <- ns[[".package"]][["version"]]
[17:59:27.675]                           if (is.null(version)) 
[17:59:27.675]                             version <- utils::packageVersion("future")
[17:59:27.675]                         }
[17:59:27.675]                         else {
[17:59:27.675]                           version <- NULL
[17:59:27.675]                         }
[17:59:27.675]                         if (!has_future || version < "1.8.0") {
[17:59:27.675]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:27.675]                             "", base::R.version$version.string), 
[17:59:27.675]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:27.675]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:27.675]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:27.675]                               "release", "version")], collapse = " "), 
[17:59:27.675]                             hostname = base::Sys.info()[["nodename"]])
[17:59:27.675]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:27.675]                             info)
[17:59:27.675]                           info <- base::paste(info, collapse = "; ")
[17:59:27.675]                           if (!has_future) {
[17:59:27.675]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:27.675]                               info)
[17:59:27.675]                           }
[17:59:27.675]                           else {
[17:59:27.675]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:27.675]                               info, version)
[17:59:27.675]                           }
[17:59:27.675]                           base::stop(msg)
[17:59:27.675]                         }
[17:59:27.675]                       })
[17:59:27.675]                     }
[17:59:27.675]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:27.675]                     base::options(mc.cores = 1L)
[17:59:27.675]                   }
[17:59:27.675]                   ...future.strategy.old <- future::plan("list")
[17:59:27.675]                   options(future.plan = NULL)
[17:59:27.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:27.675]                 }
[17:59:27.675]                 ...future.workdir <- getwd()
[17:59:27.675]             }
[17:59:27.675]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:27.675]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:27.675]         }
[17:59:27.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:27.675]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:27.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:27.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:27.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:27.675]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:27.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:27.675]             base::names(...future.oldOptions))
[17:59:27.675]     }
[17:59:27.675]     if (FALSE) {
[17:59:27.675]     }
[17:59:27.675]     else {
[17:59:27.675]         if (TRUE) {
[17:59:27.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:27.675]                 open = "w")
[17:59:27.675]         }
[17:59:27.675]         else {
[17:59:27.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:27.675]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:27.675]         }
[17:59:27.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:27.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:27.675]             base::sink(type = "output", split = FALSE)
[17:59:27.675]             base::close(...future.stdout)
[17:59:27.675]         }, add = TRUE)
[17:59:27.675]     }
[17:59:27.675]     ...future.frame <- base::sys.nframe()
[17:59:27.675]     ...future.conditions <- base::list()
[17:59:27.675]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:27.675]     if (FALSE) {
[17:59:27.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:27.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:27.675]     }
[17:59:27.675]     ...future.result <- base::tryCatch({
[17:59:27.675]         base::withCallingHandlers({
[17:59:27.675]             ...future.value <- base::withVisible(base::local({
[17:59:27.675]                 withCallingHandlers({
[17:59:27.675]                   {
[17:59:27.675]                     do.call(function(...) {
[17:59:27.675]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.675]                       if (!identical(...future.globals.maxSize.org, 
[17:59:27.675]                         ...future.globals.maxSize)) {
[17:59:27.675]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.675]                         on.exit(options(oopts), add = TRUE)
[17:59:27.675]                       }
[17:59:27.675]                       {
[17:59:27.675]                         lapply(seq_along(...future.elements_ii), 
[17:59:27.675]                           FUN = function(jj) {
[17:59:27.675]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.675]                             ...future.FUN(...future.X_jj, ...)
[17:59:27.675]                           })
[17:59:27.675]                       }
[17:59:27.675]                     }, args = future.call.arguments)
[17:59:27.675]                   }
[17:59:27.675]                 }, immediateCondition = function(cond) {
[17:59:27.675]                   save_rds <- function (object, pathname, ...) 
[17:59:27.675]                   {
[17:59:27.675]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:59:27.675]                     if (file_test("-f", pathname_tmp)) {
[17:59:27.675]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.675]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:59:27.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.675]                         fi_tmp[["mtime"]])
[17:59:27.675]                     }
[17:59:27.675]                     tryCatch({
[17:59:27.675]                       saveRDS(object, file = pathname_tmp, ...)
[17:59:27.675]                     }, error = function(ex) {
[17:59:27.675]                       msg <- conditionMessage(ex)
[17:59:27.675]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.675]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:59:27.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.675]                         fi_tmp[["mtime"]], msg)
[17:59:27.675]                       ex$message <- msg
[17:59:27.675]                       stop(ex)
[17:59:27.675]                     })
[17:59:27.675]                     stopifnot(file_test("-f", pathname_tmp))
[17:59:27.675]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:59:27.675]                     if (!res || file_test("-f", pathname_tmp)) {
[17:59:27.675]                       fi_tmp <- file.info(pathname_tmp)
[17:59:27.675]                       fi <- file.info(pathname)
[17:59:27.675]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:59:27.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:59:27.675]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:59:27.675]                         fi[["size"]], fi[["mtime"]])
[17:59:27.675]                       stop(msg)
[17:59:27.675]                     }
[17:59:27.675]                     invisible(pathname)
[17:59:27.675]                   }
[17:59:27.675]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:59:27.675]                     rootPath = tempdir()) 
[17:59:27.675]                   {
[17:59:27.675]                     obj <- list(time = Sys.time(), condition = cond)
[17:59:27.675]                     file <- tempfile(pattern = class(cond)[1], 
[17:59:27.675]                       tmpdir = path, fileext = ".rds")
[17:59:27.675]                     save_rds(obj, file)
[17:59:27.675]                   }
[17:59:27.675]                   saveImmediateCondition(cond, path = "/tmp/Rtmp9ZPdri/.future/immediateConditions")
[17:59:27.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.675]                   {
[17:59:27.675]                     inherits <- base::inherits
[17:59:27.675]                     invokeRestart <- base::invokeRestart
[17:59:27.675]                     is.null <- base::is.null
[17:59:27.675]                     muffled <- FALSE
[17:59:27.675]                     if (inherits(cond, "message")) {
[17:59:27.675]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:27.675]                       if (muffled) 
[17:59:27.675]                         invokeRestart("muffleMessage")
[17:59:27.675]                     }
[17:59:27.675]                     else if (inherits(cond, "warning")) {
[17:59:27.675]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:27.675]                       if (muffled) 
[17:59:27.675]                         invokeRestart("muffleWarning")
[17:59:27.675]                     }
[17:59:27.675]                     else if (inherits(cond, "condition")) {
[17:59:27.675]                       if (!is.null(pattern)) {
[17:59:27.675]                         computeRestarts <- base::computeRestarts
[17:59:27.675]                         grepl <- base::grepl
[17:59:27.675]                         restarts <- computeRestarts(cond)
[17:59:27.675]                         for (restart in restarts) {
[17:59:27.675]                           name <- restart$name
[17:59:27.675]                           if (is.null(name)) 
[17:59:27.675]                             next
[17:59:27.675]                           if (!grepl(pattern, name)) 
[17:59:27.675]                             next
[17:59:27.675]                           invokeRestart(restart)
[17:59:27.675]                           muffled <- TRUE
[17:59:27.675]                           break
[17:59:27.675]                         }
[17:59:27.675]                       }
[17:59:27.675]                     }
[17:59:27.675]                     invisible(muffled)
[17:59:27.675]                   }
[17:59:27.675]                   muffleCondition(cond)
[17:59:27.675]                 })
[17:59:27.675]             }))
[17:59:27.675]             future::FutureResult(value = ...future.value$value, 
[17:59:27.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.675]                   ...future.rng), globalenv = if (FALSE) 
[17:59:27.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:27.675]                     ...future.globalenv.names))
[17:59:27.675]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:27.675]         }, condition = base::local({
[17:59:27.675]             c <- base::c
[17:59:27.675]             inherits <- base::inherits
[17:59:27.675]             invokeRestart <- base::invokeRestart
[17:59:27.675]             length <- base::length
[17:59:27.675]             list <- base::list
[17:59:27.675]             seq.int <- base::seq.int
[17:59:27.675]             signalCondition <- base::signalCondition
[17:59:27.675]             sys.calls <- base::sys.calls
[17:59:27.675]             `[[` <- base::`[[`
[17:59:27.675]             `+` <- base::`+`
[17:59:27.675]             `<<-` <- base::`<<-`
[17:59:27.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:27.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:27.675]                   3L)]
[17:59:27.675]             }
[17:59:27.675]             function(cond) {
[17:59:27.675]                 is_error <- inherits(cond, "error")
[17:59:27.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:27.675]                   NULL)
[17:59:27.675]                 if (is_error) {
[17:59:27.675]                   sessionInformation <- function() {
[17:59:27.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:27.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:27.675]                       search = base::search(), system = base::Sys.info())
[17:59:27.675]                   }
[17:59:27.675]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:27.675]                     cond$call), session = sessionInformation(), 
[17:59:27.675]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:27.675]                   signalCondition(cond)
[17:59:27.675]                 }
[17:59:27.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:27.675]                 "immediateCondition"))) {
[17:59:27.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:27.675]                   ...future.conditions[[length(...future.conditions) + 
[17:59:27.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:27.675]                   if (TRUE && !signal) {
[17:59:27.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.675]                     {
[17:59:27.675]                       inherits <- base::inherits
[17:59:27.675]                       invokeRestart <- base::invokeRestart
[17:59:27.675]                       is.null <- base::is.null
[17:59:27.675]                       muffled <- FALSE
[17:59:27.675]                       if (inherits(cond, "message")) {
[17:59:27.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.675]                         if (muffled) 
[17:59:27.675]                           invokeRestart("muffleMessage")
[17:59:27.675]                       }
[17:59:27.675]                       else if (inherits(cond, "warning")) {
[17:59:27.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.675]                         if (muffled) 
[17:59:27.675]                           invokeRestart("muffleWarning")
[17:59:27.675]                       }
[17:59:27.675]                       else if (inherits(cond, "condition")) {
[17:59:27.675]                         if (!is.null(pattern)) {
[17:59:27.675]                           computeRestarts <- base::computeRestarts
[17:59:27.675]                           grepl <- base::grepl
[17:59:27.675]                           restarts <- computeRestarts(cond)
[17:59:27.675]                           for (restart in restarts) {
[17:59:27.675]                             name <- restart$name
[17:59:27.675]                             if (is.null(name)) 
[17:59:27.675]                               next
[17:59:27.675]                             if (!grepl(pattern, name)) 
[17:59:27.675]                               next
[17:59:27.675]                             invokeRestart(restart)
[17:59:27.675]                             muffled <- TRUE
[17:59:27.675]                             break
[17:59:27.675]                           }
[17:59:27.675]                         }
[17:59:27.675]                       }
[17:59:27.675]                       invisible(muffled)
[17:59:27.675]                     }
[17:59:27.675]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.675]                   }
[17:59:27.675]                 }
[17:59:27.675]                 else {
[17:59:27.675]                   if (TRUE) {
[17:59:27.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:27.675]                     {
[17:59:27.675]                       inherits <- base::inherits
[17:59:27.675]                       invokeRestart <- base::invokeRestart
[17:59:27.675]                       is.null <- base::is.null
[17:59:27.675]                       muffled <- FALSE
[17:59:27.675]                       if (inherits(cond, "message")) {
[17:59:27.675]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:27.675]                         if (muffled) 
[17:59:27.675]                           invokeRestart("muffleMessage")
[17:59:27.675]                       }
[17:59:27.675]                       else if (inherits(cond, "warning")) {
[17:59:27.675]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:27.675]                         if (muffled) 
[17:59:27.675]                           invokeRestart("muffleWarning")
[17:59:27.675]                       }
[17:59:27.675]                       else if (inherits(cond, "condition")) {
[17:59:27.675]                         if (!is.null(pattern)) {
[17:59:27.675]                           computeRestarts <- base::computeRestarts
[17:59:27.675]                           grepl <- base::grepl
[17:59:27.675]                           restarts <- computeRestarts(cond)
[17:59:27.675]                           for (restart in restarts) {
[17:59:27.675]                             name <- restart$name
[17:59:27.675]                             if (is.null(name)) 
[17:59:27.675]                               next
[17:59:27.675]                             if (!grepl(pattern, name)) 
[17:59:27.675]                               next
[17:59:27.675]                             invokeRestart(restart)
[17:59:27.675]                             muffled <- TRUE
[17:59:27.675]                             break
[17:59:27.675]                           }
[17:59:27.675]                         }
[17:59:27.675]                       }
[17:59:27.675]                       invisible(muffled)
[17:59:27.675]                     }
[17:59:27.675]                     muffleCondition(cond, pattern = "^muffle")
[17:59:27.675]                   }
[17:59:27.675]                 }
[17:59:27.675]             }
[17:59:27.675]         }))
[17:59:27.675]     }, error = function(ex) {
[17:59:27.675]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:27.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:27.675]                 ...future.rng), started = ...future.startTime, 
[17:59:27.675]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:27.675]             version = "1.8"), class = "FutureResult")
[17:59:27.675]     }, finally = {
[17:59:27.675]         if (!identical(...future.workdir, getwd())) 
[17:59:27.675]             setwd(...future.workdir)
[17:59:27.675]         {
[17:59:27.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:27.675]                 ...future.oldOptions$nwarnings <- NULL
[17:59:27.675]             }
[17:59:27.675]             base::options(...future.oldOptions)
[17:59:27.675]             if (.Platform$OS.type == "windows") {
[17:59:27.675]                 old_names <- names(...future.oldEnvVars)
[17:59:27.675]                 envs <- base::Sys.getenv()
[17:59:27.675]                 names <- names(envs)
[17:59:27.675]                 common <- intersect(names, old_names)
[17:59:27.675]                 added <- setdiff(names, old_names)
[17:59:27.675]                 removed <- setdiff(old_names, names)
[17:59:27.675]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:27.675]                   envs[common]]
[17:59:27.675]                 NAMES <- toupper(changed)
[17:59:27.675]                 args <- list()
[17:59:27.675]                 for (kk in seq_along(NAMES)) {
[17:59:27.675]                   name <- changed[[kk]]
[17:59:27.675]                   NAME <- NAMES[[kk]]
[17:59:27.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.675]                     next
[17:59:27.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.675]                 }
[17:59:27.675]                 NAMES <- toupper(added)
[17:59:27.675]                 for (kk in seq_along(NAMES)) {
[17:59:27.675]                   name <- added[[kk]]
[17:59:27.675]                   NAME <- NAMES[[kk]]
[17:59:27.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.675]                     next
[17:59:27.675]                   args[[name]] <- ""
[17:59:27.675]                 }
[17:59:27.675]                 NAMES <- toupper(removed)
[17:59:27.675]                 for (kk in seq_along(NAMES)) {
[17:59:27.675]                   name <- removed[[kk]]
[17:59:27.675]                   NAME <- NAMES[[kk]]
[17:59:27.675]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:27.675]                     next
[17:59:27.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:27.675]                 }
[17:59:27.675]                 if (length(args) > 0) 
[17:59:27.675]                   base::do.call(base::Sys.setenv, args = args)
[17:59:27.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:27.675]             }
[17:59:27.675]             else {
[17:59:27.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:27.675]             }
[17:59:27.675]             {
[17:59:27.675]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:27.675]                   0L) {
[17:59:27.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:27.675]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:27.675]                   base::options(opts)
[17:59:27.675]                 }
[17:59:27.675]                 {
[17:59:27.675]                   {
[17:59:27.675]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:27.675]                     NULL
[17:59:27.675]                   }
[17:59:27.675]                   options(future.plan = NULL)
[17:59:27.675]                   if (is.na(NA_character_)) 
[17:59:27.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:27.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:27.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:27.675]                     .init = FALSE)
[17:59:27.675]                 }
[17:59:27.675]             }
[17:59:27.675]         }
[17:59:27.675]     })
[17:59:27.675]     if (TRUE) {
[17:59:27.675]         base::sink(type = "output", split = FALSE)
[17:59:27.675]         if (TRUE) {
[17:59:27.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:27.675]         }
[17:59:27.675]         else {
[17:59:27.675]             ...future.result["stdout"] <- base::list(NULL)
[17:59:27.675]         }
[17:59:27.675]         base::close(...future.stdout)
[17:59:27.675]         ...future.stdout <- NULL
[17:59:27.675]     }
[17:59:27.675]     ...future.result$conditions <- ...future.conditions
[17:59:27.675]     ...future.result$finished <- base::Sys.time()
[17:59:27.675]     ...future.result
[17:59:27.675] }
[17:59:27.682] assign_globals() ...
[17:59:27.682] List of 5
[17:59:27.682]  $ ...future.FUN            :function (object, ...)  
[17:59:27.682]  $ future.call.arguments    : list()
[17:59:27.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:27.682]  $ ...future.elements_ii    :List of 2
[17:59:27.682]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.682]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[17:59:27.682]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.682]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[17:59:27.682]   ..$ :'data.frame':	18 obs. of  3 variables:
[17:59:27.682]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[17:59:27.682]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[17:59:27.682]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[17:59:27.682]  $ ...future.seeds_ii       : NULL
[17:59:27.682]  $ ...future.globals.maxSize: NULL
[17:59:27.682]  - attr(*, "where")=List of 5
[17:59:27.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:59:27.682]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:59:27.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:59:27.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:59:27.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:59:27.682]  - attr(*, "resolved")= logi FALSE
[17:59:27.682]  - attr(*, "total_size")= num 1240
[17:59:27.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:27.682]  - attr(*, "already-done")= logi TRUE
[17:59:27.708] - copied ‘...future.FUN’ to environment
[17:59:27.709] - copied ‘future.call.arguments’ to environment
[17:59:27.709] - copied ‘...future.elements_ii’ to environment
[17:59:27.709] - copied ‘...future.seeds_ii’ to environment
[17:59:27.709] - copied ‘...future.globals.maxSize’ to environment
[17:59:27.710] assign_globals() ... done
[17:59:27.710] requestCore(): workers = 2
[17:59:27.713] MulticoreFuture started
[17:59:27.714] - Launch lazy future ... done
[17:59:27.715] run() for ‘MulticoreFuture’ ... done
[17:59:27.715] plan(): Setting new future strategy stack:
[17:59:27.716] Created future:
[17:59:27.716] List of future strategies:
[17:59:27.716] 1. sequential:
[17:59:27.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:27.716]    - tweaked: FALSE
[17:59:27.716]    - call: NULL
[17:59:27.718] plan(): nbrOfWorkers() = 1
[17:59:27.728] plan(): Setting new future strategy stack:
[17:59:27.729] List of future strategies:
[17:59:27.729] 1. multicore:
[17:59:27.729]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:59:27.729]    - tweaked: FALSE
[17:59:27.729]    - call: plan(strategy)
[17:59:27.716] MulticoreFuture:
[17:59:27.716] Label: ‘future_by-2’
[17:59:27.716] Expression:
[17:59:27.716] {
[17:59:27.716]     do.call(function(...) {
[17:59:27.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:27.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:27.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:27.716]             on.exit(options(oopts), add = TRUE)
[17:59:27.716]         }
[17:59:27.716]         {
[17:59:27.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:27.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:27.716]                 ...future.FUN(...future.X_jj, ...)
[17:59:27.716]             })
[17:59:27.716]         }
[17:59:27.716]     }, args = future.call.arguments)
[17:59:27.716] }
[17:59:27.716] Lazy evaluation: FALSE
[17:59:27.716] Asynchronous evaluation: TRUE
[17:59:27.716] Local evaluation: TRUE
[17:59:27.716] Environment: 0x62649f4a9e38
[17:59:27.716] Capture standard output: TRUE
[17:59:27.716] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:27.716] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:27.716] Packages: <none>
[17:59:27.716] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:27.716] Resolved: FALSE
[17:59:27.716] Value: <not collected>
[17:59:27.716] Conditions captured: <none>
[17:59:27.716] Early signaling: FALSE
[17:59:27.716] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:27.716] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:27.733] Chunk #2 of 2 ... DONE
[17:59:27.733] Launching 2 futures (chunks) ... DONE
[17:59:27.734] Resolving 2 futures (chunks) ...
[17:59:27.734] resolve() on list ...
[17:59:27.735]  recursive: 0
[17:59:27.735]  length: 2
[17:59:27.735] 
[17:59:27.736] Future #1
[17:59:27.736] result() for MulticoreFuture ...
[17:59:27.738] result() for MulticoreFuture ...
[17:59:27.738] result() for MulticoreFuture ... done
[17:59:27.739] result() for MulticoreFuture ... done
[17:59:27.739] result() for MulticoreFuture ...
[17:59:27.739] result() for MulticoreFuture ... done
[17:59:27.740] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:59:27.740] - nx: 2
[17:59:27.740] plan(): nbrOfWorkers() = 2
[17:59:27.740] - relay: TRUE
[17:59:27.740] - stdout: TRUE
[17:59:27.741] - signal: TRUE
[17:59:27.741] - resignal: FALSE
[17:59:27.741] - force: TRUE
[17:59:27.742] - relayed: [n=2] FALSE, FALSE
[17:59:27.742] - queued futures: [n=2] FALSE, FALSE
[17:59:27.742]  - until=1
[17:59:27.743]  - relaying element #1
[17:59:27.743] result() for MulticoreFuture ...
[17:59:27.743] result() for MulticoreFuture ... done
[17:59:27.744] result() for MulticoreFuture ...
[17:59:27.744] result() for MulticoreFuture ... done
[17:59:27.744] result() for MulticoreFuture ...
[17:59:27.745] result() for MulticoreFuture ... done
[17:59:27.745] result() for MulticoreFuture ...
[17:59:27.745] result() for MulticoreFuture ... done
[17:59:27.745] - relayed: [n=2] TRUE, FALSE
[17:59:27.746] - queued futures: [n=2] TRUE, FALSE
[17:59:27.746] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:59:27.747]  length: 1 (resolved future 1)
[17:59:27.747] Future #2
[17:59:27.748] result() for MulticoreFuture ...
[17:59:27.749] result() for MulticoreFuture ...
[17:59:27.749] result() for MulticoreFuture ... done
[17:59:27.750] result() for MulticoreFuture ... done
[17:59:27.750] result() for MulticoreFuture ...
[17:59:27.750] result() for MulticoreFuture ... done
[17:59:27.751] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:59:27.751] - nx: 2
[17:59:27.751] - relay: TRUE
[17:59:27.752] - stdout: TRUE
[17:59:27.752] - signal: TRUE
[17:59:27.752] - resignal: FALSE
[17:59:27.752] - force: TRUE
[17:59:27.753] - relayed: [n=2] TRUE, FALSE
[17:59:27.753] - queued futures: [n=2] TRUE, FALSE
[17:59:27.753]  - until=2
[17:59:27.754]  - relaying element #2
[17:59:27.754] result() for MulticoreFuture ...
[17:59:27.754] result() for MulticoreFuture ... done
[17:59:27.754] result() for MulticoreFuture ...
[17:59:27.755] result() for MulticoreFuture ... done
[17:59:27.755] result() for MulticoreFuture ...
[17:59:27.755] result() for MulticoreFuture ... done
[17:59:27.756] result() for MulticoreFuture ...
[17:59:27.756] result() for MulticoreFuture ... done
[17:59:27.756] - relayed: [n=2] TRUE, TRUE
[17:59:27.756] - queued futures: [n=2] TRUE, TRUE
[17:59:27.756] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:59:27.757]  length: 0 (resolved future 2)
[17:59:27.757] Relaying remaining futures
[17:59:27.757] signalConditionsASAP(NULL, pos=0) ...
[17:59:27.757] - nx: 2
[17:59:27.758] - relay: TRUE
[17:59:27.758] - stdout: TRUE
[17:59:27.758] - signal: TRUE
[17:59:27.758] - resignal: FALSE
[17:59:27.759] - force: TRUE
[17:59:27.759] - relayed: [n=2] TRUE, TRUE
[17:59:27.759] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:27.759] - relayed: [n=2] TRUE, TRUE
[17:59:27.760] - queued futures: [n=2] TRUE, TRUE
[17:59:27.760] signalConditionsASAP(NULL, pos=0) ... done
[17:59:27.760] resolve() on list ... DONE
[17:59:27.760] result() for MulticoreFuture ...
[17:59:27.761] result() for MulticoreFuture ... done
[17:59:27.761] result() for MulticoreFuture ...
[17:59:27.761] result() for MulticoreFuture ... done
[17:59:27.761] result() for MulticoreFuture ...
[17:59:27.762] result() for MulticoreFuture ... done
[17:59:27.762] result() for MulticoreFuture ...
[17:59:27.762] result() for MulticoreFuture ... done
[17:59:27.762]  - Number of value chunks collected: 2
[17:59:27.763] Resolving 2 futures (chunks) ... DONE
[17:59:27.763] Reducing values from 2 chunks ...
[17:59:27.763]  - Number of values collected after concatenation: 3
[17:59:27.763]  - Number of values expected: 3
[17:59:27.764] Reducing values from 2 chunks ... DONE
[17:59:27.764] future_lapply() ... DONE
[17:59:27.764] future_by_internal() ... DONE
[17:59:27.772] future_by_internal() ...
- plan('multisession') ...
[17:59:27.773] plan(): Setting new future strategy stack:
[17:59:27.774] List of future strategies:
[17:59:27.774] 1. multisession:
[17:59:27.774]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:27.774]    - tweaked: FALSE
[17:59:27.774]    - call: plan(strategy)
[17:59:27.775] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:59:27.775] multisession:
[17:59:27.775] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:59:27.775] - tweaked: FALSE
[17:59:27.775] - call: plan(strategy)
[17:59:27.787] getGlobalsAndPackages() ...
[17:59:27.787] Not searching for globals
[17:59:27.787] - globals: [0] <none>
[17:59:27.788] getGlobalsAndPackages() ... DONE
[17:59:27.789] [local output] makeClusterPSOCK() ...
[17:59:27.859] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:59:27.861] [local output] Base port: 11554
[17:59:27.861] [local output] Getting setup options for 2 cluster nodes ...
[17:59:27.861] [local output]  - Node 1 of 2 ...
[17:59:27.862] [local output] localMachine=TRUE => revtunnel=FALSE

[17:59:27.863] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9ZPdri/worker.rank=1.parallelly.parent=307917.4b2cd6cc74584.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmp9ZPdri/worker.rank=1.parallelly.parent=307917.4b2cd6cc74584.pid")'’
[17:59:28.117] - Possible to infer worker's PID: TRUE
[17:59:28.118] [local output] Rscript port: 11554

[17:59:28.118] [local output]  - Node 2 of 2 ...
[17:59:28.122] [local output] localMachine=TRUE => revtunnel=FALSE

[17:59:28.123] [local output] Rscript port: 11554

[17:59:28.124] [local output] Getting setup options for 2 cluster nodes ... done
[17:59:28.124] [local output]  - Parallel setup requested for some PSOCK nodes
[17:59:28.125] [local output] Setting up PSOCK nodes in parallel
[17:59:28.125] List of 36
[17:59:28.125]  $ worker          : chr "localhost"
[17:59:28.125]   ..- attr(*, "localhost")= logi TRUE
[17:59:28.125]  $ master          : chr "localhost"
[17:59:28.125]  $ port            : int 11554
[17:59:28.125]  $ connectTimeout  : num 120
[17:59:28.125]  $ timeout         : num 2592000
[17:59:28.125]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:59:28.125]  $ homogeneous     : logi TRUE
[17:59:28.125]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:59:28.125]  $ rscript_envs    : NULL
[17:59:28.125]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:59:28.125]  $ rscript_startup : NULL
[17:59:28.125]  $ rscript_sh      : chr "sh"
[17:59:28.125]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:59:28.125]  $ methods         : logi TRUE
[17:59:28.125]  $ socketOptions   : chr "no-delay"
[17:59:28.125]  $ useXDR          : logi FALSE
[17:59:28.125]  $ outfile         : chr "/dev/null"
[17:59:28.125]  $ renice          : int NA
[17:59:28.125]  $ rshcmd          : NULL
[17:59:28.125]  $ user            : chr(0) 
[17:59:28.125]  $ revtunnel       : logi FALSE
[17:59:28.125]  $ rshlogfile      : NULL
[17:59:28.125]  $ rshopts         : chr(0) 
[17:59:28.125]  $ rank            : int 1
[17:59:28.125]  $ manual          : logi FALSE
[17:59:28.125]  $ dryrun          : logi FALSE
[17:59:28.125]  $ quiet           : logi FALSE
[17:59:28.125]  $ setup_strategy  : chr "parallel"
[17:59:28.125]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:59:28.125]  $ pidfile         : chr "/tmp/Rtmp9ZPdri/worker.rank=1.parallelly.parent=307917.4b2cd6cc74584.pid"
[17:59:28.125]  $ rshcmd_label    : NULL
[17:59:28.125]  $ rsh_call        : NULL
[17:59:28.125]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:59:28.125]  $ localMachine    : logi TRUE
[17:59:28.125]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:59:28.125]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:59:28.125]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:59:28.125]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:59:28.125]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:59:28.125]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:59:28.125]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:59:28.125]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:59:28.125]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:59:28.125]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:59:28.125]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:59:28.125]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:59:28.125]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:59:28.125]  $ arguments       :List of 28
[17:59:28.125]   ..$ worker          : chr "localhost"
[17:59:28.125]   ..$ master          : NULL
[17:59:28.125]   ..$ port            : int 11554
[17:59:28.125]   ..$ connectTimeout  : num 120
[17:59:28.125]   ..$ timeout         : num 2592000
[17:59:28.125]   ..$ rscript         : NULL
[17:59:28.125]   ..$ homogeneous     : NULL
[17:59:28.125]   ..$ rscript_args    : NULL
[17:59:28.125]   ..$ rscript_envs    : NULL
[17:59:28.125]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:59:28.125]   ..$ rscript_startup : NULL
[17:59:28.125]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:59:28.125]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:59:28.125]   ..$ methods         : logi TRUE
[17:59:28.125]   ..$ socketOptions   : chr "no-delay"
[17:59:28.125]   ..$ useXDR          : logi FALSE
[17:59:28.125]   ..$ outfile         : chr "/dev/null"
[17:59:28.125]   ..$ renice          : int NA
[17:59:28.125]   ..$ rshcmd          : NULL
[17:59:28.125]   ..$ user            : NULL
[17:59:28.125]   ..$ revtunnel       : logi NA
[17:59:28.125]   ..$ rshlogfile      : NULL
[17:59:28.125]   ..$ rshopts         : NULL
[17:59:28.125]   ..$ rank            : int 1
[17:59:28.125]   ..$ manual          : logi FALSE
[17:59:28.125]   ..$ dryrun          : logi FALSE
[17:59:28.125]   ..$ quiet           : logi FALSE
[17:59:28.125]   ..$ setup_strategy  : chr "parallel"
[17:59:28.125]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:59:28.159] [local output] System call to launch all workers:
[17:59:28.159] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmp9ZPdri/worker.rank=1.parallelly.parent=307917.4b2cd6cc74584.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11554 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:59:28.160] [local output] Starting PSOCK main server
[17:59:28.168] [local output] Workers launched
[17:59:28.168] [local output] Waiting for workers to connect back
[17:59:28.168]  - [local output] 0 workers out of 2 ready
[17:59:28.530]  - [local output] 0 workers out of 2 ready
[17:59:28.531]  - [local output] 1 workers out of 2 ready
[17:59:28.543]  - [local output] 1 workers out of 2 ready
[17:59:28.543]  - [local output] 2 workers out of 2 ready
[17:59:28.543] [local output] Launching of workers completed
[17:59:28.544] [local output] Collecting session information from workers
[17:59:28.545] [local output]  - Worker #1 of 2
[17:59:28.546] [local output]  - Worker #2 of 2
[17:59:28.547] [local output] makeClusterPSOCK() ... done
[17:59:28.567] Packages needed by the future expression (n = 0): <none>
[17:59:28.567] Packages needed by future strategies (n = 0): <none>
[17:59:28.568] {
[17:59:28.568]     {
[17:59:28.568]         {
[17:59:28.568]             ...future.startTime <- base::Sys.time()
[17:59:28.568]             {
[17:59:28.568]                 {
[17:59:28.568]                   {
[17:59:28.568]                     {
[17:59:28.568]                       base::local({
[17:59:28.568]                         has_future <- base::requireNamespace("future", 
[17:59:28.568]                           quietly = TRUE)
[17:59:28.568]                         if (has_future) {
[17:59:28.568]                           ns <- base::getNamespace("future")
[17:59:28.568]                           version <- ns[[".package"]][["version"]]
[17:59:28.568]                           if (is.null(version)) 
[17:59:28.568]                             version <- utils::packageVersion("future")
[17:59:28.568]                         }
[17:59:28.568]                         else {
[17:59:28.568]                           version <- NULL
[17:59:28.568]                         }
[17:59:28.568]                         if (!has_future || version < "1.8.0") {
[17:59:28.568]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:28.568]                             "", base::R.version$version.string), 
[17:59:28.568]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:28.568]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:28.568]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:28.568]                               "release", "version")], collapse = " "), 
[17:59:28.568]                             hostname = base::Sys.info()[["nodename"]])
[17:59:28.568]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:28.568]                             info)
[17:59:28.568]                           info <- base::paste(info, collapse = "; ")
[17:59:28.568]                           if (!has_future) {
[17:59:28.568]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:28.568]                               info)
[17:59:28.568]                           }
[17:59:28.568]                           else {
[17:59:28.568]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:28.568]                               info, version)
[17:59:28.568]                           }
[17:59:28.568]                           base::stop(msg)
[17:59:28.568]                         }
[17:59:28.568]                       })
[17:59:28.568]                     }
[17:59:28.568]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:28.568]                     base::options(mc.cores = 1L)
[17:59:28.568]                   }
[17:59:28.568]                   ...future.strategy.old <- future::plan("list")
[17:59:28.568]                   options(future.plan = NULL)
[17:59:28.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:28.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:28.568]                 }
[17:59:28.568]                 ...future.workdir <- getwd()
[17:59:28.568]             }
[17:59:28.568]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:28.568]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:28.568]         }
[17:59:28.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:28.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:59:28.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:28.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:28.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:28.568]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:28.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:28.568]             base::names(...future.oldOptions))
[17:59:28.568]     }
[17:59:28.568]     if (FALSE) {
[17:59:28.568]     }
[17:59:28.568]     else {
[17:59:28.568]         if (TRUE) {
[17:59:28.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:28.568]                 open = "w")
[17:59:28.568]         }
[17:59:28.568]         else {
[17:59:28.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:28.568]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:28.568]         }
[17:59:28.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:28.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:28.568]             base::sink(type = "output", split = FALSE)
[17:59:28.568]             base::close(...future.stdout)
[17:59:28.568]         }, add = TRUE)
[17:59:28.568]     }
[17:59:28.568]     ...future.frame <- base::sys.nframe()
[17:59:28.568]     ...future.conditions <- base::list()
[17:59:28.568]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:28.568]     if (FALSE) {
[17:59:28.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:28.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:28.568]     }
[17:59:28.568]     ...future.result <- base::tryCatch({
[17:59:28.568]         base::withCallingHandlers({
[17:59:28.568]             ...future.value <- base::withVisible(base::local({
[17:59:28.568]                 ...future.makeSendCondition <- base::local({
[17:59:28.568]                   sendCondition <- NULL
[17:59:28.568]                   function(frame = 1L) {
[17:59:28.568]                     if (is.function(sendCondition)) 
[17:59:28.568]                       return(sendCondition)
[17:59:28.568]                     ns <- getNamespace("parallel")
[17:59:28.568]                     if (exists("sendData", mode = "function", 
[17:59:28.568]                       envir = ns)) {
[17:59:28.568]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:28.568]                         envir = ns)
[17:59:28.568]                       envir <- sys.frame(frame)
[17:59:28.568]                       master <- NULL
[17:59:28.568]                       while (!identical(envir, .GlobalEnv) && 
[17:59:28.568]                         !identical(envir, emptyenv())) {
[17:59:28.568]                         if (exists("master", mode = "list", envir = envir, 
[17:59:28.568]                           inherits = FALSE)) {
[17:59:28.568]                           master <- get("master", mode = "list", 
[17:59:28.568]                             envir = envir, inherits = FALSE)
[17:59:28.568]                           if (inherits(master, c("SOCKnode", 
[17:59:28.568]                             "SOCK0node"))) {
[17:59:28.568]                             sendCondition <<- function(cond) {
[17:59:28.568]                               data <- list(type = "VALUE", value = cond, 
[17:59:28.568]                                 success = TRUE)
[17:59:28.568]                               parallel_sendData(master, data)
[17:59:28.568]                             }
[17:59:28.568]                             return(sendCondition)
[17:59:28.568]                           }
[17:59:28.568]                         }
[17:59:28.568]                         frame <- frame + 1L
[17:59:28.568]                         envir <- sys.frame(frame)
[17:59:28.568]                       }
[17:59:28.568]                     }
[17:59:28.568]                     sendCondition <<- function(cond) NULL
[17:59:28.568]                   }
[17:59:28.568]                 })
[17:59:28.568]                 withCallingHandlers({
[17:59:28.568]                   NA
[17:59:28.568]                 }, immediateCondition = function(cond) {
[17:59:28.568]                   sendCondition <- ...future.makeSendCondition()
[17:59:28.568]                   sendCondition(cond)
[17:59:28.568]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.568]                   {
[17:59:28.568]                     inherits <- base::inherits
[17:59:28.568]                     invokeRestart <- base::invokeRestart
[17:59:28.568]                     is.null <- base::is.null
[17:59:28.568]                     muffled <- FALSE
[17:59:28.568]                     if (inherits(cond, "message")) {
[17:59:28.568]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:28.568]                       if (muffled) 
[17:59:28.568]                         invokeRestart("muffleMessage")
[17:59:28.568]                     }
[17:59:28.568]                     else if (inherits(cond, "warning")) {
[17:59:28.568]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:28.568]                       if (muffled) 
[17:59:28.568]                         invokeRestart("muffleWarning")
[17:59:28.568]                     }
[17:59:28.568]                     else if (inherits(cond, "condition")) {
[17:59:28.568]                       if (!is.null(pattern)) {
[17:59:28.568]                         computeRestarts <- base::computeRestarts
[17:59:28.568]                         grepl <- base::grepl
[17:59:28.568]                         restarts <- computeRestarts(cond)
[17:59:28.568]                         for (restart in restarts) {
[17:59:28.568]                           name <- restart$name
[17:59:28.568]                           if (is.null(name)) 
[17:59:28.568]                             next
[17:59:28.568]                           if (!grepl(pattern, name)) 
[17:59:28.568]                             next
[17:59:28.568]                           invokeRestart(restart)
[17:59:28.568]                           muffled <- TRUE
[17:59:28.568]                           break
[17:59:28.568]                         }
[17:59:28.568]                       }
[17:59:28.568]                     }
[17:59:28.568]                     invisible(muffled)
[17:59:28.568]                   }
[17:59:28.568]                   muffleCondition(cond)
[17:59:28.568]                 })
[17:59:28.568]             }))
[17:59:28.568]             future::FutureResult(value = ...future.value$value, 
[17:59:28.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:28.568]                   ...future.rng), globalenv = if (FALSE) 
[17:59:28.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:28.568]                     ...future.globalenv.names))
[17:59:28.568]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:28.568]         }, condition = base::local({
[17:59:28.568]             c <- base::c
[17:59:28.568]             inherits <- base::inherits
[17:59:28.568]             invokeRestart <- base::invokeRestart
[17:59:28.568]             length <- base::length
[17:59:28.568]             list <- base::list
[17:59:28.568]             seq.int <- base::seq.int
[17:59:28.568]             signalCondition <- base::signalCondition
[17:59:28.568]             sys.calls <- base::sys.calls
[17:59:28.568]             `[[` <- base::`[[`
[17:59:28.568]             `+` <- base::`+`
[17:59:28.568]             `<<-` <- base::`<<-`
[17:59:28.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:28.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:28.568]                   3L)]
[17:59:28.568]             }
[17:59:28.568]             function(cond) {
[17:59:28.568]                 is_error <- inherits(cond, "error")
[17:59:28.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:28.568]                   NULL)
[17:59:28.568]                 if (is_error) {
[17:59:28.568]                   sessionInformation <- function() {
[17:59:28.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:28.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:28.568]                       search = base::search(), system = base::Sys.info())
[17:59:28.568]                   }
[17:59:28.568]                   ...future.conditions[[length(...future.conditions) + 
[17:59:28.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:28.568]                     cond$call), session = sessionInformation(), 
[17:59:28.568]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:28.568]                   signalCondition(cond)
[17:59:28.568]                 }
[17:59:28.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:28.568]                 "immediateCondition"))) {
[17:59:28.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:28.568]                   ...future.conditions[[length(...future.conditions) + 
[17:59:28.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:28.568]                   if (TRUE && !signal) {
[17:59:28.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.568]                     {
[17:59:28.568]                       inherits <- base::inherits
[17:59:28.568]                       invokeRestart <- base::invokeRestart
[17:59:28.568]                       is.null <- base::is.null
[17:59:28.568]                       muffled <- FALSE
[17:59:28.568]                       if (inherits(cond, "message")) {
[17:59:28.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:28.568]                         if (muffled) 
[17:59:28.568]                           invokeRestart("muffleMessage")
[17:59:28.568]                       }
[17:59:28.568]                       else if (inherits(cond, "warning")) {
[17:59:28.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:28.568]                         if (muffled) 
[17:59:28.568]                           invokeRestart("muffleWarning")
[17:59:28.568]                       }
[17:59:28.568]                       else if (inherits(cond, "condition")) {
[17:59:28.568]                         if (!is.null(pattern)) {
[17:59:28.568]                           computeRestarts <- base::computeRestarts
[17:59:28.568]                           grepl <- base::grepl
[17:59:28.568]                           restarts <- computeRestarts(cond)
[17:59:28.568]                           for (restart in restarts) {
[17:59:28.568]                             name <- restart$name
[17:59:28.568]                             if (is.null(name)) 
[17:59:28.568]                               next
[17:59:28.568]                             if (!grepl(pattern, name)) 
[17:59:28.568]                               next
[17:59:28.568]                             invokeRestart(restart)
[17:59:28.568]                             muffled <- TRUE
[17:59:28.568]                             break
[17:59:28.568]                           }
[17:59:28.568]                         }
[17:59:28.568]                       }
[17:59:28.568]                       invisible(muffled)
[17:59:28.568]                     }
[17:59:28.568]                     muffleCondition(cond, pattern = "^muffle")
[17:59:28.568]                   }
[17:59:28.568]                 }
[17:59:28.568]                 else {
[17:59:28.568]                   if (TRUE) {
[17:59:28.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.568]                     {
[17:59:28.568]                       inherits <- base::inherits
[17:59:28.568]                       invokeRestart <- base::invokeRestart
[17:59:28.568]                       is.null <- base::is.null
[17:59:28.568]                       muffled <- FALSE
[17:59:28.568]                       if (inherits(cond, "message")) {
[17:59:28.568]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:28.568]                         if (muffled) 
[17:59:28.568]                           invokeRestart("muffleMessage")
[17:59:28.568]                       }
[17:59:28.568]                       else if (inherits(cond, "warning")) {
[17:59:28.568]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:28.568]                         if (muffled) 
[17:59:28.568]                           invokeRestart("muffleWarning")
[17:59:28.568]                       }
[17:59:28.568]                       else if (inherits(cond, "condition")) {
[17:59:28.568]                         if (!is.null(pattern)) {
[17:59:28.568]                           computeRestarts <- base::computeRestarts
[17:59:28.568]                           grepl <- base::grepl
[17:59:28.568]                           restarts <- computeRestarts(cond)
[17:59:28.568]                           for (restart in restarts) {
[17:59:28.568]                             name <- restart$name
[17:59:28.568]                             if (is.null(name)) 
[17:59:28.568]                               next
[17:59:28.568]                             if (!grepl(pattern, name)) 
[17:59:28.568]                               next
[17:59:28.568]                             invokeRestart(restart)
[17:59:28.568]                             muffled <- TRUE
[17:59:28.568]                             break
[17:59:28.568]                           }
[17:59:28.568]                         }
[17:59:28.568]                       }
[17:59:28.568]                       invisible(muffled)
[17:59:28.568]                     }
[17:59:28.568]                     muffleCondition(cond, pattern = "^muffle")
[17:59:28.568]                   }
[17:59:28.568]                 }
[17:59:28.568]             }
[17:59:28.568]         }))
[17:59:28.568]     }, error = function(ex) {
[17:59:28.568]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:28.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:28.568]                 ...future.rng), started = ...future.startTime, 
[17:59:28.568]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:28.568]             version = "1.8"), class = "FutureResult")
[17:59:28.568]     }, finally = {
[17:59:28.568]         if (!identical(...future.workdir, getwd())) 
[17:59:28.568]             setwd(...future.workdir)
[17:59:28.568]         {
[17:59:28.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:28.568]                 ...future.oldOptions$nwarnings <- NULL
[17:59:28.568]             }
[17:59:28.568]             base::options(...future.oldOptions)
[17:59:28.568]             if (.Platform$OS.type == "windows") {
[17:59:28.568]                 old_names <- names(...future.oldEnvVars)
[17:59:28.568]                 envs <- base::Sys.getenv()
[17:59:28.568]                 names <- names(envs)
[17:59:28.568]                 common <- intersect(names, old_names)
[17:59:28.568]                 added <- setdiff(names, old_names)
[17:59:28.568]                 removed <- setdiff(old_names, names)
[17:59:28.568]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:28.568]                   envs[common]]
[17:59:28.568]                 NAMES <- toupper(changed)
[17:59:28.568]                 args <- list()
[17:59:28.568]                 for (kk in seq_along(NAMES)) {
[17:59:28.568]                   name <- changed[[kk]]
[17:59:28.568]                   NAME <- NAMES[[kk]]
[17:59:28.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.568]                     next
[17:59:28.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:28.568]                 }
[17:59:28.568]                 NAMES <- toupper(added)
[17:59:28.568]                 for (kk in seq_along(NAMES)) {
[17:59:28.568]                   name <- added[[kk]]
[17:59:28.568]                   NAME <- NAMES[[kk]]
[17:59:28.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.568]                     next
[17:59:28.568]                   args[[name]] <- ""
[17:59:28.568]                 }
[17:59:28.568]                 NAMES <- toupper(removed)
[17:59:28.568]                 for (kk in seq_along(NAMES)) {
[17:59:28.568]                   name <- removed[[kk]]
[17:59:28.568]                   NAME <- NAMES[[kk]]
[17:59:28.568]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.568]                     next
[17:59:28.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:28.568]                 }
[17:59:28.568]                 if (length(args) > 0) 
[17:59:28.568]                   base::do.call(base::Sys.setenv, args = args)
[17:59:28.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:28.568]             }
[17:59:28.568]             else {
[17:59:28.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:28.568]             }
[17:59:28.568]             {
[17:59:28.568]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:28.568]                   0L) {
[17:59:28.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:28.568]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:28.568]                   base::options(opts)
[17:59:28.568]                 }
[17:59:28.568]                 {
[17:59:28.568]                   {
[17:59:28.568]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:28.568]                     NULL
[17:59:28.568]                   }
[17:59:28.568]                   options(future.plan = NULL)
[17:59:28.568]                   if (is.na(NA_character_)) 
[17:59:28.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:28.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:28.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:28.568]                     .init = FALSE)
[17:59:28.568]                 }
[17:59:28.568]             }
[17:59:28.568]         }
[17:59:28.568]     })
[17:59:28.568]     if (TRUE) {
[17:59:28.568]         base::sink(type = "output", split = FALSE)
[17:59:28.568]         if (TRUE) {
[17:59:28.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:28.568]         }
[17:59:28.568]         else {
[17:59:28.568]             ...future.result["stdout"] <- base::list(NULL)
[17:59:28.568]         }
[17:59:28.568]         base::close(...future.stdout)
[17:59:28.568]         ...future.stdout <- NULL
[17:59:28.568]     }
[17:59:28.568]     ...future.result$conditions <- ...future.conditions
[17:59:28.568]     ...future.result$finished <- base::Sys.time()
[17:59:28.568]     ...future.result
[17:59:28.568] }
[17:59:28.670] MultisessionFuture started
[17:59:28.671] result() for ClusterFuture ...
[17:59:28.671] receiveMessageFromWorker() for ClusterFuture ...
[17:59:28.672] - Validating connection of MultisessionFuture
[17:59:28.734] - received message: FutureResult
[17:59:28.734] - Received FutureResult
[17:59:28.735] - Erased future from FutureRegistry
[17:59:28.735] result() for ClusterFuture ...
[17:59:28.735] - result already collected: FutureResult
[17:59:28.736] result() for ClusterFuture ... done
[17:59:28.736] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:28.736] result() for ClusterFuture ... done
[17:59:28.737] result() for ClusterFuture ...
[17:59:28.737] - result already collected: FutureResult
[17:59:28.738] result() for ClusterFuture ... done
[17:59:28.738] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:59:28.746] plan(): nbrOfWorkers() = 2
[17:59:28.746] future_by_internal() ...
[17:59:28.748] future_lapply() ...
[17:59:28.756] Number of chunks: 2
[17:59:28.757] getGlobalsAndPackagesXApply() ...
[17:59:28.757]  - future.globals: TRUE
[17:59:28.757] getGlobalsAndPackages() ...
[17:59:28.758] Searching for globals...
[17:59:28.761] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:28.762] Searching for globals ... DONE
[17:59:28.762] Resolving globals: FALSE
[17:59:28.763] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:28.764] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:28.764] - globals: [1] ‘FUN’
[17:59:28.765] 
[17:59:28.765] getGlobalsAndPackages() ... DONE
[17:59:28.765]  - globals found/used: [n=1] ‘FUN’
[17:59:28.766]  - needed namespaces: [n=0] 
[17:59:28.766] Finding globals ... DONE
[17:59:28.766]  - use_args: TRUE
[17:59:28.767]  - Getting '...' globals ...
[17:59:28.768] resolve() on list ...
[17:59:28.768]  recursive: 0
[17:59:28.768]  length: 1
[17:59:28.768]  elements: ‘...’
[17:59:28.769]  length: 0 (resolved future 1)
[17:59:28.769] resolve() on list ... DONE
[17:59:28.770]    - '...' content: [n=0] 
[17:59:28.770] List of 1
[17:59:28.770]  $ ...: list()
[17:59:28.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:28.770]  - attr(*, "where")=List of 1
[17:59:28.770]   ..$ ...:<environment: 0x6264a11d77d0> 
[17:59:28.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:28.770]  - attr(*, "resolved")= logi TRUE
[17:59:28.770]  - attr(*, "total_size")= num NA
[17:59:28.778]  - Getting '...' globals ... DONE
[17:59:28.779] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:28.779] List of 2
[17:59:28.779]  $ ...future.FUN:function (object, ...)  
[17:59:28.779]  $ ...          : list()
[17:59:28.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:28.779]  - attr(*, "where")=List of 2
[17:59:28.779]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:28.779]   ..$ ...          :<environment: 0x6264a11d77d0> 
[17:59:28.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:28.779]  - attr(*, "resolved")= logi FALSE
[17:59:28.779]  - attr(*, "total_size")= num 1240
[17:59:28.788] Packages to be attached in all futures: [n=0] 
[17:59:28.789] getGlobalsAndPackagesXApply() ... DONE
[17:59:28.789] Number of futures (= number of chunks): 2
[17:59:28.790] Launching 2 futures (chunks) ...
[17:59:28.790] Chunk #1 of 2 ...
[17:59:28.790]  - Finding globals in 'X' for chunk #1 ...
[17:59:28.791] getGlobalsAndPackages() ...
[17:59:28.791] Searching for globals...
[17:59:28.792] 
[17:59:28.793] Searching for globals ... DONE
[17:59:28.793] - globals: [0] <none>
[17:59:28.793] getGlobalsAndPackages() ... DONE
[17:59:28.793]    + additional globals found: [n=0] 
[17:59:28.794]    + additional namespaces needed: [n=0] 
[17:59:28.794]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:28.794]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:28.795]  - seeds: <none>
[17:59:28.795]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:28.795] getGlobalsAndPackages() ...
[17:59:28.796] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:28.796] Resolving globals: FALSE
[17:59:28.796] Tweak future expression to call with '...' arguments ...
[17:59:28.797] {
[17:59:28.797]     do.call(function(...) {
[17:59:28.797]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:28.797]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:28.797]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:28.797]             on.exit(options(oopts), add = TRUE)
[17:59:28.797]         }
[17:59:28.797]         {
[17:59:28.797]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:28.797]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:28.797]                 ...future.FUN(...future.X_jj, ...)
[17:59:28.797]             })
[17:59:28.797]         }
[17:59:28.797]     }, args = future.call.arguments)
[17:59:28.797] }
[17:59:28.798] Tweak future expression to call with '...' arguments ... DONE
[17:59:28.799] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:28.799] 
[17:59:28.799] getGlobalsAndPackages() ... DONE
[17:59:28.800] run() for ‘Future’ ...
[17:59:28.800] - state: ‘created’
[17:59:28.801] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:28.830] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:28.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:28.831]   - Field: ‘node’
[17:59:28.831]   - Field: ‘label’
[17:59:28.831]   - Field: ‘local’
[17:59:28.831]   - Field: ‘owner’
[17:59:28.832]   - Field: ‘envir’
[17:59:28.832]   - Field: ‘workers’
[17:59:28.832]   - Field: ‘packages’
[17:59:28.832]   - Field: ‘gc’
[17:59:28.833]   - Field: ‘conditions’
[17:59:28.833]   - Field: ‘persistent’
[17:59:28.833]   - Field: ‘expr’
[17:59:28.833]   - Field: ‘uuid’
[17:59:28.834]   - Field: ‘seed’
[17:59:28.834]   - Field: ‘version’
[17:59:28.834]   - Field: ‘result’
[17:59:28.834]   - Field: ‘asynchronous’
[17:59:28.835]   - Field: ‘calls’
[17:59:28.835]   - Field: ‘globals’
[17:59:28.835]   - Field: ‘stdout’
[17:59:28.836]   - Field: ‘earlySignal’
[17:59:28.836]   - Field: ‘lazy’
[17:59:28.836]   - Field: ‘state’
[17:59:28.836] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:28.837] - Launch lazy future ...
[17:59:28.838] Packages needed by the future expression (n = 0): <none>
[17:59:28.838] Packages needed by future strategies (n = 0): <none>
[17:59:28.839] {
[17:59:28.839]     {
[17:59:28.839]         {
[17:59:28.839]             ...future.startTime <- base::Sys.time()
[17:59:28.839]             {
[17:59:28.839]                 {
[17:59:28.839]                   {
[17:59:28.839]                     {
[17:59:28.839]                       base::local({
[17:59:28.839]                         has_future <- base::requireNamespace("future", 
[17:59:28.839]                           quietly = TRUE)
[17:59:28.839]                         if (has_future) {
[17:59:28.839]                           ns <- base::getNamespace("future")
[17:59:28.839]                           version <- ns[[".package"]][["version"]]
[17:59:28.839]                           if (is.null(version)) 
[17:59:28.839]                             version <- utils::packageVersion("future")
[17:59:28.839]                         }
[17:59:28.839]                         else {
[17:59:28.839]                           version <- NULL
[17:59:28.839]                         }
[17:59:28.839]                         if (!has_future || version < "1.8.0") {
[17:59:28.839]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:28.839]                             "", base::R.version$version.string), 
[17:59:28.839]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:28.839]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:28.839]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:28.839]                               "release", "version")], collapse = " "), 
[17:59:28.839]                             hostname = base::Sys.info()[["nodename"]])
[17:59:28.839]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:28.839]                             info)
[17:59:28.839]                           info <- base::paste(info, collapse = "; ")
[17:59:28.839]                           if (!has_future) {
[17:59:28.839]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:28.839]                               info)
[17:59:28.839]                           }
[17:59:28.839]                           else {
[17:59:28.839]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:28.839]                               info, version)
[17:59:28.839]                           }
[17:59:28.839]                           base::stop(msg)
[17:59:28.839]                         }
[17:59:28.839]                       })
[17:59:28.839]                     }
[17:59:28.839]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:28.839]                     base::options(mc.cores = 1L)
[17:59:28.839]                   }
[17:59:28.839]                   ...future.strategy.old <- future::plan("list")
[17:59:28.839]                   options(future.plan = NULL)
[17:59:28.839]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:28.839]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:28.839]                 }
[17:59:28.839]                 ...future.workdir <- getwd()
[17:59:28.839]             }
[17:59:28.839]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:28.839]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:28.839]         }
[17:59:28.839]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:28.839]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:28.839]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:28.839]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:28.839]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:28.839]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:28.839]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:28.839]             base::names(...future.oldOptions))
[17:59:28.839]     }
[17:59:28.839]     if (FALSE) {
[17:59:28.839]     }
[17:59:28.839]     else {
[17:59:28.839]         if (TRUE) {
[17:59:28.839]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:28.839]                 open = "w")
[17:59:28.839]         }
[17:59:28.839]         else {
[17:59:28.839]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:28.839]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:28.839]         }
[17:59:28.839]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:28.839]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:28.839]             base::sink(type = "output", split = FALSE)
[17:59:28.839]             base::close(...future.stdout)
[17:59:28.839]         }, add = TRUE)
[17:59:28.839]     }
[17:59:28.839]     ...future.frame <- base::sys.nframe()
[17:59:28.839]     ...future.conditions <- base::list()
[17:59:28.839]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:28.839]     if (FALSE) {
[17:59:28.839]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:28.839]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:28.839]     }
[17:59:28.839]     ...future.result <- base::tryCatch({
[17:59:28.839]         base::withCallingHandlers({
[17:59:28.839]             ...future.value <- base::withVisible(base::local({
[17:59:28.839]                 ...future.makeSendCondition <- base::local({
[17:59:28.839]                   sendCondition <- NULL
[17:59:28.839]                   function(frame = 1L) {
[17:59:28.839]                     if (is.function(sendCondition)) 
[17:59:28.839]                       return(sendCondition)
[17:59:28.839]                     ns <- getNamespace("parallel")
[17:59:28.839]                     if (exists("sendData", mode = "function", 
[17:59:28.839]                       envir = ns)) {
[17:59:28.839]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:28.839]                         envir = ns)
[17:59:28.839]                       envir <- sys.frame(frame)
[17:59:28.839]                       master <- NULL
[17:59:28.839]                       while (!identical(envir, .GlobalEnv) && 
[17:59:28.839]                         !identical(envir, emptyenv())) {
[17:59:28.839]                         if (exists("master", mode = "list", envir = envir, 
[17:59:28.839]                           inherits = FALSE)) {
[17:59:28.839]                           master <- get("master", mode = "list", 
[17:59:28.839]                             envir = envir, inherits = FALSE)
[17:59:28.839]                           if (inherits(master, c("SOCKnode", 
[17:59:28.839]                             "SOCK0node"))) {
[17:59:28.839]                             sendCondition <<- function(cond) {
[17:59:28.839]                               data <- list(type = "VALUE", value = cond, 
[17:59:28.839]                                 success = TRUE)
[17:59:28.839]                               parallel_sendData(master, data)
[17:59:28.839]                             }
[17:59:28.839]                             return(sendCondition)
[17:59:28.839]                           }
[17:59:28.839]                         }
[17:59:28.839]                         frame <- frame + 1L
[17:59:28.839]                         envir <- sys.frame(frame)
[17:59:28.839]                       }
[17:59:28.839]                     }
[17:59:28.839]                     sendCondition <<- function(cond) NULL
[17:59:28.839]                   }
[17:59:28.839]                 })
[17:59:28.839]                 withCallingHandlers({
[17:59:28.839]                   {
[17:59:28.839]                     do.call(function(...) {
[17:59:28.839]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:28.839]                       if (!identical(...future.globals.maxSize.org, 
[17:59:28.839]                         ...future.globals.maxSize)) {
[17:59:28.839]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:28.839]                         on.exit(options(oopts), add = TRUE)
[17:59:28.839]                       }
[17:59:28.839]                       {
[17:59:28.839]                         lapply(seq_along(...future.elements_ii), 
[17:59:28.839]                           FUN = function(jj) {
[17:59:28.839]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:28.839]                             ...future.FUN(...future.X_jj, ...)
[17:59:28.839]                           })
[17:59:28.839]                       }
[17:59:28.839]                     }, args = future.call.arguments)
[17:59:28.839]                   }
[17:59:28.839]                 }, immediateCondition = function(cond) {
[17:59:28.839]                   sendCondition <- ...future.makeSendCondition()
[17:59:28.839]                   sendCondition(cond)
[17:59:28.839]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.839]                   {
[17:59:28.839]                     inherits <- base::inherits
[17:59:28.839]                     invokeRestart <- base::invokeRestart
[17:59:28.839]                     is.null <- base::is.null
[17:59:28.839]                     muffled <- FALSE
[17:59:28.839]                     if (inherits(cond, "message")) {
[17:59:28.839]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:28.839]                       if (muffled) 
[17:59:28.839]                         invokeRestart("muffleMessage")
[17:59:28.839]                     }
[17:59:28.839]                     else if (inherits(cond, "warning")) {
[17:59:28.839]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:28.839]                       if (muffled) 
[17:59:28.839]                         invokeRestart("muffleWarning")
[17:59:28.839]                     }
[17:59:28.839]                     else if (inherits(cond, "condition")) {
[17:59:28.839]                       if (!is.null(pattern)) {
[17:59:28.839]                         computeRestarts <- base::computeRestarts
[17:59:28.839]                         grepl <- base::grepl
[17:59:28.839]                         restarts <- computeRestarts(cond)
[17:59:28.839]                         for (restart in restarts) {
[17:59:28.839]                           name <- restart$name
[17:59:28.839]                           if (is.null(name)) 
[17:59:28.839]                             next
[17:59:28.839]                           if (!grepl(pattern, name)) 
[17:59:28.839]                             next
[17:59:28.839]                           invokeRestart(restart)
[17:59:28.839]                           muffled <- TRUE
[17:59:28.839]                           break
[17:59:28.839]                         }
[17:59:28.839]                       }
[17:59:28.839]                     }
[17:59:28.839]                     invisible(muffled)
[17:59:28.839]                   }
[17:59:28.839]                   muffleCondition(cond)
[17:59:28.839]                 })
[17:59:28.839]             }))
[17:59:28.839]             future::FutureResult(value = ...future.value$value, 
[17:59:28.839]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:28.839]                   ...future.rng), globalenv = if (FALSE) 
[17:59:28.839]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:28.839]                     ...future.globalenv.names))
[17:59:28.839]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:28.839]         }, condition = base::local({
[17:59:28.839]             c <- base::c
[17:59:28.839]             inherits <- base::inherits
[17:59:28.839]             invokeRestart <- base::invokeRestart
[17:59:28.839]             length <- base::length
[17:59:28.839]             list <- base::list
[17:59:28.839]             seq.int <- base::seq.int
[17:59:28.839]             signalCondition <- base::signalCondition
[17:59:28.839]             sys.calls <- base::sys.calls
[17:59:28.839]             `[[` <- base::`[[`
[17:59:28.839]             `+` <- base::`+`
[17:59:28.839]             `<<-` <- base::`<<-`
[17:59:28.839]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:28.839]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:28.839]                   3L)]
[17:59:28.839]             }
[17:59:28.839]             function(cond) {
[17:59:28.839]                 is_error <- inherits(cond, "error")
[17:59:28.839]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:28.839]                   NULL)
[17:59:28.839]                 if (is_error) {
[17:59:28.839]                   sessionInformation <- function() {
[17:59:28.839]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:28.839]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:28.839]                       search = base::search(), system = base::Sys.info())
[17:59:28.839]                   }
[17:59:28.839]                   ...future.conditions[[length(...future.conditions) + 
[17:59:28.839]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:28.839]                     cond$call), session = sessionInformation(), 
[17:59:28.839]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:28.839]                   signalCondition(cond)
[17:59:28.839]                 }
[17:59:28.839]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:28.839]                 "immediateCondition"))) {
[17:59:28.839]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:28.839]                   ...future.conditions[[length(...future.conditions) + 
[17:59:28.839]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:28.839]                   if (TRUE && !signal) {
[17:59:28.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.839]                     {
[17:59:28.839]                       inherits <- base::inherits
[17:59:28.839]                       invokeRestart <- base::invokeRestart
[17:59:28.839]                       is.null <- base::is.null
[17:59:28.839]                       muffled <- FALSE
[17:59:28.839]                       if (inherits(cond, "message")) {
[17:59:28.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:28.839]                         if (muffled) 
[17:59:28.839]                           invokeRestart("muffleMessage")
[17:59:28.839]                       }
[17:59:28.839]                       else if (inherits(cond, "warning")) {
[17:59:28.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:28.839]                         if (muffled) 
[17:59:28.839]                           invokeRestart("muffleWarning")
[17:59:28.839]                       }
[17:59:28.839]                       else if (inherits(cond, "condition")) {
[17:59:28.839]                         if (!is.null(pattern)) {
[17:59:28.839]                           computeRestarts <- base::computeRestarts
[17:59:28.839]                           grepl <- base::grepl
[17:59:28.839]                           restarts <- computeRestarts(cond)
[17:59:28.839]                           for (restart in restarts) {
[17:59:28.839]                             name <- restart$name
[17:59:28.839]                             if (is.null(name)) 
[17:59:28.839]                               next
[17:59:28.839]                             if (!grepl(pattern, name)) 
[17:59:28.839]                               next
[17:59:28.839]                             invokeRestart(restart)
[17:59:28.839]                             muffled <- TRUE
[17:59:28.839]                             break
[17:59:28.839]                           }
[17:59:28.839]                         }
[17:59:28.839]                       }
[17:59:28.839]                       invisible(muffled)
[17:59:28.839]                     }
[17:59:28.839]                     muffleCondition(cond, pattern = "^muffle")
[17:59:28.839]                   }
[17:59:28.839]                 }
[17:59:28.839]                 else {
[17:59:28.839]                   if (TRUE) {
[17:59:28.839]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.839]                     {
[17:59:28.839]                       inherits <- base::inherits
[17:59:28.839]                       invokeRestart <- base::invokeRestart
[17:59:28.839]                       is.null <- base::is.null
[17:59:28.839]                       muffled <- FALSE
[17:59:28.839]                       if (inherits(cond, "message")) {
[17:59:28.839]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:28.839]                         if (muffled) 
[17:59:28.839]                           invokeRestart("muffleMessage")
[17:59:28.839]                       }
[17:59:28.839]                       else if (inherits(cond, "warning")) {
[17:59:28.839]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:28.839]                         if (muffled) 
[17:59:28.839]                           invokeRestart("muffleWarning")
[17:59:28.839]                       }
[17:59:28.839]                       else if (inherits(cond, "condition")) {
[17:59:28.839]                         if (!is.null(pattern)) {
[17:59:28.839]                           computeRestarts <- base::computeRestarts
[17:59:28.839]                           grepl <- base::grepl
[17:59:28.839]                           restarts <- computeRestarts(cond)
[17:59:28.839]                           for (restart in restarts) {
[17:59:28.839]                             name <- restart$name
[17:59:28.839]                             if (is.null(name)) 
[17:59:28.839]                               next
[17:59:28.839]                             if (!grepl(pattern, name)) 
[17:59:28.839]                               next
[17:59:28.839]                             invokeRestart(restart)
[17:59:28.839]                             muffled <- TRUE
[17:59:28.839]                             break
[17:59:28.839]                           }
[17:59:28.839]                         }
[17:59:28.839]                       }
[17:59:28.839]                       invisible(muffled)
[17:59:28.839]                     }
[17:59:28.839]                     muffleCondition(cond, pattern = "^muffle")
[17:59:28.839]                   }
[17:59:28.839]                 }
[17:59:28.839]             }
[17:59:28.839]         }))
[17:59:28.839]     }, error = function(ex) {
[17:59:28.839]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:28.839]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:28.839]                 ...future.rng), started = ...future.startTime, 
[17:59:28.839]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:28.839]             version = "1.8"), class = "FutureResult")
[17:59:28.839]     }, finally = {
[17:59:28.839]         if (!identical(...future.workdir, getwd())) 
[17:59:28.839]             setwd(...future.workdir)
[17:59:28.839]         {
[17:59:28.839]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:28.839]                 ...future.oldOptions$nwarnings <- NULL
[17:59:28.839]             }
[17:59:28.839]             base::options(...future.oldOptions)
[17:59:28.839]             if (.Platform$OS.type == "windows") {
[17:59:28.839]                 old_names <- names(...future.oldEnvVars)
[17:59:28.839]                 envs <- base::Sys.getenv()
[17:59:28.839]                 names <- names(envs)
[17:59:28.839]                 common <- intersect(names, old_names)
[17:59:28.839]                 added <- setdiff(names, old_names)
[17:59:28.839]                 removed <- setdiff(old_names, names)
[17:59:28.839]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:28.839]                   envs[common]]
[17:59:28.839]                 NAMES <- toupper(changed)
[17:59:28.839]                 args <- list()
[17:59:28.839]                 for (kk in seq_along(NAMES)) {
[17:59:28.839]                   name <- changed[[kk]]
[17:59:28.839]                   NAME <- NAMES[[kk]]
[17:59:28.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.839]                     next
[17:59:28.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:28.839]                 }
[17:59:28.839]                 NAMES <- toupper(added)
[17:59:28.839]                 for (kk in seq_along(NAMES)) {
[17:59:28.839]                   name <- added[[kk]]
[17:59:28.839]                   NAME <- NAMES[[kk]]
[17:59:28.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.839]                     next
[17:59:28.839]                   args[[name]] <- ""
[17:59:28.839]                 }
[17:59:28.839]                 NAMES <- toupper(removed)
[17:59:28.839]                 for (kk in seq_along(NAMES)) {
[17:59:28.839]                   name <- removed[[kk]]
[17:59:28.839]                   NAME <- NAMES[[kk]]
[17:59:28.839]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.839]                     next
[17:59:28.839]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:28.839]                 }
[17:59:28.839]                 if (length(args) > 0) 
[17:59:28.839]                   base::do.call(base::Sys.setenv, args = args)
[17:59:28.839]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:28.839]             }
[17:59:28.839]             else {
[17:59:28.839]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:28.839]             }
[17:59:28.839]             {
[17:59:28.839]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:28.839]                   0L) {
[17:59:28.839]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:28.839]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:28.839]                   base::options(opts)
[17:59:28.839]                 }
[17:59:28.839]                 {
[17:59:28.839]                   {
[17:59:28.839]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:28.839]                     NULL
[17:59:28.839]                   }
[17:59:28.839]                   options(future.plan = NULL)
[17:59:28.839]                   if (is.na(NA_character_)) 
[17:59:28.839]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:28.839]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:28.839]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:28.839]                     .init = FALSE)
[17:59:28.839]                 }
[17:59:28.839]             }
[17:59:28.839]         }
[17:59:28.839]     })
[17:59:28.839]     if (TRUE) {
[17:59:28.839]         base::sink(type = "output", split = FALSE)
[17:59:28.839]         if (TRUE) {
[17:59:28.839]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:28.839]         }
[17:59:28.839]         else {
[17:59:28.839]             ...future.result["stdout"] <- base::list(NULL)
[17:59:28.839]         }
[17:59:28.839]         base::close(...future.stdout)
[17:59:28.839]         ...future.stdout <- NULL
[17:59:28.839]     }
[17:59:28.839]     ...future.result$conditions <- ...future.conditions
[17:59:28.839]     ...future.result$finished <- base::Sys.time()
[17:59:28.839]     ...future.result
[17:59:28.839] }
[17:59:28.846] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:59:28.846] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:59:28.847] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:59:28.848] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:28.849] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:28.850] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[17:59:28.851] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[17:59:28.851] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:28.852] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:28.853] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:28.854] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:28.854] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:59:28.856] MultisessionFuture started
[17:59:28.856] - Launch lazy future ... done
[17:59:28.857] run() for ‘MultisessionFuture’ ... done
[17:59:28.857] Created future:
[17:59:28.857] MultisessionFuture:
[17:59:28.857] Label: ‘future_by-1’
[17:59:28.857] Expression:
[17:59:28.857] {
[17:59:28.857]     do.call(function(...) {
[17:59:28.857]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:28.857]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:28.857]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:28.857]             on.exit(options(oopts), add = TRUE)
[17:59:28.857]         }
[17:59:28.857]         {
[17:59:28.857]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:28.857]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:28.857]                 ...future.FUN(...future.X_jj, ...)
[17:59:28.857]             })
[17:59:28.857]         }
[17:59:28.857]     }, args = future.call.arguments)
[17:59:28.857] }
[17:59:28.857] Lazy evaluation: FALSE
[17:59:28.857] Asynchronous evaluation: TRUE
[17:59:28.857] Local evaluation: TRUE
[17:59:28.857] Environment: R_GlobalEnv
[17:59:28.857] Capture standard output: TRUE
[17:59:28.857] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:28.857] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:28.857] Packages: <none>
[17:59:28.857] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:28.857] Resolved: FALSE
[17:59:28.857] Value: <not collected>
[17:59:28.857] Conditions captured: <none>
[17:59:28.857] Early signaling: FALSE
[17:59:28.857] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:28.857] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:28.872] Chunk #1 of 2 ... DONE
[17:59:28.872] Chunk #2 of 2 ...
[17:59:28.873]  - Finding globals in 'X' for chunk #2 ...
[17:59:28.873] getGlobalsAndPackages() ...
[17:59:28.873] Searching for globals...
[17:59:28.874] 
[17:59:28.874] Searching for globals ... DONE
[17:59:28.875] - globals: [0] <none>
[17:59:28.875] getGlobalsAndPackages() ... DONE
[17:59:28.875]    + additional globals found: [n=0] 
[17:59:28.875]    + additional namespaces needed: [n=0] 
[17:59:28.876]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:28.876]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:28.876]  - seeds: <none>
[17:59:28.876]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:28.877] getGlobalsAndPackages() ...
[17:59:28.877] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:28.877] Resolving globals: FALSE
[17:59:28.877] Tweak future expression to call with '...' arguments ...
[17:59:28.878] {
[17:59:28.878]     do.call(function(...) {
[17:59:28.878]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:28.878]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:28.878]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:28.878]             on.exit(options(oopts), add = TRUE)
[17:59:28.878]         }
[17:59:28.878]         {
[17:59:28.878]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:28.878]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:28.878]                 ...future.FUN(...future.X_jj, ...)
[17:59:28.878]             })
[17:59:28.878]         }
[17:59:28.878]     }, args = future.call.arguments)
[17:59:28.878] }
[17:59:28.878] Tweak future expression to call with '...' arguments ... DONE
[17:59:28.879] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:28.880] 
[17:59:28.880] getGlobalsAndPackages() ... DONE
[17:59:28.880] run() for ‘Future’ ...
[17:59:28.881] - state: ‘created’
[17:59:28.881] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:28.915] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:28.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:28.916]   - Field: ‘node’
[17:59:28.916]   - Field: ‘label’
[17:59:28.916]   - Field: ‘local’
[17:59:28.916]   - Field: ‘owner’
[17:59:28.916]   - Field: ‘envir’
[17:59:28.917]   - Field: ‘workers’
[17:59:28.917]   - Field: ‘packages’
[17:59:28.917]   - Field: ‘gc’
[17:59:28.917]   - Field: ‘conditions’
[17:59:28.918]   - Field: ‘persistent’
[17:59:28.918]   - Field: ‘expr’
[17:59:28.918]   - Field: ‘uuid’
[17:59:28.918]   - Field: ‘seed’
[17:59:28.919]   - Field: ‘version’
[17:59:28.919]   - Field: ‘result’
[17:59:28.919]   - Field: ‘asynchronous’
[17:59:28.919]   - Field: ‘calls’
[17:59:28.920]   - Field: ‘globals’
[17:59:28.920]   - Field: ‘stdout’
[17:59:28.920]   - Field: ‘earlySignal’
[17:59:28.920]   - Field: ‘lazy’
[17:59:28.921]   - Field: ‘state’
[17:59:28.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:28.921] - Launch lazy future ...
[17:59:28.922] Packages needed by the future expression (n = 0): <none>
[17:59:28.922] Packages needed by future strategies (n = 0): <none>
[17:59:28.923] {
[17:59:28.923]     {
[17:59:28.923]         {
[17:59:28.923]             ...future.startTime <- base::Sys.time()
[17:59:28.923]             {
[17:59:28.923]                 {
[17:59:28.923]                   {
[17:59:28.923]                     {
[17:59:28.923]                       base::local({
[17:59:28.923]                         has_future <- base::requireNamespace("future", 
[17:59:28.923]                           quietly = TRUE)
[17:59:28.923]                         if (has_future) {
[17:59:28.923]                           ns <- base::getNamespace("future")
[17:59:28.923]                           version <- ns[[".package"]][["version"]]
[17:59:28.923]                           if (is.null(version)) 
[17:59:28.923]                             version <- utils::packageVersion("future")
[17:59:28.923]                         }
[17:59:28.923]                         else {
[17:59:28.923]                           version <- NULL
[17:59:28.923]                         }
[17:59:28.923]                         if (!has_future || version < "1.8.0") {
[17:59:28.923]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:28.923]                             "", base::R.version$version.string), 
[17:59:28.923]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:28.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:28.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:28.923]                               "release", "version")], collapse = " "), 
[17:59:28.923]                             hostname = base::Sys.info()[["nodename"]])
[17:59:28.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:28.923]                             info)
[17:59:28.923]                           info <- base::paste(info, collapse = "; ")
[17:59:28.923]                           if (!has_future) {
[17:59:28.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:28.923]                               info)
[17:59:28.923]                           }
[17:59:28.923]                           else {
[17:59:28.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:28.923]                               info, version)
[17:59:28.923]                           }
[17:59:28.923]                           base::stop(msg)
[17:59:28.923]                         }
[17:59:28.923]                       })
[17:59:28.923]                     }
[17:59:28.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:28.923]                     base::options(mc.cores = 1L)
[17:59:28.923]                   }
[17:59:28.923]                   ...future.strategy.old <- future::plan("list")
[17:59:28.923]                   options(future.plan = NULL)
[17:59:28.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:28.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:28.923]                 }
[17:59:28.923]                 ...future.workdir <- getwd()
[17:59:28.923]             }
[17:59:28.923]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:28.923]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:28.923]         }
[17:59:28.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:28.923]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:28.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:28.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:28.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:28.923]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:28.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:28.923]             base::names(...future.oldOptions))
[17:59:28.923]     }
[17:59:28.923]     if (FALSE) {
[17:59:28.923]     }
[17:59:28.923]     else {
[17:59:28.923]         if (TRUE) {
[17:59:28.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:28.923]                 open = "w")
[17:59:28.923]         }
[17:59:28.923]         else {
[17:59:28.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:28.923]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:28.923]         }
[17:59:28.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:28.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:28.923]             base::sink(type = "output", split = FALSE)
[17:59:28.923]             base::close(...future.stdout)
[17:59:28.923]         }, add = TRUE)
[17:59:28.923]     }
[17:59:28.923]     ...future.frame <- base::sys.nframe()
[17:59:28.923]     ...future.conditions <- base::list()
[17:59:28.923]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:28.923]     if (FALSE) {
[17:59:28.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:28.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:28.923]     }
[17:59:28.923]     ...future.result <- base::tryCatch({
[17:59:28.923]         base::withCallingHandlers({
[17:59:28.923]             ...future.value <- base::withVisible(base::local({
[17:59:28.923]                 ...future.makeSendCondition <- base::local({
[17:59:28.923]                   sendCondition <- NULL
[17:59:28.923]                   function(frame = 1L) {
[17:59:28.923]                     if (is.function(sendCondition)) 
[17:59:28.923]                       return(sendCondition)
[17:59:28.923]                     ns <- getNamespace("parallel")
[17:59:28.923]                     if (exists("sendData", mode = "function", 
[17:59:28.923]                       envir = ns)) {
[17:59:28.923]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:28.923]                         envir = ns)
[17:59:28.923]                       envir <- sys.frame(frame)
[17:59:28.923]                       master <- NULL
[17:59:28.923]                       while (!identical(envir, .GlobalEnv) && 
[17:59:28.923]                         !identical(envir, emptyenv())) {
[17:59:28.923]                         if (exists("master", mode = "list", envir = envir, 
[17:59:28.923]                           inherits = FALSE)) {
[17:59:28.923]                           master <- get("master", mode = "list", 
[17:59:28.923]                             envir = envir, inherits = FALSE)
[17:59:28.923]                           if (inherits(master, c("SOCKnode", 
[17:59:28.923]                             "SOCK0node"))) {
[17:59:28.923]                             sendCondition <<- function(cond) {
[17:59:28.923]                               data <- list(type = "VALUE", value = cond, 
[17:59:28.923]                                 success = TRUE)
[17:59:28.923]                               parallel_sendData(master, data)
[17:59:28.923]                             }
[17:59:28.923]                             return(sendCondition)
[17:59:28.923]                           }
[17:59:28.923]                         }
[17:59:28.923]                         frame <- frame + 1L
[17:59:28.923]                         envir <- sys.frame(frame)
[17:59:28.923]                       }
[17:59:28.923]                     }
[17:59:28.923]                     sendCondition <<- function(cond) NULL
[17:59:28.923]                   }
[17:59:28.923]                 })
[17:59:28.923]                 withCallingHandlers({
[17:59:28.923]                   {
[17:59:28.923]                     do.call(function(...) {
[17:59:28.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:28.923]                       if (!identical(...future.globals.maxSize.org, 
[17:59:28.923]                         ...future.globals.maxSize)) {
[17:59:28.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:28.923]                         on.exit(options(oopts), add = TRUE)
[17:59:28.923]                       }
[17:59:28.923]                       {
[17:59:28.923]                         lapply(seq_along(...future.elements_ii), 
[17:59:28.923]                           FUN = function(jj) {
[17:59:28.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:28.923]                             ...future.FUN(...future.X_jj, ...)
[17:59:28.923]                           })
[17:59:28.923]                       }
[17:59:28.923]                     }, args = future.call.arguments)
[17:59:28.923]                   }
[17:59:28.923]                 }, immediateCondition = function(cond) {
[17:59:28.923]                   sendCondition <- ...future.makeSendCondition()
[17:59:28.923]                   sendCondition(cond)
[17:59:28.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.923]                   {
[17:59:28.923]                     inherits <- base::inherits
[17:59:28.923]                     invokeRestart <- base::invokeRestart
[17:59:28.923]                     is.null <- base::is.null
[17:59:28.923]                     muffled <- FALSE
[17:59:28.923]                     if (inherits(cond, "message")) {
[17:59:28.923]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:28.923]                       if (muffled) 
[17:59:28.923]                         invokeRestart("muffleMessage")
[17:59:28.923]                     }
[17:59:28.923]                     else if (inherits(cond, "warning")) {
[17:59:28.923]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:28.923]                       if (muffled) 
[17:59:28.923]                         invokeRestart("muffleWarning")
[17:59:28.923]                     }
[17:59:28.923]                     else if (inherits(cond, "condition")) {
[17:59:28.923]                       if (!is.null(pattern)) {
[17:59:28.923]                         computeRestarts <- base::computeRestarts
[17:59:28.923]                         grepl <- base::grepl
[17:59:28.923]                         restarts <- computeRestarts(cond)
[17:59:28.923]                         for (restart in restarts) {
[17:59:28.923]                           name <- restart$name
[17:59:28.923]                           if (is.null(name)) 
[17:59:28.923]                             next
[17:59:28.923]                           if (!grepl(pattern, name)) 
[17:59:28.923]                             next
[17:59:28.923]                           invokeRestart(restart)
[17:59:28.923]                           muffled <- TRUE
[17:59:28.923]                           break
[17:59:28.923]                         }
[17:59:28.923]                       }
[17:59:28.923]                     }
[17:59:28.923]                     invisible(muffled)
[17:59:28.923]                   }
[17:59:28.923]                   muffleCondition(cond)
[17:59:28.923]                 })
[17:59:28.923]             }))
[17:59:28.923]             future::FutureResult(value = ...future.value$value, 
[17:59:28.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:28.923]                   ...future.rng), globalenv = if (FALSE) 
[17:59:28.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:28.923]                     ...future.globalenv.names))
[17:59:28.923]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:28.923]         }, condition = base::local({
[17:59:28.923]             c <- base::c
[17:59:28.923]             inherits <- base::inherits
[17:59:28.923]             invokeRestart <- base::invokeRestart
[17:59:28.923]             length <- base::length
[17:59:28.923]             list <- base::list
[17:59:28.923]             seq.int <- base::seq.int
[17:59:28.923]             signalCondition <- base::signalCondition
[17:59:28.923]             sys.calls <- base::sys.calls
[17:59:28.923]             `[[` <- base::`[[`
[17:59:28.923]             `+` <- base::`+`
[17:59:28.923]             `<<-` <- base::`<<-`
[17:59:28.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:28.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:28.923]                   3L)]
[17:59:28.923]             }
[17:59:28.923]             function(cond) {
[17:59:28.923]                 is_error <- inherits(cond, "error")
[17:59:28.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:28.923]                   NULL)
[17:59:28.923]                 if (is_error) {
[17:59:28.923]                   sessionInformation <- function() {
[17:59:28.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:28.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:28.923]                       search = base::search(), system = base::Sys.info())
[17:59:28.923]                   }
[17:59:28.923]                   ...future.conditions[[length(...future.conditions) + 
[17:59:28.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:28.923]                     cond$call), session = sessionInformation(), 
[17:59:28.923]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:28.923]                   signalCondition(cond)
[17:59:28.923]                 }
[17:59:28.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:28.923]                 "immediateCondition"))) {
[17:59:28.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:28.923]                   ...future.conditions[[length(...future.conditions) + 
[17:59:28.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:28.923]                   if (TRUE && !signal) {
[17:59:28.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.923]                     {
[17:59:28.923]                       inherits <- base::inherits
[17:59:28.923]                       invokeRestart <- base::invokeRestart
[17:59:28.923]                       is.null <- base::is.null
[17:59:28.923]                       muffled <- FALSE
[17:59:28.923]                       if (inherits(cond, "message")) {
[17:59:28.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:28.923]                         if (muffled) 
[17:59:28.923]                           invokeRestart("muffleMessage")
[17:59:28.923]                       }
[17:59:28.923]                       else if (inherits(cond, "warning")) {
[17:59:28.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:28.923]                         if (muffled) 
[17:59:28.923]                           invokeRestart("muffleWarning")
[17:59:28.923]                       }
[17:59:28.923]                       else if (inherits(cond, "condition")) {
[17:59:28.923]                         if (!is.null(pattern)) {
[17:59:28.923]                           computeRestarts <- base::computeRestarts
[17:59:28.923]                           grepl <- base::grepl
[17:59:28.923]                           restarts <- computeRestarts(cond)
[17:59:28.923]                           for (restart in restarts) {
[17:59:28.923]                             name <- restart$name
[17:59:28.923]                             if (is.null(name)) 
[17:59:28.923]                               next
[17:59:28.923]                             if (!grepl(pattern, name)) 
[17:59:28.923]                               next
[17:59:28.923]                             invokeRestart(restart)
[17:59:28.923]                             muffled <- TRUE
[17:59:28.923]                             break
[17:59:28.923]                           }
[17:59:28.923]                         }
[17:59:28.923]                       }
[17:59:28.923]                       invisible(muffled)
[17:59:28.923]                     }
[17:59:28.923]                     muffleCondition(cond, pattern = "^muffle")
[17:59:28.923]                   }
[17:59:28.923]                 }
[17:59:28.923]                 else {
[17:59:28.923]                   if (TRUE) {
[17:59:28.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:28.923]                     {
[17:59:28.923]                       inherits <- base::inherits
[17:59:28.923]                       invokeRestart <- base::invokeRestart
[17:59:28.923]                       is.null <- base::is.null
[17:59:28.923]                       muffled <- FALSE
[17:59:28.923]                       if (inherits(cond, "message")) {
[17:59:28.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:28.923]                         if (muffled) 
[17:59:28.923]                           invokeRestart("muffleMessage")
[17:59:28.923]                       }
[17:59:28.923]                       else if (inherits(cond, "warning")) {
[17:59:28.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:28.923]                         if (muffled) 
[17:59:28.923]                           invokeRestart("muffleWarning")
[17:59:28.923]                       }
[17:59:28.923]                       else if (inherits(cond, "condition")) {
[17:59:28.923]                         if (!is.null(pattern)) {
[17:59:28.923]                           computeRestarts <- base::computeRestarts
[17:59:28.923]                           grepl <- base::grepl
[17:59:28.923]                           restarts <- computeRestarts(cond)
[17:59:28.923]                           for (restart in restarts) {
[17:59:28.923]                             name <- restart$name
[17:59:28.923]                             if (is.null(name)) 
[17:59:28.923]                               next
[17:59:28.923]                             if (!grepl(pattern, name)) 
[17:59:28.923]                               next
[17:59:28.923]                             invokeRestart(restart)
[17:59:28.923]                             muffled <- TRUE
[17:59:28.923]                             break
[17:59:28.923]                           }
[17:59:28.923]                         }
[17:59:28.923]                       }
[17:59:28.923]                       invisible(muffled)
[17:59:28.923]                     }
[17:59:28.923]                     muffleCondition(cond, pattern = "^muffle")
[17:59:28.923]                   }
[17:59:28.923]                 }
[17:59:28.923]             }
[17:59:28.923]         }))
[17:59:28.923]     }, error = function(ex) {
[17:59:28.923]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:28.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:28.923]                 ...future.rng), started = ...future.startTime, 
[17:59:28.923]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:28.923]             version = "1.8"), class = "FutureResult")
[17:59:28.923]     }, finally = {
[17:59:28.923]         if (!identical(...future.workdir, getwd())) 
[17:59:28.923]             setwd(...future.workdir)
[17:59:28.923]         {
[17:59:28.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:28.923]                 ...future.oldOptions$nwarnings <- NULL
[17:59:28.923]             }
[17:59:28.923]             base::options(...future.oldOptions)
[17:59:28.923]             if (.Platform$OS.type == "windows") {
[17:59:28.923]                 old_names <- names(...future.oldEnvVars)
[17:59:28.923]                 envs <- base::Sys.getenv()
[17:59:28.923]                 names <- names(envs)
[17:59:28.923]                 common <- intersect(names, old_names)
[17:59:28.923]                 added <- setdiff(names, old_names)
[17:59:28.923]                 removed <- setdiff(old_names, names)
[17:59:28.923]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:28.923]                   envs[common]]
[17:59:28.923]                 NAMES <- toupper(changed)
[17:59:28.923]                 args <- list()
[17:59:28.923]                 for (kk in seq_along(NAMES)) {
[17:59:28.923]                   name <- changed[[kk]]
[17:59:28.923]                   NAME <- NAMES[[kk]]
[17:59:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.923]                     next
[17:59:28.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:28.923]                 }
[17:59:28.923]                 NAMES <- toupper(added)
[17:59:28.923]                 for (kk in seq_along(NAMES)) {
[17:59:28.923]                   name <- added[[kk]]
[17:59:28.923]                   NAME <- NAMES[[kk]]
[17:59:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.923]                     next
[17:59:28.923]                   args[[name]] <- ""
[17:59:28.923]                 }
[17:59:28.923]                 NAMES <- toupper(removed)
[17:59:28.923]                 for (kk in seq_along(NAMES)) {
[17:59:28.923]                   name <- removed[[kk]]
[17:59:28.923]                   NAME <- NAMES[[kk]]
[17:59:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:28.923]                     next
[17:59:28.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:28.923]                 }
[17:59:28.923]                 if (length(args) > 0) 
[17:59:28.923]                   base::do.call(base::Sys.setenv, args = args)
[17:59:28.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:28.923]             }
[17:59:28.923]             else {
[17:59:28.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:28.923]             }
[17:59:28.923]             {
[17:59:28.923]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:28.923]                   0L) {
[17:59:28.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:28.923]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:28.923]                   base::options(opts)
[17:59:28.923]                 }
[17:59:28.923]                 {
[17:59:28.923]                   {
[17:59:28.923]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:28.923]                     NULL
[17:59:28.923]                   }
[17:59:28.923]                   options(future.plan = NULL)
[17:59:28.923]                   if (is.na(NA_character_)) 
[17:59:28.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:28.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:28.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:28.923]                     .init = FALSE)
[17:59:28.923]                 }
[17:59:28.923]             }
[17:59:28.923]         }
[17:59:28.923]     })
[17:59:28.923]     if (TRUE) {
[17:59:28.923]         base::sink(type = "output", split = FALSE)
[17:59:28.923]         if (TRUE) {
[17:59:28.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:28.923]         }
[17:59:28.923]         else {
[17:59:28.923]             ...future.result["stdout"] <- base::list(NULL)
[17:59:28.923]         }
[17:59:28.923]         base::close(...future.stdout)
[17:59:28.923]         ...future.stdout <- NULL
[17:59:28.923]     }
[17:59:28.923]     ...future.result$conditions <- ...future.conditions
[17:59:28.923]     ...future.result$finished <- base::Sys.time()
[17:59:28.923]     ...future.result
[17:59:28.923] }
[17:59:29.020] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:59:29.020] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:59:29.021] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:59:29.022] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:29.023] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.023] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[17:59:29.024] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[17:59:29.025] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:29.025] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.026] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:29.027] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.027] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:59:29.028] MultisessionFuture started
[17:59:29.028] - Launch lazy future ... done
[17:59:29.029] run() for ‘MultisessionFuture’ ... done
[17:59:29.029] Created future:
[17:59:29.029] MultisessionFuture:
[17:59:29.029] Label: ‘future_by-2’
[17:59:29.029] Expression:
[17:59:29.029] {
[17:59:29.029]     do.call(function(...) {
[17:59:29.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.029]             on.exit(options(oopts), add = TRUE)
[17:59:29.029]         }
[17:59:29.029]         {
[17:59:29.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.029]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.029]             })
[17:59:29.029]         }
[17:59:29.029]     }, args = future.call.arguments)
[17:59:29.029] }
[17:59:29.029] Lazy evaluation: FALSE
[17:59:29.029] Asynchronous evaluation: TRUE
[17:59:29.029] Local evaluation: TRUE
[17:59:29.029] Environment: R_GlobalEnv
[17:59:29.029] Capture standard output: TRUE
[17:59:29.029] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.029] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:29.029] Packages: <none>
[17:59:29.029] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.029] Resolved: FALSE
[17:59:29.029] Value: <not collected>
[17:59:29.029] Conditions captured: <none>
[17:59:29.029] Early signaling: FALSE
[17:59:29.029] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.029] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.043] Chunk #2 of 2 ... DONE
[17:59:29.044] Launching 2 futures (chunks) ... DONE
[17:59:29.044] Resolving 2 futures (chunks) ...
[17:59:29.044] resolve() on list ...
[17:59:29.044]  recursive: 0
[17:59:29.045]  length: 2
[17:59:29.045] 
[17:59:29.046] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.046] - Validating connection of MultisessionFuture
[17:59:29.047] - received message: FutureResult
[17:59:29.047] - Received FutureResult
[17:59:29.047] - Erased future from FutureRegistry
[17:59:29.048] result() for ClusterFuture ...
[17:59:29.048] - result already collected: FutureResult
[17:59:29.048] result() for ClusterFuture ... done
[17:59:29.048] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.048] Future #1
[17:59:29.049] result() for ClusterFuture ...
[17:59:29.049] - result already collected: FutureResult
[17:59:29.049] result() for ClusterFuture ... done
[17:59:29.049] result() for ClusterFuture ...
[17:59:29.050] - result already collected: FutureResult
[17:59:29.050] result() for ClusterFuture ... done
[17:59:29.050] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:29.050] - nx: 2
[17:59:29.051] - relay: TRUE
[17:59:29.051] - stdout: TRUE
[17:59:29.051] - signal: TRUE
[17:59:29.051] - resignal: FALSE
[17:59:29.051] - force: TRUE
[17:59:29.052] - relayed: [n=2] FALSE, FALSE
[17:59:29.052] - queued futures: [n=2] FALSE, FALSE
[17:59:29.052]  - until=1
[17:59:29.052]  - relaying element #1
[17:59:29.053] result() for ClusterFuture ...
[17:59:29.053] - result already collected: FutureResult
[17:59:29.053] result() for ClusterFuture ... done
[17:59:29.053] result() for ClusterFuture ...
[17:59:29.053] - result already collected: FutureResult
[17:59:29.054] result() for ClusterFuture ... done
[17:59:29.054] result() for ClusterFuture ...
[17:59:29.054] - result already collected: FutureResult
[17:59:29.054] result() for ClusterFuture ... done
[17:59:29.055] result() for ClusterFuture ...
[17:59:29.055] - result already collected: FutureResult
[17:59:29.055] result() for ClusterFuture ... done
[17:59:29.055] - relayed: [n=2] TRUE, FALSE
[17:59:29.056] - queued futures: [n=2] TRUE, FALSE
[17:59:29.056] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:29.056]  length: 1 (resolved future 1)
[17:59:29.146] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.146] - Validating connection of MultisessionFuture
[17:59:29.147] - received message: FutureResult
[17:59:29.147] - Received FutureResult
[17:59:29.148] - Erased future from FutureRegistry
[17:59:29.148] result() for ClusterFuture ...
[17:59:29.149] - result already collected: FutureResult
[17:59:29.149] result() for ClusterFuture ... done
[17:59:29.149] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.150] Future #2
[17:59:29.150] result() for ClusterFuture ...
[17:59:29.151] - result already collected: FutureResult
[17:59:29.151] result() for ClusterFuture ... done
[17:59:29.151] result() for ClusterFuture ...
[17:59:29.152] - result already collected: FutureResult
[17:59:29.156] result() for ClusterFuture ... done
[17:59:29.157] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:29.157] - nx: 2
[17:59:29.157] - relay: TRUE
[17:59:29.158] - stdout: TRUE
[17:59:29.158] - signal: TRUE
[17:59:29.158] - resignal: FALSE
[17:59:29.159] - force: TRUE
[17:59:29.159] - relayed: [n=2] TRUE, FALSE
[17:59:29.159] - queued futures: [n=2] TRUE, FALSE
[17:59:29.159]  - until=2
[17:59:29.160]  - relaying element #2
[17:59:29.160] result() for ClusterFuture ...
[17:59:29.160] - result already collected: FutureResult
[17:59:29.160] result() for ClusterFuture ... done
[17:59:29.160] result() for ClusterFuture ...
[17:59:29.161] - result already collected: FutureResult
[17:59:29.161] result() for ClusterFuture ... done
[17:59:29.161] result() for ClusterFuture ...
[17:59:29.161] - result already collected: FutureResult
[17:59:29.162] result() for ClusterFuture ... done
[17:59:29.162] result() for ClusterFuture ...
[17:59:29.162] - result already collected: FutureResult
[17:59:29.162] result() for ClusterFuture ... done
[17:59:29.162] - relayed: [n=2] TRUE, TRUE
[17:59:29.163] - queued futures: [n=2] TRUE, TRUE
[17:59:29.163] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:29.163]  length: 0 (resolved future 2)
[17:59:29.163] Relaying remaining futures
[17:59:29.163] signalConditionsASAP(NULL, pos=0) ...
[17:59:29.164] - nx: 2
[17:59:29.164] - relay: TRUE
[17:59:29.164] - stdout: TRUE
[17:59:29.164] - signal: TRUE
[17:59:29.164] - resignal: FALSE
[17:59:29.165] - force: TRUE
[17:59:29.165] - relayed: [n=2] TRUE, TRUE
[17:59:29.165] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:29.165] - relayed: [n=2] TRUE, TRUE
[17:59:29.166] - queued futures: [n=2] TRUE, TRUE
[17:59:29.166] signalConditionsASAP(NULL, pos=0) ... done
[17:59:29.166] resolve() on list ... DONE
[17:59:29.166] result() for ClusterFuture ...
[17:59:29.166] - result already collected: FutureResult
[17:59:29.167] result() for ClusterFuture ... done
[17:59:29.167] result() for ClusterFuture ...
[17:59:29.167] - result already collected: FutureResult
[17:59:29.167] result() for ClusterFuture ... done
[17:59:29.167] result() for ClusterFuture ...
[17:59:29.168] - result already collected: FutureResult
[17:59:29.168] result() for ClusterFuture ... done
[17:59:29.168] result() for ClusterFuture ...
[17:59:29.168] - result already collected: FutureResult
[17:59:29.168] result() for ClusterFuture ... done
[17:59:29.169]  - Number of value chunks collected: 2
[17:59:29.169] Resolving 2 futures (chunks) ... DONE
[17:59:29.169] Reducing values from 2 chunks ...
[17:59:29.169]  - Number of values collected after concatenation: 3
[17:59:29.169]  - Number of values expected: 3
[17:59:29.170] Reducing values from 2 chunks ... DONE
[17:59:29.170] future_lapply() ... DONE
[17:59:29.170] future_by_internal() ... DONE
[17:59:29.170] future_by_internal() ...
[17:59:29.171] future_lapply() ...
[17:59:29.178] Number of chunks: 2
[17:59:29.178] getGlobalsAndPackagesXApply() ...
[17:59:29.178]  - future.globals: TRUE
[17:59:29.179] getGlobalsAndPackages() ...
[17:59:29.179] Searching for globals...
[17:59:29.181] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:29.182] Searching for globals ... DONE
[17:59:29.182] Resolving globals: FALSE
[17:59:29.183] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:29.183] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:29.184] - globals: [1] ‘FUN’
[17:59:29.184] 
[17:59:29.184] getGlobalsAndPackages() ... DONE
[17:59:29.184]  - globals found/used: [n=1] ‘FUN’
[17:59:29.185]  - needed namespaces: [n=0] 
[17:59:29.185] Finding globals ... DONE
[17:59:29.185]  - use_args: TRUE
[17:59:29.185]  - Getting '...' globals ...
[17:59:29.186] resolve() on list ...
[17:59:29.186]  recursive: 0
[17:59:29.186]  length: 1
[17:59:29.186]  elements: ‘...’
[17:59:29.187]  length: 0 (resolved future 1)
[17:59:29.187] resolve() on list ... DONE
[17:59:29.187]    - '...' content: [n=1] ‘digits’
[17:59:29.187] List of 1
[17:59:29.187]  $ ...:List of 1
[17:59:29.187]   ..$ digits: int 2
[17:59:29.187]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.187]  - attr(*, "where")=List of 1
[17:59:29.187]   ..$ ...:<environment: 0x6264a0055c58> 
[17:59:29.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.187]  - attr(*, "resolved")= logi TRUE
[17:59:29.187]  - attr(*, "total_size")= num NA
[17:59:29.193]  - Getting '...' globals ... DONE
[17:59:29.194] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:29.194] List of 2
[17:59:29.194]  $ ...future.FUN:function (object, ...)  
[17:59:29.194]  $ ...          :List of 1
[17:59:29.194]   ..$ digits: int 2
[17:59:29.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.194]  - attr(*, "where")=List of 2
[17:59:29.194]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:29.194]   ..$ ...          :<environment: 0x6264a0055c58> 
[17:59:29.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.194]  - attr(*, "resolved")= logi FALSE
[17:59:29.194]  - attr(*, "total_size")= num 1296
[17:59:29.200] Packages to be attached in all futures: [n=0] 
[17:59:29.200] getGlobalsAndPackagesXApply() ... DONE
[17:59:29.201] Number of futures (= number of chunks): 2
[17:59:29.201] Launching 2 futures (chunks) ...
[17:59:29.201] Chunk #1 of 2 ...
[17:59:29.201]  - Finding globals in 'X' for chunk #1 ...
[17:59:29.202] getGlobalsAndPackages() ...
[17:59:29.202] Searching for globals...
[17:59:29.202] 
[17:59:29.202] Searching for globals ... DONE
[17:59:29.203] - globals: [0] <none>
[17:59:29.203] getGlobalsAndPackages() ... DONE
[17:59:29.203]    + additional globals found: [n=0] 
[17:59:29.203]    + additional namespaces needed: [n=0] 
[17:59:29.203]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:29.204]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.204]  - seeds: <none>
[17:59:29.204]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.204] getGlobalsAndPackages() ...
[17:59:29.204] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.205] Resolving globals: FALSE
[17:59:29.205] Tweak future expression to call with '...' arguments ...
[17:59:29.205] {
[17:59:29.205]     do.call(function(...) {
[17:59:29.205]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.205]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.205]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.205]             on.exit(options(oopts), add = TRUE)
[17:59:29.205]         }
[17:59:29.205]         {
[17:59:29.205]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.205]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.205]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.205]             })
[17:59:29.205]         }
[17:59:29.205]     }, args = future.call.arguments)
[17:59:29.205] }
[17:59:29.206] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.206] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.206] 
[17:59:29.207] getGlobalsAndPackages() ... DONE
[17:59:29.207] run() for ‘Future’ ...
[17:59:29.207] - state: ‘created’
[17:59:29.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.235] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.235]   - Field: ‘node’
[17:59:29.236]   - Field: ‘label’
[17:59:29.236]   - Field: ‘local’
[17:59:29.236]   - Field: ‘owner’
[17:59:29.236]   - Field: ‘envir’
[17:59:29.236]   - Field: ‘workers’
[17:59:29.237]   - Field: ‘packages’
[17:59:29.237]   - Field: ‘gc’
[17:59:29.237]   - Field: ‘conditions’
[17:59:29.237]   - Field: ‘persistent’
[17:59:29.238]   - Field: ‘expr’
[17:59:29.238]   - Field: ‘uuid’
[17:59:29.238]   - Field: ‘seed’
[17:59:29.238]   - Field: ‘version’
[17:59:29.238]   - Field: ‘result’
[17:59:29.239]   - Field: ‘asynchronous’
[17:59:29.239]   - Field: ‘calls’
[17:59:29.239]   - Field: ‘globals’
[17:59:29.239]   - Field: ‘stdout’
[17:59:29.239]   - Field: ‘earlySignal’
[17:59:29.239]   - Field: ‘lazy’
[17:59:29.240]   - Field: ‘state’
[17:59:29.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.240] - Launch lazy future ...
[17:59:29.241] Packages needed by the future expression (n = 0): <none>
[17:59:29.241] Packages needed by future strategies (n = 0): <none>
[17:59:29.242] {
[17:59:29.242]     {
[17:59:29.242]         {
[17:59:29.242]             ...future.startTime <- base::Sys.time()
[17:59:29.242]             {
[17:59:29.242]                 {
[17:59:29.242]                   {
[17:59:29.242]                     {
[17:59:29.242]                       base::local({
[17:59:29.242]                         has_future <- base::requireNamespace("future", 
[17:59:29.242]                           quietly = TRUE)
[17:59:29.242]                         if (has_future) {
[17:59:29.242]                           ns <- base::getNamespace("future")
[17:59:29.242]                           version <- ns[[".package"]][["version"]]
[17:59:29.242]                           if (is.null(version)) 
[17:59:29.242]                             version <- utils::packageVersion("future")
[17:59:29.242]                         }
[17:59:29.242]                         else {
[17:59:29.242]                           version <- NULL
[17:59:29.242]                         }
[17:59:29.242]                         if (!has_future || version < "1.8.0") {
[17:59:29.242]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.242]                             "", base::R.version$version.string), 
[17:59:29.242]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:29.242]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:29.242]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.242]                               "release", "version")], collapse = " "), 
[17:59:29.242]                             hostname = base::Sys.info()[["nodename"]])
[17:59:29.242]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.242]                             info)
[17:59:29.242]                           info <- base::paste(info, collapse = "; ")
[17:59:29.242]                           if (!has_future) {
[17:59:29.242]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.242]                               info)
[17:59:29.242]                           }
[17:59:29.242]                           else {
[17:59:29.242]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.242]                               info, version)
[17:59:29.242]                           }
[17:59:29.242]                           base::stop(msg)
[17:59:29.242]                         }
[17:59:29.242]                       })
[17:59:29.242]                     }
[17:59:29.242]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.242]                     base::options(mc.cores = 1L)
[17:59:29.242]                   }
[17:59:29.242]                   ...future.strategy.old <- future::plan("list")
[17:59:29.242]                   options(future.plan = NULL)
[17:59:29.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.242]                 }
[17:59:29.242]                 ...future.workdir <- getwd()
[17:59:29.242]             }
[17:59:29.242]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.242]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.242]         }
[17:59:29.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.242]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.242]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.242]             base::names(...future.oldOptions))
[17:59:29.242]     }
[17:59:29.242]     if (FALSE) {
[17:59:29.242]     }
[17:59:29.242]     else {
[17:59:29.242]         if (TRUE) {
[17:59:29.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.242]                 open = "w")
[17:59:29.242]         }
[17:59:29.242]         else {
[17:59:29.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.242]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.242]         }
[17:59:29.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.242]             base::sink(type = "output", split = FALSE)
[17:59:29.242]             base::close(...future.stdout)
[17:59:29.242]         }, add = TRUE)
[17:59:29.242]     }
[17:59:29.242]     ...future.frame <- base::sys.nframe()
[17:59:29.242]     ...future.conditions <- base::list()
[17:59:29.242]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.242]     if (FALSE) {
[17:59:29.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.242]     }
[17:59:29.242]     ...future.result <- base::tryCatch({
[17:59:29.242]         base::withCallingHandlers({
[17:59:29.242]             ...future.value <- base::withVisible(base::local({
[17:59:29.242]                 ...future.makeSendCondition <- base::local({
[17:59:29.242]                   sendCondition <- NULL
[17:59:29.242]                   function(frame = 1L) {
[17:59:29.242]                     if (is.function(sendCondition)) 
[17:59:29.242]                       return(sendCondition)
[17:59:29.242]                     ns <- getNamespace("parallel")
[17:59:29.242]                     if (exists("sendData", mode = "function", 
[17:59:29.242]                       envir = ns)) {
[17:59:29.242]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.242]                         envir = ns)
[17:59:29.242]                       envir <- sys.frame(frame)
[17:59:29.242]                       master <- NULL
[17:59:29.242]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.242]                         !identical(envir, emptyenv())) {
[17:59:29.242]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.242]                           inherits = FALSE)) {
[17:59:29.242]                           master <- get("master", mode = "list", 
[17:59:29.242]                             envir = envir, inherits = FALSE)
[17:59:29.242]                           if (inherits(master, c("SOCKnode", 
[17:59:29.242]                             "SOCK0node"))) {
[17:59:29.242]                             sendCondition <<- function(cond) {
[17:59:29.242]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.242]                                 success = TRUE)
[17:59:29.242]                               parallel_sendData(master, data)
[17:59:29.242]                             }
[17:59:29.242]                             return(sendCondition)
[17:59:29.242]                           }
[17:59:29.242]                         }
[17:59:29.242]                         frame <- frame + 1L
[17:59:29.242]                         envir <- sys.frame(frame)
[17:59:29.242]                       }
[17:59:29.242]                     }
[17:59:29.242]                     sendCondition <<- function(cond) NULL
[17:59:29.242]                   }
[17:59:29.242]                 })
[17:59:29.242]                 withCallingHandlers({
[17:59:29.242]                   {
[17:59:29.242]                     do.call(function(...) {
[17:59:29.242]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.242]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.242]                         ...future.globals.maxSize)) {
[17:59:29.242]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.242]                         on.exit(options(oopts), add = TRUE)
[17:59:29.242]                       }
[17:59:29.242]                       {
[17:59:29.242]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.242]                           FUN = function(jj) {
[17:59:29.242]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.242]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.242]                           })
[17:59:29.242]                       }
[17:59:29.242]                     }, args = future.call.arguments)
[17:59:29.242]                   }
[17:59:29.242]                 }, immediateCondition = function(cond) {
[17:59:29.242]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.242]                   sendCondition(cond)
[17:59:29.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.242]                   {
[17:59:29.242]                     inherits <- base::inherits
[17:59:29.242]                     invokeRestart <- base::invokeRestart
[17:59:29.242]                     is.null <- base::is.null
[17:59:29.242]                     muffled <- FALSE
[17:59:29.242]                     if (inherits(cond, "message")) {
[17:59:29.242]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.242]                       if (muffled) 
[17:59:29.242]                         invokeRestart("muffleMessage")
[17:59:29.242]                     }
[17:59:29.242]                     else if (inherits(cond, "warning")) {
[17:59:29.242]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.242]                       if (muffled) 
[17:59:29.242]                         invokeRestart("muffleWarning")
[17:59:29.242]                     }
[17:59:29.242]                     else if (inherits(cond, "condition")) {
[17:59:29.242]                       if (!is.null(pattern)) {
[17:59:29.242]                         computeRestarts <- base::computeRestarts
[17:59:29.242]                         grepl <- base::grepl
[17:59:29.242]                         restarts <- computeRestarts(cond)
[17:59:29.242]                         for (restart in restarts) {
[17:59:29.242]                           name <- restart$name
[17:59:29.242]                           if (is.null(name)) 
[17:59:29.242]                             next
[17:59:29.242]                           if (!grepl(pattern, name)) 
[17:59:29.242]                             next
[17:59:29.242]                           invokeRestart(restart)
[17:59:29.242]                           muffled <- TRUE
[17:59:29.242]                           break
[17:59:29.242]                         }
[17:59:29.242]                       }
[17:59:29.242]                     }
[17:59:29.242]                     invisible(muffled)
[17:59:29.242]                   }
[17:59:29.242]                   muffleCondition(cond)
[17:59:29.242]                 })
[17:59:29.242]             }))
[17:59:29.242]             future::FutureResult(value = ...future.value$value, 
[17:59:29.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.242]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.242]                     ...future.globalenv.names))
[17:59:29.242]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.242]         }, condition = base::local({
[17:59:29.242]             c <- base::c
[17:59:29.242]             inherits <- base::inherits
[17:59:29.242]             invokeRestart <- base::invokeRestart
[17:59:29.242]             length <- base::length
[17:59:29.242]             list <- base::list
[17:59:29.242]             seq.int <- base::seq.int
[17:59:29.242]             signalCondition <- base::signalCondition
[17:59:29.242]             sys.calls <- base::sys.calls
[17:59:29.242]             `[[` <- base::`[[`
[17:59:29.242]             `+` <- base::`+`
[17:59:29.242]             `<<-` <- base::`<<-`
[17:59:29.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.242]                   3L)]
[17:59:29.242]             }
[17:59:29.242]             function(cond) {
[17:59:29.242]                 is_error <- inherits(cond, "error")
[17:59:29.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.242]                   NULL)
[17:59:29.242]                 if (is_error) {
[17:59:29.242]                   sessionInformation <- function() {
[17:59:29.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.242]                       search = base::search(), system = base::Sys.info())
[17:59:29.242]                   }
[17:59:29.242]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.242]                     cond$call), session = sessionInformation(), 
[17:59:29.242]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.242]                   signalCondition(cond)
[17:59:29.242]                 }
[17:59:29.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.242]                 "immediateCondition"))) {
[17:59:29.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.242]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.242]                   if (TRUE && !signal) {
[17:59:29.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.242]                     {
[17:59:29.242]                       inherits <- base::inherits
[17:59:29.242]                       invokeRestart <- base::invokeRestart
[17:59:29.242]                       is.null <- base::is.null
[17:59:29.242]                       muffled <- FALSE
[17:59:29.242]                       if (inherits(cond, "message")) {
[17:59:29.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.242]                         if (muffled) 
[17:59:29.242]                           invokeRestart("muffleMessage")
[17:59:29.242]                       }
[17:59:29.242]                       else if (inherits(cond, "warning")) {
[17:59:29.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.242]                         if (muffled) 
[17:59:29.242]                           invokeRestart("muffleWarning")
[17:59:29.242]                       }
[17:59:29.242]                       else if (inherits(cond, "condition")) {
[17:59:29.242]                         if (!is.null(pattern)) {
[17:59:29.242]                           computeRestarts <- base::computeRestarts
[17:59:29.242]                           grepl <- base::grepl
[17:59:29.242]                           restarts <- computeRestarts(cond)
[17:59:29.242]                           for (restart in restarts) {
[17:59:29.242]                             name <- restart$name
[17:59:29.242]                             if (is.null(name)) 
[17:59:29.242]                               next
[17:59:29.242]                             if (!grepl(pattern, name)) 
[17:59:29.242]                               next
[17:59:29.242]                             invokeRestart(restart)
[17:59:29.242]                             muffled <- TRUE
[17:59:29.242]                             break
[17:59:29.242]                           }
[17:59:29.242]                         }
[17:59:29.242]                       }
[17:59:29.242]                       invisible(muffled)
[17:59:29.242]                     }
[17:59:29.242]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.242]                   }
[17:59:29.242]                 }
[17:59:29.242]                 else {
[17:59:29.242]                   if (TRUE) {
[17:59:29.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.242]                     {
[17:59:29.242]                       inherits <- base::inherits
[17:59:29.242]                       invokeRestart <- base::invokeRestart
[17:59:29.242]                       is.null <- base::is.null
[17:59:29.242]                       muffled <- FALSE
[17:59:29.242]                       if (inherits(cond, "message")) {
[17:59:29.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.242]                         if (muffled) 
[17:59:29.242]                           invokeRestart("muffleMessage")
[17:59:29.242]                       }
[17:59:29.242]                       else if (inherits(cond, "warning")) {
[17:59:29.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.242]                         if (muffled) 
[17:59:29.242]                           invokeRestart("muffleWarning")
[17:59:29.242]                       }
[17:59:29.242]                       else if (inherits(cond, "condition")) {
[17:59:29.242]                         if (!is.null(pattern)) {
[17:59:29.242]                           computeRestarts <- base::computeRestarts
[17:59:29.242]                           grepl <- base::grepl
[17:59:29.242]                           restarts <- computeRestarts(cond)
[17:59:29.242]                           for (restart in restarts) {
[17:59:29.242]                             name <- restart$name
[17:59:29.242]                             if (is.null(name)) 
[17:59:29.242]                               next
[17:59:29.242]                             if (!grepl(pattern, name)) 
[17:59:29.242]                               next
[17:59:29.242]                             invokeRestart(restart)
[17:59:29.242]                             muffled <- TRUE
[17:59:29.242]                             break
[17:59:29.242]                           }
[17:59:29.242]                         }
[17:59:29.242]                       }
[17:59:29.242]                       invisible(muffled)
[17:59:29.242]                     }
[17:59:29.242]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.242]                   }
[17:59:29.242]                 }
[17:59:29.242]             }
[17:59:29.242]         }))
[17:59:29.242]     }, error = function(ex) {
[17:59:29.242]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.242]                 ...future.rng), started = ...future.startTime, 
[17:59:29.242]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.242]             version = "1.8"), class = "FutureResult")
[17:59:29.242]     }, finally = {
[17:59:29.242]         if (!identical(...future.workdir, getwd())) 
[17:59:29.242]             setwd(...future.workdir)
[17:59:29.242]         {
[17:59:29.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.242]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.242]             }
[17:59:29.242]             base::options(...future.oldOptions)
[17:59:29.242]             if (.Platform$OS.type == "windows") {
[17:59:29.242]                 old_names <- names(...future.oldEnvVars)
[17:59:29.242]                 envs <- base::Sys.getenv()
[17:59:29.242]                 names <- names(envs)
[17:59:29.242]                 common <- intersect(names, old_names)
[17:59:29.242]                 added <- setdiff(names, old_names)
[17:59:29.242]                 removed <- setdiff(old_names, names)
[17:59:29.242]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.242]                   envs[common]]
[17:59:29.242]                 NAMES <- toupper(changed)
[17:59:29.242]                 args <- list()
[17:59:29.242]                 for (kk in seq_along(NAMES)) {
[17:59:29.242]                   name <- changed[[kk]]
[17:59:29.242]                   NAME <- NAMES[[kk]]
[17:59:29.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.242]                     next
[17:59:29.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.242]                 }
[17:59:29.242]                 NAMES <- toupper(added)
[17:59:29.242]                 for (kk in seq_along(NAMES)) {
[17:59:29.242]                   name <- added[[kk]]
[17:59:29.242]                   NAME <- NAMES[[kk]]
[17:59:29.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.242]                     next
[17:59:29.242]                   args[[name]] <- ""
[17:59:29.242]                 }
[17:59:29.242]                 NAMES <- toupper(removed)
[17:59:29.242]                 for (kk in seq_along(NAMES)) {
[17:59:29.242]                   name <- removed[[kk]]
[17:59:29.242]                   NAME <- NAMES[[kk]]
[17:59:29.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.242]                     next
[17:59:29.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.242]                 }
[17:59:29.242]                 if (length(args) > 0) 
[17:59:29.242]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.242]             }
[17:59:29.242]             else {
[17:59:29.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.242]             }
[17:59:29.242]             {
[17:59:29.242]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.242]                   0L) {
[17:59:29.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.242]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.242]                   base::options(opts)
[17:59:29.242]                 }
[17:59:29.242]                 {
[17:59:29.242]                   {
[17:59:29.242]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.242]                     NULL
[17:59:29.242]                   }
[17:59:29.242]                   options(future.plan = NULL)
[17:59:29.242]                   if (is.na(NA_character_)) 
[17:59:29.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.242]                     .init = FALSE)
[17:59:29.242]                 }
[17:59:29.242]             }
[17:59:29.242]         }
[17:59:29.242]     })
[17:59:29.242]     if (TRUE) {
[17:59:29.242]         base::sink(type = "output", split = FALSE)
[17:59:29.242]         if (TRUE) {
[17:59:29.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.242]         }
[17:59:29.242]         else {
[17:59:29.242]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.242]         }
[17:59:29.242]         base::close(...future.stdout)
[17:59:29.242]         ...future.stdout <- NULL
[17:59:29.242]     }
[17:59:29.242]     ...future.result$conditions <- ...future.conditions
[17:59:29.242]     ...future.result$finished <- base::Sys.time()
[17:59:29.242]     ...future.result
[17:59:29.242] }
[17:59:29.247] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[17:59:29.247] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:59:29.248] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:59:29.249] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:59:29.249] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:59:29.250] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[17:59:29.251] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[17:59:29.251] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:29.252] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.252] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:29.253] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.253] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[17:59:29.254] MultisessionFuture started
[17:59:29.254] - Launch lazy future ... done
[17:59:29.254] run() for ‘MultisessionFuture’ ... done
[17:59:29.255] Created future:
[17:59:29.255] MultisessionFuture:
[17:59:29.255] Label: ‘future_by-1’
[17:59:29.255] Expression:
[17:59:29.255] {
[17:59:29.255]     do.call(function(...) {
[17:59:29.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.255]             on.exit(options(oopts), add = TRUE)
[17:59:29.255]         }
[17:59:29.255]         {
[17:59:29.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.255]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.255]             })
[17:59:29.255]         }
[17:59:29.255]     }, args = future.call.arguments)
[17:59:29.255] }
[17:59:29.255] Lazy evaluation: FALSE
[17:59:29.255] Asynchronous evaluation: TRUE
[17:59:29.255] Local evaluation: TRUE
[17:59:29.255] Environment: R_GlobalEnv
[17:59:29.255] Capture standard output: TRUE
[17:59:29.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.255] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:29.255] Packages: <none>
[17:59:29.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.255] Resolved: FALSE
[17:59:29.255] Value: <not collected>
[17:59:29.255] Conditions captured: <none>
[17:59:29.255] Early signaling: FALSE
[17:59:29.255] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.255] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.269] Chunk #1 of 2 ... DONE
[17:59:29.269] Chunk #2 of 2 ...
[17:59:29.269]  - Finding globals in 'X' for chunk #2 ...
[17:59:29.269] getGlobalsAndPackages() ...
[17:59:29.270] Searching for globals...
[17:59:29.270] 
[17:59:29.270] Searching for globals ... DONE
[17:59:29.270] - globals: [0] <none>
[17:59:29.271] getGlobalsAndPackages() ... DONE
[17:59:29.271]    + additional globals found: [n=0] 
[17:59:29.271]    + additional namespaces needed: [n=0] 
[17:59:29.271]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:29.271]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.272]  - seeds: <none>
[17:59:29.272]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.272] getGlobalsAndPackages() ...
[17:59:29.272] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.272] Resolving globals: FALSE
[17:59:29.273] Tweak future expression to call with '...' arguments ...
[17:59:29.273] {
[17:59:29.273]     do.call(function(...) {
[17:59:29.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.273]             on.exit(options(oopts), add = TRUE)
[17:59:29.273]         }
[17:59:29.273]         {
[17:59:29.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.273]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.273]             })
[17:59:29.273]         }
[17:59:29.273]     }, args = future.call.arguments)
[17:59:29.273] }
[17:59:29.273] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.274] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.274] 
[17:59:29.275] getGlobalsAndPackages() ... DONE
[17:59:29.275] run() for ‘Future’ ...
[17:59:29.275] - state: ‘created’
[17:59:29.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.300] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.301]   - Field: ‘node’
[17:59:29.301]   - Field: ‘label’
[17:59:29.301]   - Field: ‘local’
[17:59:29.301]   - Field: ‘owner’
[17:59:29.302]   - Field: ‘envir’
[17:59:29.302]   - Field: ‘workers’
[17:59:29.302]   - Field: ‘packages’
[17:59:29.302]   - Field: ‘gc’
[17:59:29.302]   - Field: ‘conditions’
[17:59:29.303]   - Field: ‘persistent’
[17:59:29.303]   - Field: ‘expr’
[17:59:29.303]   - Field: ‘uuid’
[17:59:29.303]   - Field: ‘seed’
[17:59:29.303]   - Field: ‘version’
[17:59:29.304]   - Field: ‘result’
[17:59:29.304]   - Field: ‘asynchronous’
[17:59:29.304]   - Field: ‘calls’
[17:59:29.304]   - Field: ‘globals’
[17:59:29.304]   - Field: ‘stdout’
[17:59:29.305]   - Field: ‘earlySignal’
[17:59:29.305]   - Field: ‘lazy’
[17:59:29.305]   - Field: ‘state’
[17:59:29.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.305] - Launch lazy future ...
[17:59:29.306] Packages needed by the future expression (n = 0): <none>
[17:59:29.306] Packages needed by future strategies (n = 0): <none>
[17:59:29.307] {
[17:59:29.307]     {
[17:59:29.307]         {
[17:59:29.307]             ...future.startTime <- base::Sys.time()
[17:59:29.307]             {
[17:59:29.307]                 {
[17:59:29.307]                   {
[17:59:29.307]                     {
[17:59:29.307]                       base::local({
[17:59:29.307]                         has_future <- base::requireNamespace("future", 
[17:59:29.307]                           quietly = TRUE)
[17:59:29.307]                         if (has_future) {
[17:59:29.307]                           ns <- base::getNamespace("future")
[17:59:29.307]                           version <- ns[[".package"]][["version"]]
[17:59:29.307]                           if (is.null(version)) 
[17:59:29.307]                             version <- utils::packageVersion("future")
[17:59:29.307]                         }
[17:59:29.307]                         else {
[17:59:29.307]                           version <- NULL
[17:59:29.307]                         }
[17:59:29.307]                         if (!has_future || version < "1.8.0") {
[17:59:29.307]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.307]                             "", base::R.version$version.string), 
[17:59:29.307]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:29.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:29.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.307]                               "release", "version")], collapse = " "), 
[17:59:29.307]                             hostname = base::Sys.info()[["nodename"]])
[17:59:29.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.307]                             info)
[17:59:29.307]                           info <- base::paste(info, collapse = "; ")
[17:59:29.307]                           if (!has_future) {
[17:59:29.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.307]                               info)
[17:59:29.307]                           }
[17:59:29.307]                           else {
[17:59:29.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.307]                               info, version)
[17:59:29.307]                           }
[17:59:29.307]                           base::stop(msg)
[17:59:29.307]                         }
[17:59:29.307]                       })
[17:59:29.307]                     }
[17:59:29.307]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.307]                     base::options(mc.cores = 1L)
[17:59:29.307]                   }
[17:59:29.307]                   ...future.strategy.old <- future::plan("list")
[17:59:29.307]                   options(future.plan = NULL)
[17:59:29.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.307]                 }
[17:59:29.307]                 ...future.workdir <- getwd()
[17:59:29.307]             }
[17:59:29.307]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.307]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.307]         }
[17:59:29.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.307]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.307]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.307]             base::names(...future.oldOptions))
[17:59:29.307]     }
[17:59:29.307]     if (FALSE) {
[17:59:29.307]     }
[17:59:29.307]     else {
[17:59:29.307]         if (TRUE) {
[17:59:29.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.307]                 open = "w")
[17:59:29.307]         }
[17:59:29.307]         else {
[17:59:29.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.307]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.307]         }
[17:59:29.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.307]             base::sink(type = "output", split = FALSE)
[17:59:29.307]             base::close(...future.stdout)
[17:59:29.307]         }, add = TRUE)
[17:59:29.307]     }
[17:59:29.307]     ...future.frame <- base::sys.nframe()
[17:59:29.307]     ...future.conditions <- base::list()
[17:59:29.307]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.307]     if (FALSE) {
[17:59:29.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.307]     }
[17:59:29.307]     ...future.result <- base::tryCatch({
[17:59:29.307]         base::withCallingHandlers({
[17:59:29.307]             ...future.value <- base::withVisible(base::local({
[17:59:29.307]                 ...future.makeSendCondition <- base::local({
[17:59:29.307]                   sendCondition <- NULL
[17:59:29.307]                   function(frame = 1L) {
[17:59:29.307]                     if (is.function(sendCondition)) 
[17:59:29.307]                       return(sendCondition)
[17:59:29.307]                     ns <- getNamespace("parallel")
[17:59:29.307]                     if (exists("sendData", mode = "function", 
[17:59:29.307]                       envir = ns)) {
[17:59:29.307]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.307]                         envir = ns)
[17:59:29.307]                       envir <- sys.frame(frame)
[17:59:29.307]                       master <- NULL
[17:59:29.307]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.307]                         !identical(envir, emptyenv())) {
[17:59:29.307]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.307]                           inherits = FALSE)) {
[17:59:29.307]                           master <- get("master", mode = "list", 
[17:59:29.307]                             envir = envir, inherits = FALSE)
[17:59:29.307]                           if (inherits(master, c("SOCKnode", 
[17:59:29.307]                             "SOCK0node"))) {
[17:59:29.307]                             sendCondition <<- function(cond) {
[17:59:29.307]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.307]                                 success = TRUE)
[17:59:29.307]                               parallel_sendData(master, data)
[17:59:29.307]                             }
[17:59:29.307]                             return(sendCondition)
[17:59:29.307]                           }
[17:59:29.307]                         }
[17:59:29.307]                         frame <- frame + 1L
[17:59:29.307]                         envir <- sys.frame(frame)
[17:59:29.307]                       }
[17:59:29.307]                     }
[17:59:29.307]                     sendCondition <<- function(cond) NULL
[17:59:29.307]                   }
[17:59:29.307]                 })
[17:59:29.307]                 withCallingHandlers({
[17:59:29.307]                   {
[17:59:29.307]                     do.call(function(...) {
[17:59:29.307]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.307]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.307]                         ...future.globals.maxSize)) {
[17:59:29.307]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.307]                         on.exit(options(oopts), add = TRUE)
[17:59:29.307]                       }
[17:59:29.307]                       {
[17:59:29.307]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.307]                           FUN = function(jj) {
[17:59:29.307]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.307]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.307]                           })
[17:59:29.307]                       }
[17:59:29.307]                     }, args = future.call.arguments)
[17:59:29.307]                   }
[17:59:29.307]                 }, immediateCondition = function(cond) {
[17:59:29.307]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.307]                   sendCondition(cond)
[17:59:29.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.307]                   {
[17:59:29.307]                     inherits <- base::inherits
[17:59:29.307]                     invokeRestart <- base::invokeRestart
[17:59:29.307]                     is.null <- base::is.null
[17:59:29.307]                     muffled <- FALSE
[17:59:29.307]                     if (inherits(cond, "message")) {
[17:59:29.307]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.307]                       if (muffled) 
[17:59:29.307]                         invokeRestart("muffleMessage")
[17:59:29.307]                     }
[17:59:29.307]                     else if (inherits(cond, "warning")) {
[17:59:29.307]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.307]                       if (muffled) 
[17:59:29.307]                         invokeRestart("muffleWarning")
[17:59:29.307]                     }
[17:59:29.307]                     else if (inherits(cond, "condition")) {
[17:59:29.307]                       if (!is.null(pattern)) {
[17:59:29.307]                         computeRestarts <- base::computeRestarts
[17:59:29.307]                         grepl <- base::grepl
[17:59:29.307]                         restarts <- computeRestarts(cond)
[17:59:29.307]                         for (restart in restarts) {
[17:59:29.307]                           name <- restart$name
[17:59:29.307]                           if (is.null(name)) 
[17:59:29.307]                             next
[17:59:29.307]                           if (!grepl(pattern, name)) 
[17:59:29.307]                             next
[17:59:29.307]                           invokeRestart(restart)
[17:59:29.307]                           muffled <- TRUE
[17:59:29.307]                           break
[17:59:29.307]                         }
[17:59:29.307]                       }
[17:59:29.307]                     }
[17:59:29.307]                     invisible(muffled)
[17:59:29.307]                   }
[17:59:29.307]                   muffleCondition(cond)
[17:59:29.307]                 })
[17:59:29.307]             }))
[17:59:29.307]             future::FutureResult(value = ...future.value$value, 
[17:59:29.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.307]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.307]                     ...future.globalenv.names))
[17:59:29.307]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.307]         }, condition = base::local({
[17:59:29.307]             c <- base::c
[17:59:29.307]             inherits <- base::inherits
[17:59:29.307]             invokeRestart <- base::invokeRestart
[17:59:29.307]             length <- base::length
[17:59:29.307]             list <- base::list
[17:59:29.307]             seq.int <- base::seq.int
[17:59:29.307]             signalCondition <- base::signalCondition
[17:59:29.307]             sys.calls <- base::sys.calls
[17:59:29.307]             `[[` <- base::`[[`
[17:59:29.307]             `+` <- base::`+`
[17:59:29.307]             `<<-` <- base::`<<-`
[17:59:29.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.307]                   3L)]
[17:59:29.307]             }
[17:59:29.307]             function(cond) {
[17:59:29.307]                 is_error <- inherits(cond, "error")
[17:59:29.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.307]                   NULL)
[17:59:29.307]                 if (is_error) {
[17:59:29.307]                   sessionInformation <- function() {
[17:59:29.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.307]                       search = base::search(), system = base::Sys.info())
[17:59:29.307]                   }
[17:59:29.307]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.307]                     cond$call), session = sessionInformation(), 
[17:59:29.307]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.307]                   signalCondition(cond)
[17:59:29.307]                 }
[17:59:29.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.307]                 "immediateCondition"))) {
[17:59:29.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.307]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.307]                   if (TRUE && !signal) {
[17:59:29.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.307]                     {
[17:59:29.307]                       inherits <- base::inherits
[17:59:29.307]                       invokeRestart <- base::invokeRestart
[17:59:29.307]                       is.null <- base::is.null
[17:59:29.307]                       muffled <- FALSE
[17:59:29.307]                       if (inherits(cond, "message")) {
[17:59:29.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.307]                         if (muffled) 
[17:59:29.307]                           invokeRestart("muffleMessage")
[17:59:29.307]                       }
[17:59:29.307]                       else if (inherits(cond, "warning")) {
[17:59:29.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.307]                         if (muffled) 
[17:59:29.307]                           invokeRestart("muffleWarning")
[17:59:29.307]                       }
[17:59:29.307]                       else if (inherits(cond, "condition")) {
[17:59:29.307]                         if (!is.null(pattern)) {
[17:59:29.307]                           computeRestarts <- base::computeRestarts
[17:59:29.307]                           grepl <- base::grepl
[17:59:29.307]                           restarts <- computeRestarts(cond)
[17:59:29.307]                           for (restart in restarts) {
[17:59:29.307]                             name <- restart$name
[17:59:29.307]                             if (is.null(name)) 
[17:59:29.307]                               next
[17:59:29.307]                             if (!grepl(pattern, name)) 
[17:59:29.307]                               next
[17:59:29.307]                             invokeRestart(restart)
[17:59:29.307]                             muffled <- TRUE
[17:59:29.307]                             break
[17:59:29.307]                           }
[17:59:29.307]                         }
[17:59:29.307]                       }
[17:59:29.307]                       invisible(muffled)
[17:59:29.307]                     }
[17:59:29.307]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.307]                   }
[17:59:29.307]                 }
[17:59:29.307]                 else {
[17:59:29.307]                   if (TRUE) {
[17:59:29.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.307]                     {
[17:59:29.307]                       inherits <- base::inherits
[17:59:29.307]                       invokeRestart <- base::invokeRestart
[17:59:29.307]                       is.null <- base::is.null
[17:59:29.307]                       muffled <- FALSE
[17:59:29.307]                       if (inherits(cond, "message")) {
[17:59:29.307]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.307]                         if (muffled) 
[17:59:29.307]                           invokeRestart("muffleMessage")
[17:59:29.307]                       }
[17:59:29.307]                       else if (inherits(cond, "warning")) {
[17:59:29.307]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.307]                         if (muffled) 
[17:59:29.307]                           invokeRestart("muffleWarning")
[17:59:29.307]                       }
[17:59:29.307]                       else if (inherits(cond, "condition")) {
[17:59:29.307]                         if (!is.null(pattern)) {
[17:59:29.307]                           computeRestarts <- base::computeRestarts
[17:59:29.307]                           grepl <- base::grepl
[17:59:29.307]                           restarts <- computeRestarts(cond)
[17:59:29.307]                           for (restart in restarts) {
[17:59:29.307]                             name <- restart$name
[17:59:29.307]                             if (is.null(name)) 
[17:59:29.307]                               next
[17:59:29.307]                             if (!grepl(pattern, name)) 
[17:59:29.307]                               next
[17:59:29.307]                             invokeRestart(restart)
[17:59:29.307]                             muffled <- TRUE
[17:59:29.307]                             break
[17:59:29.307]                           }
[17:59:29.307]                         }
[17:59:29.307]                       }
[17:59:29.307]                       invisible(muffled)
[17:59:29.307]                     }
[17:59:29.307]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.307]                   }
[17:59:29.307]                 }
[17:59:29.307]             }
[17:59:29.307]         }))
[17:59:29.307]     }, error = function(ex) {
[17:59:29.307]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.307]                 ...future.rng), started = ...future.startTime, 
[17:59:29.307]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.307]             version = "1.8"), class = "FutureResult")
[17:59:29.307]     }, finally = {
[17:59:29.307]         if (!identical(...future.workdir, getwd())) 
[17:59:29.307]             setwd(...future.workdir)
[17:59:29.307]         {
[17:59:29.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.307]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.307]             }
[17:59:29.307]             base::options(...future.oldOptions)
[17:59:29.307]             if (.Platform$OS.type == "windows") {
[17:59:29.307]                 old_names <- names(...future.oldEnvVars)
[17:59:29.307]                 envs <- base::Sys.getenv()
[17:59:29.307]                 names <- names(envs)
[17:59:29.307]                 common <- intersect(names, old_names)
[17:59:29.307]                 added <- setdiff(names, old_names)
[17:59:29.307]                 removed <- setdiff(old_names, names)
[17:59:29.307]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.307]                   envs[common]]
[17:59:29.307]                 NAMES <- toupper(changed)
[17:59:29.307]                 args <- list()
[17:59:29.307]                 for (kk in seq_along(NAMES)) {
[17:59:29.307]                   name <- changed[[kk]]
[17:59:29.307]                   NAME <- NAMES[[kk]]
[17:59:29.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.307]                     next
[17:59:29.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.307]                 }
[17:59:29.307]                 NAMES <- toupper(added)
[17:59:29.307]                 for (kk in seq_along(NAMES)) {
[17:59:29.307]                   name <- added[[kk]]
[17:59:29.307]                   NAME <- NAMES[[kk]]
[17:59:29.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.307]                     next
[17:59:29.307]                   args[[name]] <- ""
[17:59:29.307]                 }
[17:59:29.307]                 NAMES <- toupper(removed)
[17:59:29.307]                 for (kk in seq_along(NAMES)) {
[17:59:29.307]                   name <- removed[[kk]]
[17:59:29.307]                   NAME <- NAMES[[kk]]
[17:59:29.307]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.307]                     next
[17:59:29.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.307]                 }
[17:59:29.307]                 if (length(args) > 0) 
[17:59:29.307]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.307]             }
[17:59:29.307]             else {
[17:59:29.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.307]             }
[17:59:29.307]             {
[17:59:29.307]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.307]                   0L) {
[17:59:29.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.307]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.307]                   base::options(opts)
[17:59:29.307]                 }
[17:59:29.307]                 {
[17:59:29.307]                   {
[17:59:29.307]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.307]                     NULL
[17:59:29.307]                   }
[17:59:29.307]                   options(future.plan = NULL)
[17:59:29.307]                   if (is.na(NA_character_)) 
[17:59:29.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.307]                     .init = FALSE)
[17:59:29.307]                 }
[17:59:29.307]             }
[17:59:29.307]         }
[17:59:29.307]     })
[17:59:29.307]     if (TRUE) {
[17:59:29.307]         base::sink(type = "output", split = FALSE)
[17:59:29.307]         if (TRUE) {
[17:59:29.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.307]         }
[17:59:29.307]         else {
[17:59:29.307]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.307]         }
[17:59:29.307]         base::close(...future.stdout)
[17:59:29.307]         ...future.stdout <- NULL
[17:59:29.307]     }
[17:59:29.307]     ...future.result$conditions <- ...future.conditions
[17:59:29.307]     ...future.result$finished <- base::Sys.time()
[17:59:29.307]     ...future.result
[17:59:29.307] }
[17:59:29.312] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[17:59:29.312] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:59:29.313] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:59:29.314] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:59:29.314] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:59:29.315] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[17:59:29.315] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[17:59:29.316] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:29.316] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.317] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:29.318] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.318] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[17:59:29.319] MultisessionFuture started
[17:59:29.319] - Launch lazy future ... done
[17:59:29.319] run() for ‘MultisessionFuture’ ... done
[17:59:29.319] Created future:
[17:59:29.320] MultisessionFuture:
[17:59:29.320] Label: ‘future_by-2’
[17:59:29.320] Expression:
[17:59:29.320] {
[17:59:29.320]     do.call(function(...) {
[17:59:29.320]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.320]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.320]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.320]             on.exit(options(oopts), add = TRUE)
[17:59:29.320]         }
[17:59:29.320]         {
[17:59:29.320]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.320]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.320]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.320]             })
[17:59:29.320]         }
[17:59:29.320]     }, args = future.call.arguments)
[17:59:29.320] }
[17:59:29.320] Lazy evaluation: FALSE
[17:59:29.320] Asynchronous evaluation: TRUE
[17:59:29.320] Local evaluation: TRUE
[17:59:29.320] Environment: R_GlobalEnv
[17:59:29.320] Capture standard output: TRUE
[17:59:29.320] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.320] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:29.320] Packages: <none>
[17:59:29.320] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.320] Resolved: FALSE
[17:59:29.320] Value: <not collected>
[17:59:29.320] Conditions captured: <none>
[17:59:29.320] Early signaling: FALSE
[17:59:29.320] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.320] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.333] Chunk #2 of 2 ... DONE
[17:59:29.333] Launching 2 futures (chunks) ... DONE
[17:59:29.333] Resolving 2 futures (chunks) ...
[17:59:29.333] resolve() on list ...
[17:59:29.333]  recursive: 0
[17:59:29.334]  length: 2
[17:59:29.334] 
[17:59:29.335] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.335] - Validating connection of MultisessionFuture
[17:59:29.335] - received message: FutureResult
[17:59:29.335] - Received FutureResult
[17:59:29.336] - Erased future from FutureRegistry
[17:59:29.336] result() for ClusterFuture ...
[17:59:29.336] - result already collected: FutureResult
[17:59:29.336] result() for ClusterFuture ... done
[17:59:29.336] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.337] Future #1
[17:59:29.337] result() for ClusterFuture ...
[17:59:29.337] - result already collected: FutureResult
[17:59:29.337] result() for ClusterFuture ... done
[17:59:29.337] result() for ClusterFuture ...
[17:59:29.338] - result already collected: FutureResult
[17:59:29.338] result() for ClusterFuture ... done
[17:59:29.338] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:29.338] - nx: 2
[17:59:29.339] - relay: TRUE
[17:59:29.339] - stdout: TRUE
[17:59:29.339] - signal: TRUE
[17:59:29.339] - resignal: FALSE
[17:59:29.339] - force: TRUE
[17:59:29.340] - relayed: [n=2] FALSE, FALSE
[17:59:29.340] - queued futures: [n=2] FALSE, FALSE
[17:59:29.341]  - until=1
[17:59:29.342]  - relaying element #1
[17:59:29.342] result() for ClusterFuture ...
[17:59:29.342] - result already collected: FutureResult
[17:59:29.342] result() for ClusterFuture ... done
[17:59:29.342] result() for ClusterFuture ...
[17:59:29.343] - result already collected: FutureResult
[17:59:29.343] result() for ClusterFuture ... done
[17:59:29.343] result() for ClusterFuture ...
[17:59:29.344] - result already collected: FutureResult
[17:59:29.344] result() for ClusterFuture ... done
[17:59:29.344] result() for ClusterFuture ...
[17:59:29.344] - result already collected: FutureResult
[17:59:29.344] result() for ClusterFuture ... done
[17:59:29.345] - relayed: [n=2] TRUE, FALSE
[17:59:29.345] - queued futures: [n=2] TRUE, FALSE
[17:59:29.345] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:29.345]  length: 1 (resolved future 1)
[17:59:29.368] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.368] - Validating connection of MultisessionFuture
[17:59:29.368] - received message: FutureResult
[17:59:29.368] - Received FutureResult
[17:59:29.369] - Erased future from FutureRegistry
[17:59:29.369] result() for ClusterFuture ...
[17:59:29.369] - result already collected: FutureResult
[17:59:29.369] result() for ClusterFuture ... done
[17:59:29.370] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.370] Future #2
[17:59:29.370] result() for ClusterFuture ...
[17:59:29.370] - result already collected: FutureResult
[17:59:29.370] result() for ClusterFuture ... done
[17:59:29.371] result() for ClusterFuture ...
[17:59:29.371] - result already collected: FutureResult
[17:59:29.372] result() for ClusterFuture ... done
[17:59:29.372] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:29.372] - nx: 2
[17:59:29.372] - relay: TRUE
[17:59:29.373] - stdout: TRUE
[17:59:29.373] - signal: TRUE
[17:59:29.373] - resignal: FALSE
[17:59:29.373] - force: TRUE
[17:59:29.373] - relayed: [n=2] TRUE, FALSE
[17:59:29.373] - queued futures: [n=2] TRUE, FALSE
[17:59:29.374]  - until=2
[17:59:29.374]  - relaying element #2
[17:59:29.374] result() for ClusterFuture ...
[17:59:29.374] - result already collected: FutureResult
[17:59:29.374] result() for ClusterFuture ... done
[17:59:29.375] result() for ClusterFuture ...
[17:59:29.375] - result already collected: FutureResult
[17:59:29.375] result() for ClusterFuture ... done
[17:59:29.375] result() for ClusterFuture ...
[17:59:29.376] - result already collected: FutureResult
[17:59:29.376] result() for ClusterFuture ... done
[17:59:29.376] result() for ClusterFuture ...
[17:59:29.376] - result already collected: FutureResult
[17:59:29.376] result() for ClusterFuture ... done
[17:59:29.376] - relayed: [n=2] TRUE, TRUE
[17:59:29.377] - queued futures: [n=2] TRUE, TRUE
[17:59:29.377] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:29.377]  length: 0 (resolved future 2)
[17:59:29.377] Relaying remaining futures
[17:59:29.378] signalConditionsASAP(NULL, pos=0) ...
[17:59:29.378] - nx: 2
[17:59:29.378] - relay: TRUE
[17:59:29.378] - stdout: TRUE
[17:59:29.378] - signal: TRUE
[17:59:29.378] - resignal: FALSE
[17:59:29.379] - force: TRUE
[17:59:29.379] - relayed: [n=2] TRUE, TRUE
[17:59:29.379] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:29.379] - relayed: [n=2] TRUE, TRUE
[17:59:29.379] - queued futures: [n=2] TRUE, TRUE
[17:59:29.380] signalConditionsASAP(NULL, pos=0) ... done
[17:59:29.380] resolve() on list ... DONE
[17:59:29.380] result() for ClusterFuture ...
[17:59:29.380] - result already collected: FutureResult
[17:59:29.380] result() for ClusterFuture ... done
[17:59:29.381] result() for ClusterFuture ...
[17:59:29.381] - result already collected: FutureResult
[17:59:29.381] result() for ClusterFuture ... done
[17:59:29.381] result() for ClusterFuture ...
[17:59:29.381] - result already collected: FutureResult
[17:59:29.382] result() for ClusterFuture ... done
[17:59:29.382] result() for ClusterFuture ...
[17:59:29.382] - result already collected: FutureResult
[17:59:29.382] result() for ClusterFuture ... done
[17:59:29.382]  - Number of value chunks collected: 2
[17:59:29.383] Resolving 2 futures (chunks) ... DONE
[17:59:29.383] Reducing values from 2 chunks ...
[17:59:29.383]  - Number of values collected after concatenation: 6
[17:59:29.383]  - Number of values expected: 6
[17:59:29.383] Reducing values from 2 chunks ... DONE
[17:59:29.384] future_lapply() ... DONE
[17:59:29.384] future_by_internal() ... DONE
[17:59:29.386] future_by_internal() ...
[17:59:29.387] future_lapply() ...
[17:59:29.395] Number of chunks: 2
[17:59:29.396] getGlobalsAndPackagesXApply() ...
[17:59:29.396]  - future.globals: TRUE
[17:59:29.396] getGlobalsAndPackages() ...
[17:59:29.396] Searching for globals...
[17:59:29.400] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:29.400] Searching for globals ... DONE
[17:59:29.400] Resolving globals: FALSE
[17:59:29.401] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[17:59:29.402] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[17:59:29.403] - globals: [1] ‘FUN’
[17:59:29.403] - packages: [1] ‘stats’
[17:59:29.403] getGlobalsAndPackages() ... DONE
[17:59:29.403]  - globals found/used: [n=1] ‘FUN’
[17:59:29.403]  - needed namespaces: [n=1] ‘stats’
[17:59:29.404] Finding globals ... DONE
[17:59:29.404]  - use_args: TRUE
[17:59:29.404]  - Getting '...' globals ...
[17:59:29.405] resolve() on list ...
[17:59:29.405]  recursive: 0
[17:59:29.405]  length: 1
[17:59:29.405]  elements: ‘...’
[17:59:29.406]  length: 0 (resolved future 1)
[17:59:29.406] resolve() on list ... DONE
[17:59:29.406]    - '...' content: [n=1] ‘singular.ok’
[17:59:29.406] List of 1
[17:59:29.406]  $ ...:List of 1
[17:59:29.406]   ..$ singular.ok: logi FALSE
[17:59:29.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.406]  - attr(*, "where")=List of 1
[17:59:29.406]   ..$ ...:<environment: 0x6264a1ec37f8> 
[17:59:29.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.406]  - attr(*, "resolved")= logi TRUE
[17:59:29.406]  - attr(*, "total_size")= num NA
[17:59:29.413]  - Getting '...' globals ... DONE
[17:59:29.413] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:29.413] List of 2
[17:59:29.413]  $ ...future.FUN:function (x, ...)  
[17:59:29.413]  $ ...          :List of 1
[17:59:29.413]   ..$ singular.ok: logi FALSE
[17:59:29.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.413]  - attr(*, "where")=List of 2
[17:59:29.413]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:29.413]   ..$ ...          :<environment: 0x6264a1ec37f8> 
[17:59:29.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.413]  - attr(*, "resolved")= logi FALSE
[17:59:29.413]  - attr(*, "total_size")= num 5384
[17:59:29.421] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:29.422] getGlobalsAndPackagesXApply() ... DONE
[17:59:29.422] Number of futures (= number of chunks): 2
[17:59:29.422] Launching 2 futures (chunks) ...
[17:59:29.423] Chunk #1 of 2 ...
[17:59:29.423]  - Finding globals in 'X' for chunk #1 ...
[17:59:29.423] getGlobalsAndPackages() ...
[17:59:29.423] Searching for globals...
[17:59:29.424] 
[17:59:29.424] Searching for globals ... DONE
[17:59:29.425] - globals: [0] <none>
[17:59:29.425] getGlobalsAndPackages() ... DONE
[17:59:29.425]    + additional globals found: [n=0] 
[17:59:29.425]    + additional namespaces needed: [n=0] 
[17:59:29.425]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:29.426]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.426]  - seeds: <none>
[17:59:29.426]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.426] getGlobalsAndPackages() ...
[17:59:29.426] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.427] Resolving globals: FALSE
[17:59:29.427] Tweak future expression to call with '...' arguments ...
[17:59:29.427] {
[17:59:29.427]     do.call(function(...) {
[17:59:29.427]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.427]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.427]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.427]             on.exit(options(oopts), add = TRUE)
[17:59:29.427]         }
[17:59:29.427]         {
[17:59:29.427]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.427]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.427]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.427]             })
[17:59:29.427]         }
[17:59:29.427]     }, args = future.call.arguments)
[17:59:29.427] }
[17:59:29.428] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.428] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.429] 
[17:59:29.429] getGlobalsAndPackages() ... DONE
[17:59:29.430] run() for ‘Future’ ...
[17:59:29.430] - state: ‘created’
[17:59:29.430] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.460] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.460]   - Field: ‘node’
[17:59:29.461]   - Field: ‘label’
[17:59:29.461]   - Field: ‘local’
[17:59:29.461]   - Field: ‘owner’
[17:59:29.461]   - Field: ‘envir’
[17:59:29.461]   - Field: ‘workers’
[17:59:29.462]   - Field: ‘packages’
[17:59:29.462]   - Field: ‘gc’
[17:59:29.462]   - Field: ‘conditions’
[17:59:29.462]   - Field: ‘persistent’
[17:59:29.462]   - Field: ‘expr’
[17:59:29.463]   - Field: ‘uuid’
[17:59:29.463]   - Field: ‘seed’
[17:59:29.463]   - Field: ‘version’
[17:59:29.463]   - Field: ‘result’
[17:59:29.463]   - Field: ‘asynchronous’
[17:59:29.464]   - Field: ‘calls’
[17:59:29.464]   - Field: ‘globals’
[17:59:29.464]   - Field: ‘stdout’
[17:59:29.464]   - Field: ‘earlySignal’
[17:59:29.464]   - Field: ‘lazy’
[17:59:29.465]   - Field: ‘state’
[17:59:29.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.465] - Launch lazy future ...
[17:59:29.466] Packages needed by the future expression (n = 1): ‘stats’
[17:59:29.466] Packages needed by future strategies (n = 0): <none>
[17:59:29.467] {
[17:59:29.467]     {
[17:59:29.467]         {
[17:59:29.467]             ...future.startTime <- base::Sys.time()
[17:59:29.467]             {
[17:59:29.467]                 {
[17:59:29.467]                   {
[17:59:29.467]                     {
[17:59:29.467]                       {
[17:59:29.467]                         base::local({
[17:59:29.467]                           has_future <- base::requireNamespace("future", 
[17:59:29.467]                             quietly = TRUE)
[17:59:29.467]                           if (has_future) {
[17:59:29.467]                             ns <- base::getNamespace("future")
[17:59:29.467]                             version <- ns[[".package"]][["version"]]
[17:59:29.467]                             if (is.null(version)) 
[17:59:29.467]                               version <- utils::packageVersion("future")
[17:59:29.467]                           }
[17:59:29.467]                           else {
[17:59:29.467]                             version <- NULL
[17:59:29.467]                           }
[17:59:29.467]                           if (!has_future || version < "1.8.0") {
[17:59:29.467]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.467]                               "", base::R.version$version.string), 
[17:59:29.467]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:29.467]                                 base::R.version$platform, 8 * 
[17:59:29.467]                                   base::.Machine$sizeof.pointer), 
[17:59:29.467]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.467]                                 "release", "version")], collapse = " "), 
[17:59:29.467]                               hostname = base::Sys.info()[["nodename"]])
[17:59:29.467]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.467]                               info)
[17:59:29.467]                             info <- base::paste(info, collapse = "; ")
[17:59:29.467]                             if (!has_future) {
[17:59:29.467]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.467]                                 info)
[17:59:29.467]                             }
[17:59:29.467]                             else {
[17:59:29.467]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.467]                                 info, version)
[17:59:29.467]                             }
[17:59:29.467]                             base::stop(msg)
[17:59:29.467]                           }
[17:59:29.467]                         })
[17:59:29.467]                       }
[17:59:29.467]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.467]                       base::options(mc.cores = 1L)
[17:59:29.467]                     }
[17:59:29.467]                     base::local({
[17:59:29.467]                       for (pkg in "stats") {
[17:59:29.467]                         base::loadNamespace(pkg)
[17:59:29.467]                         base::library(pkg, character.only = TRUE)
[17:59:29.467]                       }
[17:59:29.467]                     })
[17:59:29.467]                   }
[17:59:29.467]                   ...future.strategy.old <- future::plan("list")
[17:59:29.467]                   options(future.plan = NULL)
[17:59:29.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.467]                 }
[17:59:29.467]                 ...future.workdir <- getwd()
[17:59:29.467]             }
[17:59:29.467]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.467]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.467]         }
[17:59:29.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.467]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.467]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.467]             base::names(...future.oldOptions))
[17:59:29.467]     }
[17:59:29.467]     if (FALSE) {
[17:59:29.467]     }
[17:59:29.467]     else {
[17:59:29.467]         if (TRUE) {
[17:59:29.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.467]                 open = "w")
[17:59:29.467]         }
[17:59:29.467]         else {
[17:59:29.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.467]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.467]         }
[17:59:29.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.467]             base::sink(type = "output", split = FALSE)
[17:59:29.467]             base::close(...future.stdout)
[17:59:29.467]         }, add = TRUE)
[17:59:29.467]     }
[17:59:29.467]     ...future.frame <- base::sys.nframe()
[17:59:29.467]     ...future.conditions <- base::list()
[17:59:29.467]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.467]     if (FALSE) {
[17:59:29.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.467]     }
[17:59:29.467]     ...future.result <- base::tryCatch({
[17:59:29.467]         base::withCallingHandlers({
[17:59:29.467]             ...future.value <- base::withVisible(base::local({
[17:59:29.467]                 ...future.makeSendCondition <- base::local({
[17:59:29.467]                   sendCondition <- NULL
[17:59:29.467]                   function(frame = 1L) {
[17:59:29.467]                     if (is.function(sendCondition)) 
[17:59:29.467]                       return(sendCondition)
[17:59:29.467]                     ns <- getNamespace("parallel")
[17:59:29.467]                     if (exists("sendData", mode = "function", 
[17:59:29.467]                       envir = ns)) {
[17:59:29.467]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.467]                         envir = ns)
[17:59:29.467]                       envir <- sys.frame(frame)
[17:59:29.467]                       master <- NULL
[17:59:29.467]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.467]                         !identical(envir, emptyenv())) {
[17:59:29.467]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.467]                           inherits = FALSE)) {
[17:59:29.467]                           master <- get("master", mode = "list", 
[17:59:29.467]                             envir = envir, inherits = FALSE)
[17:59:29.467]                           if (inherits(master, c("SOCKnode", 
[17:59:29.467]                             "SOCK0node"))) {
[17:59:29.467]                             sendCondition <<- function(cond) {
[17:59:29.467]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.467]                                 success = TRUE)
[17:59:29.467]                               parallel_sendData(master, data)
[17:59:29.467]                             }
[17:59:29.467]                             return(sendCondition)
[17:59:29.467]                           }
[17:59:29.467]                         }
[17:59:29.467]                         frame <- frame + 1L
[17:59:29.467]                         envir <- sys.frame(frame)
[17:59:29.467]                       }
[17:59:29.467]                     }
[17:59:29.467]                     sendCondition <<- function(cond) NULL
[17:59:29.467]                   }
[17:59:29.467]                 })
[17:59:29.467]                 withCallingHandlers({
[17:59:29.467]                   {
[17:59:29.467]                     do.call(function(...) {
[17:59:29.467]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.467]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.467]                         ...future.globals.maxSize)) {
[17:59:29.467]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.467]                         on.exit(options(oopts), add = TRUE)
[17:59:29.467]                       }
[17:59:29.467]                       {
[17:59:29.467]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.467]                           FUN = function(jj) {
[17:59:29.467]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.467]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.467]                           })
[17:59:29.467]                       }
[17:59:29.467]                     }, args = future.call.arguments)
[17:59:29.467]                   }
[17:59:29.467]                 }, immediateCondition = function(cond) {
[17:59:29.467]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.467]                   sendCondition(cond)
[17:59:29.467]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.467]                   {
[17:59:29.467]                     inherits <- base::inherits
[17:59:29.467]                     invokeRestart <- base::invokeRestart
[17:59:29.467]                     is.null <- base::is.null
[17:59:29.467]                     muffled <- FALSE
[17:59:29.467]                     if (inherits(cond, "message")) {
[17:59:29.467]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.467]                       if (muffled) 
[17:59:29.467]                         invokeRestart("muffleMessage")
[17:59:29.467]                     }
[17:59:29.467]                     else if (inherits(cond, "warning")) {
[17:59:29.467]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.467]                       if (muffled) 
[17:59:29.467]                         invokeRestart("muffleWarning")
[17:59:29.467]                     }
[17:59:29.467]                     else if (inherits(cond, "condition")) {
[17:59:29.467]                       if (!is.null(pattern)) {
[17:59:29.467]                         computeRestarts <- base::computeRestarts
[17:59:29.467]                         grepl <- base::grepl
[17:59:29.467]                         restarts <- computeRestarts(cond)
[17:59:29.467]                         for (restart in restarts) {
[17:59:29.467]                           name <- restart$name
[17:59:29.467]                           if (is.null(name)) 
[17:59:29.467]                             next
[17:59:29.467]                           if (!grepl(pattern, name)) 
[17:59:29.467]                             next
[17:59:29.467]                           invokeRestart(restart)
[17:59:29.467]                           muffled <- TRUE
[17:59:29.467]                           break
[17:59:29.467]                         }
[17:59:29.467]                       }
[17:59:29.467]                     }
[17:59:29.467]                     invisible(muffled)
[17:59:29.467]                   }
[17:59:29.467]                   muffleCondition(cond)
[17:59:29.467]                 })
[17:59:29.467]             }))
[17:59:29.467]             future::FutureResult(value = ...future.value$value, 
[17:59:29.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.467]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.467]                     ...future.globalenv.names))
[17:59:29.467]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.467]         }, condition = base::local({
[17:59:29.467]             c <- base::c
[17:59:29.467]             inherits <- base::inherits
[17:59:29.467]             invokeRestart <- base::invokeRestart
[17:59:29.467]             length <- base::length
[17:59:29.467]             list <- base::list
[17:59:29.467]             seq.int <- base::seq.int
[17:59:29.467]             signalCondition <- base::signalCondition
[17:59:29.467]             sys.calls <- base::sys.calls
[17:59:29.467]             `[[` <- base::`[[`
[17:59:29.467]             `+` <- base::`+`
[17:59:29.467]             `<<-` <- base::`<<-`
[17:59:29.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.467]                   3L)]
[17:59:29.467]             }
[17:59:29.467]             function(cond) {
[17:59:29.467]                 is_error <- inherits(cond, "error")
[17:59:29.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.467]                   NULL)
[17:59:29.467]                 if (is_error) {
[17:59:29.467]                   sessionInformation <- function() {
[17:59:29.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.467]                       search = base::search(), system = base::Sys.info())
[17:59:29.467]                   }
[17:59:29.467]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.467]                     cond$call), session = sessionInformation(), 
[17:59:29.467]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.467]                   signalCondition(cond)
[17:59:29.467]                 }
[17:59:29.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.467]                 "immediateCondition"))) {
[17:59:29.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.467]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.467]                   if (TRUE && !signal) {
[17:59:29.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.467]                     {
[17:59:29.467]                       inherits <- base::inherits
[17:59:29.467]                       invokeRestart <- base::invokeRestart
[17:59:29.467]                       is.null <- base::is.null
[17:59:29.467]                       muffled <- FALSE
[17:59:29.467]                       if (inherits(cond, "message")) {
[17:59:29.467]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.467]                         if (muffled) 
[17:59:29.467]                           invokeRestart("muffleMessage")
[17:59:29.467]                       }
[17:59:29.467]                       else if (inherits(cond, "warning")) {
[17:59:29.467]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.467]                         if (muffled) 
[17:59:29.467]                           invokeRestart("muffleWarning")
[17:59:29.467]                       }
[17:59:29.467]                       else if (inherits(cond, "condition")) {
[17:59:29.467]                         if (!is.null(pattern)) {
[17:59:29.467]                           computeRestarts <- base::computeRestarts
[17:59:29.467]                           grepl <- base::grepl
[17:59:29.467]                           restarts <- computeRestarts(cond)
[17:59:29.467]                           for (restart in restarts) {
[17:59:29.467]                             name <- restart$name
[17:59:29.467]                             if (is.null(name)) 
[17:59:29.467]                               next
[17:59:29.467]                             if (!grepl(pattern, name)) 
[17:59:29.467]                               next
[17:59:29.467]                             invokeRestart(restart)
[17:59:29.467]                             muffled <- TRUE
[17:59:29.467]                             break
[17:59:29.467]                           }
[17:59:29.467]                         }
[17:59:29.467]                       }
[17:59:29.467]                       invisible(muffled)
[17:59:29.467]                     }
[17:59:29.467]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.467]                   }
[17:59:29.467]                 }
[17:59:29.467]                 else {
[17:59:29.467]                   if (TRUE) {
[17:59:29.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.467]                     {
[17:59:29.467]                       inherits <- base::inherits
[17:59:29.467]                       invokeRestart <- base::invokeRestart
[17:59:29.467]                       is.null <- base::is.null
[17:59:29.467]                       muffled <- FALSE
[17:59:29.467]                       if (inherits(cond, "message")) {
[17:59:29.467]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.467]                         if (muffled) 
[17:59:29.467]                           invokeRestart("muffleMessage")
[17:59:29.467]                       }
[17:59:29.467]                       else if (inherits(cond, "warning")) {
[17:59:29.467]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.467]                         if (muffled) 
[17:59:29.467]                           invokeRestart("muffleWarning")
[17:59:29.467]                       }
[17:59:29.467]                       else if (inherits(cond, "condition")) {
[17:59:29.467]                         if (!is.null(pattern)) {
[17:59:29.467]                           computeRestarts <- base::computeRestarts
[17:59:29.467]                           grepl <- base::grepl
[17:59:29.467]                           restarts <- computeRestarts(cond)
[17:59:29.467]                           for (restart in restarts) {
[17:59:29.467]                             name <- restart$name
[17:59:29.467]                             if (is.null(name)) 
[17:59:29.467]                               next
[17:59:29.467]                             if (!grepl(pattern, name)) 
[17:59:29.467]                               next
[17:59:29.467]                             invokeRestart(restart)
[17:59:29.467]                             muffled <- TRUE
[17:59:29.467]                             break
[17:59:29.467]                           }
[17:59:29.467]                         }
[17:59:29.467]                       }
[17:59:29.467]                       invisible(muffled)
[17:59:29.467]                     }
[17:59:29.467]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.467]                   }
[17:59:29.467]                 }
[17:59:29.467]             }
[17:59:29.467]         }))
[17:59:29.467]     }, error = function(ex) {
[17:59:29.467]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.467]                 ...future.rng), started = ...future.startTime, 
[17:59:29.467]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.467]             version = "1.8"), class = "FutureResult")
[17:59:29.467]     }, finally = {
[17:59:29.467]         if (!identical(...future.workdir, getwd())) 
[17:59:29.467]             setwd(...future.workdir)
[17:59:29.467]         {
[17:59:29.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.467]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.467]             }
[17:59:29.467]             base::options(...future.oldOptions)
[17:59:29.467]             if (.Platform$OS.type == "windows") {
[17:59:29.467]                 old_names <- names(...future.oldEnvVars)
[17:59:29.467]                 envs <- base::Sys.getenv()
[17:59:29.467]                 names <- names(envs)
[17:59:29.467]                 common <- intersect(names, old_names)
[17:59:29.467]                 added <- setdiff(names, old_names)
[17:59:29.467]                 removed <- setdiff(old_names, names)
[17:59:29.467]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.467]                   envs[common]]
[17:59:29.467]                 NAMES <- toupper(changed)
[17:59:29.467]                 args <- list()
[17:59:29.467]                 for (kk in seq_along(NAMES)) {
[17:59:29.467]                   name <- changed[[kk]]
[17:59:29.467]                   NAME <- NAMES[[kk]]
[17:59:29.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.467]                     next
[17:59:29.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.467]                 }
[17:59:29.467]                 NAMES <- toupper(added)
[17:59:29.467]                 for (kk in seq_along(NAMES)) {
[17:59:29.467]                   name <- added[[kk]]
[17:59:29.467]                   NAME <- NAMES[[kk]]
[17:59:29.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.467]                     next
[17:59:29.467]                   args[[name]] <- ""
[17:59:29.467]                 }
[17:59:29.467]                 NAMES <- toupper(removed)
[17:59:29.467]                 for (kk in seq_along(NAMES)) {
[17:59:29.467]                   name <- removed[[kk]]
[17:59:29.467]                   NAME <- NAMES[[kk]]
[17:59:29.467]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.467]                     next
[17:59:29.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.467]                 }
[17:59:29.467]                 if (length(args) > 0) 
[17:59:29.467]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.467]             }
[17:59:29.467]             else {
[17:59:29.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.467]             }
[17:59:29.467]             {
[17:59:29.467]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.467]                   0L) {
[17:59:29.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.467]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.467]                   base::options(opts)
[17:59:29.467]                 }
[17:59:29.467]                 {
[17:59:29.467]                   {
[17:59:29.467]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.467]                     NULL
[17:59:29.467]                   }
[17:59:29.467]                   options(future.plan = NULL)
[17:59:29.467]                   if (is.na(NA_character_)) 
[17:59:29.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.467]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.467]                     .init = FALSE)
[17:59:29.467]                 }
[17:59:29.467]             }
[17:59:29.467]         }
[17:59:29.467]     })
[17:59:29.467]     if (TRUE) {
[17:59:29.467]         base::sink(type = "output", split = FALSE)
[17:59:29.467]         if (TRUE) {
[17:59:29.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.467]         }
[17:59:29.467]         else {
[17:59:29.467]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.467]         }
[17:59:29.467]         base::close(...future.stdout)
[17:59:29.467]         ...future.stdout <- NULL
[17:59:29.467]     }
[17:59:29.467]     ...future.result$conditions <- ...future.conditions
[17:59:29.467]     ...future.result$finished <- base::Sys.time()
[17:59:29.467]     ...future.result
[17:59:29.467] }
[17:59:29.472] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[17:59:29.473] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[17:59:29.473] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[17:59:29.474] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[17:59:29.475] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[17:59:29.475] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:59:29.476] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:59:29.476] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:29.477] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.477] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:29.478] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.478] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[17:59:29.479] MultisessionFuture started
[17:59:29.480] - Launch lazy future ... done
[17:59:29.480] run() for ‘MultisessionFuture’ ... done
[17:59:29.480] Created future:
[17:59:29.480] MultisessionFuture:
[17:59:29.480] Label: ‘future_by-1’
[17:59:29.480] Expression:
[17:59:29.480] {
[17:59:29.480]     do.call(function(...) {
[17:59:29.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.480]             on.exit(options(oopts), add = TRUE)
[17:59:29.480]         }
[17:59:29.480]         {
[17:59:29.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.480]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.480]             })
[17:59:29.480]         }
[17:59:29.480]     }, args = future.call.arguments)
[17:59:29.480] }
[17:59:29.480] Lazy evaluation: FALSE
[17:59:29.480] Asynchronous evaluation: TRUE
[17:59:29.480] Local evaluation: TRUE
[17:59:29.480] Environment: R_GlobalEnv
[17:59:29.480] Capture standard output: TRUE
[17:59:29.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.480] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:29.480] Packages: 1 packages (‘stats’)
[17:59:29.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.480] Resolved: FALSE
[17:59:29.480] Value: <not collected>
[17:59:29.480] Conditions captured: <none>
[17:59:29.480] Early signaling: FALSE
[17:59:29.480] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.480] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.493] Chunk #1 of 2 ... DONE
[17:59:29.493] Chunk #2 of 2 ...
[17:59:29.494]  - Finding globals in 'X' for chunk #2 ...
[17:59:29.494] getGlobalsAndPackages() ...
[17:59:29.495] Searching for globals...
[17:59:29.495] 
[17:59:29.496] Searching for globals ... DONE
[17:59:29.496] - globals: [0] <none>
[17:59:29.496] getGlobalsAndPackages() ... DONE
[17:59:29.496]    + additional globals found: [n=0] 
[17:59:29.496]    + additional namespaces needed: [n=0] 
[17:59:29.497]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:29.497]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.497]  - seeds: <none>
[17:59:29.497]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.497] getGlobalsAndPackages() ...
[17:59:29.498] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.498] Resolving globals: FALSE
[17:59:29.498] Tweak future expression to call with '...' arguments ...
[17:59:29.498] {
[17:59:29.498]     do.call(function(...) {
[17:59:29.498]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.498]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.498]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.498]             on.exit(options(oopts), add = TRUE)
[17:59:29.498]         }
[17:59:29.498]         {
[17:59:29.498]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.498]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.498]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.498]             })
[17:59:29.498]         }
[17:59:29.498]     }, args = future.call.arguments)
[17:59:29.498] }
[17:59:29.499] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.499] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.500] 
[17:59:29.500] getGlobalsAndPackages() ... DONE
[17:59:29.500] run() for ‘Future’ ...
[17:59:29.501] - state: ‘created’
[17:59:29.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.524] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.525]   - Field: ‘node’
[17:59:29.525]   - Field: ‘label’
[17:59:29.525]   - Field: ‘local’
[17:59:29.525]   - Field: ‘owner’
[17:59:29.526]   - Field: ‘envir’
[17:59:29.526]   - Field: ‘workers’
[17:59:29.526]   - Field: ‘packages’
[17:59:29.526]   - Field: ‘gc’
[17:59:29.526]   - Field: ‘conditions’
[17:59:29.527]   - Field: ‘persistent’
[17:59:29.527]   - Field: ‘expr’
[17:59:29.527]   - Field: ‘uuid’
[17:59:29.527]   - Field: ‘seed’
[17:59:29.527]   - Field: ‘version’
[17:59:29.528]   - Field: ‘result’
[17:59:29.528]   - Field: ‘asynchronous’
[17:59:29.528]   - Field: ‘calls’
[17:59:29.528]   - Field: ‘globals’
[17:59:29.528]   - Field: ‘stdout’
[17:59:29.529]   - Field: ‘earlySignal’
[17:59:29.529]   - Field: ‘lazy’
[17:59:29.529]   - Field: ‘state’
[17:59:29.529] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.529] - Launch lazy future ...
[17:59:29.530] Packages needed by the future expression (n = 1): ‘stats’
[17:59:29.530] Packages needed by future strategies (n = 0): <none>
[17:59:29.531] {
[17:59:29.531]     {
[17:59:29.531]         {
[17:59:29.531]             ...future.startTime <- base::Sys.time()
[17:59:29.531]             {
[17:59:29.531]                 {
[17:59:29.531]                   {
[17:59:29.531]                     {
[17:59:29.531]                       {
[17:59:29.531]                         base::local({
[17:59:29.531]                           has_future <- base::requireNamespace("future", 
[17:59:29.531]                             quietly = TRUE)
[17:59:29.531]                           if (has_future) {
[17:59:29.531]                             ns <- base::getNamespace("future")
[17:59:29.531]                             version <- ns[[".package"]][["version"]]
[17:59:29.531]                             if (is.null(version)) 
[17:59:29.531]                               version <- utils::packageVersion("future")
[17:59:29.531]                           }
[17:59:29.531]                           else {
[17:59:29.531]                             version <- NULL
[17:59:29.531]                           }
[17:59:29.531]                           if (!has_future || version < "1.8.0") {
[17:59:29.531]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.531]                               "", base::R.version$version.string), 
[17:59:29.531]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:29.531]                                 base::R.version$platform, 8 * 
[17:59:29.531]                                   base::.Machine$sizeof.pointer), 
[17:59:29.531]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.531]                                 "release", "version")], collapse = " "), 
[17:59:29.531]                               hostname = base::Sys.info()[["nodename"]])
[17:59:29.531]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.531]                               info)
[17:59:29.531]                             info <- base::paste(info, collapse = "; ")
[17:59:29.531]                             if (!has_future) {
[17:59:29.531]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.531]                                 info)
[17:59:29.531]                             }
[17:59:29.531]                             else {
[17:59:29.531]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.531]                                 info, version)
[17:59:29.531]                             }
[17:59:29.531]                             base::stop(msg)
[17:59:29.531]                           }
[17:59:29.531]                         })
[17:59:29.531]                       }
[17:59:29.531]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.531]                       base::options(mc.cores = 1L)
[17:59:29.531]                     }
[17:59:29.531]                     base::local({
[17:59:29.531]                       for (pkg in "stats") {
[17:59:29.531]                         base::loadNamespace(pkg)
[17:59:29.531]                         base::library(pkg, character.only = TRUE)
[17:59:29.531]                       }
[17:59:29.531]                     })
[17:59:29.531]                   }
[17:59:29.531]                   ...future.strategy.old <- future::plan("list")
[17:59:29.531]                   options(future.plan = NULL)
[17:59:29.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.531]                 }
[17:59:29.531]                 ...future.workdir <- getwd()
[17:59:29.531]             }
[17:59:29.531]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.531]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.531]         }
[17:59:29.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.531]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.531]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.531]             base::names(...future.oldOptions))
[17:59:29.531]     }
[17:59:29.531]     if (FALSE) {
[17:59:29.531]     }
[17:59:29.531]     else {
[17:59:29.531]         if (TRUE) {
[17:59:29.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.531]                 open = "w")
[17:59:29.531]         }
[17:59:29.531]         else {
[17:59:29.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.531]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.531]         }
[17:59:29.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.531]             base::sink(type = "output", split = FALSE)
[17:59:29.531]             base::close(...future.stdout)
[17:59:29.531]         }, add = TRUE)
[17:59:29.531]     }
[17:59:29.531]     ...future.frame <- base::sys.nframe()
[17:59:29.531]     ...future.conditions <- base::list()
[17:59:29.531]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.531]     if (FALSE) {
[17:59:29.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.531]     }
[17:59:29.531]     ...future.result <- base::tryCatch({
[17:59:29.531]         base::withCallingHandlers({
[17:59:29.531]             ...future.value <- base::withVisible(base::local({
[17:59:29.531]                 ...future.makeSendCondition <- base::local({
[17:59:29.531]                   sendCondition <- NULL
[17:59:29.531]                   function(frame = 1L) {
[17:59:29.531]                     if (is.function(sendCondition)) 
[17:59:29.531]                       return(sendCondition)
[17:59:29.531]                     ns <- getNamespace("parallel")
[17:59:29.531]                     if (exists("sendData", mode = "function", 
[17:59:29.531]                       envir = ns)) {
[17:59:29.531]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.531]                         envir = ns)
[17:59:29.531]                       envir <- sys.frame(frame)
[17:59:29.531]                       master <- NULL
[17:59:29.531]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.531]                         !identical(envir, emptyenv())) {
[17:59:29.531]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.531]                           inherits = FALSE)) {
[17:59:29.531]                           master <- get("master", mode = "list", 
[17:59:29.531]                             envir = envir, inherits = FALSE)
[17:59:29.531]                           if (inherits(master, c("SOCKnode", 
[17:59:29.531]                             "SOCK0node"))) {
[17:59:29.531]                             sendCondition <<- function(cond) {
[17:59:29.531]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.531]                                 success = TRUE)
[17:59:29.531]                               parallel_sendData(master, data)
[17:59:29.531]                             }
[17:59:29.531]                             return(sendCondition)
[17:59:29.531]                           }
[17:59:29.531]                         }
[17:59:29.531]                         frame <- frame + 1L
[17:59:29.531]                         envir <- sys.frame(frame)
[17:59:29.531]                       }
[17:59:29.531]                     }
[17:59:29.531]                     sendCondition <<- function(cond) NULL
[17:59:29.531]                   }
[17:59:29.531]                 })
[17:59:29.531]                 withCallingHandlers({
[17:59:29.531]                   {
[17:59:29.531]                     do.call(function(...) {
[17:59:29.531]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.531]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.531]                         ...future.globals.maxSize)) {
[17:59:29.531]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.531]                         on.exit(options(oopts), add = TRUE)
[17:59:29.531]                       }
[17:59:29.531]                       {
[17:59:29.531]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.531]                           FUN = function(jj) {
[17:59:29.531]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.531]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.531]                           })
[17:59:29.531]                       }
[17:59:29.531]                     }, args = future.call.arguments)
[17:59:29.531]                   }
[17:59:29.531]                 }, immediateCondition = function(cond) {
[17:59:29.531]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.531]                   sendCondition(cond)
[17:59:29.531]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.531]                   {
[17:59:29.531]                     inherits <- base::inherits
[17:59:29.531]                     invokeRestart <- base::invokeRestart
[17:59:29.531]                     is.null <- base::is.null
[17:59:29.531]                     muffled <- FALSE
[17:59:29.531]                     if (inherits(cond, "message")) {
[17:59:29.531]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.531]                       if (muffled) 
[17:59:29.531]                         invokeRestart("muffleMessage")
[17:59:29.531]                     }
[17:59:29.531]                     else if (inherits(cond, "warning")) {
[17:59:29.531]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.531]                       if (muffled) 
[17:59:29.531]                         invokeRestart("muffleWarning")
[17:59:29.531]                     }
[17:59:29.531]                     else if (inherits(cond, "condition")) {
[17:59:29.531]                       if (!is.null(pattern)) {
[17:59:29.531]                         computeRestarts <- base::computeRestarts
[17:59:29.531]                         grepl <- base::grepl
[17:59:29.531]                         restarts <- computeRestarts(cond)
[17:59:29.531]                         for (restart in restarts) {
[17:59:29.531]                           name <- restart$name
[17:59:29.531]                           if (is.null(name)) 
[17:59:29.531]                             next
[17:59:29.531]                           if (!grepl(pattern, name)) 
[17:59:29.531]                             next
[17:59:29.531]                           invokeRestart(restart)
[17:59:29.531]                           muffled <- TRUE
[17:59:29.531]                           break
[17:59:29.531]                         }
[17:59:29.531]                       }
[17:59:29.531]                     }
[17:59:29.531]                     invisible(muffled)
[17:59:29.531]                   }
[17:59:29.531]                   muffleCondition(cond)
[17:59:29.531]                 })
[17:59:29.531]             }))
[17:59:29.531]             future::FutureResult(value = ...future.value$value, 
[17:59:29.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.531]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.531]                     ...future.globalenv.names))
[17:59:29.531]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.531]         }, condition = base::local({
[17:59:29.531]             c <- base::c
[17:59:29.531]             inherits <- base::inherits
[17:59:29.531]             invokeRestart <- base::invokeRestart
[17:59:29.531]             length <- base::length
[17:59:29.531]             list <- base::list
[17:59:29.531]             seq.int <- base::seq.int
[17:59:29.531]             signalCondition <- base::signalCondition
[17:59:29.531]             sys.calls <- base::sys.calls
[17:59:29.531]             `[[` <- base::`[[`
[17:59:29.531]             `+` <- base::`+`
[17:59:29.531]             `<<-` <- base::`<<-`
[17:59:29.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.531]                   3L)]
[17:59:29.531]             }
[17:59:29.531]             function(cond) {
[17:59:29.531]                 is_error <- inherits(cond, "error")
[17:59:29.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.531]                   NULL)
[17:59:29.531]                 if (is_error) {
[17:59:29.531]                   sessionInformation <- function() {
[17:59:29.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.531]                       search = base::search(), system = base::Sys.info())
[17:59:29.531]                   }
[17:59:29.531]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.531]                     cond$call), session = sessionInformation(), 
[17:59:29.531]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.531]                   signalCondition(cond)
[17:59:29.531]                 }
[17:59:29.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.531]                 "immediateCondition"))) {
[17:59:29.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.531]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.531]                   if (TRUE && !signal) {
[17:59:29.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.531]                     {
[17:59:29.531]                       inherits <- base::inherits
[17:59:29.531]                       invokeRestart <- base::invokeRestart
[17:59:29.531]                       is.null <- base::is.null
[17:59:29.531]                       muffled <- FALSE
[17:59:29.531]                       if (inherits(cond, "message")) {
[17:59:29.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.531]                         if (muffled) 
[17:59:29.531]                           invokeRestart("muffleMessage")
[17:59:29.531]                       }
[17:59:29.531]                       else if (inherits(cond, "warning")) {
[17:59:29.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.531]                         if (muffled) 
[17:59:29.531]                           invokeRestart("muffleWarning")
[17:59:29.531]                       }
[17:59:29.531]                       else if (inherits(cond, "condition")) {
[17:59:29.531]                         if (!is.null(pattern)) {
[17:59:29.531]                           computeRestarts <- base::computeRestarts
[17:59:29.531]                           grepl <- base::grepl
[17:59:29.531]                           restarts <- computeRestarts(cond)
[17:59:29.531]                           for (restart in restarts) {
[17:59:29.531]                             name <- restart$name
[17:59:29.531]                             if (is.null(name)) 
[17:59:29.531]                               next
[17:59:29.531]                             if (!grepl(pattern, name)) 
[17:59:29.531]                               next
[17:59:29.531]                             invokeRestart(restart)
[17:59:29.531]                             muffled <- TRUE
[17:59:29.531]                             break
[17:59:29.531]                           }
[17:59:29.531]                         }
[17:59:29.531]                       }
[17:59:29.531]                       invisible(muffled)
[17:59:29.531]                     }
[17:59:29.531]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.531]                   }
[17:59:29.531]                 }
[17:59:29.531]                 else {
[17:59:29.531]                   if (TRUE) {
[17:59:29.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.531]                     {
[17:59:29.531]                       inherits <- base::inherits
[17:59:29.531]                       invokeRestart <- base::invokeRestart
[17:59:29.531]                       is.null <- base::is.null
[17:59:29.531]                       muffled <- FALSE
[17:59:29.531]                       if (inherits(cond, "message")) {
[17:59:29.531]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.531]                         if (muffled) 
[17:59:29.531]                           invokeRestart("muffleMessage")
[17:59:29.531]                       }
[17:59:29.531]                       else if (inherits(cond, "warning")) {
[17:59:29.531]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.531]                         if (muffled) 
[17:59:29.531]                           invokeRestart("muffleWarning")
[17:59:29.531]                       }
[17:59:29.531]                       else if (inherits(cond, "condition")) {
[17:59:29.531]                         if (!is.null(pattern)) {
[17:59:29.531]                           computeRestarts <- base::computeRestarts
[17:59:29.531]                           grepl <- base::grepl
[17:59:29.531]                           restarts <- computeRestarts(cond)
[17:59:29.531]                           for (restart in restarts) {
[17:59:29.531]                             name <- restart$name
[17:59:29.531]                             if (is.null(name)) 
[17:59:29.531]                               next
[17:59:29.531]                             if (!grepl(pattern, name)) 
[17:59:29.531]                               next
[17:59:29.531]                             invokeRestart(restart)
[17:59:29.531]                             muffled <- TRUE
[17:59:29.531]                             break
[17:59:29.531]                           }
[17:59:29.531]                         }
[17:59:29.531]                       }
[17:59:29.531]                       invisible(muffled)
[17:59:29.531]                     }
[17:59:29.531]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.531]                   }
[17:59:29.531]                 }
[17:59:29.531]             }
[17:59:29.531]         }))
[17:59:29.531]     }, error = function(ex) {
[17:59:29.531]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.531]                 ...future.rng), started = ...future.startTime, 
[17:59:29.531]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.531]             version = "1.8"), class = "FutureResult")
[17:59:29.531]     }, finally = {
[17:59:29.531]         if (!identical(...future.workdir, getwd())) 
[17:59:29.531]             setwd(...future.workdir)
[17:59:29.531]         {
[17:59:29.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.531]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.531]             }
[17:59:29.531]             base::options(...future.oldOptions)
[17:59:29.531]             if (.Platform$OS.type == "windows") {
[17:59:29.531]                 old_names <- names(...future.oldEnvVars)
[17:59:29.531]                 envs <- base::Sys.getenv()
[17:59:29.531]                 names <- names(envs)
[17:59:29.531]                 common <- intersect(names, old_names)
[17:59:29.531]                 added <- setdiff(names, old_names)
[17:59:29.531]                 removed <- setdiff(old_names, names)
[17:59:29.531]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.531]                   envs[common]]
[17:59:29.531]                 NAMES <- toupper(changed)
[17:59:29.531]                 args <- list()
[17:59:29.531]                 for (kk in seq_along(NAMES)) {
[17:59:29.531]                   name <- changed[[kk]]
[17:59:29.531]                   NAME <- NAMES[[kk]]
[17:59:29.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.531]                     next
[17:59:29.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.531]                 }
[17:59:29.531]                 NAMES <- toupper(added)
[17:59:29.531]                 for (kk in seq_along(NAMES)) {
[17:59:29.531]                   name <- added[[kk]]
[17:59:29.531]                   NAME <- NAMES[[kk]]
[17:59:29.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.531]                     next
[17:59:29.531]                   args[[name]] <- ""
[17:59:29.531]                 }
[17:59:29.531]                 NAMES <- toupper(removed)
[17:59:29.531]                 for (kk in seq_along(NAMES)) {
[17:59:29.531]                   name <- removed[[kk]]
[17:59:29.531]                   NAME <- NAMES[[kk]]
[17:59:29.531]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.531]                     next
[17:59:29.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.531]                 }
[17:59:29.531]                 if (length(args) > 0) 
[17:59:29.531]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.531]             }
[17:59:29.531]             else {
[17:59:29.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.531]             }
[17:59:29.531]             {
[17:59:29.531]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.531]                   0L) {
[17:59:29.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.531]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.531]                   base::options(opts)
[17:59:29.531]                 }
[17:59:29.531]                 {
[17:59:29.531]                   {
[17:59:29.531]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.531]                     NULL
[17:59:29.531]                   }
[17:59:29.531]                   options(future.plan = NULL)
[17:59:29.531]                   if (is.na(NA_character_)) 
[17:59:29.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.531]                     .init = FALSE)
[17:59:29.531]                 }
[17:59:29.531]             }
[17:59:29.531]         }
[17:59:29.531]     })
[17:59:29.531]     if (TRUE) {
[17:59:29.531]         base::sink(type = "output", split = FALSE)
[17:59:29.531]         if (TRUE) {
[17:59:29.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.531]         }
[17:59:29.531]         else {
[17:59:29.531]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.531]         }
[17:59:29.531]         base::close(...future.stdout)
[17:59:29.531]         ...future.stdout <- NULL
[17:59:29.531]     }
[17:59:29.531]     ...future.result$conditions <- ...future.conditions
[17:59:29.531]     ...future.result$finished <- base::Sys.time()
[17:59:29.531]     ...future.result
[17:59:29.531] }
[17:59:29.536] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[17:59:29.537] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[17:59:29.538] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[17:59:29.538] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[17:59:29.539] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[17:59:29.539] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:59:29.540] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:59:29.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:29.541] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.542] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:29.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.543] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[17:59:29.544] MultisessionFuture started
[17:59:29.544] - Launch lazy future ... done
[17:59:29.544] run() for ‘MultisessionFuture’ ... done
[17:59:29.544] Created future:
[17:59:29.545] MultisessionFuture:
[17:59:29.545] Label: ‘future_by-2’
[17:59:29.545] Expression:
[17:59:29.545] {
[17:59:29.545]     do.call(function(...) {
[17:59:29.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.545]             on.exit(options(oopts), add = TRUE)
[17:59:29.545]         }
[17:59:29.545]         {
[17:59:29.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.545]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.545]             })
[17:59:29.545]         }
[17:59:29.545]     }, args = future.call.arguments)
[17:59:29.545] }
[17:59:29.545] Lazy evaluation: FALSE
[17:59:29.545] Asynchronous evaluation: TRUE
[17:59:29.545] Local evaluation: TRUE
[17:59:29.545] Environment: R_GlobalEnv
[17:59:29.545] Capture standard output: TRUE
[17:59:29.545] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.545] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:29.545] Packages: 1 packages (‘stats’)
[17:59:29.545] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.545] Resolved: FALSE
[17:59:29.545] Value: <not collected>
[17:59:29.545] Conditions captured: <none>
[17:59:29.545] Early signaling: FALSE
[17:59:29.545] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.545] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.558] Chunk #2 of 2 ... DONE
[17:59:29.558] Launching 2 futures (chunks) ... DONE
[17:59:29.558] Resolving 2 futures (chunks) ...
[17:59:29.558] resolve() on list ...
[17:59:29.559]  recursive: 0
[17:59:29.559]  length: 2
[17:59:29.559] 
[17:59:29.560] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.560] - Validating connection of MultisessionFuture
[17:59:29.561] - received message: FutureResult
[17:59:29.561] - Received FutureResult
[17:59:29.561] - Erased future from FutureRegistry
[17:59:29.561] result() for ClusterFuture ...
[17:59:29.561] - result already collected: FutureResult
[17:59:29.562] result() for ClusterFuture ... done
[17:59:29.562] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.562] Future #1
[17:59:29.562] result() for ClusterFuture ...
[17:59:29.562] - result already collected: FutureResult
[17:59:29.563] result() for ClusterFuture ... done
[17:59:29.563] result() for ClusterFuture ...
[17:59:29.563] - result already collected: FutureResult
[17:59:29.563] result() for ClusterFuture ... done
[17:59:29.563] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:29.564] - nx: 2
[17:59:29.564] - relay: TRUE
[17:59:29.564] - stdout: TRUE
[17:59:29.564] - signal: TRUE
[17:59:29.564] - resignal: FALSE
[17:59:29.564] - force: TRUE
[17:59:29.565] - relayed: [n=2] FALSE, FALSE
[17:59:29.565] - queued futures: [n=2] FALSE, FALSE
[17:59:29.565]  - until=1
[17:59:29.565]  - relaying element #1
[17:59:29.565] result() for ClusterFuture ...
[17:59:29.565] - result already collected: FutureResult
[17:59:29.566] result() for ClusterFuture ... done
[17:59:29.566] result() for ClusterFuture ...
[17:59:29.566] - result already collected: FutureResult
[17:59:29.566] result() for ClusterFuture ... done
[17:59:29.566] result() for ClusterFuture ...
[17:59:29.567] - result already collected: FutureResult
[17:59:29.567] result() for ClusterFuture ... done
[17:59:29.567] result() for ClusterFuture ...
[17:59:29.567] - result already collected: FutureResult
[17:59:29.567] result() for ClusterFuture ... done
[17:59:29.568] - relayed: [n=2] TRUE, FALSE
[17:59:29.568] - queued futures: [n=2] TRUE, FALSE
[17:59:29.568] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:29.568]  length: 1 (resolved future 1)
[17:59:29.598] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.598] - Validating connection of MultisessionFuture
[17:59:29.599] - received message: FutureResult
[17:59:29.599] - Received FutureResult
[17:59:29.599] - Erased future from FutureRegistry
[17:59:29.599] result() for ClusterFuture ...
[17:59:29.599] - result already collected: FutureResult
[17:59:29.600] result() for ClusterFuture ... done
[17:59:29.600] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.600] Future #2
[17:59:29.600] result() for ClusterFuture ...
[17:59:29.600] - result already collected: FutureResult
[17:59:29.601] result() for ClusterFuture ... done
[17:59:29.601] result() for ClusterFuture ...
[17:59:29.601] - result already collected: FutureResult
[17:59:29.601] result() for ClusterFuture ... done
[17:59:29.602] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:29.602] - nx: 2
[17:59:29.602] - relay: TRUE
[17:59:29.602] - stdout: TRUE
[17:59:29.602] - signal: TRUE
[17:59:29.603] - resignal: FALSE
[17:59:29.603] - force: TRUE
[17:59:29.603] - relayed: [n=2] TRUE, FALSE
[17:59:29.603] - queued futures: [n=2] TRUE, FALSE
[17:59:29.603]  - until=2
[17:59:29.603]  - relaying element #2
[17:59:29.604] result() for ClusterFuture ...
[17:59:29.604] - result already collected: FutureResult
[17:59:29.604] result() for ClusterFuture ... done
[17:59:29.604] result() for ClusterFuture ...
[17:59:29.604] - result already collected: FutureResult
[17:59:29.605] result() for ClusterFuture ... done
[17:59:29.605] result() for ClusterFuture ...
[17:59:29.605] - result already collected: FutureResult
[17:59:29.605] result() for ClusterFuture ... done
[17:59:29.606] result() for ClusterFuture ...
[17:59:29.606] - result already collected: FutureResult
[17:59:29.606] result() for ClusterFuture ... done
[17:59:29.606] - relayed: [n=2] TRUE, TRUE
[17:59:29.606] - queued futures: [n=2] TRUE, TRUE
[17:59:29.607] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:29.607]  length: 0 (resolved future 2)
[17:59:29.607] Relaying remaining futures
[17:59:29.607] signalConditionsASAP(NULL, pos=0) ...
[17:59:29.607] - nx: 2
[17:59:29.608] - relay: TRUE
[17:59:29.608] - stdout: TRUE
[17:59:29.608] - signal: TRUE
[17:59:29.608] - resignal: FALSE
[17:59:29.608] - force: TRUE
[17:59:29.608] - relayed: [n=2] TRUE, TRUE
[17:59:29.609] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:29.609] - relayed: [n=2] TRUE, TRUE
[17:59:29.609] - queued futures: [n=2] TRUE, TRUE
[17:59:29.609] signalConditionsASAP(NULL, pos=0) ... done
[17:59:29.610] resolve() on list ... DONE
[17:59:29.610] result() for ClusterFuture ...
[17:59:29.610] - result already collected: FutureResult
[17:59:29.610] result() for ClusterFuture ... done
[17:59:29.610] result() for ClusterFuture ...
[17:59:29.611] - result already collected: FutureResult
[17:59:29.611] result() for ClusterFuture ... done
[17:59:29.611] result() for ClusterFuture ...
[17:59:29.611] - result already collected: FutureResult
[17:59:29.611] result() for ClusterFuture ... done
[17:59:29.612] result() for ClusterFuture ...
[17:59:29.612] - result already collected: FutureResult
[17:59:29.612] result() for ClusterFuture ... done
[17:59:29.612]  - Number of value chunks collected: 2
[17:59:29.612] Resolving 2 futures (chunks) ... DONE
[17:59:29.613] Reducing values from 2 chunks ...
[17:59:29.613]  - Number of values collected after concatenation: 3
[17:59:29.613]  - Number of values expected: 3
[17:59:29.613] Reducing values from 2 chunks ... DONE
[17:59:29.613] future_lapply() ... DONE
[17:59:29.614] future_by_internal() ... DONE
[17:59:29.623] future_by_internal() ...
[17:59:29.624] future_lapply() ...
[17:59:29.631] Number of chunks: 2
[17:59:29.631] getGlobalsAndPackagesXApply() ...
[17:59:29.632]  - future.globals: TRUE
[17:59:29.632] getGlobalsAndPackages() ...
[17:59:29.632] Searching for globals...
[17:59:29.635] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[17:59:29.636] Searching for globals ... DONE
[17:59:29.636] Resolving globals: FALSE
[17:59:29.637] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[17:59:29.638] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[17:59:29.638] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:29.638] - packages: [1] ‘stats’
[17:59:29.638] getGlobalsAndPackages() ... DONE
[17:59:29.639]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[17:59:29.639]  - needed namespaces: [n=1] ‘stats’
[17:59:29.639] Finding globals ... DONE
[17:59:29.639]  - use_args: TRUE
[17:59:29.640]  - Getting '...' globals ...
[17:59:29.640] resolve() on list ...
[17:59:29.640]  recursive: 0
[17:59:29.641]  length: 1
[17:59:29.641]  elements: ‘...’
[17:59:29.641]  length: 0 (resolved future 1)
[17:59:29.641] resolve() on list ... DONE
[17:59:29.641]    - '...' content: [n=0] 
[17:59:29.642] List of 1
[17:59:29.642]  $ ...: list()
[17:59:29.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.642]  - attr(*, "where")=List of 1
[17:59:29.642]   ..$ ...:<environment: 0x6264a1533f08> 
[17:59:29.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.642]  - attr(*, "resolved")= logi TRUE
[17:59:29.642]  - attr(*, "total_size")= num NA
[17:59:29.646]  - Getting '...' globals ... DONE
[17:59:29.647] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[17:59:29.647] List of 4
[17:59:29.647]  $ ...future.FUN:function (x)  
[17:59:29.647]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[17:59:29.647]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[17:59:29.647]  $ ...          : list()
[17:59:29.647]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.647]  - attr(*, "where")=List of 4
[17:59:29.647]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:29.647]   ..$ breaks       :<environment: R_EmptyEnv> 
[17:59:29.647]   ..$ wool         :<environment: R_EmptyEnv> 
[17:59:29.647]   ..$ ...          :<environment: 0x6264a1533f08> 
[17:59:29.647]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.647]  - attr(*, "resolved")= logi FALSE
[17:59:29.647]  - attr(*, "total_size")= num 2320
[17:59:29.655] Packages to be attached in all futures: [n=1] ‘stats’
[17:59:29.655] getGlobalsAndPackagesXApply() ... DONE
[17:59:29.655] Number of futures (= number of chunks): 2
[17:59:29.656] Launching 2 futures (chunks) ...
[17:59:29.656] Chunk #1 of 2 ...
[17:59:29.656]  - Finding globals in 'X' for chunk #1 ...
[17:59:29.656] getGlobalsAndPackages() ...
[17:59:29.656] Searching for globals...
[17:59:29.657] 
[17:59:29.657] Searching for globals ... DONE
[17:59:29.657] - globals: [0] <none>
[17:59:29.658] getGlobalsAndPackages() ... DONE
[17:59:29.658]    + additional globals found: [n=0] 
[17:59:29.658]    + additional namespaces needed: [n=0] 
[17:59:29.658]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:29.658]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.659]  - seeds: <none>
[17:59:29.659]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.659] getGlobalsAndPackages() ...
[17:59:29.659] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.659] Resolving globals: FALSE
[17:59:29.660] Tweak future expression to call with '...' arguments ...
[17:59:29.660] {
[17:59:29.660]     do.call(function(...) {
[17:59:29.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.660]             on.exit(options(oopts), add = TRUE)
[17:59:29.660]         }
[17:59:29.660]         {
[17:59:29.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.660]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.660]             })
[17:59:29.660]         }
[17:59:29.660]     }, args = future.call.arguments)
[17:59:29.660] }
[17:59:29.660] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.661] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.661] 
[17:59:29.662] getGlobalsAndPackages() ... DONE
[17:59:29.662] run() for ‘Future’ ...
[17:59:29.662] - state: ‘created’
[17:59:29.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.687]   - Field: ‘node’
[17:59:29.688]   - Field: ‘label’
[17:59:29.688]   - Field: ‘local’
[17:59:29.688]   - Field: ‘owner’
[17:59:29.688]   - Field: ‘envir’
[17:59:29.688]   - Field: ‘workers’
[17:59:29.689]   - Field: ‘packages’
[17:59:29.689]   - Field: ‘gc’
[17:59:29.689]   - Field: ‘conditions’
[17:59:29.689]   - Field: ‘persistent’
[17:59:29.689]   - Field: ‘expr’
[17:59:29.690]   - Field: ‘uuid’
[17:59:29.690]   - Field: ‘seed’
[17:59:29.690]   - Field: ‘version’
[17:59:29.690]   - Field: ‘result’
[17:59:29.690]   - Field: ‘asynchronous’
[17:59:29.691]   - Field: ‘calls’
[17:59:29.691]   - Field: ‘globals’
[17:59:29.691]   - Field: ‘stdout’
[17:59:29.691]   - Field: ‘earlySignal’
[17:59:29.691]   - Field: ‘lazy’
[17:59:29.692]   - Field: ‘state’
[17:59:29.692] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.692] - Launch lazy future ...
[17:59:29.692] Packages needed by the future expression (n = 1): ‘stats’
[17:59:29.693] Packages needed by future strategies (n = 0): <none>
[17:59:29.694] {
[17:59:29.694]     {
[17:59:29.694]         {
[17:59:29.694]             ...future.startTime <- base::Sys.time()
[17:59:29.694]             {
[17:59:29.694]                 {
[17:59:29.694]                   {
[17:59:29.694]                     {
[17:59:29.694]                       {
[17:59:29.694]                         base::local({
[17:59:29.694]                           has_future <- base::requireNamespace("future", 
[17:59:29.694]                             quietly = TRUE)
[17:59:29.694]                           if (has_future) {
[17:59:29.694]                             ns <- base::getNamespace("future")
[17:59:29.694]                             version <- ns[[".package"]][["version"]]
[17:59:29.694]                             if (is.null(version)) 
[17:59:29.694]                               version <- utils::packageVersion("future")
[17:59:29.694]                           }
[17:59:29.694]                           else {
[17:59:29.694]                             version <- NULL
[17:59:29.694]                           }
[17:59:29.694]                           if (!has_future || version < "1.8.0") {
[17:59:29.694]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.694]                               "", base::R.version$version.string), 
[17:59:29.694]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:29.694]                                 base::R.version$platform, 8 * 
[17:59:29.694]                                   base::.Machine$sizeof.pointer), 
[17:59:29.694]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.694]                                 "release", "version")], collapse = " "), 
[17:59:29.694]                               hostname = base::Sys.info()[["nodename"]])
[17:59:29.694]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.694]                               info)
[17:59:29.694]                             info <- base::paste(info, collapse = "; ")
[17:59:29.694]                             if (!has_future) {
[17:59:29.694]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.694]                                 info)
[17:59:29.694]                             }
[17:59:29.694]                             else {
[17:59:29.694]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.694]                                 info, version)
[17:59:29.694]                             }
[17:59:29.694]                             base::stop(msg)
[17:59:29.694]                           }
[17:59:29.694]                         })
[17:59:29.694]                       }
[17:59:29.694]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.694]                       base::options(mc.cores = 1L)
[17:59:29.694]                     }
[17:59:29.694]                     base::local({
[17:59:29.694]                       for (pkg in "stats") {
[17:59:29.694]                         base::loadNamespace(pkg)
[17:59:29.694]                         base::library(pkg, character.only = TRUE)
[17:59:29.694]                       }
[17:59:29.694]                     })
[17:59:29.694]                   }
[17:59:29.694]                   ...future.strategy.old <- future::plan("list")
[17:59:29.694]                   options(future.plan = NULL)
[17:59:29.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.694]                 }
[17:59:29.694]                 ...future.workdir <- getwd()
[17:59:29.694]             }
[17:59:29.694]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.694]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.694]         }
[17:59:29.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.694]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.694]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.694]             base::names(...future.oldOptions))
[17:59:29.694]     }
[17:59:29.694]     if (FALSE) {
[17:59:29.694]     }
[17:59:29.694]     else {
[17:59:29.694]         if (TRUE) {
[17:59:29.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.694]                 open = "w")
[17:59:29.694]         }
[17:59:29.694]         else {
[17:59:29.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.694]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.694]         }
[17:59:29.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.694]             base::sink(type = "output", split = FALSE)
[17:59:29.694]             base::close(...future.stdout)
[17:59:29.694]         }, add = TRUE)
[17:59:29.694]     }
[17:59:29.694]     ...future.frame <- base::sys.nframe()
[17:59:29.694]     ...future.conditions <- base::list()
[17:59:29.694]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.694]     if (FALSE) {
[17:59:29.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.694]     }
[17:59:29.694]     ...future.result <- base::tryCatch({
[17:59:29.694]         base::withCallingHandlers({
[17:59:29.694]             ...future.value <- base::withVisible(base::local({
[17:59:29.694]                 ...future.makeSendCondition <- base::local({
[17:59:29.694]                   sendCondition <- NULL
[17:59:29.694]                   function(frame = 1L) {
[17:59:29.694]                     if (is.function(sendCondition)) 
[17:59:29.694]                       return(sendCondition)
[17:59:29.694]                     ns <- getNamespace("parallel")
[17:59:29.694]                     if (exists("sendData", mode = "function", 
[17:59:29.694]                       envir = ns)) {
[17:59:29.694]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.694]                         envir = ns)
[17:59:29.694]                       envir <- sys.frame(frame)
[17:59:29.694]                       master <- NULL
[17:59:29.694]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.694]                         !identical(envir, emptyenv())) {
[17:59:29.694]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.694]                           inherits = FALSE)) {
[17:59:29.694]                           master <- get("master", mode = "list", 
[17:59:29.694]                             envir = envir, inherits = FALSE)
[17:59:29.694]                           if (inherits(master, c("SOCKnode", 
[17:59:29.694]                             "SOCK0node"))) {
[17:59:29.694]                             sendCondition <<- function(cond) {
[17:59:29.694]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.694]                                 success = TRUE)
[17:59:29.694]                               parallel_sendData(master, data)
[17:59:29.694]                             }
[17:59:29.694]                             return(sendCondition)
[17:59:29.694]                           }
[17:59:29.694]                         }
[17:59:29.694]                         frame <- frame + 1L
[17:59:29.694]                         envir <- sys.frame(frame)
[17:59:29.694]                       }
[17:59:29.694]                     }
[17:59:29.694]                     sendCondition <<- function(cond) NULL
[17:59:29.694]                   }
[17:59:29.694]                 })
[17:59:29.694]                 withCallingHandlers({
[17:59:29.694]                   {
[17:59:29.694]                     do.call(function(...) {
[17:59:29.694]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.694]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.694]                         ...future.globals.maxSize)) {
[17:59:29.694]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.694]                         on.exit(options(oopts), add = TRUE)
[17:59:29.694]                       }
[17:59:29.694]                       {
[17:59:29.694]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.694]                           FUN = function(jj) {
[17:59:29.694]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.694]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.694]                           })
[17:59:29.694]                       }
[17:59:29.694]                     }, args = future.call.arguments)
[17:59:29.694]                   }
[17:59:29.694]                 }, immediateCondition = function(cond) {
[17:59:29.694]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.694]                   sendCondition(cond)
[17:59:29.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.694]                   {
[17:59:29.694]                     inherits <- base::inherits
[17:59:29.694]                     invokeRestart <- base::invokeRestart
[17:59:29.694]                     is.null <- base::is.null
[17:59:29.694]                     muffled <- FALSE
[17:59:29.694]                     if (inherits(cond, "message")) {
[17:59:29.694]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.694]                       if (muffled) 
[17:59:29.694]                         invokeRestart("muffleMessage")
[17:59:29.694]                     }
[17:59:29.694]                     else if (inherits(cond, "warning")) {
[17:59:29.694]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.694]                       if (muffled) 
[17:59:29.694]                         invokeRestart("muffleWarning")
[17:59:29.694]                     }
[17:59:29.694]                     else if (inherits(cond, "condition")) {
[17:59:29.694]                       if (!is.null(pattern)) {
[17:59:29.694]                         computeRestarts <- base::computeRestarts
[17:59:29.694]                         grepl <- base::grepl
[17:59:29.694]                         restarts <- computeRestarts(cond)
[17:59:29.694]                         for (restart in restarts) {
[17:59:29.694]                           name <- restart$name
[17:59:29.694]                           if (is.null(name)) 
[17:59:29.694]                             next
[17:59:29.694]                           if (!grepl(pattern, name)) 
[17:59:29.694]                             next
[17:59:29.694]                           invokeRestart(restart)
[17:59:29.694]                           muffled <- TRUE
[17:59:29.694]                           break
[17:59:29.694]                         }
[17:59:29.694]                       }
[17:59:29.694]                     }
[17:59:29.694]                     invisible(muffled)
[17:59:29.694]                   }
[17:59:29.694]                   muffleCondition(cond)
[17:59:29.694]                 })
[17:59:29.694]             }))
[17:59:29.694]             future::FutureResult(value = ...future.value$value, 
[17:59:29.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.694]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.694]                     ...future.globalenv.names))
[17:59:29.694]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.694]         }, condition = base::local({
[17:59:29.694]             c <- base::c
[17:59:29.694]             inherits <- base::inherits
[17:59:29.694]             invokeRestart <- base::invokeRestart
[17:59:29.694]             length <- base::length
[17:59:29.694]             list <- base::list
[17:59:29.694]             seq.int <- base::seq.int
[17:59:29.694]             signalCondition <- base::signalCondition
[17:59:29.694]             sys.calls <- base::sys.calls
[17:59:29.694]             `[[` <- base::`[[`
[17:59:29.694]             `+` <- base::`+`
[17:59:29.694]             `<<-` <- base::`<<-`
[17:59:29.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.694]                   3L)]
[17:59:29.694]             }
[17:59:29.694]             function(cond) {
[17:59:29.694]                 is_error <- inherits(cond, "error")
[17:59:29.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.694]                   NULL)
[17:59:29.694]                 if (is_error) {
[17:59:29.694]                   sessionInformation <- function() {
[17:59:29.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.694]                       search = base::search(), system = base::Sys.info())
[17:59:29.694]                   }
[17:59:29.694]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.694]                     cond$call), session = sessionInformation(), 
[17:59:29.694]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.694]                   signalCondition(cond)
[17:59:29.694]                 }
[17:59:29.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.694]                 "immediateCondition"))) {
[17:59:29.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.694]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.694]                   if (TRUE && !signal) {
[17:59:29.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.694]                     {
[17:59:29.694]                       inherits <- base::inherits
[17:59:29.694]                       invokeRestart <- base::invokeRestart
[17:59:29.694]                       is.null <- base::is.null
[17:59:29.694]                       muffled <- FALSE
[17:59:29.694]                       if (inherits(cond, "message")) {
[17:59:29.694]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.694]                         if (muffled) 
[17:59:29.694]                           invokeRestart("muffleMessage")
[17:59:29.694]                       }
[17:59:29.694]                       else if (inherits(cond, "warning")) {
[17:59:29.694]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.694]                         if (muffled) 
[17:59:29.694]                           invokeRestart("muffleWarning")
[17:59:29.694]                       }
[17:59:29.694]                       else if (inherits(cond, "condition")) {
[17:59:29.694]                         if (!is.null(pattern)) {
[17:59:29.694]                           computeRestarts <- base::computeRestarts
[17:59:29.694]                           grepl <- base::grepl
[17:59:29.694]                           restarts <- computeRestarts(cond)
[17:59:29.694]                           for (restart in restarts) {
[17:59:29.694]                             name <- restart$name
[17:59:29.694]                             if (is.null(name)) 
[17:59:29.694]                               next
[17:59:29.694]                             if (!grepl(pattern, name)) 
[17:59:29.694]                               next
[17:59:29.694]                             invokeRestart(restart)
[17:59:29.694]                             muffled <- TRUE
[17:59:29.694]                             break
[17:59:29.694]                           }
[17:59:29.694]                         }
[17:59:29.694]                       }
[17:59:29.694]                       invisible(muffled)
[17:59:29.694]                     }
[17:59:29.694]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.694]                   }
[17:59:29.694]                 }
[17:59:29.694]                 else {
[17:59:29.694]                   if (TRUE) {
[17:59:29.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.694]                     {
[17:59:29.694]                       inherits <- base::inherits
[17:59:29.694]                       invokeRestart <- base::invokeRestart
[17:59:29.694]                       is.null <- base::is.null
[17:59:29.694]                       muffled <- FALSE
[17:59:29.694]                       if (inherits(cond, "message")) {
[17:59:29.694]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.694]                         if (muffled) 
[17:59:29.694]                           invokeRestart("muffleMessage")
[17:59:29.694]                       }
[17:59:29.694]                       else if (inherits(cond, "warning")) {
[17:59:29.694]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.694]                         if (muffled) 
[17:59:29.694]                           invokeRestart("muffleWarning")
[17:59:29.694]                       }
[17:59:29.694]                       else if (inherits(cond, "condition")) {
[17:59:29.694]                         if (!is.null(pattern)) {
[17:59:29.694]                           computeRestarts <- base::computeRestarts
[17:59:29.694]                           grepl <- base::grepl
[17:59:29.694]                           restarts <- computeRestarts(cond)
[17:59:29.694]                           for (restart in restarts) {
[17:59:29.694]                             name <- restart$name
[17:59:29.694]                             if (is.null(name)) 
[17:59:29.694]                               next
[17:59:29.694]                             if (!grepl(pattern, name)) 
[17:59:29.694]                               next
[17:59:29.694]                             invokeRestart(restart)
[17:59:29.694]                             muffled <- TRUE
[17:59:29.694]                             break
[17:59:29.694]                           }
[17:59:29.694]                         }
[17:59:29.694]                       }
[17:59:29.694]                       invisible(muffled)
[17:59:29.694]                     }
[17:59:29.694]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.694]                   }
[17:59:29.694]                 }
[17:59:29.694]             }
[17:59:29.694]         }))
[17:59:29.694]     }, error = function(ex) {
[17:59:29.694]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.694]                 ...future.rng), started = ...future.startTime, 
[17:59:29.694]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.694]             version = "1.8"), class = "FutureResult")
[17:59:29.694]     }, finally = {
[17:59:29.694]         if (!identical(...future.workdir, getwd())) 
[17:59:29.694]             setwd(...future.workdir)
[17:59:29.694]         {
[17:59:29.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.694]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.694]             }
[17:59:29.694]             base::options(...future.oldOptions)
[17:59:29.694]             if (.Platform$OS.type == "windows") {
[17:59:29.694]                 old_names <- names(...future.oldEnvVars)
[17:59:29.694]                 envs <- base::Sys.getenv()
[17:59:29.694]                 names <- names(envs)
[17:59:29.694]                 common <- intersect(names, old_names)
[17:59:29.694]                 added <- setdiff(names, old_names)
[17:59:29.694]                 removed <- setdiff(old_names, names)
[17:59:29.694]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.694]                   envs[common]]
[17:59:29.694]                 NAMES <- toupper(changed)
[17:59:29.694]                 args <- list()
[17:59:29.694]                 for (kk in seq_along(NAMES)) {
[17:59:29.694]                   name <- changed[[kk]]
[17:59:29.694]                   NAME <- NAMES[[kk]]
[17:59:29.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.694]                     next
[17:59:29.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.694]                 }
[17:59:29.694]                 NAMES <- toupper(added)
[17:59:29.694]                 for (kk in seq_along(NAMES)) {
[17:59:29.694]                   name <- added[[kk]]
[17:59:29.694]                   NAME <- NAMES[[kk]]
[17:59:29.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.694]                     next
[17:59:29.694]                   args[[name]] <- ""
[17:59:29.694]                 }
[17:59:29.694]                 NAMES <- toupper(removed)
[17:59:29.694]                 for (kk in seq_along(NAMES)) {
[17:59:29.694]                   name <- removed[[kk]]
[17:59:29.694]                   NAME <- NAMES[[kk]]
[17:59:29.694]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.694]                     next
[17:59:29.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.694]                 }
[17:59:29.694]                 if (length(args) > 0) 
[17:59:29.694]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.694]             }
[17:59:29.694]             else {
[17:59:29.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.694]             }
[17:59:29.694]             {
[17:59:29.694]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.694]                   0L) {
[17:59:29.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.694]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.694]                   base::options(opts)
[17:59:29.694]                 }
[17:59:29.694]                 {
[17:59:29.694]                   {
[17:59:29.694]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.694]                     NULL
[17:59:29.694]                   }
[17:59:29.694]                   options(future.plan = NULL)
[17:59:29.694]                   if (is.na(NA_character_)) 
[17:59:29.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.694]                     .init = FALSE)
[17:59:29.694]                 }
[17:59:29.694]             }
[17:59:29.694]         }
[17:59:29.694]     })
[17:59:29.694]     if (TRUE) {
[17:59:29.694]         base::sink(type = "output", split = FALSE)
[17:59:29.694]         if (TRUE) {
[17:59:29.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.694]         }
[17:59:29.694]         else {
[17:59:29.694]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.694]         }
[17:59:29.694]         base::close(...future.stdout)
[17:59:29.694]         ...future.stdout <- NULL
[17:59:29.694]     }
[17:59:29.694]     ...future.result$conditions <- ...future.conditions
[17:59:29.694]     ...future.result$finished <- base::Sys.time()
[17:59:29.694]     ...future.result
[17:59:29.694] }
[17:59:29.699] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[17:59:29.699] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[17:59:29.700] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[17:59:29.701] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[17:59:29.701] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[17:59:29.702] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[17:59:29.703] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[17:59:29.703] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:29.704] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.705] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:59:29.706] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:59:29.706] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:29.707] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.707] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:29.708] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.708] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[17:59:29.710] MultisessionFuture started
[17:59:29.711] - Launch lazy future ... done
[17:59:29.711] run() for ‘MultisessionFuture’ ... done
[17:59:29.711] Created future:
[17:59:29.711] MultisessionFuture:
[17:59:29.711] Label: ‘future_by-1’
[17:59:29.711] Expression:
[17:59:29.711] {
[17:59:29.711]     do.call(function(...) {
[17:59:29.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.711]             on.exit(options(oopts), add = TRUE)
[17:59:29.711]         }
[17:59:29.711]         {
[17:59:29.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.711]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.711]             })
[17:59:29.711]         }
[17:59:29.711]     }, args = future.call.arguments)
[17:59:29.711] }
[17:59:29.711] Lazy evaluation: FALSE
[17:59:29.711] Asynchronous evaluation: TRUE
[17:59:29.711] Local evaluation: TRUE
[17:59:29.711] Environment: 0x6264a15079e8
[17:59:29.711] Capture standard output: TRUE
[17:59:29.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.711] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[17:59:29.711] Packages: 1 packages (‘stats’)
[17:59:29.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.711] Resolved: FALSE
[17:59:29.711] Value: <not collected>
[17:59:29.711] Conditions captured: <none>
[17:59:29.711] Early signaling: FALSE
[17:59:29.711] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.711] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.725] Chunk #1 of 2 ... DONE
[17:59:29.725] Chunk #2 of 2 ...
[17:59:29.726]  - Finding globals in 'X' for chunk #2 ...
[17:59:29.726] getGlobalsAndPackages() ...
[17:59:29.726] Searching for globals...
[17:59:29.727] 
[17:59:29.727] Searching for globals ... DONE
[17:59:29.727] - globals: [0] <none>
[17:59:29.727] getGlobalsAndPackages() ... DONE
[17:59:29.728]    + additional globals found: [n=0] 
[17:59:29.728]    + additional namespaces needed: [n=0] 
[17:59:29.728]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:29.728]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.728]  - seeds: <none>
[17:59:29.729]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.729] getGlobalsAndPackages() ...
[17:59:29.729] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.729] Resolving globals: FALSE
[17:59:29.730] Tweak future expression to call with '...' arguments ...
[17:59:29.730] {
[17:59:29.730]     do.call(function(...) {
[17:59:29.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.730]             on.exit(options(oopts), add = TRUE)
[17:59:29.730]         }
[17:59:29.730]         {
[17:59:29.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.730]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.730]             })
[17:59:29.730]         }
[17:59:29.730]     }, args = future.call.arguments)
[17:59:29.730] }
[17:59:29.730] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.731] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.731] 
[17:59:29.732] getGlobalsAndPackages() ... DONE
[17:59:29.732] run() for ‘Future’ ...
[17:59:29.732] - state: ‘created’
[17:59:29.733] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.764]   - Field: ‘node’
[17:59:29.765]   - Field: ‘label’
[17:59:29.765]   - Field: ‘local’
[17:59:29.765]   - Field: ‘owner’
[17:59:29.765]   - Field: ‘envir’
[17:59:29.766]   - Field: ‘workers’
[17:59:29.766]   - Field: ‘packages’
[17:59:29.766]   - Field: ‘gc’
[17:59:29.766]   - Field: ‘conditions’
[17:59:29.766]   - Field: ‘persistent’
[17:59:29.767]   - Field: ‘expr’
[17:59:29.767]   - Field: ‘uuid’
[17:59:29.767]   - Field: ‘seed’
[17:59:29.767]   - Field: ‘version’
[17:59:29.767]   - Field: ‘result’
[17:59:29.771]   - Field: ‘asynchronous’
[17:59:29.771]   - Field: ‘calls’
[17:59:29.771]   - Field: ‘globals’
[17:59:29.771]   - Field: ‘stdout’
[17:59:29.771]   - Field: ‘earlySignal’
[17:59:29.772]   - Field: ‘lazy’
[17:59:29.772]   - Field: ‘state’
[17:59:29.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.772] - Launch lazy future ...
[17:59:29.773] Packages needed by the future expression (n = 1): ‘stats’
[17:59:29.773] Packages needed by future strategies (n = 0): <none>
[17:59:29.774] {
[17:59:29.774]     {
[17:59:29.774]         {
[17:59:29.774]             ...future.startTime <- base::Sys.time()
[17:59:29.774]             {
[17:59:29.774]                 {
[17:59:29.774]                   {
[17:59:29.774]                     {
[17:59:29.774]                       {
[17:59:29.774]                         base::local({
[17:59:29.774]                           has_future <- base::requireNamespace("future", 
[17:59:29.774]                             quietly = TRUE)
[17:59:29.774]                           if (has_future) {
[17:59:29.774]                             ns <- base::getNamespace("future")
[17:59:29.774]                             version <- ns[[".package"]][["version"]]
[17:59:29.774]                             if (is.null(version)) 
[17:59:29.774]                               version <- utils::packageVersion("future")
[17:59:29.774]                           }
[17:59:29.774]                           else {
[17:59:29.774]                             version <- NULL
[17:59:29.774]                           }
[17:59:29.774]                           if (!has_future || version < "1.8.0") {
[17:59:29.774]                             info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.774]                               "", base::R.version$version.string), 
[17:59:29.774]                               platform = base::sprintf("%s (%s-bit)", 
[17:59:29.774]                                 base::R.version$platform, 8 * 
[17:59:29.774]                                   base::.Machine$sizeof.pointer), 
[17:59:29.774]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.774]                                 "release", "version")], collapse = " "), 
[17:59:29.774]                               hostname = base::Sys.info()[["nodename"]])
[17:59:29.774]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.774]                               info)
[17:59:29.774]                             info <- base::paste(info, collapse = "; ")
[17:59:29.774]                             if (!has_future) {
[17:59:29.774]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.774]                                 info)
[17:59:29.774]                             }
[17:59:29.774]                             else {
[17:59:29.774]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.774]                                 info, version)
[17:59:29.774]                             }
[17:59:29.774]                             base::stop(msg)
[17:59:29.774]                           }
[17:59:29.774]                         })
[17:59:29.774]                       }
[17:59:29.774]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.774]                       base::options(mc.cores = 1L)
[17:59:29.774]                     }
[17:59:29.774]                     base::local({
[17:59:29.774]                       for (pkg in "stats") {
[17:59:29.774]                         base::loadNamespace(pkg)
[17:59:29.774]                         base::library(pkg, character.only = TRUE)
[17:59:29.774]                       }
[17:59:29.774]                     })
[17:59:29.774]                   }
[17:59:29.774]                   ...future.strategy.old <- future::plan("list")
[17:59:29.774]                   options(future.plan = NULL)
[17:59:29.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.774]                 }
[17:59:29.774]                 ...future.workdir <- getwd()
[17:59:29.774]             }
[17:59:29.774]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.774]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.774]         }
[17:59:29.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.774]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.774]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.774]             base::names(...future.oldOptions))
[17:59:29.774]     }
[17:59:29.774]     if (FALSE) {
[17:59:29.774]     }
[17:59:29.774]     else {
[17:59:29.774]         if (TRUE) {
[17:59:29.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.774]                 open = "w")
[17:59:29.774]         }
[17:59:29.774]         else {
[17:59:29.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.774]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.774]         }
[17:59:29.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.774]             base::sink(type = "output", split = FALSE)
[17:59:29.774]             base::close(...future.stdout)
[17:59:29.774]         }, add = TRUE)
[17:59:29.774]     }
[17:59:29.774]     ...future.frame <- base::sys.nframe()
[17:59:29.774]     ...future.conditions <- base::list()
[17:59:29.774]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.774]     if (FALSE) {
[17:59:29.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.774]     }
[17:59:29.774]     ...future.result <- base::tryCatch({
[17:59:29.774]         base::withCallingHandlers({
[17:59:29.774]             ...future.value <- base::withVisible(base::local({
[17:59:29.774]                 ...future.makeSendCondition <- base::local({
[17:59:29.774]                   sendCondition <- NULL
[17:59:29.774]                   function(frame = 1L) {
[17:59:29.774]                     if (is.function(sendCondition)) 
[17:59:29.774]                       return(sendCondition)
[17:59:29.774]                     ns <- getNamespace("parallel")
[17:59:29.774]                     if (exists("sendData", mode = "function", 
[17:59:29.774]                       envir = ns)) {
[17:59:29.774]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.774]                         envir = ns)
[17:59:29.774]                       envir <- sys.frame(frame)
[17:59:29.774]                       master <- NULL
[17:59:29.774]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.774]                         !identical(envir, emptyenv())) {
[17:59:29.774]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.774]                           inherits = FALSE)) {
[17:59:29.774]                           master <- get("master", mode = "list", 
[17:59:29.774]                             envir = envir, inherits = FALSE)
[17:59:29.774]                           if (inherits(master, c("SOCKnode", 
[17:59:29.774]                             "SOCK0node"))) {
[17:59:29.774]                             sendCondition <<- function(cond) {
[17:59:29.774]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.774]                                 success = TRUE)
[17:59:29.774]                               parallel_sendData(master, data)
[17:59:29.774]                             }
[17:59:29.774]                             return(sendCondition)
[17:59:29.774]                           }
[17:59:29.774]                         }
[17:59:29.774]                         frame <- frame + 1L
[17:59:29.774]                         envir <- sys.frame(frame)
[17:59:29.774]                       }
[17:59:29.774]                     }
[17:59:29.774]                     sendCondition <<- function(cond) NULL
[17:59:29.774]                   }
[17:59:29.774]                 })
[17:59:29.774]                 withCallingHandlers({
[17:59:29.774]                   {
[17:59:29.774]                     do.call(function(...) {
[17:59:29.774]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.774]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.774]                         ...future.globals.maxSize)) {
[17:59:29.774]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.774]                         on.exit(options(oopts), add = TRUE)
[17:59:29.774]                       }
[17:59:29.774]                       {
[17:59:29.774]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.774]                           FUN = function(jj) {
[17:59:29.774]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.774]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.774]                           })
[17:59:29.774]                       }
[17:59:29.774]                     }, args = future.call.arguments)
[17:59:29.774]                   }
[17:59:29.774]                 }, immediateCondition = function(cond) {
[17:59:29.774]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.774]                   sendCondition(cond)
[17:59:29.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.774]                   {
[17:59:29.774]                     inherits <- base::inherits
[17:59:29.774]                     invokeRestart <- base::invokeRestart
[17:59:29.774]                     is.null <- base::is.null
[17:59:29.774]                     muffled <- FALSE
[17:59:29.774]                     if (inherits(cond, "message")) {
[17:59:29.774]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.774]                       if (muffled) 
[17:59:29.774]                         invokeRestart("muffleMessage")
[17:59:29.774]                     }
[17:59:29.774]                     else if (inherits(cond, "warning")) {
[17:59:29.774]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.774]                       if (muffled) 
[17:59:29.774]                         invokeRestart("muffleWarning")
[17:59:29.774]                     }
[17:59:29.774]                     else if (inherits(cond, "condition")) {
[17:59:29.774]                       if (!is.null(pattern)) {
[17:59:29.774]                         computeRestarts <- base::computeRestarts
[17:59:29.774]                         grepl <- base::grepl
[17:59:29.774]                         restarts <- computeRestarts(cond)
[17:59:29.774]                         for (restart in restarts) {
[17:59:29.774]                           name <- restart$name
[17:59:29.774]                           if (is.null(name)) 
[17:59:29.774]                             next
[17:59:29.774]                           if (!grepl(pattern, name)) 
[17:59:29.774]                             next
[17:59:29.774]                           invokeRestart(restart)
[17:59:29.774]                           muffled <- TRUE
[17:59:29.774]                           break
[17:59:29.774]                         }
[17:59:29.774]                       }
[17:59:29.774]                     }
[17:59:29.774]                     invisible(muffled)
[17:59:29.774]                   }
[17:59:29.774]                   muffleCondition(cond)
[17:59:29.774]                 })
[17:59:29.774]             }))
[17:59:29.774]             future::FutureResult(value = ...future.value$value, 
[17:59:29.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.774]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.774]                     ...future.globalenv.names))
[17:59:29.774]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.774]         }, condition = base::local({
[17:59:29.774]             c <- base::c
[17:59:29.774]             inherits <- base::inherits
[17:59:29.774]             invokeRestart <- base::invokeRestart
[17:59:29.774]             length <- base::length
[17:59:29.774]             list <- base::list
[17:59:29.774]             seq.int <- base::seq.int
[17:59:29.774]             signalCondition <- base::signalCondition
[17:59:29.774]             sys.calls <- base::sys.calls
[17:59:29.774]             `[[` <- base::`[[`
[17:59:29.774]             `+` <- base::`+`
[17:59:29.774]             `<<-` <- base::`<<-`
[17:59:29.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.774]                   3L)]
[17:59:29.774]             }
[17:59:29.774]             function(cond) {
[17:59:29.774]                 is_error <- inherits(cond, "error")
[17:59:29.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.774]                   NULL)
[17:59:29.774]                 if (is_error) {
[17:59:29.774]                   sessionInformation <- function() {
[17:59:29.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.774]                       search = base::search(), system = base::Sys.info())
[17:59:29.774]                   }
[17:59:29.774]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.774]                     cond$call), session = sessionInformation(), 
[17:59:29.774]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.774]                   signalCondition(cond)
[17:59:29.774]                 }
[17:59:29.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.774]                 "immediateCondition"))) {
[17:59:29.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.774]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.774]                   if (TRUE && !signal) {
[17:59:29.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.774]                     {
[17:59:29.774]                       inherits <- base::inherits
[17:59:29.774]                       invokeRestart <- base::invokeRestart
[17:59:29.774]                       is.null <- base::is.null
[17:59:29.774]                       muffled <- FALSE
[17:59:29.774]                       if (inherits(cond, "message")) {
[17:59:29.774]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.774]                         if (muffled) 
[17:59:29.774]                           invokeRestart("muffleMessage")
[17:59:29.774]                       }
[17:59:29.774]                       else if (inherits(cond, "warning")) {
[17:59:29.774]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.774]                         if (muffled) 
[17:59:29.774]                           invokeRestart("muffleWarning")
[17:59:29.774]                       }
[17:59:29.774]                       else if (inherits(cond, "condition")) {
[17:59:29.774]                         if (!is.null(pattern)) {
[17:59:29.774]                           computeRestarts <- base::computeRestarts
[17:59:29.774]                           grepl <- base::grepl
[17:59:29.774]                           restarts <- computeRestarts(cond)
[17:59:29.774]                           for (restart in restarts) {
[17:59:29.774]                             name <- restart$name
[17:59:29.774]                             if (is.null(name)) 
[17:59:29.774]                               next
[17:59:29.774]                             if (!grepl(pattern, name)) 
[17:59:29.774]                               next
[17:59:29.774]                             invokeRestart(restart)
[17:59:29.774]                             muffled <- TRUE
[17:59:29.774]                             break
[17:59:29.774]                           }
[17:59:29.774]                         }
[17:59:29.774]                       }
[17:59:29.774]                       invisible(muffled)
[17:59:29.774]                     }
[17:59:29.774]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.774]                   }
[17:59:29.774]                 }
[17:59:29.774]                 else {
[17:59:29.774]                   if (TRUE) {
[17:59:29.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.774]                     {
[17:59:29.774]                       inherits <- base::inherits
[17:59:29.774]                       invokeRestart <- base::invokeRestart
[17:59:29.774]                       is.null <- base::is.null
[17:59:29.774]                       muffled <- FALSE
[17:59:29.774]                       if (inherits(cond, "message")) {
[17:59:29.774]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.774]                         if (muffled) 
[17:59:29.774]                           invokeRestart("muffleMessage")
[17:59:29.774]                       }
[17:59:29.774]                       else if (inherits(cond, "warning")) {
[17:59:29.774]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.774]                         if (muffled) 
[17:59:29.774]                           invokeRestart("muffleWarning")
[17:59:29.774]                       }
[17:59:29.774]                       else if (inherits(cond, "condition")) {
[17:59:29.774]                         if (!is.null(pattern)) {
[17:59:29.774]                           computeRestarts <- base::computeRestarts
[17:59:29.774]                           grepl <- base::grepl
[17:59:29.774]                           restarts <- computeRestarts(cond)
[17:59:29.774]                           for (restart in restarts) {
[17:59:29.774]                             name <- restart$name
[17:59:29.774]                             if (is.null(name)) 
[17:59:29.774]                               next
[17:59:29.774]                             if (!grepl(pattern, name)) 
[17:59:29.774]                               next
[17:59:29.774]                             invokeRestart(restart)
[17:59:29.774]                             muffled <- TRUE
[17:59:29.774]                             break
[17:59:29.774]                           }
[17:59:29.774]                         }
[17:59:29.774]                       }
[17:59:29.774]                       invisible(muffled)
[17:59:29.774]                     }
[17:59:29.774]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.774]                   }
[17:59:29.774]                 }
[17:59:29.774]             }
[17:59:29.774]         }))
[17:59:29.774]     }, error = function(ex) {
[17:59:29.774]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.774]                 ...future.rng), started = ...future.startTime, 
[17:59:29.774]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.774]             version = "1.8"), class = "FutureResult")
[17:59:29.774]     }, finally = {
[17:59:29.774]         if (!identical(...future.workdir, getwd())) 
[17:59:29.774]             setwd(...future.workdir)
[17:59:29.774]         {
[17:59:29.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.774]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.774]             }
[17:59:29.774]             base::options(...future.oldOptions)
[17:59:29.774]             if (.Platform$OS.type == "windows") {
[17:59:29.774]                 old_names <- names(...future.oldEnvVars)
[17:59:29.774]                 envs <- base::Sys.getenv()
[17:59:29.774]                 names <- names(envs)
[17:59:29.774]                 common <- intersect(names, old_names)
[17:59:29.774]                 added <- setdiff(names, old_names)
[17:59:29.774]                 removed <- setdiff(old_names, names)
[17:59:29.774]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.774]                   envs[common]]
[17:59:29.774]                 NAMES <- toupper(changed)
[17:59:29.774]                 args <- list()
[17:59:29.774]                 for (kk in seq_along(NAMES)) {
[17:59:29.774]                   name <- changed[[kk]]
[17:59:29.774]                   NAME <- NAMES[[kk]]
[17:59:29.774]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.774]                     next
[17:59:29.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.774]                 }
[17:59:29.774]                 NAMES <- toupper(added)
[17:59:29.774]                 for (kk in seq_along(NAMES)) {
[17:59:29.774]                   name <- added[[kk]]
[17:59:29.774]                   NAME <- NAMES[[kk]]
[17:59:29.774]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.774]                     next
[17:59:29.774]                   args[[name]] <- ""
[17:59:29.774]                 }
[17:59:29.774]                 NAMES <- toupper(removed)
[17:59:29.774]                 for (kk in seq_along(NAMES)) {
[17:59:29.774]                   name <- removed[[kk]]
[17:59:29.774]                   NAME <- NAMES[[kk]]
[17:59:29.774]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.774]                     next
[17:59:29.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.774]                 }
[17:59:29.774]                 if (length(args) > 0) 
[17:59:29.774]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.774]             }
[17:59:29.774]             else {
[17:59:29.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.774]             }
[17:59:29.774]             {
[17:59:29.774]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.774]                   0L) {
[17:59:29.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.774]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.774]                   base::options(opts)
[17:59:29.774]                 }
[17:59:29.774]                 {
[17:59:29.774]                   {
[17:59:29.774]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.774]                     NULL
[17:59:29.774]                   }
[17:59:29.774]                   options(future.plan = NULL)
[17:59:29.774]                   if (is.na(NA_character_)) 
[17:59:29.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.774]                     .init = FALSE)
[17:59:29.774]                 }
[17:59:29.774]             }
[17:59:29.774]         }
[17:59:29.774]     })
[17:59:29.774]     if (TRUE) {
[17:59:29.774]         base::sink(type = "output", split = FALSE)
[17:59:29.774]         if (TRUE) {
[17:59:29.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.774]         }
[17:59:29.774]         else {
[17:59:29.774]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.774]         }
[17:59:29.774]         base::close(...future.stdout)
[17:59:29.774]         ...future.stdout <- NULL
[17:59:29.774]     }
[17:59:29.774]     ...future.result$conditions <- ...future.conditions
[17:59:29.774]     ...future.result$finished <- base::Sys.time()
[17:59:29.774]     ...future.result
[17:59:29.774] }
[17:59:29.779] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[17:59:29.780] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[17:59:29.781] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[17:59:29.781] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[17:59:29.782] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[17:59:29.782] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[17:59:29.783] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[17:59:29.783] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:29.784] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.785] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:59:29.786] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:59:29.786] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:29.787] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.787] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:29.788] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:29.788] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[17:59:29.789] MultisessionFuture started
[17:59:29.789] - Launch lazy future ... done
[17:59:29.789] run() for ‘MultisessionFuture’ ... done
[17:59:29.790] Created future:
[17:59:29.790] MultisessionFuture:
[17:59:29.790] Label: ‘future_by-2’
[17:59:29.790] Expression:
[17:59:29.790] {
[17:59:29.790]     do.call(function(...) {
[17:59:29.790]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.790]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.790]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.790]             on.exit(options(oopts), add = TRUE)
[17:59:29.790]         }
[17:59:29.790]         {
[17:59:29.790]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.790]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.790]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.790]             })
[17:59:29.790]         }
[17:59:29.790]     }, args = future.call.arguments)
[17:59:29.790] }
[17:59:29.790] Lazy evaluation: FALSE
[17:59:29.790] Asynchronous evaluation: TRUE
[17:59:29.790] Local evaluation: TRUE
[17:59:29.790] Environment: 0x6264a15079e8
[17:59:29.790] Capture standard output: TRUE
[17:59:29.790] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.790] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[17:59:29.790] Packages: 1 packages (‘stats’)
[17:59:29.790] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.790] Resolved: FALSE
[17:59:29.790] Value: <not collected>
[17:59:29.790] Conditions captured: <none>
[17:59:29.790] Early signaling: FALSE
[17:59:29.790] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.790] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.803] Chunk #2 of 2 ... DONE
[17:59:29.803] Launching 2 futures (chunks) ... DONE
[17:59:29.804] Resolving 2 futures (chunks) ...
[17:59:29.804] resolve() on list ...
[17:59:29.804]  recursive: 0
[17:59:29.804]  length: 2
[17:59:29.804] 
[17:59:29.805] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.806] - Validating connection of MultisessionFuture
[17:59:29.806] - received message: FutureResult
[17:59:29.806] - Received FutureResult
[17:59:29.806] - Erased future from FutureRegistry
[17:59:29.807] result() for ClusterFuture ...
[17:59:29.807] - result already collected: FutureResult
[17:59:29.807] result() for ClusterFuture ... done
[17:59:29.807] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.807] Future #1
[17:59:29.808] result() for ClusterFuture ...
[17:59:29.808] - result already collected: FutureResult
[17:59:29.808] result() for ClusterFuture ... done
[17:59:29.808] result() for ClusterFuture ...
[17:59:29.808] - result already collected: FutureResult
[17:59:29.808] result() for ClusterFuture ... done
[17:59:29.809] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:29.809] - nx: 2
[17:59:29.809] - relay: TRUE
[17:59:29.809] - stdout: TRUE
[17:59:29.809] - signal: TRUE
[17:59:29.810] - resignal: FALSE
[17:59:29.810] - force: TRUE
[17:59:29.810] - relayed: [n=2] FALSE, FALSE
[17:59:29.810] - queued futures: [n=2] FALSE, FALSE
[17:59:29.810]  - until=1
[17:59:29.810]  - relaying element #1
[17:59:29.811] result() for ClusterFuture ...
[17:59:29.811] - result already collected: FutureResult
[17:59:29.811] result() for ClusterFuture ... done
[17:59:29.811] result() for ClusterFuture ...
[17:59:29.811] - result already collected: FutureResult
[17:59:29.811] result() for ClusterFuture ... done
[17:59:29.812] result() for ClusterFuture ...
[17:59:29.812] - result already collected: FutureResult
[17:59:29.812] result() for ClusterFuture ... done
[17:59:29.813] result() for ClusterFuture ...
[17:59:29.813] - result already collected: FutureResult
[17:59:29.813] result() for ClusterFuture ... done
[17:59:29.813] - relayed: [n=2] TRUE, FALSE
[17:59:29.813] - queued futures: [n=2] TRUE, FALSE
[17:59:29.814] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:29.814]  length: 1 (resolved future 1)
[17:59:29.839] receiveMessageFromWorker() for ClusterFuture ...
[17:59:29.839] - Validating connection of MultisessionFuture
[17:59:29.840] - received message: FutureResult
[17:59:29.840] - Received FutureResult
[17:59:29.840] - Erased future from FutureRegistry
[17:59:29.841] result() for ClusterFuture ...
[17:59:29.841] - result already collected: FutureResult
[17:59:29.841] result() for ClusterFuture ... done
[17:59:29.842] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:29.842] Future #2
[17:59:29.842] result() for ClusterFuture ...
[17:59:29.842] - result already collected: FutureResult
[17:59:29.842] result() for ClusterFuture ... done
[17:59:29.843] result() for ClusterFuture ...
[17:59:29.843] - result already collected: FutureResult
[17:59:29.843] result() for ClusterFuture ... done
[17:59:29.843] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:29.843] - nx: 2
[17:59:29.844] - relay: TRUE
[17:59:29.844] - stdout: TRUE
[17:59:29.844] - signal: TRUE
[17:59:29.844] - resignal: FALSE
[17:59:29.844] - force: TRUE
[17:59:29.844] - relayed: [n=2] TRUE, FALSE
[17:59:29.845] - queued futures: [n=2] TRUE, FALSE
[17:59:29.845]  - until=2
[17:59:29.845]  - relaying element #2
[17:59:29.845] result() for ClusterFuture ...
[17:59:29.845] - result already collected: FutureResult
[17:59:29.846] result() for ClusterFuture ... done
[17:59:29.846] result() for ClusterFuture ...
[17:59:29.846] - result already collected: FutureResult
[17:59:29.846] result() for ClusterFuture ... done
[17:59:29.846] result() for ClusterFuture ...
[17:59:29.847] - result already collected: FutureResult
[17:59:29.847] result() for ClusterFuture ... done
[17:59:29.847] result() for ClusterFuture ...
[17:59:29.847] - result already collected: FutureResult
[17:59:29.847] result() for ClusterFuture ... done
[17:59:29.847] - relayed: [n=2] TRUE, TRUE
[17:59:29.848] - queued futures: [n=2] TRUE, TRUE
[17:59:29.848] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:29.848]  length: 0 (resolved future 2)
[17:59:29.848] Relaying remaining futures
[17:59:29.848] signalConditionsASAP(NULL, pos=0) ...
[17:59:29.849] - nx: 2
[17:59:29.849] - relay: TRUE
[17:59:29.849] - stdout: TRUE
[17:59:29.849] - signal: TRUE
[17:59:29.849] - resignal: FALSE
[17:59:29.849] - force: TRUE
[17:59:29.850] - relayed: [n=2] TRUE, TRUE
[17:59:29.850] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:29.850] - relayed: [n=2] TRUE, TRUE
[17:59:29.850] - queued futures: [n=2] TRUE, TRUE
[17:59:29.850] signalConditionsASAP(NULL, pos=0) ... done
[17:59:29.851] resolve() on list ... DONE
[17:59:29.851] result() for ClusterFuture ...
[17:59:29.851] - result already collected: FutureResult
[17:59:29.851] result() for ClusterFuture ... done
[17:59:29.851] result() for ClusterFuture ...
[17:59:29.851] - result already collected: FutureResult
[17:59:29.852] result() for ClusterFuture ... done
[17:59:29.852] result() for ClusterFuture ...
[17:59:29.852] - result already collected: FutureResult
[17:59:29.852] result() for ClusterFuture ... done
[17:59:29.852] result() for ClusterFuture ...
[17:59:29.853] - result already collected: FutureResult
[17:59:29.853] result() for ClusterFuture ... done
[17:59:29.853]  - Number of value chunks collected: 2
[17:59:29.853] Resolving 2 futures (chunks) ... DONE
[17:59:29.853] Reducing values from 2 chunks ...
[17:59:29.854]  - Number of values collected after concatenation: 3
[17:59:29.854]  - Number of values expected: 3
[17:59:29.854] Reducing values from 2 chunks ... DONE
[17:59:29.854] future_lapply() ... DONE
[17:59:29.854] future_by_internal() ... DONE
[17:59:29.855] future_by_internal() ...
[17:59:29.856] future_lapply() ...
[17:59:29.863] Number of chunks: 2
[17:59:29.863] getGlobalsAndPackagesXApply() ...
[17:59:29.863]  - future.globals: TRUE
[17:59:29.863] getGlobalsAndPackages() ...
[17:59:29.864] Searching for globals...
[17:59:29.867] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:29.867] Searching for globals ... DONE
[17:59:29.867] Resolving globals: FALSE
[17:59:29.868] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:29.869] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:29.869] - globals: [1] ‘FUN’
[17:59:29.869] 
[17:59:29.870] getGlobalsAndPackages() ... DONE
[17:59:29.870]  - globals found/used: [n=1] ‘FUN’
[17:59:29.870]  - needed namespaces: [n=0] 
[17:59:29.870] Finding globals ... DONE
[17:59:29.870]  - use_args: TRUE
[17:59:29.871]  - Getting '...' globals ...
[17:59:29.871] resolve() on list ...
[17:59:29.871]  recursive: 0
[17:59:29.872]  length: 1
[17:59:29.872]  elements: ‘...’
[17:59:29.872]  length: 0 (resolved future 1)
[17:59:29.872] resolve() on list ... DONE
[17:59:29.872]    - '...' content: [n=0] 
[17:59:29.873] List of 1
[17:59:29.873]  $ ...: list()
[17:59:29.873]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.873]  - attr(*, "where")=List of 1
[17:59:29.873]   ..$ ...:<environment: 0x62649f04fe98> 
[17:59:29.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.873]  - attr(*, "resolved")= logi TRUE
[17:59:29.873]  - attr(*, "total_size")= num NA
[17:59:29.878]  - Getting '...' globals ... DONE
[17:59:29.878] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:29.878] List of 2
[17:59:29.878]  $ ...future.FUN:function (object, ...)  
[17:59:29.878]  $ ...          : list()
[17:59:29.878]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:29.878]  - attr(*, "where")=List of 2
[17:59:29.878]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:29.878]   ..$ ...          :<environment: 0x62649f04fe98> 
[17:59:29.878]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:29.878]  - attr(*, "resolved")= logi FALSE
[17:59:29.878]  - attr(*, "total_size")= num 1240
[17:59:29.884] Packages to be attached in all futures: [n=0] 
[17:59:29.884] getGlobalsAndPackagesXApply() ... DONE
[17:59:29.885] Number of futures (= number of chunks): 2
[17:59:29.885] Launching 2 futures (chunks) ...
[17:59:29.885] Chunk #1 of 2 ...
[17:59:29.886]  - Finding globals in 'X' for chunk #1 ...
[17:59:29.886] getGlobalsAndPackages() ...
[17:59:29.886] Searching for globals...
[17:59:29.887] 
[17:59:29.887] Searching for globals ... DONE
[17:59:29.887] - globals: [0] <none>
[17:59:29.887] getGlobalsAndPackages() ... DONE
[17:59:29.888]    + additional globals found: [n=0] 
[17:59:29.888]    + additional namespaces needed: [n=0] 
[17:59:29.888]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:29.888]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.889]  - seeds: <none>
[17:59:29.889]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.889] getGlobalsAndPackages() ...
[17:59:29.889] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.889] Resolving globals: FALSE
[17:59:29.890] Tweak future expression to call with '...' arguments ...
[17:59:29.890] {
[17:59:29.890]     do.call(function(...) {
[17:59:29.890]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.890]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.890]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.890]             on.exit(options(oopts), add = TRUE)
[17:59:29.890]         }
[17:59:29.890]         {
[17:59:29.890]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.890]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.890]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.890]             })
[17:59:29.890]         }
[17:59:29.890]     }, args = future.call.arguments)
[17:59:29.890] }
[17:59:29.890] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.891] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.891] 
[17:59:29.892] getGlobalsAndPackages() ... DONE
[17:59:29.892] run() for ‘Future’ ...
[17:59:29.892] - state: ‘created’
[17:59:29.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.917] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.917] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.917]   - Field: ‘node’
[17:59:29.917]   - Field: ‘label’
[17:59:29.918]   - Field: ‘local’
[17:59:29.918]   - Field: ‘owner’
[17:59:29.918]   - Field: ‘envir’
[17:59:29.918]   - Field: ‘workers’
[17:59:29.918]   - Field: ‘packages’
[17:59:29.919]   - Field: ‘gc’
[17:59:29.919]   - Field: ‘conditions’
[17:59:29.919]   - Field: ‘persistent’
[17:59:29.919]   - Field: ‘expr’
[17:59:29.919]   - Field: ‘uuid’
[17:59:29.920]   - Field: ‘seed’
[17:59:29.920]   - Field: ‘version’
[17:59:29.920]   - Field: ‘result’
[17:59:29.920]   - Field: ‘asynchronous’
[17:59:29.920]   - Field: ‘calls’
[17:59:29.921]   - Field: ‘globals’
[17:59:29.921]   - Field: ‘stdout’
[17:59:29.921]   - Field: ‘earlySignal’
[17:59:29.921]   - Field: ‘lazy’
[17:59:29.921]   - Field: ‘state’
[17:59:29.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.922] - Launch lazy future ...
[17:59:29.922] Packages needed by the future expression (n = 0): <none>
[17:59:29.923] Packages needed by future strategies (n = 0): <none>
[17:59:29.923] {
[17:59:29.923]     {
[17:59:29.923]         {
[17:59:29.923]             ...future.startTime <- base::Sys.time()
[17:59:29.923]             {
[17:59:29.923]                 {
[17:59:29.923]                   {
[17:59:29.923]                     {
[17:59:29.923]                       base::local({
[17:59:29.923]                         has_future <- base::requireNamespace("future", 
[17:59:29.923]                           quietly = TRUE)
[17:59:29.923]                         if (has_future) {
[17:59:29.923]                           ns <- base::getNamespace("future")
[17:59:29.923]                           version <- ns[[".package"]][["version"]]
[17:59:29.923]                           if (is.null(version)) 
[17:59:29.923]                             version <- utils::packageVersion("future")
[17:59:29.923]                         }
[17:59:29.923]                         else {
[17:59:29.923]                           version <- NULL
[17:59:29.923]                         }
[17:59:29.923]                         if (!has_future || version < "1.8.0") {
[17:59:29.923]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.923]                             "", base::R.version$version.string), 
[17:59:29.923]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:29.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:29.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.923]                               "release", "version")], collapse = " "), 
[17:59:29.923]                             hostname = base::Sys.info()[["nodename"]])
[17:59:29.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.923]                             info)
[17:59:29.923]                           info <- base::paste(info, collapse = "; ")
[17:59:29.923]                           if (!has_future) {
[17:59:29.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.923]                               info)
[17:59:29.923]                           }
[17:59:29.923]                           else {
[17:59:29.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.923]                               info, version)
[17:59:29.923]                           }
[17:59:29.923]                           base::stop(msg)
[17:59:29.923]                         }
[17:59:29.923]                       })
[17:59:29.923]                     }
[17:59:29.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.923]                     base::options(mc.cores = 1L)
[17:59:29.923]                   }
[17:59:29.923]                   ...future.strategy.old <- future::plan("list")
[17:59:29.923]                   options(future.plan = NULL)
[17:59:29.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.923]                 }
[17:59:29.923]                 ...future.workdir <- getwd()
[17:59:29.923]             }
[17:59:29.923]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.923]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.923]         }
[17:59:29.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.923]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.923]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.923]             base::names(...future.oldOptions))
[17:59:29.923]     }
[17:59:29.923]     if (FALSE) {
[17:59:29.923]     }
[17:59:29.923]     else {
[17:59:29.923]         if (TRUE) {
[17:59:29.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.923]                 open = "w")
[17:59:29.923]         }
[17:59:29.923]         else {
[17:59:29.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.923]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.923]         }
[17:59:29.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.923]             base::sink(type = "output", split = FALSE)
[17:59:29.923]             base::close(...future.stdout)
[17:59:29.923]         }, add = TRUE)
[17:59:29.923]     }
[17:59:29.923]     ...future.frame <- base::sys.nframe()
[17:59:29.923]     ...future.conditions <- base::list()
[17:59:29.923]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.923]     if (FALSE) {
[17:59:29.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.923]     }
[17:59:29.923]     ...future.result <- base::tryCatch({
[17:59:29.923]         base::withCallingHandlers({
[17:59:29.923]             ...future.value <- base::withVisible(base::local({
[17:59:29.923]                 ...future.makeSendCondition <- base::local({
[17:59:29.923]                   sendCondition <- NULL
[17:59:29.923]                   function(frame = 1L) {
[17:59:29.923]                     if (is.function(sendCondition)) 
[17:59:29.923]                       return(sendCondition)
[17:59:29.923]                     ns <- getNamespace("parallel")
[17:59:29.923]                     if (exists("sendData", mode = "function", 
[17:59:29.923]                       envir = ns)) {
[17:59:29.923]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.923]                         envir = ns)
[17:59:29.923]                       envir <- sys.frame(frame)
[17:59:29.923]                       master <- NULL
[17:59:29.923]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.923]                         !identical(envir, emptyenv())) {
[17:59:29.923]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.923]                           inherits = FALSE)) {
[17:59:29.923]                           master <- get("master", mode = "list", 
[17:59:29.923]                             envir = envir, inherits = FALSE)
[17:59:29.923]                           if (inherits(master, c("SOCKnode", 
[17:59:29.923]                             "SOCK0node"))) {
[17:59:29.923]                             sendCondition <<- function(cond) {
[17:59:29.923]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.923]                                 success = TRUE)
[17:59:29.923]                               parallel_sendData(master, data)
[17:59:29.923]                             }
[17:59:29.923]                             return(sendCondition)
[17:59:29.923]                           }
[17:59:29.923]                         }
[17:59:29.923]                         frame <- frame + 1L
[17:59:29.923]                         envir <- sys.frame(frame)
[17:59:29.923]                       }
[17:59:29.923]                     }
[17:59:29.923]                     sendCondition <<- function(cond) NULL
[17:59:29.923]                   }
[17:59:29.923]                 })
[17:59:29.923]                 withCallingHandlers({
[17:59:29.923]                   {
[17:59:29.923]                     do.call(function(...) {
[17:59:29.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.923]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.923]                         ...future.globals.maxSize)) {
[17:59:29.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.923]                         on.exit(options(oopts), add = TRUE)
[17:59:29.923]                       }
[17:59:29.923]                       {
[17:59:29.923]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.923]                           FUN = function(jj) {
[17:59:29.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.923]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.923]                           })
[17:59:29.923]                       }
[17:59:29.923]                     }, args = future.call.arguments)
[17:59:29.923]                   }
[17:59:29.923]                 }, immediateCondition = function(cond) {
[17:59:29.923]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.923]                   sendCondition(cond)
[17:59:29.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.923]                   {
[17:59:29.923]                     inherits <- base::inherits
[17:59:29.923]                     invokeRestart <- base::invokeRestart
[17:59:29.923]                     is.null <- base::is.null
[17:59:29.923]                     muffled <- FALSE
[17:59:29.923]                     if (inherits(cond, "message")) {
[17:59:29.923]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.923]                       if (muffled) 
[17:59:29.923]                         invokeRestart("muffleMessage")
[17:59:29.923]                     }
[17:59:29.923]                     else if (inherits(cond, "warning")) {
[17:59:29.923]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.923]                       if (muffled) 
[17:59:29.923]                         invokeRestart("muffleWarning")
[17:59:29.923]                     }
[17:59:29.923]                     else if (inherits(cond, "condition")) {
[17:59:29.923]                       if (!is.null(pattern)) {
[17:59:29.923]                         computeRestarts <- base::computeRestarts
[17:59:29.923]                         grepl <- base::grepl
[17:59:29.923]                         restarts <- computeRestarts(cond)
[17:59:29.923]                         for (restart in restarts) {
[17:59:29.923]                           name <- restart$name
[17:59:29.923]                           if (is.null(name)) 
[17:59:29.923]                             next
[17:59:29.923]                           if (!grepl(pattern, name)) 
[17:59:29.923]                             next
[17:59:29.923]                           invokeRestart(restart)
[17:59:29.923]                           muffled <- TRUE
[17:59:29.923]                           break
[17:59:29.923]                         }
[17:59:29.923]                       }
[17:59:29.923]                     }
[17:59:29.923]                     invisible(muffled)
[17:59:29.923]                   }
[17:59:29.923]                   muffleCondition(cond)
[17:59:29.923]                 })
[17:59:29.923]             }))
[17:59:29.923]             future::FutureResult(value = ...future.value$value, 
[17:59:29.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.923]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.923]                     ...future.globalenv.names))
[17:59:29.923]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.923]         }, condition = base::local({
[17:59:29.923]             c <- base::c
[17:59:29.923]             inherits <- base::inherits
[17:59:29.923]             invokeRestart <- base::invokeRestart
[17:59:29.923]             length <- base::length
[17:59:29.923]             list <- base::list
[17:59:29.923]             seq.int <- base::seq.int
[17:59:29.923]             signalCondition <- base::signalCondition
[17:59:29.923]             sys.calls <- base::sys.calls
[17:59:29.923]             `[[` <- base::`[[`
[17:59:29.923]             `+` <- base::`+`
[17:59:29.923]             `<<-` <- base::`<<-`
[17:59:29.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.923]                   3L)]
[17:59:29.923]             }
[17:59:29.923]             function(cond) {
[17:59:29.923]                 is_error <- inherits(cond, "error")
[17:59:29.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.923]                   NULL)
[17:59:29.923]                 if (is_error) {
[17:59:29.923]                   sessionInformation <- function() {
[17:59:29.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.923]                       search = base::search(), system = base::Sys.info())
[17:59:29.923]                   }
[17:59:29.923]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.923]                     cond$call), session = sessionInformation(), 
[17:59:29.923]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.923]                   signalCondition(cond)
[17:59:29.923]                 }
[17:59:29.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.923]                 "immediateCondition"))) {
[17:59:29.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.923]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.923]                   if (TRUE && !signal) {
[17:59:29.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.923]                     {
[17:59:29.923]                       inherits <- base::inherits
[17:59:29.923]                       invokeRestart <- base::invokeRestart
[17:59:29.923]                       is.null <- base::is.null
[17:59:29.923]                       muffled <- FALSE
[17:59:29.923]                       if (inherits(cond, "message")) {
[17:59:29.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.923]                         if (muffled) 
[17:59:29.923]                           invokeRestart("muffleMessage")
[17:59:29.923]                       }
[17:59:29.923]                       else if (inherits(cond, "warning")) {
[17:59:29.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.923]                         if (muffled) 
[17:59:29.923]                           invokeRestart("muffleWarning")
[17:59:29.923]                       }
[17:59:29.923]                       else if (inherits(cond, "condition")) {
[17:59:29.923]                         if (!is.null(pattern)) {
[17:59:29.923]                           computeRestarts <- base::computeRestarts
[17:59:29.923]                           grepl <- base::grepl
[17:59:29.923]                           restarts <- computeRestarts(cond)
[17:59:29.923]                           for (restart in restarts) {
[17:59:29.923]                             name <- restart$name
[17:59:29.923]                             if (is.null(name)) 
[17:59:29.923]                               next
[17:59:29.923]                             if (!grepl(pattern, name)) 
[17:59:29.923]                               next
[17:59:29.923]                             invokeRestart(restart)
[17:59:29.923]                             muffled <- TRUE
[17:59:29.923]                             break
[17:59:29.923]                           }
[17:59:29.923]                         }
[17:59:29.923]                       }
[17:59:29.923]                       invisible(muffled)
[17:59:29.923]                     }
[17:59:29.923]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.923]                   }
[17:59:29.923]                 }
[17:59:29.923]                 else {
[17:59:29.923]                   if (TRUE) {
[17:59:29.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.923]                     {
[17:59:29.923]                       inherits <- base::inherits
[17:59:29.923]                       invokeRestart <- base::invokeRestart
[17:59:29.923]                       is.null <- base::is.null
[17:59:29.923]                       muffled <- FALSE
[17:59:29.923]                       if (inherits(cond, "message")) {
[17:59:29.923]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.923]                         if (muffled) 
[17:59:29.923]                           invokeRestart("muffleMessage")
[17:59:29.923]                       }
[17:59:29.923]                       else if (inherits(cond, "warning")) {
[17:59:29.923]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.923]                         if (muffled) 
[17:59:29.923]                           invokeRestart("muffleWarning")
[17:59:29.923]                       }
[17:59:29.923]                       else if (inherits(cond, "condition")) {
[17:59:29.923]                         if (!is.null(pattern)) {
[17:59:29.923]                           computeRestarts <- base::computeRestarts
[17:59:29.923]                           grepl <- base::grepl
[17:59:29.923]                           restarts <- computeRestarts(cond)
[17:59:29.923]                           for (restart in restarts) {
[17:59:29.923]                             name <- restart$name
[17:59:29.923]                             if (is.null(name)) 
[17:59:29.923]                               next
[17:59:29.923]                             if (!grepl(pattern, name)) 
[17:59:29.923]                               next
[17:59:29.923]                             invokeRestart(restart)
[17:59:29.923]                             muffled <- TRUE
[17:59:29.923]                             break
[17:59:29.923]                           }
[17:59:29.923]                         }
[17:59:29.923]                       }
[17:59:29.923]                       invisible(muffled)
[17:59:29.923]                     }
[17:59:29.923]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.923]                   }
[17:59:29.923]                 }
[17:59:29.923]             }
[17:59:29.923]         }))
[17:59:29.923]     }, error = function(ex) {
[17:59:29.923]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.923]                 ...future.rng), started = ...future.startTime, 
[17:59:29.923]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.923]             version = "1.8"), class = "FutureResult")
[17:59:29.923]     }, finally = {
[17:59:29.923]         if (!identical(...future.workdir, getwd())) 
[17:59:29.923]             setwd(...future.workdir)
[17:59:29.923]         {
[17:59:29.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.923]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.923]             }
[17:59:29.923]             base::options(...future.oldOptions)
[17:59:29.923]             if (.Platform$OS.type == "windows") {
[17:59:29.923]                 old_names <- names(...future.oldEnvVars)
[17:59:29.923]                 envs <- base::Sys.getenv()
[17:59:29.923]                 names <- names(envs)
[17:59:29.923]                 common <- intersect(names, old_names)
[17:59:29.923]                 added <- setdiff(names, old_names)
[17:59:29.923]                 removed <- setdiff(old_names, names)
[17:59:29.923]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.923]                   envs[common]]
[17:59:29.923]                 NAMES <- toupper(changed)
[17:59:29.923]                 args <- list()
[17:59:29.923]                 for (kk in seq_along(NAMES)) {
[17:59:29.923]                   name <- changed[[kk]]
[17:59:29.923]                   NAME <- NAMES[[kk]]
[17:59:29.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.923]                     next
[17:59:29.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.923]                 }
[17:59:29.923]                 NAMES <- toupper(added)
[17:59:29.923]                 for (kk in seq_along(NAMES)) {
[17:59:29.923]                   name <- added[[kk]]
[17:59:29.923]                   NAME <- NAMES[[kk]]
[17:59:29.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.923]                     next
[17:59:29.923]                   args[[name]] <- ""
[17:59:29.923]                 }
[17:59:29.923]                 NAMES <- toupper(removed)
[17:59:29.923]                 for (kk in seq_along(NAMES)) {
[17:59:29.923]                   name <- removed[[kk]]
[17:59:29.923]                   NAME <- NAMES[[kk]]
[17:59:29.923]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.923]                     next
[17:59:29.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.923]                 }
[17:59:29.923]                 if (length(args) > 0) 
[17:59:29.923]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.923]             }
[17:59:29.923]             else {
[17:59:29.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.923]             }
[17:59:29.923]             {
[17:59:29.923]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.923]                   0L) {
[17:59:29.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.923]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.923]                   base::options(opts)
[17:59:29.923]                 }
[17:59:29.923]                 {
[17:59:29.923]                   {
[17:59:29.923]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.923]                     NULL
[17:59:29.923]                   }
[17:59:29.923]                   options(future.plan = NULL)
[17:59:29.923]                   if (is.na(NA_character_)) 
[17:59:29.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.923]                     .init = FALSE)
[17:59:29.923]                 }
[17:59:29.923]             }
[17:59:29.923]         }
[17:59:29.923]     })
[17:59:29.923]     if (TRUE) {
[17:59:29.923]         base::sink(type = "output", split = FALSE)
[17:59:29.923]         if (TRUE) {
[17:59:29.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.923]         }
[17:59:29.923]         else {
[17:59:29.923]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.923]         }
[17:59:29.923]         base::close(...future.stdout)
[17:59:29.923]         ...future.stdout <- NULL
[17:59:29.923]     }
[17:59:29.923]     ...future.result$conditions <- ...future.conditions
[17:59:29.923]     ...future.result$finished <- base::Sys.time()
[17:59:29.923]     ...future.result
[17:59:29.923] }
[17:59:29.928] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:59:29.929] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:59:29.929] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:59:29.930] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:29.931] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.931] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:59:29.932] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:59:29.932] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:29.933] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.933] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:29.934] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:29.934] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:59:29.935] MultisessionFuture started
[17:59:29.935] - Launch lazy future ... done
[17:59:29.935] run() for ‘MultisessionFuture’ ... done
[17:59:29.936] Created future:
[17:59:29.936] MultisessionFuture:
[17:59:29.936] Label: ‘future_by-1’
[17:59:29.936] Expression:
[17:59:29.936] {
[17:59:29.936]     do.call(function(...) {
[17:59:29.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.936]             on.exit(options(oopts), add = TRUE)
[17:59:29.936]         }
[17:59:29.936]         {
[17:59:29.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.936]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.936]             })
[17:59:29.936]         }
[17:59:29.936]     }, args = future.call.arguments)
[17:59:29.936] }
[17:59:29.936] Lazy evaluation: FALSE
[17:59:29.936] Asynchronous evaluation: TRUE
[17:59:29.936] Local evaluation: TRUE
[17:59:29.936] Environment: 0x62649f0a6010
[17:59:29.936] Capture standard output: TRUE
[17:59:29.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:29.936] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:29.936] Packages: <none>
[17:59:29.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:29.936] Resolved: FALSE
[17:59:29.936] Value: <not collected>
[17:59:29.936] Conditions captured: <none>
[17:59:29.936] Early signaling: FALSE
[17:59:29.936] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:29.936] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.949] Chunk #1 of 2 ... DONE
[17:59:29.949] Chunk #2 of 2 ...
[17:59:29.949]  - Finding globals in 'X' for chunk #2 ...
[17:59:29.950] getGlobalsAndPackages() ...
[17:59:29.950] Searching for globals...
[17:59:29.951] 
[17:59:29.951] Searching for globals ... DONE
[17:59:29.951] - globals: [0] <none>
[17:59:29.951] getGlobalsAndPackages() ... DONE
[17:59:29.952]    + additional globals found: [n=0] 
[17:59:29.952]    + additional namespaces needed: [n=0] 
[17:59:29.952]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:29.952]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:29.952]  - seeds: <none>
[17:59:29.952]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.953] getGlobalsAndPackages() ...
[17:59:29.953] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.953] Resolving globals: FALSE
[17:59:29.953] Tweak future expression to call with '...' arguments ...
[17:59:29.954] {
[17:59:29.954]     do.call(function(...) {
[17:59:29.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:29.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.954]             on.exit(options(oopts), add = TRUE)
[17:59:29.954]         }
[17:59:29.954]         {
[17:59:29.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:29.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.954]                 ...future.FUN(...future.X_jj, ...)
[17:59:29.954]             })
[17:59:29.954]         }
[17:59:29.954]     }, args = future.call.arguments)
[17:59:29.954] }
[17:59:29.954] Tweak future expression to call with '...' arguments ... DONE
[17:59:29.955] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:29.955] 
[17:59:29.955] getGlobalsAndPackages() ... DONE
[17:59:29.956] run() for ‘Future’ ...
[17:59:29.956] - state: ‘created’
[17:59:29.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:29.985] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:29.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:29.985]   - Field: ‘node’
[17:59:29.985]   - Field: ‘label’
[17:59:29.986]   - Field: ‘local’
[17:59:29.986]   - Field: ‘owner’
[17:59:29.986]   - Field: ‘envir’
[17:59:29.986]   - Field: ‘workers’
[17:59:29.986]   - Field: ‘packages’
[17:59:29.987]   - Field: ‘gc’
[17:59:29.987]   - Field: ‘conditions’
[17:59:29.987]   - Field: ‘persistent’
[17:59:29.987]   - Field: ‘expr’
[17:59:29.987]   - Field: ‘uuid’
[17:59:29.988]   - Field: ‘seed’
[17:59:29.988]   - Field: ‘version’
[17:59:29.988]   - Field: ‘result’
[17:59:29.988]   - Field: ‘asynchronous’
[17:59:29.988]   - Field: ‘calls’
[17:59:29.989]   - Field: ‘globals’
[17:59:29.989]   - Field: ‘stdout’
[17:59:29.989]   - Field: ‘earlySignal’
[17:59:29.989]   - Field: ‘lazy’
[17:59:29.989]   - Field: ‘state’
[17:59:29.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:29.990] - Launch lazy future ...
[17:59:29.990] Packages needed by the future expression (n = 0): <none>
[17:59:29.991] Packages needed by future strategies (n = 0): <none>
[17:59:29.992] {
[17:59:29.992]     {
[17:59:29.992]         {
[17:59:29.992]             ...future.startTime <- base::Sys.time()
[17:59:29.992]             {
[17:59:29.992]                 {
[17:59:29.992]                   {
[17:59:29.992]                     {
[17:59:29.992]                       base::local({
[17:59:29.992]                         has_future <- base::requireNamespace("future", 
[17:59:29.992]                           quietly = TRUE)
[17:59:29.992]                         if (has_future) {
[17:59:29.992]                           ns <- base::getNamespace("future")
[17:59:29.992]                           version <- ns[[".package"]][["version"]]
[17:59:29.992]                           if (is.null(version)) 
[17:59:29.992]                             version <- utils::packageVersion("future")
[17:59:29.992]                         }
[17:59:29.992]                         else {
[17:59:29.992]                           version <- NULL
[17:59:29.992]                         }
[17:59:29.992]                         if (!has_future || version < "1.8.0") {
[17:59:29.992]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:29.992]                             "", base::R.version$version.string), 
[17:59:29.992]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:29.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:29.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:29.992]                               "release", "version")], collapse = " "), 
[17:59:29.992]                             hostname = base::Sys.info()[["nodename"]])
[17:59:29.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:29.992]                             info)
[17:59:29.992]                           info <- base::paste(info, collapse = "; ")
[17:59:29.992]                           if (!has_future) {
[17:59:29.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:29.992]                               info)
[17:59:29.992]                           }
[17:59:29.992]                           else {
[17:59:29.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:29.992]                               info, version)
[17:59:29.992]                           }
[17:59:29.992]                           base::stop(msg)
[17:59:29.992]                         }
[17:59:29.992]                       })
[17:59:29.992]                     }
[17:59:29.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:29.992]                     base::options(mc.cores = 1L)
[17:59:29.992]                   }
[17:59:29.992]                   ...future.strategy.old <- future::plan("list")
[17:59:29.992]                   options(future.plan = NULL)
[17:59:29.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:29.992]                 }
[17:59:29.992]                 ...future.workdir <- getwd()
[17:59:29.992]             }
[17:59:29.992]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:29.992]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:29.992]         }
[17:59:29.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:29.992]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:29.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:29.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:29.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:29.992]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:29.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:29.992]             base::names(...future.oldOptions))
[17:59:29.992]     }
[17:59:29.992]     if (FALSE) {
[17:59:29.992]     }
[17:59:29.992]     else {
[17:59:29.992]         if (TRUE) {
[17:59:29.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:29.992]                 open = "w")
[17:59:29.992]         }
[17:59:29.992]         else {
[17:59:29.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:29.992]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:29.992]         }
[17:59:29.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:29.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:29.992]             base::sink(type = "output", split = FALSE)
[17:59:29.992]             base::close(...future.stdout)
[17:59:29.992]         }, add = TRUE)
[17:59:29.992]     }
[17:59:29.992]     ...future.frame <- base::sys.nframe()
[17:59:29.992]     ...future.conditions <- base::list()
[17:59:29.992]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:29.992]     if (FALSE) {
[17:59:29.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:29.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:29.992]     }
[17:59:29.992]     ...future.result <- base::tryCatch({
[17:59:29.992]         base::withCallingHandlers({
[17:59:29.992]             ...future.value <- base::withVisible(base::local({
[17:59:29.992]                 ...future.makeSendCondition <- base::local({
[17:59:29.992]                   sendCondition <- NULL
[17:59:29.992]                   function(frame = 1L) {
[17:59:29.992]                     if (is.function(sendCondition)) 
[17:59:29.992]                       return(sendCondition)
[17:59:29.992]                     ns <- getNamespace("parallel")
[17:59:29.992]                     if (exists("sendData", mode = "function", 
[17:59:29.992]                       envir = ns)) {
[17:59:29.992]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:29.992]                         envir = ns)
[17:59:29.992]                       envir <- sys.frame(frame)
[17:59:29.992]                       master <- NULL
[17:59:29.992]                       while (!identical(envir, .GlobalEnv) && 
[17:59:29.992]                         !identical(envir, emptyenv())) {
[17:59:29.992]                         if (exists("master", mode = "list", envir = envir, 
[17:59:29.992]                           inherits = FALSE)) {
[17:59:29.992]                           master <- get("master", mode = "list", 
[17:59:29.992]                             envir = envir, inherits = FALSE)
[17:59:29.992]                           if (inherits(master, c("SOCKnode", 
[17:59:29.992]                             "SOCK0node"))) {
[17:59:29.992]                             sendCondition <<- function(cond) {
[17:59:29.992]                               data <- list(type = "VALUE", value = cond, 
[17:59:29.992]                                 success = TRUE)
[17:59:29.992]                               parallel_sendData(master, data)
[17:59:29.992]                             }
[17:59:29.992]                             return(sendCondition)
[17:59:29.992]                           }
[17:59:29.992]                         }
[17:59:29.992]                         frame <- frame + 1L
[17:59:29.992]                         envir <- sys.frame(frame)
[17:59:29.992]                       }
[17:59:29.992]                     }
[17:59:29.992]                     sendCondition <<- function(cond) NULL
[17:59:29.992]                   }
[17:59:29.992]                 })
[17:59:29.992]                 withCallingHandlers({
[17:59:29.992]                   {
[17:59:29.992]                     do.call(function(...) {
[17:59:29.992]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:29.992]                       if (!identical(...future.globals.maxSize.org, 
[17:59:29.992]                         ...future.globals.maxSize)) {
[17:59:29.992]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:29.992]                         on.exit(options(oopts), add = TRUE)
[17:59:29.992]                       }
[17:59:29.992]                       {
[17:59:29.992]                         lapply(seq_along(...future.elements_ii), 
[17:59:29.992]                           FUN = function(jj) {
[17:59:29.992]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:29.992]                             ...future.FUN(...future.X_jj, ...)
[17:59:29.992]                           })
[17:59:29.992]                       }
[17:59:29.992]                     }, args = future.call.arguments)
[17:59:29.992]                   }
[17:59:29.992]                 }, immediateCondition = function(cond) {
[17:59:29.992]                   sendCondition <- ...future.makeSendCondition()
[17:59:29.992]                   sendCondition(cond)
[17:59:29.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.992]                   {
[17:59:29.992]                     inherits <- base::inherits
[17:59:29.992]                     invokeRestart <- base::invokeRestart
[17:59:29.992]                     is.null <- base::is.null
[17:59:29.992]                     muffled <- FALSE
[17:59:29.992]                     if (inherits(cond, "message")) {
[17:59:29.992]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:29.992]                       if (muffled) 
[17:59:29.992]                         invokeRestart("muffleMessage")
[17:59:29.992]                     }
[17:59:29.992]                     else if (inherits(cond, "warning")) {
[17:59:29.992]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:29.992]                       if (muffled) 
[17:59:29.992]                         invokeRestart("muffleWarning")
[17:59:29.992]                     }
[17:59:29.992]                     else if (inherits(cond, "condition")) {
[17:59:29.992]                       if (!is.null(pattern)) {
[17:59:29.992]                         computeRestarts <- base::computeRestarts
[17:59:29.992]                         grepl <- base::grepl
[17:59:29.992]                         restarts <- computeRestarts(cond)
[17:59:29.992]                         for (restart in restarts) {
[17:59:29.992]                           name <- restart$name
[17:59:29.992]                           if (is.null(name)) 
[17:59:29.992]                             next
[17:59:29.992]                           if (!grepl(pattern, name)) 
[17:59:29.992]                             next
[17:59:29.992]                           invokeRestart(restart)
[17:59:29.992]                           muffled <- TRUE
[17:59:29.992]                           break
[17:59:29.992]                         }
[17:59:29.992]                       }
[17:59:29.992]                     }
[17:59:29.992]                     invisible(muffled)
[17:59:29.992]                   }
[17:59:29.992]                   muffleCondition(cond)
[17:59:29.992]                 })
[17:59:29.992]             }))
[17:59:29.992]             future::FutureResult(value = ...future.value$value, 
[17:59:29.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.992]                   ...future.rng), globalenv = if (FALSE) 
[17:59:29.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:29.992]                     ...future.globalenv.names))
[17:59:29.992]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:29.992]         }, condition = base::local({
[17:59:29.992]             c <- base::c
[17:59:29.992]             inherits <- base::inherits
[17:59:29.992]             invokeRestart <- base::invokeRestart
[17:59:29.992]             length <- base::length
[17:59:29.992]             list <- base::list
[17:59:29.992]             seq.int <- base::seq.int
[17:59:29.992]             signalCondition <- base::signalCondition
[17:59:29.992]             sys.calls <- base::sys.calls
[17:59:29.992]             `[[` <- base::`[[`
[17:59:29.992]             `+` <- base::`+`
[17:59:29.992]             `<<-` <- base::`<<-`
[17:59:29.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:29.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:29.992]                   3L)]
[17:59:29.992]             }
[17:59:29.992]             function(cond) {
[17:59:29.992]                 is_error <- inherits(cond, "error")
[17:59:29.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:29.992]                   NULL)
[17:59:29.992]                 if (is_error) {
[17:59:29.992]                   sessionInformation <- function() {
[17:59:29.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:29.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:29.992]                       search = base::search(), system = base::Sys.info())
[17:59:29.992]                   }
[17:59:29.992]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:29.992]                     cond$call), session = sessionInformation(), 
[17:59:29.992]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:29.992]                   signalCondition(cond)
[17:59:29.992]                 }
[17:59:29.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:29.992]                 "immediateCondition"))) {
[17:59:29.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:29.992]                   ...future.conditions[[length(...future.conditions) + 
[17:59:29.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:29.992]                   if (TRUE && !signal) {
[17:59:29.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.992]                     {
[17:59:29.992]                       inherits <- base::inherits
[17:59:29.992]                       invokeRestart <- base::invokeRestart
[17:59:29.992]                       is.null <- base::is.null
[17:59:29.992]                       muffled <- FALSE
[17:59:29.992]                       if (inherits(cond, "message")) {
[17:59:29.992]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.992]                         if (muffled) 
[17:59:29.992]                           invokeRestart("muffleMessage")
[17:59:29.992]                       }
[17:59:29.992]                       else if (inherits(cond, "warning")) {
[17:59:29.992]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.992]                         if (muffled) 
[17:59:29.992]                           invokeRestart("muffleWarning")
[17:59:29.992]                       }
[17:59:29.992]                       else if (inherits(cond, "condition")) {
[17:59:29.992]                         if (!is.null(pattern)) {
[17:59:29.992]                           computeRestarts <- base::computeRestarts
[17:59:29.992]                           grepl <- base::grepl
[17:59:29.992]                           restarts <- computeRestarts(cond)
[17:59:29.992]                           for (restart in restarts) {
[17:59:29.992]                             name <- restart$name
[17:59:29.992]                             if (is.null(name)) 
[17:59:29.992]                               next
[17:59:29.992]                             if (!grepl(pattern, name)) 
[17:59:29.992]                               next
[17:59:29.992]                             invokeRestart(restart)
[17:59:29.992]                             muffled <- TRUE
[17:59:29.992]                             break
[17:59:29.992]                           }
[17:59:29.992]                         }
[17:59:29.992]                       }
[17:59:29.992]                       invisible(muffled)
[17:59:29.992]                     }
[17:59:29.992]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.992]                   }
[17:59:29.992]                 }
[17:59:29.992]                 else {
[17:59:29.992]                   if (TRUE) {
[17:59:29.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:29.992]                     {
[17:59:29.992]                       inherits <- base::inherits
[17:59:29.992]                       invokeRestart <- base::invokeRestart
[17:59:29.992]                       is.null <- base::is.null
[17:59:29.992]                       muffled <- FALSE
[17:59:29.992]                       if (inherits(cond, "message")) {
[17:59:29.992]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:29.992]                         if (muffled) 
[17:59:29.992]                           invokeRestart("muffleMessage")
[17:59:29.992]                       }
[17:59:29.992]                       else if (inherits(cond, "warning")) {
[17:59:29.992]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:29.992]                         if (muffled) 
[17:59:29.992]                           invokeRestart("muffleWarning")
[17:59:29.992]                       }
[17:59:29.992]                       else if (inherits(cond, "condition")) {
[17:59:29.992]                         if (!is.null(pattern)) {
[17:59:29.992]                           computeRestarts <- base::computeRestarts
[17:59:29.992]                           grepl <- base::grepl
[17:59:29.992]                           restarts <- computeRestarts(cond)
[17:59:29.992]                           for (restart in restarts) {
[17:59:29.992]                             name <- restart$name
[17:59:29.992]                             if (is.null(name)) 
[17:59:29.992]                               next
[17:59:29.992]                             if (!grepl(pattern, name)) 
[17:59:29.992]                               next
[17:59:29.992]                             invokeRestart(restart)
[17:59:29.992]                             muffled <- TRUE
[17:59:29.992]                             break
[17:59:29.992]                           }
[17:59:29.992]                         }
[17:59:29.992]                       }
[17:59:29.992]                       invisible(muffled)
[17:59:29.992]                     }
[17:59:29.992]                     muffleCondition(cond, pattern = "^muffle")
[17:59:29.992]                   }
[17:59:29.992]                 }
[17:59:29.992]             }
[17:59:29.992]         }))
[17:59:29.992]     }, error = function(ex) {
[17:59:29.992]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:29.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:29.992]                 ...future.rng), started = ...future.startTime, 
[17:59:29.992]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:29.992]             version = "1.8"), class = "FutureResult")
[17:59:29.992]     }, finally = {
[17:59:29.992]         if (!identical(...future.workdir, getwd())) 
[17:59:29.992]             setwd(...future.workdir)
[17:59:29.992]         {
[17:59:29.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:29.992]                 ...future.oldOptions$nwarnings <- NULL
[17:59:29.992]             }
[17:59:29.992]             base::options(...future.oldOptions)
[17:59:29.992]             if (.Platform$OS.type == "windows") {
[17:59:29.992]                 old_names <- names(...future.oldEnvVars)
[17:59:29.992]                 envs <- base::Sys.getenv()
[17:59:29.992]                 names <- names(envs)
[17:59:29.992]                 common <- intersect(names, old_names)
[17:59:29.992]                 added <- setdiff(names, old_names)
[17:59:29.992]                 removed <- setdiff(old_names, names)
[17:59:29.992]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:29.992]                   envs[common]]
[17:59:29.992]                 NAMES <- toupper(changed)
[17:59:29.992]                 args <- list()
[17:59:29.992]                 for (kk in seq_along(NAMES)) {
[17:59:29.992]                   name <- changed[[kk]]
[17:59:29.992]                   NAME <- NAMES[[kk]]
[17:59:29.992]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.992]                     next
[17:59:29.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.992]                 }
[17:59:29.992]                 NAMES <- toupper(added)
[17:59:29.992]                 for (kk in seq_along(NAMES)) {
[17:59:29.992]                   name <- added[[kk]]
[17:59:29.992]                   NAME <- NAMES[[kk]]
[17:59:29.992]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.992]                     next
[17:59:29.992]                   args[[name]] <- ""
[17:59:29.992]                 }
[17:59:29.992]                 NAMES <- toupper(removed)
[17:59:29.992]                 for (kk in seq_along(NAMES)) {
[17:59:29.992]                   name <- removed[[kk]]
[17:59:29.992]                   NAME <- NAMES[[kk]]
[17:59:29.992]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:29.992]                     next
[17:59:29.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:29.992]                 }
[17:59:29.992]                 if (length(args) > 0) 
[17:59:29.992]                   base::do.call(base::Sys.setenv, args = args)
[17:59:29.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:29.992]             }
[17:59:29.992]             else {
[17:59:29.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:29.992]             }
[17:59:29.992]             {
[17:59:29.992]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:29.992]                   0L) {
[17:59:29.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:29.992]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:29.992]                   base::options(opts)
[17:59:29.992]                 }
[17:59:29.992]                 {
[17:59:29.992]                   {
[17:59:29.992]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:29.992]                     NULL
[17:59:29.992]                   }
[17:59:29.992]                   options(future.plan = NULL)
[17:59:29.992]                   if (is.na(NA_character_)) 
[17:59:29.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:29.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:29.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:29.992]                     .init = FALSE)
[17:59:29.992]                 }
[17:59:29.992]             }
[17:59:29.992]         }
[17:59:29.992]     })
[17:59:29.992]     if (TRUE) {
[17:59:29.992]         base::sink(type = "output", split = FALSE)
[17:59:29.992]         if (TRUE) {
[17:59:29.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:29.992]         }
[17:59:29.992]         else {
[17:59:29.992]             ...future.result["stdout"] <- base::list(NULL)
[17:59:29.992]         }
[17:59:29.992]         base::close(...future.stdout)
[17:59:29.992]         ...future.stdout <- NULL
[17:59:29.992]     }
[17:59:29.992]     ...future.result$conditions <- ...future.conditions
[17:59:29.992]     ...future.result$finished <- base::Sys.time()
[17:59:29.992]     ...future.result
[17:59:29.992] }
[17:59:29.997] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:59:29.997] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:59:29.998] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:59:29.998] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:29.999] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:30.000] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:59:30.001] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:59:30.001] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:30.002] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:30.002] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:30.003] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:30.003] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:59:30.004] MultisessionFuture started
[17:59:30.004] - Launch lazy future ... done
[17:59:30.004] run() for ‘MultisessionFuture’ ... done
[17:59:30.005] Created future:
[17:59:30.005] MultisessionFuture:
[17:59:30.005] Label: ‘future_by-2’
[17:59:30.005] Expression:
[17:59:30.005] {
[17:59:30.005]     do.call(function(...) {
[17:59:30.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.005]             on.exit(options(oopts), add = TRUE)
[17:59:30.005]         }
[17:59:30.005]         {
[17:59:30.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.005]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.005]             })
[17:59:30.005]         }
[17:59:30.005]     }, args = future.call.arguments)
[17:59:30.005] }
[17:59:30.005] Lazy evaluation: FALSE
[17:59:30.005] Asynchronous evaluation: TRUE
[17:59:30.005] Local evaluation: TRUE
[17:59:30.005] Environment: 0x62649f0a6010
[17:59:30.005] Capture standard output: TRUE
[17:59:30.005] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:30.005] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:30.005] Packages: <none>
[17:59:30.005] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:30.005] Resolved: FALSE
[17:59:30.005] Value: <not collected>
[17:59:30.005] Conditions captured: <none>
[17:59:30.005] Early signaling: FALSE
[17:59:30.005] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:30.005] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:30.018] Chunk #2 of 2 ... DONE
[17:59:30.019] Launching 2 futures (chunks) ... DONE
[17:59:30.019] Resolving 2 futures (chunks) ...
[17:59:30.019] resolve() on list ...
[17:59:30.019]  recursive: 0
[17:59:30.019]  length: 2
[17:59:30.020] 
[17:59:30.021] receiveMessageFromWorker() for ClusterFuture ...
[17:59:30.021] - Validating connection of MultisessionFuture
[17:59:30.021] - received message: FutureResult
[17:59:30.022] - Received FutureResult
[17:59:30.022] - Erased future from FutureRegistry
[17:59:30.022] result() for ClusterFuture ...
[17:59:30.022] - result already collected: FutureResult
[17:59:30.022] result() for ClusterFuture ... done
[17:59:30.023] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:30.023] Future #1
[17:59:30.023] result() for ClusterFuture ...
[17:59:30.023] - result already collected: FutureResult
[17:59:30.023] result() for ClusterFuture ... done
[17:59:30.024] result() for ClusterFuture ...
[17:59:30.024] - result already collected: FutureResult
[17:59:30.024] result() for ClusterFuture ... done
[17:59:30.024] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:30.024] - nx: 2
[17:59:30.025] - relay: TRUE
[17:59:30.025] - stdout: TRUE
[17:59:30.025] - signal: TRUE
[17:59:30.025] - resignal: FALSE
[17:59:30.025] - force: TRUE
[17:59:30.026] - relayed: [n=2] FALSE, FALSE
[17:59:30.026] - queued futures: [n=2] FALSE, FALSE
[17:59:30.026]  - until=1
[17:59:30.026]  - relaying element #1
[17:59:30.026] result() for ClusterFuture ...
[17:59:30.027] - result already collected: FutureResult
[17:59:30.027] result() for ClusterFuture ... done
[17:59:30.027] result() for ClusterFuture ...
[17:59:30.027] - result already collected: FutureResult
[17:59:30.027] result() for ClusterFuture ... done
[17:59:30.028] result() for ClusterFuture ...
[17:59:30.028] - result already collected: FutureResult
[17:59:30.028] result() for ClusterFuture ... done
[17:59:30.028] result() for ClusterFuture ...
[17:59:30.028] - result already collected: FutureResult
[17:59:30.029] result() for ClusterFuture ... done
[17:59:30.029] - relayed: [n=2] TRUE, FALSE
[17:59:30.029] - queued futures: [n=2] TRUE, FALSE
[17:59:30.029] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:30.029]  length: 1 (resolved future 1)
[17:59:30.051] receiveMessageFromWorker() for ClusterFuture ...
[17:59:30.052] - Validating connection of MultisessionFuture
[17:59:30.052] - received message: FutureResult
[17:59:30.052] - Received FutureResult
[17:59:30.053] - Erased future from FutureRegistry
[17:59:30.053] result() for ClusterFuture ...
[17:59:30.053] - result already collected: FutureResult
[17:59:30.053] result() for ClusterFuture ... done
[17:59:30.053] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:30.054] Future #2
[17:59:30.054] result() for ClusterFuture ...
[17:59:30.054] - result already collected: FutureResult
[17:59:30.054] result() for ClusterFuture ... done
[17:59:30.054] result() for ClusterFuture ...
[17:59:30.055] - result already collected: FutureResult
[17:59:30.055] result() for ClusterFuture ... done
[17:59:30.055] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:30.055] - nx: 2
[17:59:30.055] - relay: TRUE
[17:59:30.055] - stdout: TRUE
[17:59:30.056] - signal: TRUE
[17:59:30.056] - resignal: FALSE
[17:59:30.056] - force: TRUE
[17:59:30.056] - relayed: [n=2] TRUE, FALSE
[17:59:30.056] - queued futures: [n=2] TRUE, FALSE
[17:59:30.057]  - until=2
[17:59:30.057]  - relaying element #2
[17:59:30.057] result() for ClusterFuture ...
[17:59:30.057] - result already collected: FutureResult
[17:59:30.057] result() for ClusterFuture ... done
[17:59:30.058] result() for ClusterFuture ...
[17:59:30.058] - result already collected: FutureResult
[17:59:30.058] result() for ClusterFuture ... done
[17:59:30.058] result() for ClusterFuture ...
[17:59:30.058] - result already collected: FutureResult
[17:59:30.059] result() for ClusterFuture ... done
[17:59:30.059] result() for ClusterFuture ...
[17:59:30.059] - result already collected: FutureResult
[17:59:30.059] result() for ClusterFuture ... done
[17:59:30.059] - relayed: [n=2] TRUE, TRUE
[17:59:30.059] - queued futures: [n=2] TRUE, TRUE
[17:59:30.060] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:30.060]  length: 0 (resolved future 2)
[17:59:30.060] Relaying remaining futures
[17:59:30.060] signalConditionsASAP(NULL, pos=0) ...
[17:59:30.060] - nx: 2
[17:59:30.061] - relay: TRUE
[17:59:30.061] - stdout: TRUE
[17:59:30.061] - signal: TRUE
[17:59:30.061] - resignal: FALSE
[17:59:30.061] - force: TRUE
[17:59:30.061] - relayed: [n=2] TRUE, TRUE
[17:59:30.062] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:30.062] - relayed: [n=2] TRUE, TRUE
[17:59:30.062] - queued futures: [n=2] TRUE, TRUE
[17:59:30.062] signalConditionsASAP(NULL, pos=0) ... done
[17:59:30.062] resolve() on list ... DONE
[17:59:30.063] result() for ClusterFuture ...
[17:59:30.063] - result already collected: FutureResult
[17:59:30.063] result() for ClusterFuture ... done
[17:59:30.063] result() for ClusterFuture ...
[17:59:30.063] - result already collected: FutureResult
[17:59:30.064] result() for ClusterFuture ... done
[17:59:30.064] result() for ClusterFuture ...
[17:59:30.064] - result already collected: FutureResult
[17:59:30.064] result() for ClusterFuture ... done
[17:59:30.064] result() for ClusterFuture ...
[17:59:30.065] - result already collected: FutureResult
[17:59:30.065] result() for ClusterFuture ... done
[17:59:30.065]  - Number of value chunks collected: 2
[17:59:30.065] Resolving 2 futures (chunks) ... DONE
[17:59:30.065] Reducing values from 2 chunks ...
[17:59:30.065]  - Number of values collected after concatenation: 3
[17:59:30.066]  - Number of values expected: 3
[17:59:30.066] Reducing values from 2 chunks ... DONE
[17:59:30.066] future_lapply() ... DONE
[17:59:30.066] future_by_internal() ... DONE
[17:59:30.068] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[17:59:30.069] future_lapply() ...
[17:59:30.076] Number of chunks: 2
[17:59:30.076] getGlobalsAndPackagesXApply() ...
[17:59:30.076]  - future.globals: TRUE
[17:59:30.076] getGlobalsAndPackages() ...
[17:59:30.077] Searching for globals...
[17:59:30.079] - globals found: [2] ‘FUN’, ‘UseMethod’
[17:59:30.079] Searching for globals ... DONE
[17:59:30.079] Resolving globals: FALSE
[17:59:30.083] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[17:59:30.084] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[17:59:30.084] - globals: [1] ‘FUN’
[17:59:30.084] 
[17:59:30.084] getGlobalsAndPackages() ... DONE
[17:59:30.084]  - globals found/used: [n=1] ‘FUN’
[17:59:30.085]  - needed namespaces: [n=0] 
[17:59:30.085] Finding globals ... DONE
[17:59:30.085]  - use_args: TRUE
[17:59:30.085]  - Getting '...' globals ...
[17:59:30.086] resolve() on list ...
[17:59:30.086]  recursive: 0
[17:59:30.086]  length: 1
[17:59:30.086]  elements: ‘...’
[17:59:30.087]  length: 0 (resolved future 1)
[17:59:30.087] resolve() on list ... DONE
[17:59:30.087]    - '...' content: [n=0] 
[17:59:30.087] List of 1
[17:59:30.087]  $ ...: list()
[17:59:30.087]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.087]  - attr(*, "where")=List of 1
[17:59:30.087]   ..$ ...:<environment: 0x6264a26668b0> 
[17:59:30.087]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.087]  - attr(*, "resolved")= logi TRUE
[17:59:30.087]  - attr(*, "total_size")= num NA
[17:59:30.092]  - Getting '...' globals ... DONE
[17:59:30.092] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:59:30.093] List of 2
[17:59:30.093]  $ ...future.FUN:function (object, ...)  
[17:59:30.093]  $ ...          : list()
[17:59:30.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:59:30.093]  - attr(*, "where")=List of 2
[17:59:30.093]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:59:30.093]   ..$ ...          :<environment: 0x6264a26668b0> 
[17:59:30.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:59:30.093]  - attr(*, "resolved")= logi FALSE
[17:59:30.093]  - attr(*, "total_size")= num 1240
[17:59:30.098] Packages to be attached in all futures: [n=0] 
[17:59:30.098] getGlobalsAndPackagesXApply() ... DONE
[17:59:30.098] Number of futures (= number of chunks): 2
[17:59:30.099] Launching 2 futures (chunks) ...
[17:59:30.099] Chunk #1 of 2 ...
[17:59:30.099]  - Finding globals in 'X' for chunk #1 ...
[17:59:30.099] getGlobalsAndPackages() ...
[17:59:30.099] Searching for globals...
[17:59:30.100] 
[17:59:30.100] Searching for globals ... DONE
[17:59:30.101] - globals: [0] <none>
[17:59:30.101] getGlobalsAndPackages() ... DONE
[17:59:30.101]    + additional globals found: [n=0] 
[17:59:30.101]    + additional namespaces needed: [n=0] 
[17:59:30.101]  - Finding globals in 'X' for chunk #1 ... DONE
[17:59:30.102]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:30.102]  - seeds: <none>
[17:59:30.102]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.102] getGlobalsAndPackages() ...
[17:59:30.102] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.103] Resolving globals: FALSE
[17:59:30.103] Tweak future expression to call with '...' arguments ...
[17:59:30.103] {
[17:59:30.103]     do.call(function(...) {
[17:59:30.103]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.103]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.103]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.103]             on.exit(options(oopts), add = TRUE)
[17:59:30.103]         }
[17:59:30.103]         {
[17:59:30.103]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.103]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.103]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.103]             })
[17:59:30.103]         }
[17:59:30.103]     }, args = future.call.arguments)
[17:59:30.103] }
[17:59:30.103] Tweak future expression to call with '...' arguments ... DONE
[17:59:30.104] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.104] 
[17:59:30.105] getGlobalsAndPackages() ... DONE
[17:59:30.105] run() for ‘Future’ ...
[17:59:30.105] - state: ‘created’
[17:59:30.106] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:30.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:30.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:30.130]   - Field: ‘node’
[17:59:30.130]   - Field: ‘label’
[17:59:30.130]   - Field: ‘local’
[17:59:30.130]   - Field: ‘owner’
[17:59:30.131]   - Field: ‘envir’
[17:59:30.131]   - Field: ‘workers’
[17:59:30.131]   - Field: ‘packages’
[17:59:30.131]   - Field: ‘gc’
[17:59:30.131]   - Field: ‘conditions’
[17:59:30.132]   - Field: ‘persistent’
[17:59:30.132]   - Field: ‘expr’
[17:59:30.132]   - Field: ‘uuid’
[17:59:30.132]   - Field: ‘seed’
[17:59:30.132]   - Field: ‘version’
[17:59:30.132]   - Field: ‘result’
[17:59:30.133]   - Field: ‘asynchronous’
[17:59:30.133]   - Field: ‘calls’
[17:59:30.133]   - Field: ‘globals’
[17:59:30.133]   - Field: ‘stdout’
[17:59:30.133]   - Field: ‘earlySignal’
[17:59:30.134]   - Field: ‘lazy’
[17:59:30.134]   - Field: ‘state’
[17:59:30.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:30.134] - Launch lazy future ...
[17:59:30.135] Packages needed by the future expression (n = 0): <none>
[17:59:30.135] Packages needed by future strategies (n = 0): <none>
[17:59:30.136] {
[17:59:30.136]     {
[17:59:30.136]         {
[17:59:30.136]             ...future.startTime <- base::Sys.time()
[17:59:30.136]             {
[17:59:30.136]                 {
[17:59:30.136]                   {
[17:59:30.136]                     {
[17:59:30.136]                       base::local({
[17:59:30.136]                         has_future <- base::requireNamespace("future", 
[17:59:30.136]                           quietly = TRUE)
[17:59:30.136]                         if (has_future) {
[17:59:30.136]                           ns <- base::getNamespace("future")
[17:59:30.136]                           version <- ns[[".package"]][["version"]]
[17:59:30.136]                           if (is.null(version)) 
[17:59:30.136]                             version <- utils::packageVersion("future")
[17:59:30.136]                         }
[17:59:30.136]                         else {
[17:59:30.136]                           version <- NULL
[17:59:30.136]                         }
[17:59:30.136]                         if (!has_future || version < "1.8.0") {
[17:59:30.136]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:30.136]                             "", base::R.version$version.string), 
[17:59:30.136]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:30.136]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:30.136]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:30.136]                               "release", "version")], collapse = " "), 
[17:59:30.136]                             hostname = base::Sys.info()[["nodename"]])
[17:59:30.136]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:30.136]                             info)
[17:59:30.136]                           info <- base::paste(info, collapse = "; ")
[17:59:30.136]                           if (!has_future) {
[17:59:30.136]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:30.136]                               info)
[17:59:30.136]                           }
[17:59:30.136]                           else {
[17:59:30.136]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:30.136]                               info, version)
[17:59:30.136]                           }
[17:59:30.136]                           base::stop(msg)
[17:59:30.136]                         }
[17:59:30.136]                       })
[17:59:30.136]                     }
[17:59:30.136]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:30.136]                     base::options(mc.cores = 1L)
[17:59:30.136]                   }
[17:59:30.136]                   ...future.strategy.old <- future::plan("list")
[17:59:30.136]                   options(future.plan = NULL)
[17:59:30.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:30.136]                 }
[17:59:30.136]                 ...future.workdir <- getwd()
[17:59:30.136]             }
[17:59:30.136]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:30.136]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:30.136]         }
[17:59:30.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:30.136]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:30.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:30.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:30.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:30.136]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:30.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:30.136]             base::names(...future.oldOptions))
[17:59:30.136]     }
[17:59:30.136]     if (FALSE) {
[17:59:30.136]     }
[17:59:30.136]     else {
[17:59:30.136]         if (TRUE) {
[17:59:30.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:30.136]                 open = "w")
[17:59:30.136]         }
[17:59:30.136]         else {
[17:59:30.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:30.136]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:30.136]         }
[17:59:30.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:30.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:30.136]             base::sink(type = "output", split = FALSE)
[17:59:30.136]             base::close(...future.stdout)
[17:59:30.136]         }, add = TRUE)
[17:59:30.136]     }
[17:59:30.136]     ...future.frame <- base::sys.nframe()
[17:59:30.136]     ...future.conditions <- base::list()
[17:59:30.136]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:30.136]     if (FALSE) {
[17:59:30.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:30.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:30.136]     }
[17:59:30.136]     ...future.result <- base::tryCatch({
[17:59:30.136]         base::withCallingHandlers({
[17:59:30.136]             ...future.value <- base::withVisible(base::local({
[17:59:30.136]                 ...future.makeSendCondition <- base::local({
[17:59:30.136]                   sendCondition <- NULL
[17:59:30.136]                   function(frame = 1L) {
[17:59:30.136]                     if (is.function(sendCondition)) 
[17:59:30.136]                       return(sendCondition)
[17:59:30.136]                     ns <- getNamespace("parallel")
[17:59:30.136]                     if (exists("sendData", mode = "function", 
[17:59:30.136]                       envir = ns)) {
[17:59:30.136]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:30.136]                         envir = ns)
[17:59:30.136]                       envir <- sys.frame(frame)
[17:59:30.136]                       master <- NULL
[17:59:30.136]                       while (!identical(envir, .GlobalEnv) && 
[17:59:30.136]                         !identical(envir, emptyenv())) {
[17:59:30.136]                         if (exists("master", mode = "list", envir = envir, 
[17:59:30.136]                           inherits = FALSE)) {
[17:59:30.136]                           master <- get("master", mode = "list", 
[17:59:30.136]                             envir = envir, inherits = FALSE)
[17:59:30.136]                           if (inherits(master, c("SOCKnode", 
[17:59:30.136]                             "SOCK0node"))) {
[17:59:30.136]                             sendCondition <<- function(cond) {
[17:59:30.136]                               data <- list(type = "VALUE", value = cond, 
[17:59:30.136]                                 success = TRUE)
[17:59:30.136]                               parallel_sendData(master, data)
[17:59:30.136]                             }
[17:59:30.136]                             return(sendCondition)
[17:59:30.136]                           }
[17:59:30.136]                         }
[17:59:30.136]                         frame <- frame + 1L
[17:59:30.136]                         envir <- sys.frame(frame)
[17:59:30.136]                       }
[17:59:30.136]                     }
[17:59:30.136]                     sendCondition <<- function(cond) NULL
[17:59:30.136]                   }
[17:59:30.136]                 })
[17:59:30.136]                 withCallingHandlers({
[17:59:30.136]                   {
[17:59:30.136]                     do.call(function(...) {
[17:59:30.136]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.136]                       if (!identical(...future.globals.maxSize.org, 
[17:59:30.136]                         ...future.globals.maxSize)) {
[17:59:30.136]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.136]                         on.exit(options(oopts), add = TRUE)
[17:59:30.136]                       }
[17:59:30.136]                       {
[17:59:30.136]                         lapply(seq_along(...future.elements_ii), 
[17:59:30.136]                           FUN = function(jj) {
[17:59:30.136]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.136]                             ...future.FUN(...future.X_jj, ...)
[17:59:30.136]                           })
[17:59:30.136]                       }
[17:59:30.136]                     }, args = future.call.arguments)
[17:59:30.136]                   }
[17:59:30.136]                 }, immediateCondition = function(cond) {
[17:59:30.136]                   sendCondition <- ...future.makeSendCondition()
[17:59:30.136]                   sendCondition(cond)
[17:59:30.136]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.136]                   {
[17:59:30.136]                     inherits <- base::inherits
[17:59:30.136]                     invokeRestart <- base::invokeRestart
[17:59:30.136]                     is.null <- base::is.null
[17:59:30.136]                     muffled <- FALSE
[17:59:30.136]                     if (inherits(cond, "message")) {
[17:59:30.136]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:30.136]                       if (muffled) 
[17:59:30.136]                         invokeRestart("muffleMessage")
[17:59:30.136]                     }
[17:59:30.136]                     else if (inherits(cond, "warning")) {
[17:59:30.136]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:30.136]                       if (muffled) 
[17:59:30.136]                         invokeRestart("muffleWarning")
[17:59:30.136]                     }
[17:59:30.136]                     else if (inherits(cond, "condition")) {
[17:59:30.136]                       if (!is.null(pattern)) {
[17:59:30.136]                         computeRestarts <- base::computeRestarts
[17:59:30.136]                         grepl <- base::grepl
[17:59:30.136]                         restarts <- computeRestarts(cond)
[17:59:30.136]                         for (restart in restarts) {
[17:59:30.136]                           name <- restart$name
[17:59:30.136]                           if (is.null(name)) 
[17:59:30.136]                             next
[17:59:30.136]                           if (!grepl(pattern, name)) 
[17:59:30.136]                             next
[17:59:30.136]                           invokeRestart(restart)
[17:59:30.136]                           muffled <- TRUE
[17:59:30.136]                           break
[17:59:30.136]                         }
[17:59:30.136]                       }
[17:59:30.136]                     }
[17:59:30.136]                     invisible(muffled)
[17:59:30.136]                   }
[17:59:30.136]                   muffleCondition(cond)
[17:59:30.136]                 })
[17:59:30.136]             }))
[17:59:30.136]             future::FutureResult(value = ...future.value$value, 
[17:59:30.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.136]                   ...future.rng), globalenv = if (FALSE) 
[17:59:30.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:30.136]                     ...future.globalenv.names))
[17:59:30.136]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:30.136]         }, condition = base::local({
[17:59:30.136]             c <- base::c
[17:59:30.136]             inherits <- base::inherits
[17:59:30.136]             invokeRestart <- base::invokeRestart
[17:59:30.136]             length <- base::length
[17:59:30.136]             list <- base::list
[17:59:30.136]             seq.int <- base::seq.int
[17:59:30.136]             signalCondition <- base::signalCondition
[17:59:30.136]             sys.calls <- base::sys.calls
[17:59:30.136]             `[[` <- base::`[[`
[17:59:30.136]             `+` <- base::`+`
[17:59:30.136]             `<<-` <- base::`<<-`
[17:59:30.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:30.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:30.136]                   3L)]
[17:59:30.136]             }
[17:59:30.136]             function(cond) {
[17:59:30.136]                 is_error <- inherits(cond, "error")
[17:59:30.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:30.136]                   NULL)
[17:59:30.136]                 if (is_error) {
[17:59:30.136]                   sessionInformation <- function() {
[17:59:30.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:30.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:30.136]                       search = base::search(), system = base::Sys.info())
[17:59:30.136]                   }
[17:59:30.136]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:30.136]                     cond$call), session = sessionInformation(), 
[17:59:30.136]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:30.136]                   signalCondition(cond)
[17:59:30.136]                 }
[17:59:30.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:30.136]                 "immediateCondition"))) {
[17:59:30.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:30.136]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:30.136]                   if (TRUE && !signal) {
[17:59:30.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.136]                     {
[17:59:30.136]                       inherits <- base::inherits
[17:59:30.136]                       invokeRestart <- base::invokeRestart
[17:59:30.136]                       is.null <- base::is.null
[17:59:30.136]                       muffled <- FALSE
[17:59:30.136]                       if (inherits(cond, "message")) {
[17:59:30.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.136]                         if (muffled) 
[17:59:30.136]                           invokeRestart("muffleMessage")
[17:59:30.136]                       }
[17:59:30.136]                       else if (inherits(cond, "warning")) {
[17:59:30.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.136]                         if (muffled) 
[17:59:30.136]                           invokeRestart("muffleWarning")
[17:59:30.136]                       }
[17:59:30.136]                       else if (inherits(cond, "condition")) {
[17:59:30.136]                         if (!is.null(pattern)) {
[17:59:30.136]                           computeRestarts <- base::computeRestarts
[17:59:30.136]                           grepl <- base::grepl
[17:59:30.136]                           restarts <- computeRestarts(cond)
[17:59:30.136]                           for (restart in restarts) {
[17:59:30.136]                             name <- restart$name
[17:59:30.136]                             if (is.null(name)) 
[17:59:30.136]                               next
[17:59:30.136]                             if (!grepl(pattern, name)) 
[17:59:30.136]                               next
[17:59:30.136]                             invokeRestart(restart)
[17:59:30.136]                             muffled <- TRUE
[17:59:30.136]                             break
[17:59:30.136]                           }
[17:59:30.136]                         }
[17:59:30.136]                       }
[17:59:30.136]                       invisible(muffled)
[17:59:30.136]                     }
[17:59:30.136]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.136]                   }
[17:59:30.136]                 }
[17:59:30.136]                 else {
[17:59:30.136]                   if (TRUE) {
[17:59:30.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.136]                     {
[17:59:30.136]                       inherits <- base::inherits
[17:59:30.136]                       invokeRestart <- base::invokeRestart
[17:59:30.136]                       is.null <- base::is.null
[17:59:30.136]                       muffled <- FALSE
[17:59:30.136]                       if (inherits(cond, "message")) {
[17:59:30.136]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.136]                         if (muffled) 
[17:59:30.136]                           invokeRestart("muffleMessage")
[17:59:30.136]                       }
[17:59:30.136]                       else if (inherits(cond, "warning")) {
[17:59:30.136]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.136]                         if (muffled) 
[17:59:30.136]                           invokeRestart("muffleWarning")
[17:59:30.136]                       }
[17:59:30.136]                       else if (inherits(cond, "condition")) {
[17:59:30.136]                         if (!is.null(pattern)) {
[17:59:30.136]                           computeRestarts <- base::computeRestarts
[17:59:30.136]                           grepl <- base::grepl
[17:59:30.136]                           restarts <- computeRestarts(cond)
[17:59:30.136]                           for (restart in restarts) {
[17:59:30.136]                             name <- restart$name
[17:59:30.136]                             if (is.null(name)) 
[17:59:30.136]                               next
[17:59:30.136]                             if (!grepl(pattern, name)) 
[17:59:30.136]                               next
[17:59:30.136]                             invokeRestart(restart)
[17:59:30.136]                             muffled <- TRUE
[17:59:30.136]                             break
[17:59:30.136]                           }
[17:59:30.136]                         }
[17:59:30.136]                       }
[17:59:30.136]                       invisible(muffled)
[17:59:30.136]                     }
[17:59:30.136]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.136]                   }
[17:59:30.136]                 }
[17:59:30.136]             }
[17:59:30.136]         }))
[17:59:30.136]     }, error = function(ex) {
[17:59:30.136]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:30.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.136]                 ...future.rng), started = ...future.startTime, 
[17:59:30.136]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:30.136]             version = "1.8"), class = "FutureResult")
[17:59:30.136]     }, finally = {
[17:59:30.136]         if (!identical(...future.workdir, getwd())) 
[17:59:30.136]             setwd(...future.workdir)
[17:59:30.136]         {
[17:59:30.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:30.136]                 ...future.oldOptions$nwarnings <- NULL
[17:59:30.136]             }
[17:59:30.136]             base::options(...future.oldOptions)
[17:59:30.136]             if (.Platform$OS.type == "windows") {
[17:59:30.136]                 old_names <- names(...future.oldEnvVars)
[17:59:30.136]                 envs <- base::Sys.getenv()
[17:59:30.136]                 names <- names(envs)
[17:59:30.136]                 common <- intersect(names, old_names)
[17:59:30.136]                 added <- setdiff(names, old_names)
[17:59:30.136]                 removed <- setdiff(old_names, names)
[17:59:30.136]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:30.136]                   envs[common]]
[17:59:30.136]                 NAMES <- toupper(changed)
[17:59:30.136]                 args <- list()
[17:59:30.136]                 for (kk in seq_along(NAMES)) {
[17:59:30.136]                   name <- changed[[kk]]
[17:59:30.136]                   NAME <- NAMES[[kk]]
[17:59:30.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.136]                     next
[17:59:30.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.136]                 }
[17:59:30.136]                 NAMES <- toupper(added)
[17:59:30.136]                 for (kk in seq_along(NAMES)) {
[17:59:30.136]                   name <- added[[kk]]
[17:59:30.136]                   NAME <- NAMES[[kk]]
[17:59:30.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.136]                     next
[17:59:30.136]                   args[[name]] <- ""
[17:59:30.136]                 }
[17:59:30.136]                 NAMES <- toupper(removed)
[17:59:30.136]                 for (kk in seq_along(NAMES)) {
[17:59:30.136]                   name <- removed[[kk]]
[17:59:30.136]                   NAME <- NAMES[[kk]]
[17:59:30.136]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.136]                     next
[17:59:30.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.136]                 }
[17:59:30.136]                 if (length(args) > 0) 
[17:59:30.136]                   base::do.call(base::Sys.setenv, args = args)
[17:59:30.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:30.136]             }
[17:59:30.136]             else {
[17:59:30.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:30.136]             }
[17:59:30.136]             {
[17:59:30.136]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:30.136]                   0L) {
[17:59:30.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:30.136]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:30.136]                   base::options(opts)
[17:59:30.136]                 }
[17:59:30.136]                 {
[17:59:30.136]                   {
[17:59:30.136]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:30.136]                     NULL
[17:59:30.136]                   }
[17:59:30.136]                   options(future.plan = NULL)
[17:59:30.136]                   if (is.na(NA_character_)) 
[17:59:30.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:30.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:30.136]                     .init = FALSE)
[17:59:30.136]                 }
[17:59:30.136]             }
[17:59:30.136]         }
[17:59:30.136]     })
[17:59:30.136]     if (TRUE) {
[17:59:30.136]         base::sink(type = "output", split = FALSE)
[17:59:30.136]         if (TRUE) {
[17:59:30.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:30.136]         }
[17:59:30.136]         else {
[17:59:30.136]             ...future.result["stdout"] <- base::list(NULL)
[17:59:30.136]         }
[17:59:30.136]         base::close(...future.stdout)
[17:59:30.136]         ...future.stdout <- NULL
[17:59:30.136]     }
[17:59:30.136]     ...future.result$conditions <- ...future.conditions
[17:59:30.136]     ...future.result$finished <- base::Sys.time()
[17:59:30.136]     ...future.result
[17:59:30.136] }
[17:59:30.141] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[17:59:30.142] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[17:59:30.143] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[17:59:30.143] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:59:30.144] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:59:30.144] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[17:59:30.145] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[17:59:30.145] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:59:30.146] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:59:30.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:59:30.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:59:30.148] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[17:59:30.149] MultisessionFuture started
[17:59:30.149] - Launch lazy future ... done
[17:59:30.149] run() for ‘MultisessionFuture’ ... done
[17:59:30.149] Created future:
[17:59:30.149] MultisessionFuture:
[17:59:30.149] Label: ‘future_by-1’
[17:59:30.149] Expression:
[17:59:30.149] {
[17:59:30.149]     do.call(function(...) {
[17:59:30.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.149]             on.exit(options(oopts), add = TRUE)
[17:59:30.149]         }
[17:59:30.149]         {
[17:59:30.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.149]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.149]             })
[17:59:30.149]         }
[17:59:30.149]     }, args = future.call.arguments)
[17:59:30.149] }
[17:59:30.149] Lazy evaluation: FALSE
[17:59:30.149] Asynchronous evaluation: TRUE
[17:59:30.149] Local evaluation: TRUE
[17:59:30.149] Environment: 0x6264a2632980
[17:59:30.149] Capture standard output: TRUE
[17:59:30.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:30.149] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:30.149] Packages: <none>
[17:59:30.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:30.149] Resolved: FALSE
[17:59:30.149] Value: <not collected>
[17:59:30.149] Conditions captured: <none>
[17:59:30.149] Early signaling: FALSE
[17:59:30.149] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:30.149] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:30.163] Chunk #1 of 2 ... DONE
[17:59:30.163] Chunk #2 of 2 ...
[17:59:30.163]  - Finding globals in 'X' for chunk #2 ...
[17:59:30.163] getGlobalsAndPackages() ...
[17:59:30.164] Searching for globals...
[17:59:30.164] 
[17:59:30.165] Searching for globals ... DONE
[17:59:30.165] - globals: [0] <none>
[17:59:30.165] getGlobalsAndPackages() ... DONE
[17:59:30.165]    + additional globals found: [n=0] 
[17:59:30.165]    + additional namespaces needed: [n=0] 
[17:59:30.166]  - Finding globals in 'X' for chunk #2 ... DONE
[17:59:30.166]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:59:30.166]  - seeds: <none>
[17:59:30.166]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.166] getGlobalsAndPackages() ...
[17:59:30.167] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.167] Resolving globals: FALSE
[17:59:30.167] Tweak future expression to call with '...' arguments ...
[17:59:30.167] {
[17:59:30.167]     do.call(function(...) {
[17:59:30.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.167]             on.exit(options(oopts), add = TRUE)
[17:59:30.167]         }
[17:59:30.167]         {
[17:59:30.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.167]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.167]             })
[17:59:30.167]         }
[17:59:30.167]     }, args = future.call.arguments)
[17:59:30.167] }
[17:59:30.168] Tweak future expression to call with '...' arguments ... DONE
[17:59:30.168] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:59:30.169] 
[17:59:30.169] getGlobalsAndPackages() ... DONE
[17:59:30.169] run() for ‘Future’ ...
[17:59:30.170] - state: ‘created’
[17:59:30.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:59:30.196] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:30.196] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:59:30.197]   - Field: ‘node’
[17:59:30.197]   - Field: ‘label’
[17:59:30.197]   - Field: ‘local’
[17:59:30.197]   - Field: ‘owner’
[17:59:30.198]   - Field: ‘envir’
[17:59:30.198]   - Field: ‘workers’
[17:59:30.198]   - Field: ‘packages’
[17:59:30.198]   - Field: ‘gc’
[17:59:30.198]   - Field: ‘conditions’
[17:59:30.199]   - Field: ‘persistent’
[17:59:30.199]   - Field: ‘expr’
[17:59:30.199]   - Field: ‘uuid’
[17:59:30.199]   - Field: ‘seed’
[17:59:30.199]   - Field: ‘version’
[17:59:30.200]   - Field: ‘result’
[17:59:30.200]   - Field: ‘asynchronous’
[17:59:30.200]   - Field: ‘calls’
[17:59:30.200]   - Field: ‘globals’
[17:59:30.200]   - Field: ‘stdout’
[17:59:30.201]   - Field: ‘earlySignal’
[17:59:30.201]   - Field: ‘lazy’
[17:59:30.201]   - Field: ‘state’
[17:59:30.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:59:30.201] - Launch lazy future ...
[17:59:30.202] Packages needed by the future expression (n = 0): <none>
[17:59:30.202] Packages needed by future strategies (n = 0): <none>
[17:59:30.203] {
[17:59:30.203]     {
[17:59:30.203]         {
[17:59:30.203]             ...future.startTime <- base::Sys.time()
[17:59:30.203]             {
[17:59:30.203]                 {
[17:59:30.203]                   {
[17:59:30.203]                     {
[17:59:30.203]                       base::local({
[17:59:30.203]                         has_future <- base::requireNamespace("future", 
[17:59:30.203]                           quietly = TRUE)
[17:59:30.203]                         if (has_future) {
[17:59:30.203]                           ns <- base::getNamespace("future")
[17:59:30.203]                           version <- ns[[".package"]][["version"]]
[17:59:30.203]                           if (is.null(version)) 
[17:59:30.203]                             version <- utils::packageVersion("future")
[17:59:30.203]                         }
[17:59:30.203]                         else {
[17:59:30.203]                           version <- NULL
[17:59:30.203]                         }
[17:59:30.203]                         if (!has_future || version < "1.8.0") {
[17:59:30.203]                           info <- base::c(r_version = base::gsub("R version ", 
[17:59:30.203]                             "", base::R.version$version.string), 
[17:59:30.203]                             platform = base::sprintf("%s (%s-bit)", 
[17:59:30.203]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:59:30.203]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:59:30.203]                               "release", "version")], collapse = " "), 
[17:59:30.203]                             hostname = base::Sys.info()[["nodename"]])
[17:59:30.203]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:59:30.203]                             info)
[17:59:30.203]                           info <- base::paste(info, collapse = "; ")
[17:59:30.203]                           if (!has_future) {
[17:59:30.203]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:59:30.203]                               info)
[17:59:30.203]                           }
[17:59:30.203]                           else {
[17:59:30.203]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:59:30.203]                               info, version)
[17:59:30.203]                           }
[17:59:30.203]                           base::stop(msg)
[17:59:30.203]                         }
[17:59:30.203]                       })
[17:59:30.203]                     }
[17:59:30.203]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:59:30.203]                     base::options(mc.cores = 1L)
[17:59:30.203]                   }
[17:59:30.203]                   ...future.strategy.old <- future::plan("list")
[17:59:30.203]                   options(future.plan = NULL)
[17:59:30.203]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.203]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:59:30.203]                 }
[17:59:30.203]                 ...future.workdir <- getwd()
[17:59:30.203]             }
[17:59:30.203]             ...future.oldOptions <- base::as.list(base::.Options)
[17:59:30.203]             ...future.oldEnvVars <- base::Sys.getenv()
[17:59:30.203]         }
[17:59:30.203]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:59:30.203]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:59:30.203]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:59:30.203]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:59:30.203]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:59:30.203]             future.stdout.windows.reencode = NULL, width = 80L)
[17:59:30.203]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:59:30.203]             base::names(...future.oldOptions))
[17:59:30.203]     }
[17:59:30.203]     if (FALSE) {
[17:59:30.203]     }
[17:59:30.203]     else {
[17:59:30.203]         if (TRUE) {
[17:59:30.203]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:59:30.203]                 open = "w")
[17:59:30.203]         }
[17:59:30.203]         else {
[17:59:30.203]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:59:30.203]                 windows = "NUL", "/dev/null"), open = "w")
[17:59:30.203]         }
[17:59:30.203]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:59:30.203]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:59:30.203]             base::sink(type = "output", split = FALSE)
[17:59:30.203]             base::close(...future.stdout)
[17:59:30.203]         }, add = TRUE)
[17:59:30.203]     }
[17:59:30.203]     ...future.frame <- base::sys.nframe()
[17:59:30.203]     ...future.conditions <- base::list()
[17:59:30.203]     ...future.rng <- base::globalenv()$.Random.seed
[17:59:30.203]     if (FALSE) {
[17:59:30.203]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:59:30.203]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:59:30.203]     }
[17:59:30.203]     ...future.result <- base::tryCatch({
[17:59:30.203]         base::withCallingHandlers({
[17:59:30.203]             ...future.value <- base::withVisible(base::local({
[17:59:30.203]                 ...future.makeSendCondition <- base::local({
[17:59:30.203]                   sendCondition <- NULL
[17:59:30.203]                   function(frame = 1L) {
[17:59:30.203]                     if (is.function(sendCondition)) 
[17:59:30.203]                       return(sendCondition)
[17:59:30.203]                     ns <- getNamespace("parallel")
[17:59:30.203]                     if (exists("sendData", mode = "function", 
[17:59:30.203]                       envir = ns)) {
[17:59:30.203]                       parallel_sendData <- get("sendData", mode = "function", 
[17:59:30.203]                         envir = ns)
[17:59:30.203]                       envir <- sys.frame(frame)
[17:59:30.203]                       master <- NULL
[17:59:30.203]                       while (!identical(envir, .GlobalEnv) && 
[17:59:30.203]                         !identical(envir, emptyenv())) {
[17:59:30.203]                         if (exists("master", mode = "list", envir = envir, 
[17:59:30.203]                           inherits = FALSE)) {
[17:59:30.203]                           master <- get("master", mode = "list", 
[17:59:30.203]                             envir = envir, inherits = FALSE)
[17:59:30.203]                           if (inherits(master, c("SOCKnode", 
[17:59:30.203]                             "SOCK0node"))) {
[17:59:30.203]                             sendCondition <<- function(cond) {
[17:59:30.203]                               data <- list(type = "VALUE", value = cond, 
[17:59:30.203]                                 success = TRUE)
[17:59:30.203]                               parallel_sendData(master, data)
[17:59:30.203]                             }
[17:59:30.203]                             return(sendCondition)
[17:59:30.203]                           }
[17:59:30.203]                         }
[17:59:30.203]                         frame <- frame + 1L
[17:59:30.203]                         envir <- sys.frame(frame)
[17:59:30.203]                       }
[17:59:30.203]                     }
[17:59:30.203]                     sendCondition <<- function(cond) NULL
[17:59:30.203]                   }
[17:59:30.203]                 })
[17:59:30.203]                 withCallingHandlers({
[17:59:30.203]                   {
[17:59:30.203]                     do.call(function(...) {
[17:59:30.203]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.203]                       if (!identical(...future.globals.maxSize.org, 
[17:59:30.203]                         ...future.globals.maxSize)) {
[17:59:30.203]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.203]                         on.exit(options(oopts), add = TRUE)
[17:59:30.203]                       }
[17:59:30.203]                       {
[17:59:30.203]                         lapply(seq_along(...future.elements_ii), 
[17:59:30.203]                           FUN = function(jj) {
[17:59:30.203]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.203]                             ...future.FUN(...future.X_jj, ...)
[17:59:30.203]                           })
[17:59:30.203]                       }
[17:59:30.203]                     }, args = future.call.arguments)
[17:59:30.203]                   }
[17:59:30.203]                 }, immediateCondition = function(cond) {
[17:59:30.203]                   sendCondition <- ...future.makeSendCondition()
[17:59:30.203]                   sendCondition(cond)
[17:59:30.203]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.203]                   {
[17:59:30.203]                     inherits <- base::inherits
[17:59:30.203]                     invokeRestart <- base::invokeRestart
[17:59:30.203]                     is.null <- base::is.null
[17:59:30.203]                     muffled <- FALSE
[17:59:30.203]                     if (inherits(cond, "message")) {
[17:59:30.203]                       muffled <- grepl(pattern, "muffleMessage")
[17:59:30.203]                       if (muffled) 
[17:59:30.203]                         invokeRestart("muffleMessage")
[17:59:30.203]                     }
[17:59:30.203]                     else if (inherits(cond, "warning")) {
[17:59:30.203]                       muffled <- grepl(pattern, "muffleWarning")
[17:59:30.203]                       if (muffled) 
[17:59:30.203]                         invokeRestart("muffleWarning")
[17:59:30.203]                     }
[17:59:30.203]                     else if (inherits(cond, "condition")) {
[17:59:30.203]                       if (!is.null(pattern)) {
[17:59:30.203]                         computeRestarts <- base::computeRestarts
[17:59:30.203]                         grepl <- base::grepl
[17:59:30.203]                         restarts <- computeRestarts(cond)
[17:59:30.203]                         for (restart in restarts) {
[17:59:30.203]                           name <- restart$name
[17:59:30.203]                           if (is.null(name)) 
[17:59:30.203]                             next
[17:59:30.203]                           if (!grepl(pattern, name)) 
[17:59:30.203]                             next
[17:59:30.203]                           invokeRestart(restart)
[17:59:30.203]                           muffled <- TRUE
[17:59:30.203]                           break
[17:59:30.203]                         }
[17:59:30.203]                       }
[17:59:30.203]                     }
[17:59:30.203]                     invisible(muffled)
[17:59:30.203]                   }
[17:59:30.203]                   muffleCondition(cond)
[17:59:30.203]                 })
[17:59:30.203]             }))
[17:59:30.203]             future::FutureResult(value = ...future.value$value, 
[17:59:30.203]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.203]                   ...future.rng), globalenv = if (FALSE) 
[17:59:30.203]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:59:30.203]                     ...future.globalenv.names))
[17:59:30.203]                 else NULL, started = ...future.startTime, version = "1.8")
[17:59:30.203]         }, condition = base::local({
[17:59:30.203]             c <- base::c
[17:59:30.203]             inherits <- base::inherits
[17:59:30.203]             invokeRestart <- base::invokeRestart
[17:59:30.203]             length <- base::length
[17:59:30.203]             list <- base::list
[17:59:30.203]             seq.int <- base::seq.int
[17:59:30.203]             signalCondition <- base::signalCondition
[17:59:30.203]             sys.calls <- base::sys.calls
[17:59:30.203]             `[[` <- base::`[[`
[17:59:30.203]             `+` <- base::`+`
[17:59:30.203]             `<<-` <- base::`<<-`
[17:59:30.203]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:59:30.203]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:59:30.203]                   3L)]
[17:59:30.203]             }
[17:59:30.203]             function(cond) {
[17:59:30.203]                 is_error <- inherits(cond, "error")
[17:59:30.203]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:59:30.203]                   NULL)
[17:59:30.203]                 if (is_error) {
[17:59:30.203]                   sessionInformation <- function() {
[17:59:30.203]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:59:30.203]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:59:30.203]                       search = base::search(), system = base::Sys.info())
[17:59:30.203]                   }
[17:59:30.203]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.203]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:59:30.203]                     cond$call), session = sessionInformation(), 
[17:59:30.203]                     timestamp = base::Sys.time(), signaled = 0L)
[17:59:30.203]                   signalCondition(cond)
[17:59:30.203]                 }
[17:59:30.203]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:59:30.203]                 "immediateCondition"))) {
[17:59:30.203]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:59:30.203]                   ...future.conditions[[length(...future.conditions) + 
[17:59:30.203]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:59:30.203]                   if (TRUE && !signal) {
[17:59:30.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.203]                     {
[17:59:30.203]                       inherits <- base::inherits
[17:59:30.203]                       invokeRestart <- base::invokeRestart
[17:59:30.203]                       is.null <- base::is.null
[17:59:30.203]                       muffled <- FALSE
[17:59:30.203]                       if (inherits(cond, "message")) {
[17:59:30.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.203]                         if (muffled) 
[17:59:30.203]                           invokeRestart("muffleMessage")
[17:59:30.203]                       }
[17:59:30.203]                       else if (inherits(cond, "warning")) {
[17:59:30.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.203]                         if (muffled) 
[17:59:30.203]                           invokeRestart("muffleWarning")
[17:59:30.203]                       }
[17:59:30.203]                       else if (inherits(cond, "condition")) {
[17:59:30.203]                         if (!is.null(pattern)) {
[17:59:30.203]                           computeRestarts <- base::computeRestarts
[17:59:30.203]                           grepl <- base::grepl
[17:59:30.203]                           restarts <- computeRestarts(cond)
[17:59:30.203]                           for (restart in restarts) {
[17:59:30.203]                             name <- restart$name
[17:59:30.203]                             if (is.null(name)) 
[17:59:30.203]                               next
[17:59:30.203]                             if (!grepl(pattern, name)) 
[17:59:30.203]                               next
[17:59:30.203]                             invokeRestart(restart)
[17:59:30.203]                             muffled <- TRUE
[17:59:30.203]                             break
[17:59:30.203]                           }
[17:59:30.203]                         }
[17:59:30.203]                       }
[17:59:30.203]                       invisible(muffled)
[17:59:30.203]                     }
[17:59:30.203]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.203]                   }
[17:59:30.203]                 }
[17:59:30.203]                 else {
[17:59:30.203]                   if (TRUE) {
[17:59:30.203]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:59:30.203]                     {
[17:59:30.203]                       inherits <- base::inherits
[17:59:30.203]                       invokeRestart <- base::invokeRestart
[17:59:30.203]                       is.null <- base::is.null
[17:59:30.203]                       muffled <- FALSE
[17:59:30.203]                       if (inherits(cond, "message")) {
[17:59:30.203]                         muffled <- grepl(pattern, "muffleMessage")
[17:59:30.203]                         if (muffled) 
[17:59:30.203]                           invokeRestart("muffleMessage")
[17:59:30.203]                       }
[17:59:30.203]                       else if (inherits(cond, "warning")) {
[17:59:30.203]                         muffled <- grepl(pattern, "muffleWarning")
[17:59:30.203]                         if (muffled) 
[17:59:30.203]                           invokeRestart("muffleWarning")
[17:59:30.203]                       }
[17:59:30.203]                       else if (inherits(cond, "condition")) {
[17:59:30.203]                         if (!is.null(pattern)) {
[17:59:30.203]                           computeRestarts <- base::computeRestarts
[17:59:30.203]                           grepl <- base::grepl
[17:59:30.203]                           restarts <- computeRestarts(cond)
[17:59:30.203]                           for (restart in restarts) {
[17:59:30.203]                             name <- restart$name
[17:59:30.203]                             if (is.null(name)) 
[17:59:30.203]                               next
[17:59:30.203]                             if (!grepl(pattern, name)) 
[17:59:30.203]                               next
[17:59:30.203]                             invokeRestart(restart)
[17:59:30.203]                             muffled <- TRUE
[17:59:30.203]                             break
[17:59:30.203]                           }
[17:59:30.203]                         }
[17:59:30.203]                       }
[17:59:30.203]                       invisible(muffled)
[17:59:30.203]                     }
[17:59:30.203]                     muffleCondition(cond, pattern = "^muffle")
[17:59:30.203]                   }
[17:59:30.203]                 }
[17:59:30.203]             }
[17:59:30.203]         }))
[17:59:30.203]     }, error = function(ex) {
[17:59:30.203]         base::structure(base::list(value = NULL, visible = NULL, 
[17:59:30.203]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:59:30.203]                 ...future.rng), started = ...future.startTime, 
[17:59:30.203]             finished = Sys.time(), session_uuid = NA_character_, 
[17:59:30.203]             version = "1.8"), class = "FutureResult")
[17:59:30.203]     }, finally = {
[17:59:30.203]         if (!identical(...future.workdir, getwd())) 
[17:59:30.203]             setwd(...future.workdir)
[17:59:30.203]         {
[17:59:30.203]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:59:30.203]                 ...future.oldOptions$nwarnings <- NULL
[17:59:30.203]             }
[17:59:30.203]             base::options(...future.oldOptions)
[17:59:30.203]             if (.Platform$OS.type == "windows") {
[17:59:30.203]                 old_names <- names(...future.oldEnvVars)
[17:59:30.203]                 envs <- base::Sys.getenv()
[17:59:30.203]                 names <- names(envs)
[17:59:30.203]                 common <- intersect(names, old_names)
[17:59:30.203]                 added <- setdiff(names, old_names)
[17:59:30.203]                 removed <- setdiff(old_names, names)
[17:59:30.203]                 changed <- common[...future.oldEnvVars[common] != 
[17:59:30.203]                   envs[common]]
[17:59:30.203]                 NAMES <- toupper(changed)
[17:59:30.203]                 args <- list()
[17:59:30.203]                 for (kk in seq_along(NAMES)) {
[17:59:30.203]                   name <- changed[[kk]]
[17:59:30.203]                   NAME <- NAMES[[kk]]
[17:59:30.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.203]                     next
[17:59:30.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.203]                 }
[17:59:30.203]                 NAMES <- toupper(added)
[17:59:30.203]                 for (kk in seq_along(NAMES)) {
[17:59:30.203]                   name <- added[[kk]]
[17:59:30.203]                   NAME <- NAMES[[kk]]
[17:59:30.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.203]                     next
[17:59:30.203]                   args[[name]] <- ""
[17:59:30.203]                 }
[17:59:30.203]                 NAMES <- toupper(removed)
[17:59:30.203]                 for (kk in seq_along(NAMES)) {
[17:59:30.203]                   name <- removed[[kk]]
[17:59:30.203]                   NAME <- NAMES[[kk]]
[17:59:30.203]                   if (name != NAME && is.element(NAME, old_names)) 
[17:59:30.203]                     next
[17:59:30.203]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:59:30.203]                 }
[17:59:30.203]                 if (length(args) > 0) 
[17:59:30.203]                   base::do.call(base::Sys.setenv, args = args)
[17:59:30.203]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:59:30.203]             }
[17:59:30.203]             else {
[17:59:30.203]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:59:30.203]             }
[17:59:30.203]             {
[17:59:30.203]                 if (base::length(...future.futureOptionsAdded) > 
[17:59:30.203]                   0L) {
[17:59:30.203]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:59:30.203]                   base::names(opts) <- ...future.futureOptionsAdded
[17:59:30.203]                   base::options(opts)
[17:59:30.203]                 }
[17:59:30.203]                 {
[17:59:30.203]                   {
[17:59:30.203]                     base::options(mc.cores = ...future.mc.cores.old)
[17:59:30.203]                     NULL
[17:59:30.203]                   }
[17:59:30.203]                   options(future.plan = NULL)
[17:59:30.203]                   if (is.na(NA_character_)) 
[17:59:30.203]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:59:30.203]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:59:30.203]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:59:30.203]                     .init = FALSE)
[17:59:30.203]                 }
[17:59:30.203]             }
[17:59:30.203]         }
[17:59:30.203]     })
[17:59:30.203]     if (TRUE) {
[17:59:30.203]         base::sink(type = "output", split = FALSE)
[17:59:30.203]         if (TRUE) {
[17:59:30.203]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:59:30.203]         }
[17:59:30.203]         else {
[17:59:30.203]             ...future.result["stdout"] <- base::list(NULL)
[17:59:30.203]         }
[17:59:30.203]         base::close(...future.stdout)
[17:59:30.203]         ...future.stdout <- NULL
[17:59:30.203]     }
[17:59:30.203]     ...future.result$conditions <- ...future.conditions
[17:59:30.203]     ...future.result$finished <- base::Sys.time()
[17:59:30.203]     ...future.result
[17:59:30.203] }
[17:59:30.208] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[17:59:30.208] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[17:59:30.209] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[17:59:30.210] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:59:30.211] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:59:30.211] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[17:59:30.212] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[17:59:30.212] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:59:30.213] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:59:30.214] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:59:30.214] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:59:30.215] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[17:59:30.216] MultisessionFuture started
[17:59:30.216] - Launch lazy future ... done
[17:59:30.216] run() for ‘MultisessionFuture’ ... done
[17:59:30.216] Created future:
[17:59:30.216] MultisessionFuture:
[17:59:30.216] Label: ‘future_by-2’
[17:59:30.216] Expression:
[17:59:30.216] {
[17:59:30.216]     do.call(function(...) {
[17:59:30.216]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:59:30.216]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:59:30.216]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:59:30.216]             on.exit(options(oopts), add = TRUE)
[17:59:30.216]         }
[17:59:30.216]         {
[17:59:30.216]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:59:30.216]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:59:30.216]                 ...future.FUN(...future.X_jj, ...)
[17:59:30.216]             })
[17:59:30.216]         }
[17:59:30.216]     }, args = future.call.arguments)
[17:59:30.216] }
[17:59:30.216] Lazy evaluation: FALSE
[17:59:30.216] Asynchronous evaluation: TRUE
[17:59:30.216] Local evaluation: TRUE
[17:59:30.216] Environment: 0x6264a2632980
[17:59:30.216] Capture standard output: TRUE
[17:59:30.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:59:30.216] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:59:30.216] Packages: <none>
[17:59:30.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:59:30.216] Resolved: FALSE
[17:59:30.216] Value: <not collected>
[17:59:30.216] Conditions captured: <none>
[17:59:30.216] Early signaling: FALSE
[17:59:30.216] Owner process: 63e7863b-7462-f5c3-9be3-efb44eb5d9e0
[17:59:30.216] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:59:30.230] Chunk #2 of 2 ... DONE
[17:59:30.230] Launching 2 futures (chunks) ... DONE
[17:59:30.230] Resolving 2 futures (chunks) ...
[17:59:30.230] resolve() on list ...
[17:59:30.231]  recursive: 0
[17:59:30.231]  length: 2
[17:59:30.231] 
[17:59:30.232] receiveMessageFromWorker() for ClusterFuture ...
[17:59:30.232] - Validating connection of MultisessionFuture
[17:59:30.232] - received message: FutureResult
[17:59:30.233] - Received FutureResult
[17:59:30.233] - Erased future from FutureRegistry
[17:59:30.233] result() for ClusterFuture ...
[17:59:30.233] - result already collected: FutureResult
[17:59:30.234] result() for ClusterFuture ... done
[17:59:30.234] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:30.234] Future #1
[17:59:30.234] result() for ClusterFuture ...
[17:59:30.234] - result already collected: FutureResult
[17:59:30.235] result() for ClusterFuture ... done
[17:59:30.235] result() for ClusterFuture ...
[17:59:30.235] - result already collected: FutureResult
[17:59:30.235] result() for ClusterFuture ... done
[17:59:30.235] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:59:30.236] - nx: 2
[17:59:30.236] - relay: TRUE
[17:59:30.236] - stdout: TRUE
[17:59:30.236] - signal: TRUE
[17:59:30.236] - resignal: FALSE
[17:59:30.237] - force: TRUE
[17:59:30.237] - relayed: [n=2] FALSE, FALSE
[17:59:30.237] - queued futures: [n=2] FALSE, FALSE
[17:59:30.237]  - until=1
[17:59:30.237]  - relaying element #1
[17:59:30.238] result() for ClusterFuture ...
[17:59:30.238] - result already collected: FutureResult
[17:59:30.238] result() for ClusterFuture ... done
[17:59:30.238] result() for ClusterFuture ...
[17:59:30.238] - result already collected: FutureResult
[17:59:30.238] result() for ClusterFuture ... done
[17:59:30.239] result() for ClusterFuture ...
[17:59:30.239] - result already collected: FutureResult
[17:59:30.239] result() for ClusterFuture ... done
[17:59:30.239] result() for ClusterFuture ...
[17:59:30.239] - result already collected: FutureResult
[17:59:30.240] result() for ClusterFuture ... done
[17:59:30.240] - relayed: [n=2] TRUE, FALSE
[17:59:30.240] - queued futures: [n=2] TRUE, FALSE
[17:59:30.240] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:59:30.240]  length: 1 (resolved future 1)
[17:59:30.263] receiveMessageFromWorker() for ClusterFuture ...
[17:59:30.263] - Validating connection of MultisessionFuture
[17:59:30.263] - received message: FutureResult
[17:59:30.264] - Received FutureResult
[17:59:30.264] - Erased future from FutureRegistry
[17:59:30.264] result() for ClusterFuture ...
[17:59:30.264] - result already collected: FutureResult
[17:59:30.264] result() for ClusterFuture ... done
[17:59:30.265] receiveMessageFromWorker() for ClusterFuture ... done
[17:59:30.265] Future #2
[17:59:30.265] result() for ClusterFuture ...
[17:59:30.265] - result already collected: FutureResult
[17:59:30.265] result() for ClusterFuture ... done
[17:59:30.266] result() for ClusterFuture ...
[17:59:30.266] - result already collected: FutureResult
[17:59:30.266] result() for ClusterFuture ... done
[17:59:30.266] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:59:30.266] - nx: 2
[17:59:30.267] - relay: TRUE
[17:59:30.267] - stdout: TRUE
[17:59:30.267] - signal: TRUE
[17:59:30.267] - resignal: FALSE
[17:59:30.267] - force: TRUE
[17:59:30.267] - relayed: [n=2] TRUE, FALSE
[17:59:30.268] - queued futures: [n=2] TRUE, FALSE
[17:59:30.268]  - until=2
[17:59:30.268]  - relaying element #2
[17:59:30.268] result() for ClusterFuture ...
[17:59:30.268] - result already collected: FutureResult
[17:59:30.269] result() for ClusterFuture ... done
[17:59:30.269] result() for ClusterFuture ...
[17:59:30.269] - result already collected: FutureResult
[17:59:30.269] result() for ClusterFuture ... done
[17:59:30.269] result() for ClusterFuture ...
[17:59:30.270] - result already collected: FutureResult
[17:59:30.270] result() for ClusterFuture ... done
[17:59:30.270] result() for ClusterFuture ...
[17:59:30.270] - result already collected: FutureResult
[17:59:30.270] result() for ClusterFuture ... done
[17:59:30.271] - relayed: [n=2] TRUE, TRUE
[17:59:30.271] - queued futures: [n=2] TRUE, TRUE
[17:59:30.271] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:59:30.271]  length: 0 (resolved future 2)
[17:59:30.271] Relaying remaining futures
[17:59:30.272] signalConditionsASAP(NULL, pos=0) ...
[17:59:30.272] - nx: 2
[17:59:30.272] - relay: TRUE
[17:59:30.272] - stdout: TRUE
[17:59:30.272] - signal: TRUE
[17:59:30.272] - resignal: FALSE
[17:59:30.273] - force: TRUE
[17:59:30.273] - relayed: [n=2] TRUE, TRUE
[17:59:30.273] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:59:30.273] - relayed: [n=2] TRUE, TRUE
[17:59:30.274] - queued futures: [n=2] TRUE, TRUE
[17:59:30.274] signalConditionsASAP(NULL, pos=0) ... done
[17:59:30.274] resolve() on list ... DONE
[17:59:30.274] result() for ClusterFuture ...
[17:59:30.274] - result already collected: FutureResult
[17:59:30.274] result() for ClusterFuture ... done
[17:59:30.275] result() for ClusterFuture ...
[17:59:30.275] - result already collected: FutureResult
[17:59:30.275] result() for ClusterFuture ... done
[17:59:30.275] result() for ClusterFuture ...
[17:59:30.275] - result already collected: FutureResult
[17:59:30.276] result() for ClusterFuture ... done
[17:59:30.276] result() for ClusterFuture ...
[17:59:30.276] - result already collected: FutureResult
[17:59:30.276] result() for ClusterFuture ... done
[17:59:30.276]  - Number of value chunks collected: 2
[17:59:30.277] Resolving 2 futures (chunks) ... DONE
[17:59:30.277] Reducing values from 2 chunks ...
[17:59:30.277]  - Number of values collected after concatenation: 3
[17:59:30.277]  - Number of values expected: 3
[17:59:30.277] Reducing values from 2 chunks ... DONE
[17:59:30.278] future_lapply() ... DONE
[17:59:30.278] future_by_internal() ... DONE
[17:59:30.280] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[17:59:30.281] plan(): Setting new future strategy stack:
[17:59:30.282] List of future strategies:
[17:59:30.282] 1. FutureStrategy:
[17:59:30.282]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:59:30.282]    - tweaked: FALSE
[17:59:30.282]    - call: future::plan(oplan)
[17:59:30.283] plan(): nbrOfWorkers() = 1
> 
