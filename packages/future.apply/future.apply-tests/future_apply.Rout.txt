
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:59:28.915] plan(): Setting new future strategy stack:
[16:59:28.915] List of future strategies:
[16:59:28.915] 1. sequential:
[16:59:28.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:28.915]    - tweaked: FALSE
[16:59:28.915]    - call: future::plan("sequential")
[16:59:28.930] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[16:59:28.988] plan(): Setting new future strategy stack:
[16:59:28.988] List of future strategies:
[16:59:28.988] 1. sequential:
[16:59:28.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:28.988]    - tweaked: FALSE
[16:59:28.988]    - call: plan(strategy)
[16:59:29.002] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[16:59:29.003] getGlobalsAndPackagesXApply() ...
[16:59:29.003]  - future.globals: TRUE
[16:59:29.004] getGlobalsAndPackages() ...
[16:59:29.004] Searching for globals...
[16:59:29.044] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:59:29.044] Searching for globals ... DONE
[16:59:29.045] Resolving globals: FALSE
[16:59:29.047] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:59:29.047] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:59:29.047] - globals: [1] ‘FUN’
[16:59:29.048] 
[16:59:29.048] getGlobalsAndPackages() ... DONE
[16:59:29.048]  - globals found/used: [n=1] ‘FUN’
[16:59:29.048]  - needed namespaces: [n=0] 
[16:59:29.050] Finding globals ... DONE
[16:59:29.050]  - use_args: TRUE
[16:59:29.050]  - Getting '...' globals ...
[16:59:29.051] resolve() on list ...
[16:59:29.051]  recursive: 0
[16:59:29.051]  length: 1
[16:59:29.051]  elements: ‘...’
[16:59:29.052]  length: 0 (resolved future 1)
[16:59:29.052] resolve() on list ... DONE
[16:59:29.052]    - '...' content: [n=0] 
[16:59:29.052] List of 1
[16:59:29.052]  $ ...: list()
[16:59:29.052]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.052]  - attr(*, "where")=List of 1
[16:59:29.052]   ..$ ...:<environment: 0x55f313318908> 
[16:59:29.052]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.052]  - attr(*, "resolved")= logi TRUE
[16:59:29.052]  - attr(*, "total_size")= num NA
[16:59:29.057]  - Getting '...' globals ... DONE
[16:59:29.057] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.057] List of 2
[16:59:29.057]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.057]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.057]  $ ...          : list()
[16:59:29.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.057]  - attr(*, "where")=List of 2
[16:59:29.057]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.057]   ..$ ...          :<environment: 0x55f313318908> 
[16:59:29.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.057]  - attr(*, "resolved")= logi FALSE
[16:59:29.057]  - attr(*, "total_size")= num 354224
[16:59:29.060] Packages to be attached in all futures: [n=0] 
[16:59:29.060] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.060] future_lapply() ...
[16:59:29.093] Number of chunks: 1
[16:59:29.093] getGlobalsAndPackagesXApply() ...
[16:59:29.093]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.093]  - use_args: TRUE
[16:59:29.093] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.094] List of 2
[16:59:29.094]  $ ...          : list()
[16:59:29.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.094]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.094]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.094]  - attr(*, "where")=List of 2
[16:59:29.094]   ..$ ...          :<environment: 0x55f313318908> 
[16:59:29.094]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.094]  - attr(*, "resolved")= logi FALSE
[16:59:29.094]  - attr(*, "total_size")= num NA
[16:59:29.097] Packages to be attached in all futures: [n=0] 
[16:59:29.097] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.098] Number of futures (= number of chunks): 1
[16:59:29.098] Launching 1 futures (chunks) ...
[16:59:29.098] Chunk #1 of 1 ...
[16:59:29.098]  - seeds: <none>
[16:59:29.098]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.099] getGlobalsAndPackages() ...
[16:59:29.099] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.099] Resolving globals: FALSE
[16:59:29.099] Tweak future expression to call with '...' arguments ...
[16:59:29.099] {
[16:59:29.099]     do.call(function(...) {
[16:59:29.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.099]             on.exit(options(oopts), add = TRUE)
[16:59:29.099]         }
[16:59:29.099]         {
[16:59:29.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.099]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.099]             })
[16:59:29.099]         }
[16:59:29.099]     }, args = future.call.arguments)
[16:59:29.099] }
[16:59:29.099] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.100] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.100] 
[16:59:29.100] getGlobalsAndPackages() ... DONE
[16:59:29.101] run() for ‘Future’ ...
[16:59:29.101] - state: ‘created’
[16:59:29.101] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.101] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.102]   - Field: ‘label’
[16:59:29.102]   - Field: ‘local’
[16:59:29.102]   - Field: ‘owner’
[16:59:29.104]   - Field: ‘envir’
[16:59:29.104]   - Field: ‘packages’
[16:59:29.104]   - Field: ‘gc’
[16:59:29.104]   - Field: ‘conditions’
[16:59:29.104]   - Field: ‘expr’
[16:59:29.104]   - Field: ‘uuid’
[16:59:29.104]   - Field: ‘seed’
[16:59:29.104]   - Field: ‘version’
[16:59:29.104]   - Field: ‘result’
[16:59:29.105]   - Field: ‘asynchronous’
[16:59:29.105]   - Field: ‘calls’
[16:59:29.105]   - Field: ‘globals’
[16:59:29.105]   - Field: ‘stdout’
[16:59:29.105]   - Field: ‘earlySignal’
[16:59:29.105]   - Field: ‘lazy’
[16:59:29.105]   - Field: ‘state’
[16:59:29.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.105] - Launch lazy future ...
[16:59:29.106] Packages needed by the future expression (n = 0): <none>
[16:59:29.106] Packages needed by future strategies (n = 0): <none>
[16:59:29.107] {
[16:59:29.107]     {
[16:59:29.107]         {
[16:59:29.107]             ...future.startTime <- base::Sys.time()
[16:59:29.107]             {
[16:59:29.107]                 {
[16:59:29.107]                   {
[16:59:29.107]                     base::local({
[16:59:29.107]                       has_future <- base::requireNamespace("future", 
[16:59:29.107]                         quietly = TRUE)
[16:59:29.107]                       if (has_future) {
[16:59:29.107]                         ns <- base::getNamespace("future")
[16:59:29.107]                         version <- ns[[".package"]][["version"]]
[16:59:29.107]                         if (is.null(version)) 
[16:59:29.107]                           version <- utils::packageVersion("future")
[16:59:29.107]                       }
[16:59:29.107]                       else {
[16:59:29.107]                         version <- NULL
[16:59:29.107]                       }
[16:59:29.107]                       if (!has_future || version < "1.8.0") {
[16:59:29.107]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.107]                           "", base::R.version$version.string), 
[16:59:29.107]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.107]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.107]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.107]                             "release", "version")], collapse = " "), 
[16:59:29.107]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.107]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.107]                           info)
[16:59:29.107]                         info <- base::paste(info, collapse = "; ")
[16:59:29.107]                         if (!has_future) {
[16:59:29.107]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.107]                             info)
[16:59:29.107]                         }
[16:59:29.107]                         else {
[16:59:29.107]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.107]                             info, version)
[16:59:29.107]                         }
[16:59:29.107]                         base::stop(msg)
[16:59:29.107]                       }
[16:59:29.107]                     })
[16:59:29.107]                   }
[16:59:29.107]                   ...future.strategy.old <- future::plan("list")
[16:59:29.107]                   options(future.plan = NULL)
[16:59:29.107]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.107]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.107]                 }
[16:59:29.107]                 ...future.workdir <- getwd()
[16:59:29.107]             }
[16:59:29.107]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.107]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.107]         }
[16:59:29.107]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.107]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.107]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.107]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.107]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.107]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.107]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.107]             base::names(...future.oldOptions))
[16:59:29.107]     }
[16:59:29.107]     if (FALSE) {
[16:59:29.107]     }
[16:59:29.107]     else {
[16:59:29.107]         if (TRUE) {
[16:59:29.107]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.107]                 open = "w")
[16:59:29.107]         }
[16:59:29.107]         else {
[16:59:29.107]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.107]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.107]         }
[16:59:29.107]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.107]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.107]             base::sink(type = "output", split = FALSE)
[16:59:29.107]             base::close(...future.stdout)
[16:59:29.107]         }, add = TRUE)
[16:59:29.107]     }
[16:59:29.107]     ...future.frame <- base::sys.nframe()
[16:59:29.107]     ...future.conditions <- base::list()
[16:59:29.107]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.107]     if (FALSE) {
[16:59:29.107]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.107]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.107]     }
[16:59:29.107]     ...future.result <- base::tryCatch({
[16:59:29.107]         base::withCallingHandlers({
[16:59:29.107]             ...future.value <- base::withVisible(base::local({
[16:59:29.107]                 do.call(function(...) {
[16:59:29.107]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.107]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.107]                     ...future.globals.maxSize)) {
[16:59:29.107]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.107]                     on.exit(options(oopts), add = TRUE)
[16:59:29.107]                   }
[16:59:29.107]                   {
[16:59:29.107]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.107]                       FUN = function(jj) {
[16:59:29.107]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.107]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.107]                       })
[16:59:29.107]                   }
[16:59:29.107]                 }, args = future.call.arguments)
[16:59:29.107]             }))
[16:59:29.107]             future::FutureResult(value = ...future.value$value, 
[16:59:29.107]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.107]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.107]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.107]                     ...future.globalenv.names))
[16:59:29.107]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.107]         }, condition = base::local({
[16:59:29.107]             c <- base::c
[16:59:29.107]             inherits <- base::inherits
[16:59:29.107]             invokeRestart <- base::invokeRestart
[16:59:29.107]             length <- base::length
[16:59:29.107]             list <- base::list
[16:59:29.107]             seq.int <- base::seq.int
[16:59:29.107]             signalCondition <- base::signalCondition
[16:59:29.107]             sys.calls <- base::sys.calls
[16:59:29.107]             `[[` <- base::`[[`
[16:59:29.107]             `+` <- base::`+`
[16:59:29.107]             `<<-` <- base::`<<-`
[16:59:29.107]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.107]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.107]                   3L)]
[16:59:29.107]             }
[16:59:29.107]             function(cond) {
[16:59:29.107]                 is_error <- inherits(cond, "error")
[16:59:29.107]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.107]                   NULL)
[16:59:29.107]                 if (is_error) {
[16:59:29.107]                   sessionInformation <- function() {
[16:59:29.107]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.107]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.107]                       search = base::search(), system = base::Sys.info())
[16:59:29.107]                   }
[16:59:29.107]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.107]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.107]                     cond$call), session = sessionInformation(), 
[16:59:29.107]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.107]                   signalCondition(cond)
[16:59:29.107]                 }
[16:59:29.107]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.107]                 "immediateCondition"))) {
[16:59:29.107]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.107]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.107]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.107]                   if (TRUE && !signal) {
[16:59:29.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.107]                     {
[16:59:29.107]                       inherits <- base::inherits
[16:59:29.107]                       invokeRestart <- base::invokeRestart
[16:59:29.107]                       is.null <- base::is.null
[16:59:29.107]                       muffled <- FALSE
[16:59:29.107]                       if (inherits(cond, "message")) {
[16:59:29.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.107]                         if (muffled) 
[16:59:29.107]                           invokeRestart("muffleMessage")
[16:59:29.107]                       }
[16:59:29.107]                       else if (inherits(cond, "warning")) {
[16:59:29.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.107]                         if (muffled) 
[16:59:29.107]                           invokeRestart("muffleWarning")
[16:59:29.107]                       }
[16:59:29.107]                       else if (inherits(cond, "condition")) {
[16:59:29.107]                         if (!is.null(pattern)) {
[16:59:29.107]                           computeRestarts <- base::computeRestarts
[16:59:29.107]                           grepl <- base::grepl
[16:59:29.107]                           restarts <- computeRestarts(cond)
[16:59:29.107]                           for (restart in restarts) {
[16:59:29.107]                             name <- restart$name
[16:59:29.107]                             if (is.null(name)) 
[16:59:29.107]                               next
[16:59:29.107]                             if (!grepl(pattern, name)) 
[16:59:29.107]                               next
[16:59:29.107]                             invokeRestart(restart)
[16:59:29.107]                             muffled <- TRUE
[16:59:29.107]                             break
[16:59:29.107]                           }
[16:59:29.107]                         }
[16:59:29.107]                       }
[16:59:29.107]                       invisible(muffled)
[16:59:29.107]                     }
[16:59:29.107]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.107]                   }
[16:59:29.107]                 }
[16:59:29.107]                 else {
[16:59:29.107]                   if (TRUE) {
[16:59:29.107]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.107]                     {
[16:59:29.107]                       inherits <- base::inherits
[16:59:29.107]                       invokeRestart <- base::invokeRestart
[16:59:29.107]                       is.null <- base::is.null
[16:59:29.107]                       muffled <- FALSE
[16:59:29.107]                       if (inherits(cond, "message")) {
[16:59:29.107]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.107]                         if (muffled) 
[16:59:29.107]                           invokeRestart("muffleMessage")
[16:59:29.107]                       }
[16:59:29.107]                       else if (inherits(cond, "warning")) {
[16:59:29.107]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.107]                         if (muffled) 
[16:59:29.107]                           invokeRestart("muffleWarning")
[16:59:29.107]                       }
[16:59:29.107]                       else if (inherits(cond, "condition")) {
[16:59:29.107]                         if (!is.null(pattern)) {
[16:59:29.107]                           computeRestarts <- base::computeRestarts
[16:59:29.107]                           grepl <- base::grepl
[16:59:29.107]                           restarts <- computeRestarts(cond)
[16:59:29.107]                           for (restart in restarts) {
[16:59:29.107]                             name <- restart$name
[16:59:29.107]                             if (is.null(name)) 
[16:59:29.107]                               next
[16:59:29.107]                             if (!grepl(pattern, name)) 
[16:59:29.107]                               next
[16:59:29.107]                             invokeRestart(restart)
[16:59:29.107]                             muffled <- TRUE
[16:59:29.107]                             break
[16:59:29.107]                           }
[16:59:29.107]                         }
[16:59:29.107]                       }
[16:59:29.107]                       invisible(muffled)
[16:59:29.107]                     }
[16:59:29.107]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.107]                   }
[16:59:29.107]                 }
[16:59:29.107]             }
[16:59:29.107]         }))
[16:59:29.107]     }, error = function(ex) {
[16:59:29.107]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.107]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.107]                 ...future.rng), started = ...future.startTime, 
[16:59:29.107]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.107]             version = "1.8"), class = "FutureResult")
[16:59:29.107]     }, finally = {
[16:59:29.107]         if (!identical(...future.workdir, getwd())) 
[16:59:29.107]             setwd(...future.workdir)
[16:59:29.107]         {
[16:59:29.107]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.107]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.107]             }
[16:59:29.107]             base::options(...future.oldOptions)
[16:59:29.107]             if (.Platform$OS.type == "windows") {
[16:59:29.107]                 old_names <- names(...future.oldEnvVars)
[16:59:29.107]                 envs <- base::Sys.getenv()
[16:59:29.107]                 names <- names(envs)
[16:59:29.107]                 common <- intersect(names, old_names)
[16:59:29.107]                 added <- setdiff(names, old_names)
[16:59:29.107]                 removed <- setdiff(old_names, names)
[16:59:29.107]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.107]                   envs[common]]
[16:59:29.107]                 NAMES <- toupper(changed)
[16:59:29.107]                 args <- list()
[16:59:29.107]                 for (kk in seq_along(NAMES)) {
[16:59:29.107]                   name <- changed[[kk]]
[16:59:29.107]                   NAME <- NAMES[[kk]]
[16:59:29.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.107]                     next
[16:59:29.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.107]                 }
[16:59:29.107]                 NAMES <- toupper(added)
[16:59:29.107]                 for (kk in seq_along(NAMES)) {
[16:59:29.107]                   name <- added[[kk]]
[16:59:29.107]                   NAME <- NAMES[[kk]]
[16:59:29.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.107]                     next
[16:59:29.107]                   args[[name]] <- ""
[16:59:29.107]                 }
[16:59:29.107]                 NAMES <- toupper(removed)
[16:59:29.107]                 for (kk in seq_along(NAMES)) {
[16:59:29.107]                   name <- removed[[kk]]
[16:59:29.107]                   NAME <- NAMES[[kk]]
[16:59:29.107]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.107]                     next
[16:59:29.107]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.107]                 }
[16:59:29.107]                 if (length(args) > 0) 
[16:59:29.107]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.107]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.107]             }
[16:59:29.107]             else {
[16:59:29.107]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.107]             }
[16:59:29.107]             {
[16:59:29.107]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.107]                   0L) {
[16:59:29.107]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.107]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.107]                   base::options(opts)
[16:59:29.107]                 }
[16:59:29.107]                 {
[16:59:29.107]                   {
[16:59:29.107]                     NULL
[16:59:29.107]                     RNGkind("Mersenne-Twister")
[16:59:29.107]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.107]                       inherits = FALSE)
[16:59:29.107]                   }
[16:59:29.107]                   options(future.plan = NULL)
[16:59:29.107]                   if (is.na(NA_character_)) 
[16:59:29.107]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.107]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.107]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.107]                     .init = FALSE)
[16:59:29.107]                 }
[16:59:29.107]             }
[16:59:29.107]         }
[16:59:29.107]     })
[16:59:29.107]     if (TRUE) {
[16:59:29.107]         base::sink(type = "output", split = FALSE)
[16:59:29.107]         if (TRUE) {
[16:59:29.107]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.107]         }
[16:59:29.107]         else {
[16:59:29.107]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.107]         }
[16:59:29.107]         base::close(...future.stdout)
[16:59:29.107]         ...future.stdout <- NULL
[16:59:29.107]     }
[16:59:29.107]     ...future.result$conditions <- ...future.conditions
[16:59:29.107]     ...future.result$finished <- base::Sys.time()
[16:59:29.107]     ...future.result
[16:59:29.107] }
[16:59:29.109] assign_globals() ...
[16:59:29.109] List of 5
[16:59:29.109]  $ future.call.arguments    : list()
[16:59:29.109]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.109]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.109]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.109]  $ ...future.elements_ii    :List of 2
[16:59:29.109]   ..$ : num [1:4] 1 3 1 7
[16:59:29.109]   ..$ : num [1:4] 2 4 6 8
[16:59:29.109]  $ ...future.seeds_ii       : NULL
[16:59:29.109]  $ ...future.globals.maxSize: num Inf
[16:59:29.109]  - attr(*, "resolved")= logi FALSE
[16:59:29.109]  - attr(*, "total_size")= num NA
[16:59:29.109]  - attr(*, "where")=List of 5
[16:59:29.109]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.109]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.109]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.109]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.109]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.109]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.109]  - attr(*, "already-done")= logi TRUE
[16:59:29.114] - copied ‘future.call.arguments’ to environment
[16:59:29.114] - copied ‘...future.FUN’ to environment
[16:59:29.115] - copied ‘...future.elements_ii’ to environment
[16:59:29.115] - copied ‘...future.seeds_ii’ to environment
[16:59:29.115] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.115] assign_globals() ... done
[16:59:29.115] plan(): Setting new future strategy stack:
[16:59:29.115] List of future strategies:
[16:59:29.115] 1. sequential:
[16:59:29.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.115]    - tweaked: FALSE
[16:59:29.115]    - call: NULL
[16:59:29.116] plan(): nbrOfWorkers() = 1
[16:59:29.117] plan(): Setting new future strategy stack:
[16:59:29.117] List of future strategies:
[16:59:29.117] 1. sequential:
[16:59:29.117]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.117]    - tweaked: FALSE
[16:59:29.117]    - call: plan(strategy)
[16:59:29.118] plan(): nbrOfWorkers() = 1
[16:59:29.118] SequentialFuture started (and completed)
[16:59:29.118] - Launch lazy future ... done
[16:59:29.119] run() for ‘SequentialFuture’ ... done
[16:59:29.119] Created future:
[16:59:29.119] SequentialFuture:
[16:59:29.119] Label: ‘future_apply-1’
[16:59:29.119] Expression:
[16:59:29.119] {
[16:59:29.119]     do.call(function(...) {
[16:59:29.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.119]             on.exit(options(oopts), add = TRUE)
[16:59:29.119]         }
[16:59:29.119]         {
[16:59:29.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.119]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.119]             })
[16:59:29.119]         }
[16:59:29.119]     }, args = future.call.arguments)
[16:59:29.119] }
[16:59:29.119] Lazy evaluation: FALSE
[16:59:29.119] Asynchronous evaluation: FALSE
[16:59:29.119] Local evaluation: TRUE
[16:59:29.119] Environment: R_GlobalEnv
[16:59:29.119] Capture standard output: TRUE
[16:59:29.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.119] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.119] Packages: <none>
[16:59:29.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.119] Resolved: TRUE
[16:59:29.119] Value: 2.21 KiB of class ‘list’
[16:59:29.119] Early signaling: FALSE
[16:59:29.119] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.119] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.120] Chunk #1 of 1 ... DONE
[16:59:29.120] Launching 1 futures (chunks) ... DONE
[16:59:29.121] Resolving 1 futures (chunks) ...
[16:59:29.121] resolve() on list ...
[16:59:29.121]  recursive: 0
[16:59:29.121]  length: 1
[16:59:29.121] 
[16:59:29.121] resolved() for ‘SequentialFuture’ ...
[16:59:29.121] - state: ‘finished’
[16:59:29.121] - run: TRUE
[16:59:29.121] - result: ‘FutureResult’
[16:59:29.122] resolved() for ‘SequentialFuture’ ... done
[16:59:29.122] Future #1
[16:59:29.122] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.122] - nx: 1
[16:59:29.122] - relay: TRUE
[16:59:29.122] - stdout: TRUE
[16:59:29.122] - signal: TRUE
[16:59:29.122] - resignal: FALSE
[16:59:29.123] - force: TRUE
[16:59:29.123] - relayed: [n=1] FALSE
[16:59:29.123] - queued futures: [n=1] FALSE
[16:59:29.123]  - until=1
[16:59:29.123]  - relaying element #1
[16:59:29.123] - relayed: [n=1] TRUE
[16:59:29.123] - queued futures: [n=1] TRUE
[16:59:29.123] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.124]  length: 0 (resolved future 1)
[16:59:29.124] Relaying remaining futures
[16:59:29.124] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.124] - nx: 1
[16:59:29.124] - relay: TRUE
[16:59:29.124] - stdout: TRUE
[16:59:29.124] - signal: TRUE
[16:59:29.124] - resignal: FALSE
[16:59:29.124] - force: TRUE
[16:59:29.124] - relayed: [n=1] TRUE
[16:59:29.124] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.125] - relayed: [n=1] TRUE
[16:59:29.125] - queued futures: [n=1] TRUE
[16:59:29.125] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.125] resolve() on list ... DONE
[16:59:29.125]  - Number of value chunks collected: 1
[16:59:29.125] Resolving 1 futures (chunks) ... DONE
[16:59:29.125] Reducing values from 1 chunks ...
[16:59:29.125]  - Number of values collected after concatenation: 2
[16:59:29.125]  - Number of values expected: 2
[16:59:29.126] Reducing values from 1 chunks ... DONE
[16:59:29.126] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:59:29.127] getGlobalsAndPackagesXApply() ...
[16:59:29.127]  - future.globals: TRUE
[16:59:29.127] getGlobalsAndPackages() ...
[16:59:29.127] Searching for globals...
[16:59:29.163] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:59:29.163] Searching for globals ... DONE
[16:59:29.163] Resolving globals: FALSE
[16:59:29.165] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:59:29.165] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:59:29.165] - globals: [1] ‘FUN’
[16:59:29.165] 
[16:59:29.165] getGlobalsAndPackages() ... DONE
[16:59:29.166]  - globals found/used: [n=1] ‘FUN’
[16:59:29.166]  - needed namespaces: [n=0] 
[16:59:29.166] Finding globals ... DONE
[16:59:29.166]  - use_args: TRUE
[16:59:29.166]  - Getting '...' globals ...
[16:59:29.166] resolve() on list ...
[16:59:29.166]  recursive: 0
[16:59:29.166]  length: 1
[16:59:29.167]  elements: ‘...’
[16:59:29.167]  length: 0 (resolved future 1)
[16:59:29.167] resolve() on list ... DONE
[16:59:29.167]    - '...' content: [n=0] 
[16:59:29.167] List of 1
[16:59:29.167]  $ ...: list()
[16:59:29.167]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.167]  - attr(*, "where")=List of 1
[16:59:29.167]   ..$ ...:<environment: 0x55f313d91908> 
[16:59:29.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.167]  - attr(*, "resolved")= logi TRUE
[16:59:29.167]  - attr(*, "total_size")= num NA
[16:59:29.170]  - Getting '...' globals ... DONE
[16:59:29.170] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.170] List of 2
[16:59:29.170]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.170]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.170]  $ ...          : list()
[16:59:29.170]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.170]  - attr(*, "where")=List of 2
[16:59:29.170]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.170]   ..$ ...          :<environment: 0x55f313d91908> 
[16:59:29.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.170]  - attr(*, "resolved")= logi FALSE
[16:59:29.170]  - attr(*, "total_size")= num 354224
[16:59:29.173] Packages to be attached in all futures: [n=0] 
[16:59:29.173] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.173] future_lapply() ...
[16:59:29.206] Number of chunks: 1
[16:59:29.207] getGlobalsAndPackagesXApply() ...
[16:59:29.207]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.207]  - use_args: TRUE
[16:59:29.207] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.207] List of 2
[16:59:29.207]  $ ...          : list()
[16:59:29.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.207]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.207]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.207]  - attr(*, "where")=List of 2
[16:59:29.207]   ..$ ...          :<environment: 0x55f313d91908> 
[16:59:29.207]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.207]  - attr(*, "resolved")= logi FALSE
[16:59:29.207]  - attr(*, "total_size")= num NA
[16:59:29.211] Packages to be attached in all futures: [n=0] 
[16:59:29.211] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.211] Number of futures (= number of chunks): 1
[16:59:29.211] Launching 1 futures (chunks) ...
[16:59:29.212] Chunk #1 of 1 ...
[16:59:29.212]  - seeds: <none>
[16:59:29.212]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.212] getGlobalsAndPackages() ...
[16:59:29.212] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.212] Resolving globals: FALSE
[16:59:29.212] Tweak future expression to call with '...' arguments ...
[16:59:29.212] {
[16:59:29.212]     do.call(function(...) {
[16:59:29.212]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.212]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.212]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.212]             on.exit(options(oopts), add = TRUE)
[16:59:29.212]         }
[16:59:29.212]         {
[16:59:29.212]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.212]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.212]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.212]             })
[16:59:29.212]         }
[16:59:29.212]     }, args = future.call.arguments)
[16:59:29.212] }
[16:59:29.213] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.213] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.213] 
[16:59:29.213] getGlobalsAndPackages() ... DONE
[16:59:29.213] run() for ‘Future’ ...
[16:59:29.214] - state: ‘created’
[16:59:29.214] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.214]   - Field: ‘label’
[16:59:29.214]   - Field: ‘local’
[16:59:29.214]   - Field: ‘owner’
[16:59:29.215]   - Field: ‘envir’
[16:59:29.215]   - Field: ‘packages’
[16:59:29.215]   - Field: ‘gc’
[16:59:29.215]   - Field: ‘conditions’
[16:59:29.215]   - Field: ‘expr’
[16:59:29.215]   - Field: ‘uuid’
[16:59:29.215]   - Field: ‘seed’
[16:59:29.215]   - Field: ‘version’
[16:59:29.215]   - Field: ‘result’
[16:59:29.215]   - Field: ‘asynchronous’
[16:59:29.216]   - Field: ‘calls’
[16:59:29.216]   - Field: ‘globals’
[16:59:29.216]   - Field: ‘stdout’
[16:59:29.216]   - Field: ‘earlySignal’
[16:59:29.216]   - Field: ‘lazy’
[16:59:29.216]   - Field: ‘state’
[16:59:29.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.216] - Launch lazy future ...
[16:59:29.216] Packages needed by the future expression (n = 0): <none>
[16:59:29.216] Packages needed by future strategies (n = 0): <none>
[16:59:29.217] {
[16:59:29.217]     {
[16:59:29.217]         {
[16:59:29.217]             ...future.startTime <- base::Sys.time()
[16:59:29.217]             {
[16:59:29.217]                 {
[16:59:29.217]                   {
[16:59:29.217]                     base::local({
[16:59:29.217]                       has_future <- base::requireNamespace("future", 
[16:59:29.217]                         quietly = TRUE)
[16:59:29.217]                       if (has_future) {
[16:59:29.217]                         ns <- base::getNamespace("future")
[16:59:29.217]                         version <- ns[[".package"]][["version"]]
[16:59:29.217]                         if (is.null(version)) 
[16:59:29.217]                           version <- utils::packageVersion("future")
[16:59:29.217]                       }
[16:59:29.217]                       else {
[16:59:29.217]                         version <- NULL
[16:59:29.217]                       }
[16:59:29.217]                       if (!has_future || version < "1.8.0") {
[16:59:29.217]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.217]                           "", base::R.version$version.string), 
[16:59:29.217]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.217]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.217]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.217]                             "release", "version")], collapse = " "), 
[16:59:29.217]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.217]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.217]                           info)
[16:59:29.217]                         info <- base::paste(info, collapse = "; ")
[16:59:29.217]                         if (!has_future) {
[16:59:29.217]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.217]                             info)
[16:59:29.217]                         }
[16:59:29.217]                         else {
[16:59:29.217]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.217]                             info, version)
[16:59:29.217]                         }
[16:59:29.217]                         base::stop(msg)
[16:59:29.217]                       }
[16:59:29.217]                     })
[16:59:29.217]                   }
[16:59:29.217]                   ...future.strategy.old <- future::plan("list")
[16:59:29.217]                   options(future.plan = NULL)
[16:59:29.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.217]                 }
[16:59:29.217]                 ...future.workdir <- getwd()
[16:59:29.217]             }
[16:59:29.217]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.217]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.217]         }
[16:59:29.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.217]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.217]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.217]             base::names(...future.oldOptions))
[16:59:29.217]     }
[16:59:29.217]     if (FALSE) {
[16:59:29.217]     }
[16:59:29.217]     else {
[16:59:29.217]         if (TRUE) {
[16:59:29.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.217]                 open = "w")
[16:59:29.217]         }
[16:59:29.217]         else {
[16:59:29.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.217]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.217]         }
[16:59:29.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.217]             base::sink(type = "output", split = FALSE)
[16:59:29.217]             base::close(...future.stdout)
[16:59:29.217]         }, add = TRUE)
[16:59:29.217]     }
[16:59:29.217]     ...future.frame <- base::sys.nframe()
[16:59:29.217]     ...future.conditions <- base::list()
[16:59:29.217]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.217]     if (FALSE) {
[16:59:29.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.217]     }
[16:59:29.217]     ...future.result <- base::tryCatch({
[16:59:29.217]         base::withCallingHandlers({
[16:59:29.217]             ...future.value <- base::withVisible(base::local({
[16:59:29.217]                 do.call(function(...) {
[16:59:29.217]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.217]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.217]                     ...future.globals.maxSize)) {
[16:59:29.217]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.217]                     on.exit(options(oopts), add = TRUE)
[16:59:29.217]                   }
[16:59:29.217]                   {
[16:59:29.217]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.217]                       FUN = function(jj) {
[16:59:29.217]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.217]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.217]                       })
[16:59:29.217]                   }
[16:59:29.217]                 }, args = future.call.arguments)
[16:59:29.217]             }))
[16:59:29.217]             future::FutureResult(value = ...future.value$value, 
[16:59:29.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.217]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.217]                     ...future.globalenv.names))
[16:59:29.217]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.217]         }, condition = base::local({
[16:59:29.217]             c <- base::c
[16:59:29.217]             inherits <- base::inherits
[16:59:29.217]             invokeRestart <- base::invokeRestart
[16:59:29.217]             length <- base::length
[16:59:29.217]             list <- base::list
[16:59:29.217]             seq.int <- base::seq.int
[16:59:29.217]             signalCondition <- base::signalCondition
[16:59:29.217]             sys.calls <- base::sys.calls
[16:59:29.217]             `[[` <- base::`[[`
[16:59:29.217]             `+` <- base::`+`
[16:59:29.217]             `<<-` <- base::`<<-`
[16:59:29.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.217]                   3L)]
[16:59:29.217]             }
[16:59:29.217]             function(cond) {
[16:59:29.217]                 is_error <- inherits(cond, "error")
[16:59:29.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.217]                   NULL)
[16:59:29.217]                 if (is_error) {
[16:59:29.217]                   sessionInformation <- function() {
[16:59:29.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.217]                       search = base::search(), system = base::Sys.info())
[16:59:29.217]                   }
[16:59:29.217]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.217]                     cond$call), session = sessionInformation(), 
[16:59:29.217]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.217]                   signalCondition(cond)
[16:59:29.217]                 }
[16:59:29.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.217]                 "immediateCondition"))) {
[16:59:29.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.217]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.217]                   if (TRUE && !signal) {
[16:59:29.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.217]                     {
[16:59:29.217]                       inherits <- base::inherits
[16:59:29.217]                       invokeRestart <- base::invokeRestart
[16:59:29.217]                       is.null <- base::is.null
[16:59:29.217]                       muffled <- FALSE
[16:59:29.217]                       if (inherits(cond, "message")) {
[16:59:29.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.217]                         if (muffled) 
[16:59:29.217]                           invokeRestart("muffleMessage")
[16:59:29.217]                       }
[16:59:29.217]                       else if (inherits(cond, "warning")) {
[16:59:29.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.217]                         if (muffled) 
[16:59:29.217]                           invokeRestart("muffleWarning")
[16:59:29.217]                       }
[16:59:29.217]                       else if (inherits(cond, "condition")) {
[16:59:29.217]                         if (!is.null(pattern)) {
[16:59:29.217]                           computeRestarts <- base::computeRestarts
[16:59:29.217]                           grepl <- base::grepl
[16:59:29.217]                           restarts <- computeRestarts(cond)
[16:59:29.217]                           for (restart in restarts) {
[16:59:29.217]                             name <- restart$name
[16:59:29.217]                             if (is.null(name)) 
[16:59:29.217]                               next
[16:59:29.217]                             if (!grepl(pattern, name)) 
[16:59:29.217]                               next
[16:59:29.217]                             invokeRestart(restart)
[16:59:29.217]                             muffled <- TRUE
[16:59:29.217]                             break
[16:59:29.217]                           }
[16:59:29.217]                         }
[16:59:29.217]                       }
[16:59:29.217]                       invisible(muffled)
[16:59:29.217]                     }
[16:59:29.217]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.217]                   }
[16:59:29.217]                 }
[16:59:29.217]                 else {
[16:59:29.217]                   if (TRUE) {
[16:59:29.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.217]                     {
[16:59:29.217]                       inherits <- base::inherits
[16:59:29.217]                       invokeRestart <- base::invokeRestart
[16:59:29.217]                       is.null <- base::is.null
[16:59:29.217]                       muffled <- FALSE
[16:59:29.217]                       if (inherits(cond, "message")) {
[16:59:29.217]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.217]                         if (muffled) 
[16:59:29.217]                           invokeRestart("muffleMessage")
[16:59:29.217]                       }
[16:59:29.217]                       else if (inherits(cond, "warning")) {
[16:59:29.217]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.217]                         if (muffled) 
[16:59:29.217]                           invokeRestart("muffleWarning")
[16:59:29.217]                       }
[16:59:29.217]                       else if (inherits(cond, "condition")) {
[16:59:29.217]                         if (!is.null(pattern)) {
[16:59:29.217]                           computeRestarts <- base::computeRestarts
[16:59:29.217]                           grepl <- base::grepl
[16:59:29.217]                           restarts <- computeRestarts(cond)
[16:59:29.217]                           for (restart in restarts) {
[16:59:29.217]                             name <- restart$name
[16:59:29.217]                             if (is.null(name)) 
[16:59:29.217]                               next
[16:59:29.217]                             if (!grepl(pattern, name)) 
[16:59:29.217]                               next
[16:59:29.217]                             invokeRestart(restart)
[16:59:29.217]                             muffled <- TRUE
[16:59:29.217]                             break
[16:59:29.217]                           }
[16:59:29.217]                         }
[16:59:29.217]                       }
[16:59:29.217]                       invisible(muffled)
[16:59:29.217]                     }
[16:59:29.217]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.217]                   }
[16:59:29.217]                 }
[16:59:29.217]             }
[16:59:29.217]         }))
[16:59:29.217]     }, error = function(ex) {
[16:59:29.217]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.217]                 ...future.rng), started = ...future.startTime, 
[16:59:29.217]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.217]             version = "1.8"), class = "FutureResult")
[16:59:29.217]     }, finally = {
[16:59:29.217]         if (!identical(...future.workdir, getwd())) 
[16:59:29.217]             setwd(...future.workdir)
[16:59:29.217]         {
[16:59:29.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.217]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.217]             }
[16:59:29.217]             base::options(...future.oldOptions)
[16:59:29.217]             if (.Platform$OS.type == "windows") {
[16:59:29.217]                 old_names <- names(...future.oldEnvVars)
[16:59:29.217]                 envs <- base::Sys.getenv()
[16:59:29.217]                 names <- names(envs)
[16:59:29.217]                 common <- intersect(names, old_names)
[16:59:29.217]                 added <- setdiff(names, old_names)
[16:59:29.217]                 removed <- setdiff(old_names, names)
[16:59:29.217]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.217]                   envs[common]]
[16:59:29.217]                 NAMES <- toupper(changed)
[16:59:29.217]                 args <- list()
[16:59:29.217]                 for (kk in seq_along(NAMES)) {
[16:59:29.217]                   name <- changed[[kk]]
[16:59:29.217]                   NAME <- NAMES[[kk]]
[16:59:29.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.217]                     next
[16:59:29.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.217]                 }
[16:59:29.217]                 NAMES <- toupper(added)
[16:59:29.217]                 for (kk in seq_along(NAMES)) {
[16:59:29.217]                   name <- added[[kk]]
[16:59:29.217]                   NAME <- NAMES[[kk]]
[16:59:29.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.217]                     next
[16:59:29.217]                   args[[name]] <- ""
[16:59:29.217]                 }
[16:59:29.217]                 NAMES <- toupper(removed)
[16:59:29.217]                 for (kk in seq_along(NAMES)) {
[16:59:29.217]                   name <- removed[[kk]]
[16:59:29.217]                   NAME <- NAMES[[kk]]
[16:59:29.217]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.217]                     next
[16:59:29.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.217]                 }
[16:59:29.217]                 if (length(args) > 0) 
[16:59:29.217]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.217]             }
[16:59:29.217]             else {
[16:59:29.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.217]             }
[16:59:29.217]             {
[16:59:29.217]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.217]                   0L) {
[16:59:29.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.217]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.217]                   base::options(opts)
[16:59:29.217]                 }
[16:59:29.217]                 {
[16:59:29.217]                   {
[16:59:29.217]                     NULL
[16:59:29.217]                     RNGkind("Mersenne-Twister")
[16:59:29.217]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.217]                       inherits = FALSE)
[16:59:29.217]                   }
[16:59:29.217]                   options(future.plan = NULL)
[16:59:29.217]                   if (is.na(NA_character_)) 
[16:59:29.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.217]                     .init = FALSE)
[16:59:29.217]                 }
[16:59:29.217]             }
[16:59:29.217]         }
[16:59:29.217]     })
[16:59:29.217]     if (TRUE) {
[16:59:29.217]         base::sink(type = "output", split = FALSE)
[16:59:29.217]         if (TRUE) {
[16:59:29.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.217]         }
[16:59:29.217]         else {
[16:59:29.217]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.217]         }
[16:59:29.217]         base::close(...future.stdout)
[16:59:29.217]         ...future.stdout <- NULL
[16:59:29.217]     }
[16:59:29.217]     ...future.result$conditions <- ...future.conditions
[16:59:29.217]     ...future.result$finished <- base::Sys.time()
[16:59:29.217]     ...future.result
[16:59:29.217] }
[16:59:29.219] assign_globals() ...
[16:59:29.219] List of 5
[16:59:29.219]  $ future.call.arguments    : list()
[16:59:29.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.219]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.219]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.219]  $ ...future.elements_ii    :List of 2
[16:59:29.219]   ..$ : num [1:4] 1 3 1 7
[16:59:29.219]   ..$ : num [1:4] 2 4 6 8
[16:59:29.219]  $ ...future.seeds_ii       : NULL
[16:59:29.219]  $ ...future.globals.maxSize: num Inf
[16:59:29.219]  - attr(*, "resolved")= logi FALSE
[16:59:29.219]  - attr(*, "total_size")= num NA
[16:59:29.219]  - attr(*, "where")=List of 5
[16:59:29.219]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.219]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.219]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.219]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.219]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.219]  - attr(*, "already-done")= logi TRUE
[16:59:29.226] - copied ‘future.call.arguments’ to environment
[16:59:29.226] - copied ‘...future.FUN’ to environment
[16:59:29.226] - copied ‘...future.elements_ii’ to environment
[16:59:29.226] - copied ‘...future.seeds_ii’ to environment
[16:59:29.226] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.226] assign_globals() ... done
[16:59:29.226] plan(): Setting new future strategy stack:
[16:59:29.227] List of future strategies:
[16:59:29.227] 1. sequential:
[16:59:29.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.227]    - tweaked: FALSE
[16:59:29.227]    - call: NULL
[16:59:29.227] plan(): nbrOfWorkers() = 1
[16:59:29.228] plan(): Setting new future strategy stack:
[16:59:29.228] List of future strategies:
[16:59:29.228] 1. sequential:
[16:59:29.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.228]    - tweaked: FALSE
[16:59:29.228]    - call: plan(strategy)
[16:59:29.229] plan(): nbrOfWorkers() = 1
[16:59:29.229] SequentialFuture started (and completed)
[16:59:29.229] - Launch lazy future ... done
[16:59:29.229] run() for ‘SequentialFuture’ ... done
[16:59:29.229] Created future:
[16:59:29.229] SequentialFuture:
[16:59:29.229] Label: ‘future_apply-1’
[16:59:29.229] Expression:
[16:59:29.229] {
[16:59:29.229]     do.call(function(...) {
[16:59:29.229]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.229]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.229]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.229]             on.exit(options(oopts), add = TRUE)
[16:59:29.229]         }
[16:59:29.229]         {
[16:59:29.229]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.229]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.229]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.229]             })
[16:59:29.229]         }
[16:59:29.229]     }, args = future.call.arguments)
[16:59:29.229] }
[16:59:29.229] Lazy evaluation: FALSE
[16:59:29.229] Asynchronous evaluation: FALSE
[16:59:29.229] Local evaluation: TRUE
[16:59:29.229] Environment: R_GlobalEnv
[16:59:29.229] Capture standard output: TRUE
[16:59:29.229] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.229] Globals: 5 objects totaling 346.13 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.229] Packages: <none>
[16:59:29.229] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.229] Resolved: TRUE
[16:59:29.229] Value: 2.21 KiB of class ‘list’
[16:59:29.229] Early signaling: FALSE
[16:59:29.229] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.229] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.230] Chunk #1 of 1 ... DONE
[16:59:29.230] Launching 1 futures (chunks) ... DONE
[16:59:29.231] Resolving 1 futures (chunks) ...
[16:59:29.231] resolve() on list ...
[16:59:29.231]  recursive: 0
[16:59:29.231]  length: 1
[16:59:29.231] 
[16:59:29.231] resolved() for ‘SequentialFuture’ ...
[16:59:29.231] - state: ‘finished’
[16:59:29.231] - run: TRUE
[16:59:29.231] - result: ‘FutureResult’
[16:59:29.231] resolved() for ‘SequentialFuture’ ... done
[16:59:29.232] Future #1
[16:59:29.232] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.232] - nx: 1
[16:59:29.232] - relay: TRUE
[16:59:29.232] - stdout: TRUE
[16:59:29.232] - signal: TRUE
[16:59:29.232] - resignal: FALSE
[16:59:29.232] - force: TRUE
[16:59:29.232] - relayed: [n=1] FALSE
[16:59:29.232] - queued futures: [n=1] FALSE
[16:59:29.232]  - until=1
[16:59:29.233]  - relaying element #1
[16:59:29.233] - relayed: [n=1] TRUE
[16:59:29.233] - queued futures: [n=1] TRUE
[16:59:29.233] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.233]  length: 0 (resolved future 1)
[16:59:29.233] Relaying remaining futures
[16:59:29.233] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.233] - nx: 1
[16:59:29.233] - relay: TRUE
[16:59:29.233] - stdout: TRUE
[16:59:29.234] - signal: TRUE
[16:59:29.234] - resignal: FALSE
[16:59:29.234] - force: TRUE
[16:59:29.234] - relayed: [n=1] TRUE
[16:59:29.234] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.234] - relayed: [n=1] TRUE
[16:59:29.234] - queued futures: [n=1] TRUE
[16:59:29.234] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.234] resolve() on list ... DONE
[16:59:29.234]  - Number of value chunks collected: 1
[16:59:29.235] Resolving 1 futures (chunks) ... DONE
[16:59:29.235] Reducing values from 1 chunks ...
[16:59:29.235]  - Number of values collected after concatenation: 2
[16:59:29.235]  - Number of values expected: 2
[16:59:29.235] Reducing values from 1 chunks ... DONE
[16:59:29.235] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:59:29.237] getGlobalsAndPackagesXApply() ...
[16:59:29.237]  - future.globals: TRUE
[16:59:29.237] getGlobalsAndPackages() ...
[16:59:29.238] Searching for globals...
[16:59:29.239] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:29.239] Searching for globals ... DONE
[16:59:29.239] Resolving globals: FALSE
[16:59:29.239] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:29.240] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:29.240] - globals: [1] ‘FUN’
[16:59:29.240] - packages: [1] ‘stats’
[16:59:29.240] getGlobalsAndPackages() ... DONE
[16:59:29.240]  - globals found/used: [n=1] ‘FUN’
[16:59:29.240]  - needed namespaces: [n=1] ‘stats’
[16:59:29.240] Finding globals ... DONE
[16:59:29.240]  - use_args: TRUE
[16:59:29.240]  - Getting '...' globals ...
[16:59:29.241] resolve() on list ...
[16:59:29.241]  recursive: 0
[16:59:29.241]  length: 1
[16:59:29.241]  elements: ‘...’
[16:59:29.241]  length: 0 (resolved future 1)
[16:59:29.241] resolve() on list ... DONE
[16:59:29.241]    - '...' content: [n=0] 
[16:59:29.241] List of 1
[16:59:29.241]  $ ...: list()
[16:59:29.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.241]  - attr(*, "where")=List of 1
[16:59:29.241]   ..$ ...:<environment: 0x55f313af08c0> 
[16:59:29.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.241]  - attr(*, "resolved")= logi TRUE
[16:59:29.241]  - attr(*, "total_size")= num NA
[16:59:29.244]  - Getting '...' globals ... DONE
[16:59:29.244] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.244] List of 2
[16:59:29.244]  $ ...future.FUN:function (x, ...)  
[16:59:29.244]  $ ...          : list()
[16:59:29.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.244]  - attr(*, "where")=List of 2
[16:59:29.244]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.244]   ..$ ...          :<environment: 0x55f313af08c0> 
[16:59:29.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.244]  - attr(*, "resolved")= logi FALSE
[16:59:29.244]  - attr(*, "total_size")= num 1248
[16:59:29.247] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:29.247] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.247] future_lapply() ...
[16:59:29.250] Number of chunks: 1
[16:59:29.250] getGlobalsAndPackagesXApply() ...
[16:59:29.250]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.250]  - use_args: TRUE
[16:59:29.250] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.251] List of 2
[16:59:29.251]  $ ...          : list()
[16:59:29.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.251]  $ ...future.FUN:function (x, ...)  
[16:59:29.251]  - attr(*, "where")=List of 2
[16:59:29.251]   ..$ ...          :<environment: 0x55f313af08c0> 
[16:59:29.251]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:59:29.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.251]  - attr(*, "resolved")= logi FALSE
[16:59:29.251]  - attr(*, "total_size")= num NA
[16:59:29.253] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:29.254] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.254] Number of futures (= number of chunks): 1
[16:59:29.254] Launching 1 futures (chunks) ...
[16:59:29.254] Chunk #1 of 1 ...
[16:59:29.254]  - seeds: <none>
[16:59:29.254]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.254] getGlobalsAndPackages() ...
[16:59:29.254] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.255] Resolving globals: FALSE
[16:59:29.255] Tweak future expression to call with '...' arguments ...
[16:59:29.255] {
[16:59:29.255]     do.call(function(...) {
[16:59:29.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.255]             on.exit(options(oopts), add = TRUE)
[16:59:29.255]         }
[16:59:29.255]         {
[16:59:29.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.255]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.255]             })
[16:59:29.255]         }
[16:59:29.255]     }, args = future.call.arguments)
[16:59:29.255] }
[16:59:29.255] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.256] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.256] - packages: [1] ‘stats’
[16:59:29.256] getGlobalsAndPackages() ... DONE
[16:59:29.256] run() for ‘Future’ ...
[16:59:29.256] - state: ‘created’
[16:59:29.256] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.257] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.257] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.257]   - Field: ‘label’
[16:59:29.257]   - Field: ‘local’
[16:59:29.257]   - Field: ‘owner’
[16:59:29.257]   - Field: ‘envir’
[16:59:29.257]   - Field: ‘packages’
[16:59:29.257]   - Field: ‘gc’
[16:59:29.257]   - Field: ‘conditions’
[16:59:29.258]   - Field: ‘expr’
[16:59:29.258]   - Field: ‘uuid’
[16:59:29.258]   - Field: ‘seed’
[16:59:29.258]   - Field: ‘version’
[16:59:29.258]   - Field: ‘result’
[16:59:29.258]   - Field: ‘asynchronous’
[16:59:29.258]   - Field: ‘calls’
[16:59:29.258]   - Field: ‘globals’
[16:59:29.258]   - Field: ‘stdout’
[16:59:29.258]   - Field: ‘earlySignal’
[16:59:29.258]   - Field: ‘lazy’
[16:59:29.259]   - Field: ‘state’
[16:59:29.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.259] - Launch lazy future ...
[16:59:29.259] Packages needed by the future expression (n = 1): ‘stats’
[16:59:29.259] Packages needed by future strategies (n = 0): <none>
[16:59:29.260] {
[16:59:29.260]     {
[16:59:29.260]         {
[16:59:29.260]             ...future.startTime <- base::Sys.time()
[16:59:29.260]             {
[16:59:29.260]                 {
[16:59:29.260]                   {
[16:59:29.260]                     {
[16:59:29.260]                       base::local({
[16:59:29.260]                         has_future <- base::requireNamespace("future", 
[16:59:29.260]                           quietly = TRUE)
[16:59:29.260]                         if (has_future) {
[16:59:29.260]                           ns <- base::getNamespace("future")
[16:59:29.260]                           version <- ns[[".package"]][["version"]]
[16:59:29.260]                           if (is.null(version)) 
[16:59:29.260]                             version <- utils::packageVersion("future")
[16:59:29.260]                         }
[16:59:29.260]                         else {
[16:59:29.260]                           version <- NULL
[16:59:29.260]                         }
[16:59:29.260]                         if (!has_future || version < "1.8.0") {
[16:59:29.260]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.260]                             "", base::R.version$version.string), 
[16:59:29.260]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:29.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.260]                               "release", "version")], collapse = " "), 
[16:59:29.260]                             hostname = base::Sys.info()[["nodename"]])
[16:59:29.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.260]                             info)
[16:59:29.260]                           info <- base::paste(info, collapse = "; ")
[16:59:29.260]                           if (!has_future) {
[16:59:29.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.260]                               info)
[16:59:29.260]                           }
[16:59:29.260]                           else {
[16:59:29.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.260]                               info, version)
[16:59:29.260]                           }
[16:59:29.260]                           base::stop(msg)
[16:59:29.260]                         }
[16:59:29.260]                       })
[16:59:29.260]                     }
[16:59:29.260]                     base::local({
[16:59:29.260]                       for (pkg in "stats") {
[16:59:29.260]                         base::loadNamespace(pkg)
[16:59:29.260]                         base::library(pkg, character.only = TRUE)
[16:59:29.260]                       }
[16:59:29.260]                     })
[16:59:29.260]                   }
[16:59:29.260]                   ...future.strategy.old <- future::plan("list")
[16:59:29.260]                   options(future.plan = NULL)
[16:59:29.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.260]                 }
[16:59:29.260]                 ...future.workdir <- getwd()
[16:59:29.260]             }
[16:59:29.260]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.260]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.260]         }
[16:59:29.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.260]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.260]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.260]             base::names(...future.oldOptions))
[16:59:29.260]     }
[16:59:29.260]     if (FALSE) {
[16:59:29.260]     }
[16:59:29.260]     else {
[16:59:29.260]         if (TRUE) {
[16:59:29.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.260]                 open = "w")
[16:59:29.260]         }
[16:59:29.260]         else {
[16:59:29.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.260]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.260]         }
[16:59:29.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.260]             base::sink(type = "output", split = FALSE)
[16:59:29.260]             base::close(...future.stdout)
[16:59:29.260]         }, add = TRUE)
[16:59:29.260]     }
[16:59:29.260]     ...future.frame <- base::sys.nframe()
[16:59:29.260]     ...future.conditions <- base::list()
[16:59:29.260]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.260]     if (FALSE) {
[16:59:29.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.260]     }
[16:59:29.260]     ...future.result <- base::tryCatch({
[16:59:29.260]         base::withCallingHandlers({
[16:59:29.260]             ...future.value <- base::withVisible(base::local({
[16:59:29.260]                 do.call(function(...) {
[16:59:29.260]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.260]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.260]                     ...future.globals.maxSize)) {
[16:59:29.260]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.260]                     on.exit(options(oopts), add = TRUE)
[16:59:29.260]                   }
[16:59:29.260]                   {
[16:59:29.260]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.260]                       FUN = function(jj) {
[16:59:29.260]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.260]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.260]                       })
[16:59:29.260]                   }
[16:59:29.260]                 }, args = future.call.arguments)
[16:59:29.260]             }))
[16:59:29.260]             future::FutureResult(value = ...future.value$value, 
[16:59:29.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.260]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.260]                     ...future.globalenv.names))
[16:59:29.260]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.260]         }, condition = base::local({
[16:59:29.260]             c <- base::c
[16:59:29.260]             inherits <- base::inherits
[16:59:29.260]             invokeRestart <- base::invokeRestart
[16:59:29.260]             length <- base::length
[16:59:29.260]             list <- base::list
[16:59:29.260]             seq.int <- base::seq.int
[16:59:29.260]             signalCondition <- base::signalCondition
[16:59:29.260]             sys.calls <- base::sys.calls
[16:59:29.260]             `[[` <- base::`[[`
[16:59:29.260]             `+` <- base::`+`
[16:59:29.260]             `<<-` <- base::`<<-`
[16:59:29.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.260]                   3L)]
[16:59:29.260]             }
[16:59:29.260]             function(cond) {
[16:59:29.260]                 is_error <- inherits(cond, "error")
[16:59:29.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.260]                   NULL)
[16:59:29.260]                 if (is_error) {
[16:59:29.260]                   sessionInformation <- function() {
[16:59:29.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.260]                       search = base::search(), system = base::Sys.info())
[16:59:29.260]                   }
[16:59:29.260]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.260]                     cond$call), session = sessionInformation(), 
[16:59:29.260]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.260]                   signalCondition(cond)
[16:59:29.260]                 }
[16:59:29.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.260]                 "immediateCondition"))) {
[16:59:29.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.260]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.260]                   if (TRUE && !signal) {
[16:59:29.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.260]                     {
[16:59:29.260]                       inherits <- base::inherits
[16:59:29.260]                       invokeRestart <- base::invokeRestart
[16:59:29.260]                       is.null <- base::is.null
[16:59:29.260]                       muffled <- FALSE
[16:59:29.260]                       if (inherits(cond, "message")) {
[16:59:29.260]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.260]                         if (muffled) 
[16:59:29.260]                           invokeRestart("muffleMessage")
[16:59:29.260]                       }
[16:59:29.260]                       else if (inherits(cond, "warning")) {
[16:59:29.260]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.260]                         if (muffled) 
[16:59:29.260]                           invokeRestart("muffleWarning")
[16:59:29.260]                       }
[16:59:29.260]                       else if (inherits(cond, "condition")) {
[16:59:29.260]                         if (!is.null(pattern)) {
[16:59:29.260]                           computeRestarts <- base::computeRestarts
[16:59:29.260]                           grepl <- base::grepl
[16:59:29.260]                           restarts <- computeRestarts(cond)
[16:59:29.260]                           for (restart in restarts) {
[16:59:29.260]                             name <- restart$name
[16:59:29.260]                             if (is.null(name)) 
[16:59:29.260]                               next
[16:59:29.260]                             if (!grepl(pattern, name)) 
[16:59:29.260]                               next
[16:59:29.260]                             invokeRestart(restart)
[16:59:29.260]                             muffled <- TRUE
[16:59:29.260]                             break
[16:59:29.260]                           }
[16:59:29.260]                         }
[16:59:29.260]                       }
[16:59:29.260]                       invisible(muffled)
[16:59:29.260]                     }
[16:59:29.260]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.260]                   }
[16:59:29.260]                 }
[16:59:29.260]                 else {
[16:59:29.260]                   if (TRUE) {
[16:59:29.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.260]                     {
[16:59:29.260]                       inherits <- base::inherits
[16:59:29.260]                       invokeRestart <- base::invokeRestart
[16:59:29.260]                       is.null <- base::is.null
[16:59:29.260]                       muffled <- FALSE
[16:59:29.260]                       if (inherits(cond, "message")) {
[16:59:29.260]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.260]                         if (muffled) 
[16:59:29.260]                           invokeRestart("muffleMessage")
[16:59:29.260]                       }
[16:59:29.260]                       else if (inherits(cond, "warning")) {
[16:59:29.260]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.260]                         if (muffled) 
[16:59:29.260]                           invokeRestart("muffleWarning")
[16:59:29.260]                       }
[16:59:29.260]                       else if (inherits(cond, "condition")) {
[16:59:29.260]                         if (!is.null(pattern)) {
[16:59:29.260]                           computeRestarts <- base::computeRestarts
[16:59:29.260]                           grepl <- base::grepl
[16:59:29.260]                           restarts <- computeRestarts(cond)
[16:59:29.260]                           for (restart in restarts) {
[16:59:29.260]                             name <- restart$name
[16:59:29.260]                             if (is.null(name)) 
[16:59:29.260]                               next
[16:59:29.260]                             if (!grepl(pattern, name)) 
[16:59:29.260]                               next
[16:59:29.260]                             invokeRestart(restart)
[16:59:29.260]                             muffled <- TRUE
[16:59:29.260]                             break
[16:59:29.260]                           }
[16:59:29.260]                         }
[16:59:29.260]                       }
[16:59:29.260]                       invisible(muffled)
[16:59:29.260]                     }
[16:59:29.260]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.260]                   }
[16:59:29.260]                 }
[16:59:29.260]             }
[16:59:29.260]         }))
[16:59:29.260]     }, error = function(ex) {
[16:59:29.260]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.260]                 ...future.rng), started = ...future.startTime, 
[16:59:29.260]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.260]             version = "1.8"), class = "FutureResult")
[16:59:29.260]     }, finally = {
[16:59:29.260]         if (!identical(...future.workdir, getwd())) 
[16:59:29.260]             setwd(...future.workdir)
[16:59:29.260]         {
[16:59:29.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.260]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.260]             }
[16:59:29.260]             base::options(...future.oldOptions)
[16:59:29.260]             if (.Platform$OS.type == "windows") {
[16:59:29.260]                 old_names <- names(...future.oldEnvVars)
[16:59:29.260]                 envs <- base::Sys.getenv()
[16:59:29.260]                 names <- names(envs)
[16:59:29.260]                 common <- intersect(names, old_names)
[16:59:29.260]                 added <- setdiff(names, old_names)
[16:59:29.260]                 removed <- setdiff(old_names, names)
[16:59:29.260]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.260]                   envs[common]]
[16:59:29.260]                 NAMES <- toupper(changed)
[16:59:29.260]                 args <- list()
[16:59:29.260]                 for (kk in seq_along(NAMES)) {
[16:59:29.260]                   name <- changed[[kk]]
[16:59:29.260]                   NAME <- NAMES[[kk]]
[16:59:29.260]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.260]                     next
[16:59:29.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.260]                 }
[16:59:29.260]                 NAMES <- toupper(added)
[16:59:29.260]                 for (kk in seq_along(NAMES)) {
[16:59:29.260]                   name <- added[[kk]]
[16:59:29.260]                   NAME <- NAMES[[kk]]
[16:59:29.260]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.260]                     next
[16:59:29.260]                   args[[name]] <- ""
[16:59:29.260]                 }
[16:59:29.260]                 NAMES <- toupper(removed)
[16:59:29.260]                 for (kk in seq_along(NAMES)) {
[16:59:29.260]                   name <- removed[[kk]]
[16:59:29.260]                   NAME <- NAMES[[kk]]
[16:59:29.260]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.260]                     next
[16:59:29.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.260]                 }
[16:59:29.260]                 if (length(args) > 0) 
[16:59:29.260]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.260]             }
[16:59:29.260]             else {
[16:59:29.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.260]             }
[16:59:29.260]             {
[16:59:29.260]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.260]                   0L) {
[16:59:29.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.260]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.260]                   base::options(opts)
[16:59:29.260]                 }
[16:59:29.260]                 {
[16:59:29.260]                   {
[16:59:29.260]                     NULL
[16:59:29.260]                     RNGkind("Mersenne-Twister")
[16:59:29.260]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.260]                       inherits = FALSE)
[16:59:29.260]                   }
[16:59:29.260]                   options(future.plan = NULL)
[16:59:29.260]                   if (is.na(NA_character_)) 
[16:59:29.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.260]                     .init = FALSE)
[16:59:29.260]                 }
[16:59:29.260]             }
[16:59:29.260]         }
[16:59:29.260]     })
[16:59:29.260]     if (TRUE) {
[16:59:29.260]         base::sink(type = "output", split = FALSE)
[16:59:29.260]         if (TRUE) {
[16:59:29.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.260]         }
[16:59:29.260]         else {
[16:59:29.260]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.260]         }
[16:59:29.260]         base::close(...future.stdout)
[16:59:29.260]         ...future.stdout <- NULL
[16:59:29.260]     }
[16:59:29.260]     ...future.result$conditions <- ...future.conditions
[16:59:29.260]     ...future.result$finished <- base::Sys.time()
[16:59:29.260]     ...future.result
[16:59:29.260] }
[16:59:29.261] assign_globals() ...
[16:59:29.261] List of 5
[16:59:29.261]  $ future.call.arguments    : list()
[16:59:29.261]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.261]  $ ...future.FUN            :function (x, ...)  
[16:59:29.261]  $ ...future.elements_ii    :List of 2
[16:59:29.261]   ..$ : num [1:4] 1 3 1 7
[16:59:29.261]   ..$ : num [1:4] 2 4 6 8
[16:59:29.261]  $ ...future.seeds_ii       : NULL
[16:59:29.261]  $ ...future.globals.maxSize: num Inf
[16:59:29.261]  - attr(*, "resolved")= logi FALSE
[16:59:29.261]  - attr(*, "total_size")= num NA
[16:59:29.261]  - attr(*, "where")=List of 5
[16:59:29.261]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.261]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.261]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.261]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.261]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.261]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.261]  - attr(*, "already-done")= logi TRUE
[16:59:29.267] - copied ‘future.call.arguments’ to environment
[16:59:29.267] - copied ‘...future.FUN’ to environment
[16:59:29.267] - copied ‘...future.elements_ii’ to environment
[16:59:29.267] - copied ‘...future.seeds_ii’ to environment
[16:59:29.267] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.267] assign_globals() ... done
[16:59:29.268] plan(): Setting new future strategy stack:
[16:59:29.268] List of future strategies:
[16:59:29.268] 1. sequential:
[16:59:29.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.268]    - tweaked: FALSE
[16:59:29.268]    - call: NULL
[16:59:29.268] plan(): nbrOfWorkers() = 1
[16:59:29.269] plan(): Setting new future strategy stack:
[16:59:29.269] List of future strategies:
[16:59:29.269] 1. sequential:
[16:59:29.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.269]    - tweaked: FALSE
[16:59:29.269]    - call: plan(strategy)
[16:59:29.270] plan(): nbrOfWorkers() = 1
[16:59:29.270] SequentialFuture started (and completed)
[16:59:29.270] - Launch lazy future ... done
[16:59:29.270] run() for ‘SequentialFuture’ ... done
[16:59:29.270] Created future:
[16:59:29.270] SequentialFuture:
[16:59:29.270] Label: ‘future_apply-1’
[16:59:29.270] Expression:
[16:59:29.270] {
[16:59:29.270]     do.call(function(...) {
[16:59:29.270]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.270]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.270]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.270]             on.exit(options(oopts), add = TRUE)
[16:59:29.270]         }
[16:59:29.270]         {
[16:59:29.270]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.270]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.270]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.270]             })
[16:59:29.270]         }
[16:59:29.270]     }, args = future.call.arguments)
[16:59:29.270] }
[16:59:29.270] Lazy evaluation: FALSE
[16:59:29.270] Asynchronous evaluation: FALSE
[16:59:29.270] Local evaluation: TRUE
[16:59:29.270] Environment: R_GlobalEnv
[16:59:29.270] Capture standard output: TRUE
[16:59:29.270] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.270] Globals: 5 objects totaling 1.43 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 160 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.270] Packages: 1 packages (‘stats’)
[16:59:29.270] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.270] Resolved: TRUE
[16:59:29.270] Value: 1.14 KiB of class ‘list’
[16:59:29.270] Early signaling: FALSE
[16:59:29.270] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.270] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.272] Chunk #1 of 1 ... DONE
[16:59:29.272] Launching 1 futures (chunks) ... DONE
[16:59:29.272] Resolving 1 futures (chunks) ...
[16:59:29.272] resolve() on list ...
[16:59:29.272]  recursive: 0
[16:59:29.272]  length: 1
[16:59:29.272] 
[16:59:29.272] resolved() for ‘SequentialFuture’ ...
[16:59:29.272] - state: ‘finished’
[16:59:29.272] - run: TRUE
[16:59:29.273] - result: ‘FutureResult’
[16:59:29.273] resolved() for ‘SequentialFuture’ ... done
[16:59:29.273] Future #1
[16:59:29.273] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.273] - nx: 1
[16:59:29.273] - relay: TRUE
[16:59:29.273] - stdout: TRUE
[16:59:29.273] - signal: TRUE
[16:59:29.273] - resignal: FALSE
[16:59:29.273] - force: TRUE
[16:59:29.273] - relayed: [n=1] FALSE
[16:59:29.274] - queued futures: [n=1] FALSE
[16:59:29.274]  - until=1
[16:59:29.274]  - relaying element #1
[16:59:29.274] - relayed: [n=1] TRUE
[16:59:29.274] - queued futures: [n=1] TRUE
[16:59:29.274] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.274]  length: 0 (resolved future 1)
[16:59:29.274] Relaying remaining futures
[16:59:29.274] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.274] - nx: 1
[16:59:29.275] - relay: TRUE
[16:59:29.275] - stdout: TRUE
[16:59:29.275] - signal: TRUE
[16:59:29.275] - resignal: FALSE
[16:59:29.277] - force: TRUE
[16:59:29.277] - relayed: [n=1] TRUE
[16:59:29.277] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.277] - relayed: [n=1] TRUE
[16:59:29.277] - queued futures: [n=1] TRUE
[16:59:29.277] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.277] resolve() on list ... DONE
[16:59:29.278]  - Number of value chunks collected: 1
[16:59:29.278] Resolving 1 futures (chunks) ... DONE
[16:59:29.278] Reducing values from 1 chunks ...
[16:59:29.278]  - Number of values collected after concatenation: 2
[16:59:29.278]  - Number of values expected: 2
[16:59:29.278] Reducing values from 1 chunks ... DONE
[16:59:29.278] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:59:29.279] getGlobalsAndPackagesXApply() ...
[16:59:29.279]  - future.globals: TRUE
[16:59:29.279] getGlobalsAndPackages() ...
[16:59:29.279] Searching for globals...
[16:59:29.280] - globals found: [1] ‘FUN’
[16:59:29.281] Searching for globals ... DONE
[16:59:29.281] Resolving globals: FALSE
[16:59:29.281] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:29.281] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:29.281] - globals: [1] ‘FUN’
[16:59:29.281] 
[16:59:29.282] getGlobalsAndPackages() ... DONE
[16:59:29.282]  - globals found/used: [n=1] ‘FUN’
[16:59:29.282]  - needed namespaces: [n=0] 
[16:59:29.282] Finding globals ... DONE
[16:59:29.282]  - use_args: TRUE
[16:59:29.282]  - Getting '...' globals ...
[16:59:29.282] resolve() on list ...
[16:59:29.282]  recursive: 0
[16:59:29.283]  length: 1
[16:59:29.283]  elements: ‘...’
[16:59:29.283]  length: 0 (resolved future 1)
[16:59:29.283] resolve() on list ... DONE
[16:59:29.283]    - '...' content: [n=0] 
[16:59:29.283] List of 1
[16:59:29.283]  $ ...: list()
[16:59:29.283]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.283]  - attr(*, "where")=List of 1
[16:59:29.283]   ..$ ...:<environment: 0x55f31246c4a8> 
[16:59:29.283]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.283]  - attr(*, "resolved")= logi TRUE
[16:59:29.283]  - attr(*, "total_size")= num NA
[16:59:29.286]  - Getting '...' globals ... DONE
[16:59:29.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.286] List of 2
[16:59:29.286]  $ ...future.FUN:function (x)  
[16:59:29.286]  $ ...          : list()
[16:59:29.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.286]  - attr(*, "where")=List of 2
[16:59:29.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.286]   ..$ ...          :<environment: 0x55f31246c4a8> 
[16:59:29.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.286]  - attr(*, "resolved")= logi FALSE
[16:59:29.286]  - attr(*, "total_size")= num 848
[16:59:29.289] Packages to be attached in all futures: [n=0] 
[16:59:29.289] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.289] future_lapply() ...
[16:59:29.289] Number of chunks: 1
[16:59:29.289] getGlobalsAndPackagesXApply() ...
[16:59:29.290]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.290]  - use_args: TRUE
[16:59:29.290] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.290] List of 2
[16:59:29.290]  $ ...          : list()
[16:59:29.290]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.290]  $ ...future.FUN:function (x)  
[16:59:29.290]  - attr(*, "where")=List of 2
[16:59:29.290]   ..$ ...          :<environment: 0x55f31246c4a8> 
[16:59:29.290]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.290]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.290]  - attr(*, "resolved")= logi FALSE
[16:59:29.290]  - attr(*, "total_size")= num NA
[16:59:29.293] Packages to be attached in all futures: [n=0] 
[16:59:29.294] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.294] Number of futures (= number of chunks): 1
[16:59:29.294] Launching 1 futures (chunks) ...
[16:59:29.294] Chunk #1 of 1 ...
[16:59:29.294]  - seeds: <none>
[16:59:29.294]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.294] getGlobalsAndPackages() ...
[16:59:29.294] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.294] Resolving globals: FALSE
[16:59:29.295] Tweak future expression to call with '...' arguments ...
[16:59:29.295] {
[16:59:29.295]     do.call(function(...) {
[16:59:29.295]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.295]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.295]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.295]             on.exit(options(oopts), add = TRUE)
[16:59:29.295]         }
[16:59:29.295]         {
[16:59:29.295]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.295]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.295]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.295]             })
[16:59:29.295]         }
[16:59:29.295]     }, args = future.call.arguments)
[16:59:29.295] }
[16:59:29.295] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.295] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.295] 
[16:59:29.296] getGlobalsAndPackages() ... DONE
[16:59:29.296] run() for ‘Future’ ...
[16:59:29.296] - state: ‘created’
[16:59:29.296] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.296] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.297] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.297]   - Field: ‘label’
[16:59:29.297]   - Field: ‘local’
[16:59:29.297]   - Field: ‘owner’
[16:59:29.297]   - Field: ‘envir’
[16:59:29.297]   - Field: ‘packages’
[16:59:29.297]   - Field: ‘gc’
[16:59:29.297]   - Field: ‘conditions’
[16:59:29.297]   - Field: ‘expr’
[16:59:29.297]   - Field: ‘uuid’
[16:59:29.297]   - Field: ‘seed’
[16:59:29.298]   - Field: ‘version’
[16:59:29.298]   - Field: ‘result’
[16:59:29.298]   - Field: ‘asynchronous’
[16:59:29.298]   - Field: ‘calls’
[16:59:29.298]   - Field: ‘globals’
[16:59:29.298]   - Field: ‘stdout’
[16:59:29.298]   - Field: ‘earlySignal’
[16:59:29.298]   - Field: ‘lazy’
[16:59:29.298]   - Field: ‘state’
[16:59:29.298] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.298] - Launch lazy future ...
[16:59:29.299] Packages needed by the future expression (n = 0): <none>
[16:59:29.299] Packages needed by future strategies (n = 0): <none>
[16:59:29.299] {
[16:59:29.299]     {
[16:59:29.299]         {
[16:59:29.299]             ...future.startTime <- base::Sys.time()
[16:59:29.299]             {
[16:59:29.299]                 {
[16:59:29.299]                   {
[16:59:29.299]                     base::local({
[16:59:29.299]                       has_future <- base::requireNamespace("future", 
[16:59:29.299]                         quietly = TRUE)
[16:59:29.299]                       if (has_future) {
[16:59:29.299]                         ns <- base::getNamespace("future")
[16:59:29.299]                         version <- ns[[".package"]][["version"]]
[16:59:29.299]                         if (is.null(version)) 
[16:59:29.299]                           version <- utils::packageVersion("future")
[16:59:29.299]                       }
[16:59:29.299]                       else {
[16:59:29.299]                         version <- NULL
[16:59:29.299]                       }
[16:59:29.299]                       if (!has_future || version < "1.8.0") {
[16:59:29.299]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.299]                           "", base::R.version$version.string), 
[16:59:29.299]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.299]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.299]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.299]                             "release", "version")], collapse = " "), 
[16:59:29.299]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.299]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.299]                           info)
[16:59:29.299]                         info <- base::paste(info, collapse = "; ")
[16:59:29.299]                         if (!has_future) {
[16:59:29.299]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.299]                             info)
[16:59:29.299]                         }
[16:59:29.299]                         else {
[16:59:29.299]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.299]                             info, version)
[16:59:29.299]                         }
[16:59:29.299]                         base::stop(msg)
[16:59:29.299]                       }
[16:59:29.299]                     })
[16:59:29.299]                   }
[16:59:29.299]                   ...future.strategy.old <- future::plan("list")
[16:59:29.299]                   options(future.plan = NULL)
[16:59:29.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.299]                 }
[16:59:29.299]                 ...future.workdir <- getwd()
[16:59:29.299]             }
[16:59:29.299]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.299]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.299]         }
[16:59:29.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.299]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.299]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.299]             base::names(...future.oldOptions))
[16:59:29.299]     }
[16:59:29.299]     if (FALSE) {
[16:59:29.299]     }
[16:59:29.299]     else {
[16:59:29.299]         if (TRUE) {
[16:59:29.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.299]                 open = "w")
[16:59:29.299]         }
[16:59:29.299]         else {
[16:59:29.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.299]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.299]         }
[16:59:29.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.299]             base::sink(type = "output", split = FALSE)
[16:59:29.299]             base::close(...future.stdout)
[16:59:29.299]         }, add = TRUE)
[16:59:29.299]     }
[16:59:29.299]     ...future.frame <- base::sys.nframe()
[16:59:29.299]     ...future.conditions <- base::list()
[16:59:29.299]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.299]     if (FALSE) {
[16:59:29.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.299]     }
[16:59:29.299]     ...future.result <- base::tryCatch({
[16:59:29.299]         base::withCallingHandlers({
[16:59:29.299]             ...future.value <- base::withVisible(base::local({
[16:59:29.299]                 do.call(function(...) {
[16:59:29.299]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.299]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.299]                     ...future.globals.maxSize)) {
[16:59:29.299]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.299]                     on.exit(options(oopts), add = TRUE)
[16:59:29.299]                   }
[16:59:29.299]                   {
[16:59:29.299]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.299]                       FUN = function(jj) {
[16:59:29.299]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.299]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.299]                       })
[16:59:29.299]                   }
[16:59:29.299]                 }, args = future.call.arguments)
[16:59:29.299]             }))
[16:59:29.299]             future::FutureResult(value = ...future.value$value, 
[16:59:29.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.299]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.299]                     ...future.globalenv.names))
[16:59:29.299]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.299]         }, condition = base::local({
[16:59:29.299]             c <- base::c
[16:59:29.299]             inherits <- base::inherits
[16:59:29.299]             invokeRestart <- base::invokeRestart
[16:59:29.299]             length <- base::length
[16:59:29.299]             list <- base::list
[16:59:29.299]             seq.int <- base::seq.int
[16:59:29.299]             signalCondition <- base::signalCondition
[16:59:29.299]             sys.calls <- base::sys.calls
[16:59:29.299]             `[[` <- base::`[[`
[16:59:29.299]             `+` <- base::`+`
[16:59:29.299]             `<<-` <- base::`<<-`
[16:59:29.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.299]                   3L)]
[16:59:29.299]             }
[16:59:29.299]             function(cond) {
[16:59:29.299]                 is_error <- inherits(cond, "error")
[16:59:29.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.299]                   NULL)
[16:59:29.299]                 if (is_error) {
[16:59:29.299]                   sessionInformation <- function() {
[16:59:29.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.299]                       search = base::search(), system = base::Sys.info())
[16:59:29.299]                   }
[16:59:29.299]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.299]                     cond$call), session = sessionInformation(), 
[16:59:29.299]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.299]                   signalCondition(cond)
[16:59:29.299]                 }
[16:59:29.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.299]                 "immediateCondition"))) {
[16:59:29.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.299]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.299]                   if (TRUE && !signal) {
[16:59:29.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.299]                     {
[16:59:29.299]                       inherits <- base::inherits
[16:59:29.299]                       invokeRestart <- base::invokeRestart
[16:59:29.299]                       is.null <- base::is.null
[16:59:29.299]                       muffled <- FALSE
[16:59:29.299]                       if (inherits(cond, "message")) {
[16:59:29.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.299]                         if (muffled) 
[16:59:29.299]                           invokeRestart("muffleMessage")
[16:59:29.299]                       }
[16:59:29.299]                       else if (inherits(cond, "warning")) {
[16:59:29.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.299]                         if (muffled) 
[16:59:29.299]                           invokeRestart("muffleWarning")
[16:59:29.299]                       }
[16:59:29.299]                       else if (inherits(cond, "condition")) {
[16:59:29.299]                         if (!is.null(pattern)) {
[16:59:29.299]                           computeRestarts <- base::computeRestarts
[16:59:29.299]                           grepl <- base::grepl
[16:59:29.299]                           restarts <- computeRestarts(cond)
[16:59:29.299]                           for (restart in restarts) {
[16:59:29.299]                             name <- restart$name
[16:59:29.299]                             if (is.null(name)) 
[16:59:29.299]                               next
[16:59:29.299]                             if (!grepl(pattern, name)) 
[16:59:29.299]                               next
[16:59:29.299]                             invokeRestart(restart)
[16:59:29.299]                             muffled <- TRUE
[16:59:29.299]                             break
[16:59:29.299]                           }
[16:59:29.299]                         }
[16:59:29.299]                       }
[16:59:29.299]                       invisible(muffled)
[16:59:29.299]                     }
[16:59:29.299]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.299]                   }
[16:59:29.299]                 }
[16:59:29.299]                 else {
[16:59:29.299]                   if (TRUE) {
[16:59:29.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.299]                     {
[16:59:29.299]                       inherits <- base::inherits
[16:59:29.299]                       invokeRestart <- base::invokeRestart
[16:59:29.299]                       is.null <- base::is.null
[16:59:29.299]                       muffled <- FALSE
[16:59:29.299]                       if (inherits(cond, "message")) {
[16:59:29.299]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.299]                         if (muffled) 
[16:59:29.299]                           invokeRestart("muffleMessage")
[16:59:29.299]                       }
[16:59:29.299]                       else if (inherits(cond, "warning")) {
[16:59:29.299]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.299]                         if (muffled) 
[16:59:29.299]                           invokeRestart("muffleWarning")
[16:59:29.299]                       }
[16:59:29.299]                       else if (inherits(cond, "condition")) {
[16:59:29.299]                         if (!is.null(pattern)) {
[16:59:29.299]                           computeRestarts <- base::computeRestarts
[16:59:29.299]                           grepl <- base::grepl
[16:59:29.299]                           restarts <- computeRestarts(cond)
[16:59:29.299]                           for (restart in restarts) {
[16:59:29.299]                             name <- restart$name
[16:59:29.299]                             if (is.null(name)) 
[16:59:29.299]                               next
[16:59:29.299]                             if (!grepl(pattern, name)) 
[16:59:29.299]                               next
[16:59:29.299]                             invokeRestart(restart)
[16:59:29.299]                             muffled <- TRUE
[16:59:29.299]                             break
[16:59:29.299]                           }
[16:59:29.299]                         }
[16:59:29.299]                       }
[16:59:29.299]                       invisible(muffled)
[16:59:29.299]                     }
[16:59:29.299]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.299]                   }
[16:59:29.299]                 }
[16:59:29.299]             }
[16:59:29.299]         }))
[16:59:29.299]     }, error = function(ex) {
[16:59:29.299]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.299]                 ...future.rng), started = ...future.startTime, 
[16:59:29.299]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.299]             version = "1.8"), class = "FutureResult")
[16:59:29.299]     }, finally = {
[16:59:29.299]         if (!identical(...future.workdir, getwd())) 
[16:59:29.299]             setwd(...future.workdir)
[16:59:29.299]         {
[16:59:29.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.299]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.299]             }
[16:59:29.299]             base::options(...future.oldOptions)
[16:59:29.299]             if (.Platform$OS.type == "windows") {
[16:59:29.299]                 old_names <- names(...future.oldEnvVars)
[16:59:29.299]                 envs <- base::Sys.getenv()
[16:59:29.299]                 names <- names(envs)
[16:59:29.299]                 common <- intersect(names, old_names)
[16:59:29.299]                 added <- setdiff(names, old_names)
[16:59:29.299]                 removed <- setdiff(old_names, names)
[16:59:29.299]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.299]                   envs[common]]
[16:59:29.299]                 NAMES <- toupper(changed)
[16:59:29.299]                 args <- list()
[16:59:29.299]                 for (kk in seq_along(NAMES)) {
[16:59:29.299]                   name <- changed[[kk]]
[16:59:29.299]                   NAME <- NAMES[[kk]]
[16:59:29.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.299]                     next
[16:59:29.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.299]                 }
[16:59:29.299]                 NAMES <- toupper(added)
[16:59:29.299]                 for (kk in seq_along(NAMES)) {
[16:59:29.299]                   name <- added[[kk]]
[16:59:29.299]                   NAME <- NAMES[[kk]]
[16:59:29.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.299]                     next
[16:59:29.299]                   args[[name]] <- ""
[16:59:29.299]                 }
[16:59:29.299]                 NAMES <- toupper(removed)
[16:59:29.299]                 for (kk in seq_along(NAMES)) {
[16:59:29.299]                   name <- removed[[kk]]
[16:59:29.299]                   NAME <- NAMES[[kk]]
[16:59:29.299]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.299]                     next
[16:59:29.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.299]                 }
[16:59:29.299]                 if (length(args) > 0) 
[16:59:29.299]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.299]             }
[16:59:29.299]             else {
[16:59:29.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.299]             }
[16:59:29.299]             {
[16:59:29.299]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.299]                   0L) {
[16:59:29.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.299]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.299]                   base::options(opts)
[16:59:29.299]                 }
[16:59:29.299]                 {
[16:59:29.299]                   {
[16:59:29.299]                     NULL
[16:59:29.299]                     RNGkind("Mersenne-Twister")
[16:59:29.299]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.299]                       inherits = FALSE)
[16:59:29.299]                   }
[16:59:29.299]                   options(future.plan = NULL)
[16:59:29.299]                   if (is.na(NA_character_)) 
[16:59:29.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.299]                     .init = FALSE)
[16:59:29.299]                 }
[16:59:29.299]             }
[16:59:29.299]         }
[16:59:29.299]     })
[16:59:29.299]     if (TRUE) {
[16:59:29.299]         base::sink(type = "output", split = FALSE)
[16:59:29.299]         if (TRUE) {
[16:59:29.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.299]         }
[16:59:29.299]         else {
[16:59:29.299]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.299]         }
[16:59:29.299]         base::close(...future.stdout)
[16:59:29.299]         ...future.stdout <- NULL
[16:59:29.299]     }
[16:59:29.299]     ...future.result$conditions <- ...future.conditions
[16:59:29.299]     ...future.result$finished <- base::Sys.time()
[16:59:29.299]     ...future.result
[16:59:29.299] }
[16:59:29.301] assign_globals() ...
[16:59:29.301] List of 5
[16:59:29.301]  $ future.call.arguments    : list()
[16:59:29.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.301]  $ ...future.FUN            :function (x)  
[16:59:29.301]  $ ...future.elements_ii    :List of 2
[16:59:29.301]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:29.301]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:29.301]  $ ...future.seeds_ii       : NULL
[16:59:29.301]  $ ...future.globals.maxSize: num Inf
[16:59:29.301]  - attr(*, "resolved")= logi FALSE
[16:59:29.301]  - attr(*, "total_size")= num NA
[16:59:29.301]  - attr(*, "where")=List of 5
[16:59:29.301]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.301]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.301]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.301]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.301]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.301]  - attr(*, "already-done")= logi TRUE
[16:59:29.308] - copied ‘future.call.arguments’ to environment
[16:59:29.308] - copied ‘...future.FUN’ to environment
[16:59:29.308] - copied ‘...future.elements_ii’ to environment
[16:59:29.308] - copied ‘...future.seeds_ii’ to environment
[16:59:29.308] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.309] assign_globals() ... done
[16:59:29.309] plan(): Setting new future strategy stack:
[16:59:29.309] List of future strategies:
[16:59:29.309] 1. sequential:
[16:59:29.309]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.309]    - tweaked: FALSE
[16:59:29.309]    - call: NULL
[16:59:29.309] plan(): nbrOfWorkers() = 1
[16:59:29.310] plan(): Setting new future strategy stack:
[16:59:29.310] List of future strategies:
[16:59:29.310] 1. sequential:
[16:59:29.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.310]    - tweaked: FALSE
[16:59:29.310]    - call: plan(strategy)
[16:59:29.311] plan(): nbrOfWorkers() = 1
[16:59:29.311] SequentialFuture started (and completed)
[16:59:29.311] - Launch lazy future ... done
[16:59:29.311] run() for ‘SequentialFuture’ ... done
[16:59:29.311] Created future:
[16:59:29.311] SequentialFuture:
[16:59:29.311] Label: ‘future_apply-1’
[16:59:29.311] Expression:
[16:59:29.311] {
[16:59:29.311]     do.call(function(...) {
[16:59:29.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.311]             on.exit(options(oopts), add = TRUE)
[16:59:29.311]         }
[16:59:29.311]         {
[16:59:29.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.311]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.311]             })
[16:59:29.311]         }
[16:59:29.311]     }, args = future.call.arguments)
[16:59:29.311] }
[16:59:29.311] Lazy evaluation: FALSE
[16:59:29.311] Asynchronous evaluation: FALSE
[16:59:29.311] Local evaluation: TRUE
[16:59:29.311] Environment: R_GlobalEnv
[16:59:29.311] Capture standard output: TRUE
[16:59:29.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.311] Globals: 5 objects totaling 1.10 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.311] Packages: <none>
[16:59:29.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.311] Resolved: TRUE
[16:59:29.311] Value: 224 bytes of class ‘list’
[16:59:29.311] Early signaling: FALSE
[16:59:29.311] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.311] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.312] Chunk #1 of 1 ... DONE
[16:59:29.312] Launching 1 futures (chunks) ... DONE
[16:59:29.313] Resolving 1 futures (chunks) ...
[16:59:29.313] resolve() on list ...
[16:59:29.313]  recursive: 0
[16:59:29.313]  length: 1
[16:59:29.313] 
[16:59:29.313] resolved() for ‘SequentialFuture’ ...
[16:59:29.313] - state: ‘finished’
[16:59:29.313] - run: TRUE
[16:59:29.313] - result: ‘FutureResult’
[16:59:29.313] resolved() for ‘SequentialFuture’ ... done
[16:59:29.314] Future #1
[16:59:29.314] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.314] - nx: 1
[16:59:29.314] - relay: TRUE
[16:59:29.314] - stdout: TRUE
[16:59:29.314] - signal: TRUE
[16:59:29.314] - resignal: FALSE
[16:59:29.314] - force: TRUE
[16:59:29.314] - relayed: [n=1] FALSE
[16:59:29.314] - queued futures: [n=1] FALSE
[16:59:29.315]  - until=1
[16:59:29.315]  - relaying element #1
[16:59:29.315] - relayed: [n=1] TRUE
[16:59:29.315] - queued futures: [n=1] TRUE
[16:59:29.315] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.315]  length: 0 (resolved future 1)
[16:59:29.315] Relaying remaining futures
[16:59:29.315] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.315] - nx: 1
[16:59:29.315] - relay: TRUE
[16:59:29.316] - stdout: TRUE
[16:59:29.316] - signal: TRUE
[16:59:29.316] - resignal: FALSE
[16:59:29.316] - force: TRUE
[16:59:29.316] - relayed: [n=1] TRUE
[16:59:29.316] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.316] - relayed: [n=1] TRUE
[16:59:29.316] - queued futures: [n=1] TRUE
[16:59:29.316] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.316] resolve() on list ... DONE
[16:59:29.317]  - Number of value chunks collected: 1
[16:59:29.317] Resolving 1 futures (chunks) ... DONE
[16:59:29.317] Reducing values from 1 chunks ...
[16:59:29.317]  - Number of values collected after concatenation: 2
[16:59:29.317]  - Number of values expected: 2
[16:59:29.317] Reducing values from 1 chunks ... DONE
[16:59:29.317] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:59:29.317] getGlobalsAndPackagesXApply() ...
[16:59:29.317]  - future.globals: TRUE
[16:59:29.318] getGlobalsAndPackages() ...
[16:59:29.318] Searching for globals...
[16:59:29.319] - globals found: [1] ‘FUN’
[16:59:29.319] Searching for globals ... DONE
[16:59:29.319] Resolving globals: FALSE
[16:59:29.319] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:29.320] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:29.320] - globals: [1] ‘FUN’
[16:59:29.320] 
[16:59:29.320] getGlobalsAndPackages() ... DONE
[16:59:29.320]  - globals found/used: [n=1] ‘FUN’
[16:59:29.320]  - needed namespaces: [n=0] 
[16:59:29.320] Finding globals ... DONE
[16:59:29.320]  - use_args: TRUE
[16:59:29.320]  - Getting '...' globals ...
[16:59:29.321] resolve() on list ...
[16:59:29.321]  recursive: 0
[16:59:29.321]  length: 1
[16:59:29.321]  elements: ‘...’
[16:59:29.321]  length: 0 (resolved future 1)
[16:59:29.321] resolve() on list ... DONE
[16:59:29.321]    - '...' content: [n=0] 
[16:59:29.321] List of 1
[16:59:29.321]  $ ...: list()
[16:59:29.321]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.321]  - attr(*, "where")=List of 1
[16:59:29.321]   ..$ ...:<environment: 0x55f313b9c768> 
[16:59:29.321]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.321]  - attr(*, "resolved")= logi TRUE
[16:59:29.321]  - attr(*, "total_size")= num NA
[16:59:29.324]  - Getting '...' globals ... DONE
[16:59:29.324] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.324] List of 2
[16:59:29.324]  $ ...future.FUN:function (x)  
[16:59:29.324]  $ ...          : list()
[16:59:29.324]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.324]  - attr(*, "where")=List of 2
[16:59:29.324]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.324]   ..$ ...          :<environment: 0x55f313b9c768> 
[16:59:29.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.324]  - attr(*, "resolved")= logi FALSE
[16:59:29.324]  - attr(*, "total_size")= num 848
[16:59:29.329] Packages to be attached in all futures: [n=0] 
[16:59:29.329] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.329] future_lapply() ...
[16:59:29.329] Number of chunks: 1
[16:59:29.329] getGlobalsAndPackagesXApply() ...
[16:59:29.330]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.330]  - use_args: TRUE
[16:59:29.330] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.330] List of 2
[16:59:29.330]  $ ...          : list()
[16:59:29.330]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.330]  $ ...future.FUN:function (x)  
[16:59:29.330]  - attr(*, "where")=List of 2
[16:59:29.330]   ..$ ...          :<environment: 0x55f313b9c768> 
[16:59:29.330]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.330]  - attr(*, "resolved")= logi FALSE
[16:59:29.330]  - attr(*, "total_size")= num NA
[16:59:29.333] Packages to be attached in all futures: [n=0] 
[16:59:29.333] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.334] Number of futures (= number of chunks): 1
[16:59:29.334] Launching 1 futures (chunks) ...
[16:59:29.334] Chunk #1 of 1 ...
[16:59:29.334]  - seeds: <none>
[16:59:29.334]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.334] getGlobalsAndPackages() ...
[16:59:29.334] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.334] Resolving globals: FALSE
[16:59:29.335] Tweak future expression to call with '...' arguments ...
[16:59:29.335] {
[16:59:29.335]     do.call(function(...) {
[16:59:29.335]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.335]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.335]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.335]             on.exit(options(oopts), add = TRUE)
[16:59:29.335]         }
[16:59:29.335]         {
[16:59:29.335]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.335]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.335]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.335]             })
[16:59:29.335]         }
[16:59:29.335]     }, args = future.call.arguments)
[16:59:29.335] }
[16:59:29.335] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.335] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.335] 
[16:59:29.336] getGlobalsAndPackages() ... DONE
[16:59:29.336] run() for ‘Future’ ...
[16:59:29.336] - state: ‘created’
[16:59:29.336] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.336] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.337]   - Field: ‘label’
[16:59:29.337]   - Field: ‘local’
[16:59:29.337]   - Field: ‘owner’
[16:59:29.337]   - Field: ‘envir’
[16:59:29.337]   - Field: ‘packages’
[16:59:29.337]   - Field: ‘gc’
[16:59:29.337]   - Field: ‘conditions’
[16:59:29.337]   - Field: ‘expr’
[16:59:29.337]   - Field: ‘uuid’
[16:59:29.337]   - Field: ‘seed’
[16:59:29.338]   - Field: ‘version’
[16:59:29.338]   - Field: ‘result’
[16:59:29.338]   - Field: ‘asynchronous’
[16:59:29.338]   - Field: ‘calls’
[16:59:29.338]   - Field: ‘globals’
[16:59:29.338]   - Field: ‘stdout’
[16:59:29.338]   - Field: ‘earlySignal’
[16:59:29.338]   - Field: ‘lazy’
[16:59:29.338]   - Field: ‘state’
[16:59:29.338] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.338] - Launch lazy future ...
[16:59:29.339] Packages needed by the future expression (n = 0): <none>
[16:59:29.339] Packages needed by future strategies (n = 0): <none>
[16:59:29.339] {
[16:59:29.339]     {
[16:59:29.339]         {
[16:59:29.339]             ...future.startTime <- base::Sys.time()
[16:59:29.339]             {
[16:59:29.339]                 {
[16:59:29.339]                   {
[16:59:29.339]                     base::local({
[16:59:29.339]                       has_future <- base::requireNamespace("future", 
[16:59:29.339]                         quietly = TRUE)
[16:59:29.339]                       if (has_future) {
[16:59:29.339]                         ns <- base::getNamespace("future")
[16:59:29.339]                         version <- ns[[".package"]][["version"]]
[16:59:29.339]                         if (is.null(version)) 
[16:59:29.339]                           version <- utils::packageVersion("future")
[16:59:29.339]                       }
[16:59:29.339]                       else {
[16:59:29.339]                         version <- NULL
[16:59:29.339]                       }
[16:59:29.339]                       if (!has_future || version < "1.8.0") {
[16:59:29.339]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.339]                           "", base::R.version$version.string), 
[16:59:29.339]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.339]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.339]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.339]                             "release", "version")], collapse = " "), 
[16:59:29.339]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.339]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.339]                           info)
[16:59:29.339]                         info <- base::paste(info, collapse = "; ")
[16:59:29.339]                         if (!has_future) {
[16:59:29.339]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.339]                             info)
[16:59:29.339]                         }
[16:59:29.339]                         else {
[16:59:29.339]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.339]                             info, version)
[16:59:29.339]                         }
[16:59:29.339]                         base::stop(msg)
[16:59:29.339]                       }
[16:59:29.339]                     })
[16:59:29.339]                   }
[16:59:29.339]                   ...future.strategy.old <- future::plan("list")
[16:59:29.339]                   options(future.plan = NULL)
[16:59:29.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.339]                 }
[16:59:29.339]                 ...future.workdir <- getwd()
[16:59:29.339]             }
[16:59:29.339]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.339]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.339]         }
[16:59:29.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.339]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.339]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.339]             base::names(...future.oldOptions))
[16:59:29.339]     }
[16:59:29.339]     if (FALSE) {
[16:59:29.339]     }
[16:59:29.339]     else {
[16:59:29.339]         if (TRUE) {
[16:59:29.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.339]                 open = "w")
[16:59:29.339]         }
[16:59:29.339]         else {
[16:59:29.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.339]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.339]         }
[16:59:29.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.339]             base::sink(type = "output", split = FALSE)
[16:59:29.339]             base::close(...future.stdout)
[16:59:29.339]         }, add = TRUE)
[16:59:29.339]     }
[16:59:29.339]     ...future.frame <- base::sys.nframe()
[16:59:29.339]     ...future.conditions <- base::list()
[16:59:29.339]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.339]     if (FALSE) {
[16:59:29.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.339]     }
[16:59:29.339]     ...future.result <- base::tryCatch({
[16:59:29.339]         base::withCallingHandlers({
[16:59:29.339]             ...future.value <- base::withVisible(base::local({
[16:59:29.339]                 do.call(function(...) {
[16:59:29.339]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.339]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.339]                     ...future.globals.maxSize)) {
[16:59:29.339]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.339]                     on.exit(options(oopts), add = TRUE)
[16:59:29.339]                   }
[16:59:29.339]                   {
[16:59:29.339]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.339]                       FUN = function(jj) {
[16:59:29.339]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.339]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.339]                       })
[16:59:29.339]                   }
[16:59:29.339]                 }, args = future.call.arguments)
[16:59:29.339]             }))
[16:59:29.339]             future::FutureResult(value = ...future.value$value, 
[16:59:29.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.339]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.339]                     ...future.globalenv.names))
[16:59:29.339]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.339]         }, condition = base::local({
[16:59:29.339]             c <- base::c
[16:59:29.339]             inherits <- base::inherits
[16:59:29.339]             invokeRestart <- base::invokeRestart
[16:59:29.339]             length <- base::length
[16:59:29.339]             list <- base::list
[16:59:29.339]             seq.int <- base::seq.int
[16:59:29.339]             signalCondition <- base::signalCondition
[16:59:29.339]             sys.calls <- base::sys.calls
[16:59:29.339]             `[[` <- base::`[[`
[16:59:29.339]             `+` <- base::`+`
[16:59:29.339]             `<<-` <- base::`<<-`
[16:59:29.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.339]                   3L)]
[16:59:29.339]             }
[16:59:29.339]             function(cond) {
[16:59:29.339]                 is_error <- inherits(cond, "error")
[16:59:29.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.339]                   NULL)
[16:59:29.339]                 if (is_error) {
[16:59:29.339]                   sessionInformation <- function() {
[16:59:29.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.339]                       search = base::search(), system = base::Sys.info())
[16:59:29.339]                   }
[16:59:29.339]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.339]                     cond$call), session = sessionInformation(), 
[16:59:29.339]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.339]                   signalCondition(cond)
[16:59:29.339]                 }
[16:59:29.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.339]                 "immediateCondition"))) {
[16:59:29.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.339]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.339]                   if (TRUE && !signal) {
[16:59:29.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.339]                     {
[16:59:29.339]                       inherits <- base::inherits
[16:59:29.339]                       invokeRestart <- base::invokeRestart
[16:59:29.339]                       is.null <- base::is.null
[16:59:29.339]                       muffled <- FALSE
[16:59:29.339]                       if (inherits(cond, "message")) {
[16:59:29.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.339]                         if (muffled) 
[16:59:29.339]                           invokeRestart("muffleMessage")
[16:59:29.339]                       }
[16:59:29.339]                       else if (inherits(cond, "warning")) {
[16:59:29.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.339]                         if (muffled) 
[16:59:29.339]                           invokeRestart("muffleWarning")
[16:59:29.339]                       }
[16:59:29.339]                       else if (inherits(cond, "condition")) {
[16:59:29.339]                         if (!is.null(pattern)) {
[16:59:29.339]                           computeRestarts <- base::computeRestarts
[16:59:29.339]                           grepl <- base::grepl
[16:59:29.339]                           restarts <- computeRestarts(cond)
[16:59:29.339]                           for (restart in restarts) {
[16:59:29.339]                             name <- restart$name
[16:59:29.339]                             if (is.null(name)) 
[16:59:29.339]                               next
[16:59:29.339]                             if (!grepl(pattern, name)) 
[16:59:29.339]                               next
[16:59:29.339]                             invokeRestart(restart)
[16:59:29.339]                             muffled <- TRUE
[16:59:29.339]                             break
[16:59:29.339]                           }
[16:59:29.339]                         }
[16:59:29.339]                       }
[16:59:29.339]                       invisible(muffled)
[16:59:29.339]                     }
[16:59:29.339]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.339]                   }
[16:59:29.339]                 }
[16:59:29.339]                 else {
[16:59:29.339]                   if (TRUE) {
[16:59:29.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.339]                     {
[16:59:29.339]                       inherits <- base::inherits
[16:59:29.339]                       invokeRestart <- base::invokeRestart
[16:59:29.339]                       is.null <- base::is.null
[16:59:29.339]                       muffled <- FALSE
[16:59:29.339]                       if (inherits(cond, "message")) {
[16:59:29.339]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.339]                         if (muffled) 
[16:59:29.339]                           invokeRestart("muffleMessage")
[16:59:29.339]                       }
[16:59:29.339]                       else if (inherits(cond, "warning")) {
[16:59:29.339]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.339]                         if (muffled) 
[16:59:29.339]                           invokeRestart("muffleWarning")
[16:59:29.339]                       }
[16:59:29.339]                       else if (inherits(cond, "condition")) {
[16:59:29.339]                         if (!is.null(pattern)) {
[16:59:29.339]                           computeRestarts <- base::computeRestarts
[16:59:29.339]                           grepl <- base::grepl
[16:59:29.339]                           restarts <- computeRestarts(cond)
[16:59:29.339]                           for (restart in restarts) {
[16:59:29.339]                             name <- restart$name
[16:59:29.339]                             if (is.null(name)) 
[16:59:29.339]                               next
[16:59:29.339]                             if (!grepl(pattern, name)) 
[16:59:29.339]                               next
[16:59:29.339]                             invokeRestart(restart)
[16:59:29.339]                             muffled <- TRUE
[16:59:29.339]                             break
[16:59:29.339]                           }
[16:59:29.339]                         }
[16:59:29.339]                       }
[16:59:29.339]                       invisible(muffled)
[16:59:29.339]                     }
[16:59:29.339]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.339]                   }
[16:59:29.339]                 }
[16:59:29.339]             }
[16:59:29.339]         }))
[16:59:29.339]     }, error = function(ex) {
[16:59:29.339]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.339]                 ...future.rng), started = ...future.startTime, 
[16:59:29.339]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.339]             version = "1.8"), class = "FutureResult")
[16:59:29.339]     }, finally = {
[16:59:29.339]         if (!identical(...future.workdir, getwd())) 
[16:59:29.339]             setwd(...future.workdir)
[16:59:29.339]         {
[16:59:29.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.339]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.339]             }
[16:59:29.339]             base::options(...future.oldOptions)
[16:59:29.339]             if (.Platform$OS.type == "windows") {
[16:59:29.339]                 old_names <- names(...future.oldEnvVars)
[16:59:29.339]                 envs <- base::Sys.getenv()
[16:59:29.339]                 names <- names(envs)
[16:59:29.339]                 common <- intersect(names, old_names)
[16:59:29.339]                 added <- setdiff(names, old_names)
[16:59:29.339]                 removed <- setdiff(old_names, names)
[16:59:29.339]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.339]                   envs[common]]
[16:59:29.339]                 NAMES <- toupper(changed)
[16:59:29.339]                 args <- list()
[16:59:29.339]                 for (kk in seq_along(NAMES)) {
[16:59:29.339]                   name <- changed[[kk]]
[16:59:29.339]                   NAME <- NAMES[[kk]]
[16:59:29.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.339]                     next
[16:59:29.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.339]                 }
[16:59:29.339]                 NAMES <- toupper(added)
[16:59:29.339]                 for (kk in seq_along(NAMES)) {
[16:59:29.339]                   name <- added[[kk]]
[16:59:29.339]                   NAME <- NAMES[[kk]]
[16:59:29.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.339]                     next
[16:59:29.339]                   args[[name]] <- ""
[16:59:29.339]                 }
[16:59:29.339]                 NAMES <- toupper(removed)
[16:59:29.339]                 for (kk in seq_along(NAMES)) {
[16:59:29.339]                   name <- removed[[kk]]
[16:59:29.339]                   NAME <- NAMES[[kk]]
[16:59:29.339]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.339]                     next
[16:59:29.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.339]                 }
[16:59:29.339]                 if (length(args) > 0) 
[16:59:29.339]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.339]             }
[16:59:29.339]             else {
[16:59:29.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.339]             }
[16:59:29.339]             {
[16:59:29.339]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.339]                   0L) {
[16:59:29.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.339]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.339]                   base::options(opts)
[16:59:29.339]                 }
[16:59:29.339]                 {
[16:59:29.339]                   {
[16:59:29.339]                     NULL
[16:59:29.339]                     RNGkind("Mersenne-Twister")
[16:59:29.339]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.339]                       inherits = FALSE)
[16:59:29.339]                   }
[16:59:29.339]                   options(future.plan = NULL)
[16:59:29.339]                   if (is.na(NA_character_)) 
[16:59:29.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.339]                     .init = FALSE)
[16:59:29.339]                 }
[16:59:29.339]             }
[16:59:29.339]         }
[16:59:29.339]     })
[16:59:29.339]     if (TRUE) {
[16:59:29.339]         base::sink(type = "output", split = FALSE)
[16:59:29.339]         if (TRUE) {
[16:59:29.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.339]         }
[16:59:29.339]         else {
[16:59:29.339]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.339]         }
[16:59:29.339]         base::close(...future.stdout)
[16:59:29.339]         ...future.stdout <- NULL
[16:59:29.339]     }
[16:59:29.339]     ...future.result$conditions <- ...future.conditions
[16:59:29.339]     ...future.result$finished <- base::Sys.time()
[16:59:29.339]     ...future.result
[16:59:29.339] }
[16:59:29.341] assign_globals() ...
[16:59:29.341] List of 5
[16:59:29.341]  $ future.call.arguments    : list()
[16:59:29.341]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.341]  $ ...future.FUN            :function (x)  
[16:59:29.341]  $ ...future.elements_ii    :List of 6
[16:59:29.341]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:29.341]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:29.341]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:29.341]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:29.341]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:29.341]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:29.341]  $ ...future.seeds_ii       : NULL
[16:59:29.341]  $ ...future.globals.maxSize: num Inf
[16:59:29.341]  - attr(*, "resolved")= logi FALSE
[16:59:29.341]  - attr(*, "total_size")= num NA
[16:59:29.341]  - attr(*, "where")=List of 5
[16:59:29.341]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.341]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.341]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.341]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.341]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.341]  - attr(*, "already-done")= logi TRUE
[16:59:29.347] - copied ‘future.call.arguments’ to environment
[16:59:29.347] - copied ‘...future.FUN’ to environment
[16:59:29.347] - copied ‘...future.elements_ii’ to environment
[16:59:29.348] - copied ‘...future.seeds_ii’ to environment
[16:59:29.348] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.348] assign_globals() ... done
[16:59:29.348] plan(): Setting new future strategy stack:
[16:59:29.348] List of future strategies:
[16:59:29.348] 1. sequential:
[16:59:29.348]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.348]    - tweaked: FALSE
[16:59:29.348]    - call: NULL
[16:59:29.349] plan(): nbrOfWorkers() = 1
[16:59:29.349] plan(): Setting new future strategy stack:
[16:59:29.350] List of future strategies:
[16:59:29.350] 1. sequential:
[16:59:29.350]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.350]    - tweaked: FALSE
[16:59:29.350]    - call: plan(strategy)
[16:59:29.350] plan(): nbrOfWorkers() = 1
[16:59:29.350] SequentialFuture started (and completed)
[16:59:29.350] - Launch lazy future ... done
[16:59:29.350] run() for ‘SequentialFuture’ ... done
[16:59:29.351] Created future:
[16:59:29.351] SequentialFuture:
[16:59:29.351] Label: ‘future_apply-1’
[16:59:29.351] Expression:
[16:59:29.351] {
[16:59:29.351]     do.call(function(...) {
[16:59:29.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.351]             on.exit(options(oopts), add = TRUE)
[16:59:29.351]         }
[16:59:29.351]         {
[16:59:29.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.351]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.351]             })
[16:59:29.351]         }
[16:59:29.351]     }, args = future.call.arguments)
[16:59:29.351] }
[16:59:29.351] Lazy evaluation: FALSE
[16:59:29.351] Asynchronous evaluation: FALSE
[16:59:29.351] Local evaluation: TRUE
[16:59:29.351] Environment: R_GlobalEnv
[16:59:29.351] Capture standard output: TRUE
[16:59:29.351] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.351] Globals: 5 objects totaling 1.54 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 672 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.351] Packages: <none>
[16:59:29.351] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.351] Resolved: TRUE
[16:59:29.351] Value: 672 bytes of class ‘list’
[16:59:29.351] Early signaling: FALSE
[16:59:29.351] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.351] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.352] Chunk #1 of 1 ... DONE
[16:59:29.352] Launching 1 futures (chunks) ... DONE
[16:59:29.352] Resolving 1 futures (chunks) ...
[16:59:29.352] resolve() on list ...
[16:59:29.352]  recursive: 0
[16:59:29.352]  length: 1
[16:59:29.352] 
[16:59:29.352] resolved() for ‘SequentialFuture’ ...
[16:59:29.354] - state: ‘finished’
[16:59:29.355] - run: TRUE
[16:59:29.355] - result: ‘FutureResult’
[16:59:29.355] resolved() for ‘SequentialFuture’ ... done
[16:59:29.355] Future #1
[16:59:29.355] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.355] - nx: 1
[16:59:29.355] - relay: TRUE
[16:59:29.355] - stdout: TRUE
[16:59:29.355] - signal: TRUE
[16:59:29.355] - resignal: FALSE
[16:59:29.356] - force: TRUE
[16:59:29.356] - relayed: [n=1] FALSE
[16:59:29.356] - queued futures: [n=1] FALSE
[16:59:29.356]  - until=1
[16:59:29.356]  - relaying element #1
[16:59:29.356] - relayed: [n=1] TRUE
[16:59:29.356] - queued futures: [n=1] TRUE
[16:59:29.356] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.356]  length: 0 (resolved future 1)
[16:59:29.357] Relaying remaining futures
[16:59:29.357] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.357] - nx: 1
[16:59:29.357] - relay: TRUE
[16:59:29.357] - stdout: TRUE
[16:59:29.357] - signal: TRUE
[16:59:29.357] - resignal: FALSE
[16:59:29.357] - force: TRUE
[16:59:29.357] - relayed: [n=1] TRUE
[16:59:29.357] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.357] - relayed: [n=1] TRUE
[16:59:29.357] - queued futures: [n=1] TRUE
[16:59:29.358] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.358] resolve() on list ... DONE
[16:59:29.358]  - Number of value chunks collected: 1
[16:59:29.358] Resolving 1 futures (chunks) ... DONE
[16:59:29.358] Reducing values from 1 chunks ...
[16:59:29.358]  - Number of values collected after concatenation: 6
[16:59:29.358]  - Number of values expected: 6
[16:59:29.358] Reducing values from 1 chunks ... DONE
[16:59:29.358] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:59:29.359] getGlobalsAndPackagesXApply() ...
[16:59:29.359]  - future.globals: TRUE
[16:59:29.359] getGlobalsAndPackages() ...
[16:59:29.359] Searching for globals...
[16:59:29.360] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:59:29.361] Searching for globals ... DONE
[16:59:29.361] Resolving globals: FALSE
[16:59:29.361] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:59:29.361] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:59:29.362] - globals: [1] ‘FUN’
[16:59:29.362] 
[16:59:29.362] getGlobalsAndPackages() ... DONE
[16:59:29.362]  - globals found/used: [n=1] ‘FUN’
[16:59:29.362]  - needed namespaces: [n=0] 
[16:59:29.362] Finding globals ... DONE
[16:59:29.362]  - use_args: TRUE
[16:59:29.362]  - Getting '...' globals ...
[16:59:29.363] resolve() on list ...
[16:59:29.363]  recursive: 0
[16:59:29.363]  length: 1
[16:59:29.363]  elements: ‘...’
[16:59:29.363]  length: 0 (resolved future 1)
[16:59:29.363] resolve() on list ... DONE
[16:59:29.363]    - '...' content: [n=0] 
[16:59:29.363] List of 1
[16:59:29.363]  $ ...: list()
[16:59:29.363]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.363]  - attr(*, "where")=List of 1
[16:59:29.363]   ..$ ...:<environment: 0x55f31186fd30> 
[16:59:29.363]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.363]  - attr(*, "resolved")= logi TRUE
[16:59:29.363]  - attr(*, "total_size")= num NA
[16:59:29.366]  - Getting '...' globals ... DONE
[16:59:29.366] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.366] List of 2
[16:59:29.366]  $ ...future.FUN:function (x)  
[16:59:29.366]  $ ...          : list()
[16:59:29.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.366]  - attr(*, "where")=List of 2
[16:59:29.366]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.366]   ..$ ...          :<environment: 0x55f31186fd30> 
[16:59:29.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.366]  - attr(*, "resolved")= logi FALSE
[16:59:29.366]  - attr(*, "total_size")= num 1768
[16:59:29.369] Packages to be attached in all futures: [n=0] 
[16:59:29.369] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.369] future_lapply() ...
[16:59:29.370] Number of chunks: 1
[16:59:29.370] getGlobalsAndPackagesXApply() ...
[16:59:29.370]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.370]  - use_args: TRUE
[16:59:29.370] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.370] List of 2
[16:59:29.370]  $ ...          : list()
[16:59:29.370]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.370]  $ ...future.FUN:function (x)  
[16:59:29.370]  - attr(*, "where")=List of 2
[16:59:29.370]   ..$ ...          :<environment: 0x55f31186fd30> 
[16:59:29.370]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:59:29.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.370]  - attr(*, "resolved")= logi FALSE
[16:59:29.370]  - attr(*, "total_size")= num NA
[16:59:29.373] Packages to be attached in all futures: [n=0] 
[16:59:29.373] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.373] Number of futures (= number of chunks): 1
[16:59:29.373] Launching 1 futures (chunks) ...
[16:59:29.374] Chunk #1 of 1 ...
[16:59:29.374]  - seeds: <none>
[16:59:29.374]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.374] getGlobalsAndPackages() ...
[16:59:29.374] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.374] Resolving globals: FALSE
[16:59:29.374] Tweak future expression to call with '...' arguments ...
[16:59:29.374] {
[16:59:29.374]     do.call(function(...) {
[16:59:29.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.374]             on.exit(options(oopts), add = TRUE)
[16:59:29.374]         }
[16:59:29.374]         {
[16:59:29.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.374]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.374]             })
[16:59:29.374]         }
[16:59:29.374]     }, args = future.call.arguments)
[16:59:29.374] }
[16:59:29.375] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.375] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.375] 
[16:59:29.375] getGlobalsAndPackages() ... DONE
[16:59:29.375] run() for ‘Future’ ...
[16:59:29.376] - state: ‘created’
[16:59:29.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.376] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.376]   - Field: ‘label’
[16:59:29.376]   - Field: ‘local’
[16:59:29.376]   - Field: ‘owner’
[16:59:29.377]   - Field: ‘envir’
[16:59:29.377]   - Field: ‘packages’
[16:59:29.377]   - Field: ‘gc’
[16:59:29.379]   - Field: ‘conditions’
[16:59:29.379]   - Field: ‘expr’
[16:59:29.379]   - Field: ‘uuid’
[16:59:29.379]   - Field: ‘seed’
[16:59:29.379]   - Field: ‘version’
[16:59:29.379]   - Field: ‘result’
[16:59:29.379]   - Field: ‘asynchronous’
[16:59:29.379]   - Field: ‘calls’
[16:59:29.380]   - Field: ‘globals’
[16:59:29.380]   - Field: ‘stdout’
[16:59:29.380]   - Field: ‘earlySignal’
[16:59:29.380]   - Field: ‘lazy’
[16:59:29.380]   - Field: ‘state’
[16:59:29.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.380] - Launch lazy future ...
[16:59:29.380] Packages needed by the future expression (n = 0): <none>
[16:59:29.380] Packages needed by future strategies (n = 0): <none>
[16:59:29.381] {
[16:59:29.381]     {
[16:59:29.381]         {
[16:59:29.381]             ...future.startTime <- base::Sys.time()
[16:59:29.381]             {
[16:59:29.381]                 {
[16:59:29.381]                   {
[16:59:29.381]                     base::local({
[16:59:29.381]                       has_future <- base::requireNamespace("future", 
[16:59:29.381]                         quietly = TRUE)
[16:59:29.381]                       if (has_future) {
[16:59:29.381]                         ns <- base::getNamespace("future")
[16:59:29.381]                         version <- ns[[".package"]][["version"]]
[16:59:29.381]                         if (is.null(version)) 
[16:59:29.381]                           version <- utils::packageVersion("future")
[16:59:29.381]                       }
[16:59:29.381]                       else {
[16:59:29.381]                         version <- NULL
[16:59:29.381]                       }
[16:59:29.381]                       if (!has_future || version < "1.8.0") {
[16:59:29.381]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.381]                           "", base::R.version$version.string), 
[16:59:29.381]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.381]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.381]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.381]                             "release", "version")], collapse = " "), 
[16:59:29.381]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.381]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.381]                           info)
[16:59:29.381]                         info <- base::paste(info, collapse = "; ")
[16:59:29.381]                         if (!has_future) {
[16:59:29.381]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.381]                             info)
[16:59:29.381]                         }
[16:59:29.381]                         else {
[16:59:29.381]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.381]                             info, version)
[16:59:29.381]                         }
[16:59:29.381]                         base::stop(msg)
[16:59:29.381]                       }
[16:59:29.381]                     })
[16:59:29.381]                   }
[16:59:29.381]                   ...future.strategy.old <- future::plan("list")
[16:59:29.381]                   options(future.plan = NULL)
[16:59:29.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.381]                 }
[16:59:29.381]                 ...future.workdir <- getwd()
[16:59:29.381]             }
[16:59:29.381]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.381]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.381]         }
[16:59:29.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.381]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.381]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.381]             base::names(...future.oldOptions))
[16:59:29.381]     }
[16:59:29.381]     if (FALSE) {
[16:59:29.381]     }
[16:59:29.381]     else {
[16:59:29.381]         if (TRUE) {
[16:59:29.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.381]                 open = "w")
[16:59:29.381]         }
[16:59:29.381]         else {
[16:59:29.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.381]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.381]         }
[16:59:29.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.381]             base::sink(type = "output", split = FALSE)
[16:59:29.381]             base::close(...future.stdout)
[16:59:29.381]         }, add = TRUE)
[16:59:29.381]     }
[16:59:29.381]     ...future.frame <- base::sys.nframe()
[16:59:29.381]     ...future.conditions <- base::list()
[16:59:29.381]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.381]     if (FALSE) {
[16:59:29.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.381]     }
[16:59:29.381]     ...future.result <- base::tryCatch({
[16:59:29.381]         base::withCallingHandlers({
[16:59:29.381]             ...future.value <- base::withVisible(base::local({
[16:59:29.381]                 do.call(function(...) {
[16:59:29.381]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.381]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.381]                     ...future.globals.maxSize)) {
[16:59:29.381]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.381]                     on.exit(options(oopts), add = TRUE)
[16:59:29.381]                   }
[16:59:29.381]                   {
[16:59:29.381]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.381]                       FUN = function(jj) {
[16:59:29.381]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.381]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.381]                       })
[16:59:29.381]                   }
[16:59:29.381]                 }, args = future.call.arguments)
[16:59:29.381]             }))
[16:59:29.381]             future::FutureResult(value = ...future.value$value, 
[16:59:29.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.381]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.381]                     ...future.globalenv.names))
[16:59:29.381]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.381]         }, condition = base::local({
[16:59:29.381]             c <- base::c
[16:59:29.381]             inherits <- base::inherits
[16:59:29.381]             invokeRestart <- base::invokeRestart
[16:59:29.381]             length <- base::length
[16:59:29.381]             list <- base::list
[16:59:29.381]             seq.int <- base::seq.int
[16:59:29.381]             signalCondition <- base::signalCondition
[16:59:29.381]             sys.calls <- base::sys.calls
[16:59:29.381]             `[[` <- base::`[[`
[16:59:29.381]             `+` <- base::`+`
[16:59:29.381]             `<<-` <- base::`<<-`
[16:59:29.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.381]                   3L)]
[16:59:29.381]             }
[16:59:29.381]             function(cond) {
[16:59:29.381]                 is_error <- inherits(cond, "error")
[16:59:29.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.381]                   NULL)
[16:59:29.381]                 if (is_error) {
[16:59:29.381]                   sessionInformation <- function() {
[16:59:29.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.381]                       search = base::search(), system = base::Sys.info())
[16:59:29.381]                   }
[16:59:29.381]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.381]                     cond$call), session = sessionInformation(), 
[16:59:29.381]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.381]                   signalCondition(cond)
[16:59:29.381]                 }
[16:59:29.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.381]                 "immediateCondition"))) {
[16:59:29.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.381]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.381]                   if (TRUE && !signal) {
[16:59:29.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.381]                     {
[16:59:29.381]                       inherits <- base::inherits
[16:59:29.381]                       invokeRestart <- base::invokeRestart
[16:59:29.381]                       is.null <- base::is.null
[16:59:29.381]                       muffled <- FALSE
[16:59:29.381]                       if (inherits(cond, "message")) {
[16:59:29.381]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.381]                         if (muffled) 
[16:59:29.381]                           invokeRestart("muffleMessage")
[16:59:29.381]                       }
[16:59:29.381]                       else if (inherits(cond, "warning")) {
[16:59:29.381]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.381]                         if (muffled) 
[16:59:29.381]                           invokeRestart("muffleWarning")
[16:59:29.381]                       }
[16:59:29.381]                       else if (inherits(cond, "condition")) {
[16:59:29.381]                         if (!is.null(pattern)) {
[16:59:29.381]                           computeRestarts <- base::computeRestarts
[16:59:29.381]                           grepl <- base::grepl
[16:59:29.381]                           restarts <- computeRestarts(cond)
[16:59:29.381]                           for (restart in restarts) {
[16:59:29.381]                             name <- restart$name
[16:59:29.381]                             if (is.null(name)) 
[16:59:29.381]                               next
[16:59:29.381]                             if (!grepl(pattern, name)) 
[16:59:29.381]                               next
[16:59:29.381]                             invokeRestart(restart)
[16:59:29.381]                             muffled <- TRUE
[16:59:29.381]                             break
[16:59:29.381]                           }
[16:59:29.381]                         }
[16:59:29.381]                       }
[16:59:29.381]                       invisible(muffled)
[16:59:29.381]                     }
[16:59:29.381]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.381]                   }
[16:59:29.381]                 }
[16:59:29.381]                 else {
[16:59:29.381]                   if (TRUE) {
[16:59:29.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.381]                     {
[16:59:29.381]                       inherits <- base::inherits
[16:59:29.381]                       invokeRestart <- base::invokeRestart
[16:59:29.381]                       is.null <- base::is.null
[16:59:29.381]                       muffled <- FALSE
[16:59:29.381]                       if (inherits(cond, "message")) {
[16:59:29.381]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.381]                         if (muffled) 
[16:59:29.381]                           invokeRestart("muffleMessage")
[16:59:29.381]                       }
[16:59:29.381]                       else if (inherits(cond, "warning")) {
[16:59:29.381]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.381]                         if (muffled) 
[16:59:29.381]                           invokeRestart("muffleWarning")
[16:59:29.381]                       }
[16:59:29.381]                       else if (inherits(cond, "condition")) {
[16:59:29.381]                         if (!is.null(pattern)) {
[16:59:29.381]                           computeRestarts <- base::computeRestarts
[16:59:29.381]                           grepl <- base::grepl
[16:59:29.381]                           restarts <- computeRestarts(cond)
[16:59:29.381]                           for (restart in restarts) {
[16:59:29.381]                             name <- restart$name
[16:59:29.381]                             if (is.null(name)) 
[16:59:29.381]                               next
[16:59:29.381]                             if (!grepl(pattern, name)) 
[16:59:29.381]                               next
[16:59:29.381]                             invokeRestart(restart)
[16:59:29.381]                             muffled <- TRUE
[16:59:29.381]                             break
[16:59:29.381]                           }
[16:59:29.381]                         }
[16:59:29.381]                       }
[16:59:29.381]                       invisible(muffled)
[16:59:29.381]                     }
[16:59:29.381]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.381]                   }
[16:59:29.381]                 }
[16:59:29.381]             }
[16:59:29.381]         }))
[16:59:29.381]     }, error = function(ex) {
[16:59:29.381]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.381]                 ...future.rng), started = ...future.startTime, 
[16:59:29.381]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.381]             version = "1.8"), class = "FutureResult")
[16:59:29.381]     }, finally = {
[16:59:29.381]         if (!identical(...future.workdir, getwd())) 
[16:59:29.381]             setwd(...future.workdir)
[16:59:29.381]         {
[16:59:29.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.381]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.381]             }
[16:59:29.381]             base::options(...future.oldOptions)
[16:59:29.381]             if (.Platform$OS.type == "windows") {
[16:59:29.381]                 old_names <- names(...future.oldEnvVars)
[16:59:29.381]                 envs <- base::Sys.getenv()
[16:59:29.381]                 names <- names(envs)
[16:59:29.381]                 common <- intersect(names, old_names)
[16:59:29.381]                 added <- setdiff(names, old_names)
[16:59:29.381]                 removed <- setdiff(old_names, names)
[16:59:29.381]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.381]                   envs[common]]
[16:59:29.381]                 NAMES <- toupper(changed)
[16:59:29.381]                 args <- list()
[16:59:29.381]                 for (kk in seq_along(NAMES)) {
[16:59:29.381]                   name <- changed[[kk]]
[16:59:29.381]                   NAME <- NAMES[[kk]]
[16:59:29.381]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.381]                     next
[16:59:29.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.381]                 }
[16:59:29.381]                 NAMES <- toupper(added)
[16:59:29.381]                 for (kk in seq_along(NAMES)) {
[16:59:29.381]                   name <- added[[kk]]
[16:59:29.381]                   NAME <- NAMES[[kk]]
[16:59:29.381]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.381]                     next
[16:59:29.381]                   args[[name]] <- ""
[16:59:29.381]                 }
[16:59:29.381]                 NAMES <- toupper(removed)
[16:59:29.381]                 for (kk in seq_along(NAMES)) {
[16:59:29.381]                   name <- removed[[kk]]
[16:59:29.381]                   NAME <- NAMES[[kk]]
[16:59:29.381]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.381]                     next
[16:59:29.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.381]                 }
[16:59:29.381]                 if (length(args) > 0) 
[16:59:29.381]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.381]             }
[16:59:29.381]             else {
[16:59:29.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.381]             }
[16:59:29.381]             {
[16:59:29.381]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.381]                   0L) {
[16:59:29.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.381]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.381]                   base::options(opts)
[16:59:29.381]                 }
[16:59:29.381]                 {
[16:59:29.381]                   {
[16:59:29.381]                     NULL
[16:59:29.381]                     RNGkind("Mersenne-Twister")
[16:59:29.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.381]                       inherits = FALSE)
[16:59:29.381]                   }
[16:59:29.381]                   options(future.plan = NULL)
[16:59:29.381]                   if (is.na(NA_character_)) 
[16:59:29.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.381]                     .init = FALSE)
[16:59:29.381]                 }
[16:59:29.381]             }
[16:59:29.381]         }
[16:59:29.381]     })
[16:59:29.381]     if (TRUE) {
[16:59:29.381]         base::sink(type = "output", split = FALSE)
[16:59:29.381]         if (TRUE) {
[16:59:29.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.381]         }
[16:59:29.381]         else {
[16:59:29.381]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.381]         }
[16:59:29.381]         base::close(...future.stdout)
[16:59:29.381]         ...future.stdout <- NULL
[16:59:29.381]     }
[16:59:29.381]     ...future.result$conditions <- ...future.conditions
[16:59:29.381]     ...future.result$finished <- base::Sys.time()
[16:59:29.381]     ...future.result
[16:59:29.381] }
[16:59:29.383] assign_globals() ...
[16:59:29.383] List of 5
[16:59:29.383]  $ future.call.arguments    : list()
[16:59:29.383]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.383]  $ ...future.FUN            :function (x)  
[16:59:29.383]  $ ...future.elements_ii    :List of 6
[16:59:29.383]   ..$ : int [1:4] 1 7 13 19
[16:59:29.383]   ..$ : int [1:4] 2 8 14 20
[16:59:29.383]   ..$ : int [1:4] 3 9 15 21
[16:59:29.383]   ..$ : int [1:4] 4 10 16 22
[16:59:29.383]   ..$ : int [1:4] 5 11 17 23
[16:59:29.383]   ..$ : int [1:4] 6 12 18 24
[16:59:29.383]  $ ...future.seeds_ii       : NULL
[16:59:29.383]  $ ...future.globals.maxSize: num Inf
[16:59:29.383]  - attr(*, "resolved")= logi FALSE
[16:59:29.383]  - attr(*, "total_size")= num NA
[16:59:29.383]  - attr(*, "where")=List of 5
[16:59:29.383]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.383]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.383]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.383]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.383]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.383]  - attr(*, "already-done")= logi TRUE
[16:59:29.389] - copied ‘future.call.arguments’ to environment
[16:59:29.389] - reassign environment for ‘...future.FUN’
[16:59:29.389] - copied ‘...future.FUN’ to environment
[16:59:29.389] - copied ‘...future.elements_ii’ to environment
[16:59:29.389] - copied ‘...future.seeds_ii’ to environment
[16:59:29.389] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.389] assign_globals() ... done
[16:59:29.390] plan(): Setting new future strategy stack:
[16:59:29.390] List of future strategies:
[16:59:29.390] 1. sequential:
[16:59:29.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.390]    - tweaked: FALSE
[16:59:29.390]    - call: NULL
[16:59:29.390] plan(): nbrOfWorkers() = 1
[16:59:29.391] plan(): Setting new future strategy stack:
[16:59:29.391] List of future strategies:
[16:59:29.391] 1. sequential:
[16:59:29.391]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.391]    - tweaked: FALSE
[16:59:29.391]    - call: plan(strategy)
[16:59:29.392] plan(): nbrOfWorkers() = 1
[16:59:29.392] SequentialFuture started (and completed)
[16:59:29.392] - Launch lazy future ... done
[16:59:29.392] run() for ‘SequentialFuture’ ... done
[16:59:29.392] Created future:
[16:59:29.392] SequentialFuture:
[16:59:29.392] Label: ‘future_apply-1’
[16:59:29.392] Expression:
[16:59:29.392] {
[16:59:29.392]     do.call(function(...) {
[16:59:29.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.392]             on.exit(options(oopts), add = TRUE)
[16:59:29.392]         }
[16:59:29.392]         {
[16:59:29.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.392]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.392]             })
[16:59:29.392]         }
[16:59:29.392]     }, args = future.call.arguments)
[16:59:29.392] }
[16:59:29.392] Lazy evaluation: FALSE
[16:59:29.392] Asynchronous evaluation: FALSE
[16:59:29.392] Local evaluation: TRUE
[16:59:29.392] Environment: R_GlobalEnv
[16:59:29.392] Capture standard output: TRUE
[16:59:29.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.392] Globals: 5 objects totaling 2.16 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 384 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.392] Packages: <none>
[16:59:29.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.392] Resolved: TRUE
[16:59:29.392] Value: 1.03 KiB of class ‘list’
[16:59:29.392] Early signaling: FALSE
[16:59:29.392] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.392] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.393] Chunk #1 of 1 ... DONE
[16:59:29.393] Launching 1 futures (chunks) ... DONE
[16:59:29.394] Resolving 1 futures (chunks) ...
[16:59:29.394] resolve() on list ...
[16:59:29.394]  recursive: 0
[16:59:29.394]  length: 1
[16:59:29.394] 
[16:59:29.394] resolved() for ‘SequentialFuture’ ...
[16:59:29.394] - state: ‘finished’
[16:59:29.394] - run: TRUE
[16:59:29.394] - result: ‘FutureResult’
[16:59:29.394] resolved() for ‘SequentialFuture’ ... done
[16:59:29.395] Future #1
[16:59:29.395] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.395] - nx: 1
[16:59:29.395] - relay: TRUE
[16:59:29.395] - stdout: TRUE
[16:59:29.395] - signal: TRUE
[16:59:29.395] - resignal: FALSE
[16:59:29.395] - force: TRUE
[16:59:29.395] - relayed: [n=1] FALSE
[16:59:29.395] - queued futures: [n=1] FALSE
[16:59:29.395]  - until=1
[16:59:29.396]  - relaying element #1
[16:59:29.396] - relayed: [n=1] TRUE
[16:59:29.396] - queued futures: [n=1] TRUE
[16:59:29.396] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.396]  length: 0 (resolved future 1)
[16:59:29.396] Relaying remaining futures
[16:59:29.396] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.396] - nx: 1
[16:59:29.396] - relay: TRUE
[16:59:29.396] - stdout: TRUE
[16:59:29.397] - signal: TRUE
[16:59:29.397] - resignal: FALSE
[16:59:29.397] - force: TRUE
[16:59:29.397] - relayed: [n=1] TRUE
[16:59:29.397] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.397] - relayed: [n=1] TRUE
[16:59:29.397] - queued futures: [n=1] TRUE
[16:59:29.397] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.397] resolve() on list ... DONE
[16:59:29.397]  - Number of value chunks collected: 1
[16:59:29.398] Resolving 1 futures (chunks) ... DONE
[16:59:29.398] Reducing values from 1 chunks ...
[16:59:29.398]  - Number of values collected after concatenation: 6
[16:59:29.398]  - Number of values expected: 6
[16:59:29.398] Reducing values from 1 chunks ... DONE
[16:59:29.398] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:59:29.398] getGlobalsAndPackagesXApply() ...
[16:59:29.398]  - future.globals: TRUE
[16:59:29.398] getGlobalsAndPackages() ...
[16:59:29.399] Searching for globals...
[16:59:29.400] - globals found: [1] ‘FUN’
[16:59:29.400] Searching for globals ... DONE
[16:59:29.400] Resolving globals: FALSE
[16:59:29.400] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:29.401] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:29.401] - globals: [1] ‘FUN’
[16:59:29.401] 
[16:59:29.401] getGlobalsAndPackages() ... DONE
[16:59:29.401]  - globals found/used: [n=1] ‘FUN’
[16:59:29.401]  - needed namespaces: [n=0] 
[16:59:29.401] Finding globals ... DONE
[16:59:29.401]  - use_args: TRUE
[16:59:29.401]  - Getting '...' globals ...
[16:59:29.402] resolve() on list ...
[16:59:29.402]  recursive: 0
[16:59:29.402]  length: 1
[16:59:29.402]  elements: ‘...’
[16:59:29.402]  length: 0 (resolved future 1)
[16:59:29.402] resolve() on list ... DONE
[16:59:29.404]    - '...' content: [n=0] 
[16:59:29.404] List of 1
[16:59:29.404]  $ ...: list()
[16:59:29.404]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.404]  - attr(*, "where")=List of 1
[16:59:29.404]   ..$ ...:<environment: 0x55f313edffb8> 
[16:59:29.404]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.404]  - attr(*, "resolved")= logi TRUE
[16:59:29.404]  - attr(*, "total_size")= num NA
[16:59:29.407]  - Getting '...' globals ... DONE
[16:59:29.407] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.407] List of 2
[16:59:29.407]  $ ...future.FUN:function (x)  
[16:59:29.407]  $ ...          : list()
[16:59:29.407]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.407]  - attr(*, "where")=List of 2
[16:59:29.407]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.407]   ..$ ...          :<environment: 0x55f313edffb8> 
[16:59:29.407]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.407]  - attr(*, "resolved")= logi FALSE
[16:59:29.407]  - attr(*, "total_size")= num 848
[16:59:29.410] Packages to be attached in all futures: [n=0] 
[16:59:29.410] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.410] future_lapply() ...
[16:59:29.411] Number of chunks: 1
[16:59:29.411] getGlobalsAndPackagesXApply() ...
[16:59:29.411]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.411]  - use_args: TRUE
[16:59:29.411] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.412] List of 2
[16:59:29.412]  $ ...          : list()
[16:59:29.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.412]  $ ...future.FUN:function (x)  
[16:59:29.412]  - attr(*, "where")=List of 2
[16:59:29.412]   ..$ ...          :<environment: 0x55f313edffb8> 
[16:59:29.412]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.412]  - attr(*, "resolved")= logi FALSE
[16:59:29.412]  - attr(*, "total_size")= num NA
[16:59:29.415] Packages to be attached in all futures: [n=0] 
[16:59:29.415] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.415] Number of futures (= number of chunks): 1
[16:59:29.415] Launching 1 futures (chunks) ...
[16:59:29.416] Chunk #1 of 1 ...
[16:59:29.416]  - seeds: <none>
[16:59:29.416]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.416] getGlobalsAndPackages() ...
[16:59:29.416] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.416] Resolving globals: FALSE
[16:59:29.416] Tweak future expression to call with '...' arguments ...
[16:59:29.416] {
[16:59:29.416]     do.call(function(...) {
[16:59:29.416]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.416]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.416]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.416]             on.exit(options(oopts), add = TRUE)
[16:59:29.416]         }
[16:59:29.416]         {
[16:59:29.416]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.416]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.416]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.416]             })
[16:59:29.416]         }
[16:59:29.416]     }, args = future.call.arguments)
[16:59:29.416] }
[16:59:29.417] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.417] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.417] 
[16:59:29.417] getGlobalsAndPackages() ... DONE
[16:59:29.417] run() for ‘Future’ ...
[16:59:29.418] - state: ‘created’
[16:59:29.418] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.418] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.418]   - Field: ‘label’
[16:59:29.418]   - Field: ‘local’
[16:59:29.418]   - Field: ‘owner’
[16:59:29.419]   - Field: ‘envir’
[16:59:29.419]   - Field: ‘packages’
[16:59:29.419]   - Field: ‘gc’
[16:59:29.419]   - Field: ‘conditions’
[16:59:29.419]   - Field: ‘expr’
[16:59:29.419]   - Field: ‘uuid’
[16:59:29.419]   - Field: ‘seed’
[16:59:29.419]   - Field: ‘version’
[16:59:29.419]   - Field: ‘result’
[16:59:29.419]   - Field: ‘asynchronous’
[16:59:29.420]   - Field: ‘calls’
[16:59:29.420]   - Field: ‘globals’
[16:59:29.420]   - Field: ‘stdout’
[16:59:29.420]   - Field: ‘earlySignal’
[16:59:29.420]   - Field: ‘lazy’
[16:59:29.420]   - Field: ‘state’
[16:59:29.420] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.420] - Launch lazy future ...
[16:59:29.420] Packages needed by the future expression (n = 0): <none>
[16:59:29.420] Packages needed by future strategies (n = 0): <none>
[16:59:29.421] {
[16:59:29.421]     {
[16:59:29.421]         {
[16:59:29.421]             ...future.startTime <- base::Sys.time()
[16:59:29.421]             {
[16:59:29.421]                 {
[16:59:29.421]                   {
[16:59:29.421]                     base::local({
[16:59:29.421]                       has_future <- base::requireNamespace("future", 
[16:59:29.421]                         quietly = TRUE)
[16:59:29.421]                       if (has_future) {
[16:59:29.421]                         ns <- base::getNamespace("future")
[16:59:29.421]                         version <- ns[[".package"]][["version"]]
[16:59:29.421]                         if (is.null(version)) 
[16:59:29.421]                           version <- utils::packageVersion("future")
[16:59:29.421]                       }
[16:59:29.421]                       else {
[16:59:29.421]                         version <- NULL
[16:59:29.421]                       }
[16:59:29.421]                       if (!has_future || version < "1.8.0") {
[16:59:29.421]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.421]                           "", base::R.version$version.string), 
[16:59:29.421]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.421]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.421]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.421]                             "release", "version")], collapse = " "), 
[16:59:29.421]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.421]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.421]                           info)
[16:59:29.421]                         info <- base::paste(info, collapse = "; ")
[16:59:29.421]                         if (!has_future) {
[16:59:29.421]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.421]                             info)
[16:59:29.421]                         }
[16:59:29.421]                         else {
[16:59:29.421]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.421]                             info, version)
[16:59:29.421]                         }
[16:59:29.421]                         base::stop(msg)
[16:59:29.421]                       }
[16:59:29.421]                     })
[16:59:29.421]                   }
[16:59:29.421]                   ...future.strategy.old <- future::plan("list")
[16:59:29.421]                   options(future.plan = NULL)
[16:59:29.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.421]                 }
[16:59:29.421]                 ...future.workdir <- getwd()
[16:59:29.421]             }
[16:59:29.421]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.421]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.421]         }
[16:59:29.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.421]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.421]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.421]             base::names(...future.oldOptions))
[16:59:29.421]     }
[16:59:29.421]     if (FALSE) {
[16:59:29.421]     }
[16:59:29.421]     else {
[16:59:29.421]         if (TRUE) {
[16:59:29.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.421]                 open = "w")
[16:59:29.421]         }
[16:59:29.421]         else {
[16:59:29.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.421]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.421]         }
[16:59:29.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.421]             base::sink(type = "output", split = FALSE)
[16:59:29.421]             base::close(...future.stdout)
[16:59:29.421]         }, add = TRUE)
[16:59:29.421]     }
[16:59:29.421]     ...future.frame <- base::sys.nframe()
[16:59:29.421]     ...future.conditions <- base::list()
[16:59:29.421]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.421]     if (FALSE) {
[16:59:29.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.421]     }
[16:59:29.421]     ...future.result <- base::tryCatch({
[16:59:29.421]         base::withCallingHandlers({
[16:59:29.421]             ...future.value <- base::withVisible(base::local({
[16:59:29.421]                 do.call(function(...) {
[16:59:29.421]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.421]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.421]                     ...future.globals.maxSize)) {
[16:59:29.421]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.421]                     on.exit(options(oopts), add = TRUE)
[16:59:29.421]                   }
[16:59:29.421]                   {
[16:59:29.421]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.421]                       FUN = function(jj) {
[16:59:29.421]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.421]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.421]                       })
[16:59:29.421]                   }
[16:59:29.421]                 }, args = future.call.arguments)
[16:59:29.421]             }))
[16:59:29.421]             future::FutureResult(value = ...future.value$value, 
[16:59:29.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.421]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.421]                     ...future.globalenv.names))
[16:59:29.421]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.421]         }, condition = base::local({
[16:59:29.421]             c <- base::c
[16:59:29.421]             inherits <- base::inherits
[16:59:29.421]             invokeRestart <- base::invokeRestart
[16:59:29.421]             length <- base::length
[16:59:29.421]             list <- base::list
[16:59:29.421]             seq.int <- base::seq.int
[16:59:29.421]             signalCondition <- base::signalCondition
[16:59:29.421]             sys.calls <- base::sys.calls
[16:59:29.421]             `[[` <- base::`[[`
[16:59:29.421]             `+` <- base::`+`
[16:59:29.421]             `<<-` <- base::`<<-`
[16:59:29.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.421]                   3L)]
[16:59:29.421]             }
[16:59:29.421]             function(cond) {
[16:59:29.421]                 is_error <- inherits(cond, "error")
[16:59:29.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.421]                   NULL)
[16:59:29.421]                 if (is_error) {
[16:59:29.421]                   sessionInformation <- function() {
[16:59:29.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.421]                       search = base::search(), system = base::Sys.info())
[16:59:29.421]                   }
[16:59:29.421]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.421]                     cond$call), session = sessionInformation(), 
[16:59:29.421]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.421]                   signalCondition(cond)
[16:59:29.421]                 }
[16:59:29.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.421]                 "immediateCondition"))) {
[16:59:29.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.421]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.421]                   if (TRUE && !signal) {
[16:59:29.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.421]                     {
[16:59:29.421]                       inherits <- base::inherits
[16:59:29.421]                       invokeRestart <- base::invokeRestart
[16:59:29.421]                       is.null <- base::is.null
[16:59:29.421]                       muffled <- FALSE
[16:59:29.421]                       if (inherits(cond, "message")) {
[16:59:29.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.421]                         if (muffled) 
[16:59:29.421]                           invokeRestart("muffleMessage")
[16:59:29.421]                       }
[16:59:29.421]                       else if (inherits(cond, "warning")) {
[16:59:29.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.421]                         if (muffled) 
[16:59:29.421]                           invokeRestart("muffleWarning")
[16:59:29.421]                       }
[16:59:29.421]                       else if (inherits(cond, "condition")) {
[16:59:29.421]                         if (!is.null(pattern)) {
[16:59:29.421]                           computeRestarts <- base::computeRestarts
[16:59:29.421]                           grepl <- base::grepl
[16:59:29.421]                           restarts <- computeRestarts(cond)
[16:59:29.421]                           for (restart in restarts) {
[16:59:29.421]                             name <- restart$name
[16:59:29.421]                             if (is.null(name)) 
[16:59:29.421]                               next
[16:59:29.421]                             if (!grepl(pattern, name)) 
[16:59:29.421]                               next
[16:59:29.421]                             invokeRestart(restart)
[16:59:29.421]                             muffled <- TRUE
[16:59:29.421]                             break
[16:59:29.421]                           }
[16:59:29.421]                         }
[16:59:29.421]                       }
[16:59:29.421]                       invisible(muffled)
[16:59:29.421]                     }
[16:59:29.421]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.421]                   }
[16:59:29.421]                 }
[16:59:29.421]                 else {
[16:59:29.421]                   if (TRUE) {
[16:59:29.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.421]                     {
[16:59:29.421]                       inherits <- base::inherits
[16:59:29.421]                       invokeRestart <- base::invokeRestart
[16:59:29.421]                       is.null <- base::is.null
[16:59:29.421]                       muffled <- FALSE
[16:59:29.421]                       if (inherits(cond, "message")) {
[16:59:29.421]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.421]                         if (muffled) 
[16:59:29.421]                           invokeRestart("muffleMessage")
[16:59:29.421]                       }
[16:59:29.421]                       else if (inherits(cond, "warning")) {
[16:59:29.421]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.421]                         if (muffled) 
[16:59:29.421]                           invokeRestart("muffleWarning")
[16:59:29.421]                       }
[16:59:29.421]                       else if (inherits(cond, "condition")) {
[16:59:29.421]                         if (!is.null(pattern)) {
[16:59:29.421]                           computeRestarts <- base::computeRestarts
[16:59:29.421]                           grepl <- base::grepl
[16:59:29.421]                           restarts <- computeRestarts(cond)
[16:59:29.421]                           for (restart in restarts) {
[16:59:29.421]                             name <- restart$name
[16:59:29.421]                             if (is.null(name)) 
[16:59:29.421]                               next
[16:59:29.421]                             if (!grepl(pattern, name)) 
[16:59:29.421]                               next
[16:59:29.421]                             invokeRestart(restart)
[16:59:29.421]                             muffled <- TRUE
[16:59:29.421]                             break
[16:59:29.421]                           }
[16:59:29.421]                         }
[16:59:29.421]                       }
[16:59:29.421]                       invisible(muffled)
[16:59:29.421]                     }
[16:59:29.421]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.421]                   }
[16:59:29.421]                 }
[16:59:29.421]             }
[16:59:29.421]         }))
[16:59:29.421]     }, error = function(ex) {
[16:59:29.421]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.421]                 ...future.rng), started = ...future.startTime, 
[16:59:29.421]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.421]             version = "1.8"), class = "FutureResult")
[16:59:29.421]     }, finally = {
[16:59:29.421]         if (!identical(...future.workdir, getwd())) 
[16:59:29.421]             setwd(...future.workdir)
[16:59:29.421]         {
[16:59:29.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.421]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.421]             }
[16:59:29.421]             base::options(...future.oldOptions)
[16:59:29.421]             if (.Platform$OS.type == "windows") {
[16:59:29.421]                 old_names <- names(...future.oldEnvVars)
[16:59:29.421]                 envs <- base::Sys.getenv()
[16:59:29.421]                 names <- names(envs)
[16:59:29.421]                 common <- intersect(names, old_names)
[16:59:29.421]                 added <- setdiff(names, old_names)
[16:59:29.421]                 removed <- setdiff(old_names, names)
[16:59:29.421]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.421]                   envs[common]]
[16:59:29.421]                 NAMES <- toupper(changed)
[16:59:29.421]                 args <- list()
[16:59:29.421]                 for (kk in seq_along(NAMES)) {
[16:59:29.421]                   name <- changed[[kk]]
[16:59:29.421]                   NAME <- NAMES[[kk]]
[16:59:29.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.421]                     next
[16:59:29.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.421]                 }
[16:59:29.421]                 NAMES <- toupper(added)
[16:59:29.421]                 for (kk in seq_along(NAMES)) {
[16:59:29.421]                   name <- added[[kk]]
[16:59:29.421]                   NAME <- NAMES[[kk]]
[16:59:29.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.421]                     next
[16:59:29.421]                   args[[name]] <- ""
[16:59:29.421]                 }
[16:59:29.421]                 NAMES <- toupper(removed)
[16:59:29.421]                 for (kk in seq_along(NAMES)) {
[16:59:29.421]                   name <- removed[[kk]]
[16:59:29.421]                   NAME <- NAMES[[kk]]
[16:59:29.421]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.421]                     next
[16:59:29.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.421]                 }
[16:59:29.421]                 if (length(args) > 0) 
[16:59:29.421]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.421]             }
[16:59:29.421]             else {
[16:59:29.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.421]             }
[16:59:29.421]             {
[16:59:29.421]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.421]                   0L) {
[16:59:29.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.421]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.421]                   base::options(opts)
[16:59:29.421]                 }
[16:59:29.421]                 {
[16:59:29.421]                   {
[16:59:29.421]                     NULL
[16:59:29.421]                     RNGkind("Mersenne-Twister")
[16:59:29.421]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.421]                       inherits = FALSE)
[16:59:29.421]                   }
[16:59:29.421]                   options(future.plan = NULL)
[16:59:29.421]                   if (is.na(NA_character_)) 
[16:59:29.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.421]                     .init = FALSE)
[16:59:29.421]                 }
[16:59:29.421]             }
[16:59:29.421]         }
[16:59:29.421]     })
[16:59:29.421]     if (TRUE) {
[16:59:29.421]         base::sink(type = "output", split = FALSE)
[16:59:29.421]         if (TRUE) {
[16:59:29.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.421]         }
[16:59:29.421]         else {
[16:59:29.421]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.421]         }
[16:59:29.421]         base::close(...future.stdout)
[16:59:29.421]         ...future.stdout <- NULL
[16:59:29.421]     }
[16:59:29.421]     ...future.result$conditions <- ...future.conditions
[16:59:29.421]     ...future.result$finished <- base::Sys.time()
[16:59:29.421]     ...future.result
[16:59:29.421] }
[16:59:29.423] assign_globals() ...
[16:59:29.423] List of 5
[16:59:29.423]  $ future.call.arguments    : list()
[16:59:29.423]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.423]  $ ...future.FUN            :function (x)  
[16:59:29.423]  $ ...future.elements_ii    :List of 2
[16:59:29.423]   ..$ : int 1
[16:59:29.423]   ..$ : int 2
[16:59:29.423]  $ ...future.seeds_ii       : NULL
[16:59:29.423]  $ ...future.globals.maxSize: num Inf
[16:59:29.423]  - attr(*, "resolved")= logi FALSE
[16:59:29.423]  - attr(*, "total_size")= num NA
[16:59:29.423]  - attr(*, "where")=List of 5
[16:59:29.423]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.423]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.423]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.423]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.423]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.423]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.423]  - attr(*, "already-done")= logi TRUE
[16:59:29.428] - copied ‘future.call.arguments’ to environment
[16:59:29.458] - copied ‘...future.FUN’ to environment
[16:59:29.458] - copied ‘...future.elements_ii’ to environment
[16:59:29.458] - copied ‘...future.seeds_ii’ to environment
[16:59:29.458] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.458] assign_globals() ... done
[16:59:29.459] plan(): Setting new future strategy stack:
[16:59:29.459] List of future strategies:
[16:59:29.459] 1. sequential:
[16:59:29.459]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.459]    - tweaked: FALSE
[16:59:29.459]    - call: NULL
[16:59:29.460] plan(): nbrOfWorkers() = 1
[16:59:29.461] plan(): Setting new future strategy stack:
[16:59:29.461] List of future strategies:
[16:59:29.461] 1. sequential:
[16:59:29.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.461]    - tweaked: FALSE
[16:59:29.461]    - call: plan(strategy)
[16:59:29.461] plan(): nbrOfWorkers() = 1
[16:59:29.461] SequentialFuture started (and completed)
[16:59:29.461] - Launch lazy future ... done
[16:59:29.461] run() for ‘SequentialFuture’ ... done
[16:59:29.462] Created future:
[16:59:29.462] SequentialFuture:
[16:59:29.462] Label: ‘future_apply-1’
[16:59:29.462] Expression:
[16:59:29.462] {
[16:59:29.462]     do.call(function(...) {
[16:59:29.462]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.462]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.462]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.462]             on.exit(options(oopts), add = TRUE)
[16:59:29.462]         }
[16:59:29.462]         {
[16:59:29.462]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.462]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.462]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.462]             })
[16:59:29.462]         }
[16:59:29.462]     }, args = future.call.arguments)
[16:59:29.462] }
[16:59:29.462] Lazy evaluation: FALSE
[16:59:29.462] Asynchronous evaluation: FALSE
[16:59:29.462] Local evaluation: TRUE
[16:59:29.462] Environment: R_GlobalEnv
[16:59:29.462] Capture standard output: TRUE
[16:59:29.462] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.462] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.462] Packages: <none>
[16:59:29.462] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.462] Resolved: TRUE
[16:59:29.462] Value: 112 bytes of class ‘list’
[16:59:29.462] Early signaling: FALSE
[16:59:29.462] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.462] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.463] Chunk #1 of 1 ... DONE
[16:59:29.463] Launching 1 futures (chunks) ... DONE
[16:59:29.463] Resolving 1 futures (chunks) ...
[16:59:29.463] resolve() on list ...
[16:59:29.463]  recursive: 0
[16:59:29.463]  length: 1
[16:59:29.463] 
[16:59:29.463] resolved() for ‘SequentialFuture’ ...
[16:59:29.463] - state: ‘finished’
[16:59:29.464] - run: TRUE
[16:59:29.464] - result: ‘FutureResult’
[16:59:29.464] resolved() for ‘SequentialFuture’ ... done
[16:59:29.464] Future #1
[16:59:29.464] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.464] - nx: 1
[16:59:29.464] - relay: TRUE
[16:59:29.464] - stdout: TRUE
[16:59:29.464] - signal: TRUE
[16:59:29.464] - resignal: FALSE
[16:59:29.465] - force: TRUE
[16:59:29.465] - relayed: [n=1] FALSE
[16:59:29.465] - queued futures: [n=1] FALSE
[16:59:29.465]  - until=1
[16:59:29.465]  - relaying element #1
[16:59:29.465] - relayed: [n=1] TRUE
[16:59:29.465] - queued futures: [n=1] TRUE
[16:59:29.465] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.465]  length: 0 (resolved future 1)
[16:59:29.465] Relaying remaining futures
[16:59:29.466] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.466] - nx: 1
[16:59:29.466] - relay: TRUE
[16:59:29.466] - stdout: TRUE
[16:59:29.466] - signal: TRUE
[16:59:29.466] - resignal: FALSE
[16:59:29.466] - force: TRUE
[16:59:29.466] - relayed: [n=1] TRUE
[16:59:29.466] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.466] - relayed: [n=1] TRUE
[16:59:29.466] - queued futures: [n=1] TRUE
[16:59:29.467] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.467] resolve() on list ... DONE
[16:59:29.467]  - Number of value chunks collected: 1
[16:59:29.467] Resolving 1 futures (chunks) ... DONE
[16:59:29.467] Reducing values from 1 chunks ...
[16:59:29.467]  - Number of values collected after concatenation: 2
[16:59:29.467]  - Number of values expected: 2
[16:59:29.467] Reducing values from 1 chunks ... DONE
[16:59:29.467] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:59:29.468] getGlobalsAndPackagesXApply() ...
[16:59:29.468]  - future.globals: TRUE
[16:59:29.468] getGlobalsAndPackages() ...
[16:59:29.468] Searching for globals...
[16:59:29.469] - globals found: [1] ‘FUN’
[16:59:29.469] Searching for globals ... DONE
[16:59:29.469] Resolving globals: FALSE
[16:59:29.469] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:29.470] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:29.470] - globals: [1] ‘FUN’
[16:59:29.470] 
[16:59:29.470] getGlobalsAndPackages() ... DONE
[16:59:29.470]  - globals found/used: [n=1] ‘FUN’
[16:59:29.470]  - needed namespaces: [n=0] 
[16:59:29.470] Finding globals ... DONE
[16:59:29.470]  - use_args: TRUE
[16:59:29.471]  - Getting '...' globals ...
[16:59:29.471] resolve() on list ...
[16:59:29.471]  recursive: 0
[16:59:29.471]  length: 1
[16:59:29.471]  elements: ‘...’
[16:59:29.471]  length: 0 (resolved future 1)
[16:59:29.471] resolve() on list ... DONE
[16:59:29.471]    - '...' content: [n=0] 
[16:59:29.472] List of 1
[16:59:29.472]  $ ...: list()
[16:59:29.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.472]  - attr(*, "where")=List of 1
[16:59:29.472]   ..$ ...:<environment: 0x55f312e00e48> 
[16:59:29.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.472]  - attr(*, "resolved")= logi TRUE
[16:59:29.472]  - attr(*, "total_size")= num NA
[16:59:29.474]  - Getting '...' globals ... DONE
[16:59:29.474] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.474] List of 2
[16:59:29.474]  $ ...future.FUN:function (x)  
[16:59:29.474]  $ ...          : list()
[16:59:29.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.474]  - attr(*, "where")=List of 2
[16:59:29.474]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.474]   ..$ ...          :<environment: 0x55f312e00e48> 
[16:59:29.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.474]  - attr(*, "resolved")= logi FALSE
[16:59:29.474]  - attr(*, "total_size")= num 848
[16:59:29.477] Packages to be attached in all futures: [n=0] 
[16:59:29.477] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.477] future_lapply() ...
[16:59:29.478] Number of chunks: 1
[16:59:29.478] getGlobalsAndPackagesXApply() ...
[16:59:29.478]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.478]  - use_args: TRUE
[16:59:29.479] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.479] List of 2
[16:59:29.479]  $ ...          : list()
[16:59:29.479]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.479]  $ ...future.FUN:function (x)  
[16:59:29.479]  - attr(*, "where")=List of 2
[16:59:29.479]   ..$ ...          :<environment: 0x55f312e00e48> 
[16:59:29.479]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.479]  - attr(*, "resolved")= logi FALSE
[16:59:29.479]  - attr(*, "total_size")= num NA
[16:59:29.482] Packages to be attached in all futures: [n=0] 
[16:59:29.482] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.482] Number of futures (= number of chunks): 1
[16:59:29.482] Launching 1 futures (chunks) ...
[16:59:29.483] Chunk #1 of 1 ...
[16:59:29.483]  - seeds: <none>
[16:59:29.483]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.483] getGlobalsAndPackages() ...
[16:59:29.483] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.483] Resolving globals: FALSE
[16:59:29.483] Tweak future expression to call with '...' arguments ...
[16:59:29.483] {
[16:59:29.483]     do.call(function(...) {
[16:59:29.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.483]             on.exit(options(oopts), add = TRUE)
[16:59:29.483]         }
[16:59:29.483]         {
[16:59:29.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.483]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.483]             })
[16:59:29.483]         }
[16:59:29.483]     }, args = future.call.arguments)
[16:59:29.483] }
[16:59:29.484] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.486] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.486] 
[16:59:29.486] getGlobalsAndPackages() ... DONE
[16:59:29.486] run() for ‘Future’ ...
[16:59:29.486] - state: ‘created’
[16:59:29.486] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.487] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.487]   - Field: ‘label’
[16:59:29.487]   - Field: ‘local’
[16:59:29.487]   - Field: ‘owner’
[16:59:29.488]   - Field: ‘envir’
[16:59:29.488]   - Field: ‘packages’
[16:59:29.488]   - Field: ‘gc’
[16:59:29.488]   - Field: ‘conditions’
[16:59:29.488]   - Field: ‘expr’
[16:59:29.488]   - Field: ‘uuid’
[16:59:29.488]   - Field: ‘seed’
[16:59:29.488]   - Field: ‘version’
[16:59:29.488]   - Field: ‘result’
[16:59:29.488]   - Field: ‘asynchronous’
[16:59:29.489]   - Field: ‘calls’
[16:59:29.489]   - Field: ‘globals’
[16:59:29.489]   - Field: ‘stdout’
[16:59:29.489]   - Field: ‘earlySignal’
[16:59:29.489]   - Field: ‘lazy’
[16:59:29.489]   - Field: ‘state’
[16:59:29.489] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.489] - Launch lazy future ...
[16:59:29.489] Packages needed by the future expression (n = 0): <none>
[16:59:29.489] Packages needed by future strategies (n = 0): <none>
[16:59:29.490] {
[16:59:29.490]     {
[16:59:29.490]         {
[16:59:29.490]             ...future.startTime <- base::Sys.time()
[16:59:29.490]             {
[16:59:29.490]                 {
[16:59:29.490]                   {
[16:59:29.490]                     base::local({
[16:59:29.490]                       has_future <- base::requireNamespace("future", 
[16:59:29.490]                         quietly = TRUE)
[16:59:29.490]                       if (has_future) {
[16:59:29.490]                         ns <- base::getNamespace("future")
[16:59:29.490]                         version <- ns[[".package"]][["version"]]
[16:59:29.490]                         if (is.null(version)) 
[16:59:29.490]                           version <- utils::packageVersion("future")
[16:59:29.490]                       }
[16:59:29.490]                       else {
[16:59:29.490]                         version <- NULL
[16:59:29.490]                       }
[16:59:29.490]                       if (!has_future || version < "1.8.0") {
[16:59:29.490]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.490]                           "", base::R.version$version.string), 
[16:59:29.490]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.490]                             "release", "version")], collapse = " "), 
[16:59:29.490]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.490]                           info)
[16:59:29.490]                         info <- base::paste(info, collapse = "; ")
[16:59:29.490]                         if (!has_future) {
[16:59:29.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.490]                             info)
[16:59:29.490]                         }
[16:59:29.490]                         else {
[16:59:29.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.490]                             info, version)
[16:59:29.490]                         }
[16:59:29.490]                         base::stop(msg)
[16:59:29.490]                       }
[16:59:29.490]                     })
[16:59:29.490]                   }
[16:59:29.490]                   ...future.strategy.old <- future::plan("list")
[16:59:29.490]                   options(future.plan = NULL)
[16:59:29.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.490]                 }
[16:59:29.490]                 ...future.workdir <- getwd()
[16:59:29.490]             }
[16:59:29.490]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.490]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.490]         }
[16:59:29.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.490]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.490]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.490]             base::names(...future.oldOptions))
[16:59:29.490]     }
[16:59:29.490]     if (FALSE) {
[16:59:29.490]     }
[16:59:29.490]     else {
[16:59:29.490]         if (TRUE) {
[16:59:29.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.490]                 open = "w")
[16:59:29.490]         }
[16:59:29.490]         else {
[16:59:29.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.490]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.490]         }
[16:59:29.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.490]             base::sink(type = "output", split = FALSE)
[16:59:29.490]             base::close(...future.stdout)
[16:59:29.490]         }, add = TRUE)
[16:59:29.490]     }
[16:59:29.490]     ...future.frame <- base::sys.nframe()
[16:59:29.490]     ...future.conditions <- base::list()
[16:59:29.490]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.490]     if (FALSE) {
[16:59:29.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.490]     }
[16:59:29.490]     ...future.result <- base::tryCatch({
[16:59:29.490]         base::withCallingHandlers({
[16:59:29.490]             ...future.value <- base::withVisible(base::local({
[16:59:29.490]                 do.call(function(...) {
[16:59:29.490]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.490]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.490]                     ...future.globals.maxSize)) {
[16:59:29.490]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.490]                     on.exit(options(oopts), add = TRUE)
[16:59:29.490]                   }
[16:59:29.490]                   {
[16:59:29.490]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.490]                       FUN = function(jj) {
[16:59:29.490]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.490]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.490]                       })
[16:59:29.490]                   }
[16:59:29.490]                 }, args = future.call.arguments)
[16:59:29.490]             }))
[16:59:29.490]             future::FutureResult(value = ...future.value$value, 
[16:59:29.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.490]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.490]                     ...future.globalenv.names))
[16:59:29.490]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.490]         }, condition = base::local({
[16:59:29.490]             c <- base::c
[16:59:29.490]             inherits <- base::inherits
[16:59:29.490]             invokeRestart <- base::invokeRestart
[16:59:29.490]             length <- base::length
[16:59:29.490]             list <- base::list
[16:59:29.490]             seq.int <- base::seq.int
[16:59:29.490]             signalCondition <- base::signalCondition
[16:59:29.490]             sys.calls <- base::sys.calls
[16:59:29.490]             `[[` <- base::`[[`
[16:59:29.490]             `+` <- base::`+`
[16:59:29.490]             `<<-` <- base::`<<-`
[16:59:29.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.490]                   3L)]
[16:59:29.490]             }
[16:59:29.490]             function(cond) {
[16:59:29.490]                 is_error <- inherits(cond, "error")
[16:59:29.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.490]                   NULL)
[16:59:29.490]                 if (is_error) {
[16:59:29.490]                   sessionInformation <- function() {
[16:59:29.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.490]                       search = base::search(), system = base::Sys.info())
[16:59:29.490]                   }
[16:59:29.490]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.490]                     cond$call), session = sessionInformation(), 
[16:59:29.490]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.490]                   signalCondition(cond)
[16:59:29.490]                 }
[16:59:29.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.490]                 "immediateCondition"))) {
[16:59:29.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.490]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.490]                   if (TRUE && !signal) {
[16:59:29.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.490]                     {
[16:59:29.490]                       inherits <- base::inherits
[16:59:29.490]                       invokeRestart <- base::invokeRestart
[16:59:29.490]                       is.null <- base::is.null
[16:59:29.490]                       muffled <- FALSE
[16:59:29.490]                       if (inherits(cond, "message")) {
[16:59:29.490]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.490]                         if (muffled) 
[16:59:29.490]                           invokeRestart("muffleMessage")
[16:59:29.490]                       }
[16:59:29.490]                       else if (inherits(cond, "warning")) {
[16:59:29.490]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.490]                         if (muffled) 
[16:59:29.490]                           invokeRestart("muffleWarning")
[16:59:29.490]                       }
[16:59:29.490]                       else if (inherits(cond, "condition")) {
[16:59:29.490]                         if (!is.null(pattern)) {
[16:59:29.490]                           computeRestarts <- base::computeRestarts
[16:59:29.490]                           grepl <- base::grepl
[16:59:29.490]                           restarts <- computeRestarts(cond)
[16:59:29.490]                           for (restart in restarts) {
[16:59:29.490]                             name <- restart$name
[16:59:29.490]                             if (is.null(name)) 
[16:59:29.490]                               next
[16:59:29.490]                             if (!grepl(pattern, name)) 
[16:59:29.490]                               next
[16:59:29.490]                             invokeRestart(restart)
[16:59:29.490]                             muffled <- TRUE
[16:59:29.490]                             break
[16:59:29.490]                           }
[16:59:29.490]                         }
[16:59:29.490]                       }
[16:59:29.490]                       invisible(muffled)
[16:59:29.490]                     }
[16:59:29.490]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.490]                   }
[16:59:29.490]                 }
[16:59:29.490]                 else {
[16:59:29.490]                   if (TRUE) {
[16:59:29.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.490]                     {
[16:59:29.490]                       inherits <- base::inherits
[16:59:29.490]                       invokeRestart <- base::invokeRestart
[16:59:29.490]                       is.null <- base::is.null
[16:59:29.490]                       muffled <- FALSE
[16:59:29.490]                       if (inherits(cond, "message")) {
[16:59:29.490]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.490]                         if (muffled) 
[16:59:29.490]                           invokeRestart("muffleMessage")
[16:59:29.490]                       }
[16:59:29.490]                       else if (inherits(cond, "warning")) {
[16:59:29.490]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.490]                         if (muffled) 
[16:59:29.490]                           invokeRestart("muffleWarning")
[16:59:29.490]                       }
[16:59:29.490]                       else if (inherits(cond, "condition")) {
[16:59:29.490]                         if (!is.null(pattern)) {
[16:59:29.490]                           computeRestarts <- base::computeRestarts
[16:59:29.490]                           grepl <- base::grepl
[16:59:29.490]                           restarts <- computeRestarts(cond)
[16:59:29.490]                           for (restart in restarts) {
[16:59:29.490]                             name <- restart$name
[16:59:29.490]                             if (is.null(name)) 
[16:59:29.490]                               next
[16:59:29.490]                             if (!grepl(pattern, name)) 
[16:59:29.490]                               next
[16:59:29.490]                             invokeRestart(restart)
[16:59:29.490]                             muffled <- TRUE
[16:59:29.490]                             break
[16:59:29.490]                           }
[16:59:29.490]                         }
[16:59:29.490]                       }
[16:59:29.490]                       invisible(muffled)
[16:59:29.490]                     }
[16:59:29.490]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.490]                   }
[16:59:29.490]                 }
[16:59:29.490]             }
[16:59:29.490]         }))
[16:59:29.490]     }, error = function(ex) {
[16:59:29.490]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.490]                 ...future.rng), started = ...future.startTime, 
[16:59:29.490]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.490]             version = "1.8"), class = "FutureResult")
[16:59:29.490]     }, finally = {
[16:59:29.490]         if (!identical(...future.workdir, getwd())) 
[16:59:29.490]             setwd(...future.workdir)
[16:59:29.490]         {
[16:59:29.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.490]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.490]             }
[16:59:29.490]             base::options(...future.oldOptions)
[16:59:29.490]             if (.Platform$OS.type == "windows") {
[16:59:29.490]                 old_names <- names(...future.oldEnvVars)
[16:59:29.490]                 envs <- base::Sys.getenv()
[16:59:29.490]                 names <- names(envs)
[16:59:29.490]                 common <- intersect(names, old_names)
[16:59:29.490]                 added <- setdiff(names, old_names)
[16:59:29.490]                 removed <- setdiff(old_names, names)
[16:59:29.490]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.490]                   envs[common]]
[16:59:29.490]                 NAMES <- toupper(changed)
[16:59:29.490]                 args <- list()
[16:59:29.490]                 for (kk in seq_along(NAMES)) {
[16:59:29.490]                   name <- changed[[kk]]
[16:59:29.490]                   NAME <- NAMES[[kk]]
[16:59:29.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.490]                     next
[16:59:29.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.490]                 }
[16:59:29.490]                 NAMES <- toupper(added)
[16:59:29.490]                 for (kk in seq_along(NAMES)) {
[16:59:29.490]                   name <- added[[kk]]
[16:59:29.490]                   NAME <- NAMES[[kk]]
[16:59:29.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.490]                     next
[16:59:29.490]                   args[[name]] <- ""
[16:59:29.490]                 }
[16:59:29.490]                 NAMES <- toupper(removed)
[16:59:29.490]                 for (kk in seq_along(NAMES)) {
[16:59:29.490]                   name <- removed[[kk]]
[16:59:29.490]                   NAME <- NAMES[[kk]]
[16:59:29.490]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.490]                     next
[16:59:29.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.490]                 }
[16:59:29.490]                 if (length(args) > 0) 
[16:59:29.490]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.490]             }
[16:59:29.490]             else {
[16:59:29.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.490]             }
[16:59:29.490]             {
[16:59:29.490]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.490]                   0L) {
[16:59:29.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.490]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.490]                   base::options(opts)
[16:59:29.490]                 }
[16:59:29.490]                 {
[16:59:29.490]                   {
[16:59:29.490]                     NULL
[16:59:29.490]                     RNGkind("Mersenne-Twister")
[16:59:29.490]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.490]                       inherits = FALSE)
[16:59:29.490]                   }
[16:59:29.490]                   options(future.plan = NULL)
[16:59:29.490]                   if (is.na(NA_character_)) 
[16:59:29.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.490]                     .init = FALSE)
[16:59:29.490]                 }
[16:59:29.490]             }
[16:59:29.490]         }
[16:59:29.490]     })
[16:59:29.490]     if (TRUE) {
[16:59:29.490]         base::sink(type = "output", split = FALSE)
[16:59:29.490]         if (TRUE) {
[16:59:29.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.490]         }
[16:59:29.490]         else {
[16:59:29.490]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.490]         }
[16:59:29.490]         base::close(...future.stdout)
[16:59:29.490]         ...future.stdout <- NULL
[16:59:29.490]     }
[16:59:29.490]     ...future.result$conditions <- ...future.conditions
[16:59:29.490]     ...future.result$finished <- base::Sys.time()
[16:59:29.490]     ...future.result
[16:59:29.490] }
[16:59:29.492] assign_globals() ...
[16:59:29.492] List of 5
[16:59:29.492]  $ future.call.arguments    : list()
[16:59:29.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.492]  $ ...future.FUN            :function (x)  
[16:59:29.492]  $ ...future.elements_ii    :List of 2
[16:59:29.492]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:59:29.492]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:59:29.492]  $ ...future.seeds_ii       : NULL
[16:59:29.492]  $ ...future.globals.maxSize: num Inf
[16:59:29.492]  - attr(*, "resolved")= logi FALSE
[16:59:29.492]  - attr(*, "total_size")= num NA
[16:59:29.492]  - attr(*, "where")=List of 5
[16:59:29.492]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.492]  - attr(*, "already-done")= logi TRUE
[16:59:29.497] - copied ‘future.call.arguments’ to environment
[16:59:29.497] - copied ‘...future.FUN’ to environment
[16:59:29.497] - copied ‘...future.elements_ii’ to environment
[16:59:29.497] - copied ‘...future.seeds_ii’ to environment
[16:59:29.498] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.498] assign_globals() ... done
[16:59:29.498] plan(): Setting new future strategy stack:
[16:59:29.498] List of future strategies:
[16:59:29.498] 1. sequential:
[16:59:29.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.498]    - tweaked: FALSE
[16:59:29.498]    - call: NULL
[16:59:29.498] plan(): nbrOfWorkers() = 1
[16:59:29.499] plan(): Setting new future strategy stack:
[16:59:29.499] List of future strategies:
[16:59:29.499] 1. sequential:
[16:59:29.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.499]    - tweaked: FALSE
[16:59:29.499]    - call: plan(strategy)
[16:59:29.500] plan(): nbrOfWorkers() = 1
[16:59:29.500] SequentialFuture started (and completed)
[16:59:29.500] - Launch lazy future ... done
[16:59:29.500] run() for ‘SequentialFuture’ ... done
[16:59:29.500] Created future:
[16:59:29.500] SequentialFuture:
[16:59:29.500] Label: ‘future_apply-1’
[16:59:29.500] Expression:
[16:59:29.500] {
[16:59:29.500]     do.call(function(...) {
[16:59:29.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.500]             on.exit(options(oopts), add = TRUE)
[16:59:29.500]         }
[16:59:29.500]         {
[16:59:29.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.500]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.500]             })
[16:59:29.500]         }
[16:59:29.500]     }, args = future.call.arguments)
[16:59:29.500] }
[16:59:29.500] Lazy evaluation: FALSE
[16:59:29.500] Asynchronous evaluation: FALSE
[16:59:29.500] Local evaluation: TRUE
[16:59:29.500] Environment: R_GlobalEnv
[16:59:29.500] Capture standard output: TRUE
[16:59:29.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.500] Globals: 5 objects totaling 1.37 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 496 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.500] Packages: <none>
[16:59:29.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.500] Resolved: TRUE
[16:59:29.500] Value: 496 bytes of class ‘list’
[16:59:29.500] Early signaling: FALSE
[16:59:29.500] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.500] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.501] Chunk #1 of 1 ... DONE
[16:59:29.502] Launching 1 futures (chunks) ... DONE
[16:59:29.502] Resolving 1 futures (chunks) ...
[16:59:29.502] resolve() on list ...
[16:59:29.502]  recursive: 0
[16:59:29.502]  length: 1
[16:59:29.502] 
[16:59:29.502] resolved() for ‘SequentialFuture’ ...
[16:59:29.502] - state: ‘finished’
[16:59:29.502] - run: TRUE
[16:59:29.502] - result: ‘FutureResult’
[16:59:29.503] resolved() for ‘SequentialFuture’ ... done
[16:59:29.503] Future #1
[16:59:29.503] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.503] - nx: 1
[16:59:29.503] - relay: TRUE
[16:59:29.503] - stdout: TRUE
[16:59:29.503] - signal: TRUE
[16:59:29.503] - resignal: FALSE
[16:59:29.503] - force: TRUE
[16:59:29.503] - relayed: [n=1] FALSE
[16:59:29.504] - queued futures: [n=1] FALSE
[16:59:29.504]  - until=1
[16:59:29.504]  - relaying element #1
[16:59:29.504] - relayed: [n=1] TRUE
[16:59:29.504] - queued futures: [n=1] TRUE
[16:59:29.504] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.504]  length: 0 (resolved future 1)
[16:59:29.504] Relaying remaining futures
[16:59:29.504] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.504] - nx: 1
[16:59:29.505] - relay: TRUE
[16:59:29.505] - stdout: TRUE
[16:59:29.505] - signal: TRUE
[16:59:29.505] - resignal: FALSE
[16:59:29.505] - force: TRUE
[16:59:29.505] - relayed: [n=1] TRUE
[16:59:29.505] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.505] - relayed: [n=1] TRUE
[16:59:29.505] - queued futures: [n=1] TRUE
[16:59:29.505] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.505] resolve() on list ... DONE
[16:59:29.506]  - Number of value chunks collected: 1
[16:59:29.506] Resolving 1 futures (chunks) ... DONE
[16:59:29.506] Reducing values from 1 chunks ...
[16:59:29.506]  - Number of values collected after concatenation: 2
[16:59:29.506]  - Number of values expected: 2
[16:59:29.506] Reducing values from 1 chunks ... DONE
[16:59:29.506] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:59:29.506] getGlobalsAndPackagesXApply() ...
[16:59:29.507]  - future.globals: TRUE
[16:59:29.507] getGlobalsAndPackages() ...
[16:59:29.507] Searching for globals...
[16:59:29.509] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:59:29.509] Searching for globals ... DONE
[16:59:29.510] Resolving globals: FALSE
[16:59:29.510] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:59:29.510] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:59:29.511] - globals: [1] ‘FUN’
[16:59:29.511] 
[16:59:29.511] getGlobalsAndPackages() ... DONE
[16:59:29.511]  - globals found/used: [n=1] ‘FUN’
[16:59:29.511]  - needed namespaces: [n=0] 
[16:59:29.511] Finding globals ... DONE
[16:59:29.511]  - use_args: TRUE
[16:59:29.511]  - Getting '...' globals ...
[16:59:29.513] resolve() on list ...
[16:59:29.513]  recursive: 0
[16:59:29.514]  length: 1
[16:59:29.514]  elements: ‘...’
[16:59:29.514]  length: 0 (resolved future 1)
[16:59:29.514] resolve() on list ... DONE
[16:59:29.514]    - '...' content: [n=0] 
[16:59:29.514] List of 1
[16:59:29.514]  $ ...: list()
[16:59:29.514]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.514]  - attr(*, "where")=List of 1
[16:59:29.514]   ..$ ...:<environment: 0x55f313e30d40> 
[16:59:29.514]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.514]  - attr(*, "resolved")= logi TRUE
[16:59:29.514]  - attr(*, "total_size")= num NA
[16:59:29.517]  - Getting '...' globals ... DONE
[16:59:29.517] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.517] List of 2
[16:59:29.517]  $ ...future.FUN:function (x)  
[16:59:29.517]  $ ...          : list()
[16:59:29.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.517]  - attr(*, "where")=List of 2
[16:59:29.517]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.517]   ..$ ...          :<environment: 0x55f313e30d40> 
[16:59:29.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.517]  - attr(*, "resolved")= logi FALSE
[16:59:29.517]  - attr(*, "total_size")= num 9888
[16:59:29.520] Packages to be attached in all futures: [n=0] 
[16:59:29.520] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.520] future_lapply() ...
[16:59:29.522] Number of chunks: 1
[16:59:29.522] getGlobalsAndPackagesXApply() ...
[16:59:29.522]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.522]  - use_args: TRUE
[16:59:29.522] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.522] List of 2
[16:59:29.522]  $ ...          : list()
[16:59:29.522]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.522]  $ ...future.FUN:function (x)  
[16:59:29.522]  - attr(*, "where")=List of 2
[16:59:29.522]   ..$ ...          :<environment: 0x55f313e30d40> 
[16:59:29.522]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:59:29.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.522]  - attr(*, "resolved")= logi FALSE
[16:59:29.522]  - attr(*, "total_size")= num NA
[16:59:29.525] Packages to be attached in all futures: [n=0] 
[16:59:29.525] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.525] Number of futures (= number of chunks): 1
[16:59:29.526] Launching 1 futures (chunks) ...
[16:59:29.526] Chunk #1 of 1 ...
[16:59:29.526]  - seeds: <none>
[16:59:29.526]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.526] getGlobalsAndPackages() ...
[16:59:29.526] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.526] Resolving globals: FALSE
[16:59:29.526] Tweak future expression to call with '...' arguments ...
[16:59:29.526] {
[16:59:29.526]     do.call(function(...) {
[16:59:29.526]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.526]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.526]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.526]             on.exit(options(oopts), add = TRUE)
[16:59:29.526]         }
[16:59:29.526]         {
[16:59:29.526]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.526]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.526]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.526]             })
[16:59:29.526]         }
[16:59:29.526]     }, args = future.call.arguments)
[16:59:29.526] }
[16:59:29.527] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.527] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.527] 
[16:59:29.527] getGlobalsAndPackages() ... DONE
[16:59:29.528] run() for ‘Future’ ...
[16:59:29.528] - state: ‘created’
[16:59:29.528] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.528] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.528] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.528]   - Field: ‘label’
[16:59:29.528]   - Field: ‘local’
[16:59:29.529]   - Field: ‘owner’
[16:59:29.529]   - Field: ‘envir’
[16:59:29.529]   - Field: ‘packages’
[16:59:29.529]   - Field: ‘gc’
[16:59:29.529]   - Field: ‘conditions’
[16:59:29.529]   - Field: ‘expr’
[16:59:29.529]   - Field: ‘uuid’
[16:59:29.529]   - Field: ‘seed’
[16:59:29.529]   - Field: ‘version’
[16:59:29.529]   - Field: ‘result’
[16:59:29.529]   - Field: ‘asynchronous’
[16:59:29.530]   - Field: ‘calls’
[16:59:29.530]   - Field: ‘globals’
[16:59:29.530]   - Field: ‘stdout’
[16:59:29.530]   - Field: ‘earlySignal’
[16:59:29.530]   - Field: ‘lazy’
[16:59:29.530]   - Field: ‘state’
[16:59:29.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.530] - Launch lazy future ...
[16:59:29.530] Packages needed by the future expression (n = 0): <none>
[16:59:29.531] Packages needed by future strategies (n = 0): <none>
[16:59:29.531] {
[16:59:29.531]     {
[16:59:29.531]         {
[16:59:29.531]             ...future.startTime <- base::Sys.time()
[16:59:29.531]             {
[16:59:29.531]                 {
[16:59:29.531]                   {
[16:59:29.531]                     base::local({
[16:59:29.531]                       has_future <- base::requireNamespace("future", 
[16:59:29.531]                         quietly = TRUE)
[16:59:29.531]                       if (has_future) {
[16:59:29.531]                         ns <- base::getNamespace("future")
[16:59:29.531]                         version <- ns[[".package"]][["version"]]
[16:59:29.531]                         if (is.null(version)) 
[16:59:29.531]                           version <- utils::packageVersion("future")
[16:59:29.531]                       }
[16:59:29.531]                       else {
[16:59:29.531]                         version <- NULL
[16:59:29.531]                       }
[16:59:29.531]                       if (!has_future || version < "1.8.0") {
[16:59:29.531]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.531]                           "", base::R.version$version.string), 
[16:59:29.531]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.531]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.531]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.531]                             "release", "version")], collapse = " "), 
[16:59:29.531]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.531]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.531]                           info)
[16:59:29.531]                         info <- base::paste(info, collapse = "; ")
[16:59:29.531]                         if (!has_future) {
[16:59:29.531]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.531]                             info)
[16:59:29.531]                         }
[16:59:29.531]                         else {
[16:59:29.531]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.531]                             info, version)
[16:59:29.531]                         }
[16:59:29.531]                         base::stop(msg)
[16:59:29.531]                       }
[16:59:29.531]                     })
[16:59:29.531]                   }
[16:59:29.531]                   ...future.strategy.old <- future::plan("list")
[16:59:29.531]                   options(future.plan = NULL)
[16:59:29.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.531]                 }
[16:59:29.531]                 ...future.workdir <- getwd()
[16:59:29.531]             }
[16:59:29.531]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.531]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.531]         }
[16:59:29.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.531]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.531]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.531]             base::names(...future.oldOptions))
[16:59:29.531]     }
[16:59:29.531]     if (FALSE) {
[16:59:29.531]     }
[16:59:29.531]     else {
[16:59:29.531]         if (TRUE) {
[16:59:29.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.531]                 open = "w")
[16:59:29.531]         }
[16:59:29.531]         else {
[16:59:29.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.531]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.531]         }
[16:59:29.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.531]             base::sink(type = "output", split = FALSE)
[16:59:29.531]             base::close(...future.stdout)
[16:59:29.531]         }, add = TRUE)
[16:59:29.531]     }
[16:59:29.531]     ...future.frame <- base::sys.nframe()
[16:59:29.531]     ...future.conditions <- base::list()
[16:59:29.531]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.531]     if (FALSE) {
[16:59:29.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.531]     }
[16:59:29.531]     ...future.result <- base::tryCatch({
[16:59:29.531]         base::withCallingHandlers({
[16:59:29.531]             ...future.value <- base::withVisible(base::local({
[16:59:29.531]                 do.call(function(...) {
[16:59:29.531]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.531]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.531]                     ...future.globals.maxSize)) {
[16:59:29.531]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.531]                     on.exit(options(oopts), add = TRUE)
[16:59:29.531]                   }
[16:59:29.531]                   {
[16:59:29.531]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.531]                       FUN = function(jj) {
[16:59:29.531]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.531]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.531]                       })
[16:59:29.531]                   }
[16:59:29.531]                 }, args = future.call.arguments)
[16:59:29.531]             }))
[16:59:29.531]             future::FutureResult(value = ...future.value$value, 
[16:59:29.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.531]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.531]                     ...future.globalenv.names))
[16:59:29.531]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.531]         }, condition = base::local({
[16:59:29.531]             c <- base::c
[16:59:29.531]             inherits <- base::inherits
[16:59:29.531]             invokeRestart <- base::invokeRestart
[16:59:29.531]             length <- base::length
[16:59:29.531]             list <- base::list
[16:59:29.531]             seq.int <- base::seq.int
[16:59:29.531]             signalCondition <- base::signalCondition
[16:59:29.531]             sys.calls <- base::sys.calls
[16:59:29.531]             `[[` <- base::`[[`
[16:59:29.531]             `+` <- base::`+`
[16:59:29.531]             `<<-` <- base::`<<-`
[16:59:29.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.531]                   3L)]
[16:59:29.531]             }
[16:59:29.531]             function(cond) {
[16:59:29.531]                 is_error <- inherits(cond, "error")
[16:59:29.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.531]                   NULL)
[16:59:29.531]                 if (is_error) {
[16:59:29.531]                   sessionInformation <- function() {
[16:59:29.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.531]                       search = base::search(), system = base::Sys.info())
[16:59:29.531]                   }
[16:59:29.531]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.531]                     cond$call), session = sessionInformation(), 
[16:59:29.531]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.531]                   signalCondition(cond)
[16:59:29.531]                 }
[16:59:29.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.531]                 "immediateCondition"))) {
[16:59:29.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.531]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.531]                   if (TRUE && !signal) {
[16:59:29.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.531]                     {
[16:59:29.531]                       inherits <- base::inherits
[16:59:29.531]                       invokeRestart <- base::invokeRestart
[16:59:29.531]                       is.null <- base::is.null
[16:59:29.531]                       muffled <- FALSE
[16:59:29.531]                       if (inherits(cond, "message")) {
[16:59:29.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.531]                         if (muffled) 
[16:59:29.531]                           invokeRestart("muffleMessage")
[16:59:29.531]                       }
[16:59:29.531]                       else if (inherits(cond, "warning")) {
[16:59:29.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.531]                         if (muffled) 
[16:59:29.531]                           invokeRestart("muffleWarning")
[16:59:29.531]                       }
[16:59:29.531]                       else if (inherits(cond, "condition")) {
[16:59:29.531]                         if (!is.null(pattern)) {
[16:59:29.531]                           computeRestarts <- base::computeRestarts
[16:59:29.531]                           grepl <- base::grepl
[16:59:29.531]                           restarts <- computeRestarts(cond)
[16:59:29.531]                           for (restart in restarts) {
[16:59:29.531]                             name <- restart$name
[16:59:29.531]                             if (is.null(name)) 
[16:59:29.531]                               next
[16:59:29.531]                             if (!grepl(pattern, name)) 
[16:59:29.531]                               next
[16:59:29.531]                             invokeRestart(restart)
[16:59:29.531]                             muffled <- TRUE
[16:59:29.531]                             break
[16:59:29.531]                           }
[16:59:29.531]                         }
[16:59:29.531]                       }
[16:59:29.531]                       invisible(muffled)
[16:59:29.531]                     }
[16:59:29.531]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.531]                   }
[16:59:29.531]                 }
[16:59:29.531]                 else {
[16:59:29.531]                   if (TRUE) {
[16:59:29.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.531]                     {
[16:59:29.531]                       inherits <- base::inherits
[16:59:29.531]                       invokeRestart <- base::invokeRestart
[16:59:29.531]                       is.null <- base::is.null
[16:59:29.531]                       muffled <- FALSE
[16:59:29.531]                       if (inherits(cond, "message")) {
[16:59:29.531]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.531]                         if (muffled) 
[16:59:29.531]                           invokeRestart("muffleMessage")
[16:59:29.531]                       }
[16:59:29.531]                       else if (inherits(cond, "warning")) {
[16:59:29.531]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.531]                         if (muffled) 
[16:59:29.531]                           invokeRestart("muffleWarning")
[16:59:29.531]                       }
[16:59:29.531]                       else if (inherits(cond, "condition")) {
[16:59:29.531]                         if (!is.null(pattern)) {
[16:59:29.531]                           computeRestarts <- base::computeRestarts
[16:59:29.531]                           grepl <- base::grepl
[16:59:29.531]                           restarts <- computeRestarts(cond)
[16:59:29.531]                           for (restart in restarts) {
[16:59:29.531]                             name <- restart$name
[16:59:29.531]                             if (is.null(name)) 
[16:59:29.531]                               next
[16:59:29.531]                             if (!grepl(pattern, name)) 
[16:59:29.531]                               next
[16:59:29.531]                             invokeRestart(restart)
[16:59:29.531]                             muffled <- TRUE
[16:59:29.531]                             break
[16:59:29.531]                           }
[16:59:29.531]                         }
[16:59:29.531]                       }
[16:59:29.531]                       invisible(muffled)
[16:59:29.531]                     }
[16:59:29.531]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.531]                   }
[16:59:29.531]                 }
[16:59:29.531]             }
[16:59:29.531]         }))
[16:59:29.531]     }, error = function(ex) {
[16:59:29.531]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.531]                 ...future.rng), started = ...future.startTime, 
[16:59:29.531]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.531]             version = "1.8"), class = "FutureResult")
[16:59:29.531]     }, finally = {
[16:59:29.531]         if (!identical(...future.workdir, getwd())) 
[16:59:29.531]             setwd(...future.workdir)
[16:59:29.531]         {
[16:59:29.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.531]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.531]             }
[16:59:29.531]             base::options(...future.oldOptions)
[16:59:29.531]             if (.Platform$OS.type == "windows") {
[16:59:29.531]                 old_names <- names(...future.oldEnvVars)
[16:59:29.531]                 envs <- base::Sys.getenv()
[16:59:29.531]                 names <- names(envs)
[16:59:29.531]                 common <- intersect(names, old_names)
[16:59:29.531]                 added <- setdiff(names, old_names)
[16:59:29.531]                 removed <- setdiff(old_names, names)
[16:59:29.531]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.531]                   envs[common]]
[16:59:29.531]                 NAMES <- toupper(changed)
[16:59:29.531]                 args <- list()
[16:59:29.531]                 for (kk in seq_along(NAMES)) {
[16:59:29.531]                   name <- changed[[kk]]
[16:59:29.531]                   NAME <- NAMES[[kk]]
[16:59:29.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.531]                     next
[16:59:29.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.531]                 }
[16:59:29.531]                 NAMES <- toupper(added)
[16:59:29.531]                 for (kk in seq_along(NAMES)) {
[16:59:29.531]                   name <- added[[kk]]
[16:59:29.531]                   NAME <- NAMES[[kk]]
[16:59:29.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.531]                     next
[16:59:29.531]                   args[[name]] <- ""
[16:59:29.531]                 }
[16:59:29.531]                 NAMES <- toupper(removed)
[16:59:29.531]                 for (kk in seq_along(NAMES)) {
[16:59:29.531]                   name <- removed[[kk]]
[16:59:29.531]                   NAME <- NAMES[[kk]]
[16:59:29.531]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.531]                     next
[16:59:29.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.531]                 }
[16:59:29.531]                 if (length(args) > 0) 
[16:59:29.531]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.531]             }
[16:59:29.531]             else {
[16:59:29.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.531]             }
[16:59:29.531]             {
[16:59:29.531]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.531]                   0L) {
[16:59:29.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.531]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.531]                   base::options(opts)
[16:59:29.531]                 }
[16:59:29.531]                 {
[16:59:29.531]                   {
[16:59:29.531]                     NULL
[16:59:29.531]                     RNGkind("Mersenne-Twister")
[16:59:29.531]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:29.531]                       inherits = FALSE)
[16:59:29.531]                   }
[16:59:29.531]                   options(future.plan = NULL)
[16:59:29.531]                   if (is.na(NA_character_)) 
[16:59:29.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.531]                     .init = FALSE)
[16:59:29.531]                 }
[16:59:29.531]             }
[16:59:29.531]         }
[16:59:29.531]     })
[16:59:29.531]     if (TRUE) {
[16:59:29.531]         base::sink(type = "output", split = FALSE)
[16:59:29.531]         if (TRUE) {
[16:59:29.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.531]         }
[16:59:29.531]         else {
[16:59:29.531]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.531]         }
[16:59:29.531]         base::close(...future.stdout)
[16:59:29.531]         ...future.stdout <- NULL
[16:59:29.531]     }
[16:59:29.531]     ...future.result$conditions <- ...future.conditions
[16:59:29.531]     ...future.result$finished <- base::Sys.time()
[16:59:29.531]     ...future.result
[16:59:29.531] }
[16:59:29.533] assign_globals() ...
[16:59:29.533] List of 5
[16:59:29.533]  $ future.call.arguments    : list()
[16:59:29.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.533]  $ ...future.FUN            :function (x)  
[16:59:29.533]  $ ...future.elements_ii    :List of 2
[16:59:29.533]   ..$ : int [1:2] 1 3
[16:59:29.533]   ..$ : int [1:2] 2 4
[16:59:29.533]  $ ...future.seeds_ii       : NULL
[16:59:29.533]  $ ...future.globals.maxSize: num Inf
[16:59:29.533]  - attr(*, "resolved")= logi FALSE
[16:59:29.533]  - attr(*, "total_size")= num NA
[16:59:29.533]  - attr(*, "where")=List of 5
[16:59:29.533]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.533]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.533]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.533]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.533]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.533]  - attr(*, "already-done")= logi TRUE
[16:59:29.538] - copied ‘future.call.arguments’ to environment
[16:59:29.538] - reassign environment for ‘...future.FUN’
[16:59:29.538] - copied ‘...future.FUN’ to environment
[16:59:29.540] - copied ‘...future.elements_ii’ to environment
[16:59:29.540] - copied ‘...future.seeds_ii’ to environment
[16:59:29.540] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.540] assign_globals() ... done
[16:59:29.541] plan(): Setting new future strategy stack:
[16:59:29.541] List of future strategies:
[16:59:29.541] 1. sequential:
[16:59:29.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.541]    - tweaked: FALSE
[16:59:29.541]    - call: NULL
[16:59:29.541] plan(): nbrOfWorkers() = 1
[16:59:29.542] plan(): Setting new future strategy stack:
[16:59:29.542] List of future strategies:
[16:59:29.542] 1. sequential:
[16:59:29.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.542]    - tweaked: FALSE
[16:59:29.542]    - call: plan(strategy)
[16:59:29.543] plan(): nbrOfWorkers() = 1
[16:59:29.543] SequentialFuture started (and completed)
[16:59:29.543] - Launch lazy future ... done
[16:59:29.543] run() for ‘SequentialFuture’ ... done
[16:59:29.543] Created future:
[16:59:29.544] SequentialFuture:
[16:59:29.544] Label: ‘future_apply-1’
[16:59:29.544] Expression:
[16:59:29.544] {
[16:59:29.544]     do.call(function(...) {
[16:59:29.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.544]             on.exit(options(oopts), add = TRUE)
[16:59:29.544]         }
[16:59:29.544]         {
[16:59:29.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.544]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.544]             })
[16:59:29.544]         }
[16:59:29.544]     }, args = future.call.arguments)
[16:59:29.544] }
[16:59:29.544] Lazy evaluation: FALSE
[16:59:29.544] Asynchronous evaluation: FALSE
[16:59:29.544] Local evaluation: TRUE
[16:59:29.544] Environment: R_GlobalEnv
[16:59:29.544] Capture standard output: TRUE
[16:59:29.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.544] Globals: 5 objects totaling 9.82 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.544] Packages: <none>
[16:59:29.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.544] Resolved: TRUE
[16:59:29.544] Value: 400 bytes of class ‘list’
[16:59:29.544] Early signaling: FALSE
[16:59:29.544] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.544] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.545] Chunk #1 of 1 ... DONE
[16:59:29.545] Launching 1 futures (chunks) ... DONE
[16:59:29.545] Resolving 1 futures (chunks) ...
[16:59:29.545] resolve() on list ...
[16:59:29.545]  recursive: 0
[16:59:29.545]  length: 1
[16:59:29.545] 
[16:59:29.545] resolved() for ‘SequentialFuture’ ...
[16:59:29.545] - state: ‘finished’
[16:59:29.545] - run: TRUE
[16:59:29.546] - result: ‘FutureResult’
[16:59:29.546] resolved() for ‘SequentialFuture’ ... done
[16:59:29.546] Future #1
[16:59:29.546] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.546] - nx: 1
[16:59:29.546] - relay: TRUE
[16:59:29.546] - stdout: TRUE
[16:59:29.546] - signal: TRUE
[16:59:29.546] - resignal: FALSE
[16:59:29.546] - force: TRUE
[16:59:29.546] - relayed: [n=1] FALSE
[16:59:29.547] - queued futures: [n=1] FALSE
[16:59:29.547]  - until=1
[16:59:29.547]  - relaying element #1
[16:59:29.547] - relayed: [n=1] TRUE
[16:59:29.547] - queued futures: [n=1] TRUE
[16:59:29.547] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.547]  length: 0 (resolved future 1)
[16:59:29.547] Relaying remaining futures
[16:59:29.547] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.547] - nx: 1
[16:59:29.548] - relay: TRUE
[16:59:29.548] - stdout: TRUE
[16:59:29.548] - signal: TRUE
[16:59:29.548] - resignal: FALSE
[16:59:29.548] - force: TRUE
[16:59:29.548] - relayed: [n=1] TRUE
[16:59:29.548] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.548] - relayed: [n=1] TRUE
[16:59:29.548] - queued futures: [n=1] TRUE
[16:59:29.548] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.548] resolve() on list ... DONE
[16:59:29.549]  - Number of value chunks collected: 1
[16:59:29.549] Resolving 1 futures (chunks) ... DONE
[16:59:29.549] Reducing values from 1 chunks ...
[16:59:29.549]  - Number of values collected after concatenation: 2
[16:59:29.549]  - Number of values expected: 2
[16:59:29.549] Reducing values from 1 chunks ... DONE
[16:59:29.549] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:59:29.549] getGlobalsAndPackagesXApply() ...
[16:59:29.550]  - future.globals: TRUE
[16:59:29.550] getGlobalsAndPackages() ...
[16:59:29.550] Searching for globals...
[16:59:29.553] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:59:29.553] Searching for globals ... DONE
[16:59:29.553] Resolving globals: FALSE
[16:59:29.553] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:59:29.554] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:59:29.554] - globals: [1] ‘FUN’
[16:59:29.554] 
[16:59:29.554] getGlobalsAndPackages() ... DONE
[16:59:29.554]  - globals found/used: [n=1] ‘FUN’
[16:59:29.554]  - needed namespaces: [n=0] 
[16:59:29.554] Finding globals ... DONE
[16:59:29.554]  - use_args: TRUE
[16:59:29.555]  - Getting '...' globals ...
[16:59:29.555] resolve() on list ...
[16:59:29.555]  recursive: 0
[16:59:29.555]  length: 1
[16:59:29.555]  elements: ‘...’
[16:59:29.555]  length: 0 (resolved future 1)
[16:59:29.555] resolve() on list ... DONE
[16:59:29.555]    - '...' content: [n=0] 
[16:59:29.556] List of 1
[16:59:29.556]  $ ...: list()
[16:59:29.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.556]  - attr(*, "where")=List of 1
[16:59:29.556]   ..$ ...:<environment: 0x55f312e01510> 
[16:59:29.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.556]  - attr(*, "resolved")= logi TRUE
[16:59:29.556]  - attr(*, "total_size")= num NA
[16:59:29.558]  - Getting '...' globals ... DONE
[16:59:29.558] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.558] List of 2
[16:59:29.558]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:59:29.558]  $ ...          : list()
[16:59:29.558]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.558]  - attr(*, "where")=List of 2
[16:59:29.558]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.558]   ..$ ...          :<environment: 0x55f312e01510> 
[16:59:29.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.558]  - attr(*, "resolved")= logi FALSE
[16:59:29.558]  - attr(*, "total_size")= num 36296
[16:59:29.561] Packages to be attached in all futures: [n=0] 
[16:59:29.561] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.561] future_lapply() ...
[16:59:29.563] Generating random seeds ...
[16:59:29.563] Generating random seed streams for 2 elements ...
[16:59:29.565] Generating random seed streams for 2 elements ... DONE
[16:59:29.565] Generating random seeds ... DONE
[16:59:29.566] Will set RNG state on exit: 10407, 164675386, 1640941273, -43808357, 1401171257, 183016403, 1677384733
[16:59:29.566] Number of chunks: 1
[16:59:29.566] getGlobalsAndPackagesXApply() ...
[16:59:29.566]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.566]  - use_args: TRUE
[16:59:29.566] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.567] List of 2
[16:59:29.567]  $ ...          : list()
[16:59:29.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.567]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:59:29.567]  - attr(*, "where")=List of 2
[16:59:29.567]   ..$ ...          :<environment: 0x55f312e01510> 
[16:59:29.567]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.567]  - attr(*, "resolved")= logi FALSE
[16:59:29.567]  - attr(*, "total_size")= num NA
[16:59:29.570] Packages to be attached in all futures: [n=0] 
[16:59:29.570] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.570] Number of futures (= number of chunks): 1
[16:59:29.571] Launching 1 futures (chunks) ...
[16:59:29.571] Chunk #1 of 1 ...
[16:59:29.571]  - seeds: [2] <seeds>
[16:59:29.571]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.571] getGlobalsAndPackages() ...
[16:59:29.571] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.571] Resolving globals: FALSE
[16:59:29.571] Tweak future expression to call with '...' arguments ...
[16:59:29.571] {
[16:59:29.571]     do.call(function(...) {
[16:59:29.571]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.571]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.571]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.571]             on.exit(options(oopts), add = TRUE)
[16:59:29.571]         }
[16:59:29.571]         {
[16:59:29.571]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.571]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.571]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:29.571]                   envir = globalenv(), inherits = FALSE)
[16:59:29.571]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.571]             })
[16:59:29.571]         }
[16:59:29.571]     }, args = future.call.arguments)
[16:59:29.571] }
[16:59:29.572] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.572] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.572] 
[16:59:29.572] getGlobalsAndPackages() ... DONE
[16:59:29.573] run() for ‘Future’ ...
[16:59:29.573] - state: ‘created’
[16:59:29.573] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:29.573] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:29.573]   - Field: ‘label’
[16:59:29.573]   - Field: ‘local’
[16:59:29.574]   - Field: ‘owner’
[16:59:29.574]   - Field: ‘envir’
[16:59:29.574]   - Field: ‘packages’
[16:59:29.574]   - Field: ‘gc’
[16:59:29.574]   - Field: ‘conditions’
[16:59:29.574]   - Field: ‘expr’
[16:59:29.574]   - Field: ‘uuid’
[16:59:29.574]   - Field: ‘seed’
[16:59:29.574]   - Field: ‘version’
[16:59:29.574]   - Field: ‘result’
[16:59:29.574]   - Field: ‘asynchronous’
[16:59:29.575]   - Field: ‘calls’
[16:59:29.575]   - Field: ‘globals’
[16:59:29.575]   - Field: ‘stdout’
[16:59:29.575]   - Field: ‘earlySignal’
[16:59:29.575]   - Field: ‘lazy’
[16:59:29.575]   - Field: ‘state’
[16:59:29.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:29.575] - Launch lazy future ...
[16:59:29.575] Packages needed by the future expression (n = 0): <none>
[16:59:29.575] Packages needed by future strategies (n = 0): <none>
[16:59:29.576] {
[16:59:29.576]     {
[16:59:29.576]         {
[16:59:29.576]             ...future.startTime <- base::Sys.time()
[16:59:29.576]             {
[16:59:29.576]                 {
[16:59:29.576]                   {
[16:59:29.576]                     base::local({
[16:59:29.576]                       has_future <- base::requireNamespace("future", 
[16:59:29.576]                         quietly = TRUE)
[16:59:29.576]                       if (has_future) {
[16:59:29.576]                         ns <- base::getNamespace("future")
[16:59:29.576]                         version <- ns[[".package"]][["version"]]
[16:59:29.576]                         if (is.null(version)) 
[16:59:29.576]                           version <- utils::packageVersion("future")
[16:59:29.576]                       }
[16:59:29.576]                       else {
[16:59:29.576]                         version <- NULL
[16:59:29.576]                       }
[16:59:29.576]                       if (!has_future || version < "1.8.0") {
[16:59:29.576]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.576]                           "", base::R.version$version.string), 
[16:59:29.576]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:29.576]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.576]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.576]                             "release", "version")], collapse = " "), 
[16:59:29.576]                           hostname = base::Sys.info()[["nodename"]])
[16:59:29.576]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.576]                           info)
[16:59:29.576]                         info <- base::paste(info, collapse = "; ")
[16:59:29.576]                         if (!has_future) {
[16:59:29.576]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.576]                             info)
[16:59:29.576]                         }
[16:59:29.576]                         else {
[16:59:29.576]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.576]                             info, version)
[16:59:29.576]                         }
[16:59:29.576]                         base::stop(msg)
[16:59:29.576]                       }
[16:59:29.576]                     })
[16:59:29.576]                   }
[16:59:29.576]                   ...future.strategy.old <- future::plan("list")
[16:59:29.576]                   options(future.plan = NULL)
[16:59:29.576]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.576]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.576]                 }
[16:59:29.576]                 ...future.workdir <- getwd()
[16:59:29.576]             }
[16:59:29.576]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.576]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.576]         }
[16:59:29.576]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.576]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.576]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.576]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.576]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.576]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.576]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.576]             base::names(...future.oldOptions))
[16:59:29.576]     }
[16:59:29.576]     if (FALSE) {
[16:59:29.576]     }
[16:59:29.576]     else {
[16:59:29.576]         if (TRUE) {
[16:59:29.576]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.576]                 open = "w")
[16:59:29.576]         }
[16:59:29.576]         else {
[16:59:29.576]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.576]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.576]         }
[16:59:29.576]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.576]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.576]             base::sink(type = "output", split = FALSE)
[16:59:29.576]             base::close(...future.stdout)
[16:59:29.576]         }, add = TRUE)
[16:59:29.576]     }
[16:59:29.576]     ...future.frame <- base::sys.nframe()
[16:59:29.576]     ...future.conditions <- base::list()
[16:59:29.576]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.576]     if (FALSE) {
[16:59:29.576]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.576]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.576]     }
[16:59:29.576]     ...future.result <- base::tryCatch({
[16:59:29.576]         base::withCallingHandlers({
[16:59:29.576]             ...future.value <- base::withVisible(base::local({
[16:59:29.576]                 do.call(function(...) {
[16:59:29.576]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.576]                   if (!identical(...future.globals.maxSize.org, 
[16:59:29.576]                     ...future.globals.maxSize)) {
[16:59:29.576]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.576]                     on.exit(options(oopts), add = TRUE)
[16:59:29.576]                   }
[16:59:29.576]                   {
[16:59:29.576]                     lapply(seq_along(...future.elements_ii), 
[16:59:29.576]                       FUN = function(jj) {
[16:59:29.576]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.576]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:29.576]                           envir = globalenv(), inherits = FALSE)
[16:59:29.576]                         ...future.FUN(...future.X_jj, ...)
[16:59:29.576]                       })
[16:59:29.576]                   }
[16:59:29.576]                 }, args = future.call.arguments)
[16:59:29.576]             }))
[16:59:29.576]             future::FutureResult(value = ...future.value$value, 
[16:59:29.576]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.576]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.576]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.576]                     ...future.globalenv.names))
[16:59:29.576]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.576]         }, condition = base::local({
[16:59:29.576]             c <- base::c
[16:59:29.576]             inherits <- base::inherits
[16:59:29.576]             invokeRestart <- base::invokeRestart
[16:59:29.576]             length <- base::length
[16:59:29.576]             list <- base::list
[16:59:29.576]             seq.int <- base::seq.int
[16:59:29.576]             signalCondition <- base::signalCondition
[16:59:29.576]             sys.calls <- base::sys.calls
[16:59:29.576]             `[[` <- base::`[[`
[16:59:29.576]             `+` <- base::`+`
[16:59:29.576]             `<<-` <- base::`<<-`
[16:59:29.576]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.576]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.576]                   3L)]
[16:59:29.576]             }
[16:59:29.576]             function(cond) {
[16:59:29.576]                 is_error <- inherits(cond, "error")
[16:59:29.576]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.576]                   NULL)
[16:59:29.576]                 if (is_error) {
[16:59:29.576]                   sessionInformation <- function() {
[16:59:29.576]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.576]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.576]                       search = base::search(), system = base::Sys.info())
[16:59:29.576]                   }
[16:59:29.576]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.576]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.576]                     cond$call), session = sessionInformation(), 
[16:59:29.576]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.576]                   signalCondition(cond)
[16:59:29.576]                 }
[16:59:29.576]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[16:59:29.576]                   signal <- TRUE && inherits(cond, character(0))
[16:59:29.576]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.576]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.576]                   if (TRUE && !signal) {
[16:59:29.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.576]                     {
[16:59:29.576]                       inherits <- base::inherits
[16:59:29.576]                       invokeRestart <- base::invokeRestart
[16:59:29.576]                       is.null <- base::is.null
[16:59:29.576]                       muffled <- FALSE
[16:59:29.576]                       if (inherits(cond, "message")) {
[16:59:29.576]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.576]                         if (muffled) 
[16:59:29.576]                           invokeRestart("muffleMessage")
[16:59:29.576]                       }
[16:59:29.576]                       else if (inherits(cond, "warning")) {
[16:59:29.576]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.576]                         if (muffled) 
[16:59:29.576]                           invokeRestart("muffleWarning")
[16:59:29.576]                       }
[16:59:29.576]                       else if (inherits(cond, "condition")) {
[16:59:29.576]                         if (!is.null(pattern)) {
[16:59:29.576]                           computeRestarts <- base::computeRestarts
[16:59:29.576]                           grepl <- base::grepl
[16:59:29.576]                           restarts <- computeRestarts(cond)
[16:59:29.576]                           for (restart in restarts) {
[16:59:29.576]                             name <- restart$name
[16:59:29.576]                             if (is.null(name)) 
[16:59:29.576]                               next
[16:59:29.576]                             if (!grepl(pattern, name)) 
[16:59:29.576]                               next
[16:59:29.576]                             invokeRestart(restart)
[16:59:29.576]                             muffled <- TRUE
[16:59:29.576]                             break
[16:59:29.576]                           }
[16:59:29.576]                         }
[16:59:29.576]                       }
[16:59:29.576]                       invisible(muffled)
[16:59:29.576]                     }
[16:59:29.576]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.576]                   }
[16:59:29.576]                 }
[16:59:29.576]                 else {
[16:59:29.576]                   if (FALSE) {
[16:59:29.576]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.576]                     {
[16:59:29.576]                       inherits <- base::inherits
[16:59:29.576]                       invokeRestart <- base::invokeRestart
[16:59:29.576]                       is.null <- base::is.null
[16:59:29.576]                       muffled <- FALSE
[16:59:29.576]                       if (inherits(cond, "message")) {
[16:59:29.576]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.576]                         if (muffled) 
[16:59:29.576]                           invokeRestart("muffleMessage")
[16:59:29.576]                       }
[16:59:29.576]                       else if (inherits(cond, "warning")) {
[16:59:29.576]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.576]                         if (muffled) 
[16:59:29.576]                           invokeRestart("muffleWarning")
[16:59:29.576]                       }
[16:59:29.576]                       else if (inherits(cond, "condition")) {
[16:59:29.576]                         if (!is.null(pattern)) {
[16:59:29.576]                           computeRestarts <- base::computeRestarts
[16:59:29.576]                           grepl <- base::grepl
[16:59:29.576]                           restarts <- computeRestarts(cond)
[16:59:29.576]                           for (restart in restarts) {
[16:59:29.576]                             name <- restart$name
[16:59:29.576]                             if (is.null(name)) 
[16:59:29.576]                               next
[16:59:29.576]                             if (!grepl(pattern, name)) 
[16:59:29.576]                               next
[16:59:29.576]                             invokeRestart(restart)
[16:59:29.576]                             muffled <- TRUE
[16:59:29.576]                             break
[16:59:29.576]                           }
[16:59:29.576]                         }
[16:59:29.576]                       }
[16:59:29.576]                       invisible(muffled)
[16:59:29.576]                     }
[16:59:29.576]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.576]                   }
[16:59:29.576]                 }
[16:59:29.576]             }
[16:59:29.576]         }))
[16:59:29.576]     }, error = function(ex) {
[16:59:29.576]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.576]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.576]                 ...future.rng), started = ...future.startTime, 
[16:59:29.576]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.576]             version = "1.8"), class = "FutureResult")
[16:59:29.576]     }, finally = {
[16:59:29.576]         if (!identical(...future.workdir, getwd())) 
[16:59:29.576]             setwd(...future.workdir)
[16:59:29.576]         {
[16:59:29.576]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.576]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.576]             }
[16:59:29.576]             base::options(...future.oldOptions)
[16:59:29.576]             if (.Platform$OS.type == "windows") {
[16:59:29.576]                 old_names <- names(...future.oldEnvVars)
[16:59:29.576]                 envs <- base::Sys.getenv()
[16:59:29.576]                 names <- names(envs)
[16:59:29.576]                 common <- intersect(names, old_names)
[16:59:29.576]                 added <- setdiff(names, old_names)
[16:59:29.576]                 removed <- setdiff(old_names, names)
[16:59:29.576]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.576]                   envs[common]]
[16:59:29.576]                 NAMES <- toupper(changed)
[16:59:29.576]                 args <- list()
[16:59:29.576]                 for (kk in seq_along(NAMES)) {
[16:59:29.576]                   name <- changed[[kk]]
[16:59:29.576]                   NAME <- NAMES[[kk]]
[16:59:29.576]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.576]                     next
[16:59:29.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.576]                 }
[16:59:29.576]                 NAMES <- toupper(added)
[16:59:29.576]                 for (kk in seq_along(NAMES)) {
[16:59:29.576]                   name <- added[[kk]]
[16:59:29.576]                   NAME <- NAMES[[kk]]
[16:59:29.576]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.576]                     next
[16:59:29.576]                   args[[name]] <- ""
[16:59:29.576]                 }
[16:59:29.576]                 NAMES <- toupper(removed)
[16:59:29.576]                 for (kk in seq_along(NAMES)) {
[16:59:29.576]                   name <- removed[[kk]]
[16:59:29.576]                   NAME <- NAMES[[kk]]
[16:59:29.576]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.576]                     next
[16:59:29.576]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.576]                 }
[16:59:29.576]                 if (length(args) > 0) 
[16:59:29.576]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.576]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.576]             }
[16:59:29.576]             else {
[16:59:29.576]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.576]             }
[16:59:29.576]             {
[16:59:29.576]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.576]                   0L) {
[16:59:29.576]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.576]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.576]                   base::options(opts)
[16:59:29.576]                 }
[16:59:29.576]                 {
[16:59:29.576]                   {
[16:59:29.576]                     base::assign(".Random.seed", c(10407L, 164675386L, 
[16:59:29.576]                     1640941273L, -43808357L, 1401171257L, 183016403L, 
[16:59:29.576]                     1677384733L), envir = base::globalenv(), 
[16:59:29.576]                       inherits = FALSE)
[16:59:29.576]                     NULL
[16:59:29.576]                   }
[16:59:29.576]                   options(future.plan = NULL)
[16:59:29.576]                   if (is.na(NA_character_)) 
[16:59:29.576]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.576]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.576]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.576]                     .init = FALSE)
[16:59:29.576]                 }
[16:59:29.576]             }
[16:59:29.576]         }
[16:59:29.576]     })
[16:59:29.576]     if (TRUE) {
[16:59:29.576]         base::sink(type = "output", split = FALSE)
[16:59:29.576]         if (TRUE) {
[16:59:29.576]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.576]         }
[16:59:29.576]         else {
[16:59:29.576]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.576]         }
[16:59:29.576]         base::close(...future.stdout)
[16:59:29.576]         ...future.stdout <- NULL
[16:59:29.576]     }
[16:59:29.576]     ...future.result$conditions <- ...future.conditions
[16:59:29.576]     ...future.result$finished <- base::Sys.time()
[16:59:29.576]     ...future.result
[16:59:29.576] }
[16:59:29.578] assign_globals() ...
[16:59:29.578] List of 5
[16:59:29.578]  $ future.call.arguments    : list()
[16:59:29.578]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.578]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:59:29.578]  $ ...future.elements_ii    :List of 2
[16:59:29.578]   ..$ : int [1:2] 1 3
[16:59:29.578]   ..$ : int [1:2] 2 4
[16:59:29.578]  $ ...future.seeds_ii       :List of 2
[16:59:29.578]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:59:29.578]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:59:29.578]  $ ...future.globals.maxSize: num Inf
[16:59:29.578]  - attr(*, "resolved")= logi FALSE
[16:59:29.578]  - attr(*, "total_size")= num NA
[16:59:29.578]  - attr(*, "where")=List of 5
[16:59:29.578]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.578]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.578]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.578]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.578]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.578]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.578]  - attr(*, "already-done")= logi TRUE
[16:59:29.583] - copied ‘future.call.arguments’ to environment
[16:59:29.584] - copied ‘...future.FUN’ to environment
[16:59:29.584] - copied ‘...future.elements_ii’ to environment
[16:59:29.584] - copied ‘...future.seeds_ii’ to environment
[16:59:29.584] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.584] assign_globals() ... done
[16:59:29.584] plan(): Setting new future strategy stack:
[16:59:29.584] List of future strategies:
[16:59:29.584] 1. sequential:
[16:59:29.584]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.584]    - tweaked: FALSE
[16:59:29.584]    - call: NULL
[16:59:29.585] plan(): nbrOfWorkers() = 1
[16:59:29.586] plan(): Setting new future strategy stack:
[16:59:29.586] List of future strategies:
[16:59:29.586] 1. sequential:
[16:59:29.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.586]    - tweaked: FALSE
[16:59:29.586]    - call: plan(strategy)
[16:59:29.586] plan(): nbrOfWorkers() = 1
[16:59:29.586] SequentialFuture started (and completed)
[16:59:29.586] - Launch lazy future ... done
[16:59:29.586] run() for ‘SequentialFuture’ ... done
[16:59:29.587] Created future:
[16:59:29.587] SequentialFuture:
[16:59:29.587] Label: ‘future_apply-1’
[16:59:29.587] Expression:
[16:59:29.587] {
[16:59:29.587]     do.call(function(...) {
[16:59:29.587]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.587]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.587]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.587]             on.exit(options(oopts), add = TRUE)
[16:59:29.587]         }
[16:59:29.587]         {
[16:59:29.587]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.587]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.587]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:29.587]                   envir = globalenv(), inherits = FALSE)
[16:59:29.587]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.587]             })
[16:59:29.587]         }
[16:59:29.587]     }, args = future.call.arguments)
[16:59:29.587] }
[16:59:29.587] Lazy evaluation: FALSE
[16:59:29.587] Asynchronous evaluation: FALSE
[16:59:29.587] Local evaluation: TRUE
[16:59:29.587] Environment: R_GlobalEnv
[16:59:29.587] Capture standard output: TRUE
[16:59:29.587] Capture condition classes: <none>
[16:59:29.587] Globals: 5 objects totaling 35.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 112 bytes, list ‘...future.seeds_ii’ of 160 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.587] Packages: <none>
[16:59:29.587] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:59:29.587] Resolved: TRUE
[16:59:29.587] Value: 112 bytes of class ‘list’
[16:59:29.587] Early signaling: FALSE
[16:59:29.587] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.587] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:29.588] Chunk #1 of 1 ... DONE
[16:59:29.588] Launching 1 futures (chunks) ... DONE
[16:59:29.588] Resolving 1 futures (chunks) ...
[16:59:29.588] resolve() on list ...
[16:59:29.588]  recursive: 0
[16:59:29.588]  length: 1
[16:59:29.588] 
[16:59:29.588] resolved() for ‘SequentialFuture’ ...
[16:59:29.588] - state: ‘finished’
[16:59:29.589] - run: TRUE
[16:59:29.589] - result: ‘FutureResult’
[16:59:29.589] resolved() for ‘SequentialFuture’ ... done
[16:59:29.589] Future #1
[16:59:29.589] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:29.589] - nx: 1
[16:59:29.589] - relay: TRUE
[16:59:29.589] - stdout: TRUE
[16:59:29.589] - signal: TRUE
[16:59:29.589] - resignal: FALSE
[16:59:29.589] - force: TRUE
[16:59:29.590] - relayed: [n=1] FALSE
[16:59:29.590] - queued futures: [n=1] FALSE
[16:59:29.590]  - until=1
[16:59:29.590]  - relaying element #1
[16:59:29.590] - relayed: [n=1] TRUE
[16:59:29.590] - queued futures: [n=1] TRUE
[16:59:29.590] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:29.590]  length: 0 (resolved future 1)
[16:59:29.590] Relaying remaining futures
[16:59:29.590] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.591] - nx: 1
[16:59:29.591] - relay: TRUE
[16:59:29.591] - stdout: TRUE
[16:59:29.591] - signal: TRUE
[16:59:29.591] - resignal: FALSE
[16:59:29.591] - force: TRUE
[16:59:29.591] - relayed: [n=1] TRUE
[16:59:29.593] - queued futures: [n=1] TRUE
 - flush all
[16:59:29.593] - relayed: [n=1] TRUE
[16:59:29.593] - queued futures: [n=1] TRUE
[16:59:29.593] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.593] resolve() on list ... DONE
[16:59:29.594]  - Number of value chunks collected: 1
[16:59:29.594] Resolving 1 futures (chunks) ... DONE
[16:59:29.594] Reducing values from 1 chunks ...
[16:59:29.594]  - Number of values collected after concatenation: 2
[16:59:29.594]  - Number of values expected: 2
[16:59:29.594] Reducing values from 1 chunks ... DONE
[16:59:29.594] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:59:29.594] plan(): Setting new future strategy stack:
[16:59:29.595] List of future strategies:
[16:59:29.595] 1. sequential:
[16:59:29.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.595]    - tweaked: FALSE
[16:59:29.595]    - call: plan(sequential)
[16:59:29.595] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[16:59:29.596] plan(): Setting new future strategy stack:
[16:59:29.596] List of future strategies:
[16:59:29.596] 1. multicore:
[16:59:29.596]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:29.596]    - tweaked: FALSE
[16:59:29.596]    - call: plan(strategy)
[16:59:29.600] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:59:29.601] getGlobalsAndPackagesXApply() ...
[16:59:29.601]  - future.globals: TRUE
[16:59:29.601] getGlobalsAndPackages() ...
[16:59:29.601] Searching for globals...
[16:59:29.635] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:59:29.635] Searching for globals ... DONE
[16:59:29.635] Resolving globals: FALSE
[16:59:29.639] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:59:29.639] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:59:29.640] - globals: [1] ‘FUN’
[16:59:29.640] 
[16:59:29.640] getGlobalsAndPackages() ... DONE
[16:59:29.640]  - globals found/used: [n=1] ‘FUN’
[16:59:29.640]  - needed namespaces: [n=0] 
[16:59:29.640] Finding globals ... DONE
[16:59:29.640]  - use_args: TRUE
[16:59:29.640]  - Getting '...' globals ...
[16:59:29.641] resolve() on list ...
[16:59:29.641]  recursive: 0
[16:59:29.641]  length: 1
[16:59:29.641]  elements: ‘...’
[16:59:29.641]  length: 0 (resolved future 1)
[16:59:29.641] resolve() on list ... DONE
[16:59:29.641]    - '...' content: [n=0] 
[16:59:29.641] List of 1
[16:59:29.641]  $ ...: list()
[16:59:29.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.641]  - attr(*, "where")=List of 1
[16:59:29.641]   ..$ ...:<environment: 0x55f311d7d060> 
[16:59:29.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.641]  - attr(*, "resolved")= logi TRUE
[16:59:29.641]  - attr(*, "total_size")= num NA
[16:59:29.644]  - Getting '...' globals ... DONE
[16:59:29.644] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.644] List of 2
[16:59:29.644]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.644]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.644]  $ ...          : list()
[16:59:29.644]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.644]  - attr(*, "where")=List of 2
[16:59:29.644]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.644]   ..$ ...          :<environment: 0x55f311d7d060> 
[16:59:29.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.644]  - attr(*, "resolved")= logi FALSE
[16:59:29.644]  - attr(*, "total_size")= num 354224
[16:59:29.647] Packages to be attached in all futures: [n=0] 
[16:59:29.647] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.651] future_lapply() ...
[16:59:29.688] Number of chunks: 2
[16:59:29.688] getGlobalsAndPackagesXApply() ...
[16:59:29.688]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.688]  - use_args: TRUE
[16:59:29.688] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.689] List of 2
[16:59:29.689]  $ ...          : list()
[16:59:29.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.689]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.689]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.689]  - attr(*, "where")=List of 2
[16:59:29.689]   ..$ ...          :<environment: 0x55f311d7d060> 
[16:59:29.689]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.689]  - attr(*, "resolved")= logi FALSE
[16:59:29.689]  - attr(*, "total_size")= num NA
[16:59:29.692] Packages to be attached in all futures: [n=0] 
[16:59:29.692] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.692] Number of futures (= number of chunks): 2
[16:59:29.693] Launching 2 futures (chunks) ...
[16:59:29.693] Chunk #1 of 2 ...
[16:59:29.693]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:29.693]  - seeds: <none>
[16:59:29.693]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.693] getGlobalsAndPackages() ...
[16:59:29.693] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.693] Resolving globals: FALSE
[16:59:29.693] Tweak future expression to call with '...' arguments ...
[16:59:29.694] {
[16:59:29.694]     do.call(function(...) {
[16:59:29.694]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.694]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.694]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.694]             on.exit(options(oopts), add = TRUE)
[16:59:29.694]         }
[16:59:29.694]         {
[16:59:29.694]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.694]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.694]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.694]             })
[16:59:29.694]         }
[16:59:29.694]     }, args = future.call.arguments)
[16:59:29.694] }
[16:59:29.694] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.694] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.694] 
[16:59:29.694] getGlobalsAndPackages() ... DONE
[16:59:29.695] run() for ‘Future’ ...
[16:59:29.695] - state: ‘created’
[16:59:29.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:29.699] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:29.699]   - Field: ‘label’
[16:59:29.699]   - Field: ‘local’
[16:59:29.699]   - Field: ‘owner’
[16:59:29.699]   - Field: ‘envir’
[16:59:29.699]   - Field: ‘workers’
[16:59:29.699]   - Field: ‘packages’
[16:59:29.700]   - Field: ‘gc’
[16:59:29.700]   - Field: ‘job’
[16:59:29.700]   - Field: ‘conditions’
[16:59:29.700]   - Field: ‘expr’
[16:59:29.700]   - Field: ‘uuid’
[16:59:29.700]   - Field: ‘seed’
[16:59:29.700]   - Field: ‘version’
[16:59:29.700]   - Field: ‘result’
[16:59:29.700]   - Field: ‘asynchronous’
[16:59:29.700]   - Field: ‘calls’
[16:59:29.700]   - Field: ‘globals’
[16:59:29.701]   - Field: ‘stdout’
[16:59:29.701]   - Field: ‘earlySignal’
[16:59:29.701]   - Field: ‘lazy’
[16:59:29.701]   - Field: ‘state’
[16:59:29.701] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:29.701] - Launch lazy future ...
[16:59:29.702] Packages needed by the future expression (n = 0): <none>
[16:59:29.702] Packages needed by future strategies (n = 0): <none>
[16:59:29.703] {
[16:59:29.703]     {
[16:59:29.703]         {
[16:59:29.703]             ...future.startTime <- base::Sys.time()
[16:59:29.703]             {
[16:59:29.703]                 {
[16:59:29.703]                   {
[16:59:29.703]                     {
[16:59:29.703]                       base::local({
[16:59:29.703]                         has_future <- base::requireNamespace("future", 
[16:59:29.703]                           quietly = TRUE)
[16:59:29.703]                         if (has_future) {
[16:59:29.703]                           ns <- base::getNamespace("future")
[16:59:29.703]                           version <- ns[[".package"]][["version"]]
[16:59:29.703]                           if (is.null(version)) 
[16:59:29.703]                             version <- utils::packageVersion("future")
[16:59:29.703]                         }
[16:59:29.703]                         else {
[16:59:29.703]                           version <- NULL
[16:59:29.703]                         }
[16:59:29.703]                         if (!has_future || version < "1.8.0") {
[16:59:29.703]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.703]                             "", base::R.version$version.string), 
[16:59:29.703]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:29.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.703]                               "release", "version")], collapse = " "), 
[16:59:29.703]                             hostname = base::Sys.info()[["nodename"]])
[16:59:29.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.703]                             info)
[16:59:29.703]                           info <- base::paste(info, collapse = "; ")
[16:59:29.703]                           if (!has_future) {
[16:59:29.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.703]                               info)
[16:59:29.703]                           }
[16:59:29.703]                           else {
[16:59:29.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.703]                               info, version)
[16:59:29.703]                           }
[16:59:29.703]                           base::stop(msg)
[16:59:29.703]                         }
[16:59:29.703]                       })
[16:59:29.703]                     }
[16:59:29.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:29.703]                     base::options(mc.cores = 1L)
[16:59:29.703]                   }
[16:59:29.703]                   ...future.strategy.old <- future::plan("list")
[16:59:29.703]                   options(future.plan = NULL)
[16:59:29.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.703]                 }
[16:59:29.703]                 ...future.workdir <- getwd()
[16:59:29.703]             }
[16:59:29.703]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.703]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.703]         }
[16:59:29.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.703]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.703]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.703]             base::names(...future.oldOptions))
[16:59:29.703]     }
[16:59:29.703]     if (FALSE) {
[16:59:29.703]     }
[16:59:29.703]     else {
[16:59:29.703]         if (TRUE) {
[16:59:29.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.703]                 open = "w")
[16:59:29.703]         }
[16:59:29.703]         else {
[16:59:29.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.703]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.703]         }
[16:59:29.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.703]             base::sink(type = "output", split = FALSE)
[16:59:29.703]             base::close(...future.stdout)
[16:59:29.703]         }, add = TRUE)
[16:59:29.703]     }
[16:59:29.703]     ...future.frame <- base::sys.nframe()
[16:59:29.703]     ...future.conditions <- base::list()
[16:59:29.703]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.703]     if (FALSE) {
[16:59:29.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.703]     }
[16:59:29.703]     ...future.result <- base::tryCatch({
[16:59:29.703]         base::withCallingHandlers({
[16:59:29.703]             ...future.value <- base::withVisible(base::local({
[16:59:29.703]                 withCallingHandlers({
[16:59:29.703]                   {
[16:59:29.703]                     do.call(function(...) {
[16:59:29.703]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.703]                       if (!identical(...future.globals.maxSize.org, 
[16:59:29.703]                         ...future.globals.maxSize)) {
[16:59:29.703]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.703]                         on.exit(options(oopts), add = TRUE)
[16:59:29.703]                       }
[16:59:29.703]                       {
[16:59:29.703]                         lapply(seq_along(...future.elements_ii), 
[16:59:29.703]                           FUN = function(jj) {
[16:59:29.703]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.703]                             ...future.FUN(...future.X_jj, ...)
[16:59:29.703]                           })
[16:59:29.703]                       }
[16:59:29.703]                     }, args = future.call.arguments)
[16:59:29.703]                   }
[16:59:29.703]                 }, immediateCondition = function(cond) {
[16:59:29.703]                   save_rds <- function (object, pathname, ...) 
[16:59:29.703]                   {
[16:59:29.703]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:29.703]                     if (file_test("-f", pathname_tmp)) {
[16:59:29.703]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.703]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:29.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.703]                         fi_tmp[["mtime"]])
[16:59:29.703]                     }
[16:59:29.703]                     tryCatch({
[16:59:29.703]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:29.703]                     }, error = function(ex) {
[16:59:29.703]                       msg <- conditionMessage(ex)
[16:59:29.703]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.703]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:29.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.703]                         fi_tmp[["mtime"]], msg)
[16:59:29.703]                       ex$message <- msg
[16:59:29.703]                       stop(ex)
[16:59:29.703]                     })
[16:59:29.703]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:29.703]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:29.703]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:29.703]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.703]                       fi <- file.info(pathname)
[16:59:29.703]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:29.703]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.703]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:29.703]                         fi[["size"]], fi[["mtime"]])
[16:59:29.703]                       stop(msg)
[16:59:29.703]                     }
[16:59:29.703]                     invisible(pathname)
[16:59:29.703]                   }
[16:59:29.703]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:29.703]                     rootPath = tempdir()) 
[16:59:29.703]                   {
[16:59:29.703]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:29.703]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:29.703]                       tmpdir = path, fileext = ".rds")
[16:59:29.703]                     save_rds(obj, file)
[16:59:29.703]                   }
[16:59:29.703]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:29.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.703]                   {
[16:59:29.703]                     inherits <- base::inherits
[16:59:29.703]                     invokeRestart <- base::invokeRestart
[16:59:29.703]                     is.null <- base::is.null
[16:59:29.703]                     muffled <- FALSE
[16:59:29.703]                     if (inherits(cond, "message")) {
[16:59:29.703]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:29.703]                       if (muffled) 
[16:59:29.703]                         invokeRestart("muffleMessage")
[16:59:29.703]                     }
[16:59:29.703]                     else if (inherits(cond, "warning")) {
[16:59:29.703]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:29.703]                       if (muffled) 
[16:59:29.703]                         invokeRestart("muffleWarning")
[16:59:29.703]                     }
[16:59:29.703]                     else if (inherits(cond, "condition")) {
[16:59:29.703]                       if (!is.null(pattern)) {
[16:59:29.703]                         computeRestarts <- base::computeRestarts
[16:59:29.703]                         grepl <- base::grepl
[16:59:29.703]                         restarts <- computeRestarts(cond)
[16:59:29.703]                         for (restart in restarts) {
[16:59:29.703]                           name <- restart$name
[16:59:29.703]                           if (is.null(name)) 
[16:59:29.703]                             next
[16:59:29.703]                           if (!grepl(pattern, name)) 
[16:59:29.703]                             next
[16:59:29.703]                           invokeRestart(restart)
[16:59:29.703]                           muffled <- TRUE
[16:59:29.703]                           break
[16:59:29.703]                         }
[16:59:29.703]                       }
[16:59:29.703]                     }
[16:59:29.703]                     invisible(muffled)
[16:59:29.703]                   }
[16:59:29.703]                   muffleCondition(cond)
[16:59:29.703]                 })
[16:59:29.703]             }))
[16:59:29.703]             future::FutureResult(value = ...future.value$value, 
[16:59:29.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.703]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.703]                     ...future.globalenv.names))
[16:59:29.703]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.703]         }, condition = base::local({
[16:59:29.703]             c <- base::c
[16:59:29.703]             inherits <- base::inherits
[16:59:29.703]             invokeRestart <- base::invokeRestart
[16:59:29.703]             length <- base::length
[16:59:29.703]             list <- base::list
[16:59:29.703]             seq.int <- base::seq.int
[16:59:29.703]             signalCondition <- base::signalCondition
[16:59:29.703]             sys.calls <- base::sys.calls
[16:59:29.703]             `[[` <- base::`[[`
[16:59:29.703]             `+` <- base::`+`
[16:59:29.703]             `<<-` <- base::`<<-`
[16:59:29.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.703]                   3L)]
[16:59:29.703]             }
[16:59:29.703]             function(cond) {
[16:59:29.703]                 is_error <- inherits(cond, "error")
[16:59:29.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.703]                   NULL)
[16:59:29.703]                 if (is_error) {
[16:59:29.703]                   sessionInformation <- function() {
[16:59:29.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.703]                       search = base::search(), system = base::Sys.info())
[16:59:29.703]                   }
[16:59:29.703]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.703]                     cond$call), session = sessionInformation(), 
[16:59:29.703]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.703]                   signalCondition(cond)
[16:59:29.703]                 }
[16:59:29.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.703]                 "immediateCondition"))) {
[16:59:29.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.703]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.703]                   if (TRUE && !signal) {
[16:59:29.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.703]                     {
[16:59:29.703]                       inherits <- base::inherits
[16:59:29.703]                       invokeRestart <- base::invokeRestart
[16:59:29.703]                       is.null <- base::is.null
[16:59:29.703]                       muffled <- FALSE
[16:59:29.703]                       if (inherits(cond, "message")) {
[16:59:29.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.703]                         if (muffled) 
[16:59:29.703]                           invokeRestart("muffleMessage")
[16:59:29.703]                       }
[16:59:29.703]                       else if (inherits(cond, "warning")) {
[16:59:29.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.703]                         if (muffled) 
[16:59:29.703]                           invokeRestart("muffleWarning")
[16:59:29.703]                       }
[16:59:29.703]                       else if (inherits(cond, "condition")) {
[16:59:29.703]                         if (!is.null(pattern)) {
[16:59:29.703]                           computeRestarts <- base::computeRestarts
[16:59:29.703]                           grepl <- base::grepl
[16:59:29.703]                           restarts <- computeRestarts(cond)
[16:59:29.703]                           for (restart in restarts) {
[16:59:29.703]                             name <- restart$name
[16:59:29.703]                             if (is.null(name)) 
[16:59:29.703]                               next
[16:59:29.703]                             if (!grepl(pattern, name)) 
[16:59:29.703]                               next
[16:59:29.703]                             invokeRestart(restart)
[16:59:29.703]                             muffled <- TRUE
[16:59:29.703]                             break
[16:59:29.703]                           }
[16:59:29.703]                         }
[16:59:29.703]                       }
[16:59:29.703]                       invisible(muffled)
[16:59:29.703]                     }
[16:59:29.703]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.703]                   }
[16:59:29.703]                 }
[16:59:29.703]                 else {
[16:59:29.703]                   if (TRUE) {
[16:59:29.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.703]                     {
[16:59:29.703]                       inherits <- base::inherits
[16:59:29.703]                       invokeRestart <- base::invokeRestart
[16:59:29.703]                       is.null <- base::is.null
[16:59:29.703]                       muffled <- FALSE
[16:59:29.703]                       if (inherits(cond, "message")) {
[16:59:29.703]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.703]                         if (muffled) 
[16:59:29.703]                           invokeRestart("muffleMessage")
[16:59:29.703]                       }
[16:59:29.703]                       else if (inherits(cond, "warning")) {
[16:59:29.703]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.703]                         if (muffled) 
[16:59:29.703]                           invokeRestart("muffleWarning")
[16:59:29.703]                       }
[16:59:29.703]                       else if (inherits(cond, "condition")) {
[16:59:29.703]                         if (!is.null(pattern)) {
[16:59:29.703]                           computeRestarts <- base::computeRestarts
[16:59:29.703]                           grepl <- base::grepl
[16:59:29.703]                           restarts <- computeRestarts(cond)
[16:59:29.703]                           for (restart in restarts) {
[16:59:29.703]                             name <- restart$name
[16:59:29.703]                             if (is.null(name)) 
[16:59:29.703]                               next
[16:59:29.703]                             if (!grepl(pattern, name)) 
[16:59:29.703]                               next
[16:59:29.703]                             invokeRestart(restart)
[16:59:29.703]                             muffled <- TRUE
[16:59:29.703]                             break
[16:59:29.703]                           }
[16:59:29.703]                         }
[16:59:29.703]                       }
[16:59:29.703]                       invisible(muffled)
[16:59:29.703]                     }
[16:59:29.703]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.703]                   }
[16:59:29.703]                 }
[16:59:29.703]             }
[16:59:29.703]         }))
[16:59:29.703]     }, error = function(ex) {
[16:59:29.703]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.703]                 ...future.rng), started = ...future.startTime, 
[16:59:29.703]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.703]             version = "1.8"), class = "FutureResult")
[16:59:29.703]     }, finally = {
[16:59:29.703]         if (!identical(...future.workdir, getwd())) 
[16:59:29.703]             setwd(...future.workdir)
[16:59:29.703]         {
[16:59:29.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.703]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.703]             }
[16:59:29.703]             base::options(...future.oldOptions)
[16:59:29.703]             if (.Platform$OS.type == "windows") {
[16:59:29.703]                 old_names <- names(...future.oldEnvVars)
[16:59:29.703]                 envs <- base::Sys.getenv()
[16:59:29.703]                 names <- names(envs)
[16:59:29.703]                 common <- intersect(names, old_names)
[16:59:29.703]                 added <- setdiff(names, old_names)
[16:59:29.703]                 removed <- setdiff(old_names, names)
[16:59:29.703]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.703]                   envs[common]]
[16:59:29.703]                 NAMES <- toupper(changed)
[16:59:29.703]                 args <- list()
[16:59:29.703]                 for (kk in seq_along(NAMES)) {
[16:59:29.703]                   name <- changed[[kk]]
[16:59:29.703]                   NAME <- NAMES[[kk]]
[16:59:29.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.703]                     next
[16:59:29.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.703]                 }
[16:59:29.703]                 NAMES <- toupper(added)
[16:59:29.703]                 for (kk in seq_along(NAMES)) {
[16:59:29.703]                   name <- added[[kk]]
[16:59:29.703]                   NAME <- NAMES[[kk]]
[16:59:29.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.703]                     next
[16:59:29.703]                   args[[name]] <- ""
[16:59:29.703]                 }
[16:59:29.703]                 NAMES <- toupper(removed)
[16:59:29.703]                 for (kk in seq_along(NAMES)) {
[16:59:29.703]                   name <- removed[[kk]]
[16:59:29.703]                   NAME <- NAMES[[kk]]
[16:59:29.703]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.703]                     next
[16:59:29.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.703]                 }
[16:59:29.703]                 if (length(args) > 0) 
[16:59:29.703]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.703]             }
[16:59:29.703]             else {
[16:59:29.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.703]             }
[16:59:29.703]             {
[16:59:29.703]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.703]                   0L) {
[16:59:29.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.703]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.703]                   base::options(opts)
[16:59:29.703]                 }
[16:59:29.703]                 {
[16:59:29.703]                   {
[16:59:29.703]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:29.703]                     NULL
[16:59:29.703]                   }
[16:59:29.703]                   options(future.plan = NULL)
[16:59:29.703]                   if (is.na(NA_character_)) 
[16:59:29.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.703]                     .init = FALSE)
[16:59:29.703]                 }
[16:59:29.703]             }
[16:59:29.703]         }
[16:59:29.703]     })
[16:59:29.703]     if (TRUE) {
[16:59:29.703]         base::sink(type = "output", split = FALSE)
[16:59:29.703]         if (TRUE) {
[16:59:29.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.703]         }
[16:59:29.703]         else {
[16:59:29.703]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.703]         }
[16:59:29.703]         base::close(...future.stdout)
[16:59:29.703]         ...future.stdout <- NULL
[16:59:29.703]     }
[16:59:29.703]     ...future.result$conditions <- ...future.conditions
[16:59:29.703]     ...future.result$finished <- base::Sys.time()
[16:59:29.703]     ...future.result
[16:59:29.703] }
[16:59:29.705] assign_globals() ...
[16:59:29.705] List of 5
[16:59:29.705]  $ future.call.arguments    : list()
[16:59:29.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.705]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.705]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.705]  $ ...future.elements_ii    :List of 1
[16:59:29.705]   ..$ : num [1:4] 1 3 1 7
[16:59:29.705]  $ ...future.seeds_ii       : NULL
[16:59:29.705]  $ ...future.globals.maxSize: num Inf
[16:59:29.705]  - attr(*, "resolved")= logi FALSE
[16:59:29.705]  - attr(*, "total_size")= num NA
[16:59:29.705]  - attr(*, "where")=List of 5
[16:59:29.705]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.705]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.705]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.705]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.705]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.705]  - attr(*, "already-done")= logi TRUE
[16:59:29.710] - copied ‘future.call.arguments’ to environment
[16:59:29.710] - copied ‘...future.FUN’ to environment
[16:59:29.710] - copied ‘...future.elements_ii’ to environment
[16:59:29.710] - copied ‘...future.seeds_ii’ to environment
[16:59:29.710] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.710] assign_globals() ... done
[16:59:29.711] requestCore(): workers = 2
[16:59:29.714] MulticoreFuture started
[16:59:29.714] - Launch lazy future ... done
[16:59:29.714] plan(): Setting new future strategy stack:
[16:59:29.714] run() for ‘MulticoreFuture’ ... done
[16:59:29.715] Created future:
[16:59:29.714] List of future strategies:
[16:59:29.714] 1. sequential:
[16:59:29.714]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.714]    - tweaked: FALSE
[16:59:29.714]    - call: NULL
[16:59:29.716] plan(): nbrOfWorkers() = 1
[16:59:29.724] plan(): Setting new future strategy stack:
[16:59:29.724] List of future strategies:
[16:59:29.724] 1. multicore:
[16:59:29.724]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:29.724]    - tweaked: FALSE
[16:59:29.724]    - call: plan(strategy)
[16:59:29.731] plan(): nbrOfWorkers() = 2
[16:59:29.715] MulticoreFuture:
[16:59:29.715] Label: ‘future_apply-1’
[16:59:29.715] Expression:
[16:59:29.715] {
[16:59:29.715]     do.call(function(...) {
[16:59:29.715]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.715]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.715]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.715]             on.exit(options(oopts), add = TRUE)
[16:59:29.715]         }
[16:59:29.715]         {
[16:59:29.715]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.715]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.715]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.715]             })
[16:59:29.715]         }
[16:59:29.715]     }, args = future.call.arguments)
[16:59:29.715] }
[16:59:29.715] Lazy evaluation: FALSE
[16:59:29.715] Asynchronous evaluation: TRUE
[16:59:29.715] Local evaluation: TRUE
[16:59:29.715] Environment: R_GlobalEnv
[16:59:29.715] Capture standard output: TRUE
[16:59:29.715] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.715] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.715] Packages: <none>
[16:59:29.715] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.715] Resolved: TRUE
[16:59:29.715] Value: <not collected>
[16:59:29.715] Conditions captured: <none>
[16:59:29.715] Early signaling: FALSE
[16:59:29.715] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.715] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.732] Chunk #1 of 2 ... DONE
[16:59:29.733] Chunk #2 of 2 ...
[16:59:29.733]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:29.733]  - seeds: <none>
[16:59:29.733]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.734] getGlobalsAndPackages() ...
[16:59:29.734] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.734] Resolving globals: FALSE
[16:59:29.734] Tweak future expression to call with '...' arguments ...
[16:59:29.734] {
[16:59:29.734]     do.call(function(...) {
[16:59:29.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.734]             on.exit(options(oopts), add = TRUE)
[16:59:29.734]         }
[16:59:29.734]         {
[16:59:29.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.734]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.734]             })
[16:59:29.734]         }
[16:59:29.734]     }, args = future.call.arguments)
[16:59:29.734] }
[16:59:29.735] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.735] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.736] 
[16:59:29.736] getGlobalsAndPackages() ... DONE
[16:59:29.736] run() for ‘Future’ ...
[16:59:29.736] - state: ‘created’
[16:59:29.737] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:29.741] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:29.742]   - Field: ‘label’
[16:59:29.742]   - Field: ‘local’
[16:59:29.742]   - Field: ‘owner’
[16:59:29.742]   - Field: ‘envir’
[16:59:29.742]   - Field: ‘workers’
[16:59:29.742]   - Field: ‘packages’
[16:59:29.743]   - Field: ‘gc’
[16:59:29.743]   - Field: ‘job’
[16:59:29.743]   - Field: ‘conditions’
[16:59:29.743]   - Field: ‘expr’
[16:59:29.743]   - Field: ‘uuid’
[16:59:29.743]   - Field: ‘seed’
[16:59:29.743]   - Field: ‘version’
[16:59:29.744]   - Field: ‘result’
[16:59:29.744]   - Field: ‘asynchronous’
[16:59:29.744]   - Field: ‘calls’
[16:59:29.744]   - Field: ‘globals’
[16:59:29.744]   - Field: ‘stdout’
[16:59:29.744]   - Field: ‘earlySignal’
[16:59:29.744]   - Field: ‘lazy’
[16:59:29.744]   - Field: ‘state’
[16:59:29.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:29.745] - Launch lazy future ...
[16:59:29.745] Packages needed by the future expression (n = 0): <none>
[16:59:29.745] Packages needed by future strategies (n = 0): <none>
[16:59:29.746] {
[16:59:29.746]     {
[16:59:29.746]         {
[16:59:29.746]             ...future.startTime <- base::Sys.time()
[16:59:29.746]             {
[16:59:29.746]                 {
[16:59:29.746]                   {
[16:59:29.746]                     {
[16:59:29.746]                       base::local({
[16:59:29.746]                         has_future <- base::requireNamespace("future", 
[16:59:29.746]                           quietly = TRUE)
[16:59:29.746]                         if (has_future) {
[16:59:29.746]                           ns <- base::getNamespace("future")
[16:59:29.746]                           version <- ns[[".package"]][["version"]]
[16:59:29.746]                           if (is.null(version)) 
[16:59:29.746]                             version <- utils::packageVersion("future")
[16:59:29.746]                         }
[16:59:29.746]                         else {
[16:59:29.746]                           version <- NULL
[16:59:29.746]                         }
[16:59:29.746]                         if (!has_future || version < "1.8.0") {
[16:59:29.746]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.746]                             "", base::R.version$version.string), 
[16:59:29.746]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:29.746]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.746]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.746]                               "release", "version")], collapse = " "), 
[16:59:29.746]                             hostname = base::Sys.info()[["nodename"]])
[16:59:29.746]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.746]                             info)
[16:59:29.746]                           info <- base::paste(info, collapse = "; ")
[16:59:29.746]                           if (!has_future) {
[16:59:29.746]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.746]                               info)
[16:59:29.746]                           }
[16:59:29.746]                           else {
[16:59:29.746]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.746]                               info, version)
[16:59:29.746]                           }
[16:59:29.746]                           base::stop(msg)
[16:59:29.746]                         }
[16:59:29.746]                       })
[16:59:29.746]                     }
[16:59:29.746]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:29.746]                     base::options(mc.cores = 1L)
[16:59:29.746]                   }
[16:59:29.746]                   ...future.strategy.old <- future::plan("list")
[16:59:29.746]                   options(future.plan = NULL)
[16:59:29.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.746]                 }
[16:59:29.746]                 ...future.workdir <- getwd()
[16:59:29.746]             }
[16:59:29.746]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.746]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.746]         }
[16:59:29.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.746]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.746]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.746]             base::names(...future.oldOptions))
[16:59:29.746]     }
[16:59:29.746]     if (FALSE) {
[16:59:29.746]     }
[16:59:29.746]     else {
[16:59:29.746]         if (TRUE) {
[16:59:29.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.746]                 open = "w")
[16:59:29.746]         }
[16:59:29.746]         else {
[16:59:29.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.746]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.746]         }
[16:59:29.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.746]             base::sink(type = "output", split = FALSE)
[16:59:29.746]             base::close(...future.stdout)
[16:59:29.746]         }, add = TRUE)
[16:59:29.746]     }
[16:59:29.746]     ...future.frame <- base::sys.nframe()
[16:59:29.746]     ...future.conditions <- base::list()
[16:59:29.746]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.746]     if (FALSE) {
[16:59:29.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.746]     }
[16:59:29.746]     ...future.result <- base::tryCatch({
[16:59:29.746]         base::withCallingHandlers({
[16:59:29.746]             ...future.value <- base::withVisible(base::local({
[16:59:29.746]                 withCallingHandlers({
[16:59:29.746]                   {
[16:59:29.746]                     do.call(function(...) {
[16:59:29.746]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.746]                       if (!identical(...future.globals.maxSize.org, 
[16:59:29.746]                         ...future.globals.maxSize)) {
[16:59:29.746]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.746]                         on.exit(options(oopts), add = TRUE)
[16:59:29.746]                       }
[16:59:29.746]                       {
[16:59:29.746]                         lapply(seq_along(...future.elements_ii), 
[16:59:29.746]                           FUN = function(jj) {
[16:59:29.746]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.746]                             ...future.FUN(...future.X_jj, ...)
[16:59:29.746]                           })
[16:59:29.746]                       }
[16:59:29.746]                     }, args = future.call.arguments)
[16:59:29.746]                   }
[16:59:29.746]                 }, immediateCondition = function(cond) {
[16:59:29.746]                   save_rds <- function (object, pathname, ...) 
[16:59:29.746]                   {
[16:59:29.746]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:29.746]                     if (file_test("-f", pathname_tmp)) {
[16:59:29.746]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.746]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:29.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.746]                         fi_tmp[["mtime"]])
[16:59:29.746]                     }
[16:59:29.746]                     tryCatch({
[16:59:29.746]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:29.746]                     }, error = function(ex) {
[16:59:29.746]                       msg <- conditionMessage(ex)
[16:59:29.746]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.746]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:29.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.746]                         fi_tmp[["mtime"]], msg)
[16:59:29.746]                       ex$message <- msg
[16:59:29.746]                       stop(ex)
[16:59:29.746]                     })
[16:59:29.746]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:29.746]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:29.746]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:29.746]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.746]                       fi <- file.info(pathname)
[16:59:29.746]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:29.746]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.746]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:29.746]                         fi[["size"]], fi[["mtime"]])
[16:59:29.746]                       stop(msg)
[16:59:29.746]                     }
[16:59:29.746]                     invisible(pathname)
[16:59:29.746]                   }
[16:59:29.746]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:29.746]                     rootPath = tempdir()) 
[16:59:29.746]                   {
[16:59:29.746]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:29.746]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:29.746]                       tmpdir = path, fileext = ".rds")
[16:59:29.746]                     save_rds(obj, file)
[16:59:29.746]                   }
[16:59:29.746]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:29.746]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.746]                   {
[16:59:29.746]                     inherits <- base::inherits
[16:59:29.746]                     invokeRestart <- base::invokeRestart
[16:59:29.746]                     is.null <- base::is.null
[16:59:29.746]                     muffled <- FALSE
[16:59:29.746]                     if (inherits(cond, "message")) {
[16:59:29.746]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:29.746]                       if (muffled) 
[16:59:29.746]                         invokeRestart("muffleMessage")
[16:59:29.746]                     }
[16:59:29.746]                     else if (inherits(cond, "warning")) {
[16:59:29.746]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:29.746]                       if (muffled) 
[16:59:29.746]                         invokeRestart("muffleWarning")
[16:59:29.746]                     }
[16:59:29.746]                     else if (inherits(cond, "condition")) {
[16:59:29.746]                       if (!is.null(pattern)) {
[16:59:29.746]                         computeRestarts <- base::computeRestarts
[16:59:29.746]                         grepl <- base::grepl
[16:59:29.746]                         restarts <- computeRestarts(cond)
[16:59:29.746]                         for (restart in restarts) {
[16:59:29.746]                           name <- restart$name
[16:59:29.746]                           if (is.null(name)) 
[16:59:29.746]                             next
[16:59:29.746]                           if (!grepl(pattern, name)) 
[16:59:29.746]                             next
[16:59:29.746]                           invokeRestart(restart)
[16:59:29.746]                           muffled <- TRUE
[16:59:29.746]                           break
[16:59:29.746]                         }
[16:59:29.746]                       }
[16:59:29.746]                     }
[16:59:29.746]                     invisible(muffled)
[16:59:29.746]                   }
[16:59:29.746]                   muffleCondition(cond)
[16:59:29.746]                 })
[16:59:29.746]             }))
[16:59:29.746]             future::FutureResult(value = ...future.value$value, 
[16:59:29.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.746]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.746]                     ...future.globalenv.names))
[16:59:29.746]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.746]         }, condition = base::local({
[16:59:29.746]             c <- base::c
[16:59:29.746]             inherits <- base::inherits
[16:59:29.746]             invokeRestart <- base::invokeRestart
[16:59:29.746]             length <- base::length
[16:59:29.746]             list <- base::list
[16:59:29.746]             seq.int <- base::seq.int
[16:59:29.746]             signalCondition <- base::signalCondition
[16:59:29.746]             sys.calls <- base::sys.calls
[16:59:29.746]             `[[` <- base::`[[`
[16:59:29.746]             `+` <- base::`+`
[16:59:29.746]             `<<-` <- base::`<<-`
[16:59:29.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.746]                   3L)]
[16:59:29.746]             }
[16:59:29.746]             function(cond) {
[16:59:29.746]                 is_error <- inherits(cond, "error")
[16:59:29.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.746]                   NULL)
[16:59:29.746]                 if (is_error) {
[16:59:29.746]                   sessionInformation <- function() {
[16:59:29.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.746]                       search = base::search(), system = base::Sys.info())
[16:59:29.746]                   }
[16:59:29.746]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.746]                     cond$call), session = sessionInformation(), 
[16:59:29.746]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.746]                   signalCondition(cond)
[16:59:29.746]                 }
[16:59:29.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.746]                 "immediateCondition"))) {
[16:59:29.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.746]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.746]                   if (TRUE && !signal) {
[16:59:29.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.746]                     {
[16:59:29.746]                       inherits <- base::inherits
[16:59:29.746]                       invokeRestart <- base::invokeRestart
[16:59:29.746]                       is.null <- base::is.null
[16:59:29.746]                       muffled <- FALSE
[16:59:29.746]                       if (inherits(cond, "message")) {
[16:59:29.746]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.746]                         if (muffled) 
[16:59:29.746]                           invokeRestart("muffleMessage")
[16:59:29.746]                       }
[16:59:29.746]                       else if (inherits(cond, "warning")) {
[16:59:29.746]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.746]                         if (muffled) 
[16:59:29.746]                           invokeRestart("muffleWarning")
[16:59:29.746]                       }
[16:59:29.746]                       else if (inherits(cond, "condition")) {
[16:59:29.746]                         if (!is.null(pattern)) {
[16:59:29.746]                           computeRestarts <- base::computeRestarts
[16:59:29.746]                           grepl <- base::grepl
[16:59:29.746]                           restarts <- computeRestarts(cond)
[16:59:29.746]                           for (restart in restarts) {
[16:59:29.746]                             name <- restart$name
[16:59:29.746]                             if (is.null(name)) 
[16:59:29.746]                               next
[16:59:29.746]                             if (!grepl(pattern, name)) 
[16:59:29.746]                               next
[16:59:29.746]                             invokeRestart(restart)
[16:59:29.746]                             muffled <- TRUE
[16:59:29.746]                             break
[16:59:29.746]                           }
[16:59:29.746]                         }
[16:59:29.746]                       }
[16:59:29.746]                       invisible(muffled)
[16:59:29.746]                     }
[16:59:29.746]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.746]                   }
[16:59:29.746]                 }
[16:59:29.746]                 else {
[16:59:29.746]                   if (TRUE) {
[16:59:29.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.746]                     {
[16:59:29.746]                       inherits <- base::inherits
[16:59:29.746]                       invokeRestart <- base::invokeRestart
[16:59:29.746]                       is.null <- base::is.null
[16:59:29.746]                       muffled <- FALSE
[16:59:29.746]                       if (inherits(cond, "message")) {
[16:59:29.746]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.746]                         if (muffled) 
[16:59:29.746]                           invokeRestart("muffleMessage")
[16:59:29.746]                       }
[16:59:29.746]                       else if (inherits(cond, "warning")) {
[16:59:29.746]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.746]                         if (muffled) 
[16:59:29.746]                           invokeRestart("muffleWarning")
[16:59:29.746]                       }
[16:59:29.746]                       else if (inherits(cond, "condition")) {
[16:59:29.746]                         if (!is.null(pattern)) {
[16:59:29.746]                           computeRestarts <- base::computeRestarts
[16:59:29.746]                           grepl <- base::grepl
[16:59:29.746]                           restarts <- computeRestarts(cond)
[16:59:29.746]                           for (restart in restarts) {
[16:59:29.746]                             name <- restart$name
[16:59:29.746]                             if (is.null(name)) 
[16:59:29.746]                               next
[16:59:29.746]                             if (!grepl(pattern, name)) 
[16:59:29.746]                               next
[16:59:29.746]                             invokeRestart(restart)
[16:59:29.746]                             muffled <- TRUE
[16:59:29.746]                             break
[16:59:29.746]                           }
[16:59:29.746]                         }
[16:59:29.746]                       }
[16:59:29.746]                       invisible(muffled)
[16:59:29.746]                     }
[16:59:29.746]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.746]                   }
[16:59:29.746]                 }
[16:59:29.746]             }
[16:59:29.746]         }))
[16:59:29.746]     }, error = function(ex) {
[16:59:29.746]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.746]                 ...future.rng), started = ...future.startTime, 
[16:59:29.746]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.746]             version = "1.8"), class = "FutureResult")
[16:59:29.746]     }, finally = {
[16:59:29.746]         if (!identical(...future.workdir, getwd())) 
[16:59:29.746]             setwd(...future.workdir)
[16:59:29.746]         {
[16:59:29.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.746]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.746]             }
[16:59:29.746]             base::options(...future.oldOptions)
[16:59:29.746]             if (.Platform$OS.type == "windows") {
[16:59:29.746]                 old_names <- names(...future.oldEnvVars)
[16:59:29.746]                 envs <- base::Sys.getenv()
[16:59:29.746]                 names <- names(envs)
[16:59:29.746]                 common <- intersect(names, old_names)
[16:59:29.746]                 added <- setdiff(names, old_names)
[16:59:29.746]                 removed <- setdiff(old_names, names)
[16:59:29.746]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.746]                   envs[common]]
[16:59:29.746]                 NAMES <- toupper(changed)
[16:59:29.746]                 args <- list()
[16:59:29.746]                 for (kk in seq_along(NAMES)) {
[16:59:29.746]                   name <- changed[[kk]]
[16:59:29.746]                   NAME <- NAMES[[kk]]
[16:59:29.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.746]                     next
[16:59:29.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.746]                 }
[16:59:29.746]                 NAMES <- toupper(added)
[16:59:29.746]                 for (kk in seq_along(NAMES)) {
[16:59:29.746]                   name <- added[[kk]]
[16:59:29.746]                   NAME <- NAMES[[kk]]
[16:59:29.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.746]                     next
[16:59:29.746]                   args[[name]] <- ""
[16:59:29.746]                 }
[16:59:29.746]                 NAMES <- toupper(removed)
[16:59:29.746]                 for (kk in seq_along(NAMES)) {
[16:59:29.746]                   name <- removed[[kk]]
[16:59:29.746]                   NAME <- NAMES[[kk]]
[16:59:29.746]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.746]                     next
[16:59:29.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.746]                 }
[16:59:29.746]                 if (length(args) > 0) 
[16:59:29.746]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.746]             }
[16:59:29.746]             else {
[16:59:29.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.746]             }
[16:59:29.746]             {
[16:59:29.746]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.746]                   0L) {
[16:59:29.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.746]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.746]                   base::options(opts)
[16:59:29.746]                 }
[16:59:29.746]                 {
[16:59:29.746]                   {
[16:59:29.746]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:29.746]                     NULL
[16:59:29.746]                   }
[16:59:29.746]                   options(future.plan = NULL)
[16:59:29.746]                   if (is.na(NA_character_)) 
[16:59:29.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.746]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.746]                     .init = FALSE)
[16:59:29.746]                 }
[16:59:29.746]             }
[16:59:29.746]         }
[16:59:29.746]     })
[16:59:29.746]     if (TRUE) {
[16:59:29.746]         base::sink(type = "output", split = FALSE)
[16:59:29.746]         if (TRUE) {
[16:59:29.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.746]         }
[16:59:29.746]         else {
[16:59:29.746]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.746]         }
[16:59:29.746]         base::close(...future.stdout)
[16:59:29.746]         ...future.stdout <- NULL
[16:59:29.746]     }
[16:59:29.746]     ...future.result$conditions <- ...future.conditions
[16:59:29.746]     ...future.result$finished <- base::Sys.time()
[16:59:29.746]     ...future.result
[16:59:29.746] }
[16:59:29.749] assign_globals() ...
[16:59:29.749] List of 5
[16:59:29.749]  $ future.call.arguments    : list()
[16:59:29.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.749]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.749]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.749]  $ ...future.elements_ii    :List of 1
[16:59:29.749]   ..$ : num [1:4] 2 4 6 8
[16:59:29.749]  $ ...future.seeds_ii       : NULL
[16:59:29.749]  $ ...future.globals.maxSize: num Inf
[16:59:29.749]  - attr(*, "resolved")= logi FALSE
[16:59:29.749]  - attr(*, "total_size")= num NA
[16:59:29.749]  - attr(*, "where")=List of 5
[16:59:29.749]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.749]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.749]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.749]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.749]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.749]  - attr(*, "already-done")= logi TRUE
[16:59:29.755] - copied ‘future.call.arguments’ to environment
[16:59:29.756] - copied ‘...future.FUN’ to environment
[16:59:29.756] - copied ‘...future.elements_ii’ to environment
[16:59:29.756] - copied ‘...future.seeds_ii’ to environment
[16:59:29.756] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.756] assign_globals() ... done
[16:59:29.756] requestCore(): workers = 2
[16:59:29.762] MulticoreFuture started
[16:59:29.762] - Launch lazy future ... done
[16:59:29.762] run() for ‘MulticoreFuture’ ... done
[16:59:29.762] Created future:
[16:59:29.763] plan(): Setting new future strategy stack:
[16:59:29.763] List of future strategies:
[16:59:29.763] 1. sequential:
[16:59:29.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.763]    - tweaked: FALSE
[16:59:29.763]    - call: NULL
[16:59:29.764] plan(): nbrOfWorkers() = 1
[16:59:29.766] plan(): Setting new future strategy stack:
[16:59:29.766] List of future strategies:
[16:59:29.766] 1. multicore:
[16:59:29.766]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:29.766]    - tweaked: FALSE
[16:59:29.766]    - call: plan(strategy)
[16:59:29.771] plan(): nbrOfWorkers() = 2
[16:59:29.763] MulticoreFuture:
[16:59:29.763] Label: ‘future_apply-2’
[16:59:29.763] Expression:
[16:59:29.763] {
[16:59:29.763]     do.call(function(...) {
[16:59:29.763]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.763]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.763]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.763]             on.exit(options(oopts), add = TRUE)
[16:59:29.763]         }
[16:59:29.763]         {
[16:59:29.763]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.763]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.763]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.763]             })
[16:59:29.763]         }
[16:59:29.763]     }, args = future.call.arguments)
[16:59:29.763] }
[16:59:29.763] Lazy evaluation: FALSE
[16:59:29.763] Asynchronous evaluation: TRUE
[16:59:29.763] Local evaluation: TRUE
[16:59:29.763] Environment: R_GlobalEnv
[16:59:29.763] Capture standard output: TRUE
[16:59:29.763] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.763] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.763] Packages: <none>
[16:59:29.763] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.763] Resolved: TRUE
[16:59:29.763] Value: <not collected>
[16:59:29.763] Conditions captured: <none>
[16:59:29.763] Early signaling: FALSE
[16:59:29.763] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.763] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.773] Chunk #2 of 2 ... DONE
[16:59:29.773] Launching 2 futures (chunks) ... DONE
[16:59:29.773] Resolving 2 futures (chunks) ...
[16:59:29.773] resolve() on list ...
[16:59:29.773]  recursive: 0
[16:59:29.773]  length: 2
[16:59:29.774] 
[16:59:29.774] Future #1
[16:59:29.775] result() for MulticoreFuture ...
[16:59:29.776] result() for MulticoreFuture ...
[16:59:29.777] result() for MulticoreFuture ... done
[16:59:29.777] result() for MulticoreFuture ... done
[16:59:29.777] result() for MulticoreFuture ...
[16:59:29.777] result() for MulticoreFuture ... done
[16:59:29.777] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:29.777] - nx: 2
[16:59:29.777] - relay: TRUE
[16:59:29.778] - stdout: TRUE
[16:59:29.778] - signal: TRUE
[16:59:29.778] - resignal: FALSE
[16:59:29.778] - force: TRUE
[16:59:29.778] - relayed: [n=2] FALSE, FALSE
[16:59:29.778] - queued futures: [n=2] FALSE, FALSE
[16:59:29.778]  - until=1
[16:59:29.778]  - relaying element #1
[16:59:29.779] result() for MulticoreFuture ...
[16:59:29.779] result() for MulticoreFuture ... done
[16:59:29.779] result() for MulticoreFuture ...
[16:59:29.779] result() for MulticoreFuture ... done
[16:59:29.779] result() for MulticoreFuture ...
[16:59:29.779] result() for MulticoreFuture ... done
[16:59:29.780] result() for MulticoreFuture ...
[16:59:29.780] result() for MulticoreFuture ... done
[16:59:29.780] - relayed: [n=2] TRUE, FALSE
[16:59:29.780] - queued futures: [n=2] TRUE, FALSE
[16:59:29.780] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:29.780]  length: 1 (resolved future 1)
[16:59:29.781] Future #2
[16:59:29.785] result() for MulticoreFuture ...
[16:59:29.786] result() for MulticoreFuture ...
[16:59:29.786] result() for MulticoreFuture ... done
[16:59:29.787] result() for MulticoreFuture ... done
[16:59:29.787] result() for MulticoreFuture ...
[16:59:29.787] result() for MulticoreFuture ... done
[16:59:29.787] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:29.788] - nx: 2
[16:59:29.788] - relay: TRUE
[16:59:29.788] - stdout: TRUE
[16:59:29.788] - signal: TRUE
[16:59:29.788] - resignal: FALSE
[16:59:29.788] - force: TRUE
[16:59:29.788] - relayed: [n=2] TRUE, FALSE
[16:59:29.789] - queued futures: [n=2] TRUE, FALSE
[16:59:29.789]  - until=2
[16:59:29.789]  - relaying element #2
[16:59:29.789] result() for MulticoreFuture ...
[16:59:29.789] result() for MulticoreFuture ... done
[16:59:29.789] result() for MulticoreFuture ...
[16:59:29.789] result() for MulticoreFuture ... done
[16:59:29.789] result() for MulticoreFuture ...
[16:59:29.789] result() for MulticoreFuture ... done
[16:59:29.790] result() for MulticoreFuture ...
[16:59:29.790] result() for MulticoreFuture ... done
[16:59:29.790] - relayed: [n=2] TRUE, TRUE
[16:59:29.790] - queued futures: [n=2] TRUE, TRUE
[16:59:29.790] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:29.790]  length: 0 (resolved future 2)
[16:59:29.790] Relaying remaining futures
[16:59:29.790] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.791] - nx: 2
[16:59:29.791] - relay: TRUE
[16:59:29.791] - stdout: TRUE
[16:59:29.791] - signal: TRUE
[16:59:29.791] - resignal: FALSE
[16:59:29.791] - force: TRUE
[16:59:29.791] - relayed: [n=2] TRUE, TRUE
[16:59:29.791] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:29.792] - relayed: [n=2] TRUE, TRUE
[16:59:29.792] - queued futures: [n=2] TRUE, TRUE
[16:59:29.792] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.792] resolve() on list ... DONE
[16:59:29.792] result() for MulticoreFuture ...
[16:59:29.792] result() for MulticoreFuture ... done
[16:59:29.792] result() for MulticoreFuture ...
[16:59:29.792] result() for MulticoreFuture ... done
[16:59:29.792] result() for MulticoreFuture ...
[16:59:29.792] result() for MulticoreFuture ... done
[16:59:29.793] result() for MulticoreFuture ...
[16:59:29.793] result() for MulticoreFuture ... done
[16:59:29.793]  - Number of value chunks collected: 2
[16:59:29.793] Resolving 2 futures (chunks) ... DONE
[16:59:29.793] Reducing values from 2 chunks ...
[16:59:29.793]  - Number of values collected after concatenation: 2
[16:59:29.793]  - Number of values expected: 2
[16:59:29.793] Reducing values from 2 chunks ... DONE
[16:59:29.793] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:59:29.794] getGlobalsAndPackagesXApply() ...
[16:59:29.794]  - future.globals: TRUE
[16:59:29.794] getGlobalsAndPackages() ...
[16:59:29.794] Searching for globals...
[16:59:29.831] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:59:29.831] Searching for globals ... DONE
[16:59:29.831] Resolving globals: FALSE
[16:59:29.833] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:59:29.834] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:59:29.834] - globals: [1] ‘FUN’
[16:59:29.834] 
[16:59:29.834] getGlobalsAndPackages() ... DONE
[16:59:29.834]  - globals found/used: [n=1] ‘FUN’
[16:59:29.834]  - needed namespaces: [n=0] 
[16:59:29.834] Finding globals ... DONE
[16:59:29.834]  - use_args: TRUE
[16:59:29.834]  - Getting '...' globals ...
[16:59:29.835] resolve() on list ...
[16:59:29.835]  recursive: 0
[16:59:29.835]  length: 1
[16:59:29.835]  elements: ‘...’
[16:59:29.835]  length: 0 (resolved future 1)
[16:59:29.835] resolve() on list ... DONE
[16:59:29.835]    - '...' content: [n=0] 
[16:59:29.835] List of 1
[16:59:29.835]  $ ...: list()
[16:59:29.835]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.835]  - attr(*, "where")=List of 1
[16:59:29.835]   ..$ ...:<environment: 0x55f3117e7be8> 
[16:59:29.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.835]  - attr(*, "resolved")= logi TRUE
[16:59:29.835]  - attr(*, "total_size")= num NA
[16:59:29.838]  - Getting '...' globals ... DONE
[16:59:29.838] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.838] List of 2
[16:59:29.838]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.838]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.838]  $ ...          : list()
[16:59:29.838]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.838]  - attr(*, "where")=List of 2
[16:59:29.838]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.838]   ..$ ...          :<environment: 0x55f3117e7be8> 
[16:59:29.838]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.838]  - attr(*, "resolved")= logi FALSE
[16:59:29.838]  - attr(*, "total_size")= num 354224
[16:59:29.841] Packages to be attached in all futures: [n=0] 
[16:59:29.841] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.845] future_lapply() ...
[16:59:29.883] Number of chunks: 2
[16:59:29.883] getGlobalsAndPackagesXApply() ...
[16:59:29.883]  - future.globals: <name-value list> with names ‘list()’
[16:59:29.883]  - use_args: TRUE
[16:59:29.883] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:29.883] List of 2
[16:59:29.883]  $ ...          : list()
[16:59:29.883]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.883]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.883]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.883]  - attr(*, "where")=List of 2
[16:59:29.883]   ..$ ...          :<environment: 0x55f3117e7be8> 
[16:59:29.883]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:29.883]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.883]  - attr(*, "resolved")= logi FALSE
[16:59:29.883]  - attr(*, "total_size")= num NA
[16:59:29.887] Packages to be attached in all futures: [n=0] 
[16:59:29.887] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.887] Number of futures (= number of chunks): 2
[16:59:29.888] Launching 2 futures (chunks) ...
[16:59:29.888] Chunk #1 of 2 ...
[16:59:29.888]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:29.888]  - seeds: <none>
[16:59:29.888]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.888] getGlobalsAndPackages() ...
[16:59:29.888] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.888] Resolving globals: FALSE
[16:59:29.888] Tweak future expression to call with '...' arguments ...
[16:59:29.889] {
[16:59:29.889]     do.call(function(...) {
[16:59:29.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.889]             on.exit(options(oopts), add = TRUE)
[16:59:29.889]         }
[16:59:29.889]         {
[16:59:29.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.889]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.889]             })
[16:59:29.889]         }
[16:59:29.889]     }, args = future.call.arguments)
[16:59:29.889] }
[16:59:29.889] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.889] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.889] 
[16:59:29.889] getGlobalsAndPackages() ... DONE
[16:59:29.890] run() for ‘Future’ ...
[16:59:29.890] - state: ‘created’
[16:59:29.890] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:29.894] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:29.894]   - Field: ‘label’
[16:59:29.894]   - Field: ‘local’
[16:59:29.894]   - Field: ‘owner’
[16:59:29.894]   - Field: ‘envir’
[16:59:29.894]   - Field: ‘workers’
[16:59:29.895]   - Field: ‘packages’
[16:59:29.895]   - Field: ‘gc’
[16:59:29.895]   - Field: ‘job’
[16:59:29.895]   - Field: ‘conditions’
[16:59:29.895]   - Field: ‘expr’
[16:59:29.895]   - Field: ‘uuid’
[16:59:29.895]   - Field: ‘seed’
[16:59:29.895]   - Field: ‘version’
[16:59:29.895]   - Field: ‘result’
[16:59:29.897]   - Field: ‘asynchronous’
[16:59:29.897]   - Field: ‘calls’
[16:59:29.897]   - Field: ‘globals’
[16:59:29.897]   - Field: ‘stdout’
[16:59:29.897]   - Field: ‘earlySignal’
[16:59:29.898]   - Field: ‘lazy’
[16:59:29.898]   - Field: ‘state’
[16:59:29.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:29.898] - Launch lazy future ...
[16:59:29.898] Packages needed by the future expression (n = 0): <none>
[16:59:29.898] Packages needed by future strategies (n = 0): <none>
[16:59:29.899] {
[16:59:29.899]     {
[16:59:29.899]         {
[16:59:29.899]             ...future.startTime <- base::Sys.time()
[16:59:29.899]             {
[16:59:29.899]                 {
[16:59:29.899]                   {
[16:59:29.899]                     {
[16:59:29.899]                       base::local({
[16:59:29.899]                         has_future <- base::requireNamespace("future", 
[16:59:29.899]                           quietly = TRUE)
[16:59:29.899]                         if (has_future) {
[16:59:29.899]                           ns <- base::getNamespace("future")
[16:59:29.899]                           version <- ns[[".package"]][["version"]]
[16:59:29.899]                           if (is.null(version)) 
[16:59:29.899]                             version <- utils::packageVersion("future")
[16:59:29.899]                         }
[16:59:29.899]                         else {
[16:59:29.899]                           version <- NULL
[16:59:29.899]                         }
[16:59:29.899]                         if (!has_future || version < "1.8.0") {
[16:59:29.899]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.899]                             "", base::R.version$version.string), 
[16:59:29.899]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:29.899]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.899]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.899]                               "release", "version")], collapse = " "), 
[16:59:29.899]                             hostname = base::Sys.info()[["nodename"]])
[16:59:29.899]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.899]                             info)
[16:59:29.899]                           info <- base::paste(info, collapse = "; ")
[16:59:29.899]                           if (!has_future) {
[16:59:29.899]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.899]                               info)
[16:59:29.899]                           }
[16:59:29.899]                           else {
[16:59:29.899]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.899]                               info, version)
[16:59:29.899]                           }
[16:59:29.899]                           base::stop(msg)
[16:59:29.899]                         }
[16:59:29.899]                       })
[16:59:29.899]                     }
[16:59:29.899]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:29.899]                     base::options(mc.cores = 1L)
[16:59:29.899]                   }
[16:59:29.899]                   ...future.strategy.old <- future::plan("list")
[16:59:29.899]                   options(future.plan = NULL)
[16:59:29.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.899]                 }
[16:59:29.899]                 ...future.workdir <- getwd()
[16:59:29.899]             }
[16:59:29.899]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.899]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.899]         }
[16:59:29.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.899]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.899]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.899]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.899]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.899]             base::names(...future.oldOptions))
[16:59:29.899]     }
[16:59:29.899]     if (FALSE) {
[16:59:29.899]     }
[16:59:29.899]     else {
[16:59:29.899]         if (TRUE) {
[16:59:29.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.899]                 open = "w")
[16:59:29.899]         }
[16:59:29.899]         else {
[16:59:29.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.899]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.899]         }
[16:59:29.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.899]             base::sink(type = "output", split = FALSE)
[16:59:29.899]             base::close(...future.stdout)
[16:59:29.899]         }, add = TRUE)
[16:59:29.899]     }
[16:59:29.899]     ...future.frame <- base::sys.nframe()
[16:59:29.899]     ...future.conditions <- base::list()
[16:59:29.899]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.899]     if (FALSE) {
[16:59:29.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.899]     }
[16:59:29.899]     ...future.result <- base::tryCatch({
[16:59:29.899]         base::withCallingHandlers({
[16:59:29.899]             ...future.value <- base::withVisible(base::local({
[16:59:29.899]                 withCallingHandlers({
[16:59:29.899]                   {
[16:59:29.899]                     do.call(function(...) {
[16:59:29.899]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.899]                       if (!identical(...future.globals.maxSize.org, 
[16:59:29.899]                         ...future.globals.maxSize)) {
[16:59:29.899]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.899]                         on.exit(options(oopts), add = TRUE)
[16:59:29.899]                       }
[16:59:29.899]                       {
[16:59:29.899]                         lapply(seq_along(...future.elements_ii), 
[16:59:29.899]                           FUN = function(jj) {
[16:59:29.899]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.899]                             ...future.FUN(...future.X_jj, ...)
[16:59:29.899]                           })
[16:59:29.899]                       }
[16:59:29.899]                     }, args = future.call.arguments)
[16:59:29.899]                   }
[16:59:29.899]                 }, immediateCondition = function(cond) {
[16:59:29.899]                   save_rds <- function (object, pathname, ...) 
[16:59:29.899]                   {
[16:59:29.899]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:29.899]                     if (file_test("-f", pathname_tmp)) {
[16:59:29.899]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.899]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:29.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.899]                         fi_tmp[["mtime"]])
[16:59:29.899]                     }
[16:59:29.899]                     tryCatch({
[16:59:29.899]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:29.899]                     }, error = function(ex) {
[16:59:29.899]                       msg <- conditionMessage(ex)
[16:59:29.899]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.899]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:29.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.899]                         fi_tmp[["mtime"]], msg)
[16:59:29.899]                       ex$message <- msg
[16:59:29.899]                       stop(ex)
[16:59:29.899]                     })
[16:59:29.899]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:29.899]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:29.899]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:29.899]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.899]                       fi <- file.info(pathname)
[16:59:29.899]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:29.899]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.899]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:29.899]                         fi[["size"]], fi[["mtime"]])
[16:59:29.899]                       stop(msg)
[16:59:29.899]                     }
[16:59:29.899]                     invisible(pathname)
[16:59:29.899]                   }
[16:59:29.899]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:29.899]                     rootPath = tempdir()) 
[16:59:29.899]                   {
[16:59:29.899]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:29.899]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:29.899]                       tmpdir = path, fileext = ".rds")
[16:59:29.899]                     save_rds(obj, file)
[16:59:29.899]                   }
[16:59:29.899]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:29.899]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.899]                   {
[16:59:29.899]                     inherits <- base::inherits
[16:59:29.899]                     invokeRestart <- base::invokeRestart
[16:59:29.899]                     is.null <- base::is.null
[16:59:29.899]                     muffled <- FALSE
[16:59:29.899]                     if (inherits(cond, "message")) {
[16:59:29.899]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:29.899]                       if (muffled) 
[16:59:29.899]                         invokeRestart("muffleMessage")
[16:59:29.899]                     }
[16:59:29.899]                     else if (inherits(cond, "warning")) {
[16:59:29.899]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:29.899]                       if (muffled) 
[16:59:29.899]                         invokeRestart("muffleWarning")
[16:59:29.899]                     }
[16:59:29.899]                     else if (inherits(cond, "condition")) {
[16:59:29.899]                       if (!is.null(pattern)) {
[16:59:29.899]                         computeRestarts <- base::computeRestarts
[16:59:29.899]                         grepl <- base::grepl
[16:59:29.899]                         restarts <- computeRestarts(cond)
[16:59:29.899]                         for (restart in restarts) {
[16:59:29.899]                           name <- restart$name
[16:59:29.899]                           if (is.null(name)) 
[16:59:29.899]                             next
[16:59:29.899]                           if (!grepl(pattern, name)) 
[16:59:29.899]                             next
[16:59:29.899]                           invokeRestart(restart)
[16:59:29.899]                           muffled <- TRUE
[16:59:29.899]                           break
[16:59:29.899]                         }
[16:59:29.899]                       }
[16:59:29.899]                     }
[16:59:29.899]                     invisible(muffled)
[16:59:29.899]                   }
[16:59:29.899]                   muffleCondition(cond)
[16:59:29.899]                 })
[16:59:29.899]             }))
[16:59:29.899]             future::FutureResult(value = ...future.value$value, 
[16:59:29.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.899]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.899]                     ...future.globalenv.names))
[16:59:29.899]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.899]         }, condition = base::local({
[16:59:29.899]             c <- base::c
[16:59:29.899]             inherits <- base::inherits
[16:59:29.899]             invokeRestart <- base::invokeRestart
[16:59:29.899]             length <- base::length
[16:59:29.899]             list <- base::list
[16:59:29.899]             seq.int <- base::seq.int
[16:59:29.899]             signalCondition <- base::signalCondition
[16:59:29.899]             sys.calls <- base::sys.calls
[16:59:29.899]             `[[` <- base::`[[`
[16:59:29.899]             `+` <- base::`+`
[16:59:29.899]             `<<-` <- base::`<<-`
[16:59:29.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.899]                   3L)]
[16:59:29.899]             }
[16:59:29.899]             function(cond) {
[16:59:29.899]                 is_error <- inherits(cond, "error")
[16:59:29.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.899]                   NULL)
[16:59:29.899]                 if (is_error) {
[16:59:29.899]                   sessionInformation <- function() {
[16:59:29.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.899]                       search = base::search(), system = base::Sys.info())
[16:59:29.899]                   }
[16:59:29.899]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.899]                     cond$call), session = sessionInformation(), 
[16:59:29.899]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.899]                   signalCondition(cond)
[16:59:29.899]                 }
[16:59:29.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.899]                 "immediateCondition"))) {
[16:59:29.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.899]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.899]                   if (TRUE && !signal) {
[16:59:29.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.899]                     {
[16:59:29.899]                       inherits <- base::inherits
[16:59:29.899]                       invokeRestart <- base::invokeRestart
[16:59:29.899]                       is.null <- base::is.null
[16:59:29.899]                       muffled <- FALSE
[16:59:29.899]                       if (inherits(cond, "message")) {
[16:59:29.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.899]                         if (muffled) 
[16:59:29.899]                           invokeRestart("muffleMessage")
[16:59:29.899]                       }
[16:59:29.899]                       else if (inherits(cond, "warning")) {
[16:59:29.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.899]                         if (muffled) 
[16:59:29.899]                           invokeRestart("muffleWarning")
[16:59:29.899]                       }
[16:59:29.899]                       else if (inherits(cond, "condition")) {
[16:59:29.899]                         if (!is.null(pattern)) {
[16:59:29.899]                           computeRestarts <- base::computeRestarts
[16:59:29.899]                           grepl <- base::grepl
[16:59:29.899]                           restarts <- computeRestarts(cond)
[16:59:29.899]                           for (restart in restarts) {
[16:59:29.899]                             name <- restart$name
[16:59:29.899]                             if (is.null(name)) 
[16:59:29.899]                               next
[16:59:29.899]                             if (!grepl(pattern, name)) 
[16:59:29.899]                               next
[16:59:29.899]                             invokeRestart(restart)
[16:59:29.899]                             muffled <- TRUE
[16:59:29.899]                             break
[16:59:29.899]                           }
[16:59:29.899]                         }
[16:59:29.899]                       }
[16:59:29.899]                       invisible(muffled)
[16:59:29.899]                     }
[16:59:29.899]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.899]                   }
[16:59:29.899]                 }
[16:59:29.899]                 else {
[16:59:29.899]                   if (TRUE) {
[16:59:29.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.899]                     {
[16:59:29.899]                       inherits <- base::inherits
[16:59:29.899]                       invokeRestart <- base::invokeRestart
[16:59:29.899]                       is.null <- base::is.null
[16:59:29.899]                       muffled <- FALSE
[16:59:29.899]                       if (inherits(cond, "message")) {
[16:59:29.899]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.899]                         if (muffled) 
[16:59:29.899]                           invokeRestart("muffleMessage")
[16:59:29.899]                       }
[16:59:29.899]                       else if (inherits(cond, "warning")) {
[16:59:29.899]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.899]                         if (muffled) 
[16:59:29.899]                           invokeRestart("muffleWarning")
[16:59:29.899]                       }
[16:59:29.899]                       else if (inherits(cond, "condition")) {
[16:59:29.899]                         if (!is.null(pattern)) {
[16:59:29.899]                           computeRestarts <- base::computeRestarts
[16:59:29.899]                           grepl <- base::grepl
[16:59:29.899]                           restarts <- computeRestarts(cond)
[16:59:29.899]                           for (restart in restarts) {
[16:59:29.899]                             name <- restart$name
[16:59:29.899]                             if (is.null(name)) 
[16:59:29.899]                               next
[16:59:29.899]                             if (!grepl(pattern, name)) 
[16:59:29.899]                               next
[16:59:29.899]                             invokeRestart(restart)
[16:59:29.899]                             muffled <- TRUE
[16:59:29.899]                             break
[16:59:29.899]                           }
[16:59:29.899]                         }
[16:59:29.899]                       }
[16:59:29.899]                       invisible(muffled)
[16:59:29.899]                     }
[16:59:29.899]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.899]                   }
[16:59:29.899]                 }
[16:59:29.899]             }
[16:59:29.899]         }))
[16:59:29.899]     }, error = function(ex) {
[16:59:29.899]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.899]                 ...future.rng), started = ...future.startTime, 
[16:59:29.899]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.899]             version = "1.8"), class = "FutureResult")
[16:59:29.899]     }, finally = {
[16:59:29.899]         if (!identical(...future.workdir, getwd())) 
[16:59:29.899]             setwd(...future.workdir)
[16:59:29.899]         {
[16:59:29.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.899]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.899]             }
[16:59:29.899]             base::options(...future.oldOptions)
[16:59:29.899]             if (.Platform$OS.type == "windows") {
[16:59:29.899]                 old_names <- names(...future.oldEnvVars)
[16:59:29.899]                 envs <- base::Sys.getenv()
[16:59:29.899]                 names <- names(envs)
[16:59:29.899]                 common <- intersect(names, old_names)
[16:59:29.899]                 added <- setdiff(names, old_names)
[16:59:29.899]                 removed <- setdiff(old_names, names)
[16:59:29.899]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.899]                   envs[common]]
[16:59:29.899]                 NAMES <- toupper(changed)
[16:59:29.899]                 args <- list()
[16:59:29.899]                 for (kk in seq_along(NAMES)) {
[16:59:29.899]                   name <- changed[[kk]]
[16:59:29.899]                   NAME <- NAMES[[kk]]
[16:59:29.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.899]                     next
[16:59:29.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.899]                 }
[16:59:29.899]                 NAMES <- toupper(added)
[16:59:29.899]                 for (kk in seq_along(NAMES)) {
[16:59:29.899]                   name <- added[[kk]]
[16:59:29.899]                   NAME <- NAMES[[kk]]
[16:59:29.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.899]                     next
[16:59:29.899]                   args[[name]] <- ""
[16:59:29.899]                 }
[16:59:29.899]                 NAMES <- toupper(removed)
[16:59:29.899]                 for (kk in seq_along(NAMES)) {
[16:59:29.899]                   name <- removed[[kk]]
[16:59:29.899]                   NAME <- NAMES[[kk]]
[16:59:29.899]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.899]                     next
[16:59:29.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.899]                 }
[16:59:29.899]                 if (length(args) > 0) 
[16:59:29.899]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.899]             }
[16:59:29.899]             else {
[16:59:29.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.899]             }
[16:59:29.899]             {
[16:59:29.899]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.899]                   0L) {
[16:59:29.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.899]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.899]                   base::options(opts)
[16:59:29.899]                 }
[16:59:29.899]                 {
[16:59:29.899]                   {
[16:59:29.899]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:29.899]                     NULL
[16:59:29.899]                   }
[16:59:29.899]                   options(future.plan = NULL)
[16:59:29.899]                   if (is.na(NA_character_)) 
[16:59:29.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.899]                     .init = FALSE)
[16:59:29.899]                 }
[16:59:29.899]             }
[16:59:29.899]         }
[16:59:29.899]     })
[16:59:29.899]     if (TRUE) {
[16:59:29.899]         base::sink(type = "output", split = FALSE)
[16:59:29.899]         if (TRUE) {
[16:59:29.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.899]         }
[16:59:29.899]         else {
[16:59:29.899]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.899]         }
[16:59:29.899]         base::close(...future.stdout)
[16:59:29.899]         ...future.stdout <- NULL
[16:59:29.899]     }
[16:59:29.899]     ...future.result$conditions <- ...future.conditions
[16:59:29.899]     ...future.result$finished <- base::Sys.time()
[16:59:29.899]     ...future.result
[16:59:29.899] }
[16:59:29.901] assign_globals() ...
[16:59:29.901] List of 5
[16:59:29.901]  $ future.call.arguments    : list()
[16:59:29.901]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.901]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.901]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.901]  $ ...future.elements_ii    :List of 1
[16:59:29.901]   ..$ : num [1:4] 1 3 1 7
[16:59:29.901]  $ ...future.seeds_ii       : NULL
[16:59:29.901]  $ ...future.globals.maxSize: num Inf
[16:59:29.901]  - attr(*, "resolved")= logi FALSE
[16:59:29.901]  - attr(*, "total_size")= num NA
[16:59:29.901]  - attr(*, "where")=List of 5
[16:59:29.901]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.901]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.901]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.901]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.901]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.901]  - attr(*, "already-done")= logi TRUE
[16:59:29.906] - copied ‘future.call.arguments’ to environment
[16:59:29.906] - copied ‘...future.FUN’ to environment
[16:59:29.906] - copied ‘...future.elements_ii’ to environment
[16:59:29.906] - copied ‘...future.seeds_ii’ to environment
[16:59:29.907] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.907] assign_globals() ... done
[16:59:29.907] requestCore(): workers = 2
[16:59:29.909] MulticoreFuture started
[16:59:29.909] - Launch lazy future ... done
[16:59:29.910] run() for ‘MulticoreFuture’ ... done
[16:59:29.910] Created future:
[16:59:29.910] plan(): Setting new future strategy stack:
[16:59:29.910] List of future strategies:
[16:59:29.910] 1. sequential:
[16:59:29.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.910]    - tweaked: FALSE
[16:59:29.910]    - call: NULL
[16:59:29.911] plan(): nbrOfWorkers() = 1
[16:59:29.914] plan(): Setting new future strategy stack:
[16:59:29.914] List of future strategies:
[16:59:29.914] 1. multicore:
[16:59:29.914]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:29.914]    - tweaked: FALSE
[16:59:29.914]    - call: plan(strategy)
[16:59:29.919] plan(): nbrOfWorkers() = 2
[16:59:29.910] MulticoreFuture:
[16:59:29.910] Label: ‘future_apply-1’
[16:59:29.910] Expression:
[16:59:29.910] {
[16:59:29.910]     do.call(function(...) {
[16:59:29.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.910]             on.exit(options(oopts), add = TRUE)
[16:59:29.910]         }
[16:59:29.910]         {
[16:59:29.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.910]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.910]             })
[16:59:29.910]         }
[16:59:29.910]     }, args = future.call.arguments)
[16:59:29.910] }
[16:59:29.910] Lazy evaluation: FALSE
[16:59:29.910] Asynchronous evaluation: TRUE
[16:59:29.910] Local evaluation: TRUE
[16:59:29.910] Environment: R_GlobalEnv
[16:59:29.910] Capture standard output: TRUE
[16:59:29.910] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.910] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.910] Packages: <none>
[16:59:29.910] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.910] Resolved: TRUE
[16:59:29.910] Value: <not collected>
[16:59:29.910] Conditions captured: <none>
[16:59:29.910] Early signaling: FALSE
[16:59:29.910] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.910] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.920] Chunk #1 of 2 ... DONE
[16:59:29.920] Chunk #2 of 2 ...
[16:59:29.921]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:29.921]  - seeds: <none>
[16:59:29.921]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.921] getGlobalsAndPackages() ...
[16:59:29.921] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.922] Resolving globals: FALSE
[16:59:29.922] Tweak future expression to call with '...' arguments ...
[16:59:29.922] {
[16:59:29.922]     do.call(function(...) {
[16:59:29.922]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.922]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.922]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.922]             on.exit(options(oopts), add = TRUE)
[16:59:29.922]         }
[16:59:29.922]         {
[16:59:29.922]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.922]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.922]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.922]             })
[16:59:29.922]         }
[16:59:29.922]     }, args = future.call.arguments)
[16:59:29.922] }
[16:59:29.922] Tweak future expression to call with '...' arguments ... DONE
[16:59:29.923] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:29.923] 
[16:59:29.923] getGlobalsAndPackages() ... DONE
[16:59:29.924] run() for ‘Future’ ...
[16:59:29.924] - state: ‘created’
[16:59:29.924] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:29.929] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.929] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:29.929]   - Field: ‘label’
[16:59:29.930]   - Field: ‘local’
[16:59:29.930]   - Field: ‘owner’
[16:59:29.930]   - Field: ‘envir’
[16:59:29.930]   - Field: ‘workers’
[16:59:29.930]   - Field: ‘packages’
[16:59:29.930]   - Field: ‘gc’
[16:59:29.930]   - Field: ‘job’
[16:59:29.931]   - Field: ‘conditions’
[16:59:29.931]   - Field: ‘expr’
[16:59:29.931]   - Field: ‘uuid’
[16:59:29.931]   - Field: ‘seed’
[16:59:29.931]   - Field: ‘version’
[16:59:29.931]   - Field: ‘result’
[16:59:29.932]   - Field: ‘asynchronous’
[16:59:29.932]   - Field: ‘calls’
[16:59:29.932]   - Field: ‘globals’
[16:59:29.932]   - Field: ‘stdout’
[16:59:29.932]   - Field: ‘earlySignal’
[16:59:29.932]   - Field: ‘lazy’
[16:59:29.932]   - Field: ‘state’
[16:59:29.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:29.933] - Launch lazy future ...
[16:59:29.933] Packages needed by the future expression (n = 0): <none>
[16:59:29.933] Packages needed by future strategies (n = 0): <none>
[16:59:29.934] {
[16:59:29.934]     {
[16:59:29.934]         {
[16:59:29.934]             ...future.startTime <- base::Sys.time()
[16:59:29.934]             {
[16:59:29.934]                 {
[16:59:29.934]                   {
[16:59:29.934]                     {
[16:59:29.934]                       base::local({
[16:59:29.934]                         has_future <- base::requireNamespace("future", 
[16:59:29.934]                           quietly = TRUE)
[16:59:29.934]                         if (has_future) {
[16:59:29.934]                           ns <- base::getNamespace("future")
[16:59:29.934]                           version <- ns[[".package"]][["version"]]
[16:59:29.934]                           if (is.null(version)) 
[16:59:29.934]                             version <- utils::packageVersion("future")
[16:59:29.934]                         }
[16:59:29.934]                         else {
[16:59:29.934]                           version <- NULL
[16:59:29.934]                         }
[16:59:29.934]                         if (!has_future || version < "1.8.0") {
[16:59:29.934]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:29.934]                             "", base::R.version$version.string), 
[16:59:29.934]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:29.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:29.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:29.934]                               "release", "version")], collapse = " "), 
[16:59:29.934]                             hostname = base::Sys.info()[["nodename"]])
[16:59:29.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:29.934]                             info)
[16:59:29.934]                           info <- base::paste(info, collapse = "; ")
[16:59:29.934]                           if (!has_future) {
[16:59:29.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:29.934]                               info)
[16:59:29.934]                           }
[16:59:29.934]                           else {
[16:59:29.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:29.934]                               info, version)
[16:59:29.934]                           }
[16:59:29.934]                           base::stop(msg)
[16:59:29.934]                         }
[16:59:29.934]                       })
[16:59:29.934]                     }
[16:59:29.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:29.934]                     base::options(mc.cores = 1L)
[16:59:29.934]                   }
[16:59:29.934]                   ...future.strategy.old <- future::plan("list")
[16:59:29.934]                   options(future.plan = NULL)
[16:59:29.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:29.934]                 }
[16:59:29.934]                 ...future.workdir <- getwd()
[16:59:29.934]             }
[16:59:29.934]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:29.934]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:29.934]         }
[16:59:29.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:29.934]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:29.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:29.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:29.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:29.934]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:29.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:29.934]             base::names(...future.oldOptions))
[16:59:29.934]     }
[16:59:29.934]     if (FALSE) {
[16:59:29.934]     }
[16:59:29.934]     else {
[16:59:29.934]         if (TRUE) {
[16:59:29.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:29.934]                 open = "w")
[16:59:29.934]         }
[16:59:29.934]         else {
[16:59:29.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:29.934]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:29.934]         }
[16:59:29.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:29.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:29.934]             base::sink(type = "output", split = FALSE)
[16:59:29.934]             base::close(...future.stdout)
[16:59:29.934]         }, add = TRUE)
[16:59:29.934]     }
[16:59:29.934]     ...future.frame <- base::sys.nframe()
[16:59:29.934]     ...future.conditions <- base::list()
[16:59:29.934]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:29.934]     if (FALSE) {
[16:59:29.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:29.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:29.934]     }
[16:59:29.934]     ...future.result <- base::tryCatch({
[16:59:29.934]         base::withCallingHandlers({
[16:59:29.934]             ...future.value <- base::withVisible(base::local({
[16:59:29.934]                 withCallingHandlers({
[16:59:29.934]                   {
[16:59:29.934]                     do.call(function(...) {
[16:59:29.934]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.934]                       if (!identical(...future.globals.maxSize.org, 
[16:59:29.934]                         ...future.globals.maxSize)) {
[16:59:29.934]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.934]                         on.exit(options(oopts), add = TRUE)
[16:59:29.934]                       }
[16:59:29.934]                       {
[16:59:29.934]                         lapply(seq_along(...future.elements_ii), 
[16:59:29.934]                           FUN = function(jj) {
[16:59:29.934]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.934]                             ...future.FUN(...future.X_jj, ...)
[16:59:29.934]                           })
[16:59:29.934]                       }
[16:59:29.934]                     }, args = future.call.arguments)
[16:59:29.934]                   }
[16:59:29.934]                 }, immediateCondition = function(cond) {
[16:59:29.934]                   save_rds <- function (object, pathname, ...) 
[16:59:29.934]                   {
[16:59:29.934]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:29.934]                     if (file_test("-f", pathname_tmp)) {
[16:59:29.934]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.934]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:29.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.934]                         fi_tmp[["mtime"]])
[16:59:29.934]                     }
[16:59:29.934]                     tryCatch({
[16:59:29.934]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:29.934]                     }, error = function(ex) {
[16:59:29.934]                       msg <- conditionMessage(ex)
[16:59:29.934]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.934]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:29.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.934]                         fi_tmp[["mtime"]], msg)
[16:59:29.934]                       ex$message <- msg
[16:59:29.934]                       stop(ex)
[16:59:29.934]                     })
[16:59:29.934]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:29.934]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:29.934]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:29.934]                       fi_tmp <- file.info(pathname_tmp)
[16:59:29.934]                       fi <- file.info(pathname)
[16:59:29.934]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:29.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:29.934]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:29.934]                         fi[["size"]], fi[["mtime"]])
[16:59:29.934]                       stop(msg)
[16:59:29.934]                     }
[16:59:29.934]                     invisible(pathname)
[16:59:29.934]                   }
[16:59:29.934]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:29.934]                     rootPath = tempdir()) 
[16:59:29.934]                   {
[16:59:29.934]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:29.934]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:29.934]                       tmpdir = path, fileext = ".rds")
[16:59:29.934]                     save_rds(obj, file)
[16:59:29.934]                   }
[16:59:29.934]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:29.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.934]                   {
[16:59:29.934]                     inherits <- base::inherits
[16:59:29.934]                     invokeRestart <- base::invokeRestart
[16:59:29.934]                     is.null <- base::is.null
[16:59:29.934]                     muffled <- FALSE
[16:59:29.934]                     if (inherits(cond, "message")) {
[16:59:29.934]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:29.934]                       if (muffled) 
[16:59:29.934]                         invokeRestart("muffleMessage")
[16:59:29.934]                     }
[16:59:29.934]                     else if (inherits(cond, "warning")) {
[16:59:29.934]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:29.934]                       if (muffled) 
[16:59:29.934]                         invokeRestart("muffleWarning")
[16:59:29.934]                     }
[16:59:29.934]                     else if (inherits(cond, "condition")) {
[16:59:29.934]                       if (!is.null(pattern)) {
[16:59:29.934]                         computeRestarts <- base::computeRestarts
[16:59:29.934]                         grepl <- base::grepl
[16:59:29.934]                         restarts <- computeRestarts(cond)
[16:59:29.934]                         for (restart in restarts) {
[16:59:29.934]                           name <- restart$name
[16:59:29.934]                           if (is.null(name)) 
[16:59:29.934]                             next
[16:59:29.934]                           if (!grepl(pattern, name)) 
[16:59:29.934]                             next
[16:59:29.934]                           invokeRestart(restart)
[16:59:29.934]                           muffled <- TRUE
[16:59:29.934]                           break
[16:59:29.934]                         }
[16:59:29.934]                       }
[16:59:29.934]                     }
[16:59:29.934]                     invisible(muffled)
[16:59:29.934]                   }
[16:59:29.934]                   muffleCondition(cond)
[16:59:29.934]                 })
[16:59:29.934]             }))
[16:59:29.934]             future::FutureResult(value = ...future.value$value, 
[16:59:29.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.934]                   ...future.rng), globalenv = if (FALSE) 
[16:59:29.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:29.934]                     ...future.globalenv.names))
[16:59:29.934]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:29.934]         }, condition = base::local({
[16:59:29.934]             c <- base::c
[16:59:29.934]             inherits <- base::inherits
[16:59:29.934]             invokeRestart <- base::invokeRestart
[16:59:29.934]             length <- base::length
[16:59:29.934]             list <- base::list
[16:59:29.934]             seq.int <- base::seq.int
[16:59:29.934]             signalCondition <- base::signalCondition
[16:59:29.934]             sys.calls <- base::sys.calls
[16:59:29.934]             `[[` <- base::`[[`
[16:59:29.934]             `+` <- base::`+`
[16:59:29.934]             `<<-` <- base::`<<-`
[16:59:29.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:29.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:29.934]                   3L)]
[16:59:29.934]             }
[16:59:29.934]             function(cond) {
[16:59:29.934]                 is_error <- inherits(cond, "error")
[16:59:29.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:29.934]                   NULL)
[16:59:29.934]                 if (is_error) {
[16:59:29.934]                   sessionInformation <- function() {
[16:59:29.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:29.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:29.934]                       search = base::search(), system = base::Sys.info())
[16:59:29.934]                   }
[16:59:29.934]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:29.934]                     cond$call), session = sessionInformation(), 
[16:59:29.934]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:29.934]                   signalCondition(cond)
[16:59:29.934]                 }
[16:59:29.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:29.934]                 "immediateCondition"))) {
[16:59:29.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:29.934]                   ...future.conditions[[length(...future.conditions) + 
[16:59:29.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:29.934]                   if (TRUE && !signal) {
[16:59:29.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.934]                     {
[16:59:29.934]                       inherits <- base::inherits
[16:59:29.934]                       invokeRestart <- base::invokeRestart
[16:59:29.934]                       is.null <- base::is.null
[16:59:29.934]                       muffled <- FALSE
[16:59:29.934]                       if (inherits(cond, "message")) {
[16:59:29.934]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.934]                         if (muffled) 
[16:59:29.934]                           invokeRestart("muffleMessage")
[16:59:29.934]                       }
[16:59:29.934]                       else if (inherits(cond, "warning")) {
[16:59:29.934]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.934]                         if (muffled) 
[16:59:29.934]                           invokeRestart("muffleWarning")
[16:59:29.934]                       }
[16:59:29.934]                       else if (inherits(cond, "condition")) {
[16:59:29.934]                         if (!is.null(pattern)) {
[16:59:29.934]                           computeRestarts <- base::computeRestarts
[16:59:29.934]                           grepl <- base::grepl
[16:59:29.934]                           restarts <- computeRestarts(cond)
[16:59:29.934]                           for (restart in restarts) {
[16:59:29.934]                             name <- restart$name
[16:59:29.934]                             if (is.null(name)) 
[16:59:29.934]                               next
[16:59:29.934]                             if (!grepl(pattern, name)) 
[16:59:29.934]                               next
[16:59:29.934]                             invokeRestart(restart)
[16:59:29.934]                             muffled <- TRUE
[16:59:29.934]                             break
[16:59:29.934]                           }
[16:59:29.934]                         }
[16:59:29.934]                       }
[16:59:29.934]                       invisible(muffled)
[16:59:29.934]                     }
[16:59:29.934]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.934]                   }
[16:59:29.934]                 }
[16:59:29.934]                 else {
[16:59:29.934]                   if (TRUE) {
[16:59:29.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:29.934]                     {
[16:59:29.934]                       inherits <- base::inherits
[16:59:29.934]                       invokeRestart <- base::invokeRestart
[16:59:29.934]                       is.null <- base::is.null
[16:59:29.934]                       muffled <- FALSE
[16:59:29.934]                       if (inherits(cond, "message")) {
[16:59:29.934]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:29.934]                         if (muffled) 
[16:59:29.934]                           invokeRestart("muffleMessage")
[16:59:29.934]                       }
[16:59:29.934]                       else if (inherits(cond, "warning")) {
[16:59:29.934]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:29.934]                         if (muffled) 
[16:59:29.934]                           invokeRestart("muffleWarning")
[16:59:29.934]                       }
[16:59:29.934]                       else if (inherits(cond, "condition")) {
[16:59:29.934]                         if (!is.null(pattern)) {
[16:59:29.934]                           computeRestarts <- base::computeRestarts
[16:59:29.934]                           grepl <- base::grepl
[16:59:29.934]                           restarts <- computeRestarts(cond)
[16:59:29.934]                           for (restart in restarts) {
[16:59:29.934]                             name <- restart$name
[16:59:29.934]                             if (is.null(name)) 
[16:59:29.934]                               next
[16:59:29.934]                             if (!grepl(pattern, name)) 
[16:59:29.934]                               next
[16:59:29.934]                             invokeRestart(restart)
[16:59:29.934]                             muffled <- TRUE
[16:59:29.934]                             break
[16:59:29.934]                           }
[16:59:29.934]                         }
[16:59:29.934]                       }
[16:59:29.934]                       invisible(muffled)
[16:59:29.934]                     }
[16:59:29.934]                     muffleCondition(cond, pattern = "^muffle")
[16:59:29.934]                   }
[16:59:29.934]                 }
[16:59:29.934]             }
[16:59:29.934]         }))
[16:59:29.934]     }, error = function(ex) {
[16:59:29.934]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:29.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:29.934]                 ...future.rng), started = ...future.startTime, 
[16:59:29.934]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:29.934]             version = "1.8"), class = "FutureResult")
[16:59:29.934]     }, finally = {
[16:59:29.934]         if (!identical(...future.workdir, getwd())) 
[16:59:29.934]             setwd(...future.workdir)
[16:59:29.934]         {
[16:59:29.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:29.934]                 ...future.oldOptions$nwarnings <- NULL
[16:59:29.934]             }
[16:59:29.934]             base::options(...future.oldOptions)
[16:59:29.934]             if (.Platform$OS.type == "windows") {
[16:59:29.934]                 old_names <- names(...future.oldEnvVars)
[16:59:29.934]                 envs <- base::Sys.getenv()
[16:59:29.934]                 names <- names(envs)
[16:59:29.934]                 common <- intersect(names, old_names)
[16:59:29.934]                 added <- setdiff(names, old_names)
[16:59:29.934]                 removed <- setdiff(old_names, names)
[16:59:29.934]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:29.934]                   envs[common]]
[16:59:29.934]                 NAMES <- toupper(changed)
[16:59:29.934]                 args <- list()
[16:59:29.934]                 for (kk in seq_along(NAMES)) {
[16:59:29.934]                   name <- changed[[kk]]
[16:59:29.934]                   NAME <- NAMES[[kk]]
[16:59:29.934]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.934]                     next
[16:59:29.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.934]                 }
[16:59:29.934]                 NAMES <- toupper(added)
[16:59:29.934]                 for (kk in seq_along(NAMES)) {
[16:59:29.934]                   name <- added[[kk]]
[16:59:29.934]                   NAME <- NAMES[[kk]]
[16:59:29.934]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.934]                     next
[16:59:29.934]                   args[[name]] <- ""
[16:59:29.934]                 }
[16:59:29.934]                 NAMES <- toupper(removed)
[16:59:29.934]                 for (kk in seq_along(NAMES)) {
[16:59:29.934]                   name <- removed[[kk]]
[16:59:29.934]                   NAME <- NAMES[[kk]]
[16:59:29.934]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:29.934]                     next
[16:59:29.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:29.934]                 }
[16:59:29.934]                 if (length(args) > 0) 
[16:59:29.934]                   base::do.call(base::Sys.setenv, args = args)
[16:59:29.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:29.934]             }
[16:59:29.934]             else {
[16:59:29.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:29.934]             }
[16:59:29.934]             {
[16:59:29.934]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:29.934]                   0L) {
[16:59:29.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:29.934]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:29.934]                   base::options(opts)
[16:59:29.934]                 }
[16:59:29.934]                 {
[16:59:29.934]                   {
[16:59:29.934]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:29.934]                     NULL
[16:59:29.934]                   }
[16:59:29.934]                   options(future.plan = NULL)
[16:59:29.934]                   if (is.na(NA_character_)) 
[16:59:29.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:29.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:29.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:29.934]                     .init = FALSE)
[16:59:29.934]                 }
[16:59:29.934]             }
[16:59:29.934]         }
[16:59:29.934]     })
[16:59:29.934]     if (TRUE) {
[16:59:29.934]         base::sink(type = "output", split = FALSE)
[16:59:29.934]         if (TRUE) {
[16:59:29.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:29.934]         }
[16:59:29.934]         else {
[16:59:29.934]             ...future.result["stdout"] <- base::list(NULL)
[16:59:29.934]         }
[16:59:29.934]         base::close(...future.stdout)
[16:59:29.934]         ...future.stdout <- NULL
[16:59:29.934]     }
[16:59:29.934]     ...future.result$conditions <- ...future.conditions
[16:59:29.934]     ...future.result$finished <- base::Sys.time()
[16:59:29.934]     ...future.result
[16:59:29.934] }
[16:59:29.937] assign_globals() ...
[16:59:29.937] List of 5
[16:59:29.937]  $ future.call.arguments    : list()
[16:59:29.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.937]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:29.937]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:29.937]  $ ...future.elements_ii    :List of 1
[16:59:29.937]   ..$ : num [1:4] 2 4 6 8
[16:59:29.937]  $ ...future.seeds_ii       : NULL
[16:59:29.937]  $ ...future.globals.maxSize: num Inf
[16:59:29.937]  - attr(*, "resolved")= logi FALSE
[16:59:29.937]  - attr(*, "total_size")= num NA
[16:59:29.937]  - attr(*, "where")=List of 5
[16:59:29.937]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:29.937]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:29.937]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:29.937]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:29.937]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:29.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.937]  - attr(*, "already-done")= logi TRUE
[16:59:29.947] - copied ‘future.call.arguments’ to environment
[16:59:29.948] - copied ‘...future.FUN’ to environment
[16:59:29.948] - copied ‘...future.elements_ii’ to environment
[16:59:29.948] - copied ‘...future.seeds_ii’ to environment
[16:59:29.949] - copied ‘...future.globals.maxSize’ to environment
[16:59:29.949] assign_globals() ... done
[16:59:29.949] requestCore(): workers = 2
[16:59:29.952] MulticoreFuture started
[16:59:29.952] - Launch lazy future ... done
[16:59:29.953] run() for ‘MulticoreFuture’ ... done
[16:59:29.953] plan(): Setting new future strategy stack:
[16:59:29.954] Created future:
[16:59:29.953] List of future strategies:
[16:59:29.953] 1. sequential:
[16:59:29.953]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:29.953]    - tweaked: FALSE
[16:59:29.953]    - call: NULL
[16:59:29.955] plan(): nbrOfWorkers() = 1
[16:59:29.957] plan(): Setting new future strategy stack:
[16:59:29.958] List of future strategies:
[16:59:29.958] 1. multicore:
[16:59:29.958]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:29.958]    - tweaked: FALSE
[16:59:29.958]    - call: plan(strategy)
[16:59:29.963] plan(): nbrOfWorkers() = 2
[16:59:29.954] MulticoreFuture:
[16:59:29.954] Label: ‘future_apply-2’
[16:59:29.954] Expression:
[16:59:29.954] {
[16:59:29.954]     do.call(function(...) {
[16:59:29.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:29.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:29.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:29.954]             on.exit(options(oopts), add = TRUE)
[16:59:29.954]         }
[16:59:29.954]         {
[16:59:29.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:29.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:29.954]                 ...future.FUN(...future.X_jj, ...)
[16:59:29.954]             })
[16:59:29.954]         }
[16:59:29.954]     }, args = future.call.arguments)
[16:59:29.954] }
[16:59:29.954] Lazy evaluation: FALSE
[16:59:29.954] Asynchronous evaluation: TRUE
[16:59:29.954] Local evaluation: TRUE
[16:59:29.954] Environment: R_GlobalEnv
[16:59:29.954] Capture standard output: TRUE
[16:59:29.954] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:29.954] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:29.954] Packages: <none>
[16:59:29.954] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:29.954] Resolved: TRUE
[16:59:29.954] Value: <not collected>
[16:59:29.954] Conditions captured: <none>
[16:59:29.954] Early signaling: FALSE
[16:59:29.954] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:29.954] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:29.964] Chunk #2 of 2 ... DONE
[16:59:29.964] Launching 2 futures (chunks) ... DONE
[16:59:29.964] Resolving 2 futures (chunks) ...
[16:59:29.965] resolve() on list ...
[16:59:29.965]  recursive: 0
[16:59:29.965]  length: 2
[16:59:29.966] 
[16:59:29.966] Future #1
[16:59:29.966] result() for MulticoreFuture ...
[16:59:29.967] result() for MulticoreFuture ...
[16:59:29.967] result() for MulticoreFuture ... done
[16:59:29.967] result() for MulticoreFuture ... done
[16:59:29.968] result() for MulticoreFuture ...
[16:59:29.968] result() for MulticoreFuture ... done
[16:59:29.968] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:29.968] - nx: 2
[16:59:29.968] - relay: TRUE
[16:59:29.969] - stdout: TRUE
[16:59:29.969] - signal: TRUE
[16:59:29.969] - resignal: FALSE
[16:59:29.969] - force: TRUE
[16:59:29.969] - relayed: [n=2] FALSE, FALSE
[16:59:29.969] - queued futures: [n=2] FALSE, FALSE
[16:59:29.969]  - until=1
[16:59:29.970]  - relaying element #1
[16:59:29.970] result() for MulticoreFuture ...
[16:59:29.970] result() for MulticoreFuture ... done
[16:59:29.970] result() for MulticoreFuture ...
[16:59:29.970] result() for MulticoreFuture ... done
[16:59:29.970] result() for MulticoreFuture ...
[16:59:29.971] result() for MulticoreFuture ... done
[16:59:29.971] result() for MulticoreFuture ...
[16:59:29.971] result() for MulticoreFuture ... done
[16:59:29.971] - relayed: [n=2] TRUE, FALSE
[16:59:29.971] - queued futures: [n=2] TRUE, FALSE
[16:59:29.971] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:29.971]  length: 1 (resolved future 1)
[16:59:29.972] Future #2
[16:59:29.972] result() for MulticoreFuture ...
[16:59:29.973] result() for MulticoreFuture ...
[16:59:29.973] result() for MulticoreFuture ... done
[16:59:29.973] result() for MulticoreFuture ... done
[16:59:29.973] result() for MulticoreFuture ...
[16:59:29.973] result() for MulticoreFuture ... done
[16:59:29.973] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:29.973] - nx: 2
[16:59:29.974] - relay: TRUE
[16:59:29.974] - stdout: TRUE
[16:59:29.974] - signal: TRUE
[16:59:29.974] - resignal: FALSE
[16:59:29.974] - force: TRUE
[16:59:29.974] - relayed: [n=2] TRUE, FALSE
[16:59:29.974] - queued futures: [n=2] TRUE, FALSE
[16:59:29.974]  - until=2
[16:59:29.975]  - relaying element #2
[16:59:29.975] result() for MulticoreFuture ...
[16:59:29.975] result() for MulticoreFuture ... done
[16:59:29.975] result() for MulticoreFuture ...
[16:59:29.975] result() for MulticoreFuture ... done
[16:59:29.975] result() for MulticoreFuture ...
[16:59:29.975] result() for MulticoreFuture ... done
[16:59:29.975] result() for MulticoreFuture ...
[16:59:29.975] result() for MulticoreFuture ... done
[16:59:29.976] - relayed: [n=2] TRUE, TRUE
[16:59:29.976] - queued futures: [n=2] TRUE, TRUE
[16:59:29.976] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:29.976]  length: 0 (resolved future 2)
[16:59:29.976] Relaying remaining futures
[16:59:29.976] signalConditionsASAP(NULL, pos=0) ...
[16:59:29.976] - nx: 2
[16:59:29.976] - relay: TRUE
[16:59:29.976] - stdout: TRUE
[16:59:29.977] - signal: TRUE
[16:59:29.977] - resignal: FALSE
[16:59:29.977] - force: TRUE
[16:59:29.977] - relayed: [n=2] TRUE, TRUE
[16:59:29.977] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:29.977] - relayed: [n=2] TRUE, TRUE
[16:59:29.977] - queued futures: [n=2] TRUE, TRUE
[16:59:29.977] signalConditionsASAP(NULL, pos=0) ... done
[16:59:29.977] resolve() on list ... DONE
[16:59:29.978] result() for MulticoreFuture ...
[16:59:29.978] result() for MulticoreFuture ... done
[16:59:29.978] result() for MulticoreFuture ...
[16:59:29.978] result() for MulticoreFuture ... done
[16:59:29.978] result() for MulticoreFuture ...
[16:59:29.978] result() for MulticoreFuture ... done
[16:59:29.978] result() for MulticoreFuture ...
[16:59:29.978] result() for MulticoreFuture ... done
[16:59:29.979]  - Number of value chunks collected: 2
[16:59:29.979] Resolving 2 futures (chunks) ... DONE
[16:59:29.979] Reducing values from 2 chunks ...
[16:59:29.979]  - Number of values collected after concatenation: 2
[16:59:29.979]  - Number of values expected: 2
[16:59:29.979] Reducing values from 2 chunks ... DONE
[16:59:29.979] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:59:29.980] getGlobalsAndPackagesXApply() ...
[16:59:29.980]  - future.globals: TRUE
[16:59:29.980] getGlobalsAndPackages() ...
[16:59:29.981] Searching for globals...
[16:59:29.982] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:29.982] Searching for globals ... DONE
[16:59:29.982] Resolving globals: FALSE
[16:59:29.983] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:29.983] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:29.983] - globals: [1] ‘FUN’
[16:59:29.984] - packages: [1] ‘stats’
[16:59:29.984] getGlobalsAndPackages() ... DONE
[16:59:29.984]  - globals found/used: [n=1] ‘FUN’
[16:59:29.984]  - needed namespaces: [n=1] ‘stats’
[16:59:29.984] Finding globals ... DONE
[16:59:29.984]  - use_args: TRUE
[16:59:29.984]  - Getting '...' globals ...
[16:59:29.985] resolve() on list ...
[16:59:29.985]  recursive: 0
[16:59:29.985]  length: 1
[16:59:29.985]  elements: ‘...’
[16:59:29.985]  length: 0 (resolved future 1)
[16:59:29.985] resolve() on list ... DONE
[16:59:29.985]    - '...' content: [n=0] 
[16:59:29.985] List of 1
[16:59:29.985]  $ ...: list()
[16:59:29.985]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.985]  - attr(*, "where")=List of 1
[16:59:29.985]   ..$ ...:<environment: 0x55f313ad9fb0> 
[16:59:29.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.985]  - attr(*, "resolved")= logi TRUE
[16:59:29.985]  - attr(*, "total_size")= num NA
[16:59:29.988]  - Getting '...' globals ... DONE
[16:59:29.989] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:29.989] List of 2
[16:59:29.989]  $ ...future.FUN:function (x, ...)  
[16:59:29.989]  $ ...          : list()
[16:59:29.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:29.989]  - attr(*, "where")=List of 2
[16:59:29.989]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:29.989]   ..$ ...          :<environment: 0x55f313ad9fb0> 
[16:59:29.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:29.989]  - attr(*, "resolved")= logi FALSE
[16:59:29.989]  - attr(*, "total_size")= num 1248
[16:59:29.994] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:29.994] getGlobalsAndPackagesXApply() ... DONE
[16:59:29.998] future_lapply() ...
[16:59:30.002] Number of chunks: 2
[16:59:30.002] getGlobalsAndPackagesXApply() ...
[16:59:30.002]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.002]  - use_args: TRUE
[16:59:30.002] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.003] List of 2
[16:59:30.003]  $ ...          : list()
[16:59:30.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.003]  $ ...future.FUN:function (x, ...)  
[16:59:30.003]  - attr(*, "where")=List of 2
[16:59:30.003]   ..$ ...          :<environment: 0x55f313ad9fb0> 
[16:59:30.003]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:59:30.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.003]  - attr(*, "resolved")= logi FALSE
[16:59:30.003]  - attr(*, "total_size")= num NA
[16:59:30.005] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:30.006] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.006] Number of futures (= number of chunks): 2
[16:59:30.006] Launching 2 futures (chunks) ...
[16:59:30.006] Chunk #1 of 2 ...
[16:59:30.006]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.006]  - seeds: <none>
[16:59:30.006]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.007] getGlobalsAndPackages() ...
[16:59:30.007] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.007] Resolving globals: FALSE
[16:59:30.007] Tweak future expression to call with '...' arguments ...
[16:59:30.007] {
[16:59:30.007]     do.call(function(...) {
[16:59:30.007]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.007]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.007]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.007]             on.exit(options(oopts), add = TRUE)
[16:59:30.007]         }
[16:59:30.007]         {
[16:59:30.007]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.007]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.007]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.007]             })
[16:59:30.007]         }
[16:59:30.007]     }, args = future.call.arguments)
[16:59:30.007] }
[16:59:30.007] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.008] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.008] - packages: [1] ‘stats’
[16:59:30.008] getGlobalsAndPackages() ... DONE
[16:59:30.008] run() for ‘Future’ ...
[16:59:30.008] - state: ‘created’
[16:59:30.009] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.012] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.012] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.012]   - Field: ‘label’
[16:59:30.013]   - Field: ‘local’
[16:59:30.013]   - Field: ‘owner’
[16:59:30.013]   - Field: ‘envir’
[16:59:30.013]   - Field: ‘workers’
[16:59:30.013]   - Field: ‘packages’
[16:59:30.013]   - Field: ‘gc’
[16:59:30.013]   - Field: ‘job’
[16:59:30.013]   - Field: ‘conditions’
[16:59:30.013]   - Field: ‘expr’
[16:59:30.013]   - Field: ‘uuid’
[16:59:30.014]   - Field: ‘seed’
[16:59:30.014]   - Field: ‘version’
[16:59:30.014]   - Field: ‘result’
[16:59:30.014]   - Field: ‘asynchronous’
[16:59:30.014]   - Field: ‘calls’
[16:59:30.014]   - Field: ‘globals’
[16:59:30.014]   - Field: ‘stdout’
[16:59:30.014]   - Field: ‘earlySignal’
[16:59:30.014]   - Field: ‘lazy’
[16:59:30.014]   - Field: ‘state’
[16:59:30.014] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.015] - Launch lazy future ...
[16:59:30.015] Packages needed by the future expression (n = 1): ‘stats’
[16:59:30.015] Packages needed by future strategies (n = 0): <none>
[16:59:30.016] {
[16:59:30.016]     {
[16:59:30.016]         {
[16:59:30.016]             ...future.startTime <- base::Sys.time()
[16:59:30.016]             {
[16:59:30.016]                 {
[16:59:30.016]                   {
[16:59:30.016]                     {
[16:59:30.016]                       {
[16:59:30.016]                         base::local({
[16:59:30.016]                           has_future <- base::requireNamespace("future", 
[16:59:30.016]                             quietly = TRUE)
[16:59:30.016]                           if (has_future) {
[16:59:30.016]                             ns <- base::getNamespace("future")
[16:59:30.016]                             version <- ns[[".package"]][["version"]]
[16:59:30.016]                             if (is.null(version)) 
[16:59:30.016]                               version <- utils::packageVersion("future")
[16:59:30.016]                           }
[16:59:30.016]                           else {
[16:59:30.016]                             version <- NULL
[16:59:30.016]                           }
[16:59:30.016]                           if (!has_future || version < "1.8.0") {
[16:59:30.016]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.016]                               "", base::R.version$version.string), 
[16:59:30.016]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:30.016]                                 base::R.version$platform, 8 * 
[16:59:30.016]                                   base::.Machine$sizeof.pointer), 
[16:59:30.016]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.016]                                 "release", "version")], collapse = " "), 
[16:59:30.016]                               hostname = base::Sys.info()[["nodename"]])
[16:59:30.016]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.016]                               info)
[16:59:30.016]                             info <- base::paste(info, collapse = "; ")
[16:59:30.016]                             if (!has_future) {
[16:59:30.016]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.016]                                 info)
[16:59:30.016]                             }
[16:59:30.016]                             else {
[16:59:30.016]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.016]                                 info, version)
[16:59:30.016]                             }
[16:59:30.016]                             base::stop(msg)
[16:59:30.016]                           }
[16:59:30.016]                         })
[16:59:30.016]                       }
[16:59:30.016]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.016]                       base::options(mc.cores = 1L)
[16:59:30.016]                     }
[16:59:30.016]                     base::local({
[16:59:30.016]                       for (pkg in "stats") {
[16:59:30.016]                         base::loadNamespace(pkg)
[16:59:30.016]                         base::library(pkg, character.only = TRUE)
[16:59:30.016]                       }
[16:59:30.016]                     })
[16:59:30.016]                   }
[16:59:30.016]                   ...future.strategy.old <- future::plan("list")
[16:59:30.016]                   options(future.plan = NULL)
[16:59:30.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.016]                 }
[16:59:30.016]                 ...future.workdir <- getwd()
[16:59:30.016]             }
[16:59:30.016]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.016]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.016]         }
[16:59:30.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.016]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.016]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.016]             base::names(...future.oldOptions))
[16:59:30.016]     }
[16:59:30.016]     if (FALSE) {
[16:59:30.016]     }
[16:59:30.016]     else {
[16:59:30.016]         if (TRUE) {
[16:59:30.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.016]                 open = "w")
[16:59:30.016]         }
[16:59:30.016]         else {
[16:59:30.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.016]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.016]         }
[16:59:30.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.016]             base::sink(type = "output", split = FALSE)
[16:59:30.016]             base::close(...future.stdout)
[16:59:30.016]         }, add = TRUE)
[16:59:30.016]     }
[16:59:30.016]     ...future.frame <- base::sys.nframe()
[16:59:30.016]     ...future.conditions <- base::list()
[16:59:30.016]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.016]     if (FALSE) {
[16:59:30.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.016]     }
[16:59:30.016]     ...future.result <- base::tryCatch({
[16:59:30.016]         base::withCallingHandlers({
[16:59:30.016]             ...future.value <- base::withVisible(base::local({
[16:59:30.016]                 withCallingHandlers({
[16:59:30.016]                   {
[16:59:30.016]                     do.call(function(...) {
[16:59:30.016]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.016]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.016]                         ...future.globals.maxSize)) {
[16:59:30.016]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.016]                         on.exit(options(oopts), add = TRUE)
[16:59:30.016]                       }
[16:59:30.016]                       {
[16:59:30.016]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.016]                           FUN = function(jj) {
[16:59:30.016]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.016]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.016]                           })
[16:59:30.016]                       }
[16:59:30.016]                     }, args = future.call.arguments)
[16:59:30.016]                   }
[16:59:30.016]                 }, immediateCondition = function(cond) {
[16:59:30.016]                   save_rds <- function (object, pathname, ...) 
[16:59:30.016]                   {
[16:59:30.016]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.016]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.016]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.016]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.016]                         fi_tmp[["mtime"]])
[16:59:30.016]                     }
[16:59:30.016]                     tryCatch({
[16:59:30.016]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.016]                     }, error = function(ex) {
[16:59:30.016]                       msg <- conditionMessage(ex)
[16:59:30.016]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.016]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.016]                         fi_tmp[["mtime"]], msg)
[16:59:30.016]                       ex$message <- msg
[16:59:30.016]                       stop(ex)
[16:59:30.016]                     })
[16:59:30.016]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.016]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.016]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.016]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.016]                       fi <- file.info(pathname)
[16:59:30.016]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.016]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.016]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.016]                         fi[["size"]], fi[["mtime"]])
[16:59:30.016]                       stop(msg)
[16:59:30.016]                     }
[16:59:30.016]                     invisible(pathname)
[16:59:30.016]                   }
[16:59:30.016]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.016]                     rootPath = tempdir()) 
[16:59:30.016]                   {
[16:59:30.016]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.016]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.016]                       tmpdir = path, fileext = ".rds")
[16:59:30.016]                     save_rds(obj, file)
[16:59:30.016]                   }
[16:59:30.016]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.016]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.016]                   {
[16:59:30.016]                     inherits <- base::inherits
[16:59:30.016]                     invokeRestart <- base::invokeRestart
[16:59:30.016]                     is.null <- base::is.null
[16:59:30.016]                     muffled <- FALSE
[16:59:30.016]                     if (inherits(cond, "message")) {
[16:59:30.016]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.016]                       if (muffled) 
[16:59:30.016]                         invokeRestart("muffleMessage")
[16:59:30.016]                     }
[16:59:30.016]                     else if (inherits(cond, "warning")) {
[16:59:30.016]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.016]                       if (muffled) 
[16:59:30.016]                         invokeRestart("muffleWarning")
[16:59:30.016]                     }
[16:59:30.016]                     else if (inherits(cond, "condition")) {
[16:59:30.016]                       if (!is.null(pattern)) {
[16:59:30.016]                         computeRestarts <- base::computeRestarts
[16:59:30.016]                         grepl <- base::grepl
[16:59:30.016]                         restarts <- computeRestarts(cond)
[16:59:30.016]                         for (restart in restarts) {
[16:59:30.016]                           name <- restart$name
[16:59:30.016]                           if (is.null(name)) 
[16:59:30.016]                             next
[16:59:30.016]                           if (!grepl(pattern, name)) 
[16:59:30.016]                             next
[16:59:30.016]                           invokeRestart(restart)
[16:59:30.016]                           muffled <- TRUE
[16:59:30.016]                           break
[16:59:30.016]                         }
[16:59:30.016]                       }
[16:59:30.016]                     }
[16:59:30.016]                     invisible(muffled)
[16:59:30.016]                   }
[16:59:30.016]                   muffleCondition(cond)
[16:59:30.016]                 })
[16:59:30.016]             }))
[16:59:30.016]             future::FutureResult(value = ...future.value$value, 
[16:59:30.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.016]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.016]                     ...future.globalenv.names))
[16:59:30.016]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.016]         }, condition = base::local({
[16:59:30.016]             c <- base::c
[16:59:30.016]             inherits <- base::inherits
[16:59:30.016]             invokeRestart <- base::invokeRestart
[16:59:30.016]             length <- base::length
[16:59:30.016]             list <- base::list
[16:59:30.016]             seq.int <- base::seq.int
[16:59:30.016]             signalCondition <- base::signalCondition
[16:59:30.016]             sys.calls <- base::sys.calls
[16:59:30.016]             `[[` <- base::`[[`
[16:59:30.016]             `+` <- base::`+`
[16:59:30.016]             `<<-` <- base::`<<-`
[16:59:30.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.016]                   3L)]
[16:59:30.016]             }
[16:59:30.016]             function(cond) {
[16:59:30.016]                 is_error <- inherits(cond, "error")
[16:59:30.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.016]                   NULL)
[16:59:30.016]                 if (is_error) {
[16:59:30.016]                   sessionInformation <- function() {
[16:59:30.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.016]                       search = base::search(), system = base::Sys.info())
[16:59:30.016]                   }
[16:59:30.016]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.016]                     cond$call), session = sessionInformation(), 
[16:59:30.016]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.016]                   signalCondition(cond)
[16:59:30.016]                 }
[16:59:30.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.016]                 "immediateCondition"))) {
[16:59:30.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.016]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.016]                   if (TRUE && !signal) {
[16:59:30.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.016]                     {
[16:59:30.016]                       inherits <- base::inherits
[16:59:30.016]                       invokeRestart <- base::invokeRestart
[16:59:30.016]                       is.null <- base::is.null
[16:59:30.016]                       muffled <- FALSE
[16:59:30.016]                       if (inherits(cond, "message")) {
[16:59:30.016]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.016]                         if (muffled) 
[16:59:30.016]                           invokeRestart("muffleMessage")
[16:59:30.016]                       }
[16:59:30.016]                       else if (inherits(cond, "warning")) {
[16:59:30.016]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.016]                         if (muffled) 
[16:59:30.016]                           invokeRestart("muffleWarning")
[16:59:30.016]                       }
[16:59:30.016]                       else if (inherits(cond, "condition")) {
[16:59:30.016]                         if (!is.null(pattern)) {
[16:59:30.016]                           computeRestarts <- base::computeRestarts
[16:59:30.016]                           grepl <- base::grepl
[16:59:30.016]                           restarts <- computeRestarts(cond)
[16:59:30.016]                           for (restart in restarts) {
[16:59:30.016]                             name <- restart$name
[16:59:30.016]                             if (is.null(name)) 
[16:59:30.016]                               next
[16:59:30.016]                             if (!grepl(pattern, name)) 
[16:59:30.016]                               next
[16:59:30.016]                             invokeRestart(restart)
[16:59:30.016]                             muffled <- TRUE
[16:59:30.016]                             break
[16:59:30.016]                           }
[16:59:30.016]                         }
[16:59:30.016]                       }
[16:59:30.016]                       invisible(muffled)
[16:59:30.016]                     }
[16:59:30.016]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.016]                   }
[16:59:30.016]                 }
[16:59:30.016]                 else {
[16:59:30.016]                   if (TRUE) {
[16:59:30.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.016]                     {
[16:59:30.016]                       inherits <- base::inherits
[16:59:30.016]                       invokeRestart <- base::invokeRestart
[16:59:30.016]                       is.null <- base::is.null
[16:59:30.016]                       muffled <- FALSE
[16:59:30.016]                       if (inherits(cond, "message")) {
[16:59:30.016]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.016]                         if (muffled) 
[16:59:30.016]                           invokeRestart("muffleMessage")
[16:59:30.016]                       }
[16:59:30.016]                       else if (inherits(cond, "warning")) {
[16:59:30.016]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.016]                         if (muffled) 
[16:59:30.016]                           invokeRestart("muffleWarning")
[16:59:30.016]                       }
[16:59:30.016]                       else if (inherits(cond, "condition")) {
[16:59:30.016]                         if (!is.null(pattern)) {
[16:59:30.016]                           computeRestarts <- base::computeRestarts
[16:59:30.016]                           grepl <- base::grepl
[16:59:30.016]                           restarts <- computeRestarts(cond)
[16:59:30.016]                           for (restart in restarts) {
[16:59:30.016]                             name <- restart$name
[16:59:30.016]                             if (is.null(name)) 
[16:59:30.016]                               next
[16:59:30.016]                             if (!grepl(pattern, name)) 
[16:59:30.016]                               next
[16:59:30.016]                             invokeRestart(restart)
[16:59:30.016]                             muffled <- TRUE
[16:59:30.016]                             break
[16:59:30.016]                           }
[16:59:30.016]                         }
[16:59:30.016]                       }
[16:59:30.016]                       invisible(muffled)
[16:59:30.016]                     }
[16:59:30.016]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.016]                   }
[16:59:30.016]                 }
[16:59:30.016]             }
[16:59:30.016]         }))
[16:59:30.016]     }, error = function(ex) {
[16:59:30.016]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.016]                 ...future.rng), started = ...future.startTime, 
[16:59:30.016]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.016]             version = "1.8"), class = "FutureResult")
[16:59:30.016]     }, finally = {
[16:59:30.016]         if (!identical(...future.workdir, getwd())) 
[16:59:30.016]             setwd(...future.workdir)
[16:59:30.016]         {
[16:59:30.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.016]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.016]             }
[16:59:30.016]             base::options(...future.oldOptions)
[16:59:30.016]             if (.Platform$OS.type == "windows") {
[16:59:30.016]                 old_names <- names(...future.oldEnvVars)
[16:59:30.016]                 envs <- base::Sys.getenv()
[16:59:30.016]                 names <- names(envs)
[16:59:30.016]                 common <- intersect(names, old_names)
[16:59:30.016]                 added <- setdiff(names, old_names)
[16:59:30.016]                 removed <- setdiff(old_names, names)
[16:59:30.016]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.016]                   envs[common]]
[16:59:30.016]                 NAMES <- toupper(changed)
[16:59:30.016]                 args <- list()
[16:59:30.016]                 for (kk in seq_along(NAMES)) {
[16:59:30.016]                   name <- changed[[kk]]
[16:59:30.016]                   NAME <- NAMES[[kk]]
[16:59:30.016]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.016]                     next
[16:59:30.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.016]                 }
[16:59:30.016]                 NAMES <- toupper(added)
[16:59:30.016]                 for (kk in seq_along(NAMES)) {
[16:59:30.016]                   name <- added[[kk]]
[16:59:30.016]                   NAME <- NAMES[[kk]]
[16:59:30.016]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.016]                     next
[16:59:30.016]                   args[[name]] <- ""
[16:59:30.016]                 }
[16:59:30.016]                 NAMES <- toupper(removed)
[16:59:30.016]                 for (kk in seq_along(NAMES)) {
[16:59:30.016]                   name <- removed[[kk]]
[16:59:30.016]                   NAME <- NAMES[[kk]]
[16:59:30.016]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.016]                     next
[16:59:30.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.016]                 }
[16:59:30.016]                 if (length(args) > 0) 
[16:59:30.016]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.016]             }
[16:59:30.016]             else {
[16:59:30.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.016]             }
[16:59:30.016]             {
[16:59:30.016]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.016]                   0L) {
[16:59:30.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.016]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.016]                   base::options(opts)
[16:59:30.016]                 }
[16:59:30.016]                 {
[16:59:30.016]                   {
[16:59:30.016]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.016]                     NULL
[16:59:30.016]                   }
[16:59:30.016]                   options(future.plan = NULL)
[16:59:30.016]                   if (is.na(NA_character_)) 
[16:59:30.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.016]                     .init = FALSE)
[16:59:30.016]                 }
[16:59:30.016]             }
[16:59:30.016]         }
[16:59:30.016]     })
[16:59:30.016]     if (TRUE) {
[16:59:30.016]         base::sink(type = "output", split = FALSE)
[16:59:30.016]         if (TRUE) {
[16:59:30.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.016]         }
[16:59:30.016]         else {
[16:59:30.016]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.016]         }
[16:59:30.016]         base::close(...future.stdout)
[16:59:30.016]         ...future.stdout <- NULL
[16:59:30.016]     }
[16:59:30.016]     ...future.result$conditions <- ...future.conditions
[16:59:30.016]     ...future.result$finished <- base::Sys.time()
[16:59:30.016]     ...future.result
[16:59:30.016] }
[16:59:30.018] assign_globals() ...
[16:59:30.018] List of 5
[16:59:30.018]  $ future.call.arguments    : list()
[16:59:30.018]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.018]  $ ...future.FUN            :function (x, ...)  
[16:59:30.018]  $ ...future.elements_ii    :List of 1
[16:59:30.018]   ..$ : num [1:4] 1 3 1 7
[16:59:30.018]  $ ...future.seeds_ii       : NULL
[16:59:30.018]  $ ...future.globals.maxSize: num Inf
[16:59:30.018]  - attr(*, "resolved")= logi FALSE
[16:59:30.018]  - attr(*, "total_size")= num NA
[16:59:30.018]  - attr(*, "where")=List of 5
[16:59:30.018]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.018]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.018]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.018]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.018]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.018]  - attr(*, "already-done")= logi TRUE
[16:59:30.023] - copied ‘future.call.arguments’ to environment
[16:59:30.023] - copied ‘...future.FUN’ to environment
[16:59:30.023] - copied ‘...future.elements_ii’ to environment
[16:59:30.023] - copied ‘...future.seeds_ii’ to environment
[16:59:30.024] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.025] assign_globals() ... done
[16:59:30.026] requestCore(): workers = 2
[16:59:30.028] MulticoreFuture started
[16:59:30.029] - Launch lazy future ... done
[16:59:30.029] run() for ‘MulticoreFuture’ ... done
[16:59:30.030] Created future:
[16:59:30.030] plan(): Setting new future strategy stack:
[16:59:30.030] List of future strategies:
[16:59:30.030] 1. sequential:
[16:59:30.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.030]    - tweaked: FALSE
[16:59:30.030]    - call: NULL
[16:59:30.032] plan(): nbrOfWorkers() = 1
[16:59:30.035] plan(): Setting new future strategy stack:
[16:59:30.035] List of future strategies:
[16:59:30.035] 1. multicore:
[16:59:30.035]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.035]    - tweaked: FALSE
[16:59:30.035]    - call: plan(strategy)
[16:59:30.041] plan(): nbrOfWorkers() = 2
[16:59:30.030] MulticoreFuture:
[16:59:30.030] Label: ‘future_apply-1’
[16:59:30.030] Expression:
[16:59:30.030] {
[16:59:30.030]     do.call(function(...) {
[16:59:30.030]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.030]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.030]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.030]             on.exit(options(oopts), add = TRUE)
[16:59:30.030]         }
[16:59:30.030]         {
[16:59:30.030]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.030]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.030]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.030]             })
[16:59:30.030]         }
[16:59:30.030]     }, args = future.call.arguments)
[16:59:30.030] }
[16:59:30.030] Lazy evaluation: FALSE
[16:59:30.030] Asynchronous evaluation: TRUE
[16:59:30.030] Local evaluation: TRUE
[16:59:30.030] Environment: R_GlobalEnv
[16:59:30.030] Capture standard output: TRUE
[16:59:30.030] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.030] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.030] Packages: 1 packages (‘stats’)
[16:59:30.030] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.030] Resolved: TRUE
[16:59:30.030] Value: <not collected>
[16:59:30.030] Conditions captured: <none>
[16:59:30.030] Early signaling: FALSE
[16:59:30.030] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.030] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.042] Chunk #1 of 2 ... DONE
[16:59:30.042] Chunk #2 of 2 ...
[16:59:30.043]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.043]  - seeds: <none>
[16:59:30.043]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.043] getGlobalsAndPackages() ...
[16:59:30.043] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.043] Resolving globals: FALSE
[16:59:30.044] Tweak future expression to call with '...' arguments ...
[16:59:30.044] {
[16:59:30.044]     do.call(function(...) {
[16:59:30.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.044]             on.exit(options(oopts), add = TRUE)
[16:59:30.044]         }
[16:59:30.044]         {
[16:59:30.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.044]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.044]             })
[16:59:30.044]         }
[16:59:30.044]     }, args = future.call.arguments)
[16:59:30.044] }
[16:59:30.044] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.045] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.045] - packages: [1] ‘stats’
[16:59:30.046] getGlobalsAndPackages() ... DONE
[16:59:30.046] run() for ‘Future’ ...
[16:59:30.046] - state: ‘created’
[16:59:30.047] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.051] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.051] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.052]   - Field: ‘label’
[16:59:30.052]   - Field: ‘local’
[16:59:30.052]   - Field: ‘owner’
[16:59:30.052]   - Field: ‘envir’
[16:59:30.052]   - Field: ‘workers’
[16:59:30.052]   - Field: ‘packages’
[16:59:30.052]   - Field: ‘gc’
[16:59:30.053]   - Field: ‘job’
[16:59:30.053]   - Field: ‘conditions’
[16:59:30.053]   - Field: ‘expr’
[16:59:30.053]   - Field: ‘uuid’
[16:59:30.053]   - Field: ‘seed’
[16:59:30.053]   - Field: ‘version’
[16:59:30.053]   - Field: ‘result’
[16:59:30.054]   - Field: ‘asynchronous’
[16:59:30.054]   - Field: ‘calls’
[16:59:30.054]   - Field: ‘globals’
[16:59:30.054]   - Field: ‘stdout’
[16:59:30.054]   - Field: ‘earlySignal’
[16:59:30.054]   - Field: ‘lazy’
[16:59:30.054]   - Field: ‘state’
[16:59:30.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.055] - Launch lazy future ...
[16:59:30.055] Packages needed by the future expression (n = 1): ‘stats’
[16:59:30.055] Packages needed by future strategies (n = 0): <none>
[16:59:30.056] {
[16:59:30.056]     {
[16:59:30.056]         {
[16:59:30.056]             ...future.startTime <- base::Sys.time()
[16:59:30.056]             {
[16:59:30.056]                 {
[16:59:30.056]                   {
[16:59:30.056]                     {
[16:59:30.056]                       {
[16:59:30.056]                         base::local({
[16:59:30.056]                           has_future <- base::requireNamespace("future", 
[16:59:30.056]                             quietly = TRUE)
[16:59:30.056]                           if (has_future) {
[16:59:30.056]                             ns <- base::getNamespace("future")
[16:59:30.056]                             version <- ns[[".package"]][["version"]]
[16:59:30.056]                             if (is.null(version)) 
[16:59:30.056]                               version <- utils::packageVersion("future")
[16:59:30.056]                           }
[16:59:30.056]                           else {
[16:59:30.056]                             version <- NULL
[16:59:30.056]                           }
[16:59:30.056]                           if (!has_future || version < "1.8.0") {
[16:59:30.056]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.056]                               "", base::R.version$version.string), 
[16:59:30.056]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:30.056]                                 base::R.version$platform, 8 * 
[16:59:30.056]                                   base::.Machine$sizeof.pointer), 
[16:59:30.056]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.056]                                 "release", "version")], collapse = " "), 
[16:59:30.056]                               hostname = base::Sys.info()[["nodename"]])
[16:59:30.056]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.056]                               info)
[16:59:30.056]                             info <- base::paste(info, collapse = "; ")
[16:59:30.056]                             if (!has_future) {
[16:59:30.056]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.056]                                 info)
[16:59:30.056]                             }
[16:59:30.056]                             else {
[16:59:30.056]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.056]                                 info, version)
[16:59:30.056]                             }
[16:59:30.056]                             base::stop(msg)
[16:59:30.056]                           }
[16:59:30.056]                         })
[16:59:30.056]                       }
[16:59:30.056]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.056]                       base::options(mc.cores = 1L)
[16:59:30.056]                     }
[16:59:30.056]                     base::local({
[16:59:30.056]                       for (pkg in "stats") {
[16:59:30.056]                         base::loadNamespace(pkg)
[16:59:30.056]                         base::library(pkg, character.only = TRUE)
[16:59:30.056]                       }
[16:59:30.056]                     })
[16:59:30.056]                   }
[16:59:30.056]                   ...future.strategy.old <- future::plan("list")
[16:59:30.056]                   options(future.plan = NULL)
[16:59:30.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.056]                 }
[16:59:30.056]                 ...future.workdir <- getwd()
[16:59:30.056]             }
[16:59:30.056]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.056]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.056]         }
[16:59:30.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.056]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.056]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.056]             base::names(...future.oldOptions))
[16:59:30.056]     }
[16:59:30.056]     if (FALSE) {
[16:59:30.056]     }
[16:59:30.056]     else {
[16:59:30.056]         if (TRUE) {
[16:59:30.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.056]                 open = "w")
[16:59:30.056]         }
[16:59:30.056]         else {
[16:59:30.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.056]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.056]         }
[16:59:30.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.056]             base::sink(type = "output", split = FALSE)
[16:59:30.056]             base::close(...future.stdout)
[16:59:30.056]         }, add = TRUE)
[16:59:30.056]     }
[16:59:30.056]     ...future.frame <- base::sys.nframe()
[16:59:30.056]     ...future.conditions <- base::list()
[16:59:30.056]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.056]     if (FALSE) {
[16:59:30.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.056]     }
[16:59:30.056]     ...future.result <- base::tryCatch({
[16:59:30.056]         base::withCallingHandlers({
[16:59:30.056]             ...future.value <- base::withVisible(base::local({
[16:59:30.056]                 withCallingHandlers({
[16:59:30.056]                   {
[16:59:30.056]                     do.call(function(...) {
[16:59:30.056]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.056]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.056]                         ...future.globals.maxSize)) {
[16:59:30.056]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.056]                         on.exit(options(oopts), add = TRUE)
[16:59:30.056]                       }
[16:59:30.056]                       {
[16:59:30.056]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.056]                           FUN = function(jj) {
[16:59:30.056]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.056]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.056]                           })
[16:59:30.056]                       }
[16:59:30.056]                     }, args = future.call.arguments)
[16:59:30.056]                   }
[16:59:30.056]                 }, immediateCondition = function(cond) {
[16:59:30.056]                   save_rds <- function (object, pathname, ...) 
[16:59:30.056]                   {
[16:59:30.056]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.056]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.056]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.056]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.056]                         fi_tmp[["mtime"]])
[16:59:30.056]                     }
[16:59:30.056]                     tryCatch({
[16:59:30.056]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.056]                     }, error = function(ex) {
[16:59:30.056]                       msg <- conditionMessage(ex)
[16:59:30.056]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.056]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.056]                         fi_tmp[["mtime"]], msg)
[16:59:30.056]                       ex$message <- msg
[16:59:30.056]                       stop(ex)
[16:59:30.056]                     })
[16:59:30.056]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.056]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.056]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.056]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.056]                       fi <- file.info(pathname)
[16:59:30.056]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.056]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.056]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.056]                         fi[["size"]], fi[["mtime"]])
[16:59:30.056]                       stop(msg)
[16:59:30.056]                     }
[16:59:30.056]                     invisible(pathname)
[16:59:30.056]                   }
[16:59:30.056]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.056]                     rootPath = tempdir()) 
[16:59:30.056]                   {
[16:59:30.056]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.056]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.056]                       tmpdir = path, fileext = ".rds")
[16:59:30.056]                     save_rds(obj, file)
[16:59:30.056]                   }
[16:59:30.056]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.056]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.056]                   {
[16:59:30.056]                     inherits <- base::inherits
[16:59:30.056]                     invokeRestart <- base::invokeRestart
[16:59:30.056]                     is.null <- base::is.null
[16:59:30.056]                     muffled <- FALSE
[16:59:30.056]                     if (inherits(cond, "message")) {
[16:59:30.056]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.056]                       if (muffled) 
[16:59:30.056]                         invokeRestart("muffleMessage")
[16:59:30.056]                     }
[16:59:30.056]                     else if (inherits(cond, "warning")) {
[16:59:30.056]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.056]                       if (muffled) 
[16:59:30.056]                         invokeRestart("muffleWarning")
[16:59:30.056]                     }
[16:59:30.056]                     else if (inherits(cond, "condition")) {
[16:59:30.056]                       if (!is.null(pattern)) {
[16:59:30.056]                         computeRestarts <- base::computeRestarts
[16:59:30.056]                         grepl <- base::grepl
[16:59:30.056]                         restarts <- computeRestarts(cond)
[16:59:30.056]                         for (restart in restarts) {
[16:59:30.056]                           name <- restart$name
[16:59:30.056]                           if (is.null(name)) 
[16:59:30.056]                             next
[16:59:30.056]                           if (!grepl(pattern, name)) 
[16:59:30.056]                             next
[16:59:30.056]                           invokeRestart(restart)
[16:59:30.056]                           muffled <- TRUE
[16:59:30.056]                           break
[16:59:30.056]                         }
[16:59:30.056]                       }
[16:59:30.056]                     }
[16:59:30.056]                     invisible(muffled)
[16:59:30.056]                   }
[16:59:30.056]                   muffleCondition(cond)
[16:59:30.056]                 })
[16:59:30.056]             }))
[16:59:30.056]             future::FutureResult(value = ...future.value$value, 
[16:59:30.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.056]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.056]                     ...future.globalenv.names))
[16:59:30.056]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.056]         }, condition = base::local({
[16:59:30.056]             c <- base::c
[16:59:30.056]             inherits <- base::inherits
[16:59:30.056]             invokeRestart <- base::invokeRestart
[16:59:30.056]             length <- base::length
[16:59:30.056]             list <- base::list
[16:59:30.056]             seq.int <- base::seq.int
[16:59:30.056]             signalCondition <- base::signalCondition
[16:59:30.056]             sys.calls <- base::sys.calls
[16:59:30.056]             `[[` <- base::`[[`
[16:59:30.056]             `+` <- base::`+`
[16:59:30.056]             `<<-` <- base::`<<-`
[16:59:30.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.056]                   3L)]
[16:59:30.056]             }
[16:59:30.056]             function(cond) {
[16:59:30.056]                 is_error <- inherits(cond, "error")
[16:59:30.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.056]                   NULL)
[16:59:30.056]                 if (is_error) {
[16:59:30.056]                   sessionInformation <- function() {
[16:59:30.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.056]                       search = base::search(), system = base::Sys.info())
[16:59:30.056]                   }
[16:59:30.056]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.056]                     cond$call), session = sessionInformation(), 
[16:59:30.056]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.056]                   signalCondition(cond)
[16:59:30.056]                 }
[16:59:30.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.056]                 "immediateCondition"))) {
[16:59:30.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.056]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.056]                   if (TRUE && !signal) {
[16:59:30.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.056]                     {
[16:59:30.056]                       inherits <- base::inherits
[16:59:30.056]                       invokeRestart <- base::invokeRestart
[16:59:30.056]                       is.null <- base::is.null
[16:59:30.056]                       muffled <- FALSE
[16:59:30.056]                       if (inherits(cond, "message")) {
[16:59:30.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.056]                         if (muffled) 
[16:59:30.056]                           invokeRestart("muffleMessage")
[16:59:30.056]                       }
[16:59:30.056]                       else if (inherits(cond, "warning")) {
[16:59:30.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.056]                         if (muffled) 
[16:59:30.056]                           invokeRestart("muffleWarning")
[16:59:30.056]                       }
[16:59:30.056]                       else if (inherits(cond, "condition")) {
[16:59:30.056]                         if (!is.null(pattern)) {
[16:59:30.056]                           computeRestarts <- base::computeRestarts
[16:59:30.056]                           grepl <- base::grepl
[16:59:30.056]                           restarts <- computeRestarts(cond)
[16:59:30.056]                           for (restart in restarts) {
[16:59:30.056]                             name <- restart$name
[16:59:30.056]                             if (is.null(name)) 
[16:59:30.056]                               next
[16:59:30.056]                             if (!grepl(pattern, name)) 
[16:59:30.056]                               next
[16:59:30.056]                             invokeRestart(restart)
[16:59:30.056]                             muffled <- TRUE
[16:59:30.056]                             break
[16:59:30.056]                           }
[16:59:30.056]                         }
[16:59:30.056]                       }
[16:59:30.056]                       invisible(muffled)
[16:59:30.056]                     }
[16:59:30.056]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.056]                   }
[16:59:30.056]                 }
[16:59:30.056]                 else {
[16:59:30.056]                   if (TRUE) {
[16:59:30.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.056]                     {
[16:59:30.056]                       inherits <- base::inherits
[16:59:30.056]                       invokeRestart <- base::invokeRestart
[16:59:30.056]                       is.null <- base::is.null
[16:59:30.056]                       muffled <- FALSE
[16:59:30.056]                       if (inherits(cond, "message")) {
[16:59:30.056]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.056]                         if (muffled) 
[16:59:30.056]                           invokeRestart("muffleMessage")
[16:59:30.056]                       }
[16:59:30.056]                       else if (inherits(cond, "warning")) {
[16:59:30.056]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.056]                         if (muffled) 
[16:59:30.056]                           invokeRestart("muffleWarning")
[16:59:30.056]                       }
[16:59:30.056]                       else if (inherits(cond, "condition")) {
[16:59:30.056]                         if (!is.null(pattern)) {
[16:59:30.056]                           computeRestarts <- base::computeRestarts
[16:59:30.056]                           grepl <- base::grepl
[16:59:30.056]                           restarts <- computeRestarts(cond)
[16:59:30.056]                           for (restart in restarts) {
[16:59:30.056]                             name <- restart$name
[16:59:30.056]                             if (is.null(name)) 
[16:59:30.056]                               next
[16:59:30.056]                             if (!grepl(pattern, name)) 
[16:59:30.056]                               next
[16:59:30.056]                             invokeRestart(restart)
[16:59:30.056]                             muffled <- TRUE
[16:59:30.056]                             break
[16:59:30.056]                           }
[16:59:30.056]                         }
[16:59:30.056]                       }
[16:59:30.056]                       invisible(muffled)
[16:59:30.056]                     }
[16:59:30.056]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.056]                   }
[16:59:30.056]                 }
[16:59:30.056]             }
[16:59:30.056]         }))
[16:59:30.056]     }, error = function(ex) {
[16:59:30.056]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.056]                 ...future.rng), started = ...future.startTime, 
[16:59:30.056]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.056]             version = "1.8"), class = "FutureResult")
[16:59:30.056]     }, finally = {
[16:59:30.056]         if (!identical(...future.workdir, getwd())) 
[16:59:30.056]             setwd(...future.workdir)
[16:59:30.056]         {
[16:59:30.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.056]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.056]             }
[16:59:30.056]             base::options(...future.oldOptions)
[16:59:30.056]             if (.Platform$OS.type == "windows") {
[16:59:30.056]                 old_names <- names(...future.oldEnvVars)
[16:59:30.056]                 envs <- base::Sys.getenv()
[16:59:30.056]                 names <- names(envs)
[16:59:30.056]                 common <- intersect(names, old_names)
[16:59:30.056]                 added <- setdiff(names, old_names)
[16:59:30.056]                 removed <- setdiff(old_names, names)
[16:59:30.056]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.056]                   envs[common]]
[16:59:30.056]                 NAMES <- toupper(changed)
[16:59:30.056]                 args <- list()
[16:59:30.056]                 for (kk in seq_along(NAMES)) {
[16:59:30.056]                   name <- changed[[kk]]
[16:59:30.056]                   NAME <- NAMES[[kk]]
[16:59:30.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.056]                     next
[16:59:30.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.056]                 }
[16:59:30.056]                 NAMES <- toupper(added)
[16:59:30.056]                 for (kk in seq_along(NAMES)) {
[16:59:30.056]                   name <- added[[kk]]
[16:59:30.056]                   NAME <- NAMES[[kk]]
[16:59:30.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.056]                     next
[16:59:30.056]                   args[[name]] <- ""
[16:59:30.056]                 }
[16:59:30.056]                 NAMES <- toupper(removed)
[16:59:30.056]                 for (kk in seq_along(NAMES)) {
[16:59:30.056]                   name <- removed[[kk]]
[16:59:30.056]                   NAME <- NAMES[[kk]]
[16:59:30.056]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.056]                     next
[16:59:30.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.056]                 }
[16:59:30.056]                 if (length(args) > 0) 
[16:59:30.056]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.056]             }
[16:59:30.056]             else {
[16:59:30.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.056]             }
[16:59:30.056]             {
[16:59:30.056]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.056]                   0L) {
[16:59:30.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.056]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.056]                   base::options(opts)
[16:59:30.056]                 }
[16:59:30.056]                 {
[16:59:30.056]                   {
[16:59:30.056]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.056]                     NULL
[16:59:30.056]                   }
[16:59:30.056]                   options(future.plan = NULL)
[16:59:30.056]                   if (is.na(NA_character_)) 
[16:59:30.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.056]                     .init = FALSE)
[16:59:30.056]                 }
[16:59:30.056]             }
[16:59:30.056]         }
[16:59:30.056]     })
[16:59:30.056]     if (TRUE) {
[16:59:30.056]         base::sink(type = "output", split = FALSE)
[16:59:30.056]         if (TRUE) {
[16:59:30.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.056]         }
[16:59:30.056]         else {
[16:59:30.056]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.056]         }
[16:59:30.056]         base::close(...future.stdout)
[16:59:30.056]         ...future.stdout <- NULL
[16:59:30.056]     }
[16:59:30.056]     ...future.result$conditions <- ...future.conditions
[16:59:30.056]     ...future.result$finished <- base::Sys.time()
[16:59:30.056]     ...future.result
[16:59:30.056] }
[16:59:30.060] assign_globals() ...
[16:59:30.060] List of 5
[16:59:30.060]  $ future.call.arguments    : list()
[16:59:30.060]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.060]  $ ...future.FUN            :function (x, ...)  
[16:59:30.060]  $ ...future.elements_ii    :List of 1
[16:59:30.060]   ..$ : num [1:4] 2 4 6 8
[16:59:30.060]  $ ...future.seeds_ii       : NULL
[16:59:30.060]  $ ...future.globals.maxSize: num Inf
[16:59:30.060]  - attr(*, "resolved")= logi FALSE
[16:59:30.060]  - attr(*, "total_size")= num NA
[16:59:30.060]  - attr(*, "where")=List of 5
[16:59:30.060]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.060]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.060]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.060]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.060]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.060]  - attr(*, "already-done")= logi TRUE
[16:59:30.067] - copied ‘future.call.arguments’ to environment
[16:59:30.067] - copied ‘...future.FUN’ to environment
[16:59:30.067] - copied ‘...future.elements_ii’ to environment
[16:59:30.067] - copied ‘...future.seeds_ii’ to environment
[16:59:30.067] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.067] assign_globals() ... done
[16:59:30.068] requestCore(): workers = 2
[16:59:30.070] MulticoreFuture started
[16:59:30.070] - Launch lazy future ... done
[16:59:30.071] run() for ‘MulticoreFuture’ ... done
[16:59:30.071] Created future:
[16:59:30.071] plan(): Setting new future strategy stack:
[16:59:30.072] List of future strategies:
[16:59:30.072] 1. sequential:
[16:59:30.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.072]    - tweaked: FALSE
[16:59:30.072]    - call: NULL
[16:59:30.073] plan(): nbrOfWorkers() = 1
[16:59:30.075] plan(): Setting new future strategy stack:
[16:59:30.075] List of future strategies:
[16:59:30.075] 1. multicore:
[16:59:30.075]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.075]    - tweaked: FALSE
[16:59:30.075]    - call: plan(strategy)
[16:59:30.080] plan(): nbrOfWorkers() = 2
[16:59:30.071] MulticoreFuture:
[16:59:30.071] Label: ‘future_apply-2’
[16:59:30.071] Expression:
[16:59:30.071] {
[16:59:30.071]     do.call(function(...) {
[16:59:30.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.071]             on.exit(options(oopts), add = TRUE)
[16:59:30.071]         }
[16:59:30.071]         {
[16:59:30.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.071]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.071]             })
[16:59:30.071]         }
[16:59:30.071]     }, args = future.call.arguments)
[16:59:30.071] }
[16:59:30.071] Lazy evaluation: FALSE
[16:59:30.071] Asynchronous evaluation: TRUE
[16:59:30.071] Local evaluation: TRUE
[16:59:30.071] Environment: R_GlobalEnv
[16:59:30.071] Capture standard output: TRUE
[16:59:30.071] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.071] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.071] Packages: 1 packages (‘stats’)
[16:59:30.071] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.071] Resolved: TRUE
[16:59:30.071] Value: <not collected>
[16:59:30.071] Conditions captured: <none>
[16:59:30.071] Early signaling: FALSE
[16:59:30.071] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.071] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.081] Chunk #2 of 2 ... DONE
[16:59:30.082] Launching 2 futures (chunks) ... DONE
[16:59:30.082] Resolving 2 futures (chunks) ...
[16:59:30.082] resolve() on list ...
[16:59:30.082]  recursive: 0
[16:59:30.082]  length: 2
[16:59:30.082] 
[16:59:30.083] Future #1
[16:59:30.083] result() for MulticoreFuture ...
[16:59:30.084] result() for MulticoreFuture ...
[16:59:30.084] result() for MulticoreFuture ... done
[16:59:30.084] result() for MulticoreFuture ... done
[16:59:30.084] result() for MulticoreFuture ...
[16:59:30.084] result() for MulticoreFuture ... done
[16:59:30.085] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.085] - nx: 2
[16:59:30.085] - relay: TRUE
[16:59:30.085] - stdout: TRUE
[16:59:30.085] - signal: TRUE
[16:59:30.085] - resignal: FALSE
[16:59:30.085] - force: TRUE
[16:59:30.085] - relayed: [n=2] FALSE, FALSE
[16:59:30.086] - queued futures: [n=2] FALSE, FALSE
[16:59:30.086]  - until=1
[16:59:30.086]  - relaying element #1
[16:59:30.086] result() for MulticoreFuture ...
[16:59:30.086] result() for MulticoreFuture ... done
[16:59:30.086] result() for MulticoreFuture ...
[16:59:30.086] result() for MulticoreFuture ... done
[16:59:30.087] result() for MulticoreFuture ...
[16:59:30.087] result() for MulticoreFuture ... done
[16:59:30.087] result() for MulticoreFuture ...
[16:59:30.087] result() for MulticoreFuture ... done
[16:59:30.087] - relayed: [n=2] TRUE, FALSE
[16:59:30.087] - queued futures: [n=2] TRUE, FALSE
[16:59:30.087] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.088]  length: 1 (resolved future 1)
[16:59:30.088] Future #2
[16:59:30.088] result() for MulticoreFuture ...
[16:59:30.089] result() for MulticoreFuture ...
[16:59:30.089] result() for MulticoreFuture ... done
[16:59:30.089] result() for MulticoreFuture ... done
[16:59:30.092] result() for MulticoreFuture ...
[16:59:30.092] result() for MulticoreFuture ... done
[16:59:30.093] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.093] - nx: 2
[16:59:30.093] - relay: TRUE
[16:59:30.093] - stdout: TRUE
[16:59:30.093] - signal: TRUE
[16:59:30.093] - resignal: FALSE
[16:59:30.094] - force: TRUE
[16:59:30.094] - relayed: [n=2] TRUE, FALSE
[16:59:30.094] - queued futures: [n=2] TRUE, FALSE
[16:59:30.094]  - until=2
[16:59:30.094]  - relaying element #2
[16:59:30.094] result() for MulticoreFuture ...
[16:59:30.095] result() for MulticoreFuture ... done
[16:59:30.095] result() for MulticoreFuture ...
[16:59:30.095] result() for MulticoreFuture ... done
[16:59:30.095] result() for MulticoreFuture ...
[16:59:30.095] result() for MulticoreFuture ... done
[16:59:30.095] result() for MulticoreFuture ...
[16:59:30.095] result() for MulticoreFuture ... done
[16:59:30.095] - relayed: [n=2] TRUE, TRUE
[16:59:30.096] - queued futures: [n=2] TRUE, TRUE
[16:59:30.096] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.096]  length: 0 (resolved future 2)
[16:59:30.096] Relaying remaining futures
[16:59:30.096] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.096] - nx: 2
[16:59:30.096] - relay: TRUE
[16:59:30.096] - stdout: TRUE
[16:59:30.097] - signal: TRUE
[16:59:30.097] - resignal: FALSE
[16:59:30.097] - force: TRUE
[16:59:30.097] - relayed: [n=2] TRUE, TRUE
[16:59:30.097] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.097] - relayed: [n=2] TRUE, TRUE
[16:59:30.097] - queued futures: [n=2] TRUE, TRUE
[16:59:30.097] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.097] resolve() on list ... DONE
[16:59:30.098] result() for MulticoreFuture ...
[16:59:30.098] result() for MulticoreFuture ... done
[16:59:30.098] result() for MulticoreFuture ...
[16:59:30.098] result() for MulticoreFuture ... done
[16:59:30.098] result() for MulticoreFuture ...
[16:59:30.098] result() for MulticoreFuture ... done
[16:59:30.098] result() for MulticoreFuture ...
[16:59:30.098] result() for MulticoreFuture ... done
[16:59:30.099]  - Number of value chunks collected: 2
[16:59:30.099] Resolving 2 futures (chunks) ... DONE
[16:59:30.099] Reducing values from 2 chunks ...
[16:59:30.099]  - Number of values collected after concatenation: 2
[16:59:30.099]  - Number of values expected: 2
[16:59:30.099] Reducing values from 2 chunks ... DONE
[16:59:30.099] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:59:30.100] getGlobalsAndPackagesXApply() ...
[16:59:30.100]  - future.globals: TRUE
[16:59:30.100] getGlobalsAndPackages() ...
[16:59:30.100] Searching for globals...
[16:59:30.102] - globals found: [1] ‘FUN’
[16:59:30.102] Searching for globals ... DONE
[16:59:30.102] Resolving globals: FALSE
[16:59:30.102] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:30.103] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:30.103] - globals: [1] ‘FUN’
[16:59:30.103] 
[16:59:30.103] getGlobalsAndPackages() ... DONE
[16:59:30.103]  - globals found/used: [n=1] ‘FUN’
[16:59:30.103]  - needed namespaces: [n=0] 
[16:59:30.103] Finding globals ... DONE
[16:59:30.103]  - use_args: TRUE
[16:59:30.104]  - Getting '...' globals ...
[16:59:30.104] resolve() on list ...
[16:59:30.104]  recursive: 0
[16:59:30.104]  length: 1
[16:59:30.104]  elements: ‘...’
[16:59:30.104]  length: 0 (resolved future 1)
[16:59:30.104] resolve() on list ... DONE
[16:59:30.105]    - '...' content: [n=0] 
[16:59:30.105] List of 1
[16:59:30.105]  $ ...: list()
[16:59:30.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.105]  - attr(*, "where")=List of 1
[16:59:30.105]   ..$ ...:<environment: 0x55f311824b60> 
[16:59:30.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.105]  - attr(*, "resolved")= logi TRUE
[16:59:30.105]  - attr(*, "total_size")= num NA
[16:59:30.108]  - Getting '...' globals ... DONE
[16:59:30.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.108] List of 2
[16:59:30.108]  $ ...future.FUN:function (x)  
[16:59:30.108]  $ ...          : list()
[16:59:30.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.108]  - attr(*, "where")=List of 2
[16:59:30.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.108]   ..$ ...          :<environment: 0x55f311824b60> 
[16:59:30.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.108]  - attr(*, "resolved")= logi FALSE
[16:59:30.108]  - attr(*, "total_size")= num 848
[16:59:30.111] Packages to be attached in all futures: [n=0] 
[16:59:30.111] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.115] future_lapply() ...
[16:59:30.119] Number of chunks: 2
[16:59:30.119] getGlobalsAndPackagesXApply() ...
[16:59:30.119]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.119]  - use_args: TRUE
[16:59:30.119] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.119] List of 2
[16:59:30.119]  $ ...          : list()
[16:59:30.119]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.119]  $ ...future.FUN:function (x)  
[16:59:30.119]  - attr(*, "where")=List of 2
[16:59:30.119]   ..$ ...          :<environment: 0x55f311824b60> 
[16:59:30.119]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:30.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.119]  - attr(*, "resolved")= logi FALSE
[16:59:30.119]  - attr(*, "total_size")= num NA
[16:59:30.127] Packages to be attached in all futures: [n=0] 
[16:59:30.127] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.127] Number of futures (= number of chunks): 2
[16:59:30.127] Launching 2 futures (chunks) ...
[16:59:30.127] Chunk #1 of 2 ...
[16:59:30.128]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.128]  - seeds: <none>
[16:59:30.128]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.128] getGlobalsAndPackages() ...
[16:59:30.128] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.128] Resolving globals: FALSE
[16:59:30.128] Tweak future expression to call with '...' arguments ...
[16:59:30.129] {
[16:59:30.129]     do.call(function(...) {
[16:59:30.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.129]             on.exit(options(oopts), add = TRUE)
[16:59:30.129]         }
[16:59:30.129]         {
[16:59:30.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.129]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.129]             })
[16:59:30.129]         }
[16:59:30.129]     }, args = future.call.arguments)
[16:59:30.129] }
[16:59:30.129] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.129] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.129] 
[16:59:30.129] getGlobalsAndPackages() ... DONE
[16:59:30.130] run() for ‘Future’ ...
[16:59:30.130] - state: ‘created’
[16:59:30.130] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.134] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.134] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.134]   - Field: ‘label’
[16:59:30.134]   - Field: ‘local’
[16:59:30.134]   - Field: ‘owner’
[16:59:30.134]   - Field: ‘envir’
[16:59:30.134]   - Field: ‘workers’
[16:59:30.134]   - Field: ‘packages’
[16:59:30.135]   - Field: ‘gc’
[16:59:30.135]   - Field: ‘job’
[16:59:30.135]   - Field: ‘conditions’
[16:59:30.135]   - Field: ‘expr’
[16:59:30.135]   - Field: ‘uuid’
[16:59:30.135]   - Field: ‘seed’
[16:59:30.135]   - Field: ‘version’
[16:59:30.135]   - Field: ‘result’
[16:59:30.135]   - Field: ‘asynchronous’
[16:59:30.135]   - Field: ‘calls’
[16:59:30.136]   - Field: ‘globals’
[16:59:30.136]   - Field: ‘stdout’
[16:59:30.136]   - Field: ‘earlySignal’
[16:59:30.136]   - Field: ‘lazy’
[16:59:30.136]   - Field: ‘state’
[16:59:30.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.136] - Launch lazy future ...
[16:59:30.136] Packages needed by the future expression (n = 0): <none>
[16:59:30.136] Packages needed by future strategies (n = 0): <none>
[16:59:30.137] {
[16:59:30.137]     {
[16:59:30.137]         {
[16:59:30.137]             ...future.startTime <- base::Sys.time()
[16:59:30.137]             {
[16:59:30.137]                 {
[16:59:30.137]                   {
[16:59:30.137]                     {
[16:59:30.137]                       base::local({
[16:59:30.137]                         has_future <- base::requireNamespace("future", 
[16:59:30.137]                           quietly = TRUE)
[16:59:30.137]                         if (has_future) {
[16:59:30.137]                           ns <- base::getNamespace("future")
[16:59:30.137]                           version <- ns[[".package"]][["version"]]
[16:59:30.137]                           if (is.null(version)) 
[16:59:30.137]                             version <- utils::packageVersion("future")
[16:59:30.137]                         }
[16:59:30.137]                         else {
[16:59:30.137]                           version <- NULL
[16:59:30.137]                         }
[16:59:30.137]                         if (!has_future || version < "1.8.0") {
[16:59:30.137]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.137]                             "", base::R.version$version.string), 
[16:59:30.137]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.137]                               "release", "version")], collapse = " "), 
[16:59:30.137]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.137]                             info)
[16:59:30.137]                           info <- base::paste(info, collapse = "; ")
[16:59:30.137]                           if (!has_future) {
[16:59:30.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.137]                               info)
[16:59:30.137]                           }
[16:59:30.137]                           else {
[16:59:30.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.137]                               info, version)
[16:59:30.137]                           }
[16:59:30.137]                           base::stop(msg)
[16:59:30.137]                         }
[16:59:30.137]                       })
[16:59:30.137]                     }
[16:59:30.137]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.137]                     base::options(mc.cores = 1L)
[16:59:30.137]                   }
[16:59:30.137]                   ...future.strategy.old <- future::plan("list")
[16:59:30.137]                   options(future.plan = NULL)
[16:59:30.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.137]                 }
[16:59:30.137]                 ...future.workdir <- getwd()
[16:59:30.137]             }
[16:59:30.137]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.137]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.137]         }
[16:59:30.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.137]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.137]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.137]             base::names(...future.oldOptions))
[16:59:30.137]     }
[16:59:30.137]     if (FALSE) {
[16:59:30.137]     }
[16:59:30.137]     else {
[16:59:30.137]         if (TRUE) {
[16:59:30.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.137]                 open = "w")
[16:59:30.137]         }
[16:59:30.137]         else {
[16:59:30.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.137]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.137]         }
[16:59:30.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.137]             base::sink(type = "output", split = FALSE)
[16:59:30.137]             base::close(...future.stdout)
[16:59:30.137]         }, add = TRUE)
[16:59:30.137]     }
[16:59:30.137]     ...future.frame <- base::sys.nframe()
[16:59:30.137]     ...future.conditions <- base::list()
[16:59:30.137]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.137]     if (FALSE) {
[16:59:30.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.137]     }
[16:59:30.137]     ...future.result <- base::tryCatch({
[16:59:30.137]         base::withCallingHandlers({
[16:59:30.137]             ...future.value <- base::withVisible(base::local({
[16:59:30.137]                 withCallingHandlers({
[16:59:30.137]                   {
[16:59:30.137]                     do.call(function(...) {
[16:59:30.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.137]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.137]                         ...future.globals.maxSize)) {
[16:59:30.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.137]                         on.exit(options(oopts), add = TRUE)
[16:59:30.137]                       }
[16:59:30.137]                       {
[16:59:30.137]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.137]                           FUN = function(jj) {
[16:59:30.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.137]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.137]                           })
[16:59:30.137]                       }
[16:59:30.137]                     }, args = future.call.arguments)
[16:59:30.137]                   }
[16:59:30.137]                 }, immediateCondition = function(cond) {
[16:59:30.137]                   save_rds <- function (object, pathname, ...) 
[16:59:30.137]                   {
[16:59:30.137]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.137]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.137]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.137]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.137]                         fi_tmp[["mtime"]])
[16:59:30.137]                     }
[16:59:30.137]                     tryCatch({
[16:59:30.137]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.137]                     }, error = function(ex) {
[16:59:30.137]                       msg <- conditionMessage(ex)
[16:59:30.137]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.137]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.137]                         fi_tmp[["mtime"]], msg)
[16:59:30.137]                       ex$message <- msg
[16:59:30.137]                       stop(ex)
[16:59:30.137]                     })
[16:59:30.137]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.137]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.137]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.137]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.137]                       fi <- file.info(pathname)
[16:59:30.137]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.137]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.137]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.137]                         fi[["size"]], fi[["mtime"]])
[16:59:30.137]                       stop(msg)
[16:59:30.137]                     }
[16:59:30.137]                     invisible(pathname)
[16:59:30.137]                   }
[16:59:30.137]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.137]                     rootPath = tempdir()) 
[16:59:30.137]                   {
[16:59:30.137]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.137]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.137]                       tmpdir = path, fileext = ".rds")
[16:59:30.137]                     save_rds(obj, file)
[16:59:30.137]                   }
[16:59:30.137]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.137]                   {
[16:59:30.137]                     inherits <- base::inherits
[16:59:30.137]                     invokeRestart <- base::invokeRestart
[16:59:30.137]                     is.null <- base::is.null
[16:59:30.137]                     muffled <- FALSE
[16:59:30.137]                     if (inherits(cond, "message")) {
[16:59:30.137]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.137]                       if (muffled) 
[16:59:30.137]                         invokeRestart("muffleMessage")
[16:59:30.137]                     }
[16:59:30.137]                     else if (inherits(cond, "warning")) {
[16:59:30.137]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.137]                       if (muffled) 
[16:59:30.137]                         invokeRestart("muffleWarning")
[16:59:30.137]                     }
[16:59:30.137]                     else if (inherits(cond, "condition")) {
[16:59:30.137]                       if (!is.null(pattern)) {
[16:59:30.137]                         computeRestarts <- base::computeRestarts
[16:59:30.137]                         grepl <- base::grepl
[16:59:30.137]                         restarts <- computeRestarts(cond)
[16:59:30.137]                         for (restart in restarts) {
[16:59:30.137]                           name <- restart$name
[16:59:30.137]                           if (is.null(name)) 
[16:59:30.137]                             next
[16:59:30.137]                           if (!grepl(pattern, name)) 
[16:59:30.137]                             next
[16:59:30.137]                           invokeRestart(restart)
[16:59:30.137]                           muffled <- TRUE
[16:59:30.137]                           break
[16:59:30.137]                         }
[16:59:30.137]                       }
[16:59:30.137]                     }
[16:59:30.137]                     invisible(muffled)
[16:59:30.137]                   }
[16:59:30.137]                   muffleCondition(cond)
[16:59:30.137]                 })
[16:59:30.137]             }))
[16:59:30.137]             future::FutureResult(value = ...future.value$value, 
[16:59:30.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.137]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.137]                     ...future.globalenv.names))
[16:59:30.137]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.137]         }, condition = base::local({
[16:59:30.137]             c <- base::c
[16:59:30.137]             inherits <- base::inherits
[16:59:30.137]             invokeRestart <- base::invokeRestart
[16:59:30.137]             length <- base::length
[16:59:30.137]             list <- base::list
[16:59:30.137]             seq.int <- base::seq.int
[16:59:30.137]             signalCondition <- base::signalCondition
[16:59:30.137]             sys.calls <- base::sys.calls
[16:59:30.137]             `[[` <- base::`[[`
[16:59:30.137]             `+` <- base::`+`
[16:59:30.137]             `<<-` <- base::`<<-`
[16:59:30.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.137]                   3L)]
[16:59:30.137]             }
[16:59:30.137]             function(cond) {
[16:59:30.137]                 is_error <- inherits(cond, "error")
[16:59:30.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.137]                   NULL)
[16:59:30.137]                 if (is_error) {
[16:59:30.137]                   sessionInformation <- function() {
[16:59:30.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.137]                       search = base::search(), system = base::Sys.info())
[16:59:30.137]                   }
[16:59:30.137]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.137]                     cond$call), session = sessionInformation(), 
[16:59:30.137]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.137]                   signalCondition(cond)
[16:59:30.137]                 }
[16:59:30.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.137]                 "immediateCondition"))) {
[16:59:30.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.137]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.137]                   if (TRUE && !signal) {
[16:59:30.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.137]                     {
[16:59:30.137]                       inherits <- base::inherits
[16:59:30.137]                       invokeRestart <- base::invokeRestart
[16:59:30.137]                       is.null <- base::is.null
[16:59:30.137]                       muffled <- FALSE
[16:59:30.137]                       if (inherits(cond, "message")) {
[16:59:30.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.137]                         if (muffled) 
[16:59:30.137]                           invokeRestart("muffleMessage")
[16:59:30.137]                       }
[16:59:30.137]                       else if (inherits(cond, "warning")) {
[16:59:30.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.137]                         if (muffled) 
[16:59:30.137]                           invokeRestart("muffleWarning")
[16:59:30.137]                       }
[16:59:30.137]                       else if (inherits(cond, "condition")) {
[16:59:30.137]                         if (!is.null(pattern)) {
[16:59:30.137]                           computeRestarts <- base::computeRestarts
[16:59:30.137]                           grepl <- base::grepl
[16:59:30.137]                           restarts <- computeRestarts(cond)
[16:59:30.137]                           for (restart in restarts) {
[16:59:30.137]                             name <- restart$name
[16:59:30.137]                             if (is.null(name)) 
[16:59:30.137]                               next
[16:59:30.137]                             if (!grepl(pattern, name)) 
[16:59:30.137]                               next
[16:59:30.137]                             invokeRestart(restart)
[16:59:30.137]                             muffled <- TRUE
[16:59:30.137]                             break
[16:59:30.137]                           }
[16:59:30.137]                         }
[16:59:30.137]                       }
[16:59:30.137]                       invisible(muffled)
[16:59:30.137]                     }
[16:59:30.137]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.137]                   }
[16:59:30.137]                 }
[16:59:30.137]                 else {
[16:59:30.137]                   if (TRUE) {
[16:59:30.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.137]                     {
[16:59:30.137]                       inherits <- base::inherits
[16:59:30.137]                       invokeRestart <- base::invokeRestart
[16:59:30.137]                       is.null <- base::is.null
[16:59:30.137]                       muffled <- FALSE
[16:59:30.137]                       if (inherits(cond, "message")) {
[16:59:30.137]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.137]                         if (muffled) 
[16:59:30.137]                           invokeRestart("muffleMessage")
[16:59:30.137]                       }
[16:59:30.137]                       else if (inherits(cond, "warning")) {
[16:59:30.137]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.137]                         if (muffled) 
[16:59:30.137]                           invokeRestart("muffleWarning")
[16:59:30.137]                       }
[16:59:30.137]                       else if (inherits(cond, "condition")) {
[16:59:30.137]                         if (!is.null(pattern)) {
[16:59:30.137]                           computeRestarts <- base::computeRestarts
[16:59:30.137]                           grepl <- base::grepl
[16:59:30.137]                           restarts <- computeRestarts(cond)
[16:59:30.137]                           for (restart in restarts) {
[16:59:30.137]                             name <- restart$name
[16:59:30.137]                             if (is.null(name)) 
[16:59:30.137]                               next
[16:59:30.137]                             if (!grepl(pattern, name)) 
[16:59:30.137]                               next
[16:59:30.137]                             invokeRestart(restart)
[16:59:30.137]                             muffled <- TRUE
[16:59:30.137]                             break
[16:59:30.137]                           }
[16:59:30.137]                         }
[16:59:30.137]                       }
[16:59:30.137]                       invisible(muffled)
[16:59:30.137]                     }
[16:59:30.137]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.137]                   }
[16:59:30.137]                 }
[16:59:30.137]             }
[16:59:30.137]         }))
[16:59:30.137]     }, error = function(ex) {
[16:59:30.137]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.137]                 ...future.rng), started = ...future.startTime, 
[16:59:30.137]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.137]             version = "1.8"), class = "FutureResult")
[16:59:30.137]     }, finally = {
[16:59:30.137]         if (!identical(...future.workdir, getwd())) 
[16:59:30.137]             setwd(...future.workdir)
[16:59:30.137]         {
[16:59:30.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.137]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.137]             }
[16:59:30.137]             base::options(...future.oldOptions)
[16:59:30.137]             if (.Platform$OS.type == "windows") {
[16:59:30.137]                 old_names <- names(...future.oldEnvVars)
[16:59:30.137]                 envs <- base::Sys.getenv()
[16:59:30.137]                 names <- names(envs)
[16:59:30.137]                 common <- intersect(names, old_names)
[16:59:30.137]                 added <- setdiff(names, old_names)
[16:59:30.137]                 removed <- setdiff(old_names, names)
[16:59:30.137]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.137]                   envs[common]]
[16:59:30.137]                 NAMES <- toupper(changed)
[16:59:30.137]                 args <- list()
[16:59:30.137]                 for (kk in seq_along(NAMES)) {
[16:59:30.137]                   name <- changed[[kk]]
[16:59:30.137]                   NAME <- NAMES[[kk]]
[16:59:30.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.137]                     next
[16:59:30.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.137]                 }
[16:59:30.137]                 NAMES <- toupper(added)
[16:59:30.137]                 for (kk in seq_along(NAMES)) {
[16:59:30.137]                   name <- added[[kk]]
[16:59:30.137]                   NAME <- NAMES[[kk]]
[16:59:30.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.137]                     next
[16:59:30.137]                   args[[name]] <- ""
[16:59:30.137]                 }
[16:59:30.137]                 NAMES <- toupper(removed)
[16:59:30.137]                 for (kk in seq_along(NAMES)) {
[16:59:30.137]                   name <- removed[[kk]]
[16:59:30.137]                   NAME <- NAMES[[kk]]
[16:59:30.137]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.137]                     next
[16:59:30.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.137]                 }
[16:59:30.137]                 if (length(args) > 0) 
[16:59:30.137]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.137]             }
[16:59:30.137]             else {
[16:59:30.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.137]             }
[16:59:30.137]             {
[16:59:30.137]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.137]                   0L) {
[16:59:30.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.137]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.137]                   base::options(opts)
[16:59:30.137]                 }
[16:59:30.137]                 {
[16:59:30.137]                   {
[16:59:30.137]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.137]                     NULL
[16:59:30.137]                   }
[16:59:30.137]                   options(future.plan = NULL)
[16:59:30.137]                   if (is.na(NA_character_)) 
[16:59:30.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.137]                     .init = FALSE)
[16:59:30.137]                 }
[16:59:30.137]             }
[16:59:30.137]         }
[16:59:30.137]     })
[16:59:30.137]     if (TRUE) {
[16:59:30.137]         base::sink(type = "output", split = FALSE)
[16:59:30.137]         if (TRUE) {
[16:59:30.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.137]         }
[16:59:30.137]         else {
[16:59:30.137]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.137]         }
[16:59:30.137]         base::close(...future.stdout)
[16:59:30.137]         ...future.stdout <- NULL
[16:59:30.137]     }
[16:59:30.137]     ...future.result$conditions <- ...future.conditions
[16:59:30.137]     ...future.result$finished <- base::Sys.time()
[16:59:30.137]     ...future.result
[16:59:30.137] }
[16:59:30.139] assign_globals() ...
[16:59:30.139] List of 5
[16:59:30.139]  $ future.call.arguments    : list()
[16:59:30.139]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.139]  $ ...future.FUN            :function (x)  
[16:59:30.139]  $ ...future.elements_ii    :List of 1
[16:59:30.139]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:30.139]  $ ...future.seeds_ii       : NULL
[16:59:30.139]  $ ...future.globals.maxSize: num Inf
[16:59:30.139]  - attr(*, "resolved")= logi FALSE
[16:59:30.139]  - attr(*, "total_size")= num NA
[16:59:30.139]  - attr(*, "where")=List of 5
[16:59:30.139]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.139]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.139]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.139]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.139]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.139]  - attr(*, "already-done")= logi TRUE
[16:59:30.144] - copied ‘future.call.arguments’ to environment
[16:59:30.144] - copied ‘...future.FUN’ to environment
[16:59:30.144] - copied ‘...future.elements_ii’ to environment
[16:59:30.144] - copied ‘...future.seeds_ii’ to environment
[16:59:30.145] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.145] assign_globals() ... done
[16:59:30.145] requestCore(): workers = 2
[16:59:30.147] MulticoreFuture started
[16:59:30.147] - Launch lazy future ... done
[16:59:30.148] run() for ‘MulticoreFuture’ ... done
[16:59:30.148] Created future:
[16:59:30.148] plan(): Setting new future strategy stack:
[16:59:30.148] List of future strategies:
[16:59:30.148] 1. sequential:
[16:59:30.148]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.148]    - tweaked: FALSE
[16:59:30.148]    - call: NULL
[16:59:30.149] plan(): nbrOfWorkers() = 1
[16:59:30.152] plan(): Setting new future strategy stack:
[16:59:30.152] List of future strategies:
[16:59:30.152] 1. multicore:
[16:59:30.152]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.152]    - tweaked: FALSE
[16:59:30.152]    - call: plan(strategy)
[16:59:30.157] plan(): nbrOfWorkers() = 2
[16:59:30.148] MulticoreFuture:
[16:59:30.148] Label: ‘future_apply-1’
[16:59:30.148] Expression:
[16:59:30.148] {
[16:59:30.148]     do.call(function(...) {
[16:59:30.148]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.148]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.148]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.148]             on.exit(options(oopts), add = TRUE)
[16:59:30.148]         }
[16:59:30.148]         {
[16:59:30.148]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.148]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.148]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.148]             })
[16:59:30.148]         }
[16:59:30.148]     }, args = future.call.arguments)
[16:59:30.148] }
[16:59:30.148] Lazy evaluation: FALSE
[16:59:30.148] Asynchronous evaluation: TRUE
[16:59:30.148] Local evaluation: TRUE
[16:59:30.148] Environment: R_GlobalEnv
[16:59:30.148] Capture standard output: TRUE
[16:59:30.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.148] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.148] Packages: <none>
[16:59:30.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.148] Resolved: TRUE
[16:59:30.148] Value: <not collected>
[16:59:30.148] Conditions captured: <none>
[16:59:30.148] Early signaling: FALSE
[16:59:30.148] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.148] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.158] Chunk #1 of 2 ... DONE
[16:59:30.158] Chunk #2 of 2 ...
[16:59:30.158]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.159]  - seeds: <none>
[16:59:30.159]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.159] getGlobalsAndPackages() ...
[16:59:30.159] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.159] Resolving globals: FALSE
[16:59:30.159] Tweak future expression to call with '...' arguments ...
[16:59:30.160] {
[16:59:30.160]     do.call(function(...) {
[16:59:30.160]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.160]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.160]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.160]             on.exit(options(oopts), add = TRUE)
[16:59:30.160]         }
[16:59:30.160]         {
[16:59:30.160]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.160]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.160]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.160]             })
[16:59:30.160]         }
[16:59:30.160]     }, args = future.call.arguments)
[16:59:30.160] }
[16:59:30.160] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.161] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.161] 
[16:59:30.161] getGlobalsAndPackages() ... DONE
[16:59:30.161] run() for ‘Future’ ...
[16:59:30.162] - state: ‘created’
[16:59:30.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.167] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.167] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.167]   - Field: ‘label’
[16:59:30.167]   - Field: ‘local’
[16:59:30.167]   - Field: ‘owner’
[16:59:30.167]   - Field: ‘envir’
[16:59:30.168]   - Field: ‘workers’
[16:59:30.168]   - Field: ‘packages’
[16:59:30.168]   - Field: ‘gc’
[16:59:30.168]   - Field: ‘job’
[16:59:30.168]   - Field: ‘conditions’
[16:59:30.168]   - Field: ‘expr’
[16:59:30.168]   - Field: ‘uuid’
[16:59:30.169]   - Field: ‘seed’
[16:59:30.169]   - Field: ‘version’
[16:59:30.169]   - Field: ‘result’
[16:59:30.169]   - Field: ‘asynchronous’
[16:59:30.169]   - Field: ‘calls’
[16:59:30.169]   - Field: ‘globals’
[16:59:30.169]   - Field: ‘stdout’
[16:59:30.170]   - Field: ‘earlySignal’
[16:59:30.170]   - Field: ‘lazy’
[16:59:30.170]   - Field: ‘state’
[16:59:30.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.170] - Launch lazy future ...
[16:59:30.171] Packages needed by the future expression (n = 0): <none>
[16:59:30.171] Packages needed by future strategies (n = 0): <none>
[16:59:30.175] {
[16:59:30.175]     {
[16:59:30.175]         {
[16:59:30.175]             ...future.startTime <- base::Sys.time()
[16:59:30.175]             {
[16:59:30.175]                 {
[16:59:30.175]                   {
[16:59:30.175]                     {
[16:59:30.175]                       base::local({
[16:59:30.175]                         has_future <- base::requireNamespace("future", 
[16:59:30.175]                           quietly = TRUE)
[16:59:30.175]                         if (has_future) {
[16:59:30.175]                           ns <- base::getNamespace("future")
[16:59:30.175]                           version <- ns[[".package"]][["version"]]
[16:59:30.175]                           if (is.null(version)) 
[16:59:30.175]                             version <- utils::packageVersion("future")
[16:59:30.175]                         }
[16:59:30.175]                         else {
[16:59:30.175]                           version <- NULL
[16:59:30.175]                         }
[16:59:30.175]                         if (!has_future || version < "1.8.0") {
[16:59:30.175]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.175]                             "", base::R.version$version.string), 
[16:59:30.175]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.175]                               "release", "version")], collapse = " "), 
[16:59:30.175]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.175]                             info)
[16:59:30.175]                           info <- base::paste(info, collapse = "; ")
[16:59:30.175]                           if (!has_future) {
[16:59:30.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.175]                               info)
[16:59:30.175]                           }
[16:59:30.175]                           else {
[16:59:30.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.175]                               info, version)
[16:59:30.175]                           }
[16:59:30.175]                           base::stop(msg)
[16:59:30.175]                         }
[16:59:30.175]                       })
[16:59:30.175]                     }
[16:59:30.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.175]                     base::options(mc.cores = 1L)
[16:59:30.175]                   }
[16:59:30.175]                   ...future.strategy.old <- future::plan("list")
[16:59:30.175]                   options(future.plan = NULL)
[16:59:30.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.175]                 }
[16:59:30.175]                 ...future.workdir <- getwd()
[16:59:30.175]             }
[16:59:30.175]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.175]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.175]         }
[16:59:30.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.175]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.175]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.175]             base::names(...future.oldOptions))
[16:59:30.175]     }
[16:59:30.175]     if (FALSE) {
[16:59:30.175]     }
[16:59:30.175]     else {
[16:59:30.175]         if (TRUE) {
[16:59:30.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.175]                 open = "w")
[16:59:30.175]         }
[16:59:30.175]         else {
[16:59:30.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.175]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.175]         }
[16:59:30.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.175]             base::sink(type = "output", split = FALSE)
[16:59:30.175]             base::close(...future.stdout)
[16:59:30.175]         }, add = TRUE)
[16:59:30.175]     }
[16:59:30.175]     ...future.frame <- base::sys.nframe()
[16:59:30.175]     ...future.conditions <- base::list()
[16:59:30.175]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.175]     if (FALSE) {
[16:59:30.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.175]     }
[16:59:30.175]     ...future.result <- base::tryCatch({
[16:59:30.175]         base::withCallingHandlers({
[16:59:30.175]             ...future.value <- base::withVisible(base::local({
[16:59:30.175]                 withCallingHandlers({
[16:59:30.175]                   {
[16:59:30.175]                     do.call(function(...) {
[16:59:30.175]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.175]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.175]                         ...future.globals.maxSize)) {
[16:59:30.175]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.175]                         on.exit(options(oopts), add = TRUE)
[16:59:30.175]                       }
[16:59:30.175]                       {
[16:59:30.175]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.175]                           FUN = function(jj) {
[16:59:30.175]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.175]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.175]                           })
[16:59:30.175]                       }
[16:59:30.175]                     }, args = future.call.arguments)
[16:59:30.175]                   }
[16:59:30.175]                 }, immediateCondition = function(cond) {
[16:59:30.175]                   save_rds <- function (object, pathname, ...) 
[16:59:30.175]                   {
[16:59:30.175]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.175]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.175]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.175]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.175]                         fi_tmp[["mtime"]])
[16:59:30.175]                     }
[16:59:30.175]                     tryCatch({
[16:59:30.175]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.175]                     }, error = function(ex) {
[16:59:30.175]                       msg <- conditionMessage(ex)
[16:59:30.175]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.175]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.175]                         fi_tmp[["mtime"]], msg)
[16:59:30.175]                       ex$message <- msg
[16:59:30.175]                       stop(ex)
[16:59:30.175]                     })
[16:59:30.175]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.175]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.175]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.175]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.175]                       fi <- file.info(pathname)
[16:59:30.175]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.175]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.175]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.175]                         fi[["size"]], fi[["mtime"]])
[16:59:30.175]                       stop(msg)
[16:59:30.175]                     }
[16:59:30.175]                     invisible(pathname)
[16:59:30.175]                   }
[16:59:30.175]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.175]                     rootPath = tempdir()) 
[16:59:30.175]                   {
[16:59:30.175]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.175]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.175]                       tmpdir = path, fileext = ".rds")
[16:59:30.175]                     save_rds(obj, file)
[16:59:30.175]                   }
[16:59:30.175]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.175]                   {
[16:59:30.175]                     inherits <- base::inherits
[16:59:30.175]                     invokeRestart <- base::invokeRestart
[16:59:30.175]                     is.null <- base::is.null
[16:59:30.175]                     muffled <- FALSE
[16:59:30.175]                     if (inherits(cond, "message")) {
[16:59:30.175]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.175]                       if (muffled) 
[16:59:30.175]                         invokeRestart("muffleMessage")
[16:59:30.175]                     }
[16:59:30.175]                     else if (inherits(cond, "warning")) {
[16:59:30.175]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.175]                       if (muffled) 
[16:59:30.175]                         invokeRestart("muffleWarning")
[16:59:30.175]                     }
[16:59:30.175]                     else if (inherits(cond, "condition")) {
[16:59:30.175]                       if (!is.null(pattern)) {
[16:59:30.175]                         computeRestarts <- base::computeRestarts
[16:59:30.175]                         grepl <- base::grepl
[16:59:30.175]                         restarts <- computeRestarts(cond)
[16:59:30.175]                         for (restart in restarts) {
[16:59:30.175]                           name <- restart$name
[16:59:30.175]                           if (is.null(name)) 
[16:59:30.175]                             next
[16:59:30.175]                           if (!grepl(pattern, name)) 
[16:59:30.175]                             next
[16:59:30.175]                           invokeRestart(restart)
[16:59:30.175]                           muffled <- TRUE
[16:59:30.175]                           break
[16:59:30.175]                         }
[16:59:30.175]                       }
[16:59:30.175]                     }
[16:59:30.175]                     invisible(muffled)
[16:59:30.175]                   }
[16:59:30.175]                   muffleCondition(cond)
[16:59:30.175]                 })
[16:59:30.175]             }))
[16:59:30.175]             future::FutureResult(value = ...future.value$value, 
[16:59:30.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.175]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.175]                     ...future.globalenv.names))
[16:59:30.175]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.175]         }, condition = base::local({
[16:59:30.175]             c <- base::c
[16:59:30.175]             inherits <- base::inherits
[16:59:30.175]             invokeRestart <- base::invokeRestart
[16:59:30.175]             length <- base::length
[16:59:30.175]             list <- base::list
[16:59:30.175]             seq.int <- base::seq.int
[16:59:30.175]             signalCondition <- base::signalCondition
[16:59:30.175]             sys.calls <- base::sys.calls
[16:59:30.175]             `[[` <- base::`[[`
[16:59:30.175]             `+` <- base::`+`
[16:59:30.175]             `<<-` <- base::`<<-`
[16:59:30.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.175]                   3L)]
[16:59:30.175]             }
[16:59:30.175]             function(cond) {
[16:59:30.175]                 is_error <- inherits(cond, "error")
[16:59:30.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.175]                   NULL)
[16:59:30.175]                 if (is_error) {
[16:59:30.175]                   sessionInformation <- function() {
[16:59:30.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.175]                       search = base::search(), system = base::Sys.info())
[16:59:30.175]                   }
[16:59:30.175]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.175]                     cond$call), session = sessionInformation(), 
[16:59:30.175]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.175]                   signalCondition(cond)
[16:59:30.175]                 }
[16:59:30.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.175]                 "immediateCondition"))) {
[16:59:30.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.175]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.175]                   if (TRUE && !signal) {
[16:59:30.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.175]                     {
[16:59:30.175]                       inherits <- base::inherits
[16:59:30.175]                       invokeRestart <- base::invokeRestart
[16:59:30.175]                       is.null <- base::is.null
[16:59:30.175]                       muffled <- FALSE
[16:59:30.175]                       if (inherits(cond, "message")) {
[16:59:30.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.175]                         if (muffled) 
[16:59:30.175]                           invokeRestart("muffleMessage")
[16:59:30.175]                       }
[16:59:30.175]                       else if (inherits(cond, "warning")) {
[16:59:30.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.175]                         if (muffled) 
[16:59:30.175]                           invokeRestart("muffleWarning")
[16:59:30.175]                       }
[16:59:30.175]                       else if (inherits(cond, "condition")) {
[16:59:30.175]                         if (!is.null(pattern)) {
[16:59:30.175]                           computeRestarts <- base::computeRestarts
[16:59:30.175]                           grepl <- base::grepl
[16:59:30.175]                           restarts <- computeRestarts(cond)
[16:59:30.175]                           for (restart in restarts) {
[16:59:30.175]                             name <- restart$name
[16:59:30.175]                             if (is.null(name)) 
[16:59:30.175]                               next
[16:59:30.175]                             if (!grepl(pattern, name)) 
[16:59:30.175]                               next
[16:59:30.175]                             invokeRestart(restart)
[16:59:30.175]                             muffled <- TRUE
[16:59:30.175]                             break
[16:59:30.175]                           }
[16:59:30.175]                         }
[16:59:30.175]                       }
[16:59:30.175]                       invisible(muffled)
[16:59:30.175]                     }
[16:59:30.175]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.175]                   }
[16:59:30.175]                 }
[16:59:30.175]                 else {
[16:59:30.175]                   if (TRUE) {
[16:59:30.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.175]                     {
[16:59:30.175]                       inherits <- base::inherits
[16:59:30.175]                       invokeRestart <- base::invokeRestart
[16:59:30.175]                       is.null <- base::is.null
[16:59:30.175]                       muffled <- FALSE
[16:59:30.175]                       if (inherits(cond, "message")) {
[16:59:30.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.175]                         if (muffled) 
[16:59:30.175]                           invokeRestart("muffleMessage")
[16:59:30.175]                       }
[16:59:30.175]                       else if (inherits(cond, "warning")) {
[16:59:30.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.175]                         if (muffled) 
[16:59:30.175]                           invokeRestart("muffleWarning")
[16:59:30.175]                       }
[16:59:30.175]                       else if (inherits(cond, "condition")) {
[16:59:30.175]                         if (!is.null(pattern)) {
[16:59:30.175]                           computeRestarts <- base::computeRestarts
[16:59:30.175]                           grepl <- base::grepl
[16:59:30.175]                           restarts <- computeRestarts(cond)
[16:59:30.175]                           for (restart in restarts) {
[16:59:30.175]                             name <- restart$name
[16:59:30.175]                             if (is.null(name)) 
[16:59:30.175]                               next
[16:59:30.175]                             if (!grepl(pattern, name)) 
[16:59:30.175]                               next
[16:59:30.175]                             invokeRestart(restart)
[16:59:30.175]                             muffled <- TRUE
[16:59:30.175]                             break
[16:59:30.175]                           }
[16:59:30.175]                         }
[16:59:30.175]                       }
[16:59:30.175]                       invisible(muffled)
[16:59:30.175]                     }
[16:59:30.175]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.175]                   }
[16:59:30.175]                 }
[16:59:30.175]             }
[16:59:30.175]         }))
[16:59:30.175]     }, error = function(ex) {
[16:59:30.175]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.175]                 ...future.rng), started = ...future.startTime, 
[16:59:30.175]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.175]             version = "1.8"), class = "FutureResult")
[16:59:30.175]     }, finally = {
[16:59:30.175]         if (!identical(...future.workdir, getwd())) 
[16:59:30.175]             setwd(...future.workdir)
[16:59:30.175]         {
[16:59:30.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.175]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.175]             }
[16:59:30.175]             base::options(...future.oldOptions)
[16:59:30.175]             if (.Platform$OS.type == "windows") {
[16:59:30.175]                 old_names <- names(...future.oldEnvVars)
[16:59:30.175]                 envs <- base::Sys.getenv()
[16:59:30.175]                 names <- names(envs)
[16:59:30.175]                 common <- intersect(names, old_names)
[16:59:30.175]                 added <- setdiff(names, old_names)
[16:59:30.175]                 removed <- setdiff(old_names, names)
[16:59:30.175]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.175]                   envs[common]]
[16:59:30.175]                 NAMES <- toupper(changed)
[16:59:30.175]                 args <- list()
[16:59:30.175]                 for (kk in seq_along(NAMES)) {
[16:59:30.175]                   name <- changed[[kk]]
[16:59:30.175]                   NAME <- NAMES[[kk]]
[16:59:30.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.175]                     next
[16:59:30.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.175]                 }
[16:59:30.175]                 NAMES <- toupper(added)
[16:59:30.175]                 for (kk in seq_along(NAMES)) {
[16:59:30.175]                   name <- added[[kk]]
[16:59:30.175]                   NAME <- NAMES[[kk]]
[16:59:30.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.175]                     next
[16:59:30.175]                   args[[name]] <- ""
[16:59:30.175]                 }
[16:59:30.175]                 NAMES <- toupper(removed)
[16:59:30.175]                 for (kk in seq_along(NAMES)) {
[16:59:30.175]                   name <- removed[[kk]]
[16:59:30.175]                   NAME <- NAMES[[kk]]
[16:59:30.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.175]                     next
[16:59:30.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.175]                 }
[16:59:30.175]                 if (length(args) > 0) 
[16:59:30.175]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.175]             }
[16:59:30.175]             else {
[16:59:30.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.175]             }
[16:59:30.175]             {
[16:59:30.175]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.175]                   0L) {
[16:59:30.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.175]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.175]                   base::options(opts)
[16:59:30.175]                 }
[16:59:30.175]                 {
[16:59:30.175]                   {
[16:59:30.175]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.175]                     NULL
[16:59:30.175]                   }
[16:59:30.175]                   options(future.plan = NULL)
[16:59:30.175]                   if (is.na(NA_character_)) 
[16:59:30.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.175]                     .init = FALSE)
[16:59:30.175]                 }
[16:59:30.175]             }
[16:59:30.175]         }
[16:59:30.175]     })
[16:59:30.175]     if (TRUE) {
[16:59:30.175]         base::sink(type = "output", split = FALSE)
[16:59:30.175]         if (TRUE) {
[16:59:30.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.175]         }
[16:59:30.175]         else {
[16:59:30.175]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.175]         }
[16:59:30.175]         base::close(...future.stdout)
[16:59:30.175]         ...future.stdout <- NULL
[16:59:30.175]     }
[16:59:30.175]     ...future.result$conditions <- ...future.conditions
[16:59:30.175]     ...future.result$finished <- base::Sys.time()
[16:59:30.175]     ...future.result
[16:59:30.175] }
[16:59:30.178] assign_globals() ...
[16:59:30.179] List of 5
[16:59:30.179]  $ future.call.arguments    : list()
[16:59:30.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.179]  $ ...future.FUN            :function (x)  
[16:59:30.179]  $ ...future.elements_ii    :List of 1
[16:59:30.179]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:30.179]  $ ...future.seeds_ii       : NULL
[16:59:30.179]  $ ...future.globals.maxSize: num Inf
[16:59:30.179]  - attr(*, "resolved")= logi FALSE
[16:59:30.179]  - attr(*, "total_size")= num NA
[16:59:30.179]  - attr(*, "where")=List of 5
[16:59:30.179]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.179]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.179]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.179]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.179]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.179]  - attr(*, "already-done")= logi TRUE
[16:59:30.188] - copied ‘future.call.arguments’ to environment
[16:59:30.188] - copied ‘...future.FUN’ to environment
[16:59:30.188] - copied ‘...future.elements_ii’ to environment
[16:59:30.189] - copied ‘...future.seeds_ii’ to environment
[16:59:30.189] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.189] assign_globals() ... done
[16:59:30.189] requestCore(): workers = 2
[16:59:30.191] MulticoreFuture started
[16:59:30.192] - Launch lazy future ... done
[16:59:30.192] run() for ‘MulticoreFuture’ ... done
[16:59:30.192] Created future:
[16:59:30.193] plan(): Setting new future strategy stack:
[16:59:30.193] List of future strategies:
[16:59:30.193] 1. sequential:
[16:59:30.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.193]    - tweaked: FALSE
[16:59:30.193]    - call: NULL
[16:59:30.194] plan(): nbrOfWorkers() = 1
[16:59:30.196] plan(): Setting new future strategy stack:
[16:59:30.196] List of future strategies:
[16:59:30.196] 1. multicore:
[16:59:30.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.196]    - tweaked: FALSE
[16:59:30.196]    - call: plan(strategy)
[16:59:30.201] plan(): nbrOfWorkers() = 2
[16:59:30.192] MulticoreFuture:
[16:59:30.192] Label: ‘future_apply-2’
[16:59:30.192] Expression:
[16:59:30.192] {
[16:59:30.192]     do.call(function(...) {
[16:59:30.192]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.192]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.192]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.192]             on.exit(options(oopts), add = TRUE)
[16:59:30.192]         }
[16:59:30.192]         {
[16:59:30.192]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.192]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.192]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.192]             })
[16:59:30.192]         }
[16:59:30.192]     }, args = future.call.arguments)
[16:59:30.192] }
[16:59:30.192] Lazy evaluation: FALSE
[16:59:30.192] Asynchronous evaluation: TRUE
[16:59:30.192] Local evaluation: TRUE
[16:59:30.192] Environment: R_GlobalEnv
[16:59:30.192] Capture standard output: TRUE
[16:59:30.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.192] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.192] Packages: <none>
[16:59:30.192] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.192] Resolved: TRUE
[16:59:30.192] Value: <not collected>
[16:59:30.192] Conditions captured: <none>
[16:59:30.192] Early signaling: FALSE
[16:59:30.192] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.192] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.203] Chunk #2 of 2 ... DONE
[16:59:30.203] Launching 2 futures (chunks) ... DONE
[16:59:30.203] Resolving 2 futures (chunks) ...
[16:59:30.203] resolve() on list ...
[16:59:30.203]  recursive: 0
[16:59:30.203]  length: 2
[16:59:30.204] 
[16:59:30.204] Future #1
[16:59:30.204] result() for MulticoreFuture ...
[16:59:30.205] result() for MulticoreFuture ...
[16:59:30.205] result() for MulticoreFuture ... done
[16:59:30.205] result() for MulticoreFuture ... done
[16:59:30.205] result() for MulticoreFuture ...
[16:59:30.205] result() for MulticoreFuture ... done
[16:59:30.206] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.206] - nx: 2
[16:59:30.206] - relay: TRUE
[16:59:30.206] - stdout: TRUE
[16:59:30.206] - signal: TRUE
[16:59:30.206] - resignal: FALSE
[16:59:30.206] - force: TRUE
[16:59:30.207] - relayed: [n=2] FALSE, FALSE
[16:59:30.207] - queued futures: [n=2] FALSE, FALSE
[16:59:30.207]  - until=1
[16:59:30.207]  - relaying element #1
[16:59:30.207] result() for MulticoreFuture ...
[16:59:30.207] result() for MulticoreFuture ... done
[16:59:30.207] result() for MulticoreFuture ...
[16:59:30.208] result() for MulticoreFuture ... done
[16:59:30.208] result() for MulticoreFuture ...
[16:59:30.208] result() for MulticoreFuture ... done
[16:59:30.208] result() for MulticoreFuture ...
[16:59:30.208] result() for MulticoreFuture ... done
[16:59:30.208] - relayed: [n=2] TRUE, FALSE
[16:59:30.209] - queued futures: [n=2] TRUE, FALSE
[16:59:30.209] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.209]  length: 1 (resolved future 1)
[16:59:30.209] Future #2
[16:59:30.210] result() for MulticoreFuture ...
[16:59:30.210] result() for MulticoreFuture ...
[16:59:30.210] result() for MulticoreFuture ... done
[16:59:30.211] result() for MulticoreFuture ... done
[16:59:30.211] result() for MulticoreFuture ...
[16:59:30.211] result() for MulticoreFuture ... done
[16:59:30.211] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.211] - nx: 2
[16:59:30.211] - relay: TRUE
[16:59:30.212] - stdout: TRUE
[16:59:30.212] - signal: TRUE
[16:59:30.212] - resignal: FALSE
[16:59:30.212] - force: TRUE
[16:59:30.212] - relayed: [n=2] TRUE, FALSE
[16:59:30.212] - queued futures: [n=2] TRUE, FALSE
[16:59:30.212]  - until=2
[16:59:30.212]  - relaying element #2
[16:59:30.213] result() for MulticoreFuture ...
[16:59:30.213] result() for MulticoreFuture ... done
[16:59:30.213] result() for MulticoreFuture ...
[16:59:30.213] result() for MulticoreFuture ... done
[16:59:30.213] result() for MulticoreFuture ...
[16:59:30.213] result() for MulticoreFuture ... done
[16:59:30.213] result() for MulticoreFuture ...
[16:59:30.213] result() for MulticoreFuture ... done
[16:59:30.213] - relayed: [n=2] TRUE, TRUE
[16:59:30.214] - queued futures: [n=2] TRUE, TRUE
[16:59:30.214] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.214]  length: 0 (resolved future 2)
[16:59:30.214] Relaying remaining futures
[16:59:30.214] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.214] - nx: 2
[16:59:30.214] - relay: TRUE
[16:59:30.214] - stdout: TRUE
[16:59:30.214] - signal: TRUE
[16:59:30.214] - resignal: FALSE
[16:59:30.215] - force: TRUE
[16:59:30.215] - relayed: [n=2] TRUE, TRUE
[16:59:30.215] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.215] - relayed: [n=2] TRUE, TRUE
[16:59:30.215] - queued futures: [n=2] TRUE, TRUE
[16:59:30.215] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.215] resolve() on list ... DONE
[16:59:30.215] result() for MulticoreFuture ...
[16:59:30.216] result() for MulticoreFuture ... done
[16:59:30.216] result() for MulticoreFuture ...
[16:59:30.216] result() for MulticoreFuture ... done
[16:59:30.216] result() for MulticoreFuture ...
[16:59:30.216] result() for MulticoreFuture ... done
[16:59:30.216] result() for MulticoreFuture ...
[16:59:30.216] result() for MulticoreFuture ... done
[16:59:30.216]  - Number of value chunks collected: 2
[16:59:30.216] Resolving 2 futures (chunks) ... DONE
[16:59:30.217] Reducing values from 2 chunks ...
[16:59:30.217]  - Number of values collected after concatenation: 2
[16:59:30.217]  - Number of values expected: 2
[16:59:30.217] Reducing values from 2 chunks ... DONE
[16:59:30.217] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:59:30.217] getGlobalsAndPackagesXApply() ...
[16:59:30.218]  - future.globals: TRUE
[16:59:30.218] getGlobalsAndPackages() ...
[16:59:30.218] Searching for globals...
[16:59:30.219] - globals found: [1] ‘FUN’
[16:59:30.219] Searching for globals ... DONE
[16:59:30.219] Resolving globals: FALSE
[16:59:30.220] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:30.221] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:30.221] - globals: [1] ‘FUN’
[16:59:30.221] 
[16:59:30.221] getGlobalsAndPackages() ... DONE
[16:59:30.221]  - globals found/used: [n=1] ‘FUN’
[16:59:30.221]  - needed namespaces: [n=0] 
[16:59:30.221] Finding globals ... DONE
[16:59:30.221]  - use_args: TRUE
[16:59:30.221]  - Getting '...' globals ...
[16:59:30.222] resolve() on list ...
[16:59:30.222]  recursive: 0
[16:59:30.222]  length: 1
[16:59:30.222]  elements: ‘...’
[16:59:30.222]  length: 0 (resolved future 1)
[16:59:30.222] resolve() on list ... DONE
[16:59:30.223]    - '...' content: [n=0] 
[16:59:30.223] List of 1
[16:59:30.223]  $ ...: list()
[16:59:30.223]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.223]  - attr(*, "where")=List of 1
[16:59:30.223]   ..$ ...:<environment: 0x55f313da0910> 
[16:59:30.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.223]  - attr(*, "resolved")= logi TRUE
[16:59:30.223]  - attr(*, "total_size")= num NA
[16:59:30.229]  - Getting '...' globals ... DONE
[16:59:30.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.229] List of 2
[16:59:30.229]  $ ...future.FUN:function (x)  
[16:59:30.229]  $ ...          : list()
[16:59:30.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.229]  - attr(*, "where")=List of 2
[16:59:30.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.229]   ..$ ...          :<environment: 0x55f313da0910> 
[16:59:30.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.229]  - attr(*, "resolved")= logi FALSE
[16:59:30.229]  - attr(*, "total_size")= num 848
[16:59:30.233] Packages to be attached in all futures: [n=0] 
[16:59:30.233] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.237] future_lapply() ...
[16:59:30.240] Number of chunks: 2
[16:59:30.240] getGlobalsAndPackagesXApply() ...
[16:59:30.241]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.241]  - use_args: TRUE
[16:59:30.241] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.241] List of 2
[16:59:30.241]  $ ...          : list()
[16:59:30.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.241]  $ ...future.FUN:function (x)  
[16:59:30.241]  - attr(*, "where")=List of 2
[16:59:30.241]   ..$ ...          :<environment: 0x55f313da0910> 
[16:59:30.241]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:30.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.241]  - attr(*, "resolved")= logi FALSE
[16:59:30.241]  - attr(*, "total_size")= num NA
[16:59:30.244] Packages to be attached in all futures: [n=0] 
[16:59:30.245] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.245] Number of futures (= number of chunks): 2
[16:59:30.245] Launching 2 futures (chunks) ...
[16:59:30.245] Chunk #1 of 2 ...
[16:59:30.245]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.245]  - seeds: <none>
[16:59:30.245]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.245] getGlobalsAndPackages() ...
[16:59:30.246] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.246] Resolving globals: FALSE
[16:59:30.246] Tweak future expression to call with '...' arguments ...
[16:59:30.246] {
[16:59:30.246]     do.call(function(...) {
[16:59:30.246]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.246]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.246]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.246]             on.exit(options(oopts), add = TRUE)
[16:59:30.246]         }
[16:59:30.246]         {
[16:59:30.246]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.246]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.246]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.246]             })
[16:59:30.246]         }
[16:59:30.246]     }, args = future.call.arguments)
[16:59:30.246] }
[16:59:30.246] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.247] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.247] 
[16:59:30.247] getGlobalsAndPackages() ... DONE
[16:59:30.247] run() for ‘Future’ ...
[16:59:30.247] - state: ‘created’
[16:59:30.247] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.251] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.251]   - Field: ‘label’
[16:59:30.251]   - Field: ‘local’
[16:59:30.251]   - Field: ‘owner’
[16:59:30.251]   - Field: ‘envir’
[16:59:30.252]   - Field: ‘workers’
[16:59:30.252]   - Field: ‘packages’
[16:59:30.252]   - Field: ‘gc’
[16:59:30.252]   - Field: ‘job’
[16:59:30.252]   - Field: ‘conditions’
[16:59:30.252]   - Field: ‘expr’
[16:59:30.252]   - Field: ‘uuid’
[16:59:30.252]   - Field: ‘seed’
[16:59:30.252]   - Field: ‘version’
[16:59:30.252]   - Field: ‘result’
[16:59:30.252]   - Field: ‘asynchronous’
[16:59:30.253]   - Field: ‘calls’
[16:59:30.253]   - Field: ‘globals’
[16:59:30.253]   - Field: ‘stdout’
[16:59:30.253]   - Field: ‘earlySignal’
[16:59:30.253]   - Field: ‘lazy’
[16:59:30.253]   - Field: ‘state’
[16:59:30.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.253] - Launch lazy future ...
[16:59:30.253] Packages needed by the future expression (n = 0): <none>
[16:59:30.254] Packages needed by future strategies (n = 0): <none>
[16:59:30.254] {
[16:59:30.254]     {
[16:59:30.254]         {
[16:59:30.254]             ...future.startTime <- base::Sys.time()
[16:59:30.254]             {
[16:59:30.254]                 {
[16:59:30.254]                   {
[16:59:30.254]                     {
[16:59:30.254]                       base::local({
[16:59:30.254]                         has_future <- base::requireNamespace("future", 
[16:59:30.254]                           quietly = TRUE)
[16:59:30.254]                         if (has_future) {
[16:59:30.254]                           ns <- base::getNamespace("future")
[16:59:30.254]                           version <- ns[[".package"]][["version"]]
[16:59:30.254]                           if (is.null(version)) 
[16:59:30.254]                             version <- utils::packageVersion("future")
[16:59:30.254]                         }
[16:59:30.254]                         else {
[16:59:30.254]                           version <- NULL
[16:59:30.254]                         }
[16:59:30.254]                         if (!has_future || version < "1.8.0") {
[16:59:30.254]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.254]                             "", base::R.version$version.string), 
[16:59:30.254]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.254]                               "release", "version")], collapse = " "), 
[16:59:30.254]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.254]                             info)
[16:59:30.254]                           info <- base::paste(info, collapse = "; ")
[16:59:30.254]                           if (!has_future) {
[16:59:30.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.254]                               info)
[16:59:30.254]                           }
[16:59:30.254]                           else {
[16:59:30.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.254]                               info, version)
[16:59:30.254]                           }
[16:59:30.254]                           base::stop(msg)
[16:59:30.254]                         }
[16:59:30.254]                       })
[16:59:30.254]                     }
[16:59:30.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.254]                     base::options(mc.cores = 1L)
[16:59:30.254]                   }
[16:59:30.254]                   ...future.strategy.old <- future::plan("list")
[16:59:30.254]                   options(future.plan = NULL)
[16:59:30.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.254]                 }
[16:59:30.254]                 ...future.workdir <- getwd()
[16:59:30.254]             }
[16:59:30.254]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.254]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.254]         }
[16:59:30.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.254]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.254]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.254]             base::names(...future.oldOptions))
[16:59:30.254]     }
[16:59:30.254]     if (FALSE) {
[16:59:30.254]     }
[16:59:30.254]     else {
[16:59:30.254]         if (TRUE) {
[16:59:30.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.254]                 open = "w")
[16:59:30.254]         }
[16:59:30.254]         else {
[16:59:30.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.254]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.254]         }
[16:59:30.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.254]             base::sink(type = "output", split = FALSE)
[16:59:30.254]             base::close(...future.stdout)
[16:59:30.254]         }, add = TRUE)
[16:59:30.254]     }
[16:59:30.254]     ...future.frame <- base::sys.nframe()
[16:59:30.254]     ...future.conditions <- base::list()
[16:59:30.254]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.254]     if (FALSE) {
[16:59:30.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.254]     }
[16:59:30.254]     ...future.result <- base::tryCatch({
[16:59:30.254]         base::withCallingHandlers({
[16:59:30.254]             ...future.value <- base::withVisible(base::local({
[16:59:30.254]                 withCallingHandlers({
[16:59:30.254]                   {
[16:59:30.254]                     do.call(function(...) {
[16:59:30.254]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.254]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.254]                         ...future.globals.maxSize)) {
[16:59:30.254]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.254]                         on.exit(options(oopts), add = TRUE)
[16:59:30.254]                       }
[16:59:30.254]                       {
[16:59:30.254]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.254]                           FUN = function(jj) {
[16:59:30.254]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.254]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.254]                           })
[16:59:30.254]                       }
[16:59:30.254]                     }, args = future.call.arguments)
[16:59:30.254]                   }
[16:59:30.254]                 }, immediateCondition = function(cond) {
[16:59:30.254]                   save_rds <- function (object, pathname, ...) 
[16:59:30.254]                   {
[16:59:30.254]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.254]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.254]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.254]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.254]                         fi_tmp[["mtime"]])
[16:59:30.254]                     }
[16:59:30.254]                     tryCatch({
[16:59:30.254]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.254]                     }, error = function(ex) {
[16:59:30.254]                       msg <- conditionMessage(ex)
[16:59:30.254]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.254]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.254]                         fi_tmp[["mtime"]], msg)
[16:59:30.254]                       ex$message <- msg
[16:59:30.254]                       stop(ex)
[16:59:30.254]                     })
[16:59:30.254]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.254]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.254]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.254]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.254]                       fi <- file.info(pathname)
[16:59:30.254]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.254]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.254]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.254]                         fi[["size"]], fi[["mtime"]])
[16:59:30.254]                       stop(msg)
[16:59:30.254]                     }
[16:59:30.254]                     invisible(pathname)
[16:59:30.254]                   }
[16:59:30.254]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.254]                     rootPath = tempdir()) 
[16:59:30.254]                   {
[16:59:30.254]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.254]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.254]                       tmpdir = path, fileext = ".rds")
[16:59:30.254]                     save_rds(obj, file)
[16:59:30.254]                   }
[16:59:30.254]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.254]                   {
[16:59:30.254]                     inherits <- base::inherits
[16:59:30.254]                     invokeRestart <- base::invokeRestart
[16:59:30.254]                     is.null <- base::is.null
[16:59:30.254]                     muffled <- FALSE
[16:59:30.254]                     if (inherits(cond, "message")) {
[16:59:30.254]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.254]                       if (muffled) 
[16:59:30.254]                         invokeRestart("muffleMessage")
[16:59:30.254]                     }
[16:59:30.254]                     else if (inherits(cond, "warning")) {
[16:59:30.254]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.254]                       if (muffled) 
[16:59:30.254]                         invokeRestart("muffleWarning")
[16:59:30.254]                     }
[16:59:30.254]                     else if (inherits(cond, "condition")) {
[16:59:30.254]                       if (!is.null(pattern)) {
[16:59:30.254]                         computeRestarts <- base::computeRestarts
[16:59:30.254]                         grepl <- base::grepl
[16:59:30.254]                         restarts <- computeRestarts(cond)
[16:59:30.254]                         for (restart in restarts) {
[16:59:30.254]                           name <- restart$name
[16:59:30.254]                           if (is.null(name)) 
[16:59:30.254]                             next
[16:59:30.254]                           if (!grepl(pattern, name)) 
[16:59:30.254]                             next
[16:59:30.254]                           invokeRestart(restart)
[16:59:30.254]                           muffled <- TRUE
[16:59:30.254]                           break
[16:59:30.254]                         }
[16:59:30.254]                       }
[16:59:30.254]                     }
[16:59:30.254]                     invisible(muffled)
[16:59:30.254]                   }
[16:59:30.254]                   muffleCondition(cond)
[16:59:30.254]                 })
[16:59:30.254]             }))
[16:59:30.254]             future::FutureResult(value = ...future.value$value, 
[16:59:30.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.254]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.254]                     ...future.globalenv.names))
[16:59:30.254]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.254]         }, condition = base::local({
[16:59:30.254]             c <- base::c
[16:59:30.254]             inherits <- base::inherits
[16:59:30.254]             invokeRestart <- base::invokeRestart
[16:59:30.254]             length <- base::length
[16:59:30.254]             list <- base::list
[16:59:30.254]             seq.int <- base::seq.int
[16:59:30.254]             signalCondition <- base::signalCondition
[16:59:30.254]             sys.calls <- base::sys.calls
[16:59:30.254]             `[[` <- base::`[[`
[16:59:30.254]             `+` <- base::`+`
[16:59:30.254]             `<<-` <- base::`<<-`
[16:59:30.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.254]                   3L)]
[16:59:30.254]             }
[16:59:30.254]             function(cond) {
[16:59:30.254]                 is_error <- inherits(cond, "error")
[16:59:30.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.254]                   NULL)
[16:59:30.254]                 if (is_error) {
[16:59:30.254]                   sessionInformation <- function() {
[16:59:30.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.254]                       search = base::search(), system = base::Sys.info())
[16:59:30.254]                   }
[16:59:30.254]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.254]                     cond$call), session = sessionInformation(), 
[16:59:30.254]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.254]                   signalCondition(cond)
[16:59:30.254]                 }
[16:59:30.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.254]                 "immediateCondition"))) {
[16:59:30.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.254]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.254]                   if (TRUE && !signal) {
[16:59:30.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.254]                     {
[16:59:30.254]                       inherits <- base::inherits
[16:59:30.254]                       invokeRestart <- base::invokeRestart
[16:59:30.254]                       is.null <- base::is.null
[16:59:30.254]                       muffled <- FALSE
[16:59:30.254]                       if (inherits(cond, "message")) {
[16:59:30.254]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.254]                         if (muffled) 
[16:59:30.254]                           invokeRestart("muffleMessage")
[16:59:30.254]                       }
[16:59:30.254]                       else if (inherits(cond, "warning")) {
[16:59:30.254]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.254]                         if (muffled) 
[16:59:30.254]                           invokeRestart("muffleWarning")
[16:59:30.254]                       }
[16:59:30.254]                       else if (inherits(cond, "condition")) {
[16:59:30.254]                         if (!is.null(pattern)) {
[16:59:30.254]                           computeRestarts <- base::computeRestarts
[16:59:30.254]                           grepl <- base::grepl
[16:59:30.254]                           restarts <- computeRestarts(cond)
[16:59:30.254]                           for (restart in restarts) {
[16:59:30.254]                             name <- restart$name
[16:59:30.254]                             if (is.null(name)) 
[16:59:30.254]                               next
[16:59:30.254]                             if (!grepl(pattern, name)) 
[16:59:30.254]                               next
[16:59:30.254]                             invokeRestart(restart)
[16:59:30.254]                             muffled <- TRUE
[16:59:30.254]                             break
[16:59:30.254]                           }
[16:59:30.254]                         }
[16:59:30.254]                       }
[16:59:30.254]                       invisible(muffled)
[16:59:30.254]                     }
[16:59:30.254]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.254]                   }
[16:59:30.254]                 }
[16:59:30.254]                 else {
[16:59:30.254]                   if (TRUE) {
[16:59:30.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.254]                     {
[16:59:30.254]                       inherits <- base::inherits
[16:59:30.254]                       invokeRestart <- base::invokeRestart
[16:59:30.254]                       is.null <- base::is.null
[16:59:30.254]                       muffled <- FALSE
[16:59:30.254]                       if (inherits(cond, "message")) {
[16:59:30.254]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.254]                         if (muffled) 
[16:59:30.254]                           invokeRestart("muffleMessage")
[16:59:30.254]                       }
[16:59:30.254]                       else if (inherits(cond, "warning")) {
[16:59:30.254]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.254]                         if (muffled) 
[16:59:30.254]                           invokeRestart("muffleWarning")
[16:59:30.254]                       }
[16:59:30.254]                       else if (inherits(cond, "condition")) {
[16:59:30.254]                         if (!is.null(pattern)) {
[16:59:30.254]                           computeRestarts <- base::computeRestarts
[16:59:30.254]                           grepl <- base::grepl
[16:59:30.254]                           restarts <- computeRestarts(cond)
[16:59:30.254]                           for (restart in restarts) {
[16:59:30.254]                             name <- restart$name
[16:59:30.254]                             if (is.null(name)) 
[16:59:30.254]                               next
[16:59:30.254]                             if (!grepl(pattern, name)) 
[16:59:30.254]                               next
[16:59:30.254]                             invokeRestart(restart)
[16:59:30.254]                             muffled <- TRUE
[16:59:30.254]                             break
[16:59:30.254]                           }
[16:59:30.254]                         }
[16:59:30.254]                       }
[16:59:30.254]                       invisible(muffled)
[16:59:30.254]                     }
[16:59:30.254]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.254]                   }
[16:59:30.254]                 }
[16:59:30.254]             }
[16:59:30.254]         }))
[16:59:30.254]     }, error = function(ex) {
[16:59:30.254]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.254]                 ...future.rng), started = ...future.startTime, 
[16:59:30.254]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.254]             version = "1.8"), class = "FutureResult")
[16:59:30.254]     }, finally = {
[16:59:30.254]         if (!identical(...future.workdir, getwd())) 
[16:59:30.254]             setwd(...future.workdir)
[16:59:30.254]         {
[16:59:30.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.254]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.254]             }
[16:59:30.254]             base::options(...future.oldOptions)
[16:59:30.254]             if (.Platform$OS.type == "windows") {
[16:59:30.254]                 old_names <- names(...future.oldEnvVars)
[16:59:30.254]                 envs <- base::Sys.getenv()
[16:59:30.254]                 names <- names(envs)
[16:59:30.254]                 common <- intersect(names, old_names)
[16:59:30.254]                 added <- setdiff(names, old_names)
[16:59:30.254]                 removed <- setdiff(old_names, names)
[16:59:30.254]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.254]                   envs[common]]
[16:59:30.254]                 NAMES <- toupper(changed)
[16:59:30.254]                 args <- list()
[16:59:30.254]                 for (kk in seq_along(NAMES)) {
[16:59:30.254]                   name <- changed[[kk]]
[16:59:30.254]                   NAME <- NAMES[[kk]]
[16:59:30.254]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.254]                     next
[16:59:30.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.254]                 }
[16:59:30.254]                 NAMES <- toupper(added)
[16:59:30.254]                 for (kk in seq_along(NAMES)) {
[16:59:30.254]                   name <- added[[kk]]
[16:59:30.254]                   NAME <- NAMES[[kk]]
[16:59:30.254]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.254]                     next
[16:59:30.254]                   args[[name]] <- ""
[16:59:30.254]                 }
[16:59:30.254]                 NAMES <- toupper(removed)
[16:59:30.254]                 for (kk in seq_along(NAMES)) {
[16:59:30.254]                   name <- removed[[kk]]
[16:59:30.254]                   NAME <- NAMES[[kk]]
[16:59:30.254]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.254]                     next
[16:59:30.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.254]                 }
[16:59:30.254]                 if (length(args) > 0) 
[16:59:30.254]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.254]             }
[16:59:30.254]             else {
[16:59:30.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.254]             }
[16:59:30.254]             {
[16:59:30.254]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.254]                   0L) {
[16:59:30.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.254]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.254]                   base::options(opts)
[16:59:30.254]                 }
[16:59:30.254]                 {
[16:59:30.254]                   {
[16:59:30.254]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.254]                     NULL
[16:59:30.254]                   }
[16:59:30.254]                   options(future.plan = NULL)
[16:59:30.254]                   if (is.na(NA_character_)) 
[16:59:30.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.254]                     .init = FALSE)
[16:59:30.254]                 }
[16:59:30.254]             }
[16:59:30.254]         }
[16:59:30.254]     })
[16:59:30.254]     if (TRUE) {
[16:59:30.254]         base::sink(type = "output", split = FALSE)
[16:59:30.254]         if (TRUE) {
[16:59:30.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.254]         }
[16:59:30.254]         else {
[16:59:30.254]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.254]         }
[16:59:30.254]         base::close(...future.stdout)
[16:59:30.254]         ...future.stdout <- NULL
[16:59:30.254]     }
[16:59:30.254]     ...future.result$conditions <- ...future.conditions
[16:59:30.254]     ...future.result$finished <- base::Sys.time()
[16:59:30.254]     ...future.result
[16:59:30.254] }
[16:59:30.256] assign_globals() ...
[16:59:30.257] List of 5
[16:59:30.257]  $ future.call.arguments    : list()
[16:59:30.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.257]  $ ...future.FUN            :function (x)  
[16:59:30.257]  $ ...future.elements_ii    :List of 3
[16:59:30.257]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:30.257]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:30.257]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:30.257]  $ ...future.seeds_ii       : NULL
[16:59:30.257]  $ ...future.globals.maxSize: num Inf
[16:59:30.257]  - attr(*, "resolved")= logi FALSE
[16:59:30.257]  - attr(*, "total_size")= num NA
[16:59:30.257]  - attr(*, "where")=List of 5
[16:59:30.257]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.257]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.257]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.257]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.257]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.257]  - attr(*, "already-done")= logi TRUE
[16:59:30.264] - copied ‘future.call.arguments’ to environment
[16:59:30.265] - copied ‘...future.FUN’ to environment
[16:59:30.265] - copied ‘...future.elements_ii’ to environment
[16:59:30.265] - copied ‘...future.seeds_ii’ to environment
[16:59:30.265] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.265] assign_globals() ... done
[16:59:30.265] requestCore(): workers = 2
[16:59:30.267] MulticoreFuture started
[16:59:30.268] - Launch lazy future ... done
[16:59:30.268] run() for ‘MulticoreFuture’ ... done
[16:59:30.268] Created future:
[16:59:30.269] plan(): Setting new future strategy stack:
[16:59:30.269] List of future strategies:
[16:59:30.269] 1. sequential:
[16:59:30.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.269]    - tweaked: FALSE
[16:59:30.269]    - call: NULL
[16:59:30.270] plan(): nbrOfWorkers() = 1
[16:59:30.272] plan(): Setting new future strategy stack:
[16:59:30.272] List of future strategies:
[16:59:30.272] 1. multicore:
[16:59:30.272]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.272]    - tweaked: FALSE
[16:59:30.272]    - call: plan(strategy)
[16:59:30.278] plan(): nbrOfWorkers() = 2
[16:59:30.269] MulticoreFuture:
[16:59:30.269] Label: ‘future_apply-1’
[16:59:30.269] Expression:
[16:59:30.269] {
[16:59:30.269]     do.call(function(...) {
[16:59:30.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.269]             on.exit(options(oopts), add = TRUE)
[16:59:30.269]         }
[16:59:30.269]         {
[16:59:30.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.269]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.269]             })
[16:59:30.269]         }
[16:59:30.269]     }, args = future.call.arguments)
[16:59:30.269] }
[16:59:30.269] Lazy evaluation: FALSE
[16:59:30.269] Asynchronous evaluation: TRUE
[16:59:30.269] Local evaluation: TRUE
[16:59:30.269] Environment: R_GlobalEnv
[16:59:30.269] Capture standard output: TRUE
[16:59:30.269] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.269] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.269] Packages: <none>
[16:59:30.269] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.269] Resolved: TRUE
[16:59:30.269] Value: <not collected>
[16:59:30.269] Conditions captured: <none>
[16:59:30.269] Early signaling: FALSE
[16:59:30.269] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.269] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.279] Chunk #1 of 2 ... DONE
[16:59:30.279] Chunk #2 of 2 ...
[16:59:30.280]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.280]  - seeds: <none>
[16:59:30.280]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.280] getGlobalsAndPackages() ...
[16:59:30.280] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.280] Resolving globals: FALSE
[16:59:30.281] Tweak future expression to call with '...' arguments ...
[16:59:30.281] {
[16:59:30.281]     do.call(function(...) {
[16:59:30.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.281]             on.exit(options(oopts), add = TRUE)
[16:59:30.281]         }
[16:59:30.281]         {
[16:59:30.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.281]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.281]             })
[16:59:30.281]         }
[16:59:30.281]     }, args = future.call.arguments)
[16:59:30.281] }
[16:59:30.281] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.282] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.282] 
[16:59:30.282] getGlobalsAndPackages() ... DONE
[16:59:30.283] run() for ‘Future’ ...
[16:59:30.283] - state: ‘created’
[16:59:30.283] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.288]   - Field: ‘label’
[16:59:30.288]   - Field: ‘local’
[16:59:30.288]   - Field: ‘owner’
[16:59:30.288]   - Field: ‘envir’
[16:59:30.289]   - Field: ‘workers’
[16:59:30.289]   - Field: ‘packages’
[16:59:30.289]   - Field: ‘gc’
[16:59:30.289]   - Field: ‘job’
[16:59:30.289]   - Field: ‘conditions’
[16:59:30.289]   - Field: ‘expr’
[16:59:30.289]   - Field: ‘uuid’
[16:59:30.290]   - Field: ‘seed’
[16:59:30.290]   - Field: ‘version’
[16:59:30.290]   - Field: ‘result’
[16:59:30.290]   - Field: ‘asynchronous’
[16:59:30.290]   - Field: ‘calls’
[16:59:30.290]   - Field: ‘globals’
[16:59:30.290]   - Field: ‘stdout’
[16:59:30.291]   - Field: ‘earlySignal’
[16:59:30.291]   - Field: ‘lazy’
[16:59:30.291]   - Field: ‘state’
[16:59:30.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.291] - Launch lazy future ...
[16:59:30.292] Packages needed by the future expression (n = 0): <none>
[16:59:30.292] Packages needed by future strategies (n = 0): <none>
[16:59:30.293] {
[16:59:30.293]     {
[16:59:30.293]         {
[16:59:30.293]             ...future.startTime <- base::Sys.time()
[16:59:30.293]             {
[16:59:30.293]                 {
[16:59:30.293]                   {
[16:59:30.293]                     {
[16:59:30.293]                       base::local({
[16:59:30.293]                         has_future <- base::requireNamespace("future", 
[16:59:30.293]                           quietly = TRUE)
[16:59:30.293]                         if (has_future) {
[16:59:30.293]                           ns <- base::getNamespace("future")
[16:59:30.293]                           version <- ns[[".package"]][["version"]]
[16:59:30.293]                           if (is.null(version)) 
[16:59:30.293]                             version <- utils::packageVersion("future")
[16:59:30.293]                         }
[16:59:30.293]                         else {
[16:59:30.293]                           version <- NULL
[16:59:30.293]                         }
[16:59:30.293]                         if (!has_future || version < "1.8.0") {
[16:59:30.293]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.293]                             "", base::R.version$version.string), 
[16:59:30.293]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.293]                               "release", "version")], collapse = " "), 
[16:59:30.293]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.293]                             info)
[16:59:30.293]                           info <- base::paste(info, collapse = "; ")
[16:59:30.293]                           if (!has_future) {
[16:59:30.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.293]                               info)
[16:59:30.293]                           }
[16:59:30.293]                           else {
[16:59:30.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.293]                               info, version)
[16:59:30.293]                           }
[16:59:30.293]                           base::stop(msg)
[16:59:30.293]                         }
[16:59:30.293]                       })
[16:59:30.293]                     }
[16:59:30.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.293]                     base::options(mc.cores = 1L)
[16:59:30.293]                   }
[16:59:30.293]                   ...future.strategy.old <- future::plan("list")
[16:59:30.293]                   options(future.plan = NULL)
[16:59:30.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.293]                 }
[16:59:30.293]                 ...future.workdir <- getwd()
[16:59:30.293]             }
[16:59:30.293]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.293]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.293]         }
[16:59:30.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.293]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.293]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.293]             base::names(...future.oldOptions))
[16:59:30.293]     }
[16:59:30.293]     if (FALSE) {
[16:59:30.293]     }
[16:59:30.293]     else {
[16:59:30.293]         if (TRUE) {
[16:59:30.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.293]                 open = "w")
[16:59:30.293]         }
[16:59:30.293]         else {
[16:59:30.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.293]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.293]         }
[16:59:30.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.293]             base::sink(type = "output", split = FALSE)
[16:59:30.293]             base::close(...future.stdout)
[16:59:30.293]         }, add = TRUE)
[16:59:30.293]     }
[16:59:30.293]     ...future.frame <- base::sys.nframe()
[16:59:30.293]     ...future.conditions <- base::list()
[16:59:30.293]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.293]     if (FALSE) {
[16:59:30.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.293]     }
[16:59:30.293]     ...future.result <- base::tryCatch({
[16:59:30.293]         base::withCallingHandlers({
[16:59:30.293]             ...future.value <- base::withVisible(base::local({
[16:59:30.293]                 withCallingHandlers({
[16:59:30.293]                   {
[16:59:30.293]                     do.call(function(...) {
[16:59:30.293]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.293]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.293]                         ...future.globals.maxSize)) {
[16:59:30.293]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.293]                         on.exit(options(oopts), add = TRUE)
[16:59:30.293]                       }
[16:59:30.293]                       {
[16:59:30.293]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.293]                           FUN = function(jj) {
[16:59:30.293]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.293]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.293]                           })
[16:59:30.293]                       }
[16:59:30.293]                     }, args = future.call.arguments)
[16:59:30.293]                   }
[16:59:30.293]                 }, immediateCondition = function(cond) {
[16:59:30.293]                   save_rds <- function (object, pathname, ...) 
[16:59:30.293]                   {
[16:59:30.293]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.293]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.293]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.293]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.293]                         fi_tmp[["mtime"]])
[16:59:30.293]                     }
[16:59:30.293]                     tryCatch({
[16:59:30.293]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.293]                     }, error = function(ex) {
[16:59:30.293]                       msg <- conditionMessage(ex)
[16:59:30.293]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.293]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.293]                         fi_tmp[["mtime"]], msg)
[16:59:30.293]                       ex$message <- msg
[16:59:30.293]                       stop(ex)
[16:59:30.293]                     })
[16:59:30.293]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.293]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.293]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.293]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.293]                       fi <- file.info(pathname)
[16:59:30.293]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.293]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.293]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.293]                         fi[["size"]], fi[["mtime"]])
[16:59:30.293]                       stop(msg)
[16:59:30.293]                     }
[16:59:30.293]                     invisible(pathname)
[16:59:30.293]                   }
[16:59:30.293]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.293]                     rootPath = tempdir()) 
[16:59:30.293]                   {
[16:59:30.293]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.293]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.293]                       tmpdir = path, fileext = ".rds")
[16:59:30.293]                     save_rds(obj, file)
[16:59:30.293]                   }
[16:59:30.293]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.293]                   {
[16:59:30.293]                     inherits <- base::inherits
[16:59:30.293]                     invokeRestart <- base::invokeRestart
[16:59:30.293]                     is.null <- base::is.null
[16:59:30.293]                     muffled <- FALSE
[16:59:30.293]                     if (inherits(cond, "message")) {
[16:59:30.293]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.293]                       if (muffled) 
[16:59:30.293]                         invokeRestart("muffleMessage")
[16:59:30.293]                     }
[16:59:30.293]                     else if (inherits(cond, "warning")) {
[16:59:30.293]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.293]                       if (muffled) 
[16:59:30.293]                         invokeRestart("muffleWarning")
[16:59:30.293]                     }
[16:59:30.293]                     else if (inherits(cond, "condition")) {
[16:59:30.293]                       if (!is.null(pattern)) {
[16:59:30.293]                         computeRestarts <- base::computeRestarts
[16:59:30.293]                         grepl <- base::grepl
[16:59:30.293]                         restarts <- computeRestarts(cond)
[16:59:30.293]                         for (restart in restarts) {
[16:59:30.293]                           name <- restart$name
[16:59:30.293]                           if (is.null(name)) 
[16:59:30.293]                             next
[16:59:30.293]                           if (!grepl(pattern, name)) 
[16:59:30.293]                             next
[16:59:30.293]                           invokeRestart(restart)
[16:59:30.293]                           muffled <- TRUE
[16:59:30.293]                           break
[16:59:30.293]                         }
[16:59:30.293]                       }
[16:59:30.293]                     }
[16:59:30.293]                     invisible(muffled)
[16:59:30.293]                   }
[16:59:30.293]                   muffleCondition(cond)
[16:59:30.293]                 })
[16:59:30.293]             }))
[16:59:30.293]             future::FutureResult(value = ...future.value$value, 
[16:59:30.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.293]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.293]                     ...future.globalenv.names))
[16:59:30.293]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.293]         }, condition = base::local({
[16:59:30.293]             c <- base::c
[16:59:30.293]             inherits <- base::inherits
[16:59:30.293]             invokeRestart <- base::invokeRestart
[16:59:30.293]             length <- base::length
[16:59:30.293]             list <- base::list
[16:59:30.293]             seq.int <- base::seq.int
[16:59:30.293]             signalCondition <- base::signalCondition
[16:59:30.293]             sys.calls <- base::sys.calls
[16:59:30.293]             `[[` <- base::`[[`
[16:59:30.293]             `+` <- base::`+`
[16:59:30.293]             `<<-` <- base::`<<-`
[16:59:30.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.293]                   3L)]
[16:59:30.293]             }
[16:59:30.293]             function(cond) {
[16:59:30.293]                 is_error <- inherits(cond, "error")
[16:59:30.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.293]                   NULL)
[16:59:30.293]                 if (is_error) {
[16:59:30.293]                   sessionInformation <- function() {
[16:59:30.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.293]                       search = base::search(), system = base::Sys.info())
[16:59:30.293]                   }
[16:59:30.293]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.293]                     cond$call), session = sessionInformation(), 
[16:59:30.293]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.293]                   signalCondition(cond)
[16:59:30.293]                 }
[16:59:30.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.293]                 "immediateCondition"))) {
[16:59:30.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.293]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.293]                   if (TRUE && !signal) {
[16:59:30.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.293]                     {
[16:59:30.293]                       inherits <- base::inherits
[16:59:30.293]                       invokeRestart <- base::invokeRestart
[16:59:30.293]                       is.null <- base::is.null
[16:59:30.293]                       muffled <- FALSE
[16:59:30.293]                       if (inherits(cond, "message")) {
[16:59:30.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.293]                         if (muffled) 
[16:59:30.293]                           invokeRestart("muffleMessage")
[16:59:30.293]                       }
[16:59:30.293]                       else if (inherits(cond, "warning")) {
[16:59:30.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.293]                         if (muffled) 
[16:59:30.293]                           invokeRestart("muffleWarning")
[16:59:30.293]                       }
[16:59:30.293]                       else if (inherits(cond, "condition")) {
[16:59:30.293]                         if (!is.null(pattern)) {
[16:59:30.293]                           computeRestarts <- base::computeRestarts
[16:59:30.293]                           grepl <- base::grepl
[16:59:30.293]                           restarts <- computeRestarts(cond)
[16:59:30.293]                           for (restart in restarts) {
[16:59:30.293]                             name <- restart$name
[16:59:30.293]                             if (is.null(name)) 
[16:59:30.293]                               next
[16:59:30.293]                             if (!grepl(pattern, name)) 
[16:59:30.293]                               next
[16:59:30.293]                             invokeRestart(restart)
[16:59:30.293]                             muffled <- TRUE
[16:59:30.293]                             break
[16:59:30.293]                           }
[16:59:30.293]                         }
[16:59:30.293]                       }
[16:59:30.293]                       invisible(muffled)
[16:59:30.293]                     }
[16:59:30.293]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.293]                   }
[16:59:30.293]                 }
[16:59:30.293]                 else {
[16:59:30.293]                   if (TRUE) {
[16:59:30.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.293]                     {
[16:59:30.293]                       inherits <- base::inherits
[16:59:30.293]                       invokeRestart <- base::invokeRestart
[16:59:30.293]                       is.null <- base::is.null
[16:59:30.293]                       muffled <- FALSE
[16:59:30.293]                       if (inherits(cond, "message")) {
[16:59:30.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.293]                         if (muffled) 
[16:59:30.293]                           invokeRestart("muffleMessage")
[16:59:30.293]                       }
[16:59:30.293]                       else if (inherits(cond, "warning")) {
[16:59:30.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.293]                         if (muffled) 
[16:59:30.293]                           invokeRestart("muffleWarning")
[16:59:30.293]                       }
[16:59:30.293]                       else if (inherits(cond, "condition")) {
[16:59:30.293]                         if (!is.null(pattern)) {
[16:59:30.293]                           computeRestarts <- base::computeRestarts
[16:59:30.293]                           grepl <- base::grepl
[16:59:30.293]                           restarts <- computeRestarts(cond)
[16:59:30.293]                           for (restart in restarts) {
[16:59:30.293]                             name <- restart$name
[16:59:30.293]                             if (is.null(name)) 
[16:59:30.293]                               next
[16:59:30.293]                             if (!grepl(pattern, name)) 
[16:59:30.293]                               next
[16:59:30.293]                             invokeRestart(restart)
[16:59:30.293]                             muffled <- TRUE
[16:59:30.293]                             break
[16:59:30.293]                           }
[16:59:30.293]                         }
[16:59:30.293]                       }
[16:59:30.293]                       invisible(muffled)
[16:59:30.293]                     }
[16:59:30.293]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.293]                   }
[16:59:30.293]                 }
[16:59:30.293]             }
[16:59:30.293]         }))
[16:59:30.293]     }, error = function(ex) {
[16:59:30.293]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.293]                 ...future.rng), started = ...future.startTime, 
[16:59:30.293]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.293]             version = "1.8"), class = "FutureResult")
[16:59:30.293]     }, finally = {
[16:59:30.293]         if (!identical(...future.workdir, getwd())) 
[16:59:30.293]             setwd(...future.workdir)
[16:59:30.293]         {
[16:59:30.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.293]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.293]             }
[16:59:30.293]             base::options(...future.oldOptions)
[16:59:30.293]             if (.Platform$OS.type == "windows") {
[16:59:30.293]                 old_names <- names(...future.oldEnvVars)
[16:59:30.293]                 envs <- base::Sys.getenv()
[16:59:30.293]                 names <- names(envs)
[16:59:30.293]                 common <- intersect(names, old_names)
[16:59:30.293]                 added <- setdiff(names, old_names)
[16:59:30.293]                 removed <- setdiff(old_names, names)
[16:59:30.293]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.293]                   envs[common]]
[16:59:30.293]                 NAMES <- toupper(changed)
[16:59:30.293]                 args <- list()
[16:59:30.293]                 for (kk in seq_along(NAMES)) {
[16:59:30.293]                   name <- changed[[kk]]
[16:59:30.293]                   NAME <- NAMES[[kk]]
[16:59:30.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.293]                     next
[16:59:30.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.293]                 }
[16:59:30.293]                 NAMES <- toupper(added)
[16:59:30.293]                 for (kk in seq_along(NAMES)) {
[16:59:30.293]                   name <- added[[kk]]
[16:59:30.293]                   NAME <- NAMES[[kk]]
[16:59:30.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.293]                     next
[16:59:30.293]                   args[[name]] <- ""
[16:59:30.293]                 }
[16:59:30.293]                 NAMES <- toupper(removed)
[16:59:30.293]                 for (kk in seq_along(NAMES)) {
[16:59:30.293]                   name <- removed[[kk]]
[16:59:30.293]                   NAME <- NAMES[[kk]]
[16:59:30.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.293]                     next
[16:59:30.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.293]                 }
[16:59:30.293]                 if (length(args) > 0) 
[16:59:30.293]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.293]             }
[16:59:30.293]             else {
[16:59:30.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.293]             }
[16:59:30.293]             {
[16:59:30.293]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.293]                   0L) {
[16:59:30.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.293]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.293]                   base::options(opts)
[16:59:30.293]                 }
[16:59:30.293]                 {
[16:59:30.293]                   {
[16:59:30.293]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.293]                     NULL
[16:59:30.293]                   }
[16:59:30.293]                   options(future.plan = NULL)
[16:59:30.293]                   if (is.na(NA_character_)) 
[16:59:30.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.293]                     .init = FALSE)
[16:59:30.293]                 }
[16:59:30.293]             }
[16:59:30.293]         }
[16:59:30.293]     })
[16:59:30.293]     if (TRUE) {
[16:59:30.293]         base::sink(type = "output", split = FALSE)
[16:59:30.293]         if (TRUE) {
[16:59:30.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.293]         }
[16:59:30.293]         else {
[16:59:30.293]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.293]         }
[16:59:30.293]         base::close(...future.stdout)
[16:59:30.293]         ...future.stdout <- NULL
[16:59:30.293]     }
[16:59:30.293]     ...future.result$conditions <- ...future.conditions
[16:59:30.293]     ...future.result$finished <- base::Sys.time()
[16:59:30.293]     ...future.result
[16:59:30.293] }
[16:59:30.296] assign_globals() ...
[16:59:30.297] List of 5
[16:59:30.297]  $ future.call.arguments    : list()
[16:59:30.297]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.297]  $ ...future.FUN            :function (x)  
[16:59:30.297]  $ ...future.elements_ii    :List of 3
[16:59:30.297]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:30.297]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[16:59:30.297]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[16:59:30.297]  $ ...future.seeds_ii       : NULL
[16:59:30.297]  $ ...future.globals.maxSize: num Inf
[16:59:30.297]  - attr(*, "resolved")= logi FALSE
[16:59:30.297]  - attr(*, "total_size")= num NA
[16:59:30.297]  - attr(*, "where")=List of 5
[16:59:30.297]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.297]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.297]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.297]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.297]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.297]  - attr(*, "already-done")= logi TRUE
[16:59:30.305] - copied ‘future.call.arguments’ to environment
[16:59:30.305] - copied ‘...future.FUN’ to environment
[16:59:30.305] - copied ‘...future.elements_ii’ to environment
[16:59:30.305] - copied ‘...future.seeds_ii’ to environment
[16:59:30.306] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.306] assign_globals() ... done
[16:59:30.306] requestCore(): workers = 2
[16:59:30.308] MulticoreFuture started
[16:59:30.309] - Launch lazy future ... done
[16:59:30.309] run() for ‘MulticoreFuture’ ... done
[16:59:30.309] Created future:
[16:59:30.309] plan(): Setting new future strategy stack:
[16:59:30.310] List of future strategies:
[16:59:30.310] 1. sequential:
[16:59:30.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.310]    - tweaked: FALSE
[16:59:30.310]    - call: NULL
[16:59:30.311] plan(): nbrOfWorkers() = 1
[16:59:30.313] plan(): Setting new future strategy stack:
[16:59:30.313] List of future strategies:
[16:59:30.313] 1. multicore:
[16:59:30.313]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.313]    - tweaked: FALSE
[16:59:30.313]    - call: plan(strategy)
[16:59:30.309] MulticoreFuture:
[16:59:30.309] Label: ‘future_apply-2’
[16:59:30.309] Expression:
[16:59:30.309] {
[16:59:30.309]     do.call(function(...) {
[16:59:30.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.309]             on.exit(options(oopts), add = TRUE)
[16:59:30.309]         }
[16:59:30.309]         {
[16:59:30.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.309]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.309]             })
[16:59:30.309]         }
[16:59:30.309]     }, args = future.call.arguments)
[16:59:30.309] }
[16:59:30.309] Lazy evaluation: FALSE
[16:59:30.309] Asynchronous evaluation: TRUE
[16:59:30.309] Local evaluation: TRUE
[16:59:30.309] Environment: R_GlobalEnv
[16:59:30.309] Capture standard output: TRUE
[16:59:30.309] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.309] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.309] Packages: <none>
[16:59:30.309] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.309] Resolved: FALSE
[16:59:30.309] Value: <not collected>
[16:59:30.309] Conditions captured: <none>
[16:59:30.309] Early signaling: FALSE
[16:59:30.309] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.309] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.322] Chunk #2 of 2 ... DONE
[16:59:30.323] Launching 2 futures (chunks) ... DONE
[16:59:30.323] Resolving 2 futures (chunks) ...
[16:59:30.323] resolve() on list ...
[16:59:30.323]  recursive: 0
[16:59:30.323]  length: 2
[16:59:30.324] 
[16:59:30.323] plan(): nbrOfWorkers() = 2
[16:59:30.324] Future #1
[16:59:30.324] result() for MulticoreFuture ...
[16:59:30.328] result() for MulticoreFuture ...
[16:59:30.328] result() for MulticoreFuture ... done
[16:59:30.328] result() for MulticoreFuture ... done
[16:59:30.329] result() for MulticoreFuture ...
[16:59:30.329] result() for MulticoreFuture ... done
[16:59:30.330] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.330] - nx: 2
[16:59:30.330] - relay: TRUE
[16:59:30.330] - stdout: TRUE
[16:59:30.331] - signal: TRUE
[16:59:30.331] - resignal: FALSE
[16:59:30.331] - force: TRUE
[16:59:30.331] - relayed: [n=2] FALSE, FALSE
[16:59:30.332] - queued futures: [n=2] FALSE, FALSE
[16:59:30.332]  - until=1
[16:59:30.332]  - relaying element #1
[16:59:30.333] result() for MulticoreFuture ...
[16:59:30.333] result() for MulticoreFuture ... done
[16:59:30.333] result() for MulticoreFuture ...
[16:59:30.333] result() for MulticoreFuture ... done
[16:59:30.334] result() for MulticoreFuture ...
[16:59:30.334] result() for MulticoreFuture ... done
[16:59:30.334] result() for MulticoreFuture ...
[16:59:30.334] result() for MulticoreFuture ... done
[16:59:30.334] - relayed: [n=2] TRUE, FALSE
[16:59:30.335] - queued futures: [n=2] TRUE, FALSE
[16:59:30.335] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.335]  length: 1 (resolved future 1)
[16:59:30.335] Future #2
[16:59:30.335] result() for MulticoreFuture ...
[16:59:30.336] result() for MulticoreFuture ...
[16:59:30.336] result() for MulticoreFuture ... done
[16:59:30.336] result() for MulticoreFuture ... done
[16:59:30.337] result() for MulticoreFuture ...
[16:59:30.337] result() for MulticoreFuture ... done
[16:59:30.337] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.337] - nx: 2
[16:59:30.337] - relay: TRUE
[16:59:30.337] - stdout: TRUE
[16:59:30.338] - signal: TRUE
[16:59:30.338] - resignal: FALSE
[16:59:30.338] - force: TRUE
[16:59:30.338] - relayed: [n=2] TRUE, FALSE
[16:59:30.338] - queued futures: [n=2] TRUE, FALSE
[16:59:30.338]  - until=2
[16:59:30.338]  - relaying element #2
[16:59:30.338] result() for MulticoreFuture ...
[16:59:30.339] result() for MulticoreFuture ... done
[16:59:30.339] result() for MulticoreFuture ...
[16:59:30.339] result() for MulticoreFuture ... done
[16:59:30.339] result() for MulticoreFuture ...
[16:59:30.339] result() for MulticoreFuture ... done
[16:59:30.339] result() for MulticoreFuture ...
[16:59:30.339] result() for MulticoreFuture ... done
[16:59:30.339] - relayed: [n=2] TRUE, TRUE
[16:59:30.339] - queued futures: [n=2] TRUE, TRUE
[16:59:30.340] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.340]  length: 0 (resolved future 2)
[16:59:30.340] Relaying remaining futures
[16:59:30.340] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.340] - nx: 2
[16:59:30.340] - relay: TRUE
[16:59:30.340] - stdout: TRUE
[16:59:30.340] - signal: TRUE
[16:59:30.340] - resignal: FALSE
[16:59:30.340] - force: TRUE
[16:59:30.341] - relayed: [n=2] TRUE, TRUE
[16:59:30.341] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.341] - relayed: [n=2] TRUE, TRUE
[16:59:30.341] - queued futures: [n=2] TRUE, TRUE
[16:59:30.341] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.341] resolve() on list ... DONE
[16:59:30.341] result() for MulticoreFuture ...
[16:59:30.341] result() for MulticoreFuture ... done
[16:59:30.341] result() for MulticoreFuture ...
[16:59:30.341] result() for MulticoreFuture ... done
[16:59:30.342] result() for MulticoreFuture ...
[16:59:30.342] result() for MulticoreFuture ... done
[16:59:30.342] result() for MulticoreFuture ...
[16:59:30.342] result() for MulticoreFuture ... done
[16:59:30.342]  - Number of value chunks collected: 2
[16:59:30.342] Resolving 2 futures (chunks) ... DONE
[16:59:30.342] Reducing values from 2 chunks ...
[16:59:30.342]  - Number of values collected after concatenation: 6
[16:59:30.342]  - Number of values expected: 6
[16:59:30.343] Reducing values from 2 chunks ... DONE
[16:59:30.343] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:59:30.343] getGlobalsAndPackagesXApply() ...
[16:59:30.343]  - future.globals: TRUE
[16:59:30.344] getGlobalsAndPackages() ...
[16:59:30.344] Searching for globals...
[16:59:30.345] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:59:30.345] Searching for globals ... DONE
[16:59:30.345] Resolving globals: FALSE
[16:59:30.346] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:59:30.346] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:59:30.346] - globals: [1] ‘FUN’
[16:59:30.347] 
[16:59:30.347] getGlobalsAndPackages() ... DONE
[16:59:30.347]  - globals found/used: [n=1] ‘FUN’
[16:59:30.347]  - needed namespaces: [n=0] 
[16:59:30.347] Finding globals ... DONE
[16:59:30.347]  - use_args: TRUE
[16:59:30.347]  - Getting '...' globals ...
[16:59:30.348] resolve() on list ...
[16:59:30.348]  recursive: 0
[16:59:30.348]  length: 1
[16:59:30.348]  elements: ‘...’
[16:59:30.348]  length: 0 (resolved future 1)
[16:59:30.348] resolve() on list ... DONE
[16:59:30.348]    - '...' content: [n=0] 
[16:59:30.348] List of 1
[16:59:30.348]  $ ...: list()
[16:59:30.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.348]  - attr(*, "where")=List of 1
[16:59:30.348]   ..$ ...:<environment: 0x55f312dfe978> 
[16:59:30.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.348]  - attr(*, "resolved")= logi TRUE
[16:59:30.348]  - attr(*, "total_size")= num NA
[16:59:30.351]  - Getting '...' globals ... DONE
[16:59:30.352] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.352] List of 2
[16:59:30.352]  $ ...future.FUN:function (x)  
[16:59:30.352]  $ ...          : list()
[16:59:30.352]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.352]  - attr(*, "where")=List of 2
[16:59:30.352]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.352]   ..$ ...          :<environment: 0x55f312dfe978> 
[16:59:30.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.352]  - attr(*, "resolved")= logi FALSE
[16:59:30.352]  - attr(*, "total_size")= num 1768
[16:59:30.354] Packages to be attached in all futures: [n=0] 
[16:59:30.355] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.359] future_lapply() ...
[16:59:30.365] Number of chunks: 2
[16:59:30.365] getGlobalsAndPackagesXApply() ...
[16:59:30.366]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.366]  - use_args: TRUE
[16:59:30.366] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.366] List of 2
[16:59:30.366]  $ ...          : list()
[16:59:30.366]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.366]  $ ...future.FUN:function (x)  
[16:59:30.366]  - attr(*, "where")=List of 2
[16:59:30.366]   ..$ ...          :<environment: 0x55f312dfe978> 
[16:59:30.366]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:59:30.366]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.366]  - attr(*, "resolved")= logi FALSE
[16:59:30.366]  - attr(*, "total_size")= num NA
[16:59:30.369] Packages to be attached in all futures: [n=0] 
[16:59:30.369] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.370] Number of futures (= number of chunks): 2
[16:59:30.370] Launching 2 futures (chunks) ...
[16:59:30.370] Chunk #1 of 2 ...
[16:59:30.370]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.370]  - seeds: <none>
[16:59:30.370]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.370] getGlobalsAndPackages() ...
[16:59:30.371] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.371] Resolving globals: FALSE
[16:59:30.371] Tweak future expression to call with '...' arguments ...
[16:59:30.371] {
[16:59:30.371]     do.call(function(...) {
[16:59:30.371]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.371]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.371]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.371]             on.exit(options(oopts), add = TRUE)
[16:59:30.371]         }
[16:59:30.371]         {
[16:59:30.371]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.371]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.371]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.371]             })
[16:59:30.371]         }
[16:59:30.371]     }, args = future.call.arguments)
[16:59:30.371] }
[16:59:30.371] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.372] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.372] 
[16:59:30.372] getGlobalsAndPackages() ... DONE
[16:59:30.372] run() for ‘Future’ ...
[16:59:30.372] - state: ‘created’
[16:59:30.372] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.376] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.376] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.376]   - Field: ‘label’
[16:59:30.376]   - Field: ‘local’
[16:59:30.377]   - Field: ‘owner’
[16:59:30.377]   - Field: ‘envir’
[16:59:30.377]   - Field: ‘workers’
[16:59:30.377]   - Field: ‘packages’
[16:59:30.377]   - Field: ‘gc’
[16:59:30.377]   - Field: ‘job’
[16:59:30.377]   - Field: ‘conditions’
[16:59:30.377]   - Field: ‘expr’
[16:59:30.377]   - Field: ‘uuid’
[16:59:30.377]   - Field: ‘seed’
[16:59:30.378]   - Field: ‘version’
[16:59:30.378]   - Field: ‘result’
[16:59:30.378]   - Field: ‘asynchronous’
[16:59:30.378]   - Field: ‘calls’
[16:59:30.378]   - Field: ‘globals’
[16:59:30.378]   - Field: ‘stdout’
[16:59:30.378]   - Field: ‘earlySignal’
[16:59:30.378]   - Field: ‘lazy’
[16:59:30.378]   - Field: ‘state’
[16:59:30.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.378] - Launch lazy future ...
[16:59:30.379] Packages needed by the future expression (n = 0): <none>
[16:59:30.379] Packages needed by future strategies (n = 0): <none>
[16:59:30.379] {
[16:59:30.379]     {
[16:59:30.379]         {
[16:59:30.379]             ...future.startTime <- base::Sys.time()
[16:59:30.379]             {
[16:59:30.379]                 {
[16:59:30.379]                   {
[16:59:30.379]                     {
[16:59:30.379]                       base::local({
[16:59:30.379]                         has_future <- base::requireNamespace("future", 
[16:59:30.379]                           quietly = TRUE)
[16:59:30.379]                         if (has_future) {
[16:59:30.379]                           ns <- base::getNamespace("future")
[16:59:30.379]                           version <- ns[[".package"]][["version"]]
[16:59:30.379]                           if (is.null(version)) 
[16:59:30.379]                             version <- utils::packageVersion("future")
[16:59:30.379]                         }
[16:59:30.379]                         else {
[16:59:30.379]                           version <- NULL
[16:59:30.379]                         }
[16:59:30.379]                         if (!has_future || version < "1.8.0") {
[16:59:30.379]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.379]                             "", base::R.version$version.string), 
[16:59:30.379]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.379]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.379]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.379]                               "release", "version")], collapse = " "), 
[16:59:30.379]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.379]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.379]                             info)
[16:59:30.379]                           info <- base::paste(info, collapse = "; ")
[16:59:30.379]                           if (!has_future) {
[16:59:30.379]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.379]                               info)
[16:59:30.379]                           }
[16:59:30.379]                           else {
[16:59:30.379]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.379]                               info, version)
[16:59:30.379]                           }
[16:59:30.379]                           base::stop(msg)
[16:59:30.379]                         }
[16:59:30.379]                       })
[16:59:30.379]                     }
[16:59:30.379]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.379]                     base::options(mc.cores = 1L)
[16:59:30.379]                   }
[16:59:30.379]                   ...future.strategy.old <- future::plan("list")
[16:59:30.379]                   options(future.plan = NULL)
[16:59:30.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.379]                 }
[16:59:30.379]                 ...future.workdir <- getwd()
[16:59:30.379]             }
[16:59:30.379]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.379]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.379]         }
[16:59:30.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.379]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.379]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.379]             base::names(...future.oldOptions))
[16:59:30.379]     }
[16:59:30.379]     if (FALSE) {
[16:59:30.379]     }
[16:59:30.379]     else {
[16:59:30.379]         if (TRUE) {
[16:59:30.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.379]                 open = "w")
[16:59:30.379]         }
[16:59:30.379]         else {
[16:59:30.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.379]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.379]         }
[16:59:30.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.379]             base::sink(type = "output", split = FALSE)
[16:59:30.379]             base::close(...future.stdout)
[16:59:30.379]         }, add = TRUE)
[16:59:30.379]     }
[16:59:30.379]     ...future.frame <- base::sys.nframe()
[16:59:30.379]     ...future.conditions <- base::list()
[16:59:30.379]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.379]     if (FALSE) {
[16:59:30.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.379]     }
[16:59:30.379]     ...future.result <- base::tryCatch({
[16:59:30.379]         base::withCallingHandlers({
[16:59:30.379]             ...future.value <- base::withVisible(base::local({
[16:59:30.379]                 withCallingHandlers({
[16:59:30.379]                   {
[16:59:30.379]                     do.call(function(...) {
[16:59:30.379]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.379]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.379]                         ...future.globals.maxSize)) {
[16:59:30.379]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.379]                         on.exit(options(oopts), add = TRUE)
[16:59:30.379]                       }
[16:59:30.379]                       {
[16:59:30.379]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.379]                           FUN = function(jj) {
[16:59:30.379]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.379]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.379]                           })
[16:59:30.379]                       }
[16:59:30.379]                     }, args = future.call.arguments)
[16:59:30.379]                   }
[16:59:30.379]                 }, immediateCondition = function(cond) {
[16:59:30.379]                   save_rds <- function (object, pathname, ...) 
[16:59:30.379]                   {
[16:59:30.379]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.379]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.379]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.379]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.379]                         fi_tmp[["mtime"]])
[16:59:30.379]                     }
[16:59:30.379]                     tryCatch({
[16:59:30.379]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.379]                     }, error = function(ex) {
[16:59:30.379]                       msg <- conditionMessage(ex)
[16:59:30.379]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.379]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.379]                         fi_tmp[["mtime"]], msg)
[16:59:30.379]                       ex$message <- msg
[16:59:30.379]                       stop(ex)
[16:59:30.379]                     })
[16:59:30.379]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.379]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.379]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.379]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.379]                       fi <- file.info(pathname)
[16:59:30.379]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.379]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.379]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.379]                         fi[["size"]], fi[["mtime"]])
[16:59:30.379]                       stop(msg)
[16:59:30.379]                     }
[16:59:30.379]                     invisible(pathname)
[16:59:30.379]                   }
[16:59:30.379]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.379]                     rootPath = tempdir()) 
[16:59:30.379]                   {
[16:59:30.379]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.379]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.379]                       tmpdir = path, fileext = ".rds")
[16:59:30.379]                     save_rds(obj, file)
[16:59:30.379]                   }
[16:59:30.379]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.379]                   {
[16:59:30.379]                     inherits <- base::inherits
[16:59:30.379]                     invokeRestart <- base::invokeRestart
[16:59:30.379]                     is.null <- base::is.null
[16:59:30.379]                     muffled <- FALSE
[16:59:30.379]                     if (inherits(cond, "message")) {
[16:59:30.379]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.379]                       if (muffled) 
[16:59:30.379]                         invokeRestart("muffleMessage")
[16:59:30.379]                     }
[16:59:30.379]                     else if (inherits(cond, "warning")) {
[16:59:30.379]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.379]                       if (muffled) 
[16:59:30.379]                         invokeRestart("muffleWarning")
[16:59:30.379]                     }
[16:59:30.379]                     else if (inherits(cond, "condition")) {
[16:59:30.379]                       if (!is.null(pattern)) {
[16:59:30.379]                         computeRestarts <- base::computeRestarts
[16:59:30.379]                         grepl <- base::grepl
[16:59:30.379]                         restarts <- computeRestarts(cond)
[16:59:30.379]                         for (restart in restarts) {
[16:59:30.379]                           name <- restart$name
[16:59:30.379]                           if (is.null(name)) 
[16:59:30.379]                             next
[16:59:30.379]                           if (!grepl(pattern, name)) 
[16:59:30.379]                             next
[16:59:30.379]                           invokeRestart(restart)
[16:59:30.379]                           muffled <- TRUE
[16:59:30.379]                           break
[16:59:30.379]                         }
[16:59:30.379]                       }
[16:59:30.379]                     }
[16:59:30.379]                     invisible(muffled)
[16:59:30.379]                   }
[16:59:30.379]                   muffleCondition(cond)
[16:59:30.379]                 })
[16:59:30.379]             }))
[16:59:30.379]             future::FutureResult(value = ...future.value$value, 
[16:59:30.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.379]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.379]                     ...future.globalenv.names))
[16:59:30.379]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.379]         }, condition = base::local({
[16:59:30.379]             c <- base::c
[16:59:30.379]             inherits <- base::inherits
[16:59:30.379]             invokeRestart <- base::invokeRestart
[16:59:30.379]             length <- base::length
[16:59:30.379]             list <- base::list
[16:59:30.379]             seq.int <- base::seq.int
[16:59:30.379]             signalCondition <- base::signalCondition
[16:59:30.379]             sys.calls <- base::sys.calls
[16:59:30.379]             `[[` <- base::`[[`
[16:59:30.379]             `+` <- base::`+`
[16:59:30.379]             `<<-` <- base::`<<-`
[16:59:30.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.379]                   3L)]
[16:59:30.379]             }
[16:59:30.379]             function(cond) {
[16:59:30.379]                 is_error <- inherits(cond, "error")
[16:59:30.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.379]                   NULL)
[16:59:30.379]                 if (is_error) {
[16:59:30.379]                   sessionInformation <- function() {
[16:59:30.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.379]                       search = base::search(), system = base::Sys.info())
[16:59:30.379]                   }
[16:59:30.379]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.379]                     cond$call), session = sessionInformation(), 
[16:59:30.379]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.379]                   signalCondition(cond)
[16:59:30.379]                 }
[16:59:30.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.379]                 "immediateCondition"))) {
[16:59:30.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.379]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.379]                   if (TRUE && !signal) {
[16:59:30.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.379]                     {
[16:59:30.379]                       inherits <- base::inherits
[16:59:30.379]                       invokeRestart <- base::invokeRestart
[16:59:30.379]                       is.null <- base::is.null
[16:59:30.379]                       muffled <- FALSE
[16:59:30.379]                       if (inherits(cond, "message")) {
[16:59:30.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.379]                         if (muffled) 
[16:59:30.379]                           invokeRestart("muffleMessage")
[16:59:30.379]                       }
[16:59:30.379]                       else if (inherits(cond, "warning")) {
[16:59:30.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.379]                         if (muffled) 
[16:59:30.379]                           invokeRestart("muffleWarning")
[16:59:30.379]                       }
[16:59:30.379]                       else if (inherits(cond, "condition")) {
[16:59:30.379]                         if (!is.null(pattern)) {
[16:59:30.379]                           computeRestarts <- base::computeRestarts
[16:59:30.379]                           grepl <- base::grepl
[16:59:30.379]                           restarts <- computeRestarts(cond)
[16:59:30.379]                           for (restart in restarts) {
[16:59:30.379]                             name <- restart$name
[16:59:30.379]                             if (is.null(name)) 
[16:59:30.379]                               next
[16:59:30.379]                             if (!grepl(pattern, name)) 
[16:59:30.379]                               next
[16:59:30.379]                             invokeRestart(restart)
[16:59:30.379]                             muffled <- TRUE
[16:59:30.379]                             break
[16:59:30.379]                           }
[16:59:30.379]                         }
[16:59:30.379]                       }
[16:59:30.379]                       invisible(muffled)
[16:59:30.379]                     }
[16:59:30.379]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.379]                   }
[16:59:30.379]                 }
[16:59:30.379]                 else {
[16:59:30.379]                   if (TRUE) {
[16:59:30.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.379]                     {
[16:59:30.379]                       inherits <- base::inherits
[16:59:30.379]                       invokeRestart <- base::invokeRestart
[16:59:30.379]                       is.null <- base::is.null
[16:59:30.379]                       muffled <- FALSE
[16:59:30.379]                       if (inherits(cond, "message")) {
[16:59:30.379]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.379]                         if (muffled) 
[16:59:30.379]                           invokeRestart("muffleMessage")
[16:59:30.379]                       }
[16:59:30.379]                       else if (inherits(cond, "warning")) {
[16:59:30.379]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.379]                         if (muffled) 
[16:59:30.379]                           invokeRestart("muffleWarning")
[16:59:30.379]                       }
[16:59:30.379]                       else if (inherits(cond, "condition")) {
[16:59:30.379]                         if (!is.null(pattern)) {
[16:59:30.379]                           computeRestarts <- base::computeRestarts
[16:59:30.379]                           grepl <- base::grepl
[16:59:30.379]                           restarts <- computeRestarts(cond)
[16:59:30.379]                           for (restart in restarts) {
[16:59:30.379]                             name <- restart$name
[16:59:30.379]                             if (is.null(name)) 
[16:59:30.379]                               next
[16:59:30.379]                             if (!grepl(pattern, name)) 
[16:59:30.379]                               next
[16:59:30.379]                             invokeRestart(restart)
[16:59:30.379]                             muffled <- TRUE
[16:59:30.379]                             break
[16:59:30.379]                           }
[16:59:30.379]                         }
[16:59:30.379]                       }
[16:59:30.379]                       invisible(muffled)
[16:59:30.379]                     }
[16:59:30.379]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.379]                   }
[16:59:30.379]                 }
[16:59:30.379]             }
[16:59:30.379]         }))
[16:59:30.379]     }, error = function(ex) {
[16:59:30.379]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.379]                 ...future.rng), started = ...future.startTime, 
[16:59:30.379]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.379]             version = "1.8"), class = "FutureResult")
[16:59:30.379]     }, finally = {
[16:59:30.379]         if (!identical(...future.workdir, getwd())) 
[16:59:30.379]             setwd(...future.workdir)
[16:59:30.379]         {
[16:59:30.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.379]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.379]             }
[16:59:30.379]             base::options(...future.oldOptions)
[16:59:30.379]             if (.Platform$OS.type == "windows") {
[16:59:30.379]                 old_names <- names(...future.oldEnvVars)
[16:59:30.379]                 envs <- base::Sys.getenv()
[16:59:30.379]                 names <- names(envs)
[16:59:30.379]                 common <- intersect(names, old_names)
[16:59:30.379]                 added <- setdiff(names, old_names)
[16:59:30.379]                 removed <- setdiff(old_names, names)
[16:59:30.379]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.379]                   envs[common]]
[16:59:30.379]                 NAMES <- toupper(changed)
[16:59:30.379]                 args <- list()
[16:59:30.379]                 for (kk in seq_along(NAMES)) {
[16:59:30.379]                   name <- changed[[kk]]
[16:59:30.379]                   NAME <- NAMES[[kk]]
[16:59:30.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.379]                     next
[16:59:30.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.379]                 }
[16:59:30.379]                 NAMES <- toupper(added)
[16:59:30.379]                 for (kk in seq_along(NAMES)) {
[16:59:30.379]                   name <- added[[kk]]
[16:59:30.379]                   NAME <- NAMES[[kk]]
[16:59:30.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.379]                     next
[16:59:30.379]                   args[[name]] <- ""
[16:59:30.379]                 }
[16:59:30.379]                 NAMES <- toupper(removed)
[16:59:30.379]                 for (kk in seq_along(NAMES)) {
[16:59:30.379]                   name <- removed[[kk]]
[16:59:30.379]                   NAME <- NAMES[[kk]]
[16:59:30.379]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.379]                     next
[16:59:30.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.379]                 }
[16:59:30.379]                 if (length(args) > 0) 
[16:59:30.379]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.379]             }
[16:59:30.379]             else {
[16:59:30.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.379]             }
[16:59:30.379]             {
[16:59:30.379]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.379]                   0L) {
[16:59:30.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.379]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.379]                   base::options(opts)
[16:59:30.379]                 }
[16:59:30.379]                 {
[16:59:30.379]                   {
[16:59:30.379]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.379]                     NULL
[16:59:30.379]                   }
[16:59:30.379]                   options(future.plan = NULL)
[16:59:30.379]                   if (is.na(NA_character_)) 
[16:59:30.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.379]                     .init = FALSE)
[16:59:30.379]                 }
[16:59:30.379]             }
[16:59:30.379]         }
[16:59:30.379]     })
[16:59:30.379]     if (TRUE) {
[16:59:30.379]         base::sink(type = "output", split = FALSE)
[16:59:30.379]         if (TRUE) {
[16:59:30.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.379]         }
[16:59:30.379]         else {
[16:59:30.379]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.379]         }
[16:59:30.379]         base::close(...future.stdout)
[16:59:30.379]         ...future.stdout <- NULL
[16:59:30.379]     }
[16:59:30.379]     ...future.result$conditions <- ...future.conditions
[16:59:30.379]     ...future.result$finished <- base::Sys.time()
[16:59:30.379]     ...future.result
[16:59:30.379] }
[16:59:30.382] assign_globals() ...
[16:59:30.382] List of 5
[16:59:30.382]  $ future.call.arguments    : list()
[16:59:30.382]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.382]  $ ...future.FUN            :function (x)  
[16:59:30.382]  $ ...future.elements_ii    :List of 3
[16:59:30.382]   ..$ : int [1:4] 1 7 13 19
[16:59:30.382]   ..$ : int [1:4] 2 8 14 20
[16:59:30.382]   ..$ : int [1:4] 3 9 15 21
[16:59:30.382]  $ ...future.seeds_ii       : NULL
[16:59:30.382]  $ ...future.globals.maxSize: num Inf
[16:59:30.382]  - attr(*, "resolved")= logi FALSE
[16:59:30.382]  - attr(*, "total_size")= num NA
[16:59:30.382]  - attr(*, "where")=List of 5
[16:59:30.382]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.382]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.382]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.382]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.382]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.382]  - attr(*, "already-done")= logi TRUE
[16:59:30.387] - copied ‘future.call.arguments’ to environment
[16:59:30.387] - reassign environment for ‘...future.FUN’
[16:59:30.388] - copied ‘...future.FUN’ to environment
[16:59:30.388] - copied ‘...future.elements_ii’ to environment
[16:59:30.388] - copied ‘...future.seeds_ii’ to environment
[16:59:30.388] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.388] assign_globals() ... done
[16:59:30.388] requestCore(): workers = 2
[16:59:30.390] MulticoreFuture started
[16:59:30.391] - Launch lazy future ... done
[16:59:30.391] run() for ‘MulticoreFuture’ ... done
[16:59:30.391] Created future:
[16:59:30.391] plan(): Setting new future strategy stack:
[16:59:30.392] List of future strategies:
[16:59:30.392] 1. sequential:
[16:59:30.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.392]    - tweaked: FALSE
[16:59:30.392]    - call: NULL
[16:59:30.393] plan(): nbrOfWorkers() = 1
[16:59:30.395] plan(): Setting new future strategy stack:
[16:59:30.395] List of future strategies:
[16:59:30.395] 1. multicore:
[16:59:30.395]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.395]    - tweaked: FALSE
[16:59:30.395]    - call: plan(strategy)
[16:59:30.400] plan(): nbrOfWorkers() = 2
[16:59:30.392] MulticoreFuture:
[16:59:30.392] Label: ‘future_apply-1’
[16:59:30.392] Expression:
[16:59:30.392] {
[16:59:30.392]     do.call(function(...) {
[16:59:30.392]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.392]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.392]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.392]             on.exit(options(oopts), add = TRUE)
[16:59:30.392]         }
[16:59:30.392]         {
[16:59:30.392]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.392]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.392]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.392]             })
[16:59:30.392]         }
[16:59:30.392]     }, args = future.call.arguments)
[16:59:30.392] }
[16:59:30.392] Lazy evaluation: FALSE
[16:59:30.392] Asynchronous evaluation: TRUE
[16:59:30.392] Local evaluation: TRUE
[16:59:30.392] Environment: R_GlobalEnv
[16:59:30.392] Capture standard output: TRUE
[16:59:30.392] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.392] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.392] Packages: <none>
[16:59:30.392] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.392] Resolved: TRUE
[16:59:30.392] Value: <not collected>
[16:59:30.392] Conditions captured: <none>
[16:59:30.392] Early signaling: FALSE
[16:59:30.392] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.392] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.401] Chunk #1 of 2 ... DONE
[16:59:30.401] Chunk #2 of 2 ...
[16:59:30.402]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.402]  - seeds: <none>
[16:59:30.402]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.402] getGlobalsAndPackages() ...
[16:59:30.402] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.402] Resolving globals: FALSE
[16:59:30.403] Tweak future expression to call with '...' arguments ...
[16:59:30.403] {
[16:59:30.403]     do.call(function(...) {
[16:59:30.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.403]             on.exit(options(oopts), add = TRUE)
[16:59:30.403]         }
[16:59:30.403]         {
[16:59:30.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.403]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.403]             })
[16:59:30.403]         }
[16:59:30.403]     }, args = future.call.arguments)
[16:59:30.403] }
[16:59:30.403] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.404] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.404] 
[16:59:30.407] getGlobalsAndPackages() ... DONE
[16:59:30.409] run() for ‘Future’ ...
[16:59:30.409] - state: ‘created’
[16:59:30.410] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.416] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.417] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.417]   - Field: ‘label’
[16:59:30.417]   - Field: ‘local’
[16:59:30.418]   - Field: ‘owner’
[16:59:30.418]   - Field: ‘envir’
[16:59:30.418]   - Field: ‘workers’
[16:59:30.418]   - Field: ‘packages’
[16:59:30.418]   - Field: ‘gc’
[16:59:30.419]   - Field: ‘job’
[16:59:30.419]   - Field: ‘conditions’
[16:59:30.419]   - Field: ‘expr’
[16:59:30.419]   - Field: ‘uuid’
[16:59:30.419]   - Field: ‘seed’
[16:59:30.419]   - Field: ‘version’
[16:59:30.420]   - Field: ‘result’
[16:59:30.420]   - Field: ‘asynchronous’
[16:59:30.420]   - Field: ‘calls’
[16:59:30.420]   - Field: ‘globals’
[16:59:30.420]   - Field: ‘stdout’
[16:59:30.420]   - Field: ‘earlySignal’
[16:59:30.420]   - Field: ‘lazy’
[16:59:30.421]   - Field: ‘state’
[16:59:30.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.421] - Launch lazy future ...
[16:59:30.422] Packages needed by the future expression (n = 0): <none>
[16:59:30.422] Packages needed by future strategies (n = 0): <none>
[16:59:30.423] {
[16:59:30.423]     {
[16:59:30.423]         {
[16:59:30.423]             ...future.startTime <- base::Sys.time()
[16:59:30.423]             {
[16:59:30.423]                 {
[16:59:30.423]                   {
[16:59:30.423]                     {
[16:59:30.423]                       base::local({
[16:59:30.423]                         has_future <- base::requireNamespace("future", 
[16:59:30.423]                           quietly = TRUE)
[16:59:30.423]                         if (has_future) {
[16:59:30.423]                           ns <- base::getNamespace("future")
[16:59:30.423]                           version <- ns[[".package"]][["version"]]
[16:59:30.423]                           if (is.null(version)) 
[16:59:30.423]                             version <- utils::packageVersion("future")
[16:59:30.423]                         }
[16:59:30.423]                         else {
[16:59:30.423]                           version <- NULL
[16:59:30.423]                         }
[16:59:30.423]                         if (!has_future || version < "1.8.0") {
[16:59:30.423]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.423]                             "", base::R.version$version.string), 
[16:59:30.423]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.423]                               "release", "version")], collapse = " "), 
[16:59:30.423]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.423]                             info)
[16:59:30.423]                           info <- base::paste(info, collapse = "; ")
[16:59:30.423]                           if (!has_future) {
[16:59:30.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.423]                               info)
[16:59:30.423]                           }
[16:59:30.423]                           else {
[16:59:30.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.423]                               info, version)
[16:59:30.423]                           }
[16:59:30.423]                           base::stop(msg)
[16:59:30.423]                         }
[16:59:30.423]                       })
[16:59:30.423]                     }
[16:59:30.423]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.423]                     base::options(mc.cores = 1L)
[16:59:30.423]                   }
[16:59:30.423]                   ...future.strategy.old <- future::plan("list")
[16:59:30.423]                   options(future.plan = NULL)
[16:59:30.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.423]                 }
[16:59:30.423]                 ...future.workdir <- getwd()
[16:59:30.423]             }
[16:59:30.423]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.423]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.423]         }
[16:59:30.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.423]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.423]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.423]             base::names(...future.oldOptions))
[16:59:30.423]     }
[16:59:30.423]     if (FALSE) {
[16:59:30.423]     }
[16:59:30.423]     else {
[16:59:30.423]         if (TRUE) {
[16:59:30.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.423]                 open = "w")
[16:59:30.423]         }
[16:59:30.423]         else {
[16:59:30.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.423]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.423]         }
[16:59:30.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.423]             base::sink(type = "output", split = FALSE)
[16:59:30.423]             base::close(...future.stdout)
[16:59:30.423]         }, add = TRUE)
[16:59:30.423]     }
[16:59:30.423]     ...future.frame <- base::sys.nframe()
[16:59:30.423]     ...future.conditions <- base::list()
[16:59:30.423]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.423]     if (FALSE) {
[16:59:30.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.423]     }
[16:59:30.423]     ...future.result <- base::tryCatch({
[16:59:30.423]         base::withCallingHandlers({
[16:59:30.423]             ...future.value <- base::withVisible(base::local({
[16:59:30.423]                 withCallingHandlers({
[16:59:30.423]                   {
[16:59:30.423]                     do.call(function(...) {
[16:59:30.423]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.423]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.423]                         ...future.globals.maxSize)) {
[16:59:30.423]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.423]                         on.exit(options(oopts), add = TRUE)
[16:59:30.423]                       }
[16:59:30.423]                       {
[16:59:30.423]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.423]                           FUN = function(jj) {
[16:59:30.423]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.423]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.423]                           })
[16:59:30.423]                       }
[16:59:30.423]                     }, args = future.call.arguments)
[16:59:30.423]                   }
[16:59:30.423]                 }, immediateCondition = function(cond) {
[16:59:30.423]                   save_rds <- function (object, pathname, ...) 
[16:59:30.423]                   {
[16:59:30.423]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.423]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.423]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.423]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.423]                         fi_tmp[["mtime"]])
[16:59:30.423]                     }
[16:59:30.423]                     tryCatch({
[16:59:30.423]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.423]                     }, error = function(ex) {
[16:59:30.423]                       msg <- conditionMessage(ex)
[16:59:30.423]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.423]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.423]                         fi_tmp[["mtime"]], msg)
[16:59:30.423]                       ex$message <- msg
[16:59:30.423]                       stop(ex)
[16:59:30.423]                     })
[16:59:30.423]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.423]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.423]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.423]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.423]                       fi <- file.info(pathname)
[16:59:30.423]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.423]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.423]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.423]                         fi[["size"]], fi[["mtime"]])
[16:59:30.423]                       stop(msg)
[16:59:30.423]                     }
[16:59:30.423]                     invisible(pathname)
[16:59:30.423]                   }
[16:59:30.423]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.423]                     rootPath = tempdir()) 
[16:59:30.423]                   {
[16:59:30.423]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.423]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.423]                       tmpdir = path, fileext = ".rds")
[16:59:30.423]                     save_rds(obj, file)
[16:59:30.423]                   }
[16:59:30.423]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.423]                   {
[16:59:30.423]                     inherits <- base::inherits
[16:59:30.423]                     invokeRestart <- base::invokeRestart
[16:59:30.423]                     is.null <- base::is.null
[16:59:30.423]                     muffled <- FALSE
[16:59:30.423]                     if (inherits(cond, "message")) {
[16:59:30.423]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.423]                       if (muffled) 
[16:59:30.423]                         invokeRestart("muffleMessage")
[16:59:30.423]                     }
[16:59:30.423]                     else if (inherits(cond, "warning")) {
[16:59:30.423]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.423]                       if (muffled) 
[16:59:30.423]                         invokeRestart("muffleWarning")
[16:59:30.423]                     }
[16:59:30.423]                     else if (inherits(cond, "condition")) {
[16:59:30.423]                       if (!is.null(pattern)) {
[16:59:30.423]                         computeRestarts <- base::computeRestarts
[16:59:30.423]                         grepl <- base::grepl
[16:59:30.423]                         restarts <- computeRestarts(cond)
[16:59:30.423]                         for (restart in restarts) {
[16:59:30.423]                           name <- restart$name
[16:59:30.423]                           if (is.null(name)) 
[16:59:30.423]                             next
[16:59:30.423]                           if (!grepl(pattern, name)) 
[16:59:30.423]                             next
[16:59:30.423]                           invokeRestart(restart)
[16:59:30.423]                           muffled <- TRUE
[16:59:30.423]                           break
[16:59:30.423]                         }
[16:59:30.423]                       }
[16:59:30.423]                     }
[16:59:30.423]                     invisible(muffled)
[16:59:30.423]                   }
[16:59:30.423]                   muffleCondition(cond)
[16:59:30.423]                 })
[16:59:30.423]             }))
[16:59:30.423]             future::FutureResult(value = ...future.value$value, 
[16:59:30.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.423]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.423]                     ...future.globalenv.names))
[16:59:30.423]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.423]         }, condition = base::local({
[16:59:30.423]             c <- base::c
[16:59:30.423]             inherits <- base::inherits
[16:59:30.423]             invokeRestart <- base::invokeRestart
[16:59:30.423]             length <- base::length
[16:59:30.423]             list <- base::list
[16:59:30.423]             seq.int <- base::seq.int
[16:59:30.423]             signalCondition <- base::signalCondition
[16:59:30.423]             sys.calls <- base::sys.calls
[16:59:30.423]             `[[` <- base::`[[`
[16:59:30.423]             `+` <- base::`+`
[16:59:30.423]             `<<-` <- base::`<<-`
[16:59:30.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.423]                   3L)]
[16:59:30.423]             }
[16:59:30.423]             function(cond) {
[16:59:30.423]                 is_error <- inherits(cond, "error")
[16:59:30.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.423]                   NULL)
[16:59:30.423]                 if (is_error) {
[16:59:30.423]                   sessionInformation <- function() {
[16:59:30.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.423]                       search = base::search(), system = base::Sys.info())
[16:59:30.423]                   }
[16:59:30.423]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.423]                     cond$call), session = sessionInformation(), 
[16:59:30.423]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.423]                   signalCondition(cond)
[16:59:30.423]                 }
[16:59:30.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.423]                 "immediateCondition"))) {
[16:59:30.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.423]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.423]                   if (TRUE && !signal) {
[16:59:30.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.423]                     {
[16:59:30.423]                       inherits <- base::inherits
[16:59:30.423]                       invokeRestart <- base::invokeRestart
[16:59:30.423]                       is.null <- base::is.null
[16:59:30.423]                       muffled <- FALSE
[16:59:30.423]                       if (inherits(cond, "message")) {
[16:59:30.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.423]                         if (muffled) 
[16:59:30.423]                           invokeRestart("muffleMessage")
[16:59:30.423]                       }
[16:59:30.423]                       else if (inherits(cond, "warning")) {
[16:59:30.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.423]                         if (muffled) 
[16:59:30.423]                           invokeRestart("muffleWarning")
[16:59:30.423]                       }
[16:59:30.423]                       else if (inherits(cond, "condition")) {
[16:59:30.423]                         if (!is.null(pattern)) {
[16:59:30.423]                           computeRestarts <- base::computeRestarts
[16:59:30.423]                           grepl <- base::grepl
[16:59:30.423]                           restarts <- computeRestarts(cond)
[16:59:30.423]                           for (restart in restarts) {
[16:59:30.423]                             name <- restart$name
[16:59:30.423]                             if (is.null(name)) 
[16:59:30.423]                               next
[16:59:30.423]                             if (!grepl(pattern, name)) 
[16:59:30.423]                               next
[16:59:30.423]                             invokeRestart(restart)
[16:59:30.423]                             muffled <- TRUE
[16:59:30.423]                             break
[16:59:30.423]                           }
[16:59:30.423]                         }
[16:59:30.423]                       }
[16:59:30.423]                       invisible(muffled)
[16:59:30.423]                     }
[16:59:30.423]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.423]                   }
[16:59:30.423]                 }
[16:59:30.423]                 else {
[16:59:30.423]                   if (TRUE) {
[16:59:30.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.423]                     {
[16:59:30.423]                       inherits <- base::inherits
[16:59:30.423]                       invokeRestart <- base::invokeRestart
[16:59:30.423]                       is.null <- base::is.null
[16:59:30.423]                       muffled <- FALSE
[16:59:30.423]                       if (inherits(cond, "message")) {
[16:59:30.423]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.423]                         if (muffled) 
[16:59:30.423]                           invokeRestart("muffleMessage")
[16:59:30.423]                       }
[16:59:30.423]                       else if (inherits(cond, "warning")) {
[16:59:30.423]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.423]                         if (muffled) 
[16:59:30.423]                           invokeRestart("muffleWarning")
[16:59:30.423]                       }
[16:59:30.423]                       else if (inherits(cond, "condition")) {
[16:59:30.423]                         if (!is.null(pattern)) {
[16:59:30.423]                           computeRestarts <- base::computeRestarts
[16:59:30.423]                           grepl <- base::grepl
[16:59:30.423]                           restarts <- computeRestarts(cond)
[16:59:30.423]                           for (restart in restarts) {
[16:59:30.423]                             name <- restart$name
[16:59:30.423]                             if (is.null(name)) 
[16:59:30.423]                               next
[16:59:30.423]                             if (!grepl(pattern, name)) 
[16:59:30.423]                               next
[16:59:30.423]                             invokeRestart(restart)
[16:59:30.423]                             muffled <- TRUE
[16:59:30.423]                             break
[16:59:30.423]                           }
[16:59:30.423]                         }
[16:59:30.423]                       }
[16:59:30.423]                       invisible(muffled)
[16:59:30.423]                     }
[16:59:30.423]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.423]                   }
[16:59:30.423]                 }
[16:59:30.423]             }
[16:59:30.423]         }))
[16:59:30.423]     }, error = function(ex) {
[16:59:30.423]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.423]                 ...future.rng), started = ...future.startTime, 
[16:59:30.423]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.423]             version = "1.8"), class = "FutureResult")
[16:59:30.423]     }, finally = {
[16:59:30.423]         if (!identical(...future.workdir, getwd())) 
[16:59:30.423]             setwd(...future.workdir)
[16:59:30.423]         {
[16:59:30.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.423]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.423]             }
[16:59:30.423]             base::options(...future.oldOptions)
[16:59:30.423]             if (.Platform$OS.type == "windows") {
[16:59:30.423]                 old_names <- names(...future.oldEnvVars)
[16:59:30.423]                 envs <- base::Sys.getenv()
[16:59:30.423]                 names <- names(envs)
[16:59:30.423]                 common <- intersect(names, old_names)
[16:59:30.423]                 added <- setdiff(names, old_names)
[16:59:30.423]                 removed <- setdiff(old_names, names)
[16:59:30.423]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.423]                   envs[common]]
[16:59:30.423]                 NAMES <- toupper(changed)
[16:59:30.423]                 args <- list()
[16:59:30.423]                 for (kk in seq_along(NAMES)) {
[16:59:30.423]                   name <- changed[[kk]]
[16:59:30.423]                   NAME <- NAMES[[kk]]
[16:59:30.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.423]                     next
[16:59:30.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.423]                 }
[16:59:30.423]                 NAMES <- toupper(added)
[16:59:30.423]                 for (kk in seq_along(NAMES)) {
[16:59:30.423]                   name <- added[[kk]]
[16:59:30.423]                   NAME <- NAMES[[kk]]
[16:59:30.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.423]                     next
[16:59:30.423]                   args[[name]] <- ""
[16:59:30.423]                 }
[16:59:30.423]                 NAMES <- toupper(removed)
[16:59:30.423]                 for (kk in seq_along(NAMES)) {
[16:59:30.423]                   name <- removed[[kk]]
[16:59:30.423]                   NAME <- NAMES[[kk]]
[16:59:30.423]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.423]                     next
[16:59:30.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.423]                 }
[16:59:30.423]                 if (length(args) > 0) 
[16:59:30.423]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.423]             }
[16:59:30.423]             else {
[16:59:30.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.423]             }
[16:59:30.423]             {
[16:59:30.423]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.423]                   0L) {
[16:59:30.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.423]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.423]                   base::options(opts)
[16:59:30.423]                 }
[16:59:30.423]                 {
[16:59:30.423]                   {
[16:59:30.423]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.423]                     NULL
[16:59:30.423]                   }
[16:59:30.423]                   options(future.plan = NULL)
[16:59:30.423]                   if (is.na(NA_character_)) 
[16:59:30.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.423]                     .init = FALSE)
[16:59:30.423]                 }
[16:59:30.423]             }
[16:59:30.423]         }
[16:59:30.423]     })
[16:59:30.423]     if (TRUE) {
[16:59:30.423]         base::sink(type = "output", split = FALSE)
[16:59:30.423]         if (TRUE) {
[16:59:30.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.423]         }
[16:59:30.423]         else {
[16:59:30.423]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.423]         }
[16:59:30.423]         base::close(...future.stdout)
[16:59:30.423]         ...future.stdout <- NULL
[16:59:30.423]     }
[16:59:30.423]     ...future.result$conditions <- ...future.conditions
[16:59:30.423]     ...future.result$finished <- base::Sys.time()
[16:59:30.423]     ...future.result
[16:59:30.423] }
[16:59:30.425] assign_globals() ...
[16:59:30.425] List of 5
[16:59:30.425]  $ future.call.arguments    : list()
[16:59:30.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.425]  $ ...future.FUN            :function (x)  
[16:59:30.425]  $ ...future.elements_ii    :List of 3
[16:59:30.425]   ..$ : int [1:4] 4 10 16 22
[16:59:30.425]   ..$ : int [1:4] 5 11 17 23
[16:59:30.425]   ..$ : int [1:4] 6 12 18 24
[16:59:30.425]  $ ...future.seeds_ii       : NULL
[16:59:30.425]  $ ...future.globals.maxSize: num Inf
[16:59:30.425]  - attr(*, "resolved")= logi FALSE
[16:59:30.425]  - attr(*, "total_size")= num NA
[16:59:30.425]  - attr(*, "where")=List of 5
[16:59:30.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.425]  - attr(*, "already-done")= logi TRUE
[16:59:30.433] - copied ‘future.call.arguments’ to environment
[16:59:30.433] - reassign environment for ‘...future.FUN’
[16:59:30.433] - copied ‘...future.FUN’ to environment
[16:59:30.433] - copied ‘...future.elements_ii’ to environment
[16:59:30.433] - copied ‘...future.seeds_ii’ to environment
[16:59:30.433] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.433] assign_globals() ... done
[16:59:30.434] requestCore(): workers = 2
[16:59:30.436] MulticoreFuture started
[16:59:30.436] - Launch lazy future ... done
[16:59:30.437] run() for ‘MulticoreFuture’ ... done
[16:59:30.437] Created future:
[16:59:30.437] plan(): Setting new future strategy stack:
[16:59:30.437] List of future strategies:
[16:59:30.437] 1. sequential:
[16:59:30.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.437]    - tweaked: FALSE
[16:59:30.437]    - call: NULL
[16:59:30.438] plan(): nbrOfWorkers() = 1
[16:59:30.440] plan(): Setting new future strategy stack:
[16:59:30.441] List of future strategies:
[16:59:30.441] 1. multicore:
[16:59:30.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.441]    - tweaked: FALSE
[16:59:30.441]    - call: plan(strategy)
[16:59:30.446] plan(): nbrOfWorkers() = 2
[16:59:30.437] MulticoreFuture:
[16:59:30.437] Label: ‘future_apply-2’
[16:59:30.437] Expression:
[16:59:30.437] {
[16:59:30.437]     do.call(function(...) {
[16:59:30.437]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.437]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.437]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.437]             on.exit(options(oopts), add = TRUE)
[16:59:30.437]         }
[16:59:30.437]         {
[16:59:30.437]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.437]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.437]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.437]             })
[16:59:30.437]         }
[16:59:30.437]     }, args = future.call.arguments)
[16:59:30.437] }
[16:59:30.437] Lazy evaluation: FALSE
[16:59:30.437] Asynchronous evaluation: TRUE
[16:59:30.437] Local evaluation: TRUE
[16:59:30.437] Environment: R_GlobalEnv
[16:59:30.437] Capture standard output: TRUE
[16:59:30.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.437] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.437] Packages: <none>
[16:59:30.437] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.437] Resolved: TRUE
[16:59:30.437] Value: <not collected>
[16:59:30.437] Conditions captured: <none>
[16:59:30.437] Early signaling: FALSE
[16:59:30.437] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.437] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.447] Chunk #2 of 2 ... DONE
[16:59:30.447] Launching 2 futures (chunks) ... DONE
[16:59:30.448] Resolving 2 futures (chunks) ...
[16:59:30.448] resolve() on list ...
[16:59:30.448]  recursive: 0
[16:59:30.448]  length: 2
[16:59:30.448] 
[16:59:30.449] Future #1
[16:59:30.449] result() for MulticoreFuture ...
[16:59:30.450] result() for MulticoreFuture ...
[16:59:30.450] result() for MulticoreFuture ... done
[16:59:30.450] result() for MulticoreFuture ... done
[16:59:30.450] result() for MulticoreFuture ...
[16:59:30.450] result() for MulticoreFuture ... done
[16:59:30.451] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.451] - nx: 2
[16:59:30.451] - relay: TRUE
[16:59:30.451] - stdout: TRUE
[16:59:30.451] - signal: TRUE
[16:59:30.451] - resignal: FALSE
[16:59:30.451] - force: TRUE
[16:59:30.451] - relayed: [n=2] FALSE, FALSE
[16:59:30.452] - queued futures: [n=2] FALSE, FALSE
[16:59:30.452]  - until=1
[16:59:30.452]  - relaying element #1
[16:59:30.452] result() for MulticoreFuture ...
[16:59:30.452] result() for MulticoreFuture ... done
[16:59:30.452] result() for MulticoreFuture ...
[16:59:30.453] result() for MulticoreFuture ... done
[16:59:30.453] result() for MulticoreFuture ...
[16:59:30.453] result() for MulticoreFuture ... done
[16:59:30.453] result() for MulticoreFuture ...
[16:59:30.453] result() for MulticoreFuture ... done
[16:59:30.453] - relayed: [n=2] TRUE, FALSE
[16:59:30.453] - queued futures: [n=2] TRUE, FALSE
[16:59:30.454] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.454]  length: 1 (resolved future 1)
[16:59:30.454] Future #2
[16:59:30.454] result() for MulticoreFuture ...
[16:59:30.455] result() for MulticoreFuture ...
[16:59:30.455] result() for MulticoreFuture ... done
[16:59:30.455] result() for MulticoreFuture ... done
[16:59:30.455] result() for MulticoreFuture ...
[16:59:30.456] result() for MulticoreFuture ... done
[16:59:30.456] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.456] - nx: 2
[16:59:30.456] - relay: TRUE
[16:59:30.456] - stdout: TRUE
[16:59:30.456] - signal: TRUE
[16:59:30.456] - resignal: FALSE
[16:59:30.456] - force: TRUE
[16:59:30.457] - relayed: [n=2] TRUE, FALSE
[16:59:30.457] - queued futures: [n=2] TRUE, FALSE
[16:59:30.457]  - until=2
[16:59:30.457]  - relaying element #2
[16:59:30.457] result() for MulticoreFuture ...
[16:59:30.457] result() for MulticoreFuture ... done
[16:59:30.457] result() for MulticoreFuture ...
[16:59:30.457] result() for MulticoreFuture ... done
[16:59:30.458] result() for MulticoreFuture ...
[16:59:30.458] result() for MulticoreFuture ... done
[16:59:30.458] result() for MulticoreFuture ...
[16:59:30.458] result() for MulticoreFuture ... done
[16:59:30.458] - relayed: [n=2] TRUE, TRUE
[16:59:30.458] - queued futures: [n=2] TRUE, TRUE
[16:59:30.458] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.458]  length: 0 (resolved future 2)
[16:59:30.458] Relaying remaining futures
[16:59:30.459] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.459] - nx: 2
[16:59:30.459] - relay: TRUE
[16:59:30.459] - stdout: TRUE
[16:59:30.459] - signal: TRUE
[16:59:30.459] - resignal: FALSE
[16:59:30.461] - force: TRUE
[16:59:30.462] - relayed: [n=2] TRUE, TRUE
[16:59:30.462] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.462] - relayed: [n=2] TRUE, TRUE
[16:59:30.462] - queued futures: [n=2] TRUE, TRUE
[16:59:30.463] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.463] resolve() on list ... DONE
[16:59:30.463] result() for MulticoreFuture ...
[16:59:30.463] result() for MulticoreFuture ... done
[16:59:30.463] result() for MulticoreFuture ...
[16:59:30.463] result() for MulticoreFuture ... done
[16:59:30.464] result() for MulticoreFuture ...
[16:59:30.464] result() for MulticoreFuture ... done
[16:59:30.464] result() for MulticoreFuture ...
[16:59:30.464] result() for MulticoreFuture ... done
[16:59:30.464]  - Number of value chunks collected: 2
[16:59:30.465] Resolving 2 futures (chunks) ... DONE
[16:59:30.465] Reducing values from 2 chunks ...
[16:59:30.465]  - Number of values collected after concatenation: 6
[16:59:30.465]  - Number of values expected: 6
[16:59:30.465] Reducing values from 2 chunks ... DONE
[16:59:30.465] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:59:30.466] getGlobalsAndPackagesXApply() ...
[16:59:30.466]  - future.globals: TRUE
[16:59:30.466] getGlobalsAndPackages() ...
[16:59:30.466] Searching for globals...
[16:59:30.468] - globals found: [1] ‘FUN’
[16:59:30.468] Searching for globals ... DONE
[16:59:30.468] Resolving globals: FALSE
[16:59:30.468] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:30.469] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:30.469] - globals: [1] ‘FUN’
[16:59:30.469] 
[16:59:30.469] getGlobalsAndPackages() ... DONE
[16:59:30.469]  - globals found/used: [n=1] ‘FUN’
[16:59:30.469]  - needed namespaces: [n=0] 
[16:59:30.470] Finding globals ... DONE
[16:59:30.470]  - use_args: TRUE
[16:59:30.470]  - Getting '...' globals ...
[16:59:30.470] resolve() on list ...
[16:59:30.470]  recursive: 0
[16:59:30.470]  length: 1
[16:59:30.470]  elements: ‘...’
[16:59:30.471]  length: 0 (resolved future 1)
[16:59:30.471] resolve() on list ... DONE
[16:59:30.471]    - '...' content: [n=0] 
[16:59:30.471] List of 1
[16:59:30.471]  $ ...: list()
[16:59:30.471]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.471]  - attr(*, "where")=List of 1
[16:59:30.471]   ..$ ...:<environment: 0x55f31441e780> 
[16:59:30.471]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.471]  - attr(*, "resolved")= logi TRUE
[16:59:30.471]  - attr(*, "total_size")= num NA
[16:59:30.474]  - Getting '...' globals ... DONE
[16:59:30.474] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.474] List of 2
[16:59:30.474]  $ ...future.FUN:function (x)  
[16:59:30.474]  $ ...          : list()
[16:59:30.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.474]  - attr(*, "where")=List of 2
[16:59:30.474]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.474]   ..$ ...          :<environment: 0x55f31441e780> 
[16:59:30.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.474]  - attr(*, "resolved")= logi FALSE
[16:59:30.474]  - attr(*, "total_size")= num 848
[16:59:30.477] Packages to be attached in all futures: [n=0] 
[16:59:30.477] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.481] future_lapply() ...
[16:59:30.485] Number of chunks: 2
[16:59:30.485] getGlobalsAndPackagesXApply() ...
[16:59:30.485]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.486]  - use_args: TRUE
[16:59:30.486] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.486] List of 2
[16:59:30.486]  $ ...          : list()
[16:59:30.486]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.486]  $ ...future.FUN:function (x)  
[16:59:30.486]  - attr(*, "where")=List of 2
[16:59:30.486]   ..$ ...          :<environment: 0x55f31441e780> 
[16:59:30.486]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:30.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.486]  - attr(*, "resolved")= logi FALSE
[16:59:30.486]  - attr(*, "total_size")= num NA
[16:59:30.489] Packages to be attached in all futures: [n=0] 
[16:59:30.489] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.490] Number of futures (= number of chunks): 2
[16:59:30.490] Launching 2 futures (chunks) ...
[16:59:30.490] Chunk #1 of 2 ...
[16:59:30.490]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.490]  - seeds: <none>
[16:59:30.490]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.490] getGlobalsAndPackages() ...
[16:59:30.490] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.490] Resolving globals: FALSE
[16:59:30.491] Tweak future expression to call with '...' arguments ...
[16:59:30.491] {
[16:59:30.491]     do.call(function(...) {
[16:59:30.491]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.491]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.491]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.491]             on.exit(options(oopts), add = TRUE)
[16:59:30.491]         }
[16:59:30.491]         {
[16:59:30.491]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.491]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.491]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.491]             })
[16:59:30.491]         }
[16:59:30.491]     }, args = future.call.arguments)
[16:59:30.491] }
[16:59:30.491] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.491] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.492] 
[16:59:30.492] getGlobalsAndPackages() ... DONE
[16:59:30.492] run() for ‘Future’ ...
[16:59:30.492] - state: ‘created’
[16:59:30.492] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.498] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.498]   - Field: ‘label’
[16:59:30.498]   - Field: ‘local’
[16:59:30.498]   - Field: ‘owner’
[16:59:30.499]   - Field: ‘envir’
[16:59:30.499]   - Field: ‘workers’
[16:59:30.499]   - Field: ‘packages’
[16:59:30.499]   - Field: ‘gc’
[16:59:30.499]   - Field: ‘job’
[16:59:30.499]   - Field: ‘conditions’
[16:59:30.499]   - Field: ‘expr’
[16:59:30.499]   - Field: ‘uuid’
[16:59:30.500]   - Field: ‘seed’
[16:59:30.500]   - Field: ‘version’
[16:59:30.500]   - Field: ‘result’
[16:59:30.500]   - Field: ‘asynchronous’
[16:59:30.500]   - Field: ‘calls’
[16:59:30.500]   - Field: ‘globals’
[16:59:30.500]   - Field: ‘stdout’
[16:59:30.500]   - Field: ‘earlySignal’
[16:59:30.500]   - Field: ‘lazy’
[16:59:30.500]   - Field: ‘state’
[16:59:30.501] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.501] - Launch lazy future ...
[16:59:30.501] Packages needed by the future expression (n = 0): <none>
[16:59:30.501] Packages needed by future strategies (n = 0): <none>
[16:59:30.502] {
[16:59:30.502]     {
[16:59:30.502]         {
[16:59:30.502]             ...future.startTime <- base::Sys.time()
[16:59:30.502]             {
[16:59:30.502]                 {
[16:59:30.502]                   {
[16:59:30.502]                     {
[16:59:30.502]                       base::local({
[16:59:30.502]                         has_future <- base::requireNamespace("future", 
[16:59:30.502]                           quietly = TRUE)
[16:59:30.502]                         if (has_future) {
[16:59:30.502]                           ns <- base::getNamespace("future")
[16:59:30.502]                           version <- ns[[".package"]][["version"]]
[16:59:30.502]                           if (is.null(version)) 
[16:59:30.502]                             version <- utils::packageVersion("future")
[16:59:30.502]                         }
[16:59:30.502]                         else {
[16:59:30.502]                           version <- NULL
[16:59:30.502]                         }
[16:59:30.502]                         if (!has_future || version < "1.8.0") {
[16:59:30.502]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.502]                             "", base::R.version$version.string), 
[16:59:30.502]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.502]                               "release", "version")], collapse = " "), 
[16:59:30.502]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.502]                             info)
[16:59:30.502]                           info <- base::paste(info, collapse = "; ")
[16:59:30.502]                           if (!has_future) {
[16:59:30.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.502]                               info)
[16:59:30.502]                           }
[16:59:30.502]                           else {
[16:59:30.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.502]                               info, version)
[16:59:30.502]                           }
[16:59:30.502]                           base::stop(msg)
[16:59:30.502]                         }
[16:59:30.502]                       })
[16:59:30.502]                     }
[16:59:30.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.502]                     base::options(mc.cores = 1L)
[16:59:30.502]                   }
[16:59:30.502]                   ...future.strategy.old <- future::plan("list")
[16:59:30.502]                   options(future.plan = NULL)
[16:59:30.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.502]                 }
[16:59:30.502]                 ...future.workdir <- getwd()
[16:59:30.502]             }
[16:59:30.502]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.502]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.502]         }
[16:59:30.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.502]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.502]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.502]             base::names(...future.oldOptions))
[16:59:30.502]     }
[16:59:30.502]     if (FALSE) {
[16:59:30.502]     }
[16:59:30.502]     else {
[16:59:30.502]         if (TRUE) {
[16:59:30.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.502]                 open = "w")
[16:59:30.502]         }
[16:59:30.502]         else {
[16:59:30.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.502]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.502]         }
[16:59:30.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.502]             base::sink(type = "output", split = FALSE)
[16:59:30.502]             base::close(...future.stdout)
[16:59:30.502]         }, add = TRUE)
[16:59:30.502]     }
[16:59:30.502]     ...future.frame <- base::sys.nframe()
[16:59:30.502]     ...future.conditions <- base::list()
[16:59:30.502]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.502]     if (FALSE) {
[16:59:30.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.502]     }
[16:59:30.502]     ...future.result <- base::tryCatch({
[16:59:30.502]         base::withCallingHandlers({
[16:59:30.502]             ...future.value <- base::withVisible(base::local({
[16:59:30.502]                 withCallingHandlers({
[16:59:30.502]                   {
[16:59:30.502]                     do.call(function(...) {
[16:59:30.502]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.502]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.502]                         ...future.globals.maxSize)) {
[16:59:30.502]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.502]                         on.exit(options(oopts), add = TRUE)
[16:59:30.502]                       }
[16:59:30.502]                       {
[16:59:30.502]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.502]                           FUN = function(jj) {
[16:59:30.502]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.502]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.502]                           })
[16:59:30.502]                       }
[16:59:30.502]                     }, args = future.call.arguments)
[16:59:30.502]                   }
[16:59:30.502]                 }, immediateCondition = function(cond) {
[16:59:30.502]                   save_rds <- function (object, pathname, ...) 
[16:59:30.502]                   {
[16:59:30.502]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.502]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.502]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.502]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.502]                         fi_tmp[["mtime"]])
[16:59:30.502]                     }
[16:59:30.502]                     tryCatch({
[16:59:30.502]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.502]                     }, error = function(ex) {
[16:59:30.502]                       msg <- conditionMessage(ex)
[16:59:30.502]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.502]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.502]                         fi_tmp[["mtime"]], msg)
[16:59:30.502]                       ex$message <- msg
[16:59:30.502]                       stop(ex)
[16:59:30.502]                     })
[16:59:30.502]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.502]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.502]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.502]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.502]                       fi <- file.info(pathname)
[16:59:30.502]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.502]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.502]                         fi[["size"]], fi[["mtime"]])
[16:59:30.502]                       stop(msg)
[16:59:30.502]                     }
[16:59:30.502]                     invisible(pathname)
[16:59:30.502]                   }
[16:59:30.502]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.502]                     rootPath = tempdir()) 
[16:59:30.502]                   {
[16:59:30.502]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.502]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.502]                       tmpdir = path, fileext = ".rds")
[16:59:30.502]                     save_rds(obj, file)
[16:59:30.502]                   }
[16:59:30.502]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.502]                   {
[16:59:30.502]                     inherits <- base::inherits
[16:59:30.502]                     invokeRestart <- base::invokeRestart
[16:59:30.502]                     is.null <- base::is.null
[16:59:30.502]                     muffled <- FALSE
[16:59:30.502]                     if (inherits(cond, "message")) {
[16:59:30.502]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.502]                       if (muffled) 
[16:59:30.502]                         invokeRestart("muffleMessage")
[16:59:30.502]                     }
[16:59:30.502]                     else if (inherits(cond, "warning")) {
[16:59:30.502]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.502]                       if (muffled) 
[16:59:30.502]                         invokeRestart("muffleWarning")
[16:59:30.502]                     }
[16:59:30.502]                     else if (inherits(cond, "condition")) {
[16:59:30.502]                       if (!is.null(pattern)) {
[16:59:30.502]                         computeRestarts <- base::computeRestarts
[16:59:30.502]                         grepl <- base::grepl
[16:59:30.502]                         restarts <- computeRestarts(cond)
[16:59:30.502]                         for (restart in restarts) {
[16:59:30.502]                           name <- restart$name
[16:59:30.502]                           if (is.null(name)) 
[16:59:30.502]                             next
[16:59:30.502]                           if (!grepl(pattern, name)) 
[16:59:30.502]                             next
[16:59:30.502]                           invokeRestart(restart)
[16:59:30.502]                           muffled <- TRUE
[16:59:30.502]                           break
[16:59:30.502]                         }
[16:59:30.502]                       }
[16:59:30.502]                     }
[16:59:30.502]                     invisible(muffled)
[16:59:30.502]                   }
[16:59:30.502]                   muffleCondition(cond)
[16:59:30.502]                 })
[16:59:30.502]             }))
[16:59:30.502]             future::FutureResult(value = ...future.value$value, 
[16:59:30.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.502]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.502]                     ...future.globalenv.names))
[16:59:30.502]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.502]         }, condition = base::local({
[16:59:30.502]             c <- base::c
[16:59:30.502]             inherits <- base::inherits
[16:59:30.502]             invokeRestart <- base::invokeRestart
[16:59:30.502]             length <- base::length
[16:59:30.502]             list <- base::list
[16:59:30.502]             seq.int <- base::seq.int
[16:59:30.502]             signalCondition <- base::signalCondition
[16:59:30.502]             sys.calls <- base::sys.calls
[16:59:30.502]             `[[` <- base::`[[`
[16:59:30.502]             `+` <- base::`+`
[16:59:30.502]             `<<-` <- base::`<<-`
[16:59:30.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.502]                   3L)]
[16:59:30.502]             }
[16:59:30.502]             function(cond) {
[16:59:30.502]                 is_error <- inherits(cond, "error")
[16:59:30.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.502]                   NULL)
[16:59:30.502]                 if (is_error) {
[16:59:30.502]                   sessionInformation <- function() {
[16:59:30.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.502]                       search = base::search(), system = base::Sys.info())
[16:59:30.502]                   }
[16:59:30.502]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.502]                     cond$call), session = sessionInformation(), 
[16:59:30.502]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.502]                   signalCondition(cond)
[16:59:30.502]                 }
[16:59:30.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.502]                 "immediateCondition"))) {
[16:59:30.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.502]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.502]                   if (TRUE && !signal) {
[16:59:30.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.502]                     {
[16:59:30.502]                       inherits <- base::inherits
[16:59:30.502]                       invokeRestart <- base::invokeRestart
[16:59:30.502]                       is.null <- base::is.null
[16:59:30.502]                       muffled <- FALSE
[16:59:30.502]                       if (inherits(cond, "message")) {
[16:59:30.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.502]                         if (muffled) 
[16:59:30.502]                           invokeRestart("muffleMessage")
[16:59:30.502]                       }
[16:59:30.502]                       else if (inherits(cond, "warning")) {
[16:59:30.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.502]                         if (muffled) 
[16:59:30.502]                           invokeRestart("muffleWarning")
[16:59:30.502]                       }
[16:59:30.502]                       else if (inherits(cond, "condition")) {
[16:59:30.502]                         if (!is.null(pattern)) {
[16:59:30.502]                           computeRestarts <- base::computeRestarts
[16:59:30.502]                           grepl <- base::grepl
[16:59:30.502]                           restarts <- computeRestarts(cond)
[16:59:30.502]                           for (restart in restarts) {
[16:59:30.502]                             name <- restart$name
[16:59:30.502]                             if (is.null(name)) 
[16:59:30.502]                               next
[16:59:30.502]                             if (!grepl(pattern, name)) 
[16:59:30.502]                               next
[16:59:30.502]                             invokeRestart(restart)
[16:59:30.502]                             muffled <- TRUE
[16:59:30.502]                             break
[16:59:30.502]                           }
[16:59:30.502]                         }
[16:59:30.502]                       }
[16:59:30.502]                       invisible(muffled)
[16:59:30.502]                     }
[16:59:30.502]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.502]                   }
[16:59:30.502]                 }
[16:59:30.502]                 else {
[16:59:30.502]                   if (TRUE) {
[16:59:30.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.502]                     {
[16:59:30.502]                       inherits <- base::inherits
[16:59:30.502]                       invokeRestart <- base::invokeRestart
[16:59:30.502]                       is.null <- base::is.null
[16:59:30.502]                       muffled <- FALSE
[16:59:30.502]                       if (inherits(cond, "message")) {
[16:59:30.502]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.502]                         if (muffled) 
[16:59:30.502]                           invokeRestart("muffleMessage")
[16:59:30.502]                       }
[16:59:30.502]                       else if (inherits(cond, "warning")) {
[16:59:30.502]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.502]                         if (muffled) 
[16:59:30.502]                           invokeRestart("muffleWarning")
[16:59:30.502]                       }
[16:59:30.502]                       else if (inherits(cond, "condition")) {
[16:59:30.502]                         if (!is.null(pattern)) {
[16:59:30.502]                           computeRestarts <- base::computeRestarts
[16:59:30.502]                           grepl <- base::grepl
[16:59:30.502]                           restarts <- computeRestarts(cond)
[16:59:30.502]                           for (restart in restarts) {
[16:59:30.502]                             name <- restart$name
[16:59:30.502]                             if (is.null(name)) 
[16:59:30.502]                               next
[16:59:30.502]                             if (!grepl(pattern, name)) 
[16:59:30.502]                               next
[16:59:30.502]                             invokeRestart(restart)
[16:59:30.502]                             muffled <- TRUE
[16:59:30.502]                             break
[16:59:30.502]                           }
[16:59:30.502]                         }
[16:59:30.502]                       }
[16:59:30.502]                       invisible(muffled)
[16:59:30.502]                     }
[16:59:30.502]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.502]                   }
[16:59:30.502]                 }
[16:59:30.502]             }
[16:59:30.502]         }))
[16:59:30.502]     }, error = function(ex) {
[16:59:30.502]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.502]                 ...future.rng), started = ...future.startTime, 
[16:59:30.502]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.502]             version = "1.8"), class = "FutureResult")
[16:59:30.502]     }, finally = {
[16:59:30.502]         if (!identical(...future.workdir, getwd())) 
[16:59:30.502]             setwd(...future.workdir)
[16:59:30.502]         {
[16:59:30.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.502]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.502]             }
[16:59:30.502]             base::options(...future.oldOptions)
[16:59:30.502]             if (.Platform$OS.type == "windows") {
[16:59:30.502]                 old_names <- names(...future.oldEnvVars)
[16:59:30.502]                 envs <- base::Sys.getenv()
[16:59:30.502]                 names <- names(envs)
[16:59:30.502]                 common <- intersect(names, old_names)
[16:59:30.502]                 added <- setdiff(names, old_names)
[16:59:30.502]                 removed <- setdiff(old_names, names)
[16:59:30.502]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.502]                   envs[common]]
[16:59:30.502]                 NAMES <- toupper(changed)
[16:59:30.502]                 args <- list()
[16:59:30.502]                 for (kk in seq_along(NAMES)) {
[16:59:30.502]                   name <- changed[[kk]]
[16:59:30.502]                   NAME <- NAMES[[kk]]
[16:59:30.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.502]                     next
[16:59:30.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.502]                 }
[16:59:30.502]                 NAMES <- toupper(added)
[16:59:30.502]                 for (kk in seq_along(NAMES)) {
[16:59:30.502]                   name <- added[[kk]]
[16:59:30.502]                   NAME <- NAMES[[kk]]
[16:59:30.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.502]                     next
[16:59:30.502]                   args[[name]] <- ""
[16:59:30.502]                 }
[16:59:30.502]                 NAMES <- toupper(removed)
[16:59:30.502]                 for (kk in seq_along(NAMES)) {
[16:59:30.502]                   name <- removed[[kk]]
[16:59:30.502]                   NAME <- NAMES[[kk]]
[16:59:30.502]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.502]                     next
[16:59:30.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.502]                 }
[16:59:30.502]                 if (length(args) > 0) 
[16:59:30.502]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.502]             }
[16:59:30.502]             else {
[16:59:30.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.502]             }
[16:59:30.502]             {
[16:59:30.502]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.502]                   0L) {
[16:59:30.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.502]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.502]                   base::options(opts)
[16:59:30.502]                 }
[16:59:30.502]                 {
[16:59:30.502]                   {
[16:59:30.502]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.502]                     NULL
[16:59:30.502]                   }
[16:59:30.502]                   options(future.plan = NULL)
[16:59:30.502]                   if (is.na(NA_character_)) 
[16:59:30.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.502]                     .init = FALSE)
[16:59:30.502]                 }
[16:59:30.502]             }
[16:59:30.502]         }
[16:59:30.502]     })
[16:59:30.502]     if (TRUE) {
[16:59:30.502]         base::sink(type = "output", split = FALSE)
[16:59:30.502]         if (TRUE) {
[16:59:30.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.502]         }
[16:59:30.502]         else {
[16:59:30.502]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.502]         }
[16:59:30.502]         base::close(...future.stdout)
[16:59:30.502]         ...future.stdout <- NULL
[16:59:30.502]     }
[16:59:30.502]     ...future.result$conditions <- ...future.conditions
[16:59:30.502]     ...future.result$finished <- base::Sys.time()
[16:59:30.502]     ...future.result
[16:59:30.502] }
[16:59:30.504] assign_globals() ...
[16:59:30.504] List of 5
[16:59:30.504]  $ future.call.arguments    : list()
[16:59:30.504]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.504]  $ ...future.FUN            :function (x)  
[16:59:30.504]  $ ...future.elements_ii    :List of 1
[16:59:30.504]   ..$ : int 1
[16:59:30.504]  $ ...future.seeds_ii       : NULL
[16:59:30.504]  $ ...future.globals.maxSize: num Inf
[16:59:30.504]  - attr(*, "resolved")= logi FALSE
[16:59:30.504]  - attr(*, "total_size")= num NA
[16:59:30.504]  - attr(*, "where")=List of 5
[16:59:30.504]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.504]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.504]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.504]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.504]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.504]  - attr(*, "already-done")= logi TRUE
[16:59:30.509] - copied ‘future.call.arguments’ to environment
[16:59:30.509] - copied ‘...future.FUN’ to environment
[16:59:30.509] - copied ‘...future.elements_ii’ to environment
[16:59:30.509] - copied ‘...future.seeds_ii’ to environment
[16:59:30.509] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.510] assign_globals() ... done
[16:59:30.510] requestCore(): workers = 2
[16:59:30.512] MulticoreFuture started
[16:59:30.512] - Launch lazy future ... done
[16:59:30.513] run() for ‘MulticoreFuture’ ... done
[16:59:30.513] Created future:
[16:59:30.513] plan(): Setting new future strategy stack:
[16:59:30.513] List of future strategies:
[16:59:30.513] 1. sequential:
[16:59:30.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.513]    - tweaked: FALSE
[16:59:30.513]    - call: NULL
[16:59:30.514] plan(): nbrOfWorkers() = 1
[16:59:30.517] plan(): Setting new future strategy stack:
[16:59:30.517] List of future strategies:
[16:59:30.517] 1. multicore:
[16:59:30.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.517]    - tweaked: FALSE
[16:59:30.517]    - call: plan(strategy)
[16:59:30.522] plan(): nbrOfWorkers() = 2
[16:59:30.513] MulticoreFuture:
[16:59:30.513] Label: ‘future_apply-1’
[16:59:30.513] Expression:
[16:59:30.513] {
[16:59:30.513]     do.call(function(...) {
[16:59:30.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.513]             on.exit(options(oopts), add = TRUE)
[16:59:30.513]         }
[16:59:30.513]         {
[16:59:30.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.513]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.513]             })
[16:59:30.513]         }
[16:59:30.513]     }, args = future.call.arguments)
[16:59:30.513] }
[16:59:30.513] Lazy evaluation: FALSE
[16:59:30.513] Asynchronous evaluation: TRUE
[16:59:30.513] Local evaluation: TRUE
[16:59:30.513] Environment: R_GlobalEnv
[16:59:30.513] Capture standard output: TRUE
[16:59:30.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.513] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.513] Packages: <none>
[16:59:30.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.513] Resolved: TRUE
[16:59:30.513] Value: <not collected>
[16:59:30.513] Conditions captured: <none>
[16:59:30.513] Early signaling: FALSE
[16:59:30.513] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.513] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.524] Chunk #1 of 2 ... DONE
[16:59:30.524] Chunk #2 of 2 ...
[16:59:30.524]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.524]  - seeds: <none>
[16:59:30.524]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.525] getGlobalsAndPackages() ...
[16:59:30.525] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.525] Resolving globals: FALSE
[16:59:30.525] Tweak future expression to call with '...' arguments ...
[16:59:30.525] {
[16:59:30.525]     do.call(function(...) {
[16:59:30.525]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.525]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.525]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.525]             on.exit(options(oopts), add = TRUE)
[16:59:30.525]         }
[16:59:30.525]         {
[16:59:30.525]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.525]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.525]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.525]             })
[16:59:30.525]         }
[16:59:30.525]     }, args = future.call.arguments)
[16:59:30.525] }
[16:59:30.526] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.526] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.527] 
[16:59:30.527] getGlobalsAndPackages() ... DONE
[16:59:30.527] run() for ‘Future’ ...
[16:59:30.528] - state: ‘created’
[16:59:30.528] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.532] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.533]   - Field: ‘label’
[16:59:30.533]   - Field: ‘local’
[16:59:30.533]   - Field: ‘owner’
[16:59:30.533]   - Field: ‘envir’
[16:59:30.533]   - Field: ‘workers’
[16:59:30.534]   - Field: ‘packages’
[16:59:30.534]   - Field: ‘gc’
[16:59:30.534]   - Field: ‘job’
[16:59:30.534]   - Field: ‘conditions’
[16:59:30.534]   - Field: ‘expr’
[16:59:30.534]   - Field: ‘uuid’
[16:59:30.534]   - Field: ‘seed’
[16:59:30.535]   - Field: ‘version’
[16:59:30.535]   - Field: ‘result’
[16:59:30.535]   - Field: ‘asynchronous’
[16:59:30.535]   - Field: ‘calls’
[16:59:30.535]   - Field: ‘globals’
[16:59:30.535]   - Field: ‘stdout’
[16:59:30.535]   - Field: ‘earlySignal’
[16:59:30.536]   - Field: ‘lazy’
[16:59:30.536]   - Field: ‘state’
[16:59:30.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.536] - Launch lazy future ...
[16:59:30.537] Packages needed by the future expression (n = 0): <none>
[16:59:30.537] Packages needed by future strategies (n = 0): <none>
[16:59:30.537] {
[16:59:30.537]     {
[16:59:30.537]         {
[16:59:30.537]             ...future.startTime <- base::Sys.time()
[16:59:30.537]             {
[16:59:30.537]                 {
[16:59:30.537]                   {
[16:59:30.537]                     {
[16:59:30.537]                       base::local({
[16:59:30.537]                         has_future <- base::requireNamespace("future", 
[16:59:30.537]                           quietly = TRUE)
[16:59:30.537]                         if (has_future) {
[16:59:30.537]                           ns <- base::getNamespace("future")
[16:59:30.537]                           version <- ns[[".package"]][["version"]]
[16:59:30.537]                           if (is.null(version)) 
[16:59:30.537]                             version <- utils::packageVersion("future")
[16:59:30.537]                         }
[16:59:30.537]                         else {
[16:59:30.537]                           version <- NULL
[16:59:30.537]                         }
[16:59:30.537]                         if (!has_future || version < "1.8.0") {
[16:59:30.537]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.537]                             "", base::R.version$version.string), 
[16:59:30.537]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.537]                               "release", "version")], collapse = " "), 
[16:59:30.537]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.537]                             info)
[16:59:30.537]                           info <- base::paste(info, collapse = "; ")
[16:59:30.537]                           if (!has_future) {
[16:59:30.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.537]                               info)
[16:59:30.537]                           }
[16:59:30.537]                           else {
[16:59:30.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.537]                               info, version)
[16:59:30.537]                           }
[16:59:30.537]                           base::stop(msg)
[16:59:30.537]                         }
[16:59:30.537]                       })
[16:59:30.537]                     }
[16:59:30.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.537]                     base::options(mc.cores = 1L)
[16:59:30.537]                   }
[16:59:30.537]                   ...future.strategy.old <- future::plan("list")
[16:59:30.537]                   options(future.plan = NULL)
[16:59:30.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.537]                 }
[16:59:30.537]                 ...future.workdir <- getwd()
[16:59:30.537]             }
[16:59:30.537]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.537]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.537]         }
[16:59:30.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.537]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.537]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.537]             base::names(...future.oldOptions))
[16:59:30.537]     }
[16:59:30.537]     if (FALSE) {
[16:59:30.537]     }
[16:59:30.537]     else {
[16:59:30.537]         if (TRUE) {
[16:59:30.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.537]                 open = "w")
[16:59:30.537]         }
[16:59:30.537]         else {
[16:59:30.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.537]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.537]         }
[16:59:30.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.537]             base::sink(type = "output", split = FALSE)
[16:59:30.537]             base::close(...future.stdout)
[16:59:30.537]         }, add = TRUE)
[16:59:30.537]     }
[16:59:30.537]     ...future.frame <- base::sys.nframe()
[16:59:30.537]     ...future.conditions <- base::list()
[16:59:30.537]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.537]     if (FALSE) {
[16:59:30.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.537]     }
[16:59:30.537]     ...future.result <- base::tryCatch({
[16:59:30.537]         base::withCallingHandlers({
[16:59:30.537]             ...future.value <- base::withVisible(base::local({
[16:59:30.537]                 withCallingHandlers({
[16:59:30.537]                   {
[16:59:30.537]                     do.call(function(...) {
[16:59:30.537]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.537]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.537]                         ...future.globals.maxSize)) {
[16:59:30.537]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.537]                         on.exit(options(oopts), add = TRUE)
[16:59:30.537]                       }
[16:59:30.537]                       {
[16:59:30.537]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.537]                           FUN = function(jj) {
[16:59:30.537]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.537]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.537]                           })
[16:59:30.537]                       }
[16:59:30.537]                     }, args = future.call.arguments)
[16:59:30.537]                   }
[16:59:30.537]                 }, immediateCondition = function(cond) {
[16:59:30.537]                   save_rds <- function (object, pathname, ...) 
[16:59:30.537]                   {
[16:59:30.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.537]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.537]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.537]                         fi_tmp[["mtime"]])
[16:59:30.537]                     }
[16:59:30.537]                     tryCatch({
[16:59:30.537]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.537]                     }, error = function(ex) {
[16:59:30.537]                       msg <- conditionMessage(ex)
[16:59:30.537]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.537]                         fi_tmp[["mtime"]], msg)
[16:59:30.537]                       ex$message <- msg
[16:59:30.537]                       stop(ex)
[16:59:30.537]                     })
[16:59:30.537]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.537]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.537]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.537]                       fi <- file.info(pathname)
[16:59:30.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.537]                         fi[["size"]], fi[["mtime"]])
[16:59:30.537]                       stop(msg)
[16:59:30.537]                     }
[16:59:30.537]                     invisible(pathname)
[16:59:30.537]                   }
[16:59:30.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.537]                     rootPath = tempdir()) 
[16:59:30.537]                   {
[16:59:30.537]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.537]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.537]                       tmpdir = path, fileext = ".rds")
[16:59:30.537]                     save_rds(obj, file)
[16:59:30.537]                   }
[16:59:30.537]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.537]                   {
[16:59:30.537]                     inherits <- base::inherits
[16:59:30.537]                     invokeRestart <- base::invokeRestart
[16:59:30.537]                     is.null <- base::is.null
[16:59:30.537]                     muffled <- FALSE
[16:59:30.537]                     if (inherits(cond, "message")) {
[16:59:30.537]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.537]                       if (muffled) 
[16:59:30.537]                         invokeRestart("muffleMessage")
[16:59:30.537]                     }
[16:59:30.537]                     else if (inherits(cond, "warning")) {
[16:59:30.537]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.537]                       if (muffled) 
[16:59:30.537]                         invokeRestart("muffleWarning")
[16:59:30.537]                     }
[16:59:30.537]                     else if (inherits(cond, "condition")) {
[16:59:30.537]                       if (!is.null(pattern)) {
[16:59:30.537]                         computeRestarts <- base::computeRestarts
[16:59:30.537]                         grepl <- base::grepl
[16:59:30.537]                         restarts <- computeRestarts(cond)
[16:59:30.537]                         for (restart in restarts) {
[16:59:30.537]                           name <- restart$name
[16:59:30.537]                           if (is.null(name)) 
[16:59:30.537]                             next
[16:59:30.537]                           if (!grepl(pattern, name)) 
[16:59:30.537]                             next
[16:59:30.537]                           invokeRestart(restart)
[16:59:30.537]                           muffled <- TRUE
[16:59:30.537]                           break
[16:59:30.537]                         }
[16:59:30.537]                       }
[16:59:30.537]                     }
[16:59:30.537]                     invisible(muffled)
[16:59:30.537]                   }
[16:59:30.537]                   muffleCondition(cond)
[16:59:30.537]                 })
[16:59:30.537]             }))
[16:59:30.537]             future::FutureResult(value = ...future.value$value, 
[16:59:30.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.537]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.537]                     ...future.globalenv.names))
[16:59:30.537]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.537]         }, condition = base::local({
[16:59:30.537]             c <- base::c
[16:59:30.537]             inherits <- base::inherits
[16:59:30.537]             invokeRestart <- base::invokeRestart
[16:59:30.537]             length <- base::length
[16:59:30.537]             list <- base::list
[16:59:30.537]             seq.int <- base::seq.int
[16:59:30.537]             signalCondition <- base::signalCondition
[16:59:30.537]             sys.calls <- base::sys.calls
[16:59:30.537]             `[[` <- base::`[[`
[16:59:30.537]             `+` <- base::`+`
[16:59:30.537]             `<<-` <- base::`<<-`
[16:59:30.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.537]                   3L)]
[16:59:30.537]             }
[16:59:30.537]             function(cond) {
[16:59:30.537]                 is_error <- inherits(cond, "error")
[16:59:30.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.537]                   NULL)
[16:59:30.537]                 if (is_error) {
[16:59:30.537]                   sessionInformation <- function() {
[16:59:30.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.537]                       search = base::search(), system = base::Sys.info())
[16:59:30.537]                   }
[16:59:30.537]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.537]                     cond$call), session = sessionInformation(), 
[16:59:30.537]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.537]                   signalCondition(cond)
[16:59:30.537]                 }
[16:59:30.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.537]                 "immediateCondition"))) {
[16:59:30.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.537]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.537]                   if (TRUE && !signal) {
[16:59:30.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.537]                     {
[16:59:30.537]                       inherits <- base::inherits
[16:59:30.537]                       invokeRestart <- base::invokeRestart
[16:59:30.537]                       is.null <- base::is.null
[16:59:30.537]                       muffled <- FALSE
[16:59:30.537]                       if (inherits(cond, "message")) {
[16:59:30.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.537]                         if (muffled) 
[16:59:30.537]                           invokeRestart("muffleMessage")
[16:59:30.537]                       }
[16:59:30.537]                       else if (inherits(cond, "warning")) {
[16:59:30.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.537]                         if (muffled) 
[16:59:30.537]                           invokeRestart("muffleWarning")
[16:59:30.537]                       }
[16:59:30.537]                       else if (inherits(cond, "condition")) {
[16:59:30.537]                         if (!is.null(pattern)) {
[16:59:30.537]                           computeRestarts <- base::computeRestarts
[16:59:30.537]                           grepl <- base::grepl
[16:59:30.537]                           restarts <- computeRestarts(cond)
[16:59:30.537]                           for (restart in restarts) {
[16:59:30.537]                             name <- restart$name
[16:59:30.537]                             if (is.null(name)) 
[16:59:30.537]                               next
[16:59:30.537]                             if (!grepl(pattern, name)) 
[16:59:30.537]                               next
[16:59:30.537]                             invokeRestart(restart)
[16:59:30.537]                             muffled <- TRUE
[16:59:30.537]                             break
[16:59:30.537]                           }
[16:59:30.537]                         }
[16:59:30.537]                       }
[16:59:30.537]                       invisible(muffled)
[16:59:30.537]                     }
[16:59:30.537]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.537]                   }
[16:59:30.537]                 }
[16:59:30.537]                 else {
[16:59:30.537]                   if (TRUE) {
[16:59:30.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.537]                     {
[16:59:30.537]                       inherits <- base::inherits
[16:59:30.537]                       invokeRestart <- base::invokeRestart
[16:59:30.537]                       is.null <- base::is.null
[16:59:30.537]                       muffled <- FALSE
[16:59:30.537]                       if (inherits(cond, "message")) {
[16:59:30.537]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.537]                         if (muffled) 
[16:59:30.537]                           invokeRestart("muffleMessage")
[16:59:30.537]                       }
[16:59:30.537]                       else if (inherits(cond, "warning")) {
[16:59:30.537]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.537]                         if (muffled) 
[16:59:30.537]                           invokeRestart("muffleWarning")
[16:59:30.537]                       }
[16:59:30.537]                       else if (inherits(cond, "condition")) {
[16:59:30.537]                         if (!is.null(pattern)) {
[16:59:30.537]                           computeRestarts <- base::computeRestarts
[16:59:30.537]                           grepl <- base::grepl
[16:59:30.537]                           restarts <- computeRestarts(cond)
[16:59:30.537]                           for (restart in restarts) {
[16:59:30.537]                             name <- restart$name
[16:59:30.537]                             if (is.null(name)) 
[16:59:30.537]                               next
[16:59:30.537]                             if (!grepl(pattern, name)) 
[16:59:30.537]                               next
[16:59:30.537]                             invokeRestart(restart)
[16:59:30.537]                             muffled <- TRUE
[16:59:30.537]                             break
[16:59:30.537]                           }
[16:59:30.537]                         }
[16:59:30.537]                       }
[16:59:30.537]                       invisible(muffled)
[16:59:30.537]                     }
[16:59:30.537]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.537]                   }
[16:59:30.537]                 }
[16:59:30.537]             }
[16:59:30.537]         }))
[16:59:30.537]     }, error = function(ex) {
[16:59:30.537]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.537]                 ...future.rng), started = ...future.startTime, 
[16:59:30.537]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.537]             version = "1.8"), class = "FutureResult")
[16:59:30.537]     }, finally = {
[16:59:30.537]         if (!identical(...future.workdir, getwd())) 
[16:59:30.537]             setwd(...future.workdir)
[16:59:30.537]         {
[16:59:30.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.537]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.537]             }
[16:59:30.537]             base::options(...future.oldOptions)
[16:59:30.537]             if (.Platform$OS.type == "windows") {
[16:59:30.537]                 old_names <- names(...future.oldEnvVars)
[16:59:30.537]                 envs <- base::Sys.getenv()
[16:59:30.537]                 names <- names(envs)
[16:59:30.537]                 common <- intersect(names, old_names)
[16:59:30.537]                 added <- setdiff(names, old_names)
[16:59:30.537]                 removed <- setdiff(old_names, names)
[16:59:30.537]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.537]                   envs[common]]
[16:59:30.537]                 NAMES <- toupper(changed)
[16:59:30.537]                 args <- list()
[16:59:30.537]                 for (kk in seq_along(NAMES)) {
[16:59:30.537]                   name <- changed[[kk]]
[16:59:30.537]                   NAME <- NAMES[[kk]]
[16:59:30.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.537]                     next
[16:59:30.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.537]                 }
[16:59:30.537]                 NAMES <- toupper(added)
[16:59:30.537]                 for (kk in seq_along(NAMES)) {
[16:59:30.537]                   name <- added[[kk]]
[16:59:30.537]                   NAME <- NAMES[[kk]]
[16:59:30.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.537]                     next
[16:59:30.537]                   args[[name]] <- ""
[16:59:30.537]                 }
[16:59:30.537]                 NAMES <- toupper(removed)
[16:59:30.537]                 for (kk in seq_along(NAMES)) {
[16:59:30.537]                   name <- removed[[kk]]
[16:59:30.537]                   NAME <- NAMES[[kk]]
[16:59:30.537]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.537]                     next
[16:59:30.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.537]                 }
[16:59:30.537]                 if (length(args) > 0) 
[16:59:30.537]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.537]             }
[16:59:30.537]             else {
[16:59:30.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.537]             }
[16:59:30.537]             {
[16:59:30.537]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.537]                   0L) {
[16:59:30.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.537]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.537]                   base::options(opts)
[16:59:30.537]                 }
[16:59:30.537]                 {
[16:59:30.537]                   {
[16:59:30.537]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.537]                     NULL
[16:59:30.537]                   }
[16:59:30.537]                   options(future.plan = NULL)
[16:59:30.537]                   if (is.na(NA_character_)) 
[16:59:30.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.537]                     .init = FALSE)
[16:59:30.537]                 }
[16:59:30.537]             }
[16:59:30.537]         }
[16:59:30.537]     })
[16:59:30.537]     if (TRUE) {
[16:59:30.537]         base::sink(type = "output", split = FALSE)
[16:59:30.537]         if (TRUE) {
[16:59:30.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.537]         }
[16:59:30.537]         else {
[16:59:30.537]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.537]         }
[16:59:30.537]         base::close(...future.stdout)
[16:59:30.537]         ...future.stdout <- NULL
[16:59:30.537]     }
[16:59:30.537]     ...future.result$conditions <- ...future.conditions
[16:59:30.537]     ...future.result$finished <- base::Sys.time()
[16:59:30.537]     ...future.result
[16:59:30.537] }
[16:59:30.541] assign_globals() ...
[16:59:30.541] List of 5
[16:59:30.541]  $ future.call.arguments    : list()
[16:59:30.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.541]  $ ...future.FUN            :function (x)  
[16:59:30.541]  $ ...future.elements_ii    :List of 1
[16:59:30.541]   ..$ : int 2
[16:59:30.541]  $ ...future.seeds_ii       : NULL
[16:59:30.541]  $ ...future.globals.maxSize: num Inf
[16:59:30.541]  - attr(*, "resolved")= logi FALSE
[16:59:30.541]  - attr(*, "total_size")= num NA
[16:59:30.541]  - attr(*, "where")=List of 5
[16:59:30.541]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.541]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.541]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.541]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.541]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.541]  - attr(*, "already-done")= logi TRUE
[16:59:30.554] - copied ‘future.call.arguments’ to environment
[16:59:30.554] - copied ‘...future.FUN’ to environment
[16:59:30.554] - copied ‘...future.elements_ii’ to environment
[16:59:30.554] - copied ‘...future.seeds_ii’ to environment
[16:59:30.554] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.555] assign_globals() ... done
[16:59:30.555] requestCore(): workers = 2
[16:59:30.557] MulticoreFuture started
[16:59:30.558] - Launch lazy future ... done
[16:59:30.558] run() for ‘MulticoreFuture’ ... done
[16:59:30.558] Created future:
[16:59:30.558] plan(): Setting new future strategy stack:
[16:59:30.559] List of future strategies:
[16:59:30.559] 1. sequential:
[16:59:30.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.559]    - tweaked: FALSE
[16:59:30.559]    - call: NULL
[16:59:30.560] plan(): nbrOfWorkers() = 1
[16:59:30.562] plan(): Setting new future strategy stack:
[16:59:30.563] List of future strategies:
[16:59:30.563] 1. multicore:
[16:59:30.563]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.563]    - tweaked: FALSE
[16:59:30.563]    - call: plan(strategy)
[16:59:30.568] plan(): nbrOfWorkers() = 2
[16:59:30.558] MulticoreFuture:
[16:59:30.558] Label: ‘future_apply-2’
[16:59:30.558] Expression:
[16:59:30.558] {
[16:59:30.558]     do.call(function(...) {
[16:59:30.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.558]             on.exit(options(oopts), add = TRUE)
[16:59:30.558]         }
[16:59:30.558]         {
[16:59:30.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.558]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.558]             })
[16:59:30.558]         }
[16:59:30.558]     }, args = future.call.arguments)
[16:59:30.558] }
[16:59:30.558] Lazy evaluation: FALSE
[16:59:30.558] Asynchronous evaluation: TRUE
[16:59:30.558] Local evaluation: TRUE
[16:59:30.558] Environment: R_GlobalEnv
[16:59:30.558] Capture standard output: TRUE
[16:59:30.558] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.558] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.558] Packages: <none>
[16:59:30.558] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.558] Resolved: TRUE
[16:59:30.558] Value: <not collected>
[16:59:30.558] Conditions captured: <none>
[16:59:30.558] Early signaling: FALSE
[16:59:30.558] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.558] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.569] Chunk #2 of 2 ... DONE
[16:59:30.570] Launching 2 futures (chunks) ... DONE
[16:59:30.570] Resolving 2 futures (chunks) ...
[16:59:30.570] resolve() on list ...
[16:59:30.570]  recursive: 0
[16:59:30.570]  length: 2
[16:59:30.570] 
[16:59:30.571] Future #1
[16:59:30.571] result() for MulticoreFuture ...
[16:59:30.572] result() for MulticoreFuture ...
[16:59:30.572] result() for MulticoreFuture ... done
[16:59:30.572] result() for MulticoreFuture ... done
[16:59:30.572] result() for MulticoreFuture ...
[16:59:30.573] result() for MulticoreFuture ... done
[16:59:30.573] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.573] - nx: 2
[16:59:30.573] - relay: TRUE
[16:59:30.573] - stdout: TRUE
[16:59:30.573] - signal: TRUE
[16:59:30.573] - resignal: FALSE
[16:59:30.574] - force: TRUE
[16:59:30.574] - relayed: [n=2] FALSE, FALSE
[16:59:30.574] - queued futures: [n=2] FALSE, FALSE
[16:59:30.574]  - until=1
[16:59:30.574]  - relaying element #1
[16:59:30.574] result() for MulticoreFuture ...
[16:59:30.574] result() for MulticoreFuture ... done
[16:59:30.575] result() for MulticoreFuture ...
[16:59:30.575] result() for MulticoreFuture ... done
[16:59:30.575] result() for MulticoreFuture ...
[16:59:30.575] result() for MulticoreFuture ... done
[16:59:30.575] result() for MulticoreFuture ...
[16:59:30.575] result() for MulticoreFuture ... done
[16:59:30.576] - relayed: [n=2] TRUE, FALSE
[16:59:30.576] - queued futures: [n=2] TRUE, FALSE
[16:59:30.576] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.576]  length: 1 (resolved future 1)
[16:59:30.576] Future #2
[16:59:30.576] result() for MulticoreFuture ...
[16:59:30.577] result() for MulticoreFuture ...
[16:59:30.577] result() for MulticoreFuture ... done
[16:59:30.577] result() for MulticoreFuture ... done
[16:59:30.578] result() for MulticoreFuture ...
[16:59:30.578] result() for MulticoreFuture ... done
[16:59:30.578] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.578] - nx: 2
[16:59:30.578] - relay: TRUE
[16:59:30.578] - stdout: TRUE
[16:59:30.578] - signal: TRUE
[16:59:30.579] - resignal: FALSE
[16:59:30.579] - force: TRUE
[16:59:30.579] - relayed: [n=2] TRUE, FALSE
[16:59:30.579] - queued futures: [n=2] TRUE, FALSE
[16:59:30.579]  - until=2
[16:59:30.579]  - relaying element #2
[16:59:30.579] result() for MulticoreFuture ...
[16:59:30.580] result() for MulticoreFuture ... done
[16:59:30.580] result() for MulticoreFuture ...
[16:59:30.580] result() for MulticoreFuture ... done
[16:59:30.580] result() for MulticoreFuture ...
[16:59:30.580] result() for MulticoreFuture ... done
[16:59:30.580] result() for MulticoreFuture ...
[16:59:30.580] result() for MulticoreFuture ... done
[16:59:30.580] - relayed: [n=2] TRUE, TRUE
[16:59:30.581] - queued futures: [n=2] TRUE, TRUE
[16:59:30.581] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.581]  length: 0 (resolved future 2)
[16:59:30.581] Relaying remaining futures
[16:59:30.581] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.581] - nx: 2
[16:59:30.581] - relay: TRUE
[16:59:30.581] - stdout: TRUE
[16:59:30.581] - signal: TRUE
[16:59:30.582] - resignal: FALSE
[16:59:30.582] - force: TRUE
[16:59:30.582] - relayed: [n=2] TRUE, TRUE
[16:59:30.582] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.582] - relayed: [n=2] TRUE, TRUE
[16:59:30.582] - queued futures: [n=2] TRUE, TRUE
[16:59:30.582] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.582] resolve() on list ... DONE
[16:59:30.583] result() for MulticoreFuture ...
[16:59:30.583] result() for MulticoreFuture ... done
[16:59:30.583] result() for MulticoreFuture ...
[16:59:30.583] result() for MulticoreFuture ... done
[16:59:30.583] result() for MulticoreFuture ...
[16:59:30.583] result() for MulticoreFuture ... done
[16:59:30.583] result() for MulticoreFuture ...
[16:59:30.583] result() for MulticoreFuture ... done
[16:59:30.583]  - Number of value chunks collected: 2
[16:59:30.584] Resolving 2 futures (chunks) ... DONE
[16:59:30.584] Reducing values from 2 chunks ...
[16:59:30.584]  - Number of values collected after concatenation: 2
[16:59:30.584]  - Number of values expected: 2
[16:59:30.584] Reducing values from 2 chunks ... DONE
[16:59:30.584] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:59:30.585] getGlobalsAndPackagesXApply() ...
[16:59:30.585]  - future.globals: TRUE
[16:59:30.585] getGlobalsAndPackages() ...
[16:59:30.585] Searching for globals...
[16:59:30.586] - globals found: [1] ‘FUN’
[16:59:30.586] Searching for globals ... DONE
[16:59:30.586] Resolving globals: FALSE
[16:59:30.587] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:30.587] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:30.587] - globals: [1] ‘FUN’
[16:59:30.588] 
[16:59:30.588] getGlobalsAndPackages() ... DONE
[16:59:30.588]  - globals found/used: [n=1] ‘FUN’
[16:59:30.588]  - needed namespaces: [n=0] 
[16:59:30.588] Finding globals ... DONE
[16:59:30.588]  - use_args: TRUE
[16:59:30.588]  - Getting '...' globals ...
[16:59:30.589] resolve() on list ...
[16:59:30.589]  recursive: 0
[16:59:30.589]  length: 1
[16:59:30.589]  elements: ‘...’
[16:59:30.589]  length: 0 (resolved future 1)
[16:59:30.589] resolve() on list ... DONE
[16:59:30.589]    - '...' content: [n=0] 
[16:59:30.589] List of 1
[16:59:30.589]  $ ...: list()
[16:59:30.589]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.589]  - attr(*, "where")=List of 1
[16:59:30.589]   ..$ ...:<environment: 0x55f313c22ec0> 
[16:59:30.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.589]  - attr(*, "resolved")= logi TRUE
[16:59:30.589]  - attr(*, "total_size")= num NA
[16:59:30.595]  - Getting '...' globals ... DONE
[16:59:30.596] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.596] List of 2
[16:59:30.596]  $ ...future.FUN:function (x)  
[16:59:30.596]  $ ...          : list()
[16:59:30.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.596]  - attr(*, "where")=List of 2
[16:59:30.596]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.596]   ..$ ...          :<environment: 0x55f313c22ec0> 
[16:59:30.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.596]  - attr(*, "resolved")= logi FALSE
[16:59:30.596]  - attr(*, "total_size")= num 848
[16:59:30.599] Packages to be attached in all futures: [n=0] 
[16:59:30.599] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.604] future_lapply() ...
[16:59:30.608] Number of chunks: 2
[16:59:30.608] getGlobalsAndPackagesXApply() ...
[16:59:30.608]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.609]  - use_args: TRUE
[16:59:30.609] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.609] List of 2
[16:59:30.609]  $ ...          : list()
[16:59:30.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.609]  $ ...future.FUN:function (x)  
[16:59:30.609]  - attr(*, "where")=List of 2
[16:59:30.609]   ..$ ...          :<environment: 0x55f313c22ec0> 
[16:59:30.609]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:30.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.609]  - attr(*, "resolved")= logi FALSE
[16:59:30.609]  - attr(*, "total_size")= num NA
[16:59:30.612] Packages to be attached in all futures: [n=0] 
[16:59:30.612] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.613] Number of futures (= number of chunks): 2
[16:59:30.613] Launching 2 futures (chunks) ...
[16:59:30.613] Chunk #1 of 2 ...
[16:59:30.613]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.613]  - seeds: <none>
[16:59:30.613]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.613] getGlobalsAndPackages() ...
[16:59:30.613] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.614] Resolving globals: FALSE
[16:59:30.614] Tweak future expression to call with '...' arguments ...
[16:59:30.614] {
[16:59:30.614]     do.call(function(...) {
[16:59:30.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.614]             on.exit(options(oopts), add = TRUE)
[16:59:30.614]         }
[16:59:30.614]         {
[16:59:30.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.614]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.614]             })
[16:59:30.614]         }
[16:59:30.614]     }, args = future.call.arguments)
[16:59:30.614] }
[16:59:30.614] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.614] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.615] 
[16:59:30.615] getGlobalsAndPackages() ... DONE
[16:59:30.615] run() for ‘Future’ ...
[16:59:30.615] - state: ‘created’
[16:59:30.615] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.619] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.619] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.619]   - Field: ‘label’
[16:59:30.619]   - Field: ‘local’
[16:59:30.619]   - Field: ‘owner’
[16:59:30.619]   - Field: ‘envir’
[16:59:30.620]   - Field: ‘workers’
[16:59:30.620]   - Field: ‘packages’
[16:59:30.620]   - Field: ‘gc’
[16:59:30.620]   - Field: ‘job’
[16:59:30.620]   - Field: ‘conditions’
[16:59:30.620]   - Field: ‘expr’
[16:59:30.620]   - Field: ‘uuid’
[16:59:30.620]   - Field: ‘seed’
[16:59:30.620]   - Field: ‘version’
[16:59:30.620]   - Field: ‘result’
[16:59:30.620]   - Field: ‘asynchronous’
[16:59:30.621]   - Field: ‘calls’
[16:59:30.621]   - Field: ‘globals’
[16:59:30.621]   - Field: ‘stdout’
[16:59:30.621]   - Field: ‘earlySignal’
[16:59:30.621]   - Field: ‘lazy’
[16:59:30.621]   - Field: ‘state’
[16:59:30.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.621] - Launch lazy future ...
[16:59:30.621] Packages needed by the future expression (n = 0): <none>
[16:59:30.622] Packages needed by future strategies (n = 0): <none>
[16:59:30.622] {
[16:59:30.622]     {
[16:59:30.622]         {
[16:59:30.622]             ...future.startTime <- base::Sys.time()
[16:59:30.622]             {
[16:59:30.622]                 {
[16:59:30.622]                   {
[16:59:30.622]                     {
[16:59:30.622]                       base::local({
[16:59:30.622]                         has_future <- base::requireNamespace("future", 
[16:59:30.622]                           quietly = TRUE)
[16:59:30.622]                         if (has_future) {
[16:59:30.622]                           ns <- base::getNamespace("future")
[16:59:30.622]                           version <- ns[[".package"]][["version"]]
[16:59:30.622]                           if (is.null(version)) 
[16:59:30.622]                             version <- utils::packageVersion("future")
[16:59:30.622]                         }
[16:59:30.622]                         else {
[16:59:30.622]                           version <- NULL
[16:59:30.622]                         }
[16:59:30.622]                         if (!has_future || version < "1.8.0") {
[16:59:30.622]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.622]                             "", base::R.version$version.string), 
[16:59:30.622]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.622]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.622]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.622]                               "release", "version")], collapse = " "), 
[16:59:30.622]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.622]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.622]                             info)
[16:59:30.622]                           info <- base::paste(info, collapse = "; ")
[16:59:30.622]                           if (!has_future) {
[16:59:30.622]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.622]                               info)
[16:59:30.622]                           }
[16:59:30.622]                           else {
[16:59:30.622]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.622]                               info, version)
[16:59:30.622]                           }
[16:59:30.622]                           base::stop(msg)
[16:59:30.622]                         }
[16:59:30.622]                       })
[16:59:30.622]                     }
[16:59:30.622]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.622]                     base::options(mc.cores = 1L)
[16:59:30.622]                   }
[16:59:30.622]                   ...future.strategy.old <- future::plan("list")
[16:59:30.622]                   options(future.plan = NULL)
[16:59:30.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.622]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.622]                 }
[16:59:30.622]                 ...future.workdir <- getwd()
[16:59:30.622]             }
[16:59:30.622]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.622]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.622]         }
[16:59:30.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.622]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.622]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.622]             base::names(...future.oldOptions))
[16:59:30.622]     }
[16:59:30.622]     if (FALSE) {
[16:59:30.622]     }
[16:59:30.622]     else {
[16:59:30.622]         if (TRUE) {
[16:59:30.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.622]                 open = "w")
[16:59:30.622]         }
[16:59:30.622]         else {
[16:59:30.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.622]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.622]         }
[16:59:30.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.622]             base::sink(type = "output", split = FALSE)
[16:59:30.622]             base::close(...future.stdout)
[16:59:30.622]         }, add = TRUE)
[16:59:30.622]     }
[16:59:30.622]     ...future.frame <- base::sys.nframe()
[16:59:30.622]     ...future.conditions <- base::list()
[16:59:30.622]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.622]     if (FALSE) {
[16:59:30.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.622]     }
[16:59:30.622]     ...future.result <- base::tryCatch({
[16:59:30.622]         base::withCallingHandlers({
[16:59:30.622]             ...future.value <- base::withVisible(base::local({
[16:59:30.622]                 withCallingHandlers({
[16:59:30.622]                   {
[16:59:30.622]                     do.call(function(...) {
[16:59:30.622]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.622]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.622]                         ...future.globals.maxSize)) {
[16:59:30.622]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.622]                         on.exit(options(oopts), add = TRUE)
[16:59:30.622]                       }
[16:59:30.622]                       {
[16:59:30.622]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.622]                           FUN = function(jj) {
[16:59:30.622]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.622]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.622]                           })
[16:59:30.622]                       }
[16:59:30.622]                     }, args = future.call.arguments)
[16:59:30.622]                   }
[16:59:30.622]                 }, immediateCondition = function(cond) {
[16:59:30.622]                   save_rds <- function (object, pathname, ...) 
[16:59:30.622]                   {
[16:59:30.622]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.622]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.622]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.622]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.622]                         fi_tmp[["mtime"]])
[16:59:30.622]                     }
[16:59:30.622]                     tryCatch({
[16:59:30.622]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.622]                     }, error = function(ex) {
[16:59:30.622]                       msg <- conditionMessage(ex)
[16:59:30.622]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.622]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.622]                         fi_tmp[["mtime"]], msg)
[16:59:30.622]                       ex$message <- msg
[16:59:30.622]                       stop(ex)
[16:59:30.622]                     })
[16:59:30.622]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.622]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.622]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.622]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.622]                       fi <- file.info(pathname)
[16:59:30.622]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.622]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.622]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.622]                         fi[["size"]], fi[["mtime"]])
[16:59:30.622]                       stop(msg)
[16:59:30.622]                     }
[16:59:30.622]                     invisible(pathname)
[16:59:30.622]                   }
[16:59:30.622]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.622]                     rootPath = tempdir()) 
[16:59:30.622]                   {
[16:59:30.622]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.622]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.622]                       tmpdir = path, fileext = ".rds")
[16:59:30.622]                     save_rds(obj, file)
[16:59:30.622]                   }
[16:59:30.622]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.622]                   {
[16:59:30.622]                     inherits <- base::inherits
[16:59:30.622]                     invokeRestart <- base::invokeRestart
[16:59:30.622]                     is.null <- base::is.null
[16:59:30.622]                     muffled <- FALSE
[16:59:30.622]                     if (inherits(cond, "message")) {
[16:59:30.622]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.622]                       if (muffled) 
[16:59:30.622]                         invokeRestart("muffleMessage")
[16:59:30.622]                     }
[16:59:30.622]                     else if (inherits(cond, "warning")) {
[16:59:30.622]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.622]                       if (muffled) 
[16:59:30.622]                         invokeRestart("muffleWarning")
[16:59:30.622]                     }
[16:59:30.622]                     else if (inherits(cond, "condition")) {
[16:59:30.622]                       if (!is.null(pattern)) {
[16:59:30.622]                         computeRestarts <- base::computeRestarts
[16:59:30.622]                         grepl <- base::grepl
[16:59:30.622]                         restarts <- computeRestarts(cond)
[16:59:30.622]                         for (restart in restarts) {
[16:59:30.622]                           name <- restart$name
[16:59:30.622]                           if (is.null(name)) 
[16:59:30.622]                             next
[16:59:30.622]                           if (!grepl(pattern, name)) 
[16:59:30.622]                             next
[16:59:30.622]                           invokeRestart(restart)
[16:59:30.622]                           muffled <- TRUE
[16:59:30.622]                           break
[16:59:30.622]                         }
[16:59:30.622]                       }
[16:59:30.622]                     }
[16:59:30.622]                     invisible(muffled)
[16:59:30.622]                   }
[16:59:30.622]                   muffleCondition(cond)
[16:59:30.622]                 })
[16:59:30.622]             }))
[16:59:30.622]             future::FutureResult(value = ...future.value$value, 
[16:59:30.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.622]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.622]                     ...future.globalenv.names))
[16:59:30.622]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.622]         }, condition = base::local({
[16:59:30.622]             c <- base::c
[16:59:30.622]             inherits <- base::inherits
[16:59:30.622]             invokeRestart <- base::invokeRestart
[16:59:30.622]             length <- base::length
[16:59:30.622]             list <- base::list
[16:59:30.622]             seq.int <- base::seq.int
[16:59:30.622]             signalCondition <- base::signalCondition
[16:59:30.622]             sys.calls <- base::sys.calls
[16:59:30.622]             `[[` <- base::`[[`
[16:59:30.622]             `+` <- base::`+`
[16:59:30.622]             `<<-` <- base::`<<-`
[16:59:30.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.622]                   3L)]
[16:59:30.622]             }
[16:59:30.622]             function(cond) {
[16:59:30.622]                 is_error <- inherits(cond, "error")
[16:59:30.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.622]                   NULL)
[16:59:30.622]                 if (is_error) {
[16:59:30.622]                   sessionInformation <- function() {
[16:59:30.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.622]                       search = base::search(), system = base::Sys.info())
[16:59:30.622]                   }
[16:59:30.622]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.622]                     cond$call), session = sessionInformation(), 
[16:59:30.622]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.622]                   signalCondition(cond)
[16:59:30.622]                 }
[16:59:30.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.622]                 "immediateCondition"))) {
[16:59:30.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.622]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.622]                   if (TRUE && !signal) {
[16:59:30.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.622]                     {
[16:59:30.622]                       inherits <- base::inherits
[16:59:30.622]                       invokeRestart <- base::invokeRestart
[16:59:30.622]                       is.null <- base::is.null
[16:59:30.622]                       muffled <- FALSE
[16:59:30.622]                       if (inherits(cond, "message")) {
[16:59:30.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.622]                         if (muffled) 
[16:59:30.622]                           invokeRestart("muffleMessage")
[16:59:30.622]                       }
[16:59:30.622]                       else if (inherits(cond, "warning")) {
[16:59:30.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.622]                         if (muffled) 
[16:59:30.622]                           invokeRestart("muffleWarning")
[16:59:30.622]                       }
[16:59:30.622]                       else if (inherits(cond, "condition")) {
[16:59:30.622]                         if (!is.null(pattern)) {
[16:59:30.622]                           computeRestarts <- base::computeRestarts
[16:59:30.622]                           grepl <- base::grepl
[16:59:30.622]                           restarts <- computeRestarts(cond)
[16:59:30.622]                           for (restart in restarts) {
[16:59:30.622]                             name <- restart$name
[16:59:30.622]                             if (is.null(name)) 
[16:59:30.622]                               next
[16:59:30.622]                             if (!grepl(pattern, name)) 
[16:59:30.622]                               next
[16:59:30.622]                             invokeRestart(restart)
[16:59:30.622]                             muffled <- TRUE
[16:59:30.622]                             break
[16:59:30.622]                           }
[16:59:30.622]                         }
[16:59:30.622]                       }
[16:59:30.622]                       invisible(muffled)
[16:59:30.622]                     }
[16:59:30.622]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.622]                   }
[16:59:30.622]                 }
[16:59:30.622]                 else {
[16:59:30.622]                   if (TRUE) {
[16:59:30.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.622]                     {
[16:59:30.622]                       inherits <- base::inherits
[16:59:30.622]                       invokeRestart <- base::invokeRestart
[16:59:30.622]                       is.null <- base::is.null
[16:59:30.622]                       muffled <- FALSE
[16:59:30.622]                       if (inherits(cond, "message")) {
[16:59:30.622]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.622]                         if (muffled) 
[16:59:30.622]                           invokeRestart("muffleMessage")
[16:59:30.622]                       }
[16:59:30.622]                       else if (inherits(cond, "warning")) {
[16:59:30.622]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.622]                         if (muffled) 
[16:59:30.622]                           invokeRestart("muffleWarning")
[16:59:30.622]                       }
[16:59:30.622]                       else if (inherits(cond, "condition")) {
[16:59:30.622]                         if (!is.null(pattern)) {
[16:59:30.622]                           computeRestarts <- base::computeRestarts
[16:59:30.622]                           grepl <- base::grepl
[16:59:30.622]                           restarts <- computeRestarts(cond)
[16:59:30.622]                           for (restart in restarts) {
[16:59:30.622]                             name <- restart$name
[16:59:30.622]                             if (is.null(name)) 
[16:59:30.622]                               next
[16:59:30.622]                             if (!grepl(pattern, name)) 
[16:59:30.622]                               next
[16:59:30.622]                             invokeRestart(restart)
[16:59:30.622]                             muffled <- TRUE
[16:59:30.622]                             break
[16:59:30.622]                           }
[16:59:30.622]                         }
[16:59:30.622]                       }
[16:59:30.622]                       invisible(muffled)
[16:59:30.622]                     }
[16:59:30.622]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.622]                   }
[16:59:30.622]                 }
[16:59:30.622]             }
[16:59:30.622]         }))
[16:59:30.622]     }, error = function(ex) {
[16:59:30.622]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.622]                 ...future.rng), started = ...future.startTime, 
[16:59:30.622]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.622]             version = "1.8"), class = "FutureResult")
[16:59:30.622]     }, finally = {
[16:59:30.622]         if (!identical(...future.workdir, getwd())) 
[16:59:30.622]             setwd(...future.workdir)
[16:59:30.622]         {
[16:59:30.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.622]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.622]             }
[16:59:30.622]             base::options(...future.oldOptions)
[16:59:30.622]             if (.Platform$OS.type == "windows") {
[16:59:30.622]                 old_names <- names(...future.oldEnvVars)
[16:59:30.622]                 envs <- base::Sys.getenv()
[16:59:30.622]                 names <- names(envs)
[16:59:30.622]                 common <- intersect(names, old_names)
[16:59:30.622]                 added <- setdiff(names, old_names)
[16:59:30.622]                 removed <- setdiff(old_names, names)
[16:59:30.622]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.622]                   envs[common]]
[16:59:30.622]                 NAMES <- toupper(changed)
[16:59:30.622]                 args <- list()
[16:59:30.622]                 for (kk in seq_along(NAMES)) {
[16:59:30.622]                   name <- changed[[kk]]
[16:59:30.622]                   NAME <- NAMES[[kk]]
[16:59:30.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.622]                     next
[16:59:30.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.622]                 }
[16:59:30.622]                 NAMES <- toupper(added)
[16:59:30.622]                 for (kk in seq_along(NAMES)) {
[16:59:30.622]                   name <- added[[kk]]
[16:59:30.622]                   NAME <- NAMES[[kk]]
[16:59:30.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.622]                     next
[16:59:30.622]                   args[[name]] <- ""
[16:59:30.622]                 }
[16:59:30.622]                 NAMES <- toupper(removed)
[16:59:30.622]                 for (kk in seq_along(NAMES)) {
[16:59:30.622]                   name <- removed[[kk]]
[16:59:30.622]                   NAME <- NAMES[[kk]]
[16:59:30.622]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.622]                     next
[16:59:30.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.622]                 }
[16:59:30.622]                 if (length(args) > 0) 
[16:59:30.622]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.622]             }
[16:59:30.622]             else {
[16:59:30.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.622]             }
[16:59:30.622]             {
[16:59:30.622]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.622]                   0L) {
[16:59:30.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.622]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.622]                   base::options(opts)
[16:59:30.622]                 }
[16:59:30.622]                 {
[16:59:30.622]                   {
[16:59:30.622]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.622]                     NULL
[16:59:30.622]                   }
[16:59:30.622]                   options(future.plan = NULL)
[16:59:30.622]                   if (is.na(NA_character_)) 
[16:59:30.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.622]                     .init = FALSE)
[16:59:30.622]                 }
[16:59:30.622]             }
[16:59:30.622]         }
[16:59:30.622]     })
[16:59:30.622]     if (TRUE) {
[16:59:30.622]         base::sink(type = "output", split = FALSE)
[16:59:30.622]         if (TRUE) {
[16:59:30.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.622]         }
[16:59:30.622]         else {
[16:59:30.622]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.622]         }
[16:59:30.622]         base::close(...future.stdout)
[16:59:30.622]         ...future.stdout <- NULL
[16:59:30.622]     }
[16:59:30.622]     ...future.result$conditions <- ...future.conditions
[16:59:30.622]     ...future.result$finished <- base::Sys.time()
[16:59:30.622]     ...future.result
[16:59:30.622] }
[16:59:30.625] assign_globals() ...
[16:59:30.625] List of 5
[16:59:30.625]  $ future.call.arguments    : list()
[16:59:30.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.625]  $ ...future.FUN            :function (x)  
[16:59:30.625]  $ ...future.elements_ii    :List of 1
[16:59:30.625]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[16:59:30.625]  $ ...future.seeds_ii       : NULL
[16:59:30.625]  $ ...future.globals.maxSize: num Inf
[16:59:30.625]  - attr(*, "resolved")= logi FALSE
[16:59:30.625]  - attr(*, "total_size")= num NA
[16:59:30.625]  - attr(*, "where")=List of 5
[16:59:30.625]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.625]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.625]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.625]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.625]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.625]  - attr(*, "already-done")= logi TRUE
[16:59:30.632] - copied ‘future.call.arguments’ to environment
[16:59:30.633] - copied ‘...future.FUN’ to environment
[16:59:30.633] - copied ‘...future.elements_ii’ to environment
[16:59:30.633] - copied ‘...future.seeds_ii’ to environment
[16:59:30.633] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.633] assign_globals() ... done
[16:59:30.633] requestCore(): workers = 2
[16:59:30.635] MulticoreFuture started
[16:59:30.636] - Launch lazy future ... done
[16:59:30.636] run() for ‘MulticoreFuture’ ... done
[16:59:30.637] Created future:
[16:59:30.637] plan(): Setting new future strategy stack:
[16:59:30.637] List of future strategies:
[16:59:30.637] 1. sequential:
[16:59:30.637]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.637]    - tweaked: FALSE
[16:59:30.637]    - call: NULL
[16:59:30.638] plan(): nbrOfWorkers() = 1
[16:59:30.641] plan(): Setting new future strategy stack:
[16:59:30.641] List of future strategies:
[16:59:30.641] 1. multicore:
[16:59:30.641]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.641]    - tweaked: FALSE
[16:59:30.641]    - call: plan(strategy)
[16:59:30.646] plan(): nbrOfWorkers() = 2
[16:59:30.637] MulticoreFuture:
[16:59:30.637] Label: ‘future_apply-1’
[16:59:30.637] Expression:
[16:59:30.637] {
[16:59:30.637]     do.call(function(...) {
[16:59:30.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.637]             on.exit(options(oopts), add = TRUE)
[16:59:30.637]         }
[16:59:30.637]         {
[16:59:30.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.637]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.637]             })
[16:59:30.637]         }
[16:59:30.637]     }, args = future.call.arguments)
[16:59:30.637] }
[16:59:30.637] Lazy evaluation: FALSE
[16:59:30.637] Asynchronous evaluation: TRUE
[16:59:30.637] Local evaluation: TRUE
[16:59:30.637] Environment: R_GlobalEnv
[16:59:30.637] Capture standard output: TRUE
[16:59:30.637] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.637] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.637] Packages: <none>
[16:59:30.637] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.637] Resolved: TRUE
[16:59:30.637] Value: <not collected>
[16:59:30.637] Conditions captured: <none>
[16:59:30.637] Early signaling: FALSE
[16:59:30.637] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.637] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.648] Chunk #1 of 2 ... DONE
[16:59:30.648] Chunk #2 of 2 ...
[16:59:30.648]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.648]  - seeds: <none>
[16:59:30.648]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.649] getGlobalsAndPackages() ...
[16:59:30.649] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.649] Resolving globals: FALSE
[16:59:30.649] Tweak future expression to call with '...' arguments ...
[16:59:30.649] {
[16:59:30.649]     do.call(function(...) {
[16:59:30.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.649]             on.exit(options(oopts), add = TRUE)
[16:59:30.649]         }
[16:59:30.649]         {
[16:59:30.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.649]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.649]             })
[16:59:30.649]         }
[16:59:30.649]     }, args = future.call.arguments)
[16:59:30.649] }
[16:59:30.650] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.650] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.651] 
[16:59:30.651] getGlobalsAndPackages() ... DONE
[16:59:30.651] run() for ‘Future’ ...
[16:59:30.652] - state: ‘created’
[16:59:30.652] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.656] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.657]   - Field: ‘label’
[16:59:30.657]   - Field: ‘local’
[16:59:30.657]   - Field: ‘owner’
[16:59:30.657]   - Field: ‘envir’
[16:59:30.657]   - Field: ‘workers’
[16:59:30.658]   - Field: ‘packages’
[16:59:30.658]   - Field: ‘gc’
[16:59:30.658]   - Field: ‘job’
[16:59:30.658]   - Field: ‘conditions’
[16:59:30.658]   - Field: ‘expr’
[16:59:30.658]   - Field: ‘uuid’
[16:59:30.658]   - Field: ‘seed’
[16:59:30.659]   - Field: ‘version’
[16:59:30.659]   - Field: ‘result’
[16:59:30.659]   - Field: ‘asynchronous’
[16:59:30.659]   - Field: ‘calls’
[16:59:30.659]   - Field: ‘globals’
[16:59:30.659]   - Field: ‘stdout’
[16:59:30.659]   - Field: ‘earlySignal’
[16:59:30.660]   - Field: ‘lazy’
[16:59:30.660]   - Field: ‘state’
[16:59:30.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.660] - Launch lazy future ...
[16:59:30.660] Packages needed by the future expression (n = 0): <none>
[16:59:30.661] Packages needed by future strategies (n = 0): <none>
[16:59:30.661] {
[16:59:30.661]     {
[16:59:30.661]         {
[16:59:30.661]             ...future.startTime <- base::Sys.time()
[16:59:30.661]             {
[16:59:30.661]                 {
[16:59:30.661]                   {
[16:59:30.661]                     {
[16:59:30.661]                       base::local({
[16:59:30.661]                         has_future <- base::requireNamespace("future", 
[16:59:30.661]                           quietly = TRUE)
[16:59:30.661]                         if (has_future) {
[16:59:30.661]                           ns <- base::getNamespace("future")
[16:59:30.661]                           version <- ns[[".package"]][["version"]]
[16:59:30.661]                           if (is.null(version)) 
[16:59:30.661]                             version <- utils::packageVersion("future")
[16:59:30.661]                         }
[16:59:30.661]                         else {
[16:59:30.661]                           version <- NULL
[16:59:30.661]                         }
[16:59:30.661]                         if (!has_future || version < "1.8.0") {
[16:59:30.661]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.661]                             "", base::R.version$version.string), 
[16:59:30.661]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.661]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.661]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.661]                               "release", "version")], collapse = " "), 
[16:59:30.661]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.661]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.661]                             info)
[16:59:30.661]                           info <- base::paste(info, collapse = "; ")
[16:59:30.661]                           if (!has_future) {
[16:59:30.661]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.661]                               info)
[16:59:30.661]                           }
[16:59:30.661]                           else {
[16:59:30.661]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.661]                               info, version)
[16:59:30.661]                           }
[16:59:30.661]                           base::stop(msg)
[16:59:30.661]                         }
[16:59:30.661]                       })
[16:59:30.661]                     }
[16:59:30.661]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.661]                     base::options(mc.cores = 1L)
[16:59:30.661]                   }
[16:59:30.661]                   ...future.strategy.old <- future::plan("list")
[16:59:30.661]                   options(future.plan = NULL)
[16:59:30.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.661]                 }
[16:59:30.661]                 ...future.workdir <- getwd()
[16:59:30.661]             }
[16:59:30.661]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.661]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.661]         }
[16:59:30.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.661]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.661]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.661]             base::names(...future.oldOptions))
[16:59:30.661]     }
[16:59:30.661]     if (FALSE) {
[16:59:30.661]     }
[16:59:30.661]     else {
[16:59:30.661]         if (TRUE) {
[16:59:30.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.661]                 open = "w")
[16:59:30.661]         }
[16:59:30.661]         else {
[16:59:30.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.661]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.661]         }
[16:59:30.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.661]             base::sink(type = "output", split = FALSE)
[16:59:30.661]             base::close(...future.stdout)
[16:59:30.661]         }, add = TRUE)
[16:59:30.661]     }
[16:59:30.661]     ...future.frame <- base::sys.nframe()
[16:59:30.661]     ...future.conditions <- base::list()
[16:59:30.661]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.661]     if (FALSE) {
[16:59:30.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.661]     }
[16:59:30.661]     ...future.result <- base::tryCatch({
[16:59:30.661]         base::withCallingHandlers({
[16:59:30.661]             ...future.value <- base::withVisible(base::local({
[16:59:30.661]                 withCallingHandlers({
[16:59:30.661]                   {
[16:59:30.661]                     do.call(function(...) {
[16:59:30.661]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.661]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.661]                         ...future.globals.maxSize)) {
[16:59:30.661]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.661]                         on.exit(options(oopts), add = TRUE)
[16:59:30.661]                       }
[16:59:30.661]                       {
[16:59:30.661]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.661]                           FUN = function(jj) {
[16:59:30.661]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.661]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.661]                           })
[16:59:30.661]                       }
[16:59:30.661]                     }, args = future.call.arguments)
[16:59:30.661]                   }
[16:59:30.661]                 }, immediateCondition = function(cond) {
[16:59:30.661]                   save_rds <- function (object, pathname, ...) 
[16:59:30.661]                   {
[16:59:30.661]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.661]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.661]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.661]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.661]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.661]                         fi_tmp[["mtime"]])
[16:59:30.661]                     }
[16:59:30.661]                     tryCatch({
[16:59:30.661]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.661]                     }, error = function(ex) {
[16:59:30.661]                       msg <- conditionMessage(ex)
[16:59:30.661]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.661]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.661]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.661]                         fi_tmp[["mtime"]], msg)
[16:59:30.661]                       ex$message <- msg
[16:59:30.661]                       stop(ex)
[16:59:30.661]                     })
[16:59:30.661]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.661]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.661]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.661]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.661]                       fi <- file.info(pathname)
[16:59:30.661]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.661]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.661]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.661]                         fi[["size"]], fi[["mtime"]])
[16:59:30.661]                       stop(msg)
[16:59:30.661]                     }
[16:59:30.661]                     invisible(pathname)
[16:59:30.661]                   }
[16:59:30.661]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.661]                     rootPath = tempdir()) 
[16:59:30.661]                   {
[16:59:30.661]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.661]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.661]                       tmpdir = path, fileext = ".rds")
[16:59:30.661]                     save_rds(obj, file)
[16:59:30.661]                   }
[16:59:30.661]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.661]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.661]                   {
[16:59:30.661]                     inherits <- base::inherits
[16:59:30.661]                     invokeRestart <- base::invokeRestart
[16:59:30.661]                     is.null <- base::is.null
[16:59:30.661]                     muffled <- FALSE
[16:59:30.661]                     if (inherits(cond, "message")) {
[16:59:30.661]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.661]                       if (muffled) 
[16:59:30.661]                         invokeRestart("muffleMessage")
[16:59:30.661]                     }
[16:59:30.661]                     else if (inherits(cond, "warning")) {
[16:59:30.661]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.661]                       if (muffled) 
[16:59:30.661]                         invokeRestart("muffleWarning")
[16:59:30.661]                     }
[16:59:30.661]                     else if (inherits(cond, "condition")) {
[16:59:30.661]                       if (!is.null(pattern)) {
[16:59:30.661]                         computeRestarts <- base::computeRestarts
[16:59:30.661]                         grepl <- base::grepl
[16:59:30.661]                         restarts <- computeRestarts(cond)
[16:59:30.661]                         for (restart in restarts) {
[16:59:30.661]                           name <- restart$name
[16:59:30.661]                           if (is.null(name)) 
[16:59:30.661]                             next
[16:59:30.661]                           if (!grepl(pattern, name)) 
[16:59:30.661]                             next
[16:59:30.661]                           invokeRestart(restart)
[16:59:30.661]                           muffled <- TRUE
[16:59:30.661]                           break
[16:59:30.661]                         }
[16:59:30.661]                       }
[16:59:30.661]                     }
[16:59:30.661]                     invisible(muffled)
[16:59:30.661]                   }
[16:59:30.661]                   muffleCondition(cond)
[16:59:30.661]                 })
[16:59:30.661]             }))
[16:59:30.661]             future::FutureResult(value = ...future.value$value, 
[16:59:30.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.661]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.661]                     ...future.globalenv.names))
[16:59:30.661]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.661]         }, condition = base::local({
[16:59:30.661]             c <- base::c
[16:59:30.661]             inherits <- base::inherits
[16:59:30.661]             invokeRestart <- base::invokeRestart
[16:59:30.661]             length <- base::length
[16:59:30.661]             list <- base::list
[16:59:30.661]             seq.int <- base::seq.int
[16:59:30.661]             signalCondition <- base::signalCondition
[16:59:30.661]             sys.calls <- base::sys.calls
[16:59:30.661]             `[[` <- base::`[[`
[16:59:30.661]             `+` <- base::`+`
[16:59:30.661]             `<<-` <- base::`<<-`
[16:59:30.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.661]                   3L)]
[16:59:30.661]             }
[16:59:30.661]             function(cond) {
[16:59:30.661]                 is_error <- inherits(cond, "error")
[16:59:30.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.661]                   NULL)
[16:59:30.661]                 if (is_error) {
[16:59:30.661]                   sessionInformation <- function() {
[16:59:30.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.661]                       search = base::search(), system = base::Sys.info())
[16:59:30.661]                   }
[16:59:30.661]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.661]                     cond$call), session = sessionInformation(), 
[16:59:30.661]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.661]                   signalCondition(cond)
[16:59:30.661]                 }
[16:59:30.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.661]                 "immediateCondition"))) {
[16:59:30.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.661]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.661]                   if (TRUE && !signal) {
[16:59:30.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.661]                     {
[16:59:30.661]                       inherits <- base::inherits
[16:59:30.661]                       invokeRestart <- base::invokeRestart
[16:59:30.661]                       is.null <- base::is.null
[16:59:30.661]                       muffled <- FALSE
[16:59:30.661]                       if (inherits(cond, "message")) {
[16:59:30.661]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.661]                         if (muffled) 
[16:59:30.661]                           invokeRestart("muffleMessage")
[16:59:30.661]                       }
[16:59:30.661]                       else if (inherits(cond, "warning")) {
[16:59:30.661]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.661]                         if (muffled) 
[16:59:30.661]                           invokeRestart("muffleWarning")
[16:59:30.661]                       }
[16:59:30.661]                       else if (inherits(cond, "condition")) {
[16:59:30.661]                         if (!is.null(pattern)) {
[16:59:30.661]                           computeRestarts <- base::computeRestarts
[16:59:30.661]                           grepl <- base::grepl
[16:59:30.661]                           restarts <- computeRestarts(cond)
[16:59:30.661]                           for (restart in restarts) {
[16:59:30.661]                             name <- restart$name
[16:59:30.661]                             if (is.null(name)) 
[16:59:30.661]                               next
[16:59:30.661]                             if (!grepl(pattern, name)) 
[16:59:30.661]                               next
[16:59:30.661]                             invokeRestart(restart)
[16:59:30.661]                             muffled <- TRUE
[16:59:30.661]                             break
[16:59:30.661]                           }
[16:59:30.661]                         }
[16:59:30.661]                       }
[16:59:30.661]                       invisible(muffled)
[16:59:30.661]                     }
[16:59:30.661]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.661]                   }
[16:59:30.661]                 }
[16:59:30.661]                 else {
[16:59:30.661]                   if (TRUE) {
[16:59:30.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.661]                     {
[16:59:30.661]                       inherits <- base::inherits
[16:59:30.661]                       invokeRestart <- base::invokeRestart
[16:59:30.661]                       is.null <- base::is.null
[16:59:30.661]                       muffled <- FALSE
[16:59:30.661]                       if (inherits(cond, "message")) {
[16:59:30.661]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.661]                         if (muffled) 
[16:59:30.661]                           invokeRestart("muffleMessage")
[16:59:30.661]                       }
[16:59:30.661]                       else if (inherits(cond, "warning")) {
[16:59:30.661]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.661]                         if (muffled) 
[16:59:30.661]                           invokeRestart("muffleWarning")
[16:59:30.661]                       }
[16:59:30.661]                       else if (inherits(cond, "condition")) {
[16:59:30.661]                         if (!is.null(pattern)) {
[16:59:30.661]                           computeRestarts <- base::computeRestarts
[16:59:30.661]                           grepl <- base::grepl
[16:59:30.661]                           restarts <- computeRestarts(cond)
[16:59:30.661]                           for (restart in restarts) {
[16:59:30.661]                             name <- restart$name
[16:59:30.661]                             if (is.null(name)) 
[16:59:30.661]                               next
[16:59:30.661]                             if (!grepl(pattern, name)) 
[16:59:30.661]                               next
[16:59:30.661]                             invokeRestart(restart)
[16:59:30.661]                             muffled <- TRUE
[16:59:30.661]                             break
[16:59:30.661]                           }
[16:59:30.661]                         }
[16:59:30.661]                       }
[16:59:30.661]                       invisible(muffled)
[16:59:30.661]                     }
[16:59:30.661]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.661]                   }
[16:59:30.661]                 }
[16:59:30.661]             }
[16:59:30.661]         }))
[16:59:30.661]     }, error = function(ex) {
[16:59:30.661]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.661]                 ...future.rng), started = ...future.startTime, 
[16:59:30.661]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.661]             version = "1.8"), class = "FutureResult")
[16:59:30.661]     }, finally = {
[16:59:30.661]         if (!identical(...future.workdir, getwd())) 
[16:59:30.661]             setwd(...future.workdir)
[16:59:30.661]         {
[16:59:30.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.661]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.661]             }
[16:59:30.661]             base::options(...future.oldOptions)
[16:59:30.661]             if (.Platform$OS.type == "windows") {
[16:59:30.661]                 old_names <- names(...future.oldEnvVars)
[16:59:30.661]                 envs <- base::Sys.getenv()
[16:59:30.661]                 names <- names(envs)
[16:59:30.661]                 common <- intersect(names, old_names)
[16:59:30.661]                 added <- setdiff(names, old_names)
[16:59:30.661]                 removed <- setdiff(old_names, names)
[16:59:30.661]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.661]                   envs[common]]
[16:59:30.661]                 NAMES <- toupper(changed)
[16:59:30.661]                 args <- list()
[16:59:30.661]                 for (kk in seq_along(NAMES)) {
[16:59:30.661]                   name <- changed[[kk]]
[16:59:30.661]                   NAME <- NAMES[[kk]]
[16:59:30.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.661]                     next
[16:59:30.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.661]                 }
[16:59:30.661]                 NAMES <- toupper(added)
[16:59:30.661]                 for (kk in seq_along(NAMES)) {
[16:59:30.661]                   name <- added[[kk]]
[16:59:30.661]                   NAME <- NAMES[[kk]]
[16:59:30.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.661]                     next
[16:59:30.661]                   args[[name]] <- ""
[16:59:30.661]                 }
[16:59:30.661]                 NAMES <- toupper(removed)
[16:59:30.661]                 for (kk in seq_along(NAMES)) {
[16:59:30.661]                   name <- removed[[kk]]
[16:59:30.661]                   NAME <- NAMES[[kk]]
[16:59:30.661]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.661]                     next
[16:59:30.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.661]                 }
[16:59:30.661]                 if (length(args) > 0) 
[16:59:30.661]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.661]             }
[16:59:30.661]             else {
[16:59:30.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.661]             }
[16:59:30.661]             {
[16:59:30.661]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.661]                   0L) {
[16:59:30.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.661]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.661]                   base::options(opts)
[16:59:30.661]                 }
[16:59:30.661]                 {
[16:59:30.661]                   {
[16:59:30.661]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.661]                     NULL
[16:59:30.661]                   }
[16:59:30.661]                   options(future.plan = NULL)
[16:59:30.661]                   if (is.na(NA_character_)) 
[16:59:30.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.661]                     .init = FALSE)
[16:59:30.661]                 }
[16:59:30.661]             }
[16:59:30.661]         }
[16:59:30.661]     })
[16:59:30.661]     if (TRUE) {
[16:59:30.661]         base::sink(type = "output", split = FALSE)
[16:59:30.661]         if (TRUE) {
[16:59:30.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.661]         }
[16:59:30.661]         else {
[16:59:30.661]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.661]         }
[16:59:30.661]         base::close(...future.stdout)
[16:59:30.661]         ...future.stdout <- NULL
[16:59:30.661]     }
[16:59:30.661]     ...future.result$conditions <- ...future.conditions
[16:59:30.661]     ...future.result$finished <- base::Sys.time()
[16:59:30.661]     ...future.result
[16:59:30.661] }
[16:59:30.665] assign_globals() ...
[16:59:30.665] List of 5
[16:59:30.665]  $ future.call.arguments    : list()
[16:59:30.665]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.665]  $ ...future.FUN            :function (x)  
[16:59:30.665]  $ ...future.elements_ii    :List of 1
[16:59:30.665]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[16:59:30.665]  $ ...future.seeds_ii       : NULL
[16:59:30.665]  $ ...future.globals.maxSize: num Inf
[16:59:30.665]  - attr(*, "resolved")= logi FALSE
[16:59:30.665]  - attr(*, "total_size")= num NA
[16:59:30.665]  - attr(*, "where")=List of 5
[16:59:30.665]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.665]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.665]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.665]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.665]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.665]  - attr(*, "already-done")= logi TRUE
[16:59:30.673] - copied ‘future.call.arguments’ to environment
[16:59:30.673] - copied ‘...future.FUN’ to environment
[16:59:30.673] - copied ‘...future.elements_ii’ to environment
[16:59:30.673] - copied ‘...future.seeds_ii’ to environment
[16:59:30.674] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.674] assign_globals() ... done
[16:59:30.674] requestCore(): workers = 2
[16:59:30.676] MulticoreFuture started
[16:59:30.677] - Launch lazy future ... done
[16:59:30.677] run() for ‘MulticoreFuture’ ... done
[16:59:30.677] Created future:
[16:59:30.677] plan(): Setting new future strategy stack:
[16:59:30.678] List of future strategies:
[16:59:30.678] 1. sequential:
[16:59:30.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.678]    - tweaked: FALSE
[16:59:30.678]    - call: NULL
[16:59:30.679] plan(): nbrOfWorkers() = 1
[16:59:30.681] plan(): Setting new future strategy stack:
[16:59:30.681] List of future strategies:
[16:59:30.681] 1. multicore:
[16:59:30.681]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.681]    - tweaked: FALSE
[16:59:30.681]    - call: plan(strategy)
[16:59:30.677] MulticoreFuture:
[16:59:30.677] Label: ‘future_apply-2’
[16:59:30.677] Expression:
[16:59:30.677] {
[16:59:30.677]     do.call(function(...) {
[16:59:30.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.677]             on.exit(options(oopts), add = TRUE)
[16:59:30.677]         }
[16:59:30.677]         {
[16:59:30.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.677]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.677]             })
[16:59:30.677]         }
[16:59:30.677]     }, args = future.call.arguments)
[16:59:30.677] }
[16:59:30.677] Lazy evaluation: FALSE
[16:59:30.677] Asynchronous evaluation: TRUE
[16:59:30.677] Local evaluation: TRUE
[16:59:30.677] Environment: R_GlobalEnv
[16:59:30.677] Capture standard output: TRUE
[16:59:30.677] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.677] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.677] Packages: <none>
[16:59:30.677] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.677] Resolved: FALSE
[16:59:30.677] Value: <not collected>
[16:59:30.677] Conditions captured: <none>
[16:59:30.677] Early signaling: FALSE
[16:59:30.677] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.677] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.690] plan(): nbrOfWorkers() = 2
[16:59:30.691] Chunk #2 of 2 ... DONE
[16:59:30.691] Launching 2 futures (chunks) ... DONE
[16:59:30.691] Resolving 2 futures (chunks) ...
[16:59:30.691] resolve() on list ...
[16:59:30.691]  recursive: 0
[16:59:30.691]  length: 2
[16:59:30.692] 
[16:59:30.692] Future #1
[16:59:30.692] result() for MulticoreFuture ...
[16:59:30.693] result() for MulticoreFuture ...
[16:59:30.693] result() for MulticoreFuture ... done
[16:59:30.696] result() for MulticoreFuture ... done
[16:59:30.696] result() for MulticoreFuture ...
[16:59:30.697] result() for MulticoreFuture ... done
[16:59:30.697] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.698] - nx: 2
[16:59:30.698] - relay: TRUE
[16:59:30.698] - stdout: TRUE
[16:59:30.699] - signal: TRUE
[16:59:30.699] - resignal: FALSE
[16:59:30.699] - force: TRUE
[16:59:30.699] - relayed: [n=2] FALSE, FALSE
[16:59:30.700] - queued futures: [n=2] FALSE, FALSE
[16:59:30.700]  - until=1
[16:59:30.700]  - relaying element #1
[16:59:30.701] result() for MulticoreFuture ...
[16:59:30.701] result() for MulticoreFuture ... done
[16:59:30.701] result() for MulticoreFuture ...
[16:59:30.702] result() for MulticoreFuture ... done
[16:59:30.702] result() for MulticoreFuture ...
[16:59:30.702] result() for MulticoreFuture ... done
[16:59:30.702] result() for MulticoreFuture ...
[16:59:30.703] result() for MulticoreFuture ... done
[16:59:30.703] - relayed: [n=2] TRUE, FALSE
[16:59:30.703] - queued futures: [n=2] TRUE, FALSE
[16:59:30.703] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.704]  length: 1 (resolved future 1)
[16:59:30.704] Future #2
[16:59:30.704] result() for MulticoreFuture ...
[16:59:30.705] result() for MulticoreFuture ...
[16:59:30.705] result() for MulticoreFuture ... done
[16:59:30.705] result() for MulticoreFuture ... done
[16:59:30.705] result() for MulticoreFuture ...
[16:59:30.705] result() for MulticoreFuture ... done
[16:59:30.706] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.706] - nx: 2
[16:59:30.706] - relay: TRUE
[16:59:30.706] - stdout: TRUE
[16:59:30.706] - signal: TRUE
[16:59:30.706] - resignal: FALSE
[16:59:30.707] - force: TRUE
[16:59:30.707] - relayed: [n=2] TRUE, FALSE
[16:59:30.707] - queued futures: [n=2] TRUE, FALSE
[16:59:30.707]  - until=2
[16:59:30.707]  - relaying element #2
[16:59:30.707] result() for MulticoreFuture ...
[16:59:30.707] result() for MulticoreFuture ... done
[16:59:30.707] result() for MulticoreFuture ...
[16:59:30.708] result() for MulticoreFuture ... done
[16:59:30.708] result() for MulticoreFuture ...
[16:59:30.708] result() for MulticoreFuture ... done
[16:59:30.708] result() for MulticoreFuture ...
[16:59:30.708] result() for MulticoreFuture ... done
[16:59:30.708] - relayed: [n=2] TRUE, TRUE
[16:59:30.708] - queued futures: [n=2] TRUE, TRUE
[16:59:30.708] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.708]  length: 0 (resolved future 2)
[16:59:30.709] Relaying remaining futures
[16:59:30.709] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.709] - nx: 2
[16:59:30.709] - relay: TRUE
[16:59:30.709] - stdout: TRUE
[16:59:30.709] - signal: TRUE
[16:59:30.709] - resignal: FALSE
[16:59:30.709] - force: TRUE
[16:59:30.709] - relayed: [n=2] TRUE, TRUE
[16:59:30.709] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.710] - relayed: [n=2] TRUE, TRUE
[16:59:30.710] - queued futures: [n=2] TRUE, TRUE
[16:59:30.710] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.710] resolve() on list ... DONE
[16:59:30.710] result() for MulticoreFuture ...
[16:59:30.710] result() for MulticoreFuture ... done
[16:59:30.710] result() for MulticoreFuture ...
[16:59:30.710] result() for MulticoreFuture ... done
[16:59:30.710] result() for MulticoreFuture ...
[16:59:30.710] result() for MulticoreFuture ... done
[16:59:30.711] result() for MulticoreFuture ...
[16:59:30.711] result() for MulticoreFuture ... done
[16:59:30.711]  - Number of value chunks collected: 2
[16:59:30.711] Resolving 2 futures (chunks) ... DONE
[16:59:30.711] Reducing values from 2 chunks ...
[16:59:30.711]  - Number of values collected after concatenation: 2
[16:59:30.711]  - Number of values expected: 2
[16:59:30.711] Reducing values from 2 chunks ... DONE
[16:59:30.712] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:59:30.712] getGlobalsAndPackagesXApply() ...
[16:59:30.712]  - future.globals: TRUE
[16:59:30.712] getGlobalsAndPackages() ...
[16:59:30.712] Searching for globals...
[16:59:30.715] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:59:30.715] Searching for globals ... DONE
[16:59:30.716] Resolving globals: FALSE
[16:59:30.716] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:59:30.717] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:59:30.717] - globals: [1] ‘FUN’
[16:59:30.717] 
[16:59:30.717] getGlobalsAndPackages() ... DONE
[16:59:30.717]  - globals found/used: [n=1] ‘FUN’
[16:59:30.717]  - needed namespaces: [n=0] 
[16:59:30.717] Finding globals ... DONE
[16:59:30.717]  - use_args: TRUE
[16:59:30.717]  - Getting '...' globals ...
[16:59:30.718] resolve() on list ...
[16:59:30.718]  recursive: 0
[16:59:30.718]  length: 1
[16:59:30.718]  elements: ‘...’
[16:59:30.718]  length: 0 (resolved future 1)
[16:59:30.718] resolve() on list ... DONE
[16:59:30.718]    - '...' content: [n=0] 
[16:59:30.719] List of 1
[16:59:30.719]  $ ...: list()
[16:59:30.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.719]  - attr(*, "where")=List of 1
[16:59:30.719]   ..$ ...:<environment: 0x55f311e67280> 
[16:59:30.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.719]  - attr(*, "resolved")= logi TRUE
[16:59:30.719]  - attr(*, "total_size")= num NA
[16:59:30.721]  - Getting '...' globals ... DONE
[16:59:30.722] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.722] List of 2
[16:59:30.722]  $ ...future.FUN:function (x)  
[16:59:30.722]  $ ...          : list()
[16:59:30.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.722]  - attr(*, "where")=List of 2
[16:59:30.722]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.722]   ..$ ...          :<environment: 0x55f311e67280> 
[16:59:30.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.722]  - attr(*, "resolved")= logi FALSE
[16:59:30.722]  - attr(*, "total_size")= num 9888
[16:59:30.727] Packages to be attached in all futures: [n=0] 
[16:59:30.727] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.731] future_lapply() ...
[16:59:30.736] Number of chunks: 2
[16:59:30.736] getGlobalsAndPackagesXApply() ...
[16:59:30.736]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.736]  - use_args: TRUE
[16:59:30.736] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.736] List of 2
[16:59:30.736]  $ ...          : list()
[16:59:30.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.736]  $ ...future.FUN:function (x)  
[16:59:30.736]  - attr(*, "where")=List of 2
[16:59:30.736]   ..$ ...          :<environment: 0x55f311e67280> 
[16:59:30.736]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:59:30.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.736]  - attr(*, "resolved")= logi FALSE
[16:59:30.736]  - attr(*, "total_size")= num NA
[16:59:30.739] Packages to be attached in all futures: [n=0] 
[16:59:30.739] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.740] Number of futures (= number of chunks): 2
[16:59:30.740] Launching 2 futures (chunks) ...
[16:59:30.740] Chunk #1 of 2 ...
[16:59:30.740]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.740]  - seeds: <none>
[16:59:30.740]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.740] getGlobalsAndPackages() ...
[16:59:30.740] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.741] Resolving globals: FALSE
[16:59:30.741] Tweak future expression to call with '...' arguments ...
[16:59:30.741] {
[16:59:30.741]     do.call(function(...) {
[16:59:30.741]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.741]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.741]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.741]             on.exit(options(oopts), add = TRUE)
[16:59:30.741]         }
[16:59:30.741]         {
[16:59:30.741]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.741]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.741]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.741]             })
[16:59:30.741]         }
[16:59:30.741]     }, args = future.call.arguments)
[16:59:30.741] }
[16:59:30.741] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.741] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.741] 
[16:59:30.742] getGlobalsAndPackages() ... DONE
[16:59:30.742] run() for ‘Future’ ...
[16:59:30.742] - state: ‘created’
[16:59:30.742] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.746] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.746] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.746]   - Field: ‘label’
[16:59:30.746]   - Field: ‘local’
[16:59:30.746]   - Field: ‘owner’
[16:59:30.746]   - Field: ‘envir’
[16:59:30.746]   - Field: ‘workers’
[16:59:30.746]   - Field: ‘packages’
[16:59:30.746]   - Field: ‘gc’
[16:59:30.747]   - Field: ‘job’
[16:59:30.747]   - Field: ‘conditions’
[16:59:30.747]   - Field: ‘expr’
[16:59:30.747]   - Field: ‘uuid’
[16:59:30.747]   - Field: ‘seed’
[16:59:30.747]   - Field: ‘version’
[16:59:30.747]   - Field: ‘result’
[16:59:30.747]   - Field: ‘asynchronous’
[16:59:30.747]   - Field: ‘calls’
[16:59:30.747]   - Field: ‘globals’
[16:59:30.748]   - Field: ‘stdout’
[16:59:30.748]   - Field: ‘earlySignal’
[16:59:30.748]   - Field: ‘lazy’
[16:59:30.748]   - Field: ‘state’
[16:59:30.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.748] - Launch lazy future ...
[16:59:30.748] Packages needed by the future expression (n = 0): <none>
[16:59:30.748] Packages needed by future strategies (n = 0): <none>
[16:59:30.749] {
[16:59:30.749]     {
[16:59:30.749]         {
[16:59:30.749]             ...future.startTime <- base::Sys.time()
[16:59:30.749]             {
[16:59:30.749]                 {
[16:59:30.749]                   {
[16:59:30.749]                     {
[16:59:30.749]                       base::local({
[16:59:30.749]                         has_future <- base::requireNamespace("future", 
[16:59:30.749]                           quietly = TRUE)
[16:59:30.749]                         if (has_future) {
[16:59:30.749]                           ns <- base::getNamespace("future")
[16:59:30.749]                           version <- ns[[".package"]][["version"]]
[16:59:30.749]                           if (is.null(version)) 
[16:59:30.749]                             version <- utils::packageVersion("future")
[16:59:30.749]                         }
[16:59:30.749]                         else {
[16:59:30.749]                           version <- NULL
[16:59:30.749]                         }
[16:59:30.749]                         if (!has_future || version < "1.8.0") {
[16:59:30.749]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.749]                             "", base::R.version$version.string), 
[16:59:30.749]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.749]                               "release", "version")], collapse = " "), 
[16:59:30.749]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.749]                             info)
[16:59:30.749]                           info <- base::paste(info, collapse = "; ")
[16:59:30.749]                           if (!has_future) {
[16:59:30.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.749]                               info)
[16:59:30.749]                           }
[16:59:30.749]                           else {
[16:59:30.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.749]                               info, version)
[16:59:30.749]                           }
[16:59:30.749]                           base::stop(msg)
[16:59:30.749]                         }
[16:59:30.749]                       })
[16:59:30.749]                     }
[16:59:30.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.749]                     base::options(mc.cores = 1L)
[16:59:30.749]                   }
[16:59:30.749]                   ...future.strategy.old <- future::plan("list")
[16:59:30.749]                   options(future.plan = NULL)
[16:59:30.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.749]                 }
[16:59:30.749]                 ...future.workdir <- getwd()
[16:59:30.749]             }
[16:59:30.749]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.749]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.749]         }
[16:59:30.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.749]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.749]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.749]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.749]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.749]             base::names(...future.oldOptions))
[16:59:30.749]     }
[16:59:30.749]     if (FALSE) {
[16:59:30.749]     }
[16:59:30.749]     else {
[16:59:30.749]         if (TRUE) {
[16:59:30.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.749]                 open = "w")
[16:59:30.749]         }
[16:59:30.749]         else {
[16:59:30.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.749]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.749]         }
[16:59:30.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.749]             base::sink(type = "output", split = FALSE)
[16:59:30.749]             base::close(...future.stdout)
[16:59:30.749]         }, add = TRUE)
[16:59:30.749]     }
[16:59:30.749]     ...future.frame <- base::sys.nframe()
[16:59:30.749]     ...future.conditions <- base::list()
[16:59:30.749]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.749]     if (FALSE) {
[16:59:30.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.749]     }
[16:59:30.749]     ...future.result <- base::tryCatch({
[16:59:30.749]         base::withCallingHandlers({
[16:59:30.749]             ...future.value <- base::withVisible(base::local({
[16:59:30.749]                 withCallingHandlers({
[16:59:30.749]                   {
[16:59:30.749]                     do.call(function(...) {
[16:59:30.749]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.749]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.749]                         ...future.globals.maxSize)) {
[16:59:30.749]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.749]                         on.exit(options(oopts), add = TRUE)
[16:59:30.749]                       }
[16:59:30.749]                       {
[16:59:30.749]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.749]                           FUN = function(jj) {
[16:59:30.749]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.749]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.749]                           })
[16:59:30.749]                       }
[16:59:30.749]                     }, args = future.call.arguments)
[16:59:30.749]                   }
[16:59:30.749]                 }, immediateCondition = function(cond) {
[16:59:30.749]                   save_rds <- function (object, pathname, ...) 
[16:59:30.749]                   {
[16:59:30.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.749]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.749]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.749]                         fi_tmp[["mtime"]])
[16:59:30.749]                     }
[16:59:30.749]                     tryCatch({
[16:59:30.749]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.749]                     }, error = function(ex) {
[16:59:30.749]                       msg <- conditionMessage(ex)
[16:59:30.749]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.749]                         fi_tmp[["mtime"]], msg)
[16:59:30.749]                       ex$message <- msg
[16:59:30.749]                       stop(ex)
[16:59:30.749]                     })
[16:59:30.749]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.749]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.749]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.749]                       fi <- file.info(pathname)
[16:59:30.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.749]                         fi[["size"]], fi[["mtime"]])
[16:59:30.749]                       stop(msg)
[16:59:30.749]                     }
[16:59:30.749]                     invisible(pathname)
[16:59:30.749]                   }
[16:59:30.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.749]                     rootPath = tempdir()) 
[16:59:30.749]                   {
[16:59:30.749]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.749]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.749]                       tmpdir = path, fileext = ".rds")
[16:59:30.749]                     save_rds(obj, file)
[16:59:30.749]                   }
[16:59:30.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.749]                   {
[16:59:30.749]                     inherits <- base::inherits
[16:59:30.749]                     invokeRestart <- base::invokeRestart
[16:59:30.749]                     is.null <- base::is.null
[16:59:30.749]                     muffled <- FALSE
[16:59:30.749]                     if (inherits(cond, "message")) {
[16:59:30.749]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.749]                       if (muffled) 
[16:59:30.749]                         invokeRestart("muffleMessage")
[16:59:30.749]                     }
[16:59:30.749]                     else if (inherits(cond, "warning")) {
[16:59:30.749]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.749]                       if (muffled) 
[16:59:30.749]                         invokeRestart("muffleWarning")
[16:59:30.749]                     }
[16:59:30.749]                     else if (inherits(cond, "condition")) {
[16:59:30.749]                       if (!is.null(pattern)) {
[16:59:30.749]                         computeRestarts <- base::computeRestarts
[16:59:30.749]                         grepl <- base::grepl
[16:59:30.749]                         restarts <- computeRestarts(cond)
[16:59:30.749]                         for (restart in restarts) {
[16:59:30.749]                           name <- restart$name
[16:59:30.749]                           if (is.null(name)) 
[16:59:30.749]                             next
[16:59:30.749]                           if (!grepl(pattern, name)) 
[16:59:30.749]                             next
[16:59:30.749]                           invokeRestart(restart)
[16:59:30.749]                           muffled <- TRUE
[16:59:30.749]                           break
[16:59:30.749]                         }
[16:59:30.749]                       }
[16:59:30.749]                     }
[16:59:30.749]                     invisible(muffled)
[16:59:30.749]                   }
[16:59:30.749]                   muffleCondition(cond)
[16:59:30.749]                 })
[16:59:30.749]             }))
[16:59:30.749]             future::FutureResult(value = ...future.value$value, 
[16:59:30.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.749]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.749]                     ...future.globalenv.names))
[16:59:30.749]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.749]         }, condition = base::local({
[16:59:30.749]             c <- base::c
[16:59:30.749]             inherits <- base::inherits
[16:59:30.749]             invokeRestart <- base::invokeRestart
[16:59:30.749]             length <- base::length
[16:59:30.749]             list <- base::list
[16:59:30.749]             seq.int <- base::seq.int
[16:59:30.749]             signalCondition <- base::signalCondition
[16:59:30.749]             sys.calls <- base::sys.calls
[16:59:30.749]             `[[` <- base::`[[`
[16:59:30.749]             `+` <- base::`+`
[16:59:30.749]             `<<-` <- base::`<<-`
[16:59:30.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.749]                   3L)]
[16:59:30.749]             }
[16:59:30.749]             function(cond) {
[16:59:30.749]                 is_error <- inherits(cond, "error")
[16:59:30.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.749]                   NULL)
[16:59:30.749]                 if (is_error) {
[16:59:30.749]                   sessionInformation <- function() {
[16:59:30.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.749]                       search = base::search(), system = base::Sys.info())
[16:59:30.749]                   }
[16:59:30.749]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.749]                     cond$call), session = sessionInformation(), 
[16:59:30.749]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.749]                   signalCondition(cond)
[16:59:30.749]                 }
[16:59:30.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.749]                 "immediateCondition"))) {
[16:59:30.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.749]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.749]                   if (TRUE && !signal) {
[16:59:30.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.749]                     {
[16:59:30.749]                       inherits <- base::inherits
[16:59:30.749]                       invokeRestart <- base::invokeRestart
[16:59:30.749]                       is.null <- base::is.null
[16:59:30.749]                       muffled <- FALSE
[16:59:30.749]                       if (inherits(cond, "message")) {
[16:59:30.749]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.749]                         if (muffled) 
[16:59:30.749]                           invokeRestart("muffleMessage")
[16:59:30.749]                       }
[16:59:30.749]                       else if (inherits(cond, "warning")) {
[16:59:30.749]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.749]                         if (muffled) 
[16:59:30.749]                           invokeRestart("muffleWarning")
[16:59:30.749]                       }
[16:59:30.749]                       else if (inherits(cond, "condition")) {
[16:59:30.749]                         if (!is.null(pattern)) {
[16:59:30.749]                           computeRestarts <- base::computeRestarts
[16:59:30.749]                           grepl <- base::grepl
[16:59:30.749]                           restarts <- computeRestarts(cond)
[16:59:30.749]                           for (restart in restarts) {
[16:59:30.749]                             name <- restart$name
[16:59:30.749]                             if (is.null(name)) 
[16:59:30.749]                               next
[16:59:30.749]                             if (!grepl(pattern, name)) 
[16:59:30.749]                               next
[16:59:30.749]                             invokeRestart(restart)
[16:59:30.749]                             muffled <- TRUE
[16:59:30.749]                             break
[16:59:30.749]                           }
[16:59:30.749]                         }
[16:59:30.749]                       }
[16:59:30.749]                       invisible(muffled)
[16:59:30.749]                     }
[16:59:30.749]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.749]                   }
[16:59:30.749]                 }
[16:59:30.749]                 else {
[16:59:30.749]                   if (TRUE) {
[16:59:30.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.749]                     {
[16:59:30.749]                       inherits <- base::inherits
[16:59:30.749]                       invokeRestart <- base::invokeRestart
[16:59:30.749]                       is.null <- base::is.null
[16:59:30.749]                       muffled <- FALSE
[16:59:30.749]                       if (inherits(cond, "message")) {
[16:59:30.749]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.749]                         if (muffled) 
[16:59:30.749]                           invokeRestart("muffleMessage")
[16:59:30.749]                       }
[16:59:30.749]                       else if (inherits(cond, "warning")) {
[16:59:30.749]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.749]                         if (muffled) 
[16:59:30.749]                           invokeRestart("muffleWarning")
[16:59:30.749]                       }
[16:59:30.749]                       else if (inherits(cond, "condition")) {
[16:59:30.749]                         if (!is.null(pattern)) {
[16:59:30.749]                           computeRestarts <- base::computeRestarts
[16:59:30.749]                           grepl <- base::grepl
[16:59:30.749]                           restarts <- computeRestarts(cond)
[16:59:30.749]                           for (restart in restarts) {
[16:59:30.749]                             name <- restart$name
[16:59:30.749]                             if (is.null(name)) 
[16:59:30.749]                               next
[16:59:30.749]                             if (!grepl(pattern, name)) 
[16:59:30.749]                               next
[16:59:30.749]                             invokeRestart(restart)
[16:59:30.749]                             muffled <- TRUE
[16:59:30.749]                             break
[16:59:30.749]                           }
[16:59:30.749]                         }
[16:59:30.749]                       }
[16:59:30.749]                       invisible(muffled)
[16:59:30.749]                     }
[16:59:30.749]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.749]                   }
[16:59:30.749]                 }
[16:59:30.749]             }
[16:59:30.749]         }))
[16:59:30.749]     }, error = function(ex) {
[16:59:30.749]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.749]                 ...future.rng), started = ...future.startTime, 
[16:59:30.749]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.749]             version = "1.8"), class = "FutureResult")
[16:59:30.749]     }, finally = {
[16:59:30.749]         if (!identical(...future.workdir, getwd())) 
[16:59:30.749]             setwd(...future.workdir)
[16:59:30.749]         {
[16:59:30.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.749]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.749]             }
[16:59:30.749]             base::options(...future.oldOptions)
[16:59:30.749]             if (.Platform$OS.type == "windows") {
[16:59:30.749]                 old_names <- names(...future.oldEnvVars)
[16:59:30.749]                 envs <- base::Sys.getenv()
[16:59:30.749]                 names <- names(envs)
[16:59:30.749]                 common <- intersect(names, old_names)
[16:59:30.749]                 added <- setdiff(names, old_names)
[16:59:30.749]                 removed <- setdiff(old_names, names)
[16:59:30.749]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.749]                   envs[common]]
[16:59:30.749]                 NAMES <- toupper(changed)
[16:59:30.749]                 args <- list()
[16:59:30.749]                 for (kk in seq_along(NAMES)) {
[16:59:30.749]                   name <- changed[[kk]]
[16:59:30.749]                   NAME <- NAMES[[kk]]
[16:59:30.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.749]                     next
[16:59:30.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.749]                 }
[16:59:30.749]                 NAMES <- toupper(added)
[16:59:30.749]                 for (kk in seq_along(NAMES)) {
[16:59:30.749]                   name <- added[[kk]]
[16:59:30.749]                   NAME <- NAMES[[kk]]
[16:59:30.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.749]                     next
[16:59:30.749]                   args[[name]] <- ""
[16:59:30.749]                 }
[16:59:30.749]                 NAMES <- toupper(removed)
[16:59:30.749]                 for (kk in seq_along(NAMES)) {
[16:59:30.749]                   name <- removed[[kk]]
[16:59:30.749]                   NAME <- NAMES[[kk]]
[16:59:30.749]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.749]                     next
[16:59:30.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.749]                 }
[16:59:30.749]                 if (length(args) > 0) 
[16:59:30.749]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.749]             }
[16:59:30.749]             else {
[16:59:30.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.749]             }
[16:59:30.749]             {
[16:59:30.749]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.749]                   0L) {
[16:59:30.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.749]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.749]                   base::options(opts)
[16:59:30.749]                 }
[16:59:30.749]                 {
[16:59:30.749]                   {
[16:59:30.749]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.749]                     NULL
[16:59:30.749]                   }
[16:59:30.749]                   options(future.plan = NULL)
[16:59:30.749]                   if (is.na(NA_character_)) 
[16:59:30.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.749]                     .init = FALSE)
[16:59:30.749]                 }
[16:59:30.749]             }
[16:59:30.749]         }
[16:59:30.749]     })
[16:59:30.749]     if (TRUE) {
[16:59:30.749]         base::sink(type = "output", split = FALSE)
[16:59:30.749]         if (TRUE) {
[16:59:30.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.749]         }
[16:59:30.749]         else {
[16:59:30.749]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.749]         }
[16:59:30.749]         base::close(...future.stdout)
[16:59:30.749]         ...future.stdout <- NULL
[16:59:30.749]     }
[16:59:30.749]     ...future.result$conditions <- ...future.conditions
[16:59:30.749]     ...future.result$finished <- base::Sys.time()
[16:59:30.749]     ...future.result
[16:59:30.749] }
[16:59:30.751] assign_globals() ...
[16:59:30.752] List of 5
[16:59:30.752]  $ future.call.arguments    : list()
[16:59:30.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.752]  $ ...future.FUN            :function (x)  
[16:59:30.752]  $ ...future.elements_ii    :List of 1
[16:59:30.752]   ..$ : int [1:2] 1 3
[16:59:30.752]  $ ...future.seeds_ii       : NULL
[16:59:30.752]  $ ...future.globals.maxSize: num Inf
[16:59:30.752]  - attr(*, "resolved")= logi FALSE
[16:59:30.752]  - attr(*, "total_size")= num NA
[16:59:30.752]  - attr(*, "where")=List of 5
[16:59:30.752]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.752]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.752]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.752]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.752]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.752]  - attr(*, "already-done")= logi TRUE
[16:59:30.759] - copied ‘future.call.arguments’ to environment
[16:59:30.759] - reassign environment for ‘...future.FUN’
[16:59:30.759] - copied ‘...future.FUN’ to environment
[16:59:30.759] - copied ‘...future.elements_ii’ to environment
[16:59:30.759] - copied ‘...future.seeds_ii’ to environment
[16:59:30.759] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.759] assign_globals() ... done
[16:59:30.760] requestCore(): workers = 2
[16:59:30.762] MulticoreFuture started
[16:59:30.763] - Launch lazy future ... done
[16:59:30.763] plan(): Setting new future strategy stack:
[16:59:30.764] run() for ‘MulticoreFuture’ ... done
[16:59:30.764] Created future:
[16:59:30.764] List of future strategies:
[16:59:30.764] 1. sequential:
[16:59:30.764]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.764]    - tweaked: FALSE
[16:59:30.764]    - call: NULL
[16:59:30.766] plan(): nbrOfWorkers() = 1
[16:59:30.769] plan(): Setting new future strategy stack:
[16:59:30.769] List of future strategies:
[16:59:30.769] 1. multicore:
[16:59:30.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.769]    - tweaked: FALSE
[16:59:30.769]    - call: plan(strategy)
[16:59:30.775] plan(): nbrOfWorkers() = 2
[16:59:30.765] MulticoreFuture:
[16:59:30.765] Label: ‘future_apply-1’
[16:59:30.765] Expression:
[16:59:30.765] {
[16:59:30.765]     do.call(function(...) {
[16:59:30.765]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.765]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.765]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.765]             on.exit(options(oopts), add = TRUE)
[16:59:30.765]         }
[16:59:30.765]         {
[16:59:30.765]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.765]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.765]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.765]             })
[16:59:30.765]         }
[16:59:30.765]     }, args = future.call.arguments)
[16:59:30.765] }
[16:59:30.765] Lazy evaluation: FALSE
[16:59:30.765] Asynchronous evaluation: TRUE
[16:59:30.765] Local evaluation: TRUE
[16:59:30.765] Environment: R_GlobalEnv
[16:59:30.765] Capture standard output: TRUE
[16:59:30.765] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.765] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.765] Packages: <none>
[16:59:30.765] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.765] Resolved: TRUE
[16:59:30.765] Value: <not collected>
[16:59:30.765] Conditions captured: <none>
[16:59:30.765] Early signaling: FALSE
[16:59:30.765] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.765] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.776] Chunk #1 of 2 ... DONE
[16:59:30.776] Chunk #2 of 2 ...
[16:59:30.776]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.777]  - seeds: <none>
[16:59:30.777]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.777] getGlobalsAndPackages() ...
[16:59:30.777] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.777] Resolving globals: FALSE
[16:59:30.777] Tweak future expression to call with '...' arguments ...
[16:59:30.778] {
[16:59:30.778]     do.call(function(...) {
[16:59:30.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.778]             on.exit(options(oopts), add = TRUE)
[16:59:30.778]         }
[16:59:30.778]         {
[16:59:30.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.778]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.778]             })
[16:59:30.778]         }
[16:59:30.778]     }, args = future.call.arguments)
[16:59:30.778] }
[16:59:30.778] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.779] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.779] 
[16:59:30.779] getGlobalsAndPackages() ... DONE
[16:59:30.780] run() for ‘Future’ ...
[16:59:30.780] - state: ‘created’
[16:59:30.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.785] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.785] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.785]   - Field: ‘label’
[16:59:30.785]   - Field: ‘local’
[16:59:30.785]   - Field: ‘owner’
[16:59:30.786]   - Field: ‘envir’
[16:59:30.786]   - Field: ‘workers’
[16:59:30.786]   - Field: ‘packages’
[16:59:30.786]   - Field: ‘gc’
[16:59:30.786]   - Field: ‘job’
[16:59:30.786]   - Field: ‘conditions’
[16:59:30.786]   - Field: ‘expr’
[16:59:30.787]   - Field: ‘uuid’
[16:59:30.787]   - Field: ‘seed’
[16:59:30.787]   - Field: ‘version’
[16:59:30.787]   - Field: ‘result’
[16:59:30.787]   - Field: ‘asynchronous’
[16:59:30.787]   - Field: ‘calls’
[16:59:30.787]   - Field: ‘globals’
[16:59:30.788]   - Field: ‘stdout’
[16:59:30.788]   - Field: ‘earlySignal’
[16:59:30.788]   - Field: ‘lazy’
[16:59:30.788]   - Field: ‘state’
[16:59:30.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.788] - Launch lazy future ...
[16:59:30.789] Packages needed by the future expression (n = 0): <none>
[16:59:30.789] Packages needed by future strategies (n = 0): <none>
[16:59:30.789] {
[16:59:30.789]     {
[16:59:30.789]         {
[16:59:30.789]             ...future.startTime <- base::Sys.time()
[16:59:30.789]             {
[16:59:30.789]                 {
[16:59:30.789]                   {
[16:59:30.789]                     {
[16:59:30.789]                       base::local({
[16:59:30.789]                         has_future <- base::requireNamespace("future", 
[16:59:30.789]                           quietly = TRUE)
[16:59:30.789]                         if (has_future) {
[16:59:30.789]                           ns <- base::getNamespace("future")
[16:59:30.789]                           version <- ns[[".package"]][["version"]]
[16:59:30.789]                           if (is.null(version)) 
[16:59:30.789]                             version <- utils::packageVersion("future")
[16:59:30.789]                         }
[16:59:30.789]                         else {
[16:59:30.789]                           version <- NULL
[16:59:30.789]                         }
[16:59:30.789]                         if (!has_future || version < "1.8.0") {
[16:59:30.789]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.789]                             "", base::R.version$version.string), 
[16:59:30.789]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.789]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.789]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.789]                               "release", "version")], collapse = " "), 
[16:59:30.789]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.789]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.789]                             info)
[16:59:30.789]                           info <- base::paste(info, collapse = "; ")
[16:59:30.789]                           if (!has_future) {
[16:59:30.789]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.789]                               info)
[16:59:30.789]                           }
[16:59:30.789]                           else {
[16:59:30.789]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.789]                               info, version)
[16:59:30.789]                           }
[16:59:30.789]                           base::stop(msg)
[16:59:30.789]                         }
[16:59:30.789]                       })
[16:59:30.789]                     }
[16:59:30.789]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.789]                     base::options(mc.cores = 1L)
[16:59:30.789]                   }
[16:59:30.789]                   ...future.strategy.old <- future::plan("list")
[16:59:30.789]                   options(future.plan = NULL)
[16:59:30.789]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.789]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.789]                 }
[16:59:30.789]                 ...future.workdir <- getwd()
[16:59:30.789]             }
[16:59:30.789]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.789]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.789]         }
[16:59:30.789]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.789]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.789]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.789]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.789]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.789]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.789]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.789]             base::names(...future.oldOptions))
[16:59:30.789]     }
[16:59:30.789]     if (FALSE) {
[16:59:30.789]     }
[16:59:30.789]     else {
[16:59:30.789]         if (TRUE) {
[16:59:30.789]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.789]                 open = "w")
[16:59:30.789]         }
[16:59:30.789]         else {
[16:59:30.789]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.789]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.789]         }
[16:59:30.789]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.789]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.789]             base::sink(type = "output", split = FALSE)
[16:59:30.789]             base::close(...future.stdout)
[16:59:30.789]         }, add = TRUE)
[16:59:30.789]     }
[16:59:30.789]     ...future.frame <- base::sys.nframe()
[16:59:30.789]     ...future.conditions <- base::list()
[16:59:30.789]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.789]     if (FALSE) {
[16:59:30.789]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.789]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.789]     }
[16:59:30.789]     ...future.result <- base::tryCatch({
[16:59:30.789]         base::withCallingHandlers({
[16:59:30.789]             ...future.value <- base::withVisible(base::local({
[16:59:30.789]                 withCallingHandlers({
[16:59:30.789]                   {
[16:59:30.789]                     do.call(function(...) {
[16:59:30.789]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.789]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.789]                         ...future.globals.maxSize)) {
[16:59:30.789]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.789]                         on.exit(options(oopts), add = TRUE)
[16:59:30.789]                       }
[16:59:30.789]                       {
[16:59:30.789]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.789]                           FUN = function(jj) {
[16:59:30.789]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.789]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.789]                           })
[16:59:30.789]                       }
[16:59:30.789]                     }, args = future.call.arguments)
[16:59:30.789]                   }
[16:59:30.789]                 }, immediateCondition = function(cond) {
[16:59:30.789]                   save_rds <- function (object, pathname, ...) 
[16:59:30.789]                   {
[16:59:30.789]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.789]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.789]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.789]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.789]                         fi_tmp[["mtime"]])
[16:59:30.789]                     }
[16:59:30.789]                     tryCatch({
[16:59:30.789]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.789]                     }, error = function(ex) {
[16:59:30.789]                       msg <- conditionMessage(ex)
[16:59:30.789]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.789]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.789]                         fi_tmp[["mtime"]], msg)
[16:59:30.789]                       ex$message <- msg
[16:59:30.789]                       stop(ex)
[16:59:30.789]                     })
[16:59:30.789]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.789]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.789]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.789]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.789]                       fi <- file.info(pathname)
[16:59:30.789]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.789]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.789]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.789]                         fi[["size"]], fi[["mtime"]])
[16:59:30.789]                       stop(msg)
[16:59:30.789]                     }
[16:59:30.789]                     invisible(pathname)
[16:59:30.789]                   }
[16:59:30.789]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.789]                     rootPath = tempdir()) 
[16:59:30.789]                   {
[16:59:30.789]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.789]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.789]                       tmpdir = path, fileext = ".rds")
[16:59:30.789]                     save_rds(obj, file)
[16:59:30.789]                   }
[16:59:30.789]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.789]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.789]                   {
[16:59:30.789]                     inherits <- base::inherits
[16:59:30.789]                     invokeRestart <- base::invokeRestart
[16:59:30.789]                     is.null <- base::is.null
[16:59:30.789]                     muffled <- FALSE
[16:59:30.789]                     if (inherits(cond, "message")) {
[16:59:30.789]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.789]                       if (muffled) 
[16:59:30.789]                         invokeRestart("muffleMessage")
[16:59:30.789]                     }
[16:59:30.789]                     else if (inherits(cond, "warning")) {
[16:59:30.789]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.789]                       if (muffled) 
[16:59:30.789]                         invokeRestart("muffleWarning")
[16:59:30.789]                     }
[16:59:30.789]                     else if (inherits(cond, "condition")) {
[16:59:30.789]                       if (!is.null(pattern)) {
[16:59:30.789]                         computeRestarts <- base::computeRestarts
[16:59:30.789]                         grepl <- base::grepl
[16:59:30.789]                         restarts <- computeRestarts(cond)
[16:59:30.789]                         for (restart in restarts) {
[16:59:30.789]                           name <- restart$name
[16:59:30.789]                           if (is.null(name)) 
[16:59:30.789]                             next
[16:59:30.789]                           if (!grepl(pattern, name)) 
[16:59:30.789]                             next
[16:59:30.789]                           invokeRestart(restart)
[16:59:30.789]                           muffled <- TRUE
[16:59:30.789]                           break
[16:59:30.789]                         }
[16:59:30.789]                       }
[16:59:30.789]                     }
[16:59:30.789]                     invisible(muffled)
[16:59:30.789]                   }
[16:59:30.789]                   muffleCondition(cond)
[16:59:30.789]                 })
[16:59:30.789]             }))
[16:59:30.789]             future::FutureResult(value = ...future.value$value, 
[16:59:30.789]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.789]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.789]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.789]                     ...future.globalenv.names))
[16:59:30.789]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.789]         }, condition = base::local({
[16:59:30.789]             c <- base::c
[16:59:30.789]             inherits <- base::inherits
[16:59:30.789]             invokeRestart <- base::invokeRestart
[16:59:30.789]             length <- base::length
[16:59:30.789]             list <- base::list
[16:59:30.789]             seq.int <- base::seq.int
[16:59:30.789]             signalCondition <- base::signalCondition
[16:59:30.789]             sys.calls <- base::sys.calls
[16:59:30.789]             `[[` <- base::`[[`
[16:59:30.789]             `+` <- base::`+`
[16:59:30.789]             `<<-` <- base::`<<-`
[16:59:30.789]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.789]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.789]                   3L)]
[16:59:30.789]             }
[16:59:30.789]             function(cond) {
[16:59:30.789]                 is_error <- inherits(cond, "error")
[16:59:30.789]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.789]                   NULL)
[16:59:30.789]                 if (is_error) {
[16:59:30.789]                   sessionInformation <- function() {
[16:59:30.789]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.789]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.789]                       search = base::search(), system = base::Sys.info())
[16:59:30.789]                   }
[16:59:30.789]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.789]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.789]                     cond$call), session = sessionInformation(), 
[16:59:30.789]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.789]                   signalCondition(cond)
[16:59:30.789]                 }
[16:59:30.789]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:30.789]                 "immediateCondition"))) {
[16:59:30.789]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.789]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.789]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.789]                   if (TRUE && !signal) {
[16:59:30.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.789]                     {
[16:59:30.789]                       inherits <- base::inherits
[16:59:30.789]                       invokeRestart <- base::invokeRestart
[16:59:30.789]                       is.null <- base::is.null
[16:59:30.789]                       muffled <- FALSE
[16:59:30.789]                       if (inherits(cond, "message")) {
[16:59:30.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.789]                         if (muffled) 
[16:59:30.789]                           invokeRestart("muffleMessage")
[16:59:30.789]                       }
[16:59:30.789]                       else if (inherits(cond, "warning")) {
[16:59:30.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.789]                         if (muffled) 
[16:59:30.789]                           invokeRestart("muffleWarning")
[16:59:30.789]                       }
[16:59:30.789]                       else if (inherits(cond, "condition")) {
[16:59:30.789]                         if (!is.null(pattern)) {
[16:59:30.789]                           computeRestarts <- base::computeRestarts
[16:59:30.789]                           grepl <- base::grepl
[16:59:30.789]                           restarts <- computeRestarts(cond)
[16:59:30.789]                           for (restart in restarts) {
[16:59:30.789]                             name <- restart$name
[16:59:30.789]                             if (is.null(name)) 
[16:59:30.789]                               next
[16:59:30.789]                             if (!grepl(pattern, name)) 
[16:59:30.789]                               next
[16:59:30.789]                             invokeRestart(restart)
[16:59:30.789]                             muffled <- TRUE
[16:59:30.789]                             break
[16:59:30.789]                           }
[16:59:30.789]                         }
[16:59:30.789]                       }
[16:59:30.789]                       invisible(muffled)
[16:59:30.789]                     }
[16:59:30.789]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.789]                   }
[16:59:30.789]                 }
[16:59:30.789]                 else {
[16:59:30.789]                   if (TRUE) {
[16:59:30.789]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.789]                     {
[16:59:30.789]                       inherits <- base::inherits
[16:59:30.789]                       invokeRestart <- base::invokeRestart
[16:59:30.789]                       is.null <- base::is.null
[16:59:30.789]                       muffled <- FALSE
[16:59:30.789]                       if (inherits(cond, "message")) {
[16:59:30.789]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.789]                         if (muffled) 
[16:59:30.789]                           invokeRestart("muffleMessage")
[16:59:30.789]                       }
[16:59:30.789]                       else if (inherits(cond, "warning")) {
[16:59:30.789]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.789]                         if (muffled) 
[16:59:30.789]                           invokeRestart("muffleWarning")
[16:59:30.789]                       }
[16:59:30.789]                       else if (inherits(cond, "condition")) {
[16:59:30.789]                         if (!is.null(pattern)) {
[16:59:30.789]                           computeRestarts <- base::computeRestarts
[16:59:30.789]                           grepl <- base::grepl
[16:59:30.789]                           restarts <- computeRestarts(cond)
[16:59:30.789]                           for (restart in restarts) {
[16:59:30.789]                             name <- restart$name
[16:59:30.789]                             if (is.null(name)) 
[16:59:30.789]                               next
[16:59:30.789]                             if (!grepl(pattern, name)) 
[16:59:30.789]                               next
[16:59:30.789]                             invokeRestart(restart)
[16:59:30.789]                             muffled <- TRUE
[16:59:30.789]                             break
[16:59:30.789]                           }
[16:59:30.789]                         }
[16:59:30.789]                       }
[16:59:30.789]                       invisible(muffled)
[16:59:30.789]                     }
[16:59:30.789]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.789]                   }
[16:59:30.789]                 }
[16:59:30.789]             }
[16:59:30.789]         }))
[16:59:30.789]     }, error = function(ex) {
[16:59:30.789]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.789]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.789]                 ...future.rng), started = ...future.startTime, 
[16:59:30.789]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.789]             version = "1.8"), class = "FutureResult")
[16:59:30.789]     }, finally = {
[16:59:30.789]         if (!identical(...future.workdir, getwd())) 
[16:59:30.789]             setwd(...future.workdir)
[16:59:30.789]         {
[16:59:30.789]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.789]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.789]             }
[16:59:30.789]             base::options(...future.oldOptions)
[16:59:30.789]             if (.Platform$OS.type == "windows") {
[16:59:30.789]                 old_names <- names(...future.oldEnvVars)
[16:59:30.789]                 envs <- base::Sys.getenv()
[16:59:30.789]                 names <- names(envs)
[16:59:30.789]                 common <- intersect(names, old_names)
[16:59:30.789]                 added <- setdiff(names, old_names)
[16:59:30.789]                 removed <- setdiff(old_names, names)
[16:59:30.789]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.789]                   envs[common]]
[16:59:30.789]                 NAMES <- toupper(changed)
[16:59:30.789]                 args <- list()
[16:59:30.789]                 for (kk in seq_along(NAMES)) {
[16:59:30.789]                   name <- changed[[kk]]
[16:59:30.789]                   NAME <- NAMES[[kk]]
[16:59:30.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.789]                     next
[16:59:30.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.789]                 }
[16:59:30.789]                 NAMES <- toupper(added)
[16:59:30.789]                 for (kk in seq_along(NAMES)) {
[16:59:30.789]                   name <- added[[kk]]
[16:59:30.789]                   NAME <- NAMES[[kk]]
[16:59:30.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.789]                     next
[16:59:30.789]                   args[[name]] <- ""
[16:59:30.789]                 }
[16:59:30.789]                 NAMES <- toupper(removed)
[16:59:30.789]                 for (kk in seq_along(NAMES)) {
[16:59:30.789]                   name <- removed[[kk]]
[16:59:30.789]                   NAME <- NAMES[[kk]]
[16:59:30.789]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.789]                     next
[16:59:30.789]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.789]                 }
[16:59:30.789]                 if (length(args) > 0) 
[16:59:30.789]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.789]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.789]             }
[16:59:30.789]             else {
[16:59:30.789]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.789]             }
[16:59:30.789]             {
[16:59:30.789]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.789]                   0L) {
[16:59:30.789]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.789]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.789]                   base::options(opts)
[16:59:30.789]                 }
[16:59:30.789]                 {
[16:59:30.789]                   {
[16:59:30.789]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.789]                     NULL
[16:59:30.789]                   }
[16:59:30.789]                   options(future.plan = NULL)
[16:59:30.789]                   if (is.na(NA_character_)) 
[16:59:30.789]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.789]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.789]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.789]                     .init = FALSE)
[16:59:30.789]                 }
[16:59:30.789]             }
[16:59:30.789]         }
[16:59:30.789]     })
[16:59:30.789]     if (TRUE) {
[16:59:30.789]         base::sink(type = "output", split = FALSE)
[16:59:30.789]         if (TRUE) {
[16:59:30.789]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.789]         }
[16:59:30.789]         else {
[16:59:30.789]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.789]         }
[16:59:30.789]         base::close(...future.stdout)
[16:59:30.789]         ...future.stdout <- NULL
[16:59:30.789]     }
[16:59:30.789]     ...future.result$conditions <- ...future.conditions
[16:59:30.789]     ...future.result$finished <- base::Sys.time()
[16:59:30.789]     ...future.result
[16:59:30.789] }
[16:59:30.793] assign_globals() ...
[16:59:30.793] List of 5
[16:59:30.793]  $ future.call.arguments    : list()
[16:59:30.793]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.793]  $ ...future.FUN            :function (x)  
[16:59:30.793]  $ ...future.elements_ii    :List of 1
[16:59:30.793]   ..$ : int [1:2] 2 4
[16:59:30.793]  $ ...future.seeds_ii       : NULL
[16:59:30.793]  $ ...future.globals.maxSize: num Inf
[16:59:30.793]  - attr(*, "resolved")= logi FALSE
[16:59:30.793]  - attr(*, "total_size")= num NA
[16:59:30.793]  - attr(*, "where")=List of 5
[16:59:30.793]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.793]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.793]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.793]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.793]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.793]  - attr(*, "already-done")= logi TRUE
[16:59:30.800] - copied ‘future.call.arguments’ to environment
[16:59:30.800] - reassign environment for ‘...future.FUN’
[16:59:30.800] - copied ‘...future.FUN’ to environment
[16:59:30.800] - copied ‘...future.elements_ii’ to environment
[16:59:30.801] - copied ‘...future.seeds_ii’ to environment
[16:59:30.801] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.801] assign_globals() ... done
[16:59:30.801] requestCore(): workers = 2
[16:59:30.803] MulticoreFuture started
[16:59:30.804] - Launch lazy future ... done
[16:59:30.804] run() for ‘MulticoreFuture’ ... done
[16:59:30.804] Created future:
[16:59:30.804] plan(): Setting new future strategy stack:
[16:59:30.805] List of future strategies:
[16:59:30.805] 1. sequential:
[16:59:30.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.805]    - tweaked: FALSE
[16:59:30.805]    - call: NULL
[16:59:30.806] plan(): nbrOfWorkers() = 1
[16:59:30.808] plan(): Setting new future strategy stack:
[16:59:30.808] List of future strategies:
[16:59:30.808] 1. multicore:
[16:59:30.808]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.808]    - tweaked: FALSE
[16:59:30.808]    - call: plan(strategy)
[16:59:30.813] plan(): nbrOfWorkers() = 2
[16:59:30.804] MulticoreFuture:
[16:59:30.804] Label: ‘future_apply-2’
[16:59:30.804] Expression:
[16:59:30.804] {
[16:59:30.804]     do.call(function(...) {
[16:59:30.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.804]             on.exit(options(oopts), add = TRUE)
[16:59:30.804]         }
[16:59:30.804]         {
[16:59:30.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.804]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.804]             })
[16:59:30.804]         }
[16:59:30.804]     }, args = future.call.arguments)
[16:59:30.804] }
[16:59:30.804] Lazy evaluation: FALSE
[16:59:30.804] Asynchronous evaluation: TRUE
[16:59:30.804] Local evaluation: TRUE
[16:59:30.804] Environment: R_GlobalEnv
[16:59:30.804] Capture standard output: TRUE
[16:59:30.804] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:30.804] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.804] Packages: <none>
[16:59:30.804] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:30.804] Resolved: TRUE
[16:59:30.804] Value: <not collected>
[16:59:30.804] Conditions captured: <none>
[16:59:30.804] Early signaling: FALSE
[16:59:30.804] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.804] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.814] Chunk #2 of 2 ... DONE
[16:59:30.814] Launching 2 futures (chunks) ... DONE
[16:59:30.814] Resolving 2 futures (chunks) ...
[16:59:30.815] resolve() on list ...
[16:59:30.815]  recursive: 0
[16:59:30.815]  length: 2
[16:59:30.815] 
[16:59:30.816] Future #1
[16:59:30.816] result() for MulticoreFuture ...
[16:59:30.817] result() for MulticoreFuture ...
[16:59:30.817] result() for MulticoreFuture ... done
[16:59:30.817] result() for MulticoreFuture ... done
[16:59:30.817] result() for MulticoreFuture ...
[16:59:30.817] result() for MulticoreFuture ... done
[16:59:30.817] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.818] - nx: 2
[16:59:30.818] - relay: TRUE
[16:59:30.818] - stdout: TRUE
[16:59:30.818] - signal: TRUE
[16:59:30.818] - resignal: FALSE
[16:59:30.818] - force: TRUE
[16:59:30.818] - relayed: [n=2] FALSE, FALSE
[16:59:30.818] - queued futures: [n=2] FALSE, FALSE
[16:59:30.819]  - until=1
[16:59:30.819]  - relaying element #1
[16:59:30.819] result() for MulticoreFuture ...
[16:59:30.819] result() for MulticoreFuture ... done
[16:59:30.819] result() for MulticoreFuture ...
[16:59:30.823] result() for MulticoreFuture ... done
[16:59:30.824] result() for MulticoreFuture ...
[16:59:30.824] result() for MulticoreFuture ... done
[16:59:30.824] result() for MulticoreFuture ...
[16:59:30.825] result() for MulticoreFuture ... done
[16:59:30.825] - relayed: [n=2] TRUE, FALSE
[16:59:30.825] - queued futures: [n=2] TRUE, FALSE
[16:59:30.826] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.826]  length: 1 (resolved future 1)
[16:59:30.826] Future #2
[16:59:30.827] result() for MulticoreFuture ...
[16:59:30.828] result() for MulticoreFuture ...
[16:59:30.829] result() for MulticoreFuture ... done
[16:59:30.829] result() for MulticoreFuture ... done
[16:59:30.829] result() for MulticoreFuture ...
[16:59:30.829] result() for MulticoreFuture ... done
[16:59:30.830] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.830] - nx: 2
[16:59:30.830] - relay: TRUE
[16:59:30.830] - stdout: TRUE
[16:59:30.830] - signal: TRUE
[16:59:30.830] - resignal: FALSE
[16:59:30.831] - force: TRUE
[16:59:30.831] - relayed: [n=2] TRUE, FALSE
[16:59:30.831] - queued futures: [n=2] TRUE, FALSE
[16:59:30.831]  - until=2
[16:59:30.831]  - relaying element #2
[16:59:30.831] result() for MulticoreFuture ...
[16:59:30.831] result() for MulticoreFuture ... done
[16:59:30.832] result() for MulticoreFuture ...
[16:59:30.832] result() for MulticoreFuture ... done
[16:59:30.832] result() for MulticoreFuture ...
[16:59:30.832] result() for MulticoreFuture ... done
[16:59:30.832] result() for MulticoreFuture ...
[16:59:30.832] result() for MulticoreFuture ... done
[16:59:30.832] - relayed: [n=2] TRUE, TRUE
[16:59:30.832] - queued futures: [n=2] TRUE, TRUE
[16:59:30.833] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.833]  length: 0 (resolved future 2)
[16:59:30.833] Relaying remaining futures
[16:59:30.833] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.833] - nx: 2
[16:59:30.833] - relay: TRUE
[16:59:30.833] - stdout: TRUE
[16:59:30.833] - signal: TRUE
[16:59:30.833] - resignal: FALSE
[16:59:30.833] - force: TRUE
[16:59:30.834] - relayed: [n=2] TRUE, TRUE
[16:59:30.834] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.834] - relayed: [n=2] TRUE, TRUE
[16:59:30.834] - queued futures: [n=2] TRUE, TRUE
[16:59:30.834] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.834] resolve() on list ... DONE
[16:59:30.834] result() for MulticoreFuture ...
[16:59:30.834] result() for MulticoreFuture ... done
[16:59:30.834] result() for MulticoreFuture ...
[16:59:30.835] result() for MulticoreFuture ... done
[16:59:30.835] result() for MulticoreFuture ...
[16:59:30.835] result() for MulticoreFuture ... done
[16:59:30.835] result() for MulticoreFuture ...
[16:59:30.835] result() for MulticoreFuture ... done
[16:59:30.835]  - Number of value chunks collected: 2
[16:59:30.835] Resolving 2 futures (chunks) ... DONE
[16:59:30.835] Reducing values from 2 chunks ...
[16:59:30.836]  - Number of values collected after concatenation: 2
[16:59:30.836]  - Number of values expected: 2
[16:59:30.836] Reducing values from 2 chunks ... DONE
[16:59:30.836] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:59:30.836] getGlobalsAndPackagesXApply() ...
[16:59:30.836]  - future.globals: TRUE
[16:59:30.836] getGlobalsAndPackages() ...
[16:59:30.837] Searching for globals...
[16:59:30.840] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:59:30.840] Searching for globals ... DONE
[16:59:30.840] Resolving globals: FALSE
[16:59:30.841] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:59:30.842] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:59:30.842] - globals: [1] ‘FUN’
[16:59:30.842] 
[16:59:30.842] getGlobalsAndPackages() ... DONE
[16:59:30.842]  - globals found/used: [n=1] ‘FUN’
[16:59:30.842]  - needed namespaces: [n=0] 
[16:59:30.842] Finding globals ... DONE
[16:59:30.842]  - use_args: TRUE
[16:59:30.842]  - Getting '...' globals ...
[16:59:30.843] resolve() on list ...
[16:59:30.843]  recursive: 0
[16:59:30.843]  length: 1
[16:59:30.843]  elements: ‘...’
[16:59:30.843]  length: 0 (resolved future 1)
[16:59:30.843] resolve() on list ... DONE
[16:59:30.843]    - '...' content: [n=0] 
[16:59:30.844] List of 1
[16:59:30.844]  $ ...: list()
[16:59:30.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.844]  - attr(*, "where")=List of 1
[16:59:30.844]   ..$ ...:<environment: 0x55f3117ef398> 
[16:59:30.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.844]  - attr(*, "resolved")= logi TRUE
[16:59:30.844]  - attr(*, "total_size")= num NA
[16:59:30.846]  - Getting '...' globals ... DONE
[16:59:30.847] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:30.847] List of 2
[16:59:30.847]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:59:30.847]  $ ...          : list()
[16:59:30.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.847]  - attr(*, "where")=List of 2
[16:59:30.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:30.847]   ..$ ...          :<environment: 0x55f3117ef398> 
[16:59:30.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.847]  - attr(*, "resolved")= logi FALSE
[16:59:30.847]  - attr(*, "total_size")= num 36296
[16:59:30.850] Packages to be attached in all futures: [n=0] 
[16:59:30.850] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.856] future_lapply() ...
[16:59:30.858] Generating random seeds ...
[16:59:30.858] Generating random seed streams for 2 elements ...
[16:59:30.859] Generating random seed streams for 2 elements ... DONE
[16:59:30.859] Generating random seeds ... DONE
[16:59:30.859] Will set RNG state on exit: 10407, -43808357, 1177243629, -1062665225, 1677384733, -686861633, -1073504926
[16:59:30.863] Number of chunks: 2
[16:59:30.863] getGlobalsAndPackagesXApply() ...
[16:59:30.863]  - future.globals: <name-value list> with names ‘list()’
[16:59:30.863]  - use_args: TRUE
[16:59:30.863] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:30.863] List of 2
[16:59:30.863]  $ ...          : list()
[16:59:30.863]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.863]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:59:30.863]  - attr(*, "where")=List of 2
[16:59:30.863]   ..$ ...          :<environment: 0x55f3117ef398> 
[16:59:30.863]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:30.863]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.863]  - attr(*, "resolved")= logi FALSE
[16:59:30.863]  - attr(*, "total_size")= num NA
[16:59:30.867] Packages to be attached in all futures: [n=0] 
[16:59:30.867] getGlobalsAndPackagesXApply() ... DONE
[16:59:30.867] Number of futures (= number of chunks): 2
[16:59:30.867] Launching 2 futures (chunks) ...
[16:59:30.867] Chunk #1 of 2 ...
[16:59:30.868]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.868]  - seeds: [1] <seeds>
[16:59:30.868]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.868] getGlobalsAndPackages() ...
[16:59:30.868] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.868] Resolving globals: FALSE
[16:59:30.868] Tweak future expression to call with '...' arguments ...
[16:59:30.868] {
[16:59:30.868]     do.call(function(...) {
[16:59:30.868]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.868]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.868]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.868]             on.exit(options(oopts), add = TRUE)
[16:59:30.868]         }
[16:59:30.868]         {
[16:59:30.868]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.868]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.868]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:30.868]                   envir = globalenv(), inherits = FALSE)
[16:59:30.868]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.868]             })
[16:59:30.868]         }
[16:59:30.868]     }, args = future.call.arguments)
[16:59:30.868] }
[16:59:30.869] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.869] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.869] 
[16:59:30.869] getGlobalsAndPackages() ... DONE
[16:59:30.870] run() for ‘Future’ ...
[16:59:30.870] - state: ‘created’
[16:59:30.870] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.874] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.874] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.874]   - Field: ‘label’
[16:59:30.874]   - Field: ‘local’
[16:59:30.874]   - Field: ‘owner’
[16:59:30.874]   - Field: ‘envir’
[16:59:30.874]   - Field: ‘workers’
[16:59:30.875]   - Field: ‘packages’
[16:59:30.875]   - Field: ‘gc’
[16:59:30.875]   - Field: ‘job’
[16:59:30.875]   - Field: ‘conditions’
[16:59:30.875]   - Field: ‘expr’
[16:59:30.875]   - Field: ‘uuid’
[16:59:30.875]   - Field: ‘seed’
[16:59:30.875]   - Field: ‘version’
[16:59:30.875]   - Field: ‘result’
[16:59:30.875]   - Field: ‘asynchronous’
[16:59:30.876]   - Field: ‘calls’
[16:59:30.876]   - Field: ‘globals’
[16:59:30.876]   - Field: ‘stdout’
[16:59:30.876]   - Field: ‘earlySignal’
[16:59:30.876]   - Field: ‘lazy’
[16:59:30.876]   - Field: ‘state’
[16:59:30.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.876] - Launch lazy future ...
[16:59:30.877] Packages needed by the future expression (n = 0): <none>
[16:59:30.877] Packages needed by future strategies (n = 0): <none>
[16:59:30.877] {
[16:59:30.877]     {
[16:59:30.877]         {
[16:59:30.877]             ...future.startTime <- base::Sys.time()
[16:59:30.877]             {
[16:59:30.877]                 {
[16:59:30.877]                   {
[16:59:30.877]                     {
[16:59:30.877]                       base::local({
[16:59:30.877]                         has_future <- base::requireNamespace("future", 
[16:59:30.877]                           quietly = TRUE)
[16:59:30.877]                         if (has_future) {
[16:59:30.877]                           ns <- base::getNamespace("future")
[16:59:30.877]                           version <- ns[[".package"]][["version"]]
[16:59:30.877]                           if (is.null(version)) 
[16:59:30.877]                             version <- utils::packageVersion("future")
[16:59:30.877]                         }
[16:59:30.877]                         else {
[16:59:30.877]                           version <- NULL
[16:59:30.877]                         }
[16:59:30.877]                         if (!has_future || version < "1.8.0") {
[16:59:30.877]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.877]                             "", base::R.version$version.string), 
[16:59:30.877]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.877]                               "release", "version")], collapse = " "), 
[16:59:30.877]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.877]                             info)
[16:59:30.877]                           info <- base::paste(info, collapse = "; ")
[16:59:30.877]                           if (!has_future) {
[16:59:30.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.877]                               info)
[16:59:30.877]                           }
[16:59:30.877]                           else {
[16:59:30.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.877]                               info, version)
[16:59:30.877]                           }
[16:59:30.877]                           base::stop(msg)
[16:59:30.877]                         }
[16:59:30.877]                       })
[16:59:30.877]                     }
[16:59:30.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.877]                     base::options(mc.cores = 1L)
[16:59:30.877]                   }
[16:59:30.877]                   ...future.strategy.old <- future::plan("list")
[16:59:30.877]                   options(future.plan = NULL)
[16:59:30.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.877]                 }
[16:59:30.877]                 ...future.workdir <- getwd()
[16:59:30.877]             }
[16:59:30.877]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.877]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.877]         }
[16:59:30.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.877]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.877]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.877]             base::names(...future.oldOptions))
[16:59:30.877]     }
[16:59:30.877]     if (FALSE) {
[16:59:30.877]     }
[16:59:30.877]     else {
[16:59:30.877]         if (TRUE) {
[16:59:30.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.877]                 open = "w")
[16:59:30.877]         }
[16:59:30.877]         else {
[16:59:30.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.877]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.877]         }
[16:59:30.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.877]             base::sink(type = "output", split = FALSE)
[16:59:30.877]             base::close(...future.stdout)
[16:59:30.877]         }, add = TRUE)
[16:59:30.877]     }
[16:59:30.877]     ...future.frame <- base::sys.nframe()
[16:59:30.877]     ...future.conditions <- base::list()
[16:59:30.877]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.877]     if (FALSE) {
[16:59:30.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.877]     }
[16:59:30.877]     ...future.result <- base::tryCatch({
[16:59:30.877]         base::withCallingHandlers({
[16:59:30.877]             ...future.value <- base::withVisible(base::local({
[16:59:30.877]                 withCallingHandlers({
[16:59:30.877]                   {
[16:59:30.877]                     do.call(function(...) {
[16:59:30.877]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.877]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.877]                         ...future.globals.maxSize)) {
[16:59:30.877]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.877]                         on.exit(options(oopts), add = TRUE)
[16:59:30.877]                       }
[16:59:30.877]                       {
[16:59:30.877]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.877]                           FUN = function(jj) {
[16:59:30.877]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.877]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:30.877]                               envir = globalenv(), inherits = FALSE)
[16:59:30.877]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.877]                           })
[16:59:30.877]                       }
[16:59:30.877]                     }, args = future.call.arguments)
[16:59:30.877]                   }
[16:59:30.877]                 }, immediateCondition = function(cond) {
[16:59:30.877]                   save_rds <- function (object, pathname, ...) 
[16:59:30.877]                   {
[16:59:30.877]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.877]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.877]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.877]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.877]                         fi_tmp[["mtime"]])
[16:59:30.877]                     }
[16:59:30.877]                     tryCatch({
[16:59:30.877]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.877]                     }, error = function(ex) {
[16:59:30.877]                       msg <- conditionMessage(ex)
[16:59:30.877]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.877]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.877]                         fi_tmp[["mtime"]], msg)
[16:59:30.877]                       ex$message <- msg
[16:59:30.877]                       stop(ex)
[16:59:30.877]                     })
[16:59:30.877]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.877]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.877]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.877]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.877]                       fi <- file.info(pathname)
[16:59:30.877]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.877]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.877]                         fi[["size"]], fi[["mtime"]])
[16:59:30.877]                       stop(msg)
[16:59:30.877]                     }
[16:59:30.877]                     invisible(pathname)
[16:59:30.877]                   }
[16:59:30.877]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.877]                     rootPath = tempdir()) 
[16:59:30.877]                   {
[16:59:30.877]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.877]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.877]                       tmpdir = path, fileext = ".rds")
[16:59:30.877]                     save_rds(obj, file)
[16:59:30.877]                   }
[16:59:30.877]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.877]                   {
[16:59:30.877]                     inherits <- base::inherits
[16:59:30.877]                     invokeRestart <- base::invokeRestart
[16:59:30.877]                     is.null <- base::is.null
[16:59:30.877]                     muffled <- FALSE
[16:59:30.877]                     if (inherits(cond, "message")) {
[16:59:30.877]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.877]                       if (muffled) 
[16:59:30.877]                         invokeRestart("muffleMessage")
[16:59:30.877]                     }
[16:59:30.877]                     else if (inherits(cond, "warning")) {
[16:59:30.877]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.877]                       if (muffled) 
[16:59:30.877]                         invokeRestart("muffleWarning")
[16:59:30.877]                     }
[16:59:30.877]                     else if (inherits(cond, "condition")) {
[16:59:30.877]                       if (!is.null(pattern)) {
[16:59:30.877]                         computeRestarts <- base::computeRestarts
[16:59:30.877]                         grepl <- base::grepl
[16:59:30.877]                         restarts <- computeRestarts(cond)
[16:59:30.877]                         for (restart in restarts) {
[16:59:30.877]                           name <- restart$name
[16:59:30.877]                           if (is.null(name)) 
[16:59:30.877]                             next
[16:59:30.877]                           if (!grepl(pattern, name)) 
[16:59:30.877]                             next
[16:59:30.877]                           invokeRestart(restart)
[16:59:30.877]                           muffled <- TRUE
[16:59:30.877]                           break
[16:59:30.877]                         }
[16:59:30.877]                       }
[16:59:30.877]                     }
[16:59:30.877]                     invisible(muffled)
[16:59:30.877]                   }
[16:59:30.877]                   muffleCondition(cond)
[16:59:30.877]                 })
[16:59:30.877]             }))
[16:59:30.877]             future::FutureResult(value = ...future.value$value, 
[16:59:30.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.877]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.877]                     ...future.globalenv.names))
[16:59:30.877]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.877]         }, condition = base::local({
[16:59:30.877]             c <- base::c
[16:59:30.877]             inherits <- base::inherits
[16:59:30.877]             invokeRestart <- base::invokeRestart
[16:59:30.877]             length <- base::length
[16:59:30.877]             list <- base::list
[16:59:30.877]             seq.int <- base::seq.int
[16:59:30.877]             signalCondition <- base::signalCondition
[16:59:30.877]             sys.calls <- base::sys.calls
[16:59:30.877]             `[[` <- base::`[[`
[16:59:30.877]             `+` <- base::`+`
[16:59:30.877]             `<<-` <- base::`<<-`
[16:59:30.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.877]                   3L)]
[16:59:30.877]             }
[16:59:30.877]             function(cond) {
[16:59:30.877]                 is_error <- inherits(cond, "error")
[16:59:30.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.877]                   NULL)
[16:59:30.877]                 if (is_error) {
[16:59:30.877]                   sessionInformation <- function() {
[16:59:30.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.877]                       search = base::search(), system = base::Sys.info())
[16:59:30.877]                   }
[16:59:30.877]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.877]                     cond$call), session = sessionInformation(), 
[16:59:30.877]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.877]                   signalCondition(cond)
[16:59:30.877]                 }
[16:59:30.877]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:59:30.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.877]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.877]                   if (TRUE && !signal) {
[16:59:30.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.877]                     {
[16:59:30.877]                       inherits <- base::inherits
[16:59:30.877]                       invokeRestart <- base::invokeRestart
[16:59:30.877]                       is.null <- base::is.null
[16:59:30.877]                       muffled <- FALSE
[16:59:30.877]                       if (inherits(cond, "message")) {
[16:59:30.877]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.877]                         if (muffled) 
[16:59:30.877]                           invokeRestart("muffleMessage")
[16:59:30.877]                       }
[16:59:30.877]                       else if (inherits(cond, "warning")) {
[16:59:30.877]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.877]                         if (muffled) 
[16:59:30.877]                           invokeRestart("muffleWarning")
[16:59:30.877]                       }
[16:59:30.877]                       else if (inherits(cond, "condition")) {
[16:59:30.877]                         if (!is.null(pattern)) {
[16:59:30.877]                           computeRestarts <- base::computeRestarts
[16:59:30.877]                           grepl <- base::grepl
[16:59:30.877]                           restarts <- computeRestarts(cond)
[16:59:30.877]                           for (restart in restarts) {
[16:59:30.877]                             name <- restart$name
[16:59:30.877]                             if (is.null(name)) 
[16:59:30.877]                               next
[16:59:30.877]                             if (!grepl(pattern, name)) 
[16:59:30.877]                               next
[16:59:30.877]                             invokeRestart(restart)
[16:59:30.877]                             muffled <- TRUE
[16:59:30.877]                             break
[16:59:30.877]                           }
[16:59:30.877]                         }
[16:59:30.877]                       }
[16:59:30.877]                       invisible(muffled)
[16:59:30.877]                     }
[16:59:30.877]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.877]                   }
[16:59:30.877]                 }
[16:59:30.877]                 else {
[16:59:30.877]                   if (TRUE) {
[16:59:30.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.877]                     {
[16:59:30.877]                       inherits <- base::inherits
[16:59:30.877]                       invokeRestart <- base::invokeRestart
[16:59:30.877]                       is.null <- base::is.null
[16:59:30.877]                       muffled <- FALSE
[16:59:30.877]                       if (inherits(cond, "message")) {
[16:59:30.877]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.877]                         if (muffled) 
[16:59:30.877]                           invokeRestart("muffleMessage")
[16:59:30.877]                       }
[16:59:30.877]                       else if (inherits(cond, "warning")) {
[16:59:30.877]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.877]                         if (muffled) 
[16:59:30.877]                           invokeRestart("muffleWarning")
[16:59:30.877]                       }
[16:59:30.877]                       else if (inherits(cond, "condition")) {
[16:59:30.877]                         if (!is.null(pattern)) {
[16:59:30.877]                           computeRestarts <- base::computeRestarts
[16:59:30.877]                           grepl <- base::grepl
[16:59:30.877]                           restarts <- computeRestarts(cond)
[16:59:30.877]                           for (restart in restarts) {
[16:59:30.877]                             name <- restart$name
[16:59:30.877]                             if (is.null(name)) 
[16:59:30.877]                               next
[16:59:30.877]                             if (!grepl(pattern, name)) 
[16:59:30.877]                               next
[16:59:30.877]                             invokeRestart(restart)
[16:59:30.877]                             muffled <- TRUE
[16:59:30.877]                             break
[16:59:30.877]                           }
[16:59:30.877]                         }
[16:59:30.877]                       }
[16:59:30.877]                       invisible(muffled)
[16:59:30.877]                     }
[16:59:30.877]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.877]                   }
[16:59:30.877]                 }
[16:59:30.877]             }
[16:59:30.877]         }))
[16:59:30.877]     }, error = function(ex) {
[16:59:30.877]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.877]                 ...future.rng), started = ...future.startTime, 
[16:59:30.877]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.877]             version = "1.8"), class = "FutureResult")
[16:59:30.877]     }, finally = {
[16:59:30.877]         if (!identical(...future.workdir, getwd())) 
[16:59:30.877]             setwd(...future.workdir)
[16:59:30.877]         {
[16:59:30.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.877]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.877]             }
[16:59:30.877]             base::options(...future.oldOptions)
[16:59:30.877]             if (.Platform$OS.type == "windows") {
[16:59:30.877]                 old_names <- names(...future.oldEnvVars)
[16:59:30.877]                 envs <- base::Sys.getenv()
[16:59:30.877]                 names <- names(envs)
[16:59:30.877]                 common <- intersect(names, old_names)
[16:59:30.877]                 added <- setdiff(names, old_names)
[16:59:30.877]                 removed <- setdiff(old_names, names)
[16:59:30.877]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.877]                   envs[common]]
[16:59:30.877]                 NAMES <- toupper(changed)
[16:59:30.877]                 args <- list()
[16:59:30.877]                 for (kk in seq_along(NAMES)) {
[16:59:30.877]                   name <- changed[[kk]]
[16:59:30.877]                   NAME <- NAMES[[kk]]
[16:59:30.877]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.877]                     next
[16:59:30.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.877]                 }
[16:59:30.877]                 NAMES <- toupper(added)
[16:59:30.877]                 for (kk in seq_along(NAMES)) {
[16:59:30.877]                   name <- added[[kk]]
[16:59:30.877]                   NAME <- NAMES[[kk]]
[16:59:30.877]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.877]                     next
[16:59:30.877]                   args[[name]] <- ""
[16:59:30.877]                 }
[16:59:30.877]                 NAMES <- toupper(removed)
[16:59:30.877]                 for (kk in seq_along(NAMES)) {
[16:59:30.877]                   name <- removed[[kk]]
[16:59:30.877]                   NAME <- NAMES[[kk]]
[16:59:30.877]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.877]                     next
[16:59:30.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.877]                 }
[16:59:30.877]                 if (length(args) > 0) 
[16:59:30.877]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.877]             }
[16:59:30.877]             else {
[16:59:30.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.877]             }
[16:59:30.877]             {
[16:59:30.877]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.877]                   0L) {
[16:59:30.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.877]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.877]                   base::options(opts)
[16:59:30.877]                 }
[16:59:30.877]                 {
[16:59:30.877]                   {
[16:59:30.877]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.877]                     NULL
[16:59:30.877]                   }
[16:59:30.877]                   options(future.plan = NULL)
[16:59:30.877]                   if (is.na(NA_character_)) 
[16:59:30.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.877]                     .init = FALSE)
[16:59:30.877]                 }
[16:59:30.877]             }
[16:59:30.877]         }
[16:59:30.877]     })
[16:59:30.877]     if (TRUE) {
[16:59:30.877]         base::sink(type = "output", split = FALSE)
[16:59:30.877]         if (TRUE) {
[16:59:30.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.877]         }
[16:59:30.877]         else {
[16:59:30.877]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.877]         }
[16:59:30.877]         base::close(...future.stdout)
[16:59:30.877]         ...future.stdout <- NULL
[16:59:30.877]     }
[16:59:30.877]     ...future.result$conditions <- ...future.conditions
[16:59:30.877]     ...future.result$finished <- base::Sys.time()
[16:59:30.877]     ...future.result
[16:59:30.877] }
[16:59:30.880] assign_globals() ...
[16:59:30.880] List of 5
[16:59:30.880]  $ future.call.arguments    : list()
[16:59:30.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.880]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:59:30.880]  $ ...future.elements_ii    :List of 1
[16:59:30.880]   ..$ : int [1:2] 1 3
[16:59:30.880]  $ ...future.seeds_ii       :List of 1
[16:59:30.880]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[16:59:30.880]  $ ...future.globals.maxSize: num Inf
[16:59:30.880]  - attr(*, "resolved")= logi FALSE
[16:59:30.880]  - attr(*, "total_size")= num NA
[16:59:30.880]  - attr(*, "where")=List of 5
[16:59:30.880]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.880]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.880]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.880]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.880]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.880]  - attr(*, "already-done")= logi TRUE
[16:59:30.888] - copied ‘future.call.arguments’ to environment
[16:59:30.888] - copied ‘...future.FUN’ to environment
[16:59:30.888] - copied ‘...future.elements_ii’ to environment
[16:59:30.888] - copied ‘...future.seeds_ii’ to environment
[16:59:30.888] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.888] assign_globals() ... done
[16:59:30.889] requestCore(): workers = 2
[16:59:30.891] MulticoreFuture started
[16:59:30.892] - Launch lazy future ... done
[16:59:30.892] run() for ‘MulticoreFuture’ ... done
[16:59:30.892] plan(): Setting new future strategy stack:
[16:59:30.892] Created future:
[16:59:30.893] List of future strategies:
[16:59:30.893] 1. sequential:
[16:59:30.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.893]    - tweaked: FALSE
[16:59:30.893]    - call: NULL
[16:59:30.894] plan(): nbrOfWorkers() = 1
[16:59:30.896] plan(): Setting new future strategy stack:
[16:59:30.897] List of future strategies:
[16:59:30.897] 1. multicore:
[16:59:30.897]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.897]    - tweaked: FALSE
[16:59:30.897]    - call: plan(strategy)
[16:59:30.902] plan(): nbrOfWorkers() = 2
[16:59:30.893] MulticoreFuture:
[16:59:30.893] Label: ‘future_apply-1’
[16:59:30.893] Expression:
[16:59:30.893] {
[16:59:30.893]     do.call(function(...) {
[16:59:30.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.893]             on.exit(options(oopts), add = TRUE)
[16:59:30.893]         }
[16:59:30.893]         {
[16:59:30.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.893]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:30.893]                   envir = globalenv(), inherits = FALSE)
[16:59:30.893]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.893]             })
[16:59:30.893]         }
[16:59:30.893]     }, args = future.call.arguments)
[16:59:30.893] }
[16:59:30.893] Lazy evaluation: FALSE
[16:59:30.893] Asynchronous evaluation: TRUE
[16:59:30.893] Local evaluation: TRUE
[16:59:30.893] Environment: R_GlobalEnv
[16:59:30.893] Capture standard output: TRUE
[16:59:30.893] Capture condition classes: <none>
[16:59:30.893] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.893] Packages: <none>
[16:59:30.893] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:59:30.893] Resolved: TRUE
[16:59:30.893] Value: <not collected>
[16:59:30.893] Conditions captured: <none>
[16:59:30.893] Early signaling: FALSE
[16:59:30.893] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.893] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.904] Chunk #1 of 2 ... DONE
[16:59:30.904] Chunk #2 of 2 ...
[16:59:30.904]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:30.904]  - seeds: [1] <seeds>
[16:59:30.905]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.905] getGlobalsAndPackages() ...
[16:59:30.905] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.905] Resolving globals: FALSE
[16:59:30.905] Tweak future expression to call with '...' arguments ...
[16:59:30.906] {
[16:59:30.906]     do.call(function(...) {
[16:59:30.906]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.906]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.906]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.906]             on.exit(options(oopts), add = TRUE)
[16:59:30.906]         }
[16:59:30.906]         {
[16:59:30.906]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.906]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.906]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:30.906]                   envir = globalenv(), inherits = FALSE)
[16:59:30.906]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.906]             })
[16:59:30.906]         }
[16:59:30.906]     }, args = future.call.arguments)
[16:59:30.906] }
[16:59:30.906] Tweak future expression to call with '...' arguments ... DONE
[16:59:30.907] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:30.907] 
[16:59:30.907] getGlobalsAndPackages() ... DONE
[16:59:30.908] run() for ‘Future’ ...
[16:59:30.908] - state: ‘created’
[16:59:30.908] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:30.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:30.913]   - Field: ‘label’
[16:59:30.913]   - Field: ‘local’
[16:59:30.913]   - Field: ‘owner’
[16:59:30.913]   - Field: ‘envir’
[16:59:30.914]   - Field: ‘workers’
[16:59:30.914]   - Field: ‘packages’
[16:59:30.914]   - Field: ‘gc’
[16:59:30.914]   - Field: ‘job’
[16:59:30.914]   - Field: ‘conditions’
[16:59:30.914]   - Field: ‘expr’
[16:59:30.914]   - Field: ‘uuid’
[16:59:30.915]   - Field: ‘seed’
[16:59:30.915]   - Field: ‘version’
[16:59:30.915]   - Field: ‘result’
[16:59:30.915]   - Field: ‘asynchronous’
[16:59:30.915]   - Field: ‘calls’
[16:59:30.915]   - Field: ‘globals’
[16:59:30.915]   - Field: ‘stdout’
[16:59:30.916]   - Field: ‘earlySignal’
[16:59:30.916]   - Field: ‘lazy’
[16:59:30.916]   - Field: ‘state’
[16:59:30.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:30.916] - Launch lazy future ...
[16:59:30.917] Packages needed by the future expression (n = 0): <none>
[16:59:30.917] Packages needed by future strategies (n = 0): <none>
[16:59:30.918] {
[16:59:30.918]     {
[16:59:30.918]         {
[16:59:30.918]             ...future.startTime <- base::Sys.time()
[16:59:30.918]             {
[16:59:30.918]                 {
[16:59:30.918]                   {
[16:59:30.918]                     {
[16:59:30.918]                       base::local({
[16:59:30.918]                         has_future <- base::requireNamespace("future", 
[16:59:30.918]                           quietly = TRUE)
[16:59:30.918]                         if (has_future) {
[16:59:30.918]                           ns <- base::getNamespace("future")
[16:59:30.918]                           version <- ns[[".package"]][["version"]]
[16:59:30.918]                           if (is.null(version)) 
[16:59:30.918]                             version <- utils::packageVersion("future")
[16:59:30.918]                         }
[16:59:30.918]                         else {
[16:59:30.918]                           version <- NULL
[16:59:30.918]                         }
[16:59:30.918]                         if (!has_future || version < "1.8.0") {
[16:59:30.918]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:30.918]                             "", base::R.version$version.string), 
[16:59:30.918]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:30.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:30.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:30.918]                               "release", "version")], collapse = " "), 
[16:59:30.918]                             hostname = base::Sys.info()[["nodename"]])
[16:59:30.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:30.918]                             info)
[16:59:30.918]                           info <- base::paste(info, collapse = "; ")
[16:59:30.918]                           if (!has_future) {
[16:59:30.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:30.918]                               info)
[16:59:30.918]                           }
[16:59:30.918]                           else {
[16:59:30.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:30.918]                               info, version)
[16:59:30.918]                           }
[16:59:30.918]                           base::stop(msg)
[16:59:30.918]                         }
[16:59:30.918]                       })
[16:59:30.918]                     }
[16:59:30.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:30.918]                     base::options(mc.cores = 1L)
[16:59:30.918]                   }
[16:59:30.918]                   ...future.strategy.old <- future::plan("list")
[16:59:30.918]                   options(future.plan = NULL)
[16:59:30.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:30.918]                 }
[16:59:30.918]                 ...future.workdir <- getwd()
[16:59:30.918]             }
[16:59:30.918]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:30.918]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:30.918]         }
[16:59:30.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:30.918]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:30.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:30.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:30.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:30.918]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:30.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:30.918]             base::names(...future.oldOptions))
[16:59:30.918]     }
[16:59:30.918]     if (FALSE) {
[16:59:30.918]     }
[16:59:30.918]     else {
[16:59:30.918]         if (TRUE) {
[16:59:30.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:30.918]                 open = "w")
[16:59:30.918]         }
[16:59:30.918]         else {
[16:59:30.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:30.918]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:30.918]         }
[16:59:30.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:30.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:30.918]             base::sink(type = "output", split = FALSE)
[16:59:30.918]             base::close(...future.stdout)
[16:59:30.918]         }, add = TRUE)
[16:59:30.918]     }
[16:59:30.918]     ...future.frame <- base::sys.nframe()
[16:59:30.918]     ...future.conditions <- base::list()
[16:59:30.918]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:30.918]     if (FALSE) {
[16:59:30.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:30.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:30.918]     }
[16:59:30.918]     ...future.result <- base::tryCatch({
[16:59:30.918]         base::withCallingHandlers({
[16:59:30.918]             ...future.value <- base::withVisible(base::local({
[16:59:30.918]                 withCallingHandlers({
[16:59:30.918]                   {
[16:59:30.918]                     do.call(function(...) {
[16:59:30.918]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.918]                       if (!identical(...future.globals.maxSize.org, 
[16:59:30.918]                         ...future.globals.maxSize)) {
[16:59:30.918]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.918]                         on.exit(options(oopts), add = TRUE)
[16:59:30.918]                       }
[16:59:30.918]                       {
[16:59:30.918]                         lapply(seq_along(...future.elements_ii), 
[16:59:30.918]                           FUN = function(jj) {
[16:59:30.918]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.918]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:30.918]                               envir = globalenv(), inherits = FALSE)
[16:59:30.918]                             ...future.FUN(...future.X_jj, ...)
[16:59:30.918]                           })
[16:59:30.918]                       }
[16:59:30.918]                     }, args = future.call.arguments)
[16:59:30.918]                   }
[16:59:30.918]                 }, immediateCondition = function(cond) {
[16:59:30.918]                   save_rds <- function (object, pathname, ...) 
[16:59:30.918]                   {
[16:59:30.918]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:30.918]                     if (file_test("-f", pathname_tmp)) {
[16:59:30.918]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.918]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:30.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.918]                         fi_tmp[["mtime"]])
[16:59:30.918]                     }
[16:59:30.918]                     tryCatch({
[16:59:30.918]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:30.918]                     }, error = function(ex) {
[16:59:30.918]                       msg <- conditionMessage(ex)
[16:59:30.918]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.918]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:30.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.918]                         fi_tmp[["mtime"]], msg)
[16:59:30.918]                       ex$message <- msg
[16:59:30.918]                       stop(ex)
[16:59:30.918]                     })
[16:59:30.918]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:30.918]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:30.918]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:30.918]                       fi_tmp <- file.info(pathname_tmp)
[16:59:30.918]                       fi <- file.info(pathname)
[16:59:30.918]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:30.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:30.918]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:30.918]                         fi[["size"]], fi[["mtime"]])
[16:59:30.918]                       stop(msg)
[16:59:30.918]                     }
[16:59:30.918]                     invisible(pathname)
[16:59:30.918]                   }
[16:59:30.918]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:30.918]                     rootPath = tempdir()) 
[16:59:30.918]                   {
[16:59:30.918]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:30.918]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:30.918]                       tmpdir = path, fileext = ".rds")
[16:59:30.918]                     save_rds(obj, file)
[16:59:30.918]                   }
[16:59:30.918]                   saveImmediateCondition(cond, path = "/tmp/RtmpKOVFz9/.future/immediateConditions")
[16:59:30.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.918]                   {
[16:59:30.918]                     inherits <- base::inherits
[16:59:30.918]                     invokeRestart <- base::invokeRestart
[16:59:30.918]                     is.null <- base::is.null
[16:59:30.918]                     muffled <- FALSE
[16:59:30.918]                     if (inherits(cond, "message")) {
[16:59:30.918]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:30.918]                       if (muffled) 
[16:59:30.918]                         invokeRestart("muffleMessage")
[16:59:30.918]                     }
[16:59:30.918]                     else if (inherits(cond, "warning")) {
[16:59:30.918]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:30.918]                       if (muffled) 
[16:59:30.918]                         invokeRestart("muffleWarning")
[16:59:30.918]                     }
[16:59:30.918]                     else if (inherits(cond, "condition")) {
[16:59:30.918]                       if (!is.null(pattern)) {
[16:59:30.918]                         computeRestarts <- base::computeRestarts
[16:59:30.918]                         grepl <- base::grepl
[16:59:30.918]                         restarts <- computeRestarts(cond)
[16:59:30.918]                         for (restart in restarts) {
[16:59:30.918]                           name <- restart$name
[16:59:30.918]                           if (is.null(name)) 
[16:59:30.918]                             next
[16:59:30.918]                           if (!grepl(pattern, name)) 
[16:59:30.918]                             next
[16:59:30.918]                           invokeRestart(restart)
[16:59:30.918]                           muffled <- TRUE
[16:59:30.918]                           break
[16:59:30.918]                         }
[16:59:30.918]                       }
[16:59:30.918]                     }
[16:59:30.918]                     invisible(muffled)
[16:59:30.918]                   }
[16:59:30.918]                   muffleCondition(cond)
[16:59:30.918]                 })
[16:59:30.918]             }))
[16:59:30.918]             future::FutureResult(value = ...future.value$value, 
[16:59:30.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.918]                   ...future.rng), globalenv = if (FALSE) 
[16:59:30.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:30.918]                     ...future.globalenv.names))
[16:59:30.918]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:30.918]         }, condition = base::local({
[16:59:30.918]             c <- base::c
[16:59:30.918]             inherits <- base::inherits
[16:59:30.918]             invokeRestart <- base::invokeRestart
[16:59:30.918]             length <- base::length
[16:59:30.918]             list <- base::list
[16:59:30.918]             seq.int <- base::seq.int
[16:59:30.918]             signalCondition <- base::signalCondition
[16:59:30.918]             sys.calls <- base::sys.calls
[16:59:30.918]             `[[` <- base::`[[`
[16:59:30.918]             `+` <- base::`+`
[16:59:30.918]             `<<-` <- base::`<<-`
[16:59:30.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:30.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:30.918]                   3L)]
[16:59:30.918]             }
[16:59:30.918]             function(cond) {
[16:59:30.918]                 is_error <- inherits(cond, "error")
[16:59:30.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:30.918]                   NULL)
[16:59:30.918]                 if (is_error) {
[16:59:30.918]                   sessionInformation <- function() {
[16:59:30.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:30.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:30.918]                       search = base::search(), system = base::Sys.info())
[16:59:30.918]                   }
[16:59:30.918]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:30.918]                     cond$call), session = sessionInformation(), 
[16:59:30.918]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:30.918]                   signalCondition(cond)
[16:59:30.918]                 }
[16:59:30.918]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:59:30.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:30.918]                   ...future.conditions[[length(...future.conditions) + 
[16:59:30.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:30.918]                   if (TRUE && !signal) {
[16:59:30.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.918]                     {
[16:59:30.918]                       inherits <- base::inherits
[16:59:30.918]                       invokeRestart <- base::invokeRestart
[16:59:30.918]                       is.null <- base::is.null
[16:59:30.918]                       muffled <- FALSE
[16:59:30.918]                       if (inherits(cond, "message")) {
[16:59:30.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.918]                         if (muffled) 
[16:59:30.918]                           invokeRestart("muffleMessage")
[16:59:30.918]                       }
[16:59:30.918]                       else if (inherits(cond, "warning")) {
[16:59:30.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.918]                         if (muffled) 
[16:59:30.918]                           invokeRestart("muffleWarning")
[16:59:30.918]                       }
[16:59:30.918]                       else if (inherits(cond, "condition")) {
[16:59:30.918]                         if (!is.null(pattern)) {
[16:59:30.918]                           computeRestarts <- base::computeRestarts
[16:59:30.918]                           grepl <- base::grepl
[16:59:30.918]                           restarts <- computeRestarts(cond)
[16:59:30.918]                           for (restart in restarts) {
[16:59:30.918]                             name <- restart$name
[16:59:30.918]                             if (is.null(name)) 
[16:59:30.918]                               next
[16:59:30.918]                             if (!grepl(pattern, name)) 
[16:59:30.918]                               next
[16:59:30.918]                             invokeRestart(restart)
[16:59:30.918]                             muffled <- TRUE
[16:59:30.918]                             break
[16:59:30.918]                           }
[16:59:30.918]                         }
[16:59:30.918]                       }
[16:59:30.918]                       invisible(muffled)
[16:59:30.918]                     }
[16:59:30.918]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.918]                   }
[16:59:30.918]                 }
[16:59:30.918]                 else {
[16:59:30.918]                   if (TRUE) {
[16:59:30.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:30.918]                     {
[16:59:30.918]                       inherits <- base::inherits
[16:59:30.918]                       invokeRestart <- base::invokeRestart
[16:59:30.918]                       is.null <- base::is.null
[16:59:30.918]                       muffled <- FALSE
[16:59:30.918]                       if (inherits(cond, "message")) {
[16:59:30.918]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:30.918]                         if (muffled) 
[16:59:30.918]                           invokeRestart("muffleMessage")
[16:59:30.918]                       }
[16:59:30.918]                       else if (inherits(cond, "warning")) {
[16:59:30.918]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:30.918]                         if (muffled) 
[16:59:30.918]                           invokeRestart("muffleWarning")
[16:59:30.918]                       }
[16:59:30.918]                       else if (inherits(cond, "condition")) {
[16:59:30.918]                         if (!is.null(pattern)) {
[16:59:30.918]                           computeRestarts <- base::computeRestarts
[16:59:30.918]                           grepl <- base::grepl
[16:59:30.918]                           restarts <- computeRestarts(cond)
[16:59:30.918]                           for (restart in restarts) {
[16:59:30.918]                             name <- restart$name
[16:59:30.918]                             if (is.null(name)) 
[16:59:30.918]                               next
[16:59:30.918]                             if (!grepl(pattern, name)) 
[16:59:30.918]                               next
[16:59:30.918]                             invokeRestart(restart)
[16:59:30.918]                             muffled <- TRUE
[16:59:30.918]                             break
[16:59:30.918]                           }
[16:59:30.918]                         }
[16:59:30.918]                       }
[16:59:30.918]                       invisible(muffled)
[16:59:30.918]                     }
[16:59:30.918]                     muffleCondition(cond, pattern = "^muffle")
[16:59:30.918]                   }
[16:59:30.918]                 }
[16:59:30.918]             }
[16:59:30.918]         }))
[16:59:30.918]     }, error = function(ex) {
[16:59:30.918]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:30.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:30.918]                 ...future.rng), started = ...future.startTime, 
[16:59:30.918]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:30.918]             version = "1.8"), class = "FutureResult")
[16:59:30.918]     }, finally = {
[16:59:30.918]         if (!identical(...future.workdir, getwd())) 
[16:59:30.918]             setwd(...future.workdir)
[16:59:30.918]         {
[16:59:30.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:30.918]                 ...future.oldOptions$nwarnings <- NULL
[16:59:30.918]             }
[16:59:30.918]             base::options(...future.oldOptions)
[16:59:30.918]             if (.Platform$OS.type == "windows") {
[16:59:30.918]                 old_names <- names(...future.oldEnvVars)
[16:59:30.918]                 envs <- base::Sys.getenv()
[16:59:30.918]                 names <- names(envs)
[16:59:30.918]                 common <- intersect(names, old_names)
[16:59:30.918]                 added <- setdiff(names, old_names)
[16:59:30.918]                 removed <- setdiff(old_names, names)
[16:59:30.918]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:30.918]                   envs[common]]
[16:59:30.918]                 NAMES <- toupper(changed)
[16:59:30.918]                 args <- list()
[16:59:30.918]                 for (kk in seq_along(NAMES)) {
[16:59:30.918]                   name <- changed[[kk]]
[16:59:30.918]                   NAME <- NAMES[[kk]]
[16:59:30.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.918]                     next
[16:59:30.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.918]                 }
[16:59:30.918]                 NAMES <- toupper(added)
[16:59:30.918]                 for (kk in seq_along(NAMES)) {
[16:59:30.918]                   name <- added[[kk]]
[16:59:30.918]                   NAME <- NAMES[[kk]]
[16:59:30.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.918]                     next
[16:59:30.918]                   args[[name]] <- ""
[16:59:30.918]                 }
[16:59:30.918]                 NAMES <- toupper(removed)
[16:59:30.918]                 for (kk in seq_along(NAMES)) {
[16:59:30.918]                   name <- removed[[kk]]
[16:59:30.918]                   NAME <- NAMES[[kk]]
[16:59:30.918]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:30.918]                     next
[16:59:30.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:30.918]                 }
[16:59:30.918]                 if (length(args) > 0) 
[16:59:30.918]                   base::do.call(base::Sys.setenv, args = args)
[16:59:30.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:30.918]             }
[16:59:30.918]             else {
[16:59:30.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:30.918]             }
[16:59:30.918]             {
[16:59:30.918]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:30.918]                   0L) {
[16:59:30.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:30.918]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:30.918]                   base::options(opts)
[16:59:30.918]                 }
[16:59:30.918]                 {
[16:59:30.918]                   {
[16:59:30.918]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:30.918]                     NULL
[16:59:30.918]                   }
[16:59:30.918]                   options(future.plan = NULL)
[16:59:30.918]                   if (is.na(NA_character_)) 
[16:59:30.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:30.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:30.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:30.918]                     .init = FALSE)
[16:59:30.918]                 }
[16:59:30.918]             }
[16:59:30.918]         }
[16:59:30.918]     })
[16:59:30.918]     if (TRUE) {
[16:59:30.918]         base::sink(type = "output", split = FALSE)
[16:59:30.918]         if (TRUE) {
[16:59:30.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:30.918]         }
[16:59:30.918]         else {
[16:59:30.918]             ...future.result["stdout"] <- base::list(NULL)
[16:59:30.918]         }
[16:59:30.918]         base::close(...future.stdout)
[16:59:30.918]         ...future.stdout <- NULL
[16:59:30.918]     }
[16:59:30.918]     ...future.result$conditions <- ...future.conditions
[16:59:30.918]     ...future.result$finished <- base::Sys.time()
[16:59:30.918]     ...future.result
[16:59:30.918] }
[16:59:30.921] assign_globals() ...
[16:59:30.921] List of 5
[16:59:30.921]  $ future.call.arguments    : list()
[16:59:30.921]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:30.921]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[16:59:30.921]  $ ...future.elements_ii    :List of 1
[16:59:30.921]   ..$ : int [1:2] 2 4
[16:59:30.921]  $ ...future.seeds_ii       :List of 1
[16:59:30.921]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[16:59:30.921]  $ ...future.globals.maxSize: num Inf
[16:59:30.921]  - attr(*, "resolved")= logi FALSE
[16:59:30.921]  - attr(*, "total_size")= num NA
[16:59:30.921]  - attr(*, "where")=List of 5
[16:59:30.921]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:30.921]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:30.921]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:30.921]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:30.921]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:30.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:30.921]  - attr(*, "already-done")= logi TRUE
[16:59:30.929] - copied ‘future.call.arguments’ to environment
[16:59:30.930] - copied ‘...future.FUN’ to environment
[16:59:30.930] - copied ‘...future.elements_ii’ to environment
[16:59:30.930] - copied ‘...future.seeds_ii’ to environment
[16:59:30.930] - copied ‘...future.globals.maxSize’ to environment
[16:59:30.930] assign_globals() ... done
[16:59:30.930] requestCore(): workers = 2
[16:59:30.933] MulticoreFuture started
[16:59:30.933] - Launch lazy future ... done
[16:59:30.933] run() for ‘MulticoreFuture’ ... done
[16:59:30.934] Created future:
[16:59:30.934] plan(): Setting new future strategy stack:
[16:59:30.934] List of future strategies:
[16:59:30.934] 1. sequential:
[16:59:30.934]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.934]    - tweaked: FALSE
[16:59:30.934]    - call: NULL
[16:59:30.935] plan(): nbrOfWorkers() = 1
[16:59:30.937] plan(): Setting new future strategy stack:
[16:59:30.937] List of future strategies:
[16:59:30.937] 1. multicore:
[16:59:30.937]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:30.937]    - tweaked: FALSE
[16:59:30.937]    - call: plan(strategy)
[16:59:30.934] MulticoreFuture:
[16:59:30.934] Label: ‘future_apply-2’
[16:59:30.934] Expression:
[16:59:30.934] {
[16:59:30.934]     do.call(function(...) {
[16:59:30.934]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:30.934]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:30.934]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:30.934]             on.exit(options(oopts), add = TRUE)
[16:59:30.934]         }
[16:59:30.934]         {
[16:59:30.934]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:30.934]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:30.934]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:30.934]                   envir = globalenv(), inherits = FALSE)
[16:59:30.934]                 ...future.FUN(...future.X_jj, ...)
[16:59:30.934]             })
[16:59:30.934]         }
[16:59:30.934]     }, args = future.call.arguments)
[16:59:30.934] }
[16:59:30.934] Lazy evaluation: FALSE
[16:59:30.934] Asynchronous evaluation: TRUE
[16:59:30.934] Local evaluation: TRUE
[16:59:30.934] Environment: R_GlobalEnv
[16:59:30.934] Capture standard output: TRUE
[16:59:30.934] Capture condition classes: <none>
[16:59:30.934] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:30.934] Packages: <none>
[16:59:30.934] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:59:30.934] Resolved: FALSE
[16:59:30.934] Value: <not collected>
[16:59:30.934] Conditions captured: <none>
[16:59:30.934] Early signaling: FALSE
[16:59:30.934] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:30.934] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:30.947] Chunk #2 of 2 ... DONE
[16:59:30.947] Launching 2 futures (chunks) ... DONE
[16:59:30.947] Resolving 2 futures (chunks) ...
[16:59:30.948] resolve() on list ...
[16:59:30.948]  recursive: 0
[16:59:30.948]  length: 2
[16:59:30.948] 
[16:59:30.948] Future #1
[16:59:30.948] plan(): nbrOfWorkers() = 2
[16:59:30.949] result() for MulticoreFuture ...
[16:59:30.952] result() for MulticoreFuture ...
[16:59:30.953] result() for MulticoreFuture ... done
[16:59:30.953] result() for MulticoreFuture ... done
[16:59:30.953] result() for MulticoreFuture ...
[16:59:30.954] result() for MulticoreFuture ... done
[16:59:30.954] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:30.955] - nx: 2
[16:59:30.955] - relay: TRUE
[16:59:30.955] - stdout: TRUE
[16:59:30.956] - signal: TRUE
[16:59:30.956] - resignal: FALSE
[16:59:30.956] - force: TRUE
[16:59:30.956] - relayed: [n=2] FALSE, FALSE
[16:59:30.957] - queued futures: [n=2] FALSE, FALSE
[16:59:30.957]  - until=1
[16:59:30.957]  - relaying element #1
[16:59:30.958] result() for MulticoreFuture ...
[16:59:30.958] result() for MulticoreFuture ... done
[16:59:30.958] result() for MulticoreFuture ...
[16:59:30.959] result() for MulticoreFuture ... done
[16:59:30.959] result() for MulticoreFuture ...
[16:59:30.959] result() for MulticoreFuture ... done
[16:59:30.959] result() for MulticoreFuture ...
[16:59:30.960] result() for MulticoreFuture ... done
[16:59:30.960] - relayed: [n=2] TRUE, FALSE
[16:59:30.960] - queued futures: [n=2] TRUE, FALSE
[16:59:30.960] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:30.960]  length: 1 (resolved future 1)
[16:59:30.961] Future #2
[16:59:30.961] result() for MulticoreFuture ...
[16:59:30.962] result() for MulticoreFuture ...
[16:59:30.962] result() for MulticoreFuture ... done
[16:59:30.962] result() for MulticoreFuture ... done
[16:59:30.962] result() for MulticoreFuture ...
[16:59:30.962] result() for MulticoreFuture ... done
[16:59:30.963] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:30.963] - nx: 2
[16:59:30.963] - relay: TRUE
[16:59:30.963] - stdout: TRUE
[16:59:30.963] - signal: TRUE
[16:59:30.963] - resignal: FALSE
[16:59:30.963] - force: TRUE
[16:59:30.964] - relayed: [n=2] TRUE, FALSE
[16:59:30.964] - queued futures: [n=2] TRUE, FALSE
[16:59:30.964]  - until=2
[16:59:30.964]  - relaying element #2
[16:59:30.964] result() for MulticoreFuture ...
[16:59:30.964] result() for MulticoreFuture ... done
[16:59:30.964] result() for MulticoreFuture ...
[16:59:30.964] result() for MulticoreFuture ... done
[16:59:30.965] result() for MulticoreFuture ...
[16:59:30.965] result() for MulticoreFuture ... done
[16:59:30.965] result() for MulticoreFuture ...
[16:59:30.965] result() for MulticoreFuture ... done
[16:59:30.965] - relayed: [n=2] TRUE, TRUE
[16:59:30.965] - queued futures: [n=2] TRUE, TRUE
[16:59:30.965] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:30.965]  length: 0 (resolved future 2)
[16:59:30.965] Relaying remaining futures
[16:59:30.966] signalConditionsASAP(NULL, pos=0) ...
[16:59:30.966] - nx: 2
[16:59:30.966] - relay: TRUE
[16:59:30.966] - stdout: TRUE
[16:59:30.966] - signal: TRUE
[16:59:30.966] - resignal: FALSE
[16:59:30.966] - force: TRUE
[16:59:30.966] - relayed: [n=2] TRUE, TRUE
[16:59:30.966] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:30.967] - relayed: [n=2] TRUE, TRUE
[16:59:30.967] - queued futures: [n=2] TRUE, TRUE
[16:59:30.967] signalConditionsASAP(NULL, pos=0) ... done
[16:59:30.967] resolve() on list ... DONE
[16:59:30.967] result() for MulticoreFuture ...
[16:59:30.967] result() for MulticoreFuture ... done
[16:59:30.967] result() for MulticoreFuture ...
[16:59:30.968] result() for MulticoreFuture ... done
[16:59:30.968] result() for MulticoreFuture ...
[16:59:30.968] result() for MulticoreFuture ... done
[16:59:30.968] result() for MulticoreFuture ...
[16:59:30.968] result() for MulticoreFuture ... done
[16:59:30.968]  - Number of value chunks collected: 2
[16:59:30.968] Resolving 2 futures (chunks) ... DONE
[16:59:30.968] Reducing values from 2 chunks ...
[16:59:30.968]  - Number of values collected after concatenation: 2
[16:59:30.969]  - Number of values expected: 2
[16:59:30.969] Reducing values from 2 chunks ... DONE
[16:59:30.969] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:59:30.969] plan(): Setting new future strategy stack:
[16:59:30.969] List of future strategies:
[16:59:30.969] 1. sequential:
[16:59:30.969]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:30.969]    - tweaked: FALSE
[16:59:30.969]    - call: plan(sequential)
[16:59:30.970] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[16:59:30.970] plan(): Setting new future strategy stack:
[16:59:30.970] List of future strategies:
[16:59:30.970] 1. multisession:
[16:59:30.970]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:30.970]    - tweaked: FALSE
[16:59:30.970]    - call: plan(strategy)
[16:59:30.971] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:59:30.971] multisession:
[16:59:30.971] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:30.971] - tweaked: FALSE
[16:59:30.971] - call: plan(strategy)
[16:59:30.978] getGlobalsAndPackages() ...
[16:59:30.978] Not searching for globals
[16:59:30.978] - globals: [0] <none>
[16:59:30.978] getGlobalsAndPackages() ... DONE
[16:59:30.979] [local output] makeClusterPSOCK() ...
[16:59:31.028] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:59:31.029] [local output] Base port: 11550
[16:59:31.030] [local output] Getting setup options for 2 cluster nodes ...
[16:59:31.030] [local output]  - Node 1 of 2 ...
[16:59:31.030] [local output] localMachine=TRUE => revtunnel=FALSE

[16:59:31.031] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKOVFz9/worker.rank=1.parallelly.parent=28367.6ecf4aef037c.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpKOVFz9/worker.rank=1.parallelly.parent=28367.6ecf4aef037c.pid")'’
[16:59:31.224] - Possible to infer worker's PID: TRUE
[16:59:31.225] [local output] Rscript port: 11550

[16:59:31.225] [local output]  - Node 2 of 2 ...
[16:59:31.225] [local output] localMachine=TRUE => revtunnel=FALSE

[16:59:31.226] [local output] Rscript port: 11550

[16:59:31.226] [local output] Getting setup options for 2 cluster nodes ... done
[16:59:31.226] [local output]  - Parallel setup requested for some PSOCK nodes
[16:59:31.227] [local output] Setting up PSOCK nodes in parallel
[16:59:31.227] List of 36
[16:59:31.227]  $ worker          : chr "localhost"
[16:59:31.227]   ..- attr(*, "localhost")= logi TRUE
[16:59:31.227]  $ master          : chr "localhost"
[16:59:31.227]  $ port            : int 11550
[16:59:31.227]  $ connectTimeout  : num 120
[16:59:31.227]  $ timeout         : num 2592000
[16:59:31.227]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:59:31.227]  $ homogeneous     : logi TRUE
[16:59:31.227]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:59:31.227]  $ rscript_envs    : NULL
[16:59:31.227]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:59:31.227]  $ rscript_startup : NULL
[16:59:31.227]  $ rscript_sh      : chr "sh"
[16:59:31.227]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:59:31.227]  $ methods         : logi TRUE
[16:59:31.227]  $ socketOptions   : chr "no-delay"
[16:59:31.227]  $ useXDR          : logi FALSE
[16:59:31.227]  $ outfile         : chr "/dev/null"
[16:59:31.227]  $ renice          : int NA
[16:59:31.227]  $ rshcmd          : NULL
[16:59:31.227]  $ user            : chr(0) 
[16:59:31.227]  $ revtunnel       : logi FALSE
[16:59:31.227]  $ rshlogfile      : NULL
[16:59:31.227]  $ rshopts         : chr(0) 
[16:59:31.227]  $ rank            : int 1
[16:59:31.227]  $ manual          : logi FALSE
[16:59:31.227]  $ dryrun          : logi FALSE
[16:59:31.227]  $ quiet           : logi FALSE
[16:59:31.227]  $ setup_strategy  : chr "parallel"
[16:59:31.227]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:59:31.227]  $ pidfile         : chr "/tmp/RtmpKOVFz9/worker.rank=1.parallelly.parent=28367.6ecf4aef037c.pid"
[16:59:31.227]  $ rshcmd_label    : NULL
[16:59:31.227]  $ rsh_call        : NULL
[16:59:31.227]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:59:31.227]  $ localMachine    : logi TRUE
[16:59:31.227]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:59:31.227]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:59:31.227]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:59:31.227]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:59:31.227]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:59:31.227]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:59:31.227]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:59:31.227]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:59:31.227]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:59:31.227]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:59:31.227]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:59:31.227]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:59:31.227]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:59:31.227]  $ arguments       :List of 28
[16:59:31.227]   ..$ worker          : chr "localhost"
[16:59:31.227]   ..$ master          : NULL
[16:59:31.227]   ..$ port            : int 11550
[16:59:31.227]   ..$ connectTimeout  : num 120
[16:59:31.227]   ..$ timeout         : num 2592000
[16:59:31.227]   ..$ rscript         : NULL
[16:59:31.227]   ..$ homogeneous     : NULL
[16:59:31.227]   ..$ rscript_args    : NULL
[16:59:31.227]   ..$ rscript_envs    : NULL
[16:59:31.227]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:59:31.227]   ..$ rscript_startup : NULL
[16:59:31.227]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:59:31.227]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:59:31.227]   ..$ methods         : logi TRUE
[16:59:31.227]   ..$ socketOptions   : chr "no-delay"
[16:59:31.227]   ..$ useXDR          : logi FALSE
[16:59:31.227]   ..$ outfile         : chr "/dev/null"
[16:59:31.227]   ..$ renice          : int NA
[16:59:31.227]   ..$ rshcmd          : NULL
[16:59:31.227]   ..$ user            : NULL
[16:59:31.227]   ..$ revtunnel       : logi NA
[16:59:31.227]   ..$ rshlogfile      : NULL
[16:59:31.227]   ..$ rshopts         : NULL
[16:59:31.227]   ..$ rank            : int 1
[16:59:31.227]   ..$ manual          : logi FALSE
[16:59:31.227]   ..$ dryrun          : logi FALSE
[16:59:31.227]   ..$ quiet           : logi FALSE
[16:59:31.227]   ..$ setup_strategy  : chr "parallel"
[16:59:31.227]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:59:31.244] [local output] System call to launch all workers:
[16:59:31.244] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpKOVFz9/worker.rank=1.parallelly.parent=28367.6ecf4aef037c.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11550 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:59:31.244] [local output] Starting PSOCK main server
[16:59:31.251] [local output] Workers launched
[16:59:31.251] [local output] Waiting for workers to connect back
[16:59:31.251]  - [local output] 0 workers out of 2 ready
[16:59:31.518]  - [local output] 0 workers out of 2 ready
[16:59:31.519]  - [local output] 0 workers out of 2 ready
[16:59:31.519]  - [local output] 1 workers out of 2 ready
[16:59:31.519]  - [local output] 2 workers out of 2 ready
[16:59:31.520] [local output] Launching of workers completed
[16:59:31.520] [local output] Collecting session information from workers
[16:59:31.520] [local output]  - Worker #1 of 2
[16:59:31.521] [local output]  - Worker #2 of 2
[16:59:31.521] [local output] makeClusterPSOCK() ... done
[16:59:31.533] Packages needed by the future expression (n = 0): <none>
[16:59:31.533] Packages needed by future strategies (n = 0): <none>
[16:59:31.533] {
[16:59:31.533]     {
[16:59:31.533]         {
[16:59:31.533]             ...future.startTime <- base::Sys.time()
[16:59:31.533]             {
[16:59:31.533]                 {
[16:59:31.533]                   {
[16:59:31.533]                     {
[16:59:31.533]                       base::local({
[16:59:31.533]                         has_future <- base::requireNamespace("future", 
[16:59:31.533]                           quietly = TRUE)
[16:59:31.533]                         if (has_future) {
[16:59:31.533]                           ns <- base::getNamespace("future")
[16:59:31.533]                           version <- ns[[".package"]][["version"]]
[16:59:31.533]                           if (is.null(version)) 
[16:59:31.533]                             version <- utils::packageVersion("future")
[16:59:31.533]                         }
[16:59:31.533]                         else {
[16:59:31.533]                           version <- NULL
[16:59:31.533]                         }
[16:59:31.533]                         if (!has_future || version < "1.8.0") {
[16:59:31.533]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:31.533]                             "", base::R.version$version.string), 
[16:59:31.533]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:31.533]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:31.533]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:31.533]                               "release", "version")], collapse = " "), 
[16:59:31.533]                             hostname = base::Sys.info()[["nodename"]])
[16:59:31.533]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:31.533]                             info)
[16:59:31.533]                           info <- base::paste(info, collapse = "; ")
[16:59:31.533]                           if (!has_future) {
[16:59:31.533]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:31.533]                               info)
[16:59:31.533]                           }
[16:59:31.533]                           else {
[16:59:31.533]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:31.533]                               info, version)
[16:59:31.533]                           }
[16:59:31.533]                           base::stop(msg)
[16:59:31.533]                         }
[16:59:31.533]                       })
[16:59:31.533]                     }
[16:59:31.533]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:31.533]                     base::options(mc.cores = 1L)
[16:59:31.533]                   }
[16:59:31.533]                   ...future.strategy.old <- future::plan("list")
[16:59:31.533]                   options(future.plan = NULL)
[16:59:31.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:31.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:31.533]                 }
[16:59:31.533]                 ...future.workdir <- getwd()
[16:59:31.533]             }
[16:59:31.533]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:31.533]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:31.533]         }
[16:59:31.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:31.533]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:31.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:31.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:31.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:31.533]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:31.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:31.533]             base::names(...future.oldOptions))
[16:59:31.533]     }
[16:59:31.533]     if (FALSE) {
[16:59:31.533]     }
[16:59:31.533]     else {
[16:59:31.533]         if (TRUE) {
[16:59:31.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:31.533]                 open = "w")
[16:59:31.533]         }
[16:59:31.533]         else {
[16:59:31.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:31.533]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:31.533]         }
[16:59:31.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:31.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:31.533]             base::sink(type = "output", split = FALSE)
[16:59:31.533]             base::close(...future.stdout)
[16:59:31.533]         }, add = TRUE)
[16:59:31.533]     }
[16:59:31.533]     ...future.frame <- base::sys.nframe()
[16:59:31.533]     ...future.conditions <- base::list()
[16:59:31.533]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:31.533]     if (FALSE) {
[16:59:31.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:31.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:31.533]     }
[16:59:31.533]     ...future.result <- base::tryCatch({
[16:59:31.533]         base::withCallingHandlers({
[16:59:31.533]             ...future.value <- base::withVisible(base::local({
[16:59:31.533]                 ...future.makeSendCondition <- base::local({
[16:59:31.533]                   sendCondition <- NULL
[16:59:31.533]                   function(frame = 1L) {
[16:59:31.533]                     if (is.function(sendCondition)) 
[16:59:31.533]                       return(sendCondition)
[16:59:31.533]                     ns <- getNamespace("parallel")
[16:59:31.533]                     if (exists("sendData", mode = "function", 
[16:59:31.533]                       envir = ns)) {
[16:59:31.533]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:31.533]                         envir = ns)
[16:59:31.533]                       envir <- sys.frame(frame)
[16:59:31.533]                       master <- NULL
[16:59:31.533]                       while (!identical(envir, .GlobalEnv) && 
[16:59:31.533]                         !identical(envir, emptyenv())) {
[16:59:31.533]                         if (exists("master", mode = "list", envir = envir, 
[16:59:31.533]                           inherits = FALSE)) {
[16:59:31.533]                           master <- get("master", mode = "list", 
[16:59:31.533]                             envir = envir, inherits = FALSE)
[16:59:31.533]                           if (inherits(master, c("SOCKnode", 
[16:59:31.533]                             "SOCK0node"))) {
[16:59:31.533]                             sendCondition <<- function(cond) {
[16:59:31.533]                               data <- list(type = "VALUE", value = cond, 
[16:59:31.533]                                 success = TRUE)
[16:59:31.533]                               parallel_sendData(master, data)
[16:59:31.533]                             }
[16:59:31.533]                             return(sendCondition)
[16:59:31.533]                           }
[16:59:31.533]                         }
[16:59:31.533]                         frame <- frame + 1L
[16:59:31.533]                         envir <- sys.frame(frame)
[16:59:31.533]                       }
[16:59:31.533]                     }
[16:59:31.533]                     sendCondition <<- function(cond) NULL
[16:59:31.533]                   }
[16:59:31.533]                 })
[16:59:31.533]                 withCallingHandlers({
[16:59:31.533]                   NA
[16:59:31.533]                 }, immediateCondition = function(cond) {
[16:59:31.533]                   sendCondition <- ...future.makeSendCondition()
[16:59:31.533]                   sendCondition(cond)
[16:59:31.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.533]                   {
[16:59:31.533]                     inherits <- base::inherits
[16:59:31.533]                     invokeRestart <- base::invokeRestart
[16:59:31.533]                     is.null <- base::is.null
[16:59:31.533]                     muffled <- FALSE
[16:59:31.533]                     if (inherits(cond, "message")) {
[16:59:31.533]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:31.533]                       if (muffled) 
[16:59:31.533]                         invokeRestart("muffleMessage")
[16:59:31.533]                     }
[16:59:31.533]                     else if (inherits(cond, "warning")) {
[16:59:31.533]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:31.533]                       if (muffled) 
[16:59:31.533]                         invokeRestart("muffleWarning")
[16:59:31.533]                     }
[16:59:31.533]                     else if (inherits(cond, "condition")) {
[16:59:31.533]                       if (!is.null(pattern)) {
[16:59:31.533]                         computeRestarts <- base::computeRestarts
[16:59:31.533]                         grepl <- base::grepl
[16:59:31.533]                         restarts <- computeRestarts(cond)
[16:59:31.533]                         for (restart in restarts) {
[16:59:31.533]                           name <- restart$name
[16:59:31.533]                           if (is.null(name)) 
[16:59:31.533]                             next
[16:59:31.533]                           if (!grepl(pattern, name)) 
[16:59:31.533]                             next
[16:59:31.533]                           invokeRestart(restart)
[16:59:31.533]                           muffled <- TRUE
[16:59:31.533]                           break
[16:59:31.533]                         }
[16:59:31.533]                       }
[16:59:31.533]                     }
[16:59:31.533]                     invisible(muffled)
[16:59:31.533]                   }
[16:59:31.533]                   muffleCondition(cond)
[16:59:31.533]                 })
[16:59:31.533]             }))
[16:59:31.533]             future::FutureResult(value = ...future.value$value, 
[16:59:31.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:31.533]                   ...future.rng), globalenv = if (FALSE) 
[16:59:31.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:31.533]                     ...future.globalenv.names))
[16:59:31.533]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:31.533]         }, condition = base::local({
[16:59:31.533]             c <- base::c
[16:59:31.533]             inherits <- base::inherits
[16:59:31.533]             invokeRestart <- base::invokeRestart
[16:59:31.533]             length <- base::length
[16:59:31.533]             list <- base::list
[16:59:31.533]             seq.int <- base::seq.int
[16:59:31.533]             signalCondition <- base::signalCondition
[16:59:31.533]             sys.calls <- base::sys.calls
[16:59:31.533]             `[[` <- base::`[[`
[16:59:31.533]             `+` <- base::`+`
[16:59:31.533]             `<<-` <- base::`<<-`
[16:59:31.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:31.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:31.533]                   3L)]
[16:59:31.533]             }
[16:59:31.533]             function(cond) {
[16:59:31.533]                 is_error <- inherits(cond, "error")
[16:59:31.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:31.533]                   NULL)
[16:59:31.533]                 if (is_error) {
[16:59:31.533]                   sessionInformation <- function() {
[16:59:31.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:31.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:31.533]                       search = base::search(), system = base::Sys.info())
[16:59:31.533]                   }
[16:59:31.533]                   ...future.conditions[[length(...future.conditions) + 
[16:59:31.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:31.533]                     cond$call), session = sessionInformation(), 
[16:59:31.533]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:31.533]                   signalCondition(cond)
[16:59:31.533]                 }
[16:59:31.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:31.533]                 "immediateCondition"))) {
[16:59:31.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:31.533]                   ...future.conditions[[length(...future.conditions) + 
[16:59:31.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:31.533]                   if (TRUE && !signal) {
[16:59:31.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.533]                     {
[16:59:31.533]                       inherits <- base::inherits
[16:59:31.533]                       invokeRestart <- base::invokeRestart
[16:59:31.533]                       is.null <- base::is.null
[16:59:31.533]                       muffled <- FALSE
[16:59:31.533]                       if (inherits(cond, "message")) {
[16:59:31.533]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:31.533]                         if (muffled) 
[16:59:31.533]                           invokeRestart("muffleMessage")
[16:59:31.533]                       }
[16:59:31.533]                       else if (inherits(cond, "warning")) {
[16:59:31.533]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:31.533]                         if (muffled) 
[16:59:31.533]                           invokeRestart("muffleWarning")
[16:59:31.533]                       }
[16:59:31.533]                       else if (inherits(cond, "condition")) {
[16:59:31.533]                         if (!is.null(pattern)) {
[16:59:31.533]                           computeRestarts <- base::computeRestarts
[16:59:31.533]                           grepl <- base::grepl
[16:59:31.533]                           restarts <- computeRestarts(cond)
[16:59:31.533]                           for (restart in restarts) {
[16:59:31.533]                             name <- restart$name
[16:59:31.533]                             if (is.null(name)) 
[16:59:31.533]                               next
[16:59:31.533]                             if (!grepl(pattern, name)) 
[16:59:31.533]                               next
[16:59:31.533]                             invokeRestart(restart)
[16:59:31.533]                             muffled <- TRUE
[16:59:31.533]                             break
[16:59:31.533]                           }
[16:59:31.533]                         }
[16:59:31.533]                       }
[16:59:31.533]                       invisible(muffled)
[16:59:31.533]                     }
[16:59:31.533]                     muffleCondition(cond, pattern = "^muffle")
[16:59:31.533]                   }
[16:59:31.533]                 }
[16:59:31.533]                 else {
[16:59:31.533]                   if (TRUE) {
[16:59:31.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.533]                     {
[16:59:31.533]                       inherits <- base::inherits
[16:59:31.533]                       invokeRestart <- base::invokeRestart
[16:59:31.533]                       is.null <- base::is.null
[16:59:31.533]                       muffled <- FALSE
[16:59:31.533]                       if (inherits(cond, "message")) {
[16:59:31.533]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:31.533]                         if (muffled) 
[16:59:31.533]                           invokeRestart("muffleMessage")
[16:59:31.533]                       }
[16:59:31.533]                       else if (inherits(cond, "warning")) {
[16:59:31.533]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:31.533]                         if (muffled) 
[16:59:31.533]                           invokeRestart("muffleWarning")
[16:59:31.533]                       }
[16:59:31.533]                       else if (inherits(cond, "condition")) {
[16:59:31.533]                         if (!is.null(pattern)) {
[16:59:31.533]                           computeRestarts <- base::computeRestarts
[16:59:31.533]                           grepl <- base::grepl
[16:59:31.533]                           restarts <- computeRestarts(cond)
[16:59:31.533]                           for (restart in restarts) {
[16:59:31.533]                             name <- restart$name
[16:59:31.533]                             if (is.null(name)) 
[16:59:31.533]                               next
[16:59:31.533]                             if (!grepl(pattern, name)) 
[16:59:31.533]                               next
[16:59:31.533]                             invokeRestart(restart)
[16:59:31.533]                             muffled <- TRUE
[16:59:31.533]                             break
[16:59:31.533]                           }
[16:59:31.533]                         }
[16:59:31.533]                       }
[16:59:31.533]                       invisible(muffled)
[16:59:31.533]                     }
[16:59:31.533]                     muffleCondition(cond, pattern = "^muffle")
[16:59:31.533]                   }
[16:59:31.533]                 }
[16:59:31.533]             }
[16:59:31.533]         }))
[16:59:31.533]     }, error = function(ex) {
[16:59:31.533]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:31.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:31.533]                 ...future.rng), started = ...future.startTime, 
[16:59:31.533]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:31.533]             version = "1.8"), class = "FutureResult")
[16:59:31.533]     }, finally = {
[16:59:31.533]         if (!identical(...future.workdir, getwd())) 
[16:59:31.533]             setwd(...future.workdir)
[16:59:31.533]         {
[16:59:31.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:31.533]                 ...future.oldOptions$nwarnings <- NULL
[16:59:31.533]             }
[16:59:31.533]             base::options(...future.oldOptions)
[16:59:31.533]             if (.Platform$OS.type == "windows") {
[16:59:31.533]                 old_names <- names(...future.oldEnvVars)
[16:59:31.533]                 envs <- base::Sys.getenv()
[16:59:31.533]                 names <- names(envs)
[16:59:31.533]                 common <- intersect(names, old_names)
[16:59:31.533]                 added <- setdiff(names, old_names)
[16:59:31.533]                 removed <- setdiff(old_names, names)
[16:59:31.533]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:31.533]                   envs[common]]
[16:59:31.533]                 NAMES <- toupper(changed)
[16:59:31.533]                 args <- list()
[16:59:31.533]                 for (kk in seq_along(NAMES)) {
[16:59:31.533]                   name <- changed[[kk]]
[16:59:31.533]                   NAME <- NAMES[[kk]]
[16:59:31.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.533]                     next
[16:59:31.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:31.533]                 }
[16:59:31.533]                 NAMES <- toupper(added)
[16:59:31.533]                 for (kk in seq_along(NAMES)) {
[16:59:31.533]                   name <- added[[kk]]
[16:59:31.533]                   NAME <- NAMES[[kk]]
[16:59:31.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.533]                     next
[16:59:31.533]                   args[[name]] <- ""
[16:59:31.533]                 }
[16:59:31.533]                 NAMES <- toupper(removed)
[16:59:31.533]                 for (kk in seq_along(NAMES)) {
[16:59:31.533]                   name <- removed[[kk]]
[16:59:31.533]                   NAME <- NAMES[[kk]]
[16:59:31.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.533]                     next
[16:59:31.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:31.533]                 }
[16:59:31.533]                 if (length(args) > 0) 
[16:59:31.533]                   base::do.call(base::Sys.setenv, args = args)
[16:59:31.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:31.533]             }
[16:59:31.533]             else {
[16:59:31.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:31.533]             }
[16:59:31.533]             {
[16:59:31.533]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:31.533]                   0L) {
[16:59:31.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:31.533]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:31.533]                   base::options(opts)
[16:59:31.533]                 }
[16:59:31.533]                 {
[16:59:31.533]                   {
[16:59:31.533]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:31.533]                     NULL
[16:59:31.533]                   }
[16:59:31.533]                   options(future.plan = NULL)
[16:59:31.533]                   if (is.na(NA_character_)) 
[16:59:31.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:31.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:31.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:31.533]                     .init = FALSE)
[16:59:31.533]                 }
[16:59:31.533]             }
[16:59:31.533]         }
[16:59:31.533]     })
[16:59:31.533]     if (TRUE) {
[16:59:31.533]         base::sink(type = "output", split = FALSE)
[16:59:31.533]         if (TRUE) {
[16:59:31.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:31.533]         }
[16:59:31.533]         else {
[16:59:31.533]             ...future.result["stdout"] <- base::list(NULL)
[16:59:31.533]         }
[16:59:31.533]         base::close(...future.stdout)
[16:59:31.533]         ...future.stdout <- NULL
[16:59:31.533]     }
[16:59:31.533]     ...future.result$conditions <- ...future.conditions
[16:59:31.533]     ...future.result$finished <- base::Sys.time()
[16:59:31.533]     ...future.result
[16:59:31.533] }
[16:59:31.587] MultisessionFuture started
[16:59:31.587] result() for ClusterFuture ...
[16:59:31.588] receiveMessageFromWorker() for ClusterFuture ...
[16:59:31.588] - Validating connection of MultisessionFuture
[16:59:31.622] - received message: FutureResult
[16:59:31.622] - Received FutureResult
[16:59:31.622] - Erased future from FutureRegistry
[16:59:31.622] result() for ClusterFuture ...
[16:59:31.622] - result already collected: FutureResult
[16:59:31.622] result() for ClusterFuture ... done
[16:59:31.622] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:31.623] result() for ClusterFuture ... done
[16:59:31.623] result() for ClusterFuture ...
[16:59:31.623] - result already collected: FutureResult
[16:59:31.623] result() for ClusterFuture ... done
[16:59:31.623] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:59:31.627] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[16:59:31.628] getGlobalsAndPackagesXApply() ...
[16:59:31.628]  - future.globals: TRUE
[16:59:31.628] getGlobalsAndPackages() ...
[16:59:31.628] Searching for globals...
[16:59:31.668] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:59:31.669] Searching for globals ... DONE
[16:59:31.669] Resolving globals: FALSE
[16:59:31.673] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:59:31.673] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:59:31.673] - globals: [1] ‘FUN’
[16:59:31.673] 
[16:59:31.673] getGlobalsAndPackages() ... DONE
[16:59:31.673]  - globals found/used: [n=1] ‘FUN’
[16:59:31.673]  - needed namespaces: [n=0] 
[16:59:31.674] Finding globals ... DONE
[16:59:31.674]  - use_args: TRUE
[16:59:31.674]  - Getting '...' globals ...
[16:59:31.674] resolve() on list ...
[16:59:31.674]  recursive: 0
[16:59:31.674]  length: 1
[16:59:31.674]  elements: ‘...’
[16:59:31.674]  length: 0 (resolved future 1)
[16:59:31.674] resolve() on list ... DONE
[16:59:31.675]    - '...' content: [n=0] 
[16:59:31.675] List of 1
[16:59:31.675]  $ ...: list()
[16:59:31.675]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:31.675]  - attr(*, "where")=List of 1
[16:59:31.675]   ..$ ...:<environment: 0x55f31505f2b8> 
[16:59:31.675]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:31.675]  - attr(*, "resolved")= logi TRUE
[16:59:31.675]  - attr(*, "total_size")= num NA
[16:59:31.677]  - Getting '...' globals ... DONE
[16:59:31.677] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:31.677] List of 2
[16:59:31.677]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:31.677]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:31.677]  $ ...          : list()
[16:59:31.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:31.677]  - attr(*, "where")=List of 2
[16:59:31.677]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:31.677]   ..$ ...          :<environment: 0x55f31505f2b8> 
[16:59:31.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:31.677]  - attr(*, "resolved")= logi FALSE
[16:59:31.677]  - attr(*, "total_size")= num 354224
[16:59:31.680] Packages to be attached in all futures: [n=0] 
[16:59:31.680] getGlobalsAndPackagesXApply() ... DONE
[16:59:31.684] future_lapply() ...
[16:59:31.716] Number of chunks: 2
[16:59:31.717] getGlobalsAndPackagesXApply() ...
[16:59:31.717]  - future.globals: <name-value list> with names ‘list()’
[16:59:31.717]  - use_args: TRUE
[16:59:31.717] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:31.717] List of 2
[16:59:31.717]  $ ...          : list()
[16:59:31.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:31.717]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:31.717]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:31.717]  - attr(*, "where")=List of 2
[16:59:31.717]   ..$ ...          :<environment: 0x55f31505f2b8> 
[16:59:31.717]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:31.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:31.717]  - attr(*, "resolved")= logi FALSE
[16:59:31.717]  - attr(*, "total_size")= num NA
[16:59:31.721] Packages to be attached in all futures: [n=0] 
[16:59:31.721] getGlobalsAndPackagesXApply() ... DONE
[16:59:31.721] Number of futures (= number of chunks): 2
[16:59:31.721] Launching 2 futures (chunks) ...
[16:59:31.721] Chunk #1 of 2 ...
[16:59:31.722]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:31.722]  - seeds: <none>
[16:59:31.722]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:31.722] getGlobalsAndPackages() ...
[16:59:31.722] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:31.722] Resolving globals: FALSE
[16:59:31.722] Tweak future expression to call with '...' arguments ...
[16:59:31.722] {
[16:59:31.722]     do.call(function(...) {
[16:59:31.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:31.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:31.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:31.722]             on.exit(options(oopts), add = TRUE)
[16:59:31.722]         }
[16:59:31.722]         {
[16:59:31.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:31.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:31.722]                 ...future.FUN(...future.X_jj, ...)
[16:59:31.722]             })
[16:59:31.722]         }
[16:59:31.722]     }, args = future.call.arguments)
[16:59:31.722] }
[16:59:31.723] Tweak future expression to call with '...' arguments ... DONE
[16:59:31.723] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:31.723] 
[16:59:31.723] getGlobalsAndPackages() ... DONE
[16:59:31.723] run() for ‘Future’ ...
[16:59:31.724] - state: ‘created’
[16:59:31.724] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:31.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:31.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:31.738]   - Field: ‘node’
[16:59:31.738]   - Field: ‘label’
[16:59:31.738]   - Field: ‘local’
[16:59:31.738]   - Field: ‘owner’
[16:59:31.738]   - Field: ‘envir’
[16:59:31.738]   - Field: ‘workers’
[16:59:31.738]   - Field: ‘packages’
[16:59:31.738]   - Field: ‘gc’
[16:59:31.738]   - Field: ‘conditions’
[16:59:31.738]   - Field: ‘persistent’
[16:59:31.739]   - Field: ‘expr’
[16:59:31.739]   - Field: ‘uuid’
[16:59:31.739]   - Field: ‘seed’
[16:59:31.739]   - Field: ‘version’
[16:59:31.739]   - Field: ‘result’
[16:59:31.739]   - Field: ‘asynchronous’
[16:59:31.739]   - Field: ‘calls’
[16:59:31.739]   - Field: ‘globals’
[16:59:31.739]   - Field: ‘stdout’
[16:59:31.739]   - Field: ‘earlySignal’
[16:59:31.739]   - Field: ‘lazy’
[16:59:31.740]   - Field: ‘state’
[16:59:31.740] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:31.740] - Launch lazy future ...
[16:59:31.740] Packages needed by the future expression (n = 0): <none>
[16:59:31.740] Packages needed by future strategies (n = 0): <none>
[16:59:31.741] {
[16:59:31.741]     {
[16:59:31.741]         {
[16:59:31.741]             ...future.startTime <- base::Sys.time()
[16:59:31.741]             {
[16:59:31.741]                 {
[16:59:31.741]                   {
[16:59:31.741]                     {
[16:59:31.741]                       base::local({
[16:59:31.741]                         has_future <- base::requireNamespace("future", 
[16:59:31.741]                           quietly = TRUE)
[16:59:31.741]                         if (has_future) {
[16:59:31.741]                           ns <- base::getNamespace("future")
[16:59:31.741]                           version <- ns[[".package"]][["version"]]
[16:59:31.741]                           if (is.null(version)) 
[16:59:31.741]                             version <- utils::packageVersion("future")
[16:59:31.741]                         }
[16:59:31.741]                         else {
[16:59:31.741]                           version <- NULL
[16:59:31.741]                         }
[16:59:31.741]                         if (!has_future || version < "1.8.0") {
[16:59:31.741]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:31.741]                             "", base::R.version$version.string), 
[16:59:31.741]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:31.741]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:31.741]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:31.741]                               "release", "version")], collapse = " "), 
[16:59:31.741]                             hostname = base::Sys.info()[["nodename"]])
[16:59:31.741]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:31.741]                             info)
[16:59:31.741]                           info <- base::paste(info, collapse = "; ")
[16:59:31.741]                           if (!has_future) {
[16:59:31.741]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:31.741]                               info)
[16:59:31.741]                           }
[16:59:31.741]                           else {
[16:59:31.741]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:31.741]                               info, version)
[16:59:31.741]                           }
[16:59:31.741]                           base::stop(msg)
[16:59:31.741]                         }
[16:59:31.741]                       })
[16:59:31.741]                     }
[16:59:31.741]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:31.741]                     base::options(mc.cores = 1L)
[16:59:31.741]                   }
[16:59:31.741]                   ...future.strategy.old <- future::plan("list")
[16:59:31.741]                   options(future.plan = NULL)
[16:59:31.741]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:31.741]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:31.741]                 }
[16:59:31.741]                 ...future.workdir <- getwd()
[16:59:31.741]             }
[16:59:31.741]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:31.741]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:31.741]         }
[16:59:31.741]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:31.741]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:31.741]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:31.741]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:31.741]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:31.741]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:31.741]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:31.741]             base::names(...future.oldOptions))
[16:59:31.741]     }
[16:59:31.741]     if (FALSE) {
[16:59:31.741]     }
[16:59:31.741]     else {
[16:59:31.741]         if (TRUE) {
[16:59:31.741]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:31.741]                 open = "w")
[16:59:31.741]         }
[16:59:31.741]         else {
[16:59:31.741]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:31.741]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:31.741]         }
[16:59:31.741]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:31.741]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:31.741]             base::sink(type = "output", split = FALSE)
[16:59:31.741]             base::close(...future.stdout)
[16:59:31.741]         }, add = TRUE)
[16:59:31.741]     }
[16:59:31.741]     ...future.frame <- base::sys.nframe()
[16:59:31.741]     ...future.conditions <- base::list()
[16:59:31.741]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:31.741]     if (FALSE) {
[16:59:31.741]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:31.741]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:31.741]     }
[16:59:31.741]     ...future.result <- base::tryCatch({
[16:59:31.741]         base::withCallingHandlers({
[16:59:31.741]             ...future.value <- base::withVisible(base::local({
[16:59:31.741]                 ...future.makeSendCondition <- base::local({
[16:59:31.741]                   sendCondition <- NULL
[16:59:31.741]                   function(frame = 1L) {
[16:59:31.741]                     if (is.function(sendCondition)) 
[16:59:31.741]                       return(sendCondition)
[16:59:31.741]                     ns <- getNamespace("parallel")
[16:59:31.741]                     if (exists("sendData", mode = "function", 
[16:59:31.741]                       envir = ns)) {
[16:59:31.741]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:31.741]                         envir = ns)
[16:59:31.741]                       envir <- sys.frame(frame)
[16:59:31.741]                       master <- NULL
[16:59:31.741]                       while (!identical(envir, .GlobalEnv) && 
[16:59:31.741]                         !identical(envir, emptyenv())) {
[16:59:31.741]                         if (exists("master", mode = "list", envir = envir, 
[16:59:31.741]                           inherits = FALSE)) {
[16:59:31.741]                           master <- get("master", mode = "list", 
[16:59:31.741]                             envir = envir, inherits = FALSE)
[16:59:31.741]                           if (inherits(master, c("SOCKnode", 
[16:59:31.741]                             "SOCK0node"))) {
[16:59:31.741]                             sendCondition <<- function(cond) {
[16:59:31.741]                               data <- list(type = "VALUE", value = cond, 
[16:59:31.741]                                 success = TRUE)
[16:59:31.741]                               parallel_sendData(master, data)
[16:59:31.741]                             }
[16:59:31.741]                             return(sendCondition)
[16:59:31.741]                           }
[16:59:31.741]                         }
[16:59:31.741]                         frame <- frame + 1L
[16:59:31.741]                         envir <- sys.frame(frame)
[16:59:31.741]                       }
[16:59:31.741]                     }
[16:59:31.741]                     sendCondition <<- function(cond) NULL
[16:59:31.741]                   }
[16:59:31.741]                 })
[16:59:31.741]                 withCallingHandlers({
[16:59:31.741]                   {
[16:59:31.741]                     do.call(function(...) {
[16:59:31.741]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:31.741]                       if (!identical(...future.globals.maxSize.org, 
[16:59:31.741]                         ...future.globals.maxSize)) {
[16:59:31.741]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:31.741]                         on.exit(options(oopts), add = TRUE)
[16:59:31.741]                       }
[16:59:31.741]                       {
[16:59:31.741]                         lapply(seq_along(...future.elements_ii), 
[16:59:31.741]                           FUN = function(jj) {
[16:59:31.741]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:31.741]                             ...future.FUN(...future.X_jj, ...)
[16:59:31.741]                           })
[16:59:31.741]                       }
[16:59:31.741]                     }, args = future.call.arguments)
[16:59:31.741]                   }
[16:59:31.741]                 }, immediateCondition = function(cond) {
[16:59:31.741]                   sendCondition <- ...future.makeSendCondition()
[16:59:31.741]                   sendCondition(cond)
[16:59:31.741]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.741]                   {
[16:59:31.741]                     inherits <- base::inherits
[16:59:31.741]                     invokeRestart <- base::invokeRestart
[16:59:31.741]                     is.null <- base::is.null
[16:59:31.741]                     muffled <- FALSE
[16:59:31.741]                     if (inherits(cond, "message")) {
[16:59:31.741]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:31.741]                       if (muffled) 
[16:59:31.741]                         invokeRestart("muffleMessage")
[16:59:31.741]                     }
[16:59:31.741]                     else if (inherits(cond, "warning")) {
[16:59:31.741]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:31.741]                       if (muffled) 
[16:59:31.741]                         invokeRestart("muffleWarning")
[16:59:31.741]                     }
[16:59:31.741]                     else if (inherits(cond, "condition")) {
[16:59:31.741]                       if (!is.null(pattern)) {
[16:59:31.741]                         computeRestarts <- base::computeRestarts
[16:59:31.741]                         grepl <- base::grepl
[16:59:31.741]                         restarts <- computeRestarts(cond)
[16:59:31.741]                         for (restart in restarts) {
[16:59:31.741]                           name <- restart$name
[16:59:31.741]                           if (is.null(name)) 
[16:59:31.741]                             next
[16:59:31.741]                           if (!grepl(pattern, name)) 
[16:59:31.741]                             next
[16:59:31.741]                           invokeRestart(restart)
[16:59:31.741]                           muffled <- TRUE
[16:59:31.741]                           break
[16:59:31.741]                         }
[16:59:31.741]                       }
[16:59:31.741]                     }
[16:59:31.741]                     invisible(muffled)
[16:59:31.741]                   }
[16:59:31.741]                   muffleCondition(cond)
[16:59:31.741]                 })
[16:59:31.741]             }))
[16:59:31.741]             future::FutureResult(value = ...future.value$value, 
[16:59:31.741]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:31.741]                   ...future.rng), globalenv = if (FALSE) 
[16:59:31.741]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:31.741]                     ...future.globalenv.names))
[16:59:31.741]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:31.741]         }, condition = base::local({
[16:59:31.741]             c <- base::c
[16:59:31.741]             inherits <- base::inherits
[16:59:31.741]             invokeRestart <- base::invokeRestart
[16:59:31.741]             length <- base::length
[16:59:31.741]             list <- base::list
[16:59:31.741]             seq.int <- base::seq.int
[16:59:31.741]             signalCondition <- base::signalCondition
[16:59:31.741]             sys.calls <- base::sys.calls
[16:59:31.741]             `[[` <- base::`[[`
[16:59:31.741]             `+` <- base::`+`
[16:59:31.741]             `<<-` <- base::`<<-`
[16:59:31.741]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:31.741]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:31.741]                   3L)]
[16:59:31.741]             }
[16:59:31.741]             function(cond) {
[16:59:31.741]                 is_error <- inherits(cond, "error")
[16:59:31.741]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:31.741]                   NULL)
[16:59:31.741]                 if (is_error) {
[16:59:31.741]                   sessionInformation <- function() {
[16:59:31.741]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:31.741]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:31.741]                       search = base::search(), system = base::Sys.info())
[16:59:31.741]                   }
[16:59:31.741]                   ...future.conditions[[length(...future.conditions) + 
[16:59:31.741]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:31.741]                     cond$call), session = sessionInformation(), 
[16:59:31.741]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:31.741]                   signalCondition(cond)
[16:59:31.741]                 }
[16:59:31.741]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:31.741]                 "immediateCondition"))) {
[16:59:31.741]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:31.741]                   ...future.conditions[[length(...future.conditions) + 
[16:59:31.741]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:31.741]                   if (TRUE && !signal) {
[16:59:31.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.741]                     {
[16:59:31.741]                       inherits <- base::inherits
[16:59:31.741]                       invokeRestart <- base::invokeRestart
[16:59:31.741]                       is.null <- base::is.null
[16:59:31.741]                       muffled <- FALSE
[16:59:31.741]                       if (inherits(cond, "message")) {
[16:59:31.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:31.741]                         if (muffled) 
[16:59:31.741]                           invokeRestart("muffleMessage")
[16:59:31.741]                       }
[16:59:31.741]                       else if (inherits(cond, "warning")) {
[16:59:31.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:31.741]                         if (muffled) 
[16:59:31.741]                           invokeRestart("muffleWarning")
[16:59:31.741]                       }
[16:59:31.741]                       else if (inherits(cond, "condition")) {
[16:59:31.741]                         if (!is.null(pattern)) {
[16:59:31.741]                           computeRestarts <- base::computeRestarts
[16:59:31.741]                           grepl <- base::grepl
[16:59:31.741]                           restarts <- computeRestarts(cond)
[16:59:31.741]                           for (restart in restarts) {
[16:59:31.741]                             name <- restart$name
[16:59:31.741]                             if (is.null(name)) 
[16:59:31.741]                               next
[16:59:31.741]                             if (!grepl(pattern, name)) 
[16:59:31.741]                               next
[16:59:31.741]                             invokeRestart(restart)
[16:59:31.741]                             muffled <- TRUE
[16:59:31.741]                             break
[16:59:31.741]                           }
[16:59:31.741]                         }
[16:59:31.741]                       }
[16:59:31.741]                       invisible(muffled)
[16:59:31.741]                     }
[16:59:31.741]                     muffleCondition(cond, pattern = "^muffle")
[16:59:31.741]                   }
[16:59:31.741]                 }
[16:59:31.741]                 else {
[16:59:31.741]                   if (TRUE) {
[16:59:31.741]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.741]                     {
[16:59:31.741]                       inherits <- base::inherits
[16:59:31.741]                       invokeRestart <- base::invokeRestart
[16:59:31.741]                       is.null <- base::is.null
[16:59:31.741]                       muffled <- FALSE
[16:59:31.741]                       if (inherits(cond, "message")) {
[16:59:31.741]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:31.741]                         if (muffled) 
[16:59:31.741]                           invokeRestart("muffleMessage")
[16:59:31.741]                       }
[16:59:31.741]                       else if (inherits(cond, "warning")) {
[16:59:31.741]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:31.741]                         if (muffled) 
[16:59:31.741]                           invokeRestart("muffleWarning")
[16:59:31.741]                       }
[16:59:31.741]                       else if (inherits(cond, "condition")) {
[16:59:31.741]                         if (!is.null(pattern)) {
[16:59:31.741]                           computeRestarts <- base::computeRestarts
[16:59:31.741]                           grepl <- base::grepl
[16:59:31.741]                           restarts <- computeRestarts(cond)
[16:59:31.741]                           for (restart in restarts) {
[16:59:31.741]                             name <- restart$name
[16:59:31.741]                             if (is.null(name)) 
[16:59:31.741]                               next
[16:59:31.741]                             if (!grepl(pattern, name)) 
[16:59:31.741]                               next
[16:59:31.741]                             invokeRestart(restart)
[16:59:31.741]                             muffled <- TRUE
[16:59:31.741]                             break
[16:59:31.741]                           }
[16:59:31.741]                         }
[16:59:31.741]                       }
[16:59:31.741]                       invisible(muffled)
[16:59:31.741]                     }
[16:59:31.741]                     muffleCondition(cond, pattern = "^muffle")
[16:59:31.741]                   }
[16:59:31.741]                 }
[16:59:31.741]             }
[16:59:31.741]         }))
[16:59:31.741]     }, error = function(ex) {
[16:59:31.741]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:31.741]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:31.741]                 ...future.rng), started = ...future.startTime, 
[16:59:31.741]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:31.741]             version = "1.8"), class = "FutureResult")
[16:59:31.741]     }, finally = {
[16:59:31.741]         if (!identical(...future.workdir, getwd())) 
[16:59:31.741]             setwd(...future.workdir)
[16:59:31.741]         {
[16:59:31.741]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:31.741]                 ...future.oldOptions$nwarnings <- NULL
[16:59:31.741]             }
[16:59:31.741]             base::options(...future.oldOptions)
[16:59:31.741]             if (.Platform$OS.type == "windows") {
[16:59:31.741]                 old_names <- names(...future.oldEnvVars)
[16:59:31.741]                 envs <- base::Sys.getenv()
[16:59:31.741]                 names <- names(envs)
[16:59:31.741]                 common <- intersect(names, old_names)
[16:59:31.741]                 added <- setdiff(names, old_names)
[16:59:31.741]                 removed <- setdiff(old_names, names)
[16:59:31.741]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:31.741]                   envs[common]]
[16:59:31.741]                 NAMES <- toupper(changed)
[16:59:31.741]                 args <- list()
[16:59:31.741]                 for (kk in seq_along(NAMES)) {
[16:59:31.741]                   name <- changed[[kk]]
[16:59:31.741]                   NAME <- NAMES[[kk]]
[16:59:31.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.741]                     next
[16:59:31.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:31.741]                 }
[16:59:31.741]                 NAMES <- toupper(added)
[16:59:31.741]                 for (kk in seq_along(NAMES)) {
[16:59:31.741]                   name <- added[[kk]]
[16:59:31.741]                   NAME <- NAMES[[kk]]
[16:59:31.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.741]                     next
[16:59:31.741]                   args[[name]] <- ""
[16:59:31.741]                 }
[16:59:31.741]                 NAMES <- toupper(removed)
[16:59:31.741]                 for (kk in seq_along(NAMES)) {
[16:59:31.741]                   name <- removed[[kk]]
[16:59:31.741]                   NAME <- NAMES[[kk]]
[16:59:31.741]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.741]                     next
[16:59:31.741]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:31.741]                 }
[16:59:31.741]                 if (length(args) > 0) 
[16:59:31.741]                   base::do.call(base::Sys.setenv, args = args)
[16:59:31.741]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:31.741]             }
[16:59:31.741]             else {
[16:59:31.741]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:31.741]             }
[16:59:31.741]             {
[16:59:31.741]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:31.741]                   0L) {
[16:59:31.741]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:31.741]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:31.741]                   base::options(opts)
[16:59:31.741]                 }
[16:59:31.741]                 {
[16:59:31.741]                   {
[16:59:31.741]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:31.741]                     NULL
[16:59:31.741]                   }
[16:59:31.741]                   options(future.plan = NULL)
[16:59:31.741]                   if (is.na(NA_character_)) 
[16:59:31.741]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:31.741]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:31.741]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:31.741]                     .init = FALSE)
[16:59:31.741]                 }
[16:59:31.741]             }
[16:59:31.741]         }
[16:59:31.741]     })
[16:59:31.741]     if (TRUE) {
[16:59:31.741]         base::sink(type = "output", split = FALSE)
[16:59:31.741]         if (TRUE) {
[16:59:31.741]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:31.741]         }
[16:59:31.741]         else {
[16:59:31.741]             ...future.result["stdout"] <- base::list(NULL)
[16:59:31.741]         }
[16:59:31.741]         base::close(...future.stdout)
[16:59:31.741]         ...future.stdout <- NULL
[16:59:31.741]     }
[16:59:31.741]     ...future.result$conditions <- ...future.conditions
[16:59:31.741]     ...future.result$finished <- base::Sys.time()
[16:59:31.741]     ...future.result
[16:59:31.741] }
[16:59:31.744] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[16:59:31.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:31.744] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:31.745] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:59:31.788] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:59:31.788] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:59:31.789] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:59:31.789] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:31.789] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:31.789] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:31.790] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:31.790] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[16:59:31.791] MultisessionFuture started
[16:59:31.791] - Launch lazy future ... done
[16:59:31.791] run() for ‘MultisessionFuture’ ... done
[16:59:31.791] Created future:
[16:59:31.791] MultisessionFuture:
[16:59:31.791] Label: ‘future_apply-1’
[16:59:31.791] Expression:
[16:59:31.791] {
[16:59:31.791]     do.call(function(...) {
[16:59:31.791]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:31.791]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:31.791]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:31.791]             on.exit(options(oopts), add = TRUE)
[16:59:31.791]         }
[16:59:31.791]         {
[16:59:31.791]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:31.791]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:31.791]                 ...future.FUN(...future.X_jj, ...)
[16:59:31.791]             })
[16:59:31.791]         }
[16:59:31.791]     }, args = future.call.arguments)
[16:59:31.791] }
[16:59:31.791] Lazy evaluation: FALSE
[16:59:31.791] Asynchronous evaluation: TRUE
[16:59:31.791] Local evaluation: TRUE
[16:59:31.791] Environment: R_GlobalEnv
[16:59:31.791] Capture standard output: TRUE
[16:59:31.791] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:31.791] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:31.791] Packages: <none>
[16:59:31.791] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:31.791] Resolved: FALSE
[16:59:31.791] Value: <not collected>
[16:59:31.791] Conditions captured: <none>
[16:59:31.791] Early signaling: FALSE
[16:59:31.791] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:31.791] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:31.803] Chunk #1 of 2 ... DONE
[16:59:31.803] Chunk #2 of 2 ...
[16:59:31.804]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:31.804]  - seeds: <none>
[16:59:31.804]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:31.804] getGlobalsAndPackages() ...
[16:59:31.804] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:31.804] Resolving globals: FALSE
[16:59:31.804] Tweak future expression to call with '...' arguments ...
[16:59:31.804] {
[16:59:31.804]     do.call(function(...) {
[16:59:31.804]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:31.804]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:31.804]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:31.804]             on.exit(options(oopts), add = TRUE)
[16:59:31.804]         }
[16:59:31.804]         {
[16:59:31.804]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:31.804]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:31.804]                 ...future.FUN(...future.X_jj, ...)
[16:59:31.804]             })
[16:59:31.804]         }
[16:59:31.804]     }, args = future.call.arguments)
[16:59:31.804] }
[16:59:31.805] Tweak future expression to call with '...' arguments ... DONE
[16:59:31.805] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:31.805] 
[16:59:31.805] getGlobalsAndPackages() ... DONE
[16:59:31.805] run() for ‘Future’ ...
[16:59:31.806] - state: ‘created’
[16:59:31.806] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:31.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:31.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:31.820]   - Field: ‘node’
[16:59:31.820]   - Field: ‘label’
[16:59:31.820]   - Field: ‘local’
[16:59:31.820]   - Field: ‘owner’
[16:59:31.820]   - Field: ‘envir’
[16:59:31.821]   - Field: ‘workers’
[16:59:31.821]   - Field: ‘packages’
[16:59:31.821]   - Field: ‘gc’
[16:59:31.821]   - Field: ‘conditions’
[16:59:31.821]   - Field: ‘persistent’
[16:59:31.821]   - Field: ‘expr’
[16:59:31.821]   - Field: ‘uuid’
[16:59:31.821]   - Field: ‘seed’
[16:59:31.821]   - Field: ‘version’
[16:59:31.821]   - Field: ‘result’
[16:59:31.821]   - Field: ‘asynchronous’
[16:59:31.822]   - Field: ‘calls’
[16:59:31.822]   - Field: ‘globals’
[16:59:31.822]   - Field: ‘stdout’
[16:59:31.822]   - Field: ‘earlySignal’
[16:59:31.822]   - Field: ‘lazy’
[16:59:31.822]   - Field: ‘state’
[16:59:31.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:31.822] - Launch lazy future ...
[16:59:31.822] Packages needed by the future expression (n = 0): <none>
[16:59:31.823] Packages needed by future strategies (n = 0): <none>
[16:59:31.825] {
[16:59:31.825]     {
[16:59:31.825]         {
[16:59:31.825]             ...future.startTime <- base::Sys.time()
[16:59:31.825]             {
[16:59:31.825]                 {
[16:59:31.825]                   {
[16:59:31.825]                     {
[16:59:31.825]                       base::local({
[16:59:31.825]                         has_future <- base::requireNamespace("future", 
[16:59:31.825]                           quietly = TRUE)
[16:59:31.825]                         if (has_future) {
[16:59:31.825]                           ns <- base::getNamespace("future")
[16:59:31.825]                           version <- ns[[".package"]][["version"]]
[16:59:31.825]                           if (is.null(version)) 
[16:59:31.825]                             version <- utils::packageVersion("future")
[16:59:31.825]                         }
[16:59:31.825]                         else {
[16:59:31.825]                           version <- NULL
[16:59:31.825]                         }
[16:59:31.825]                         if (!has_future || version < "1.8.0") {
[16:59:31.825]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:31.825]                             "", base::R.version$version.string), 
[16:59:31.825]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:31.825]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:31.825]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:31.825]                               "release", "version")], collapse = " "), 
[16:59:31.825]                             hostname = base::Sys.info()[["nodename"]])
[16:59:31.825]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:31.825]                             info)
[16:59:31.825]                           info <- base::paste(info, collapse = "; ")
[16:59:31.825]                           if (!has_future) {
[16:59:31.825]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:31.825]                               info)
[16:59:31.825]                           }
[16:59:31.825]                           else {
[16:59:31.825]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:31.825]                               info, version)
[16:59:31.825]                           }
[16:59:31.825]                           base::stop(msg)
[16:59:31.825]                         }
[16:59:31.825]                       })
[16:59:31.825]                     }
[16:59:31.825]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:31.825]                     base::options(mc.cores = 1L)
[16:59:31.825]                   }
[16:59:31.825]                   ...future.strategy.old <- future::plan("list")
[16:59:31.825]                   options(future.plan = NULL)
[16:59:31.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:31.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:31.825]                 }
[16:59:31.825]                 ...future.workdir <- getwd()
[16:59:31.825]             }
[16:59:31.825]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:31.825]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:31.825]         }
[16:59:31.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:31.825]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:31.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:31.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:31.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:31.825]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:31.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:31.825]             base::names(...future.oldOptions))
[16:59:31.825]     }
[16:59:31.825]     if (FALSE) {
[16:59:31.825]     }
[16:59:31.825]     else {
[16:59:31.825]         if (TRUE) {
[16:59:31.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:31.825]                 open = "w")
[16:59:31.825]         }
[16:59:31.825]         else {
[16:59:31.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:31.825]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:31.825]         }
[16:59:31.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:31.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:31.825]             base::sink(type = "output", split = FALSE)
[16:59:31.825]             base::close(...future.stdout)
[16:59:31.825]         }, add = TRUE)
[16:59:31.825]     }
[16:59:31.825]     ...future.frame <- base::sys.nframe()
[16:59:31.825]     ...future.conditions <- base::list()
[16:59:31.825]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:31.825]     if (FALSE) {
[16:59:31.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:31.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:31.825]     }
[16:59:31.825]     ...future.result <- base::tryCatch({
[16:59:31.825]         base::withCallingHandlers({
[16:59:31.825]             ...future.value <- base::withVisible(base::local({
[16:59:31.825]                 ...future.makeSendCondition <- base::local({
[16:59:31.825]                   sendCondition <- NULL
[16:59:31.825]                   function(frame = 1L) {
[16:59:31.825]                     if (is.function(sendCondition)) 
[16:59:31.825]                       return(sendCondition)
[16:59:31.825]                     ns <- getNamespace("parallel")
[16:59:31.825]                     if (exists("sendData", mode = "function", 
[16:59:31.825]                       envir = ns)) {
[16:59:31.825]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:31.825]                         envir = ns)
[16:59:31.825]                       envir <- sys.frame(frame)
[16:59:31.825]                       master <- NULL
[16:59:31.825]                       while (!identical(envir, .GlobalEnv) && 
[16:59:31.825]                         !identical(envir, emptyenv())) {
[16:59:31.825]                         if (exists("master", mode = "list", envir = envir, 
[16:59:31.825]                           inherits = FALSE)) {
[16:59:31.825]                           master <- get("master", mode = "list", 
[16:59:31.825]                             envir = envir, inherits = FALSE)
[16:59:31.825]                           if (inherits(master, c("SOCKnode", 
[16:59:31.825]                             "SOCK0node"))) {
[16:59:31.825]                             sendCondition <<- function(cond) {
[16:59:31.825]                               data <- list(type = "VALUE", value = cond, 
[16:59:31.825]                                 success = TRUE)
[16:59:31.825]                               parallel_sendData(master, data)
[16:59:31.825]                             }
[16:59:31.825]                             return(sendCondition)
[16:59:31.825]                           }
[16:59:31.825]                         }
[16:59:31.825]                         frame <- frame + 1L
[16:59:31.825]                         envir <- sys.frame(frame)
[16:59:31.825]                       }
[16:59:31.825]                     }
[16:59:31.825]                     sendCondition <<- function(cond) NULL
[16:59:31.825]                   }
[16:59:31.825]                 })
[16:59:31.825]                 withCallingHandlers({
[16:59:31.825]                   {
[16:59:31.825]                     do.call(function(...) {
[16:59:31.825]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:31.825]                       if (!identical(...future.globals.maxSize.org, 
[16:59:31.825]                         ...future.globals.maxSize)) {
[16:59:31.825]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:31.825]                         on.exit(options(oopts), add = TRUE)
[16:59:31.825]                       }
[16:59:31.825]                       {
[16:59:31.825]                         lapply(seq_along(...future.elements_ii), 
[16:59:31.825]                           FUN = function(jj) {
[16:59:31.825]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:31.825]                             ...future.FUN(...future.X_jj, ...)
[16:59:31.825]                           })
[16:59:31.825]                       }
[16:59:31.825]                     }, args = future.call.arguments)
[16:59:31.825]                   }
[16:59:31.825]                 }, immediateCondition = function(cond) {
[16:59:31.825]                   sendCondition <- ...future.makeSendCondition()
[16:59:31.825]                   sendCondition(cond)
[16:59:31.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.825]                   {
[16:59:31.825]                     inherits <- base::inherits
[16:59:31.825]                     invokeRestart <- base::invokeRestart
[16:59:31.825]                     is.null <- base::is.null
[16:59:31.825]                     muffled <- FALSE
[16:59:31.825]                     if (inherits(cond, "message")) {
[16:59:31.825]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:31.825]                       if (muffled) 
[16:59:31.825]                         invokeRestart("muffleMessage")
[16:59:31.825]                     }
[16:59:31.825]                     else if (inherits(cond, "warning")) {
[16:59:31.825]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:31.825]                       if (muffled) 
[16:59:31.825]                         invokeRestart("muffleWarning")
[16:59:31.825]                     }
[16:59:31.825]                     else if (inherits(cond, "condition")) {
[16:59:31.825]                       if (!is.null(pattern)) {
[16:59:31.825]                         computeRestarts <- base::computeRestarts
[16:59:31.825]                         grepl <- base::grepl
[16:59:31.825]                         restarts <- computeRestarts(cond)
[16:59:31.825]                         for (restart in restarts) {
[16:59:31.825]                           name <- restart$name
[16:59:31.825]                           if (is.null(name)) 
[16:59:31.825]                             next
[16:59:31.825]                           if (!grepl(pattern, name)) 
[16:59:31.825]                             next
[16:59:31.825]                           invokeRestart(restart)
[16:59:31.825]                           muffled <- TRUE
[16:59:31.825]                           break
[16:59:31.825]                         }
[16:59:31.825]                       }
[16:59:31.825]                     }
[16:59:31.825]                     invisible(muffled)
[16:59:31.825]                   }
[16:59:31.825]                   muffleCondition(cond)
[16:59:31.825]                 })
[16:59:31.825]             }))
[16:59:31.825]             future::FutureResult(value = ...future.value$value, 
[16:59:31.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:31.825]                   ...future.rng), globalenv = if (FALSE) 
[16:59:31.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:31.825]                     ...future.globalenv.names))
[16:59:31.825]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:31.825]         }, condition = base::local({
[16:59:31.825]             c <- base::c
[16:59:31.825]             inherits <- base::inherits
[16:59:31.825]             invokeRestart <- base::invokeRestart
[16:59:31.825]             length <- base::length
[16:59:31.825]             list <- base::list
[16:59:31.825]             seq.int <- base::seq.int
[16:59:31.825]             signalCondition <- base::signalCondition
[16:59:31.825]             sys.calls <- base::sys.calls
[16:59:31.825]             `[[` <- base::`[[`
[16:59:31.825]             `+` <- base::`+`
[16:59:31.825]             `<<-` <- base::`<<-`
[16:59:31.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:31.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:31.825]                   3L)]
[16:59:31.825]             }
[16:59:31.825]             function(cond) {
[16:59:31.825]                 is_error <- inherits(cond, "error")
[16:59:31.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:31.825]                   NULL)
[16:59:31.825]                 if (is_error) {
[16:59:31.825]                   sessionInformation <- function() {
[16:59:31.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:31.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:31.825]                       search = base::search(), system = base::Sys.info())
[16:59:31.825]                   }
[16:59:31.825]                   ...future.conditions[[length(...future.conditions) + 
[16:59:31.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:31.825]                     cond$call), session = sessionInformation(), 
[16:59:31.825]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:31.825]                   signalCondition(cond)
[16:59:31.825]                 }
[16:59:31.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:31.825]                 "immediateCondition"))) {
[16:59:31.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:31.825]                   ...future.conditions[[length(...future.conditions) + 
[16:59:31.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:31.825]                   if (TRUE && !signal) {
[16:59:31.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.825]                     {
[16:59:31.825]                       inherits <- base::inherits
[16:59:31.825]                       invokeRestart <- base::invokeRestart
[16:59:31.825]                       is.null <- base::is.null
[16:59:31.825]                       muffled <- FALSE
[16:59:31.825]                       if (inherits(cond, "message")) {
[16:59:31.825]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:31.825]                         if (muffled) 
[16:59:31.825]                           invokeRestart("muffleMessage")
[16:59:31.825]                       }
[16:59:31.825]                       else if (inherits(cond, "warning")) {
[16:59:31.825]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:31.825]                         if (muffled) 
[16:59:31.825]                           invokeRestart("muffleWarning")
[16:59:31.825]                       }
[16:59:31.825]                       else if (inherits(cond, "condition")) {
[16:59:31.825]                         if (!is.null(pattern)) {
[16:59:31.825]                           computeRestarts <- base::computeRestarts
[16:59:31.825]                           grepl <- base::grepl
[16:59:31.825]                           restarts <- computeRestarts(cond)
[16:59:31.825]                           for (restart in restarts) {
[16:59:31.825]                             name <- restart$name
[16:59:31.825]                             if (is.null(name)) 
[16:59:31.825]                               next
[16:59:31.825]                             if (!grepl(pattern, name)) 
[16:59:31.825]                               next
[16:59:31.825]                             invokeRestart(restart)
[16:59:31.825]                             muffled <- TRUE
[16:59:31.825]                             break
[16:59:31.825]                           }
[16:59:31.825]                         }
[16:59:31.825]                       }
[16:59:31.825]                       invisible(muffled)
[16:59:31.825]                     }
[16:59:31.825]                     muffleCondition(cond, pattern = "^muffle")
[16:59:31.825]                   }
[16:59:31.825]                 }
[16:59:31.825]                 else {
[16:59:31.825]                   if (TRUE) {
[16:59:31.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:31.825]                     {
[16:59:31.825]                       inherits <- base::inherits
[16:59:31.825]                       invokeRestart <- base::invokeRestart
[16:59:31.825]                       is.null <- base::is.null
[16:59:31.825]                       muffled <- FALSE
[16:59:31.825]                       if (inherits(cond, "message")) {
[16:59:31.825]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:31.825]                         if (muffled) 
[16:59:31.825]                           invokeRestart("muffleMessage")
[16:59:31.825]                       }
[16:59:31.825]                       else if (inherits(cond, "warning")) {
[16:59:31.825]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:31.825]                         if (muffled) 
[16:59:31.825]                           invokeRestart("muffleWarning")
[16:59:31.825]                       }
[16:59:31.825]                       else if (inherits(cond, "condition")) {
[16:59:31.825]                         if (!is.null(pattern)) {
[16:59:31.825]                           computeRestarts <- base::computeRestarts
[16:59:31.825]                           grepl <- base::grepl
[16:59:31.825]                           restarts <- computeRestarts(cond)
[16:59:31.825]                           for (restart in restarts) {
[16:59:31.825]                             name <- restart$name
[16:59:31.825]                             if (is.null(name)) 
[16:59:31.825]                               next
[16:59:31.825]                             if (!grepl(pattern, name)) 
[16:59:31.825]                               next
[16:59:31.825]                             invokeRestart(restart)
[16:59:31.825]                             muffled <- TRUE
[16:59:31.825]                             break
[16:59:31.825]                           }
[16:59:31.825]                         }
[16:59:31.825]                       }
[16:59:31.825]                       invisible(muffled)
[16:59:31.825]                     }
[16:59:31.825]                     muffleCondition(cond, pattern = "^muffle")
[16:59:31.825]                   }
[16:59:31.825]                 }
[16:59:31.825]             }
[16:59:31.825]         }))
[16:59:31.825]     }, error = function(ex) {
[16:59:31.825]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:31.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:31.825]                 ...future.rng), started = ...future.startTime, 
[16:59:31.825]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:31.825]             version = "1.8"), class = "FutureResult")
[16:59:31.825]     }, finally = {
[16:59:31.825]         if (!identical(...future.workdir, getwd())) 
[16:59:31.825]             setwd(...future.workdir)
[16:59:31.825]         {
[16:59:31.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:31.825]                 ...future.oldOptions$nwarnings <- NULL
[16:59:31.825]             }
[16:59:31.825]             base::options(...future.oldOptions)
[16:59:31.825]             if (.Platform$OS.type == "windows") {
[16:59:31.825]                 old_names <- names(...future.oldEnvVars)
[16:59:31.825]                 envs <- base::Sys.getenv()
[16:59:31.825]                 names <- names(envs)
[16:59:31.825]                 common <- intersect(names, old_names)
[16:59:31.825]                 added <- setdiff(names, old_names)
[16:59:31.825]                 removed <- setdiff(old_names, names)
[16:59:31.825]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:31.825]                   envs[common]]
[16:59:31.825]                 NAMES <- toupper(changed)
[16:59:31.825]                 args <- list()
[16:59:31.825]                 for (kk in seq_along(NAMES)) {
[16:59:31.825]                   name <- changed[[kk]]
[16:59:31.825]                   NAME <- NAMES[[kk]]
[16:59:31.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.825]                     next
[16:59:31.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:31.825]                 }
[16:59:31.825]                 NAMES <- toupper(added)
[16:59:31.825]                 for (kk in seq_along(NAMES)) {
[16:59:31.825]                   name <- added[[kk]]
[16:59:31.825]                   NAME <- NAMES[[kk]]
[16:59:31.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.825]                     next
[16:59:31.825]                   args[[name]] <- ""
[16:59:31.825]                 }
[16:59:31.825]                 NAMES <- toupper(removed)
[16:59:31.825]                 for (kk in seq_along(NAMES)) {
[16:59:31.825]                   name <- removed[[kk]]
[16:59:31.825]                   NAME <- NAMES[[kk]]
[16:59:31.825]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:31.825]                     next
[16:59:31.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:31.825]                 }
[16:59:31.825]                 if (length(args) > 0) 
[16:59:31.825]                   base::do.call(base::Sys.setenv, args = args)
[16:59:31.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:31.825]             }
[16:59:31.825]             else {
[16:59:31.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:31.825]             }
[16:59:31.825]             {
[16:59:31.825]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:31.825]                   0L) {
[16:59:31.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:31.825]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:31.825]                   base::options(opts)
[16:59:31.825]                 }
[16:59:31.825]                 {
[16:59:31.825]                   {
[16:59:31.825]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:31.825]                     NULL
[16:59:31.825]                   }
[16:59:31.825]                   options(future.plan = NULL)
[16:59:31.825]                   if (is.na(NA_character_)) 
[16:59:31.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:31.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:31.825]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:31.825]                     .init = FALSE)
[16:59:31.825]                 }
[16:59:31.825]             }
[16:59:31.825]         }
[16:59:31.825]     })
[16:59:31.825]     if (TRUE) {
[16:59:31.825]         base::sink(type = "output", split = FALSE)
[16:59:31.825]         if (TRUE) {
[16:59:31.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:31.825]         }
[16:59:31.825]         else {
[16:59:31.825]             ...future.result["stdout"] <- base::list(NULL)
[16:59:31.825]         }
[16:59:31.825]         base::close(...future.stdout)
[16:59:31.825]         ...future.stdout <- NULL
[16:59:31.825]     }
[16:59:31.825]     ...future.result$conditions <- ...future.conditions
[16:59:31.825]     ...future.result$finished <- base::Sys.time()
[16:59:31.825]     ...future.result
[16:59:31.825] }
[16:59:31.877] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[16:59:31.877] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:31.878] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:31.878] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:59:31.920] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:59:31.920] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:59:31.921] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:59:31.921] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:31.921] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:31.921] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:31.922] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:31.922] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[16:59:31.923] MultisessionFuture started
[16:59:31.923] - Launch lazy future ... done
[16:59:31.923] run() for ‘MultisessionFuture’ ... done
[16:59:31.923] Created future:
[16:59:31.923] MultisessionFuture:
[16:59:31.923] Label: ‘future_apply-2’
[16:59:31.923] Expression:
[16:59:31.923] {
[16:59:31.923]     do.call(function(...) {
[16:59:31.923]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:31.923]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:31.923]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:31.923]             on.exit(options(oopts), add = TRUE)
[16:59:31.923]         }
[16:59:31.923]         {
[16:59:31.923]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:31.923]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:31.923]                 ...future.FUN(...future.X_jj, ...)
[16:59:31.923]             })
[16:59:31.923]         }
[16:59:31.923]     }, args = future.call.arguments)
[16:59:31.923] }
[16:59:31.923] Lazy evaluation: FALSE
[16:59:31.923] Asynchronous evaluation: TRUE
[16:59:31.923] Local evaluation: TRUE
[16:59:31.923] Environment: R_GlobalEnv
[16:59:31.923] Capture standard output: TRUE
[16:59:31.923] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:31.923] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:31.923] Packages: <none>
[16:59:31.923] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:31.923] Resolved: FALSE
[16:59:31.923] Value: <not collected>
[16:59:31.923] Conditions captured: <none>
[16:59:31.923] Early signaling: FALSE
[16:59:31.923] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:31.923] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:31.935] Chunk #2 of 2 ... DONE
[16:59:31.935] Launching 2 futures (chunks) ... DONE
[16:59:31.935] Resolving 2 futures (chunks) ...
[16:59:31.935] resolve() on list ...
[16:59:31.936]  recursive: 0
[16:59:31.936]  length: 2
[16:59:31.936] 
[16:59:31.936] receiveMessageFromWorker() for ClusterFuture ...
[16:59:31.936] - Validating connection of MultisessionFuture
[16:59:31.937] - received message: FutureResult
[16:59:31.937] - Received FutureResult
[16:59:31.937] - Erased future from FutureRegistry
[16:59:31.937] result() for ClusterFuture ...
[16:59:31.937] - result already collected: FutureResult
[16:59:31.937] result() for ClusterFuture ... done
[16:59:31.937] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:31.937] Future #1
[16:59:31.937] result() for ClusterFuture ...
[16:59:31.937] - result already collected: FutureResult
[16:59:31.938] result() for ClusterFuture ... done
[16:59:31.938] result() for ClusterFuture ...
[16:59:31.938] - result already collected: FutureResult
[16:59:31.938] result() for ClusterFuture ... done
[16:59:31.938] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:31.938] - nx: 2
[16:59:31.938] - relay: TRUE
[16:59:31.938] - stdout: TRUE
[16:59:31.938] - signal: TRUE
[16:59:31.938] - resignal: FALSE
[16:59:31.938] - force: TRUE
[16:59:31.938] - relayed: [n=2] FALSE, FALSE
[16:59:31.938] - queued futures: [n=2] FALSE, FALSE
[16:59:31.939]  - until=1
[16:59:31.939]  - relaying element #1
[16:59:31.939] result() for ClusterFuture ...
[16:59:31.939] - result already collected: FutureResult
[16:59:31.939] result() for ClusterFuture ... done
[16:59:31.939] result() for ClusterFuture ...
[16:59:31.939] - result already collected: FutureResult
[16:59:31.939] result() for ClusterFuture ... done
[16:59:31.939] result() for ClusterFuture ...
[16:59:31.939] - result already collected: FutureResult
[16:59:31.939] result() for ClusterFuture ... done
[16:59:31.940] result() for ClusterFuture ...
[16:59:31.940] - result already collected: FutureResult
[16:59:31.940] result() for ClusterFuture ... done
[16:59:31.940] - relayed: [n=2] TRUE, FALSE
[16:59:31.940] - queued futures: [n=2] TRUE, FALSE
[16:59:31.940] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:31.940]  length: 1 (resolved future 1)
[16:59:32.003] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.003] - Validating connection of MultisessionFuture
[16:59:32.004] - received message: FutureResult
[16:59:32.004] - Received FutureResult
[16:59:32.004] - Erased future from FutureRegistry
[16:59:32.004] result() for ClusterFuture ...
[16:59:32.004] - result already collected: FutureResult
[16:59:32.004] result() for ClusterFuture ... done
[16:59:32.004] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.004] Future #2
[16:59:32.004] result() for ClusterFuture ...
[16:59:32.004] - result already collected: FutureResult
[16:59:32.005] result() for ClusterFuture ... done
[16:59:32.005] result() for ClusterFuture ...
[16:59:32.005] - result already collected: FutureResult
[16:59:32.005] result() for ClusterFuture ... done
[16:59:32.005] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.005] - nx: 2
[16:59:32.005] - relay: TRUE
[16:59:32.005] - stdout: TRUE
[16:59:32.005] - signal: TRUE
[16:59:32.005] - resignal: FALSE
[16:59:32.005] - force: TRUE
[16:59:32.005] - relayed: [n=2] TRUE, FALSE
[16:59:32.006] - queued futures: [n=2] TRUE, FALSE
[16:59:32.006]  - until=2
[16:59:32.006]  - relaying element #2
[16:59:32.006] result() for ClusterFuture ...
[16:59:32.006] - result already collected: FutureResult
[16:59:32.006] result() for ClusterFuture ... done
[16:59:32.006] result() for ClusterFuture ...
[16:59:32.006] - result already collected: FutureResult
[16:59:32.006] result() for ClusterFuture ... done
[16:59:32.006] result() for ClusterFuture ...
[16:59:32.006] - result already collected: FutureResult
[16:59:32.007] result() for ClusterFuture ... done
[16:59:32.007] result() for ClusterFuture ...
[16:59:32.007] - result already collected: FutureResult
[16:59:32.007] result() for ClusterFuture ... done
[16:59:32.007] - relayed: [n=2] TRUE, TRUE
[16:59:32.007] - queued futures: [n=2] TRUE, TRUE
[16:59:32.007] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.007]  length: 0 (resolved future 2)
[16:59:32.007] Relaying remaining futures
[16:59:32.007] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.007] - nx: 2
[16:59:32.008] - relay: TRUE
[16:59:32.008] - stdout: TRUE
[16:59:32.008] - signal: TRUE
[16:59:32.008] - resignal: FALSE
[16:59:32.008] - force: TRUE
[16:59:32.008] - relayed: [n=2] TRUE, TRUE
[16:59:32.008] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.008] - relayed: [n=2] TRUE, TRUE
[16:59:32.008] - queued futures: [n=2] TRUE, TRUE
[16:59:32.008] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.008] resolve() on list ... DONE
[16:59:32.008] result() for ClusterFuture ...
[16:59:32.009] - result already collected: FutureResult
[16:59:32.009] result() for ClusterFuture ... done
[16:59:32.009] result() for ClusterFuture ...
[16:59:32.009] - result already collected: FutureResult
[16:59:32.009] result() for ClusterFuture ... done
[16:59:32.009] result() for ClusterFuture ...
[16:59:32.009] - result already collected: FutureResult
[16:59:32.009] result() for ClusterFuture ... done
[16:59:32.009] result() for ClusterFuture ...
[16:59:32.009] - result already collected: FutureResult
[16:59:32.009] result() for ClusterFuture ... done
[16:59:32.009]  - Number of value chunks collected: 2
[16:59:32.010] Resolving 2 futures (chunks) ... DONE
[16:59:32.010] Reducing values from 2 chunks ...
[16:59:32.010]  - Number of values collected after concatenation: 2
[16:59:32.010]  - Number of values expected: 2
[16:59:32.010] Reducing values from 2 chunks ... DONE
[16:59:32.010] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:59:32.010] getGlobalsAndPackagesXApply() ...
[16:59:32.011]  - future.globals: TRUE
[16:59:32.011] getGlobalsAndPackages() ...
[16:59:32.011] Searching for globals...
[16:59:32.041] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[16:59:32.041] Searching for globals ... DONE
[16:59:32.041] Resolving globals: FALSE
[16:59:32.043] The total size of the 1 globals is 345.92 KiB (354224 bytes)
[16:59:32.043] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 345.92 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (345.92 KiB of class ‘function’)
[16:59:32.044] - globals: [1] ‘FUN’
[16:59:32.044] 
[16:59:32.044] getGlobalsAndPackages() ... DONE
[16:59:32.044]  - globals found/used: [n=1] ‘FUN’
[16:59:32.044]  - needed namespaces: [n=0] 
[16:59:32.044] Finding globals ... DONE
[16:59:32.044]  - use_args: TRUE
[16:59:32.044]  - Getting '...' globals ...
[16:59:32.045] resolve() on list ...
[16:59:32.045]  recursive: 0
[16:59:32.045]  length: 1
[16:59:32.045]  elements: ‘...’
[16:59:32.045]  length: 0 (resolved future 1)
[16:59:32.045] resolve() on list ... DONE
[16:59:32.045]    - '...' content: [n=0] 
[16:59:32.045] List of 1
[16:59:32.045]  $ ...: list()
[16:59:32.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.045]  - attr(*, "where")=List of 1
[16:59:32.045]   ..$ ...:<environment: 0x55f3124ef180> 
[16:59:32.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.045]  - attr(*, "resolved")= logi TRUE
[16:59:32.045]  - attr(*, "total_size")= num NA
[16:59:32.048]  - Getting '...' globals ... DONE
[16:59:32.048] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:32.048] List of 2
[16:59:32.048]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:32.048]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:32.048]  $ ...          : list()
[16:59:32.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.048]  - attr(*, "where")=List of 2
[16:59:32.048]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:32.048]   ..$ ...          :<environment: 0x55f3124ef180> 
[16:59:32.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.048]  - attr(*, "resolved")= logi FALSE
[16:59:32.048]  - attr(*, "total_size")= num 354224
[16:59:32.051] Packages to be attached in all futures: [n=0] 
[16:59:32.051] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.054] future_lapply() ...
[16:59:32.093] Number of chunks: 2
[16:59:32.093] getGlobalsAndPackagesXApply() ...
[16:59:32.093]  - future.globals: <name-value list> with names ‘list()’
[16:59:32.093]  - use_args: TRUE
[16:59:32.093] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:32.094] List of 2
[16:59:32.094]  $ ...          : list()
[16:59:32.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.094]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[16:59:32.094]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[16:59:32.094]  - attr(*, "where")=List of 2
[16:59:32.094]   ..$ ...          :<environment: 0x55f3124ef180> 
[16:59:32.094]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:32.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.094]  - attr(*, "resolved")= logi FALSE
[16:59:32.094]  - attr(*, "total_size")= num NA
[16:59:32.098] Packages to be attached in all futures: [n=0] 
[16:59:32.098] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.098] Number of futures (= number of chunks): 2
[16:59:32.098] Launching 2 futures (chunks) ...
[16:59:32.098] Chunk #1 of 2 ...
[16:59:32.098]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.098]  - seeds: <none>
[16:59:32.098]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.099] getGlobalsAndPackages() ...
[16:59:32.099] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.099] Resolving globals: FALSE
[16:59:32.099] Tweak future expression to call with '...' arguments ...
[16:59:32.099] {
[16:59:32.099]     do.call(function(...) {
[16:59:32.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.099]             on.exit(options(oopts), add = TRUE)
[16:59:32.099]         }
[16:59:32.099]         {
[16:59:32.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.099]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.099]             })
[16:59:32.099]         }
[16:59:32.099]     }, args = future.call.arguments)
[16:59:32.099] }
[16:59:32.099] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.100] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.100] 
[16:59:32.100] getGlobalsAndPackages() ... DONE
[16:59:32.100] run() for ‘Future’ ...
[16:59:32.100] - state: ‘created’
[16:59:32.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.114] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.114] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.115]   - Field: ‘node’
[16:59:32.115]   - Field: ‘label’
[16:59:32.115]   - Field: ‘local’
[16:59:32.115]   - Field: ‘owner’
[16:59:32.115]   - Field: ‘envir’
[16:59:32.115]   - Field: ‘workers’
[16:59:32.115]   - Field: ‘packages’
[16:59:32.115]   - Field: ‘gc’
[16:59:32.115]   - Field: ‘conditions’
[16:59:32.116]   - Field: ‘persistent’
[16:59:32.116]   - Field: ‘expr’
[16:59:32.116]   - Field: ‘uuid’
[16:59:32.116]   - Field: ‘seed’
[16:59:32.116]   - Field: ‘version’
[16:59:32.116]   - Field: ‘result’
[16:59:32.116]   - Field: ‘asynchronous’
[16:59:32.116]   - Field: ‘calls’
[16:59:32.116]   - Field: ‘globals’
[16:59:32.116]   - Field: ‘stdout’
[16:59:32.116]   - Field: ‘earlySignal’
[16:59:32.117]   - Field: ‘lazy’
[16:59:32.117]   - Field: ‘state’
[16:59:32.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.117] - Launch lazy future ...
[16:59:32.117] Packages needed by the future expression (n = 0): <none>
[16:59:32.117] Packages needed by future strategies (n = 0): <none>
[16:59:32.118] {
[16:59:32.118]     {
[16:59:32.118]         {
[16:59:32.118]             ...future.startTime <- base::Sys.time()
[16:59:32.118]             {
[16:59:32.118]                 {
[16:59:32.118]                   {
[16:59:32.118]                     {
[16:59:32.118]                       base::local({
[16:59:32.118]                         has_future <- base::requireNamespace("future", 
[16:59:32.118]                           quietly = TRUE)
[16:59:32.118]                         if (has_future) {
[16:59:32.118]                           ns <- base::getNamespace("future")
[16:59:32.118]                           version <- ns[[".package"]][["version"]]
[16:59:32.118]                           if (is.null(version)) 
[16:59:32.118]                             version <- utils::packageVersion("future")
[16:59:32.118]                         }
[16:59:32.118]                         else {
[16:59:32.118]                           version <- NULL
[16:59:32.118]                         }
[16:59:32.118]                         if (!has_future || version < "1.8.0") {
[16:59:32.118]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.118]                             "", base::R.version$version.string), 
[16:59:32.118]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.118]                               "release", "version")], collapse = " "), 
[16:59:32.118]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.118]                             info)
[16:59:32.118]                           info <- base::paste(info, collapse = "; ")
[16:59:32.118]                           if (!has_future) {
[16:59:32.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.118]                               info)
[16:59:32.118]                           }
[16:59:32.118]                           else {
[16:59:32.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.118]                               info, version)
[16:59:32.118]                           }
[16:59:32.118]                           base::stop(msg)
[16:59:32.118]                         }
[16:59:32.118]                       })
[16:59:32.118]                     }
[16:59:32.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.118]                     base::options(mc.cores = 1L)
[16:59:32.118]                   }
[16:59:32.118]                   ...future.strategy.old <- future::plan("list")
[16:59:32.118]                   options(future.plan = NULL)
[16:59:32.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.118]                 }
[16:59:32.118]                 ...future.workdir <- getwd()
[16:59:32.118]             }
[16:59:32.118]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.118]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.118]         }
[16:59:32.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.118]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.118]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.118]             base::names(...future.oldOptions))
[16:59:32.118]     }
[16:59:32.118]     if (FALSE) {
[16:59:32.118]     }
[16:59:32.118]     else {
[16:59:32.118]         if (TRUE) {
[16:59:32.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.118]                 open = "w")
[16:59:32.118]         }
[16:59:32.118]         else {
[16:59:32.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.118]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.118]         }
[16:59:32.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.118]             base::sink(type = "output", split = FALSE)
[16:59:32.118]             base::close(...future.stdout)
[16:59:32.118]         }, add = TRUE)
[16:59:32.118]     }
[16:59:32.118]     ...future.frame <- base::sys.nframe()
[16:59:32.118]     ...future.conditions <- base::list()
[16:59:32.118]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.118]     if (FALSE) {
[16:59:32.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.118]     }
[16:59:32.118]     ...future.result <- base::tryCatch({
[16:59:32.118]         base::withCallingHandlers({
[16:59:32.118]             ...future.value <- base::withVisible(base::local({
[16:59:32.118]                 ...future.makeSendCondition <- base::local({
[16:59:32.118]                   sendCondition <- NULL
[16:59:32.118]                   function(frame = 1L) {
[16:59:32.118]                     if (is.function(sendCondition)) 
[16:59:32.118]                       return(sendCondition)
[16:59:32.118]                     ns <- getNamespace("parallel")
[16:59:32.118]                     if (exists("sendData", mode = "function", 
[16:59:32.118]                       envir = ns)) {
[16:59:32.118]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.118]                         envir = ns)
[16:59:32.118]                       envir <- sys.frame(frame)
[16:59:32.118]                       master <- NULL
[16:59:32.118]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.118]                         !identical(envir, emptyenv())) {
[16:59:32.118]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.118]                           inherits = FALSE)) {
[16:59:32.118]                           master <- get("master", mode = "list", 
[16:59:32.118]                             envir = envir, inherits = FALSE)
[16:59:32.118]                           if (inherits(master, c("SOCKnode", 
[16:59:32.118]                             "SOCK0node"))) {
[16:59:32.118]                             sendCondition <<- function(cond) {
[16:59:32.118]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.118]                                 success = TRUE)
[16:59:32.118]                               parallel_sendData(master, data)
[16:59:32.118]                             }
[16:59:32.118]                             return(sendCondition)
[16:59:32.118]                           }
[16:59:32.118]                         }
[16:59:32.118]                         frame <- frame + 1L
[16:59:32.118]                         envir <- sys.frame(frame)
[16:59:32.118]                       }
[16:59:32.118]                     }
[16:59:32.118]                     sendCondition <<- function(cond) NULL
[16:59:32.118]                   }
[16:59:32.118]                 })
[16:59:32.118]                 withCallingHandlers({
[16:59:32.118]                   {
[16:59:32.118]                     do.call(function(...) {
[16:59:32.118]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.118]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.118]                         ...future.globals.maxSize)) {
[16:59:32.118]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.118]                         on.exit(options(oopts), add = TRUE)
[16:59:32.118]                       }
[16:59:32.118]                       {
[16:59:32.118]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.118]                           FUN = function(jj) {
[16:59:32.118]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.118]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.118]                           })
[16:59:32.118]                       }
[16:59:32.118]                     }, args = future.call.arguments)
[16:59:32.118]                   }
[16:59:32.118]                 }, immediateCondition = function(cond) {
[16:59:32.118]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.118]                   sendCondition(cond)
[16:59:32.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.118]                   {
[16:59:32.118]                     inherits <- base::inherits
[16:59:32.118]                     invokeRestart <- base::invokeRestart
[16:59:32.118]                     is.null <- base::is.null
[16:59:32.118]                     muffled <- FALSE
[16:59:32.118]                     if (inherits(cond, "message")) {
[16:59:32.118]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.118]                       if (muffled) 
[16:59:32.118]                         invokeRestart("muffleMessage")
[16:59:32.118]                     }
[16:59:32.118]                     else if (inherits(cond, "warning")) {
[16:59:32.118]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.118]                       if (muffled) 
[16:59:32.118]                         invokeRestart("muffleWarning")
[16:59:32.118]                     }
[16:59:32.118]                     else if (inherits(cond, "condition")) {
[16:59:32.118]                       if (!is.null(pattern)) {
[16:59:32.118]                         computeRestarts <- base::computeRestarts
[16:59:32.118]                         grepl <- base::grepl
[16:59:32.118]                         restarts <- computeRestarts(cond)
[16:59:32.118]                         for (restart in restarts) {
[16:59:32.118]                           name <- restart$name
[16:59:32.118]                           if (is.null(name)) 
[16:59:32.118]                             next
[16:59:32.118]                           if (!grepl(pattern, name)) 
[16:59:32.118]                             next
[16:59:32.118]                           invokeRestart(restart)
[16:59:32.118]                           muffled <- TRUE
[16:59:32.118]                           break
[16:59:32.118]                         }
[16:59:32.118]                       }
[16:59:32.118]                     }
[16:59:32.118]                     invisible(muffled)
[16:59:32.118]                   }
[16:59:32.118]                   muffleCondition(cond)
[16:59:32.118]                 })
[16:59:32.118]             }))
[16:59:32.118]             future::FutureResult(value = ...future.value$value, 
[16:59:32.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.118]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.118]                     ...future.globalenv.names))
[16:59:32.118]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.118]         }, condition = base::local({
[16:59:32.118]             c <- base::c
[16:59:32.118]             inherits <- base::inherits
[16:59:32.118]             invokeRestart <- base::invokeRestart
[16:59:32.118]             length <- base::length
[16:59:32.118]             list <- base::list
[16:59:32.118]             seq.int <- base::seq.int
[16:59:32.118]             signalCondition <- base::signalCondition
[16:59:32.118]             sys.calls <- base::sys.calls
[16:59:32.118]             `[[` <- base::`[[`
[16:59:32.118]             `+` <- base::`+`
[16:59:32.118]             `<<-` <- base::`<<-`
[16:59:32.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.118]                   3L)]
[16:59:32.118]             }
[16:59:32.118]             function(cond) {
[16:59:32.118]                 is_error <- inherits(cond, "error")
[16:59:32.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.118]                   NULL)
[16:59:32.118]                 if (is_error) {
[16:59:32.118]                   sessionInformation <- function() {
[16:59:32.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.118]                       search = base::search(), system = base::Sys.info())
[16:59:32.118]                   }
[16:59:32.118]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.118]                     cond$call), session = sessionInformation(), 
[16:59:32.118]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.118]                   signalCondition(cond)
[16:59:32.118]                 }
[16:59:32.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.118]                 "immediateCondition"))) {
[16:59:32.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.118]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.118]                   if (TRUE && !signal) {
[16:59:32.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.118]                     {
[16:59:32.118]                       inherits <- base::inherits
[16:59:32.118]                       invokeRestart <- base::invokeRestart
[16:59:32.118]                       is.null <- base::is.null
[16:59:32.118]                       muffled <- FALSE
[16:59:32.118]                       if (inherits(cond, "message")) {
[16:59:32.118]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.118]                         if (muffled) 
[16:59:32.118]                           invokeRestart("muffleMessage")
[16:59:32.118]                       }
[16:59:32.118]                       else if (inherits(cond, "warning")) {
[16:59:32.118]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.118]                         if (muffled) 
[16:59:32.118]                           invokeRestart("muffleWarning")
[16:59:32.118]                       }
[16:59:32.118]                       else if (inherits(cond, "condition")) {
[16:59:32.118]                         if (!is.null(pattern)) {
[16:59:32.118]                           computeRestarts <- base::computeRestarts
[16:59:32.118]                           grepl <- base::grepl
[16:59:32.118]                           restarts <- computeRestarts(cond)
[16:59:32.118]                           for (restart in restarts) {
[16:59:32.118]                             name <- restart$name
[16:59:32.118]                             if (is.null(name)) 
[16:59:32.118]                               next
[16:59:32.118]                             if (!grepl(pattern, name)) 
[16:59:32.118]                               next
[16:59:32.118]                             invokeRestart(restart)
[16:59:32.118]                             muffled <- TRUE
[16:59:32.118]                             break
[16:59:32.118]                           }
[16:59:32.118]                         }
[16:59:32.118]                       }
[16:59:32.118]                       invisible(muffled)
[16:59:32.118]                     }
[16:59:32.118]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.118]                   }
[16:59:32.118]                 }
[16:59:32.118]                 else {
[16:59:32.118]                   if (TRUE) {
[16:59:32.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.118]                     {
[16:59:32.118]                       inherits <- base::inherits
[16:59:32.118]                       invokeRestart <- base::invokeRestart
[16:59:32.118]                       is.null <- base::is.null
[16:59:32.118]                       muffled <- FALSE
[16:59:32.118]                       if (inherits(cond, "message")) {
[16:59:32.118]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.118]                         if (muffled) 
[16:59:32.118]                           invokeRestart("muffleMessage")
[16:59:32.118]                       }
[16:59:32.118]                       else if (inherits(cond, "warning")) {
[16:59:32.118]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.118]                         if (muffled) 
[16:59:32.118]                           invokeRestart("muffleWarning")
[16:59:32.118]                       }
[16:59:32.118]                       else if (inherits(cond, "condition")) {
[16:59:32.118]                         if (!is.null(pattern)) {
[16:59:32.118]                           computeRestarts <- base::computeRestarts
[16:59:32.118]                           grepl <- base::grepl
[16:59:32.118]                           restarts <- computeRestarts(cond)
[16:59:32.118]                           for (restart in restarts) {
[16:59:32.118]                             name <- restart$name
[16:59:32.118]                             if (is.null(name)) 
[16:59:32.118]                               next
[16:59:32.118]                             if (!grepl(pattern, name)) 
[16:59:32.118]                               next
[16:59:32.118]                             invokeRestart(restart)
[16:59:32.118]                             muffled <- TRUE
[16:59:32.118]                             break
[16:59:32.118]                           }
[16:59:32.118]                         }
[16:59:32.118]                       }
[16:59:32.118]                       invisible(muffled)
[16:59:32.118]                     }
[16:59:32.118]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.118]                   }
[16:59:32.118]                 }
[16:59:32.118]             }
[16:59:32.118]         }))
[16:59:32.118]     }, error = function(ex) {
[16:59:32.118]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.118]                 ...future.rng), started = ...future.startTime, 
[16:59:32.118]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.118]             version = "1.8"), class = "FutureResult")
[16:59:32.118]     }, finally = {
[16:59:32.118]         if (!identical(...future.workdir, getwd())) 
[16:59:32.118]             setwd(...future.workdir)
[16:59:32.118]         {
[16:59:32.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.118]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.118]             }
[16:59:32.118]             base::options(...future.oldOptions)
[16:59:32.118]             if (.Platform$OS.type == "windows") {
[16:59:32.118]                 old_names <- names(...future.oldEnvVars)
[16:59:32.118]                 envs <- base::Sys.getenv()
[16:59:32.118]                 names <- names(envs)
[16:59:32.118]                 common <- intersect(names, old_names)
[16:59:32.118]                 added <- setdiff(names, old_names)
[16:59:32.118]                 removed <- setdiff(old_names, names)
[16:59:32.118]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.118]                   envs[common]]
[16:59:32.118]                 NAMES <- toupper(changed)
[16:59:32.118]                 args <- list()
[16:59:32.118]                 for (kk in seq_along(NAMES)) {
[16:59:32.118]                   name <- changed[[kk]]
[16:59:32.118]                   NAME <- NAMES[[kk]]
[16:59:32.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.118]                     next
[16:59:32.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.118]                 }
[16:59:32.118]                 NAMES <- toupper(added)
[16:59:32.118]                 for (kk in seq_along(NAMES)) {
[16:59:32.118]                   name <- added[[kk]]
[16:59:32.118]                   NAME <- NAMES[[kk]]
[16:59:32.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.118]                     next
[16:59:32.118]                   args[[name]] <- ""
[16:59:32.118]                 }
[16:59:32.118]                 NAMES <- toupper(removed)
[16:59:32.118]                 for (kk in seq_along(NAMES)) {
[16:59:32.118]                   name <- removed[[kk]]
[16:59:32.118]                   NAME <- NAMES[[kk]]
[16:59:32.118]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.118]                     next
[16:59:32.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.118]                 }
[16:59:32.118]                 if (length(args) > 0) 
[16:59:32.118]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.118]             }
[16:59:32.118]             else {
[16:59:32.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.118]             }
[16:59:32.118]             {
[16:59:32.118]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.118]                   0L) {
[16:59:32.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.118]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.118]                   base::options(opts)
[16:59:32.118]                 }
[16:59:32.118]                 {
[16:59:32.118]                   {
[16:59:32.118]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.118]                     NULL
[16:59:32.118]                   }
[16:59:32.118]                   options(future.plan = NULL)
[16:59:32.118]                   if (is.na(NA_character_)) 
[16:59:32.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.118]                     .init = FALSE)
[16:59:32.118]                 }
[16:59:32.118]             }
[16:59:32.118]         }
[16:59:32.118]     })
[16:59:32.118]     if (TRUE) {
[16:59:32.118]         base::sink(type = "output", split = FALSE)
[16:59:32.118]         if (TRUE) {
[16:59:32.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.118]         }
[16:59:32.118]         else {
[16:59:32.118]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.118]         }
[16:59:32.118]         base::close(...future.stdout)
[16:59:32.118]         ...future.stdout <- NULL
[16:59:32.118]     }
[16:59:32.118]     ...future.result$conditions <- ...future.conditions
[16:59:32.118]     ...future.result$finished <- base::Sys.time()
[16:59:32.118]     ...future.result
[16:59:32.118] }
[16:59:32.121] Exporting 5 global objects (346.05 KiB) to cluster node #1 ...
[16:59:32.121] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.122] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.122] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ...
[16:59:32.168] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #1 ... DONE
[16:59:32.168] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:59:32.169] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:59:32.169] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.169] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.169] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.170] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.170] Exporting 5 global objects (346.05 KiB) to cluster node #1 ... DONE
[16:59:32.170] MultisessionFuture started
[16:59:32.171] - Launch lazy future ... done
[16:59:32.171] run() for ‘MultisessionFuture’ ... done
[16:59:32.171] Created future:
[16:59:32.171] MultisessionFuture:
[16:59:32.171] Label: ‘future_apply-1’
[16:59:32.171] Expression:
[16:59:32.171] {
[16:59:32.171]     do.call(function(...) {
[16:59:32.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.171]             on.exit(options(oopts), add = TRUE)
[16:59:32.171]         }
[16:59:32.171]         {
[16:59:32.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.171]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.171]             })
[16:59:32.171]         }
[16:59:32.171]     }, args = future.call.arguments)
[16:59:32.171] }
[16:59:32.171] Lazy evaluation: FALSE
[16:59:32.171] Asynchronous evaluation: TRUE
[16:59:32.171] Local evaluation: TRUE
[16:59:32.171] Environment: R_GlobalEnv
[16:59:32.171] Capture standard output: TRUE
[16:59:32.171] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.171] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.171] Packages: <none>
[16:59:32.171] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.171] Resolved: FALSE
[16:59:32.171] Value: <not collected>
[16:59:32.171] Conditions captured: <none>
[16:59:32.171] Early signaling: FALSE
[16:59:32.171] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.171] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.183] Chunk #1 of 2 ... DONE
[16:59:32.183] Chunk #2 of 2 ...
[16:59:32.183]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.184]  - seeds: <none>
[16:59:32.184]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.184] getGlobalsAndPackages() ...
[16:59:32.184] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.184] Resolving globals: FALSE
[16:59:32.184] Tweak future expression to call with '...' arguments ...
[16:59:32.184] {
[16:59:32.184]     do.call(function(...) {
[16:59:32.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.184]             on.exit(options(oopts), add = TRUE)
[16:59:32.184]         }
[16:59:32.184]         {
[16:59:32.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.184]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.184]             })
[16:59:32.184]         }
[16:59:32.184]     }, args = future.call.arguments)
[16:59:32.184] }
[16:59:32.185] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.185] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.185] 
[16:59:32.185] getGlobalsAndPackages() ... DONE
[16:59:32.186] run() for ‘Future’ ...
[16:59:32.186] - state: ‘created’
[16:59:32.186] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.200] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.201]   - Field: ‘node’
[16:59:32.201]   - Field: ‘label’
[16:59:32.201]   - Field: ‘local’
[16:59:32.201]   - Field: ‘owner’
[16:59:32.201]   - Field: ‘envir’
[16:59:32.201]   - Field: ‘workers’
[16:59:32.201]   - Field: ‘packages’
[16:59:32.201]   - Field: ‘gc’
[16:59:32.201]   - Field: ‘conditions’
[16:59:32.202]   - Field: ‘persistent’
[16:59:32.202]   - Field: ‘expr’
[16:59:32.202]   - Field: ‘uuid’
[16:59:32.202]   - Field: ‘seed’
[16:59:32.202]   - Field: ‘version’
[16:59:32.202]   - Field: ‘result’
[16:59:32.202]   - Field: ‘asynchronous’
[16:59:32.202]   - Field: ‘calls’
[16:59:32.202]   - Field: ‘globals’
[16:59:32.202]   - Field: ‘stdout’
[16:59:32.202]   - Field: ‘earlySignal’
[16:59:32.202]   - Field: ‘lazy’
[16:59:32.203]   - Field: ‘state’
[16:59:32.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.203] - Launch lazy future ...
[16:59:32.203] Packages needed by the future expression (n = 0): <none>
[16:59:32.203] Packages needed by future strategies (n = 0): <none>
[16:59:32.204] {
[16:59:32.204]     {
[16:59:32.204]         {
[16:59:32.204]             ...future.startTime <- base::Sys.time()
[16:59:32.204]             {
[16:59:32.204]                 {
[16:59:32.204]                   {
[16:59:32.204]                     {
[16:59:32.204]                       base::local({
[16:59:32.204]                         has_future <- base::requireNamespace("future", 
[16:59:32.204]                           quietly = TRUE)
[16:59:32.204]                         if (has_future) {
[16:59:32.204]                           ns <- base::getNamespace("future")
[16:59:32.204]                           version <- ns[[".package"]][["version"]]
[16:59:32.204]                           if (is.null(version)) 
[16:59:32.204]                             version <- utils::packageVersion("future")
[16:59:32.204]                         }
[16:59:32.204]                         else {
[16:59:32.204]                           version <- NULL
[16:59:32.204]                         }
[16:59:32.204]                         if (!has_future || version < "1.8.0") {
[16:59:32.204]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.204]                             "", base::R.version$version.string), 
[16:59:32.204]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.204]                               "release", "version")], collapse = " "), 
[16:59:32.204]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.204]                             info)
[16:59:32.204]                           info <- base::paste(info, collapse = "; ")
[16:59:32.204]                           if (!has_future) {
[16:59:32.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.204]                               info)
[16:59:32.204]                           }
[16:59:32.204]                           else {
[16:59:32.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.204]                               info, version)
[16:59:32.204]                           }
[16:59:32.204]                           base::stop(msg)
[16:59:32.204]                         }
[16:59:32.204]                       })
[16:59:32.204]                     }
[16:59:32.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.204]                     base::options(mc.cores = 1L)
[16:59:32.204]                   }
[16:59:32.204]                   ...future.strategy.old <- future::plan("list")
[16:59:32.204]                   options(future.plan = NULL)
[16:59:32.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.204]                 }
[16:59:32.204]                 ...future.workdir <- getwd()
[16:59:32.204]             }
[16:59:32.204]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.204]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.204]         }
[16:59:32.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.204]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.204]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.204]             base::names(...future.oldOptions))
[16:59:32.204]     }
[16:59:32.204]     if (FALSE) {
[16:59:32.204]     }
[16:59:32.204]     else {
[16:59:32.204]         if (TRUE) {
[16:59:32.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.204]                 open = "w")
[16:59:32.204]         }
[16:59:32.204]         else {
[16:59:32.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.204]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.204]         }
[16:59:32.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.204]             base::sink(type = "output", split = FALSE)
[16:59:32.204]             base::close(...future.stdout)
[16:59:32.204]         }, add = TRUE)
[16:59:32.204]     }
[16:59:32.204]     ...future.frame <- base::sys.nframe()
[16:59:32.204]     ...future.conditions <- base::list()
[16:59:32.204]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.204]     if (FALSE) {
[16:59:32.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.204]     }
[16:59:32.204]     ...future.result <- base::tryCatch({
[16:59:32.204]         base::withCallingHandlers({
[16:59:32.204]             ...future.value <- base::withVisible(base::local({
[16:59:32.204]                 ...future.makeSendCondition <- base::local({
[16:59:32.204]                   sendCondition <- NULL
[16:59:32.204]                   function(frame = 1L) {
[16:59:32.204]                     if (is.function(sendCondition)) 
[16:59:32.204]                       return(sendCondition)
[16:59:32.204]                     ns <- getNamespace("parallel")
[16:59:32.204]                     if (exists("sendData", mode = "function", 
[16:59:32.204]                       envir = ns)) {
[16:59:32.204]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.204]                         envir = ns)
[16:59:32.204]                       envir <- sys.frame(frame)
[16:59:32.204]                       master <- NULL
[16:59:32.204]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.204]                         !identical(envir, emptyenv())) {
[16:59:32.204]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.204]                           inherits = FALSE)) {
[16:59:32.204]                           master <- get("master", mode = "list", 
[16:59:32.204]                             envir = envir, inherits = FALSE)
[16:59:32.204]                           if (inherits(master, c("SOCKnode", 
[16:59:32.204]                             "SOCK0node"))) {
[16:59:32.204]                             sendCondition <<- function(cond) {
[16:59:32.204]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.204]                                 success = TRUE)
[16:59:32.204]                               parallel_sendData(master, data)
[16:59:32.204]                             }
[16:59:32.204]                             return(sendCondition)
[16:59:32.204]                           }
[16:59:32.204]                         }
[16:59:32.204]                         frame <- frame + 1L
[16:59:32.204]                         envir <- sys.frame(frame)
[16:59:32.204]                       }
[16:59:32.204]                     }
[16:59:32.204]                     sendCondition <<- function(cond) NULL
[16:59:32.204]                   }
[16:59:32.204]                 })
[16:59:32.204]                 withCallingHandlers({
[16:59:32.204]                   {
[16:59:32.204]                     do.call(function(...) {
[16:59:32.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.204]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.204]                         ...future.globals.maxSize)) {
[16:59:32.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.204]                         on.exit(options(oopts), add = TRUE)
[16:59:32.204]                       }
[16:59:32.204]                       {
[16:59:32.204]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.204]                           FUN = function(jj) {
[16:59:32.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.204]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.204]                           })
[16:59:32.204]                       }
[16:59:32.204]                     }, args = future.call.arguments)
[16:59:32.204]                   }
[16:59:32.204]                 }, immediateCondition = function(cond) {
[16:59:32.204]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.204]                   sendCondition(cond)
[16:59:32.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.204]                   {
[16:59:32.204]                     inherits <- base::inherits
[16:59:32.204]                     invokeRestart <- base::invokeRestart
[16:59:32.204]                     is.null <- base::is.null
[16:59:32.204]                     muffled <- FALSE
[16:59:32.204]                     if (inherits(cond, "message")) {
[16:59:32.204]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.204]                       if (muffled) 
[16:59:32.204]                         invokeRestart("muffleMessage")
[16:59:32.204]                     }
[16:59:32.204]                     else if (inherits(cond, "warning")) {
[16:59:32.204]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.204]                       if (muffled) 
[16:59:32.204]                         invokeRestart("muffleWarning")
[16:59:32.204]                     }
[16:59:32.204]                     else if (inherits(cond, "condition")) {
[16:59:32.204]                       if (!is.null(pattern)) {
[16:59:32.204]                         computeRestarts <- base::computeRestarts
[16:59:32.204]                         grepl <- base::grepl
[16:59:32.204]                         restarts <- computeRestarts(cond)
[16:59:32.204]                         for (restart in restarts) {
[16:59:32.204]                           name <- restart$name
[16:59:32.204]                           if (is.null(name)) 
[16:59:32.204]                             next
[16:59:32.204]                           if (!grepl(pattern, name)) 
[16:59:32.204]                             next
[16:59:32.204]                           invokeRestart(restart)
[16:59:32.204]                           muffled <- TRUE
[16:59:32.204]                           break
[16:59:32.204]                         }
[16:59:32.204]                       }
[16:59:32.204]                     }
[16:59:32.204]                     invisible(muffled)
[16:59:32.204]                   }
[16:59:32.204]                   muffleCondition(cond)
[16:59:32.204]                 })
[16:59:32.204]             }))
[16:59:32.204]             future::FutureResult(value = ...future.value$value, 
[16:59:32.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.204]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.204]                     ...future.globalenv.names))
[16:59:32.204]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.204]         }, condition = base::local({
[16:59:32.204]             c <- base::c
[16:59:32.204]             inherits <- base::inherits
[16:59:32.204]             invokeRestart <- base::invokeRestart
[16:59:32.204]             length <- base::length
[16:59:32.204]             list <- base::list
[16:59:32.204]             seq.int <- base::seq.int
[16:59:32.204]             signalCondition <- base::signalCondition
[16:59:32.204]             sys.calls <- base::sys.calls
[16:59:32.204]             `[[` <- base::`[[`
[16:59:32.204]             `+` <- base::`+`
[16:59:32.204]             `<<-` <- base::`<<-`
[16:59:32.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.204]                   3L)]
[16:59:32.204]             }
[16:59:32.204]             function(cond) {
[16:59:32.204]                 is_error <- inherits(cond, "error")
[16:59:32.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.204]                   NULL)
[16:59:32.204]                 if (is_error) {
[16:59:32.204]                   sessionInformation <- function() {
[16:59:32.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.204]                       search = base::search(), system = base::Sys.info())
[16:59:32.204]                   }
[16:59:32.204]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.204]                     cond$call), session = sessionInformation(), 
[16:59:32.204]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.204]                   signalCondition(cond)
[16:59:32.204]                 }
[16:59:32.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.204]                 "immediateCondition"))) {
[16:59:32.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.204]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.204]                   if (TRUE && !signal) {
[16:59:32.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.204]                     {
[16:59:32.204]                       inherits <- base::inherits
[16:59:32.204]                       invokeRestart <- base::invokeRestart
[16:59:32.204]                       is.null <- base::is.null
[16:59:32.204]                       muffled <- FALSE
[16:59:32.204]                       if (inherits(cond, "message")) {
[16:59:32.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.204]                         if (muffled) 
[16:59:32.204]                           invokeRestart("muffleMessage")
[16:59:32.204]                       }
[16:59:32.204]                       else if (inherits(cond, "warning")) {
[16:59:32.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.204]                         if (muffled) 
[16:59:32.204]                           invokeRestart("muffleWarning")
[16:59:32.204]                       }
[16:59:32.204]                       else if (inherits(cond, "condition")) {
[16:59:32.204]                         if (!is.null(pattern)) {
[16:59:32.204]                           computeRestarts <- base::computeRestarts
[16:59:32.204]                           grepl <- base::grepl
[16:59:32.204]                           restarts <- computeRestarts(cond)
[16:59:32.204]                           for (restart in restarts) {
[16:59:32.204]                             name <- restart$name
[16:59:32.204]                             if (is.null(name)) 
[16:59:32.204]                               next
[16:59:32.204]                             if (!grepl(pattern, name)) 
[16:59:32.204]                               next
[16:59:32.204]                             invokeRestart(restart)
[16:59:32.204]                             muffled <- TRUE
[16:59:32.204]                             break
[16:59:32.204]                           }
[16:59:32.204]                         }
[16:59:32.204]                       }
[16:59:32.204]                       invisible(muffled)
[16:59:32.204]                     }
[16:59:32.204]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.204]                   }
[16:59:32.204]                 }
[16:59:32.204]                 else {
[16:59:32.204]                   if (TRUE) {
[16:59:32.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.204]                     {
[16:59:32.204]                       inherits <- base::inherits
[16:59:32.204]                       invokeRestart <- base::invokeRestart
[16:59:32.204]                       is.null <- base::is.null
[16:59:32.204]                       muffled <- FALSE
[16:59:32.204]                       if (inherits(cond, "message")) {
[16:59:32.204]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.204]                         if (muffled) 
[16:59:32.204]                           invokeRestart("muffleMessage")
[16:59:32.204]                       }
[16:59:32.204]                       else if (inherits(cond, "warning")) {
[16:59:32.204]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.204]                         if (muffled) 
[16:59:32.204]                           invokeRestart("muffleWarning")
[16:59:32.204]                       }
[16:59:32.204]                       else if (inherits(cond, "condition")) {
[16:59:32.204]                         if (!is.null(pattern)) {
[16:59:32.204]                           computeRestarts <- base::computeRestarts
[16:59:32.204]                           grepl <- base::grepl
[16:59:32.204]                           restarts <- computeRestarts(cond)
[16:59:32.204]                           for (restart in restarts) {
[16:59:32.204]                             name <- restart$name
[16:59:32.204]                             if (is.null(name)) 
[16:59:32.204]                               next
[16:59:32.204]                             if (!grepl(pattern, name)) 
[16:59:32.204]                               next
[16:59:32.204]                             invokeRestart(restart)
[16:59:32.204]                             muffled <- TRUE
[16:59:32.204]                             break
[16:59:32.204]                           }
[16:59:32.204]                         }
[16:59:32.204]                       }
[16:59:32.204]                       invisible(muffled)
[16:59:32.204]                     }
[16:59:32.204]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.204]                   }
[16:59:32.204]                 }
[16:59:32.204]             }
[16:59:32.204]         }))
[16:59:32.204]     }, error = function(ex) {
[16:59:32.204]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.204]                 ...future.rng), started = ...future.startTime, 
[16:59:32.204]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.204]             version = "1.8"), class = "FutureResult")
[16:59:32.204]     }, finally = {
[16:59:32.204]         if (!identical(...future.workdir, getwd())) 
[16:59:32.204]             setwd(...future.workdir)
[16:59:32.204]         {
[16:59:32.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.204]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.204]             }
[16:59:32.204]             base::options(...future.oldOptions)
[16:59:32.204]             if (.Platform$OS.type == "windows") {
[16:59:32.204]                 old_names <- names(...future.oldEnvVars)
[16:59:32.204]                 envs <- base::Sys.getenv()
[16:59:32.204]                 names <- names(envs)
[16:59:32.204]                 common <- intersect(names, old_names)
[16:59:32.204]                 added <- setdiff(names, old_names)
[16:59:32.204]                 removed <- setdiff(old_names, names)
[16:59:32.204]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.204]                   envs[common]]
[16:59:32.204]                 NAMES <- toupper(changed)
[16:59:32.204]                 args <- list()
[16:59:32.204]                 for (kk in seq_along(NAMES)) {
[16:59:32.204]                   name <- changed[[kk]]
[16:59:32.204]                   NAME <- NAMES[[kk]]
[16:59:32.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.204]                     next
[16:59:32.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.204]                 }
[16:59:32.204]                 NAMES <- toupper(added)
[16:59:32.204]                 for (kk in seq_along(NAMES)) {
[16:59:32.204]                   name <- added[[kk]]
[16:59:32.204]                   NAME <- NAMES[[kk]]
[16:59:32.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.204]                     next
[16:59:32.204]                   args[[name]] <- ""
[16:59:32.204]                 }
[16:59:32.204]                 NAMES <- toupper(removed)
[16:59:32.204]                 for (kk in seq_along(NAMES)) {
[16:59:32.204]                   name <- removed[[kk]]
[16:59:32.204]                   NAME <- NAMES[[kk]]
[16:59:32.204]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.204]                     next
[16:59:32.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.204]                 }
[16:59:32.204]                 if (length(args) > 0) 
[16:59:32.204]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.204]             }
[16:59:32.204]             else {
[16:59:32.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.204]             }
[16:59:32.204]             {
[16:59:32.204]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.204]                   0L) {
[16:59:32.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.204]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.204]                   base::options(opts)
[16:59:32.204]                 }
[16:59:32.204]                 {
[16:59:32.204]                   {
[16:59:32.204]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.204]                     NULL
[16:59:32.204]                   }
[16:59:32.204]                   options(future.plan = NULL)
[16:59:32.204]                   if (is.na(NA_character_)) 
[16:59:32.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.204]                     .init = FALSE)
[16:59:32.204]                 }
[16:59:32.204]             }
[16:59:32.204]         }
[16:59:32.204]     })
[16:59:32.204]     if (TRUE) {
[16:59:32.204]         base::sink(type = "output", split = FALSE)
[16:59:32.204]         if (TRUE) {
[16:59:32.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.204]         }
[16:59:32.204]         else {
[16:59:32.204]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.204]         }
[16:59:32.204]         base::close(...future.stdout)
[16:59:32.204]         ...future.stdout <- NULL
[16:59:32.204]     }
[16:59:32.204]     ...future.result$conditions <- ...future.conditions
[16:59:32.204]     ...future.result$finished <- base::Sys.time()
[16:59:32.204]     ...future.result
[16:59:32.204] }
[16:59:32.207] Exporting 5 global objects (346.05 KiB) to cluster node #2 ...
[16:59:32.207] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:32.208] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.208] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ...
[16:59:32.252] Exporting ‘...future.FUN’ (345.92 KiB) to cluster node #2 ... DONE
[16:59:32.252] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:59:32.253] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:59:32.253] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:32.253] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.254] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:32.254] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:32.254] Exporting 5 global objects (346.05 KiB) to cluster node #2 ... DONE
[16:59:32.254] MultisessionFuture started
[16:59:32.255] - Launch lazy future ... done
[16:59:32.255] run() for ‘MultisessionFuture’ ... done
[16:59:32.255] Created future:
[16:59:32.255] MultisessionFuture:
[16:59:32.255] Label: ‘future_apply-2’
[16:59:32.255] Expression:
[16:59:32.255] {
[16:59:32.255]     do.call(function(...) {
[16:59:32.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.255]             on.exit(options(oopts), add = TRUE)
[16:59:32.255]         }
[16:59:32.255]         {
[16:59:32.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.255]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.255]             })
[16:59:32.255]         }
[16:59:32.255]     }, args = future.call.arguments)
[16:59:32.255] }
[16:59:32.255] Lazy evaluation: FALSE
[16:59:32.255] Asynchronous evaluation: TRUE
[16:59:32.255] Local evaluation: TRUE
[16:59:32.255] Environment: R_GlobalEnv
[16:59:32.255] Capture standard output: TRUE
[16:59:32.255] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.255] Globals: 5 objects totaling 346.05 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 345.92 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.255] Packages: <none>
[16:59:32.255] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.255] Resolved: FALSE
[16:59:32.255] Value: <not collected>
[16:59:32.255] Conditions captured: <none>
[16:59:32.255] Early signaling: FALSE
[16:59:32.255] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.255] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.267] Chunk #2 of 2 ... DONE
[16:59:32.267] Launching 2 futures (chunks) ... DONE
[16:59:32.267] Resolving 2 futures (chunks) ...
[16:59:32.267] resolve() on list ...
[16:59:32.267]  recursive: 0
[16:59:32.268]  length: 2
[16:59:32.268] 
[16:59:32.268] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.268] - Validating connection of MultisessionFuture
[16:59:32.269] - received message: FutureResult
[16:59:32.269] - Received FutureResult
[16:59:32.269] - Erased future from FutureRegistry
[16:59:32.269] result() for ClusterFuture ...
[16:59:32.269] - result already collected: FutureResult
[16:59:32.269] result() for ClusterFuture ... done
[16:59:32.269] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.269] Future #1
[16:59:32.269] result() for ClusterFuture ...
[16:59:32.269] - result already collected: FutureResult
[16:59:32.270] result() for ClusterFuture ... done
[16:59:32.270] result() for ClusterFuture ...
[16:59:32.270] - result already collected: FutureResult
[16:59:32.270] result() for ClusterFuture ... done
[16:59:32.270] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:32.270] - nx: 2
[16:59:32.270] - relay: TRUE
[16:59:32.270] - stdout: TRUE
[16:59:32.270] - signal: TRUE
[16:59:32.270] - resignal: FALSE
[16:59:32.270] - force: TRUE
[16:59:32.270] - relayed: [n=2] FALSE, FALSE
[16:59:32.271] - queued futures: [n=2] FALSE, FALSE
[16:59:32.271]  - until=1
[16:59:32.271]  - relaying element #1
[16:59:32.271] result() for ClusterFuture ...
[16:59:32.271] - result already collected: FutureResult
[16:59:32.271] result() for ClusterFuture ... done
[16:59:32.271] result() for ClusterFuture ...
[16:59:32.271] - result already collected: FutureResult
[16:59:32.271] result() for ClusterFuture ... done
[16:59:32.271] result() for ClusterFuture ...
[16:59:32.272] - result already collected: FutureResult
[16:59:32.272] result() for ClusterFuture ... done
[16:59:32.272] result() for ClusterFuture ...
[16:59:32.272] - result already collected: FutureResult
[16:59:32.272] result() for ClusterFuture ... done
[16:59:32.272] - relayed: [n=2] TRUE, FALSE
[16:59:32.272] - queued futures: [n=2] TRUE, FALSE
[16:59:32.272] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:32.272]  length: 1 (resolved future 1)
[16:59:32.300] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.301] - Validating connection of MultisessionFuture
[16:59:32.301] - received message: FutureResult
[16:59:32.301] - Received FutureResult
[16:59:32.301] - Erased future from FutureRegistry
[16:59:32.301] result() for ClusterFuture ...
[16:59:32.301] - result already collected: FutureResult
[16:59:32.301] result() for ClusterFuture ... done
[16:59:32.301] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.302] Future #2
[16:59:32.302] result() for ClusterFuture ...
[16:59:32.302] - result already collected: FutureResult
[16:59:32.302] result() for ClusterFuture ... done
[16:59:32.302] result() for ClusterFuture ...
[16:59:32.302] - result already collected: FutureResult
[16:59:32.302] result() for ClusterFuture ... done
[16:59:32.302] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.302] - nx: 2
[16:59:32.302] - relay: TRUE
[16:59:32.302] - stdout: TRUE
[16:59:32.303] - signal: TRUE
[16:59:32.303] - resignal: FALSE
[16:59:32.303] - force: TRUE
[16:59:32.303] - relayed: [n=2] TRUE, FALSE
[16:59:32.303] - queued futures: [n=2] TRUE, FALSE
[16:59:32.303]  - until=2
[16:59:32.303]  - relaying element #2
[16:59:32.303] result() for ClusterFuture ...
[16:59:32.303] - result already collected: FutureResult
[16:59:32.303] result() for ClusterFuture ... done
[16:59:32.303] result() for ClusterFuture ...
[16:59:32.304] - result already collected: FutureResult
[16:59:32.304] result() for ClusterFuture ... done
[16:59:32.304] result() for ClusterFuture ...
[16:59:32.304] - result already collected: FutureResult
[16:59:32.304] result() for ClusterFuture ... done
[16:59:32.306] result() for ClusterFuture ...
[16:59:32.306] - result already collected: FutureResult
[16:59:32.307] result() for ClusterFuture ... done
[16:59:32.307] - relayed: [n=2] TRUE, TRUE
[16:59:32.307] - queued futures: [n=2] TRUE, TRUE
[16:59:32.307] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.307]  length: 0 (resolved future 2)
[16:59:32.307] Relaying remaining futures
[16:59:32.307] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.307] - nx: 2
[16:59:32.307] - relay: TRUE
[16:59:32.307] - stdout: TRUE
[16:59:32.307] - signal: TRUE
[16:59:32.308] - resignal: FALSE
[16:59:32.308] - force: TRUE
[16:59:32.308] - relayed: [n=2] TRUE, TRUE
[16:59:32.308] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.308] - relayed: [n=2] TRUE, TRUE
[16:59:32.308] - queued futures: [n=2] TRUE, TRUE
[16:59:32.308] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.308] resolve() on list ... DONE
[16:59:32.308] result() for ClusterFuture ...
[16:59:32.308] - result already collected: FutureResult
[16:59:32.308] result() for ClusterFuture ... done
[16:59:32.308] result() for ClusterFuture ...
[16:59:32.309] - result already collected: FutureResult
[16:59:32.309] result() for ClusterFuture ... done
[16:59:32.309] result() for ClusterFuture ...
[16:59:32.309] - result already collected: FutureResult
[16:59:32.309] result() for ClusterFuture ... done
[16:59:32.309] result() for ClusterFuture ...
[16:59:32.309] - result already collected: FutureResult
[16:59:32.309] result() for ClusterFuture ... done
[16:59:32.309]  - Number of value chunks collected: 2
[16:59:32.309] Resolving 2 futures (chunks) ... DONE
[16:59:32.309] Reducing values from 2 chunks ...
[16:59:32.310]  - Number of values collected after concatenation: 2
[16:59:32.310]  - Number of values expected: 2
[16:59:32.310] Reducing values from 2 chunks ... DONE
[16:59:32.310] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[16:59:32.311] getGlobalsAndPackagesXApply() ...
[16:59:32.311]  - future.globals: TRUE
[16:59:32.311] getGlobalsAndPackages() ...
[16:59:32.311] Searching for globals...
[16:59:32.312] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:32.312] Searching for globals ... DONE
[16:59:32.312] Resolving globals: FALSE
[16:59:32.313] The total size of the 1 globals is 1.22 KiB (1248 bytes)
[16:59:32.313] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 1.22 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.22 KiB of class ‘function’)
[16:59:32.313] - globals: [1] ‘FUN’
[16:59:32.313] - packages: [1] ‘stats’
[16:59:32.314] getGlobalsAndPackages() ... DONE
[16:59:32.314]  - globals found/used: [n=1] ‘FUN’
[16:59:32.314]  - needed namespaces: [n=1] ‘stats’
[16:59:32.314] Finding globals ... DONE
[16:59:32.314]  - use_args: TRUE
[16:59:32.314]  - Getting '...' globals ...
[16:59:32.314] resolve() on list ...
[16:59:32.314]  recursive: 0
[16:59:32.314]  length: 1
[16:59:32.315]  elements: ‘...’
[16:59:32.315]  length: 0 (resolved future 1)
[16:59:32.315] resolve() on list ... DONE
[16:59:32.315]    - '...' content: [n=0] 
[16:59:32.315] List of 1
[16:59:32.315]  $ ...: list()
[16:59:32.315]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.315]  - attr(*, "where")=List of 1
[16:59:32.315]   ..$ ...:<environment: 0x55f3143abea0> 
[16:59:32.315]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.315]  - attr(*, "resolved")= logi TRUE
[16:59:32.315]  - attr(*, "total_size")= num NA
[16:59:32.317]  - Getting '...' globals ... DONE
[16:59:32.318] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:32.318] List of 2
[16:59:32.318]  $ ...future.FUN:function (x, ...)  
[16:59:32.318]  $ ...          : list()
[16:59:32.318]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.318]  - attr(*, "where")=List of 2
[16:59:32.318]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:32.318]   ..$ ...          :<environment: 0x55f3143abea0> 
[16:59:32.318]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.318]  - attr(*, "resolved")= logi FALSE
[16:59:32.318]  - attr(*, "total_size")= num 1248
[16:59:32.320] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:32.320] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.324] future_lapply() ...
[16:59:32.328] Number of chunks: 2
[16:59:32.328] getGlobalsAndPackagesXApply() ...
[16:59:32.328]  - future.globals: <name-value list> with names ‘list()’
[16:59:32.329]  - use_args: TRUE
[16:59:32.329] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:32.329] List of 2
[16:59:32.329]  $ ...          : list()
[16:59:32.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.329]  $ ...future.FUN:function (x, ...)  
[16:59:32.329]  - attr(*, "where")=List of 2
[16:59:32.329]   ..$ ...          :<environment: 0x55f3143abea0> 
[16:59:32.329]   ..$ ...future.FUN:<environment: namespace:stats> 
[16:59:32.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.329]  - attr(*, "resolved")= logi FALSE
[16:59:32.329]  - attr(*, "total_size")= num NA
[16:59:32.332] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:32.332] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.332] Number of futures (= number of chunks): 2
[16:59:32.332] Launching 2 futures (chunks) ...
[16:59:32.332] Chunk #1 of 2 ...
[16:59:32.332]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.333]  - seeds: <none>
[16:59:32.333]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.333] getGlobalsAndPackages() ...
[16:59:32.333] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.333] Resolving globals: FALSE
[16:59:32.333] Tweak future expression to call with '...' arguments ...
[16:59:32.333] {
[16:59:32.333]     do.call(function(...) {
[16:59:32.333]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.333]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.333]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.333]             on.exit(options(oopts), add = TRUE)
[16:59:32.333]         }
[16:59:32.333]         {
[16:59:32.333]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.333]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.333]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.333]             })
[16:59:32.333]         }
[16:59:32.333]     }, args = future.call.arguments)
[16:59:32.333] }
[16:59:32.334] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.334] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.334] - packages: [1] ‘stats’
[16:59:32.334] getGlobalsAndPackages() ... DONE
[16:59:32.334] run() for ‘Future’ ...
[16:59:32.335] - state: ‘created’
[16:59:32.335] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.349] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.349] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.349]   - Field: ‘node’
[16:59:32.349]   - Field: ‘label’
[16:59:32.349]   - Field: ‘local’
[16:59:32.349]   - Field: ‘owner’
[16:59:32.349]   - Field: ‘envir’
[16:59:32.350]   - Field: ‘workers’
[16:59:32.350]   - Field: ‘packages’
[16:59:32.350]   - Field: ‘gc’
[16:59:32.350]   - Field: ‘conditions’
[16:59:32.350]   - Field: ‘persistent’
[16:59:32.350]   - Field: ‘expr’
[16:59:32.350]   - Field: ‘uuid’
[16:59:32.350]   - Field: ‘seed’
[16:59:32.350]   - Field: ‘version’
[16:59:32.350]   - Field: ‘result’
[16:59:32.350]   - Field: ‘asynchronous’
[16:59:32.351]   - Field: ‘calls’
[16:59:32.351]   - Field: ‘globals’
[16:59:32.351]   - Field: ‘stdout’
[16:59:32.351]   - Field: ‘earlySignal’
[16:59:32.351]   - Field: ‘lazy’
[16:59:32.351]   - Field: ‘state’
[16:59:32.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.351] - Launch lazy future ...
[16:59:32.351] Packages needed by the future expression (n = 1): ‘stats’
[16:59:32.352] Packages needed by future strategies (n = 0): <none>
[16:59:32.352] {
[16:59:32.352]     {
[16:59:32.352]         {
[16:59:32.352]             ...future.startTime <- base::Sys.time()
[16:59:32.352]             {
[16:59:32.352]                 {
[16:59:32.352]                   {
[16:59:32.352]                     {
[16:59:32.352]                       {
[16:59:32.352]                         base::local({
[16:59:32.352]                           has_future <- base::requireNamespace("future", 
[16:59:32.352]                             quietly = TRUE)
[16:59:32.352]                           if (has_future) {
[16:59:32.352]                             ns <- base::getNamespace("future")
[16:59:32.352]                             version <- ns[[".package"]][["version"]]
[16:59:32.352]                             if (is.null(version)) 
[16:59:32.352]                               version <- utils::packageVersion("future")
[16:59:32.352]                           }
[16:59:32.352]                           else {
[16:59:32.352]                             version <- NULL
[16:59:32.352]                           }
[16:59:32.352]                           if (!has_future || version < "1.8.0") {
[16:59:32.352]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.352]                               "", base::R.version$version.string), 
[16:59:32.352]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:32.352]                                 base::R.version$platform, 8 * 
[16:59:32.352]                                   base::.Machine$sizeof.pointer), 
[16:59:32.352]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.352]                                 "release", "version")], collapse = " "), 
[16:59:32.352]                               hostname = base::Sys.info()[["nodename"]])
[16:59:32.352]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.352]                               info)
[16:59:32.352]                             info <- base::paste(info, collapse = "; ")
[16:59:32.352]                             if (!has_future) {
[16:59:32.352]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.352]                                 info)
[16:59:32.352]                             }
[16:59:32.352]                             else {
[16:59:32.352]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.352]                                 info, version)
[16:59:32.352]                             }
[16:59:32.352]                             base::stop(msg)
[16:59:32.352]                           }
[16:59:32.352]                         })
[16:59:32.352]                       }
[16:59:32.352]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.352]                       base::options(mc.cores = 1L)
[16:59:32.352]                     }
[16:59:32.352]                     base::local({
[16:59:32.352]                       for (pkg in "stats") {
[16:59:32.352]                         base::loadNamespace(pkg)
[16:59:32.352]                         base::library(pkg, character.only = TRUE)
[16:59:32.352]                       }
[16:59:32.352]                     })
[16:59:32.352]                   }
[16:59:32.352]                   ...future.strategy.old <- future::plan("list")
[16:59:32.352]                   options(future.plan = NULL)
[16:59:32.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.352]                 }
[16:59:32.352]                 ...future.workdir <- getwd()
[16:59:32.352]             }
[16:59:32.352]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.352]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.352]         }
[16:59:32.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.352]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.352]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.352]             base::names(...future.oldOptions))
[16:59:32.352]     }
[16:59:32.352]     if (FALSE) {
[16:59:32.352]     }
[16:59:32.352]     else {
[16:59:32.352]         if (TRUE) {
[16:59:32.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.352]                 open = "w")
[16:59:32.352]         }
[16:59:32.352]         else {
[16:59:32.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.352]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.352]         }
[16:59:32.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.352]             base::sink(type = "output", split = FALSE)
[16:59:32.352]             base::close(...future.stdout)
[16:59:32.352]         }, add = TRUE)
[16:59:32.352]     }
[16:59:32.352]     ...future.frame <- base::sys.nframe()
[16:59:32.352]     ...future.conditions <- base::list()
[16:59:32.352]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.352]     if (FALSE) {
[16:59:32.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.352]     }
[16:59:32.352]     ...future.result <- base::tryCatch({
[16:59:32.352]         base::withCallingHandlers({
[16:59:32.352]             ...future.value <- base::withVisible(base::local({
[16:59:32.352]                 ...future.makeSendCondition <- base::local({
[16:59:32.352]                   sendCondition <- NULL
[16:59:32.352]                   function(frame = 1L) {
[16:59:32.352]                     if (is.function(sendCondition)) 
[16:59:32.352]                       return(sendCondition)
[16:59:32.352]                     ns <- getNamespace("parallel")
[16:59:32.352]                     if (exists("sendData", mode = "function", 
[16:59:32.352]                       envir = ns)) {
[16:59:32.352]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.352]                         envir = ns)
[16:59:32.352]                       envir <- sys.frame(frame)
[16:59:32.352]                       master <- NULL
[16:59:32.352]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.352]                         !identical(envir, emptyenv())) {
[16:59:32.352]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.352]                           inherits = FALSE)) {
[16:59:32.352]                           master <- get("master", mode = "list", 
[16:59:32.352]                             envir = envir, inherits = FALSE)
[16:59:32.352]                           if (inherits(master, c("SOCKnode", 
[16:59:32.352]                             "SOCK0node"))) {
[16:59:32.352]                             sendCondition <<- function(cond) {
[16:59:32.352]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.352]                                 success = TRUE)
[16:59:32.352]                               parallel_sendData(master, data)
[16:59:32.352]                             }
[16:59:32.352]                             return(sendCondition)
[16:59:32.352]                           }
[16:59:32.352]                         }
[16:59:32.352]                         frame <- frame + 1L
[16:59:32.352]                         envir <- sys.frame(frame)
[16:59:32.352]                       }
[16:59:32.352]                     }
[16:59:32.352]                     sendCondition <<- function(cond) NULL
[16:59:32.352]                   }
[16:59:32.352]                 })
[16:59:32.352]                 withCallingHandlers({
[16:59:32.352]                   {
[16:59:32.352]                     do.call(function(...) {
[16:59:32.352]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.352]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.352]                         ...future.globals.maxSize)) {
[16:59:32.352]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.352]                         on.exit(options(oopts), add = TRUE)
[16:59:32.352]                       }
[16:59:32.352]                       {
[16:59:32.352]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.352]                           FUN = function(jj) {
[16:59:32.352]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.352]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.352]                           })
[16:59:32.352]                       }
[16:59:32.352]                     }, args = future.call.arguments)
[16:59:32.352]                   }
[16:59:32.352]                 }, immediateCondition = function(cond) {
[16:59:32.352]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.352]                   sendCondition(cond)
[16:59:32.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.352]                   {
[16:59:32.352]                     inherits <- base::inherits
[16:59:32.352]                     invokeRestart <- base::invokeRestart
[16:59:32.352]                     is.null <- base::is.null
[16:59:32.352]                     muffled <- FALSE
[16:59:32.352]                     if (inherits(cond, "message")) {
[16:59:32.352]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.352]                       if (muffled) 
[16:59:32.352]                         invokeRestart("muffleMessage")
[16:59:32.352]                     }
[16:59:32.352]                     else if (inherits(cond, "warning")) {
[16:59:32.352]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.352]                       if (muffled) 
[16:59:32.352]                         invokeRestart("muffleWarning")
[16:59:32.352]                     }
[16:59:32.352]                     else if (inherits(cond, "condition")) {
[16:59:32.352]                       if (!is.null(pattern)) {
[16:59:32.352]                         computeRestarts <- base::computeRestarts
[16:59:32.352]                         grepl <- base::grepl
[16:59:32.352]                         restarts <- computeRestarts(cond)
[16:59:32.352]                         for (restart in restarts) {
[16:59:32.352]                           name <- restart$name
[16:59:32.352]                           if (is.null(name)) 
[16:59:32.352]                             next
[16:59:32.352]                           if (!grepl(pattern, name)) 
[16:59:32.352]                             next
[16:59:32.352]                           invokeRestart(restart)
[16:59:32.352]                           muffled <- TRUE
[16:59:32.352]                           break
[16:59:32.352]                         }
[16:59:32.352]                       }
[16:59:32.352]                     }
[16:59:32.352]                     invisible(muffled)
[16:59:32.352]                   }
[16:59:32.352]                   muffleCondition(cond)
[16:59:32.352]                 })
[16:59:32.352]             }))
[16:59:32.352]             future::FutureResult(value = ...future.value$value, 
[16:59:32.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.352]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.352]                     ...future.globalenv.names))
[16:59:32.352]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.352]         }, condition = base::local({
[16:59:32.352]             c <- base::c
[16:59:32.352]             inherits <- base::inherits
[16:59:32.352]             invokeRestart <- base::invokeRestart
[16:59:32.352]             length <- base::length
[16:59:32.352]             list <- base::list
[16:59:32.352]             seq.int <- base::seq.int
[16:59:32.352]             signalCondition <- base::signalCondition
[16:59:32.352]             sys.calls <- base::sys.calls
[16:59:32.352]             `[[` <- base::`[[`
[16:59:32.352]             `+` <- base::`+`
[16:59:32.352]             `<<-` <- base::`<<-`
[16:59:32.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.352]                   3L)]
[16:59:32.352]             }
[16:59:32.352]             function(cond) {
[16:59:32.352]                 is_error <- inherits(cond, "error")
[16:59:32.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.352]                   NULL)
[16:59:32.352]                 if (is_error) {
[16:59:32.352]                   sessionInformation <- function() {
[16:59:32.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.352]                       search = base::search(), system = base::Sys.info())
[16:59:32.352]                   }
[16:59:32.352]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.352]                     cond$call), session = sessionInformation(), 
[16:59:32.352]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.352]                   signalCondition(cond)
[16:59:32.352]                 }
[16:59:32.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.352]                 "immediateCondition"))) {
[16:59:32.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.352]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.352]                   if (TRUE && !signal) {
[16:59:32.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.352]                     {
[16:59:32.352]                       inherits <- base::inherits
[16:59:32.352]                       invokeRestart <- base::invokeRestart
[16:59:32.352]                       is.null <- base::is.null
[16:59:32.352]                       muffled <- FALSE
[16:59:32.352]                       if (inherits(cond, "message")) {
[16:59:32.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.352]                         if (muffled) 
[16:59:32.352]                           invokeRestart("muffleMessage")
[16:59:32.352]                       }
[16:59:32.352]                       else if (inherits(cond, "warning")) {
[16:59:32.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.352]                         if (muffled) 
[16:59:32.352]                           invokeRestart("muffleWarning")
[16:59:32.352]                       }
[16:59:32.352]                       else if (inherits(cond, "condition")) {
[16:59:32.352]                         if (!is.null(pattern)) {
[16:59:32.352]                           computeRestarts <- base::computeRestarts
[16:59:32.352]                           grepl <- base::grepl
[16:59:32.352]                           restarts <- computeRestarts(cond)
[16:59:32.352]                           for (restart in restarts) {
[16:59:32.352]                             name <- restart$name
[16:59:32.352]                             if (is.null(name)) 
[16:59:32.352]                               next
[16:59:32.352]                             if (!grepl(pattern, name)) 
[16:59:32.352]                               next
[16:59:32.352]                             invokeRestart(restart)
[16:59:32.352]                             muffled <- TRUE
[16:59:32.352]                             break
[16:59:32.352]                           }
[16:59:32.352]                         }
[16:59:32.352]                       }
[16:59:32.352]                       invisible(muffled)
[16:59:32.352]                     }
[16:59:32.352]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.352]                   }
[16:59:32.352]                 }
[16:59:32.352]                 else {
[16:59:32.352]                   if (TRUE) {
[16:59:32.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.352]                     {
[16:59:32.352]                       inherits <- base::inherits
[16:59:32.352]                       invokeRestart <- base::invokeRestart
[16:59:32.352]                       is.null <- base::is.null
[16:59:32.352]                       muffled <- FALSE
[16:59:32.352]                       if (inherits(cond, "message")) {
[16:59:32.352]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.352]                         if (muffled) 
[16:59:32.352]                           invokeRestart("muffleMessage")
[16:59:32.352]                       }
[16:59:32.352]                       else if (inherits(cond, "warning")) {
[16:59:32.352]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.352]                         if (muffled) 
[16:59:32.352]                           invokeRestart("muffleWarning")
[16:59:32.352]                       }
[16:59:32.352]                       else if (inherits(cond, "condition")) {
[16:59:32.352]                         if (!is.null(pattern)) {
[16:59:32.352]                           computeRestarts <- base::computeRestarts
[16:59:32.352]                           grepl <- base::grepl
[16:59:32.352]                           restarts <- computeRestarts(cond)
[16:59:32.352]                           for (restart in restarts) {
[16:59:32.352]                             name <- restart$name
[16:59:32.352]                             if (is.null(name)) 
[16:59:32.352]                               next
[16:59:32.352]                             if (!grepl(pattern, name)) 
[16:59:32.352]                               next
[16:59:32.352]                             invokeRestart(restart)
[16:59:32.352]                             muffled <- TRUE
[16:59:32.352]                             break
[16:59:32.352]                           }
[16:59:32.352]                         }
[16:59:32.352]                       }
[16:59:32.352]                       invisible(muffled)
[16:59:32.352]                     }
[16:59:32.352]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.352]                   }
[16:59:32.352]                 }
[16:59:32.352]             }
[16:59:32.352]         }))
[16:59:32.352]     }, error = function(ex) {
[16:59:32.352]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.352]                 ...future.rng), started = ...future.startTime, 
[16:59:32.352]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.352]             version = "1.8"), class = "FutureResult")
[16:59:32.352]     }, finally = {
[16:59:32.352]         if (!identical(...future.workdir, getwd())) 
[16:59:32.352]             setwd(...future.workdir)
[16:59:32.352]         {
[16:59:32.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.352]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.352]             }
[16:59:32.352]             base::options(...future.oldOptions)
[16:59:32.352]             if (.Platform$OS.type == "windows") {
[16:59:32.352]                 old_names <- names(...future.oldEnvVars)
[16:59:32.352]                 envs <- base::Sys.getenv()
[16:59:32.352]                 names <- names(envs)
[16:59:32.352]                 common <- intersect(names, old_names)
[16:59:32.352]                 added <- setdiff(names, old_names)
[16:59:32.352]                 removed <- setdiff(old_names, names)
[16:59:32.352]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.352]                   envs[common]]
[16:59:32.352]                 NAMES <- toupper(changed)
[16:59:32.352]                 args <- list()
[16:59:32.352]                 for (kk in seq_along(NAMES)) {
[16:59:32.352]                   name <- changed[[kk]]
[16:59:32.352]                   NAME <- NAMES[[kk]]
[16:59:32.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.352]                     next
[16:59:32.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.352]                 }
[16:59:32.352]                 NAMES <- toupper(added)
[16:59:32.352]                 for (kk in seq_along(NAMES)) {
[16:59:32.352]                   name <- added[[kk]]
[16:59:32.352]                   NAME <- NAMES[[kk]]
[16:59:32.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.352]                     next
[16:59:32.352]                   args[[name]] <- ""
[16:59:32.352]                 }
[16:59:32.352]                 NAMES <- toupper(removed)
[16:59:32.352]                 for (kk in seq_along(NAMES)) {
[16:59:32.352]                   name <- removed[[kk]]
[16:59:32.352]                   NAME <- NAMES[[kk]]
[16:59:32.352]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.352]                     next
[16:59:32.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.352]                 }
[16:59:32.352]                 if (length(args) > 0) 
[16:59:32.352]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.352]             }
[16:59:32.352]             else {
[16:59:32.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.352]             }
[16:59:32.352]             {
[16:59:32.352]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.352]                   0L) {
[16:59:32.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.352]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.352]                   base::options(opts)
[16:59:32.352]                 }
[16:59:32.352]                 {
[16:59:32.352]                   {
[16:59:32.352]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.352]                     NULL
[16:59:32.352]                   }
[16:59:32.352]                   options(future.plan = NULL)
[16:59:32.352]                   if (is.na(NA_character_)) 
[16:59:32.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.352]                     .init = FALSE)
[16:59:32.352]                 }
[16:59:32.352]             }
[16:59:32.352]         }
[16:59:32.352]     })
[16:59:32.352]     if (TRUE) {
[16:59:32.352]         base::sink(type = "output", split = FALSE)
[16:59:32.352]         if (TRUE) {
[16:59:32.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.352]         }
[16:59:32.352]         else {
[16:59:32.352]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.352]         }
[16:59:32.352]         base::close(...future.stdout)
[16:59:32.352]         ...future.stdout <- NULL
[16:59:32.352]     }
[16:59:32.352]     ...future.result$conditions <- ...future.conditions
[16:59:32.352]     ...future.result$finished <- base::Sys.time()
[16:59:32.352]     ...future.result
[16:59:32.352] }
[16:59:32.355] Exporting 5 global objects (1.35 KiB) to cluster node #1 ...
[16:59:32.355] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.356] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.356] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ...
[16:59:32.356] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #1 ... DONE
[16:59:32.356] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ...
[16:59:32.357] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #1 ... DONE
[16:59:32.357] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.357] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.357] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.357] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.358] Exporting 5 global objects (1.35 KiB) to cluster node #1 ... DONE
[16:59:32.358] MultisessionFuture started
[16:59:32.358] - Launch lazy future ... done
[16:59:32.358] run() for ‘MultisessionFuture’ ... done
[16:59:32.358] Created future:
[16:59:32.358] MultisessionFuture:
[16:59:32.358] Label: ‘future_apply-1’
[16:59:32.358] Expression:
[16:59:32.358] {
[16:59:32.358]     do.call(function(...) {
[16:59:32.358]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.358]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.358]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.358]             on.exit(options(oopts), add = TRUE)
[16:59:32.358]         }
[16:59:32.358]         {
[16:59:32.358]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.358]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.358]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.358]             })
[16:59:32.358]         }
[16:59:32.358]     }, args = future.call.arguments)
[16:59:32.358] }
[16:59:32.358] Lazy evaluation: FALSE
[16:59:32.358] Asynchronous evaluation: TRUE
[16:59:32.358] Local evaluation: TRUE
[16:59:32.358] Environment: R_GlobalEnv
[16:59:32.358] Capture standard output: TRUE
[16:59:32.358] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.358] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.358] Packages: 1 packages (‘stats’)
[16:59:32.358] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.358] Resolved: FALSE
[16:59:32.358] Value: <not collected>
[16:59:32.358] Conditions captured: <none>
[16:59:32.358] Early signaling: FALSE
[16:59:32.358] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.358] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.370] Chunk #1 of 2 ... DONE
[16:59:32.370] Chunk #2 of 2 ...
[16:59:32.370]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.370]  - seeds: <none>
[16:59:32.370]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.371] getGlobalsAndPackages() ...
[16:59:32.371] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.371] Resolving globals: FALSE
[16:59:32.371] Tweak future expression to call with '...' arguments ...
[16:59:32.371] {
[16:59:32.371]     do.call(function(...) {
[16:59:32.371]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.371]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.371]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.371]             on.exit(options(oopts), add = TRUE)
[16:59:32.371]         }
[16:59:32.371]         {
[16:59:32.371]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.371]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.371]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.371]             })
[16:59:32.371]         }
[16:59:32.371]     }, args = future.call.arguments)
[16:59:32.371] }
[16:59:32.371] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.372] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.372] - packages: [1] ‘stats’
[16:59:32.372] getGlobalsAndPackages() ... DONE
[16:59:32.372] run() for ‘Future’ ...
[16:59:32.372] - state: ‘created’
[16:59:32.373] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.387] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.387] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.387]   - Field: ‘node’
[16:59:32.387]   - Field: ‘label’
[16:59:32.387]   - Field: ‘local’
[16:59:32.387]   - Field: ‘owner’
[16:59:32.387]   - Field: ‘envir’
[16:59:32.387]   - Field: ‘workers’
[16:59:32.387]   - Field: ‘packages’
[16:59:32.388]   - Field: ‘gc’
[16:59:32.388]   - Field: ‘conditions’
[16:59:32.388]   - Field: ‘persistent’
[16:59:32.388]   - Field: ‘expr’
[16:59:32.388]   - Field: ‘uuid’
[16:59:32.388]   - Field: ‘seed’
[16:59:32.388]   - Field: ‘version’
[16:59:32.388]   - Field: ‘result’
[16:59:32.388]   - Field: ‘asynchronous’
[16:59:32.388]   - Field: ‘calls’
[16:59:32.388]   - Field: ‘globals’
[16:59:32.389]   - Field: ‘stdout’
[16:59:32.389]   - Field: ‘earlySignal’
[16:59:32.389]   - Field: ‘lazy’
[16:59:32.389]   - Field: ‘state’
[16:59:32.389] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.389] - Launch lazy future ...
[16:59:32.389] Packages needed by the future expression (n = 1): ‘stats’
[16:59:32.389] Packages needed by future strategies (n = 0): <none>
[16:59:32.390] {
[16:59:32.390]     {
[16:59:32.390]         {
[16:59:32.390]             ...future.startTime <- base::Sys.time()
[16:59:32.390]             {
[16:59:32.390]                 {
[16:59:32.390]                   {
[16:59:32.390]                     {
[16:59:32.390]                       {
[16:59:32.390]                         base::local({
[16:59:32.390]                           has_future <- base::requireNamespace("future", 
[16:59:32.390]                             quietly = TRUE)
[16:59:32.390]                           if (has_future) {
[16:59:32.390]                             ns <- base::getNamespace("future")
[16:59:32.390]                             version <- ns[[".package"]][["version"]]
[16:59:32.390]                             if (is.null(version)) 
[16:59:32.390]                               version <- utils::packageVersion("future")
[16:59:32.390]                           }
[16:59:32.390]                           else {
[16:59:32.390]                             version <- NULL
[16:59:32.390]                           }
[16:59:32.390]                           if (!has_future || version < "1.8.0") {
[16:59:32.390]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.390]                               "", base::R.version$version.string), 
[16:59:32.390]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:32.390]                                 base::R.version$platform, 8 * 
[16:59:32.390]                                   base::.Machine$sizeof.pointer), 
[16:59:32.390]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.390]                                 "release", "version")], collapse = " "), 
[16:59:32.390]                               hostname = base::Sys.info()[["nodename"]])
[16:59:32.390]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.390]                               info)
[16:59:32.390]                             info <- base::paste(info, collapse = "; ")
[16:59:32.390]                             if (!has_future) {
[16:59:32.390]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.390]                                 info)
[16:59:32.390]                             }
[16:59:32.390]                             else {
[16:59:32.390]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.390]                                 info, version)
[16:59:32.390]                             }
[16:59:32.390]                             base::stop(msg)
[16:59:32.390]                           }
[16:59:32.390]                         })
[16:59:32.390]                       }
[16:59:32.390]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.390]                       base::options(mc.cores = 1L)
[16:59:32.390]                     }
[16:59:32.390]                     base::local({
[16:59:32.390]                       for (pkg in "stats") {
[16:59:32.390]                         base::loadNamespace(pkg)
[16:59:32.390]                         base::library(pkg, character.only = TRUE)
[16:59:32.390]                       }
[16:59:32.390]                     })
[16:59:32.390]                   }
[16:59:32.390]                   ...future.strategy.old <- future::plan("list")
[16:59:32.390]                   options(future.plan = NULL)
[16:59:32.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.390]                 }
[16:59:32.390]                 ...future.workdir <- getwd()
[16:59:32.390]             }
[16:59:32.390]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.390]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.390]         }
[16:59:32.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.390]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.390]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.390]             base::names(...future.oldOptions))
[16:59:32.390]     }
[16:59:32.390]     if (FALSE) {
[16:59:32.390]     }
[16:59:32.390]     else {
[16:59:32.390]         if (TRUE) {
[16:59:32.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.390]                 open = "w")
[16:59:32.390]         }
[16:59:32.390]         else {
[16:59:32.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.390]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.390]         }
[16:59:32.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.390]             base::sink(type = "output", split = FALSE)
[16:59:32.390]             base::close(...future.stdout)
[16:59:32.390]         }, add = TRUE)
[16:59:32.390]     }
[16:59:32.390]     ...future.frame <- base::sys.nframe()
[16:59:32.390]     ...future.conditions <- base::list()
[16:59:32.390]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.390]     if (FALSE) {
[16:59:32.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.390]     }
[16:59:32.390]     ...future.result <- base::tryCatch({
[16:59:32.390]         base::withCallingHandlers({
[16:59:32.390]             ...future.value <- base::withVisible(base::local({
[16:59:32.390]                 ...future.makeSendCondition <- base::local({
[16:59:32.390]                   sendCondition <- NULL
[16:59:32.390]                   function(frame = 1L) {
[16:59:32.390]                     if (is.function(sendCondition)) 
[16:59:32.390]                       return(sendCondition)
[16:59:32.390]                     ns <- getNamespace("parallel")
[16:59:32.390]                     if (exists("sendData", mode = "function", 
[16:59:32.390]                       envir = ns)) {
[16:59:32.390]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.390]                         envir = ns)
[16:59:32.390]                       envir <- sys.frame(frame)
[16:59:32.390]                       master <- NULL
[16:59:32.390]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.390]                         !identical(envir, emptyenv())) {
[16:59:32.390]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.390]                           inherits = FALSE)) {
[16:59:32.390]                           master <- get("master", mode = "list", 
[16:59:32.390]                             envir = envir, inherits = FALSE)
[16:59:32.390]                           if (inherits(master, c("SOCKnode", 
[16:59:32.390]                             "SOCK0node"))) {
[16:59:32.390]                             sendCondition <<- function(cond) {
[16:59:32.390]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.390]                                 success = TRUE)
[16:59:32.390]                               parallel_sendData(master, data)
[16:59:32.390]                             }
[16:59:32.390]                             return(sendCondition)
[16:59:32.390]                           }
[16:59:32.390]                         }
[16:59:32.390]                         frame <- frame + 1L
[16:59:32.390]                         envir <- sys.frame(frame)
[16:59:32.390]                       }
[16:59:32.390]                     }
[16:59:32.390]                     sendCondition <<- function(cond) NULL
[16:59:32.390]                   }
[16:59:32.390]                 })
[16:59:32.390]                 withCallingHandlers({
[16:59:32.390]                   {
[16:59:32.390]                     do.call(function(...) {
[16:59:32.390]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.390]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.390]                         ...future.globals.maxSize)) {
[16:59:32.390]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.390]                         on.exit(options(oopts), add = TRUE)
[16:59:32.390]                       }
[16:59:32.390]                       {
[16:59:32.390]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.390]                           FUN = function(jj) {
[16:59:32.390]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.390]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.390]                           })
[16:59:32.390]                       }
[16:59:32.390]                     }, args = future.call.arguments)
[16:59:32.390]                   }
[16:59:32.390]                 }, immediateCondition = function(cond) {
[16:59:32.390]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.390]                   sendCondition(cond)
[16:59:32.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.390]                   {
[16:59:32.390]                     inherits <- base::inherits
[16:59:32.390]                     invokeRestart <- base::invokeRestart
[16:59:32.390]                     is.null <- base::is.null
[16:59:32.390]                     muffled <- FALSE
[16:59:32.390]                     if (inherits(cond, "message")) {
[16:59:32.390]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.390]                       if (muffled) 
[16:59:32.390]                         invokeRestart("muffleMessage")
[16:59:32.390]                     }
[16:59:32.390]                     else if (inherits(cond, "warning")) {
[16:59:32.390]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.390]                       if (muffled) 
[16:59:32.390]                         invokeRestart("muffleWarning")
[16:59:32.390]                     }
[16:59:32.390]                     else if (inherits(cond, "condition")) {
[16:59:32.390]                       if (!is.null(pattern)) {
[16:59:32.390]                         computeRestarts <- base::computeRestarts
[16:59:32.390]                         grepl <- base::grepl
[16:59:32.390]                         restarts <- computeRestarts(cond)
[16:59:32.390]                         for (restart in restarts) {
[16:59:32.390]                           name <- restart$name
[16:59:32.390]                           if (is.null(name)) 
[16:59:32.390]                             next
[16:59:32.390]                           if (!grepl(pattern, name)) 
[16:59:32.390]                             next
[16:59:32.390]                           invokeRestart(restart)
[16:59:32.390]                           muffled <- TRUE
[16:59:32.390]                           break
[16:59:32.390]                         }
[16:59:32.390]                       }
[16:59:32.390]                     }
[16:59:32.390]                     invisible(muffled)
[16:59:32.390]                   }
[16:59:32.390]                   muffleCondition(cond)
[16:59:32.390]                 })
[16:59:32.390]             }))
[16:59:32.390]             future::FutureResult(value = ...future.value$value, 
[16:59:32.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.390]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.390]                     ...future.globalenv.names))
[16:59:32.390]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.390]         }, condition = base::local({
[16:59:32.390]             c <- base::c
[16:59:32.390]             inherits <- base::inherits
[16:59:32.390]             invokeRestart <- base::invokeRestart
[16:59:32.390]             length <- base::length
[16:59:32.390]             list <- base::list
[16:59:32.390]             seq.int <- base::seq.int
[16:59:32.390]             signalCondition <- base::signalCondition
[16:59:32.390]             sys.calls <- base::sys.calls
[16:59:32.390]             `[[` <- base::`[[`
[16:59:32.390]             `+` <- base::`+`
[16:59:32.390]             `<<-` <- base::`<<-`
[16:59:32.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.390]                   3L)]
[16:59:32.390]             }
[16:59:32.390]             function(cond) {
[16:59:32.390]                 is_error <- inherits(cond, "error")
[16:59:32.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.390]                   NULL)
[16:59:32.390]                 if (is_error) {
[16:59:32.390]                   sessionInformation <- function() {
[16:59:32.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.390]                       search = base::search(), system = base::Sys.info())
[16:59:32.390]                   }
[16:59:32.390]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.390]                     cond$call), session = sessionInformation(), 
[16:59:32.390]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.390]                   signalCondition(cond)
[16:59:32.390]                 }
[16:59:32.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.390]                 "immediateCondition"))) {
[16:59:32.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.390]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.390]                   if (TRUE && !signal) {
[16:59:32.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.390]                     {
[16:59:32.390]                       inherits <- base::inherits
[16:59:32.390]                       invokeRestart <- base::invokeRestart
[16:59:32.390]                       is.null <- base::is.null
[16:59:32.390]                       muffled <- FALSE
[16:59:32.390]                       if (inherits(cond, "message")) {
[16:59:32.390]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.390]                         if (muffled) 
[16:59:32.390]                           invokeRestart("muffleMessage")
[16:59:32.390]                       }
[16:59:32.390]                       else if (inherits(cond, "warning")) {
[16:59:32.390]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.390]                         if (muffled) 
[16:59:32.390]                           invokeRestart("muffleWarning")
[16:59:32.390]                       }
[16:59:32.390]                       else if (inherits(cond, "condition")) {
[16:59:32.390]                         if (!is.null(pattern)) {
[16:59:32.390]                           computeRestarts <- base::computeRestarts
[16:59:32.390]                           grepl <- base::grepl
[16:59:32.390]                           restarts <- computeRestarts(cond)
[16:59:32.390]                           for (restart in restarts) {
[16:59:32.390]                             name <- restart$name
[16:59:32.390]                             if (is.null(name)) 
[16:59:32.390]                               next
[16:59:32.390]                             if (!grepl(pattern, name)) 
[16:59:32.390]                               next
[16:59:32.390]                             invokeRestart(restart)
[16:59:32.390]                             muffled <- TRUE
[16:59:32.390]                             break
[16:59:32.390]                           }
[16:59:32.390]                         }
[16:59:32.390]                       }
[16:59:32.390]                       invisible(muffled)
[16:59:32.390]                     }
[16:59:32.390]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.390]                   }
[16:59:32.390]                 }
[16:59:32.390]                 else {
[16:59:32.390]                   if (TRUE) {
[16:59:32.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.390]                     {
[16:59:32.390]                       inherits <- base::inherits
[16:59:32.390]                       invokeRestart <- base::invokeRestart
[16:59:32.390]                       is.null <- base::is.null
[16:59:32.390]                       muffled <- FALSE
[16:59:32.390]                       if (inherits(cond, "message")) {
[16:59:32.390]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.390]                         if (muffled) 
[16:59:32.390]                           invokeRestart("muffleMessage")
[16:59:32.390]                       }
[16:59:32.390]                       else if (inherits(cond, "warning")) {
[16:59:32.390]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.390]                         if (muffled) 
[16:59:32.390]                           invokeRestart("muffleWarning")
[16:59:32.390]                       }
[16:59:32.390]                       else if (inherits(cond, "condition")) {
[16:59:32.390]                         if (!is.null(pattern)) {
[16:59:32.390]                           computeRestarts <- base::computeRestarts
[16:59:32.390]                           grepl <- base::grepl
[16:59:32.390]                           restarts <- computeRestarts(cond)
[16:59:32.390]                           for (restart in restarts) {
[16:59:32.390]                             name <- restart$name
[16:59:32.390]                             if (is.null(name)) 
[16:59:32.390]                               next
[16:59:32.390]                             if (!grepl(pattern, name)) 
[16:59:32.390]                               next
[16:59:32.390]                             invokeRestart(restart)
[16:59:32.390]                             muffled <- TRUE
[16:59:32.390]                             break
[16:59:32.390]                           }
[16:59:32.390]                         }
[16:59:32.390]                       }
[16:59:32.390]                       invisible(muffled)
[16:59:32.390]                     }
[16:59:32.390]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.390]                   }
[16:59:32.390]                 }
[16:59:32.390]             }
[16:59:32.390]         }))
[16:59:32.390]     }, error = function(ex) {
[16:59:32.390]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.390]                 ...future.rng), started = ...future.startTime, 
[16:59:32.390]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.390]             version = "1.8"), class = "FutureResult")
[16:59:32.390]     }, finally = {
[16:59:32.390]         if (!identical(...future.workdir, getwd())) 
[16:59:32.390]             setwd(...future.workdir)
[16:59:32.390]         {
[16:59:32.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.390]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.390]             }
[16:59:32.390]             base::options(...future.oldOptions)
[16:59:32.390]             if (.Platform$OS.type == "windows") {
[16:59:32.390]                 old_names <- names(...future.oldEnvVars)
[16:59:32.390]                 envs <- base::Sys.getenv()
[16:59:32.390]                 names <- names(envs)
[16:59:32.390]                 common <- intersect(names, old_names)
[16:59:32.390]                 added <- setdiff(names, old_names)
[16:59:32.390]                 removed <- setdiff(old_names, names)
[16:59:32.390]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.390]                   envs[common]]
[16:59:32.390]                 NAMES <- toupper(changed)
[16:59:32.390]                 args <- list()
[16:59:32.390]                 for (kk in seq_along(NAMES)) {
[16:59:32.390]                   name <- changed[[kk]]
[16:59:32.390]                   NAME <- NAMES[[kk]]
[16:59:32.390]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.390]                     next
[16:59:32.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.390]                 }
[16:59:32.390]                 NAMES <- toupper(added)
[16:59:32.390]                 for (kk in seq_along(NAMES)) {
[16:59:32.390]                   name <- added[[kk]]
[16:59:32.390]                   NAME <- NAMES[[kk]]
[16:59:32.390]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.390]                     next
[16:59:32.390]                   args[[name]] <- ""
[16:59:32.390]                 }
[16:59:32.390]                 NAMES <- toupper(removed)
[16:59:32.390]                 for (kk in seq_along(NAMES)) {
[16:59:32.390]                   name <- removed[[kk]]
[16:59:32.390]                   NAME <- NAMES[[kk]]
[16:59:32.390]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.390]                     next
[16:59:32.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.390]                 }
[16:59:32.390]                 if (length(args) > 0) 
[16:59:32.390]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.390]             }
[16:59:32.390]             else {
[16:59:32.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.390]             }
[16:59:32.390]             {
[16:59:32.390]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.390]                   0L) {
[16:59:32.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.390]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.390]                   base::options(opts)
[16:59:32.390]                 }
[16:59:32.390]                 {
[16:59:32.390]                   {
[16:59:32.390]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.390]                     NULL
[16:59:32.390]                   }
[16:59:32.390]                   options(future.plan = NULL)
[16:59:32.390]                   if (is.na(NA_character_)) 
[16:59:32.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.390]                     .init = FALSE)
[16:59:32.390]                 }
[16:59:32.390]             }
[16:59:32.390]         }
[16:59:32.390]     })
[16:59:32.390]     if (TRUE) {
[16:59:32.390]         base::sink(type = "output", split = FALSE)
[16:59:32.390]         if (TRUE) {
[16:59:32.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.390]         }
[16:59:32.390]         else {
[16:59:32.390]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.390]         }
[16:59:32.390]         base::close(...future.stdout)
[16:59:32.390]         ...future.stdout <- NULL
[16:59:32.390]     }
[16:59:32.390]     ...future.result$conditions <- ...future.conditions
[16:59:32.390]     ...future.result$finished <- base::Sys.time()
[16:59:32.390]     ...future.result
[16:59:32.390] }
[16:59:32.393] Exporting 5 global objects (1.35 KiB) to cluster node #2 ...
[16:59:32.393] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:32.394] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.394] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ...
[16:59:32.394] Exporting ‘...future.FUN’ (1.22 KiB) to cluster node #2 ... DONE
[16:59:32.394] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ...
[16:59:32.395] Exporting ‘...future.elements_ii’ (80 bytes) to cluster node #2 ... DONE
[16:59:32.395] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:32.395] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.395] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:32.396] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:32.396] Exporting 5 global objects (1.35 KiB) to cluster node #2 ... DONE
[16:59:32.396] MultisessionFuture started
[16:59:32.396] - Launch lazy future ... done
[16:59:32.396] run() for ‘MultisessionFuture’ ... done
[16:59:32.397] Created future:
[16:59:32.397] MultisessionFuture:
[16:59:32.397] Label: ‘future_apply-2’
[16:59:32.397] Expression:
[16:59:32.397] {
[16:59:32.397]     do.call(function(...) {
[16:59:32.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.397]             on.exit(options(oopts), add = TRUE)
[16:59:32.397]         }
[16:59:32.397]         {
[16:59:32.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.397]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.397]             })
[16:59:32.397]         }
[16:59:32.397]     }, args = future.call.arguments)
[16:59:32.397] }
[16:59:32.397] Lazy evaluation: FALSE
[16:59:32.397] Asynchronous evaluation: TRUE
[16:59:32.397] Local evaluation: TRUE
[16:59:32.397] Environment: R_GlobalEnv
[16:59:32.397] Capture standard output: TRUE
[16:59:32.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.397] Globals: 5 objects totaling 1.35 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.22 KiB, list ‘...future.elements_ii’ of 80 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.397] Packages: 1 packages (‘stats’)
[16:59:32.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.397] Resolved: FALSE
[16:59:32.397] Value: <not collected>
[16:59:32.397] Conditions captured: <none>
[16:59:32.397] Early signaling: FALSE
[16:59:32.397] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.397] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.408] Chunk #2 of 2 ... DONE
[16:59:32.408] Launching 2 futures (chunks) ... DONE
[16:59:32.409] Resolving 2 futures (chunks) ...
[16:59:32.409] resolve() on list ...
[16:59:32.409]  recursive: 0
[16:59:32.409]  length: 2
[16:59:32.409] 
[16:59:32.409] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.410] - Validating connection of MultisessionFuture
[16:59:32.410] - received message: FutureResult
[16:59:32.410] - Received FutureResult
[16:59:32.410] - Erased future from FutureRegistry
[16:59:32.410] result() for ClusterFuture ...
[16:59:32.410] - result already collected: FutureResult
[16:59:32.410] result() for ClusterFuture ... done
[16:59:32.410] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.411] Future #1
[16:59:32.411] result() for ClusterFuture ...
[16:59:32.411] - result already collected: FutureResult
[16:59:32.411] result() for ClusterFuture ... done
[16:59:32.411] result() for ClusterFuture ...
[16:59:32.411] - result already collected: FutureResult
[16:59:32.411] result() for ClusterFuture ... done
[16:59:32.411] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:32.411] - nx: 2
[16:59:32.411] - relay: TRUE
[16:59:32.411] - stdout: TRUE
[16:59:32.411] - signal: TRUE
[16:59:32.412] - resignal: FALSE
[16:59:32.412] - force: TRUE
[16:59:32.412] - relayed: [n=2] FALSE, FALSE
[16:59:32.412] - queued futures: [n=2] FALSE, FALSE
[16:59:32.412]  - until=1
[16:59:32.412]  - relaying element #1
[16:59:32.412] result() for ClusterFuture ...
[16:59:32.412] - result already collected: FutureResult
[16:59:32.412] result() for ClusterFuture ... done
[16:59:32.412] result() for ClusterFuture ...
[16:59:32.412] - result already collected: FutureResult
[16:59:32.412] result() for ClusterFuture ... done
[16:59:32.413] result() for ClusterFuture ...
[16:59:32.413] - result already collected: FutureResult
[16:59:32.413] result() for ClusterFuture ... done
[16:59:32.413] result() for ClusterFuture ...
[16:59:32.413] - result already collected: FutureResult
[16:59:32.413] result() for ClusterFuture ... done
[16:59:32.413] - relayed: [n=2] TRUE, FALSE
[16:59:32.413] - queued futures: [n=2] TRUE, FALSE
[16:59:32.413] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:32.413]  length: 1 (resolved future 1)
[16:59:32.443] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.443] - Validating connection of MultisessionFuture
[16:59:32.443] - received message: FutureResult
[16:59:32.444] - Received FutureResult
[16:59:32.444] - Erased future from FutureRegistry
[16:59:32.444] result() for ClusterFuture ...
[16:59:32.444] - result already collected: FutureResult
[16:59:32.444] result() for ClusterFuture ... done
[16:59:32.444] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.444] Future #2
[16:59:32.444] result() for ClusterFuture ...
[16:59:32.444] - result already collected: FutureResult
[16:59:32.444] result() for ClusterFuture ... done
[16:59:32.444] result() for ClusterFuture ...
[16:59:32.445] - result already collected: FutureResult
[16:59:32.445] result() for ClusterFuture ... done
[16:59:32.445] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.445] - nx: 2
[16:59:32.445] - relay: TRUE
[16:59:32.445] - stdout: TRUE
[16:59:32.445] - signal: TRUE
[16:59:32.445] - resignal: FALSE
[16:59:32.445] - force: TRUE
[16:59:32.445] - relayed: [n=2] TRUE, FALSE
[16:59:32.445] - queued futures: [n=2] TRUE, FALSE
[16:59:32.445]  - until=2
[16:59:32.446]  - relaying element #2
[16:59:32.446] result() for ClusterFuture ...
[16:59:32.446] - result already collected: FutureResult
[16:59:32.446] result() for ClusterFuture ... done
[16:59:32.446] result() for ClusterFuture ...
[16:59:32.446] - result already collected: FutureResult
[16:59:32.446] result() for ClusterFuture ... done
[16:59:32.446] result() for ClusterFuture ...
[16:59:32.446] - result already collected: FutureResult
[16:59:32.446] result() for ClusterFuture ... done
[16:59:32.446] result() for ClusterFuture ...
[16:59:32.447] - result already collected: FutureResult
[16:59:32.447] result() for ClusterFuture ... done
[16:59:32.447] - relayed: [n=2] TRUE, TRUE
[16:59:32.447] - queued futures: [n=2] TRUE, TRUE
[16:59:32.447] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.447]  length: 0 (resolved future 2)
[16:59:32.447] Relaying remaining futures
[16:59:32.447] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.447] - nx: 2
[16:59:32.447] - relay: TRUE
[16:59:32.447] - stdout: TRUE
[16:59:32.447] - signal: TRUE
[16:59:32.448] - resignal: FALSE
[16:59:32.448] - force: TRUE
[16:59:32.448] - relayed: [n=2] TRUE, TRUE
[16:59:32.448] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.448] - relayed: [n=2] TRUE, TRUE
[16:59:32.448] - queued futures: [n=2] TRUE, TRUE
[16:59:32.448] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.448] resolve() on list ... DONE
[16:59:32.448] result() for ClusterFuture ...
[16:59:32.448] - result already collected: FutureResult
[16:59:32.448] result() for ClusterFuture ... done
[16:59:32.449] result() for ClusterFuture ...
[16:59:32.449] - result already collected: FutureResult
[16:59:32.449] result() for ClusterFuture ... done
[16:59:32.449] result() for ClusterFuture ...
[16:59:32.449] - result already collected: FutureResult
[16:59:32.449] result() for ClusterFuture ... done
[16:59:32.449] result() for ClusterFuture ...
[16:59:32.449] - result already collected: FutureResult
[16:59:32.449] result() for ClusterFuture ... done
[16:59:32.449]  - Number of value chunks collected: 2
[16:59:32.449] Resolving 2 futures (chunks) ... DONE
[16:59:32.450] Reducing values from 2 chunks ...
[16:59:32.450]  - Number of values collected after concatenation: 2
[16:59:32.450]  - Number of values expected: 2
[16:59:32.450] Reducing values from 2 chunks ... DONE
[16:59:32.450] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[16:59:32.450] getGlobalsAndPackagesXApply() ...
[16:59:32.450]  - future.globals: TRUE
[16:59:32.451] getGlobalsAndPackages() ...
[16:59:32.451] Searching for globals...
[16:59:32.452] - globals found: [1] ‘FUN’
[16:59:32.452] Searching for globals ... DONE
[16:59:32.452] Resolving globals: FALSE
[16:59:32.452] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:32.453] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:32.453] - globals: [1] ‘FUN’
[16:59:32.453] 
[16:59:32.453] getGlobalsAndPackages() ... DONE
[16:59:32.453]  - globals found/used: [n=1] ‘FUN’
[16:59:32.453]  - needed namespaces: [n=0] 
[16:59:32.453] Finding globals ... DONE
[16:59:32.453]  - use_args: TRUE
[16:59:32.453]  - Getting '...' globals ...
[16:59:32.454] resolve() on list ...
[16:59:32.454]  recursive: 0
[16:59:32.454]  length: 1
[16:59:32.454]  elements: ‘...’
[16:59:32.454]  length: 0 (resolved future 1)
[16:59:32.454] resolve() on list ... DONE
[16:59:32.454]    - '...' content: [n=0] 
[16:59:32.454] List of 1
[16:59:32.454]  $ ...: list()
[16:59:32.454]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.454]  - attr(*, "where")=List of 1
[16:59:32.454]   ..$ ...:<environment: 0x55f315d0ad78> 
[16:59:32.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.454]  - attr(*, "resolved")= logi TRUE
[16:59:32.454]  - attr(*, "total_size")= num NA
[16:59:32.457]  - Getting '...' globals ... DONE
[16:59:32.457] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:32.457] List of 2
[16:59:32.457]  $ ...future.FUN:function (x)  
[16:59:32.457]  $ ...          : list()
[16:59:32.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.457]  - attr(*, "where")=List of 2
[16:59:32.457]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:32.457]   ..$ ...          :<environment: 0x55f315d0ad78> 
[16:59:32.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.457]  - attr(*, "resolved")= logi FALSE
[16:59:32.457]  - attr(*, "total_size")= num 848
[16:59:32.460] Packages to be attached in all futures: [n=0] 
[16:59:32.460] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.464] future_lapply() ...
[16:59:32.467] Number of chunks: 2
[16:59:32.468] getGlobalsAndPackagesXApply() ...
[16:59:32.468]  - future.globals: <name-value list> with names ‘list()’
[16:59:32.468]  - use_args: TRUE
[16:59:32.468] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:32.468] List of 2
[16:59:32.468]  $ ...          : list()
[16:59:32.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.468]  $ ...future.FUN:function (x)  
[16:59:32.468]  - attr(*, "where")=List of 2
[16:59:32.468]   ..$ ...          :<environment: 0x55f315d0ad78> 
[16:59:32.468]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:32.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.468]  - attr(*, "resolved")= logi FALSE
[16:59:32.468]  - attr(*, "total_size")= num NA
[16:59:32.473] Packages to be attached in all futures: [n=0] 
[16:59:32.474] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.474] Number of futures (= number of chunks): 2
[16:59:32.474] Launching 2 futures (chunks) ...
[16:59:32.474] Chunk #1 of 2 ...
[16:59:32.474]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.474]  - seeds: <none>
[16:59:32.474]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.474] getGlobalsAndPackages() ...
[16:59:32.474] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.475] Resolving globals: FALSE
[16:59:32.475] Tweak future expression to call with '...' arguments ...
[16:59:32.475] {
[16:59:32.475]     do.call(function(...) {
[16:59:32.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.475]             on.exit(options(oopts), add = TRUE)
[16:59:32.475]         }
[16:59:32.475]         {
[16:59:32.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.475]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.475]             })
[16:59:32.475]         }
[16:59:32.475]     }, args = future.call.arguments)
[16:59:32.475] }
[16:59:32.475] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.475] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.476] 
[16:59:32.476] getGlobalsAndPackages() ... DONE
[16:59:32.476] run() for ‘Future’ ...
[16:59:32.476] - state: ‘created’
[16:59:32.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.491] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.491]   - Field: ‘node’
[16:59:32.491]   - Field: ‘label’
[16:59:32.491]   - Field: ‘local’
[16:59:32.491]   - Field: ‘owner’
[16:59:32.491]   - Field: ‘envir’
[16:59:32.491]   - Field: ‘workers’
[16:59:32.491]   - Field: ‘packages’
[16:59:32.491]   - Field: ‘gc’
[16:59:32.491]   - Field: ‘conditions’
[16:59:32.492]   - Field: ‘persistent’
[16:59:32.492]   - Field: ‘expr’
[16:59:32.492]   - Field: ‘uuid’
[16:59:32.492]   - Field: ‘seed’
[16:59:32.492]   - Field: ‘version’
[16:59:32.492]   - Field: ‘result’
[16:59:32.492]   - Field: ‘asynchronous’
[16:59:32.492]   - Field: ‘calls’
[16:59:32.492]   - Field: ‘globals’
[16:59:32.492]   - Field: ‘stdout’
[16:59:32.492]   - Field: ‘earlySignal’
[16:59:32.493]   - Field: ‘lazy’
[16:59:32.493]   - Field: ‘state’
[16:59:32.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.493] - Launch lazy future ...
[16:59:32.493] Packages needed by the future expression (n = 0): <none>
[16:59:32.493] Packages needed by future strategies (n = 0): <none>
[16:59:32.494] {
[16:59:32.494]     {
[16:59:32.494]         {
[16:59:32.494]             ...future.startTime <- base::Sys.time()
[16:59:32.494]             {
[16:59:32.494]                 {
[16:59:32.494]                   {
[16:59:32.494]                     {
[16:59:32.494]                       base::local({
[16:59:32.494]                         has_future <- base::requireNamespace("future", 
[16:59:32.494]                           quietly = TRUE)
[16:59:32.494]                         if (has_future) {
[16:59:32.494]                           ns <- base::getNamespace("future")
[16:59:32.494]                           version <- ns[[".package"]][["version"]]
[16:59:32.494]                           if (is.null(version)) 
[16:59:32.494]                             version <- utils::packageVersion("future")
[16:59:32.494]                         }
[16:59:32.494]                         else {
[16:59:32.494]                           version <- NULL
[16:59:32.494]                         }
[16:59:32.494]                         if (!has_future || version < "1.8.0") {
[16:59:32.494]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.494]                             "", base::R.version$version.string), 
[16:59:32.494]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.494]                               "release", "version")], collapse = " "), 
[16:59:32.494]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.494]                             info)
[16:59:32.494]                           info <- base::paste(info, collapse = "; ")
[16:59:32.494]                           if (!has_future) {
[16:59:32.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.494]                               info)
[16:59:32.494]                           }
[16:59:32.494]                           else {
[16:59:32.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.494]                               info, version)
[16:59:32.494]                           }
[16:59:32.494]                           base::stop(msg)
[16:59:32.494]                         }
[16:59:32.494]                       })
[16:59:32.494]                     }
[16:59:32.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.494]                     base::options(mc.cores = 1L)
[16:59:32.494]                   }
[16:59:32.494]                   ...future.strategy.old <- future::plan("list")
[16:59:32.494]                   options(future.plan = NULL)
[16:59:32.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.494]                 }
[16:59:32.494]                 ...future.workdir <- getwd()
[16:59:32.494]             }
[16:59:32.494]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.494]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.494]         }
[16:59:32.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.494]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.494]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.494]             base::names(...future.oldOptions))
[16:59:32.494]     }
[16:59:32.494]     if (FALSE) {
[16:59:32.494]     }
[16:59:32.494]     else {
[16:59:32.494]         if (TRUE) {
[16:59:32.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.494]                 open = "w")
[16:59:32.494]         }
[16:59:32.494]         else {
[16:59:32.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.494]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.494]         }
[16:59:32.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.494]             base::sink(type = "output", split = FALSE)
[16:59:32.494]             base::close(...future.stdout)
[16:59:32.494]         }, add = TRUE)
[16:59:32.494]     }
[16:59:32.494]     ...future.frame <- base::sys.nframe()
[16:59:32.494]     ...future.conditions <- base::list()
[16:59:32.494]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.494]     if (FALSE) {
[16:59:32.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.494]     }
[16:59:32.494]     ...future.result <- base::tryCatch({
[16:59:32.494]         base::withCallingHandlers({
[16:59:32.494]             ...future.value <- base::withVisible(base::local({
[16:59:32.494]                 ...future.makeSendCondition <- base::local({
[16:59:32.494]                   sendCondition <- NULL
[16:59:32.494]                   function(frame = 1L) {
[16:59:32.494]                     if (is.function(sendCondition)) 
[16:59:32.494]                       return(sendCondition)
[16:59:32.494]                     ns <- getNamespace("parallel")
[16:59:32.494]                     if (exists("sendData", mode = "function", 
[16:59:32.494]                       envir = ns)) {
[16:59:32.494]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.494]                         envir = ns)
[16:59:32.494]                       envir <- sys.frame(frame)
[16:59:32.494]                       master <- NULL
[16:59:32.494]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.494]                         !identical(envir, emptyenv())) {
[16:59:32.494]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.494]                           inherits = FALSE)) {
[16:59:32.494]                           master <- get("master", mode = "list", 
[16:59:32.494]                             envir = envir, inherits = FALSE)
[16:59:32.494]                           if (inherits(master, c("SOCKnode", 
[16:59:32.494]                             "SOCK0node"))) {
[16:59:32.494]                             sendCondition <<- function(cond) {
[16:59:32.494]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.494]                                 success = TRUE)
[16:59:32.494]                               parallel_sendData(master, data)
[16:59:32.494]                             }
[16:59:32.494]                             return(sendCondition)
[16:59:32.494]                           }
[16:59:32.494]                         }
[16:59:32.494]                         frame <- frame + 1L
[16:59:32.494]                         envir <- sys.frame(frame)
[16:59:32.494]                       }
[16:59:32.494]                     }
[16:59:32.494]                     sendCondition <<- function(cond) NULL
[16:59:32.494]                   }
[16:59:32.494]                 })
[16:59:32.494]                 withCallingHandlers({
[16:59:32.494]                   {
[16:59:32.494]                     do.call(function(...) {
[16:59:32.494]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.494]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.494]                         ...future.globals.maxSize)) {
[16:59:32.494]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.494]                         on.exit(options(oopts), add = TRUE)
[16:59:32.494]                       }
[16:59:32.494]                       {
[16:59:32.494]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.494]                           FUN = function(jj) {
[16:59:32.494]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.494]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.494]                           })
[16:59:32.494]                       }
[16:59:32.494]                     }, args = future.call.arguments)
[16:59:32.494]                   }
[16:59:32.494]                 }, immediateCondition = function(cond) {
[16:59:32.494]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.494]                   sendCondition(cond)
[16:59:32.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.494]                   {
[16:59:32.494]                     inherits <- base::inherits
[16:59:32.494]                     invokeRestart <- base::invokeRestart
[16:59:32.494]                     is.null <- base::is.null
[16:59:32.494]                     muffled <- FALSE
[16:59:32.494]                     if (inherits(cond, "message")) {
[16:59:32.494]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.494]                       if (muffled) 
[16:59:32.494]                         invokeRestart("muffleMessage")
[16:59:32.494]                     }
[16:59:32.494]                     else if (inherits(cond, "warning")) {
[16:59:32.494]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.494]                       if (muffled) 
[16:59:32.494]                         invokeRestart("muffleWarning")
[16:59:32.494]                     }
[16:59:32.494]                     else if (inherits(cond, "condition")) {
[16:59:32.494]                       if (!is.null(pattern)) {
[16:59:32.494]                         computeRestarts <- base::computeRestarts
[16:59:32.494]                         grepl <- base::grepl
[16:59:32.494]                         restarts <- computeRestarts(cond)
[16:59:32.494]                         for (restart in restarts) {
[16:59:32.494]                           name <- restart$name
[16:59:32.494]                           if (is.null(name)) 
[16:59:32.494]                             next
[16:59:32.494]                           if (!grepl(pattern, name)) 
[16:59:32.494]                             next
[16:59:32.494]                           invokeRestart(restart)
[16:59:32.494]                           muffled <- TRUE
[16:59:32.494]                           break
[16:59:32.494]                         }
[16:59:32.494]                       }
[16:59:32.494]                     }
[16:59:32.494]                     invisible(muffled)
[16:59:32.494]                   }
[16:59:32.494]                   muffleCondition(cond)
[16:59:32.494]                 })
[16:59:32.494]             }))
[16:59:32.494]             future::FutureResult(value = ...future.value$value, 
[16:59:32.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.494]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.494]                     ...future.globalenv.names))
[16:59:32.494]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.494]         }, condition = base::local({
[16:59:32.494]             c <- base::c
[16:59:32.494]             inherits <- base::inherits
[16:59:32.494]             invokeRestart <- base::invokeRestart
[16:59:32.494]             length <- base::length
[16:59:32.494]             list <- base::list
[16:59:32.494]             seq.int <- base::seq.int
[16:59:32.494]             signalCondition <- base::signalCondition
[16:59:32.494]             sys.calls <- base::sys.calls
[16:59:32.494]             `[[` <- base::`[[`
[16:59:32.494]             `+` <- base::`+`
[16:59:32.494]             `<<-` <- base::`<<-`
[16:59:32.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.494]                   3L)]
[16:59:32.494]             }
[16:59:32.494]             function(cond) {
[16:59:32.494]                 is_error <- inherits(cond, "error")
[16:59:32.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.494]                   NULL)
[16:59:32.494]                 if (is_error) {
[16:59:32.494]                   sessionInformation <- function() {
[16:59:32.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.494]                       search = base::search(), system = base::Sys.info())
[16:59:32.494]                   }
[16:59:32.494]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.494]                     cond$call), session = sessionInformation(), 
[16:59:32.494]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.494]                   signalCondition(cond)
[16:59:32.494]                 }
[16:59:32.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.494]                 "immediateCondition"))) {
[16:59:32.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.494]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.494]                   if (TRUE && !signal) {
[16:59:32.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.494]                     {
[16:59:32.494]                       inherits <- base::inherits
[16:59:32.494]                       invokeRestart <- base::invokeRestart
[16:59:32.494]                       is.null <- base::is.null
[16:59:32.494]                       muffled <- FALSE
[16:59:32.494]                       if (inherits(cond, "message")) {
[16:59:32.494]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.494]                         if (muffled) 
[16:59:32.494]                           invokeRestart("muffleMessage")
[16:59:32.494]                       }
[16:59:32.494]                       else if (inherits(cond, "warning")) {
[16:59:32.494]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.494]                         if (muffled) 
[16:59:32.494]                           invokeRestart("muffleWarning")
[16:59:32.494]                       }
[16:59:32.494]                       else if (inherits(cond, "condition")) {
[16:59:32.494]                         if (!is.null(pattern)) {
[16:59:32.494]                           computeRestarts <- base::computeRestarts
[16:59:32.494]                           grepl <- base::grepl
[16:59:32.494]                           restarts <- computeRestarts(cond)
[16:59:32.494]                           for (restart in restarts) {
[16:59:32.494]                             name <- restart$name
[16:59:32.494]                             if (is.null(name)) 
[16:59:32.494]                               next
[16:59:32.494]                             if (!grepl(pattern, name)) 
[16:59:32.494]                               next
[16:59:32.494]                             invokeRestart(restart)
[16:59:32.494]                             muffled <- TRUE
[16:59:32.494]                             break
[16:59:32.494]                           }
[16:59:32.494]                         }
[16:59:32.494]                       }
[16:59:32.494]                       invisible(muffled)
[16:59:32.494]                     }
[16:59:32.494]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.494]                   }
[16:59:32.494]                 }
[16:59:32.494]                 else {
[16:59:32.494]                   if (TRUE) {
[16:59:32.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.494]                     {
[16:59:32.494]                       inherits <- base::inherits
[16:59:32.494]                       invokeRestart <- base::invokeRestart
[16:59:32.494]                       is.null <- base::is.null
[16:59:32.494]                       muffled <- FALSE
[16:59:32.494]                       if (inherits(cond, "message")) {
[16:59:32.494]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.494]                         if (muffled) 
[16:59:32.494]                           invokeRestart("muffleMessage")
[16:59:32.494]                       }
[16:59:32.494]                       else if (inherits(cond, "warning")) {
[16:59:32.494]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.494]                         if (muffled) 
[16:59:32.494]                           invokeRestart("muffleWarning")
[16:59:32.494]                       }
[16:59:32.494]                       else if (inherits(cond, "condition")) {
[16:59:32.494]                         if (!is.null(pattern)) {
[16:59:32.494]                           computeRestarts <- base::computeRestarts
[16:59:32.494]                           grepl <- base::grepl
[16:59:32.494]                           restarts <- computeRestarts(cond)
[16:59:32.494]                           for (restart in restarts) {
[16:59:32.494]                             name <- restart$name
[16:59:32.494]                             if (is.null(name)) 
[16:59:32.494]                               next
[16:59:32.494]                             if (!grepl(pattern, name)) 
[16:59:32.494]                               next
[16:59:32.494]                             invokeRestart(restart)
[16:59:32.494]                             muffled <- TRUE
[16:59:32.494]                             break
[16:59:32.494]                           }
[16:59:32.494]                         }
[16:59:32.494]                       }
[16:59:32.494]                       invisible(muffled)
[16:59:32.494]                     }
[16:59:32.494]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.494]                   }
[16:59:32.494]                 }
[16:59:32.494]             }
[16:59:32.494]         }))
[16:59:32.494]     }, error = function(ex) {
[16:59:32.494]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.494]                 ...future.rng), started = ...future.startTime, 
[16:59:32.494]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.494]             version = "1.8"), class = "FutureResult")
[16:59:32.494]     }, finally = {
[16:59:32.494]         if (!identical(...future.workdir, getwd())) 
[16:59:32.494]             setwd(...future.workdir)
[16:59:32.494]         {
[16:59:32.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.494]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.494]             }
[16:59:32.494]             base::options(...future.oldOptions)
[16:59:32.494]             if (.Platform$OS.type == "windows") {
[16:59:32.494]                 old_names <- names(...future.oldEnvVars)
[16:59:32.494]                 envs <- base::Sys.getenv()
[16:59:32.494]                 names <- names(envs)
[16:59:32.494]                 common <- intersect(names, old_names)
[16:59:32.494]                 added <- setdiff(names, old_names)
[16:59:32.494]                 removed <- setdiff(old_names, names)
[16:59:32.494]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.494]                   envs[common]]
[16:59:32.494]                 NAMES <- toupper(changed)
[16:59:32.494]                 args <- list()
[16:59:32.494]                 for (kk in seq_along(NAMES)) {
[16:59:32.494]                   name <- changed[[kk]]
[16:59:32.494]                   NAME <- NAMES[[kk]]
[16:59:32.494]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.494]                     next
[16:59:32.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.494]                 }
[16:59:32.494]                 NAMES <- toupper(added)
[16:59:32.494]                 for (kk in seq_along(NAMES)) {
[16:59:32.494]                   name <- added[[kk]]
[16:59:32.494]                   NAME <- NAMES[[kk]]
[16:59:32.494]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.494]                     next
[16:59:32.494]                   args[[name]] <- ""
[16:59:32.494]                 }
[16:59:32.494]                 NAMES <- toupper(removed)
[16:59:32.494]                 for (kk in seq_along(NAMES)) {
[16:59:32.494]                   name <- removed[[kk]]
[16:59:32.494]                   NAME <- NAMES[[kk]]
[16:59:32.494]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.494]                     next
[16:59:32.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.494]                 }
[16:59:32.494]                 if (length(args) > 0) 
[16:59:32.494]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.494]             }
[16:59:32.494]             else {
[16:59:32.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.494]             }
[16:59:32.494]             {
[16:59:32.494]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.494]                   0L) {
[16:59:32.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.494]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.494]                   base::options(opts)
[16:59:32.494]                 }
[16:59:32.494]                 {
[16:59:32.494]                   {
[16:59:32.494]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.494]                     NULL
[16:59:32.494]                   }
[16:59:32.494]                   options(future.plan = NULL)
[16:59:32.494]                   if (is.na(NA_character_)) 
[16:59:32.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.494]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.494]                     .init = FALSE)
[16:59:32.494]                 }
[16:59:32.494]             }
[16:59:32.494]         }
[16:59:32.494]     })
[16:59:32.494]     if (TRUE) {
[16:59:32.494]         base::sink(type = "output", split = FALSE)
[16:59:32.494]         if (TRUE) {
[16:59:32.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.494]         }
[16:59:32.494]         else {
[16:59:32.494]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.494]         }
[16:59:32.494]         base::close(...future.stdout)
[16:59:32.494]         ...future.stdout <- NULL
[16:59:32.494]     }
[16:59:32.494]     ...future.result$conditions <- ...future.conditions
[16:59:32.494]     ...future.result$finished <- base::Sys.time()
[16:59:32.494]     ...future.result
[16:59:32.494] }
[16:59:32.497] Exporting 5 global objects (0.99 KiB) to cluster node #1 ...
[16:59:32.497] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.497] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.497] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:59:32.498] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:59:32.498] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:59:32.498] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:59:32.498] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.499] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.499] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.499] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.499] Exporting 5 global objects (0.99 KiB) to cluster node #1 ... DONE
[16:59:32.500] MultisessionFuture started
[16:59:32.500] - Launch lazy future ... done
[16:59:32.500] run() for ‘MultisessionFuture’ ... done
[16:59:32.500] Created future:
[16:59:32.500] MultisessionFuture:
[16:59:32.500] Label: ‘future_apply-1’
[16:59:32.500] Expression:
[16:59:32.500] {
[16:59:32.500]     do.call(function(...) {
[16:59:32.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.500]             on.exit(options(oopts), add = TRUE)
[16:59:32.500]         }
[16:59:32.500]         {
[16:59:32.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.500]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.500]             })
[16:59:32.500]         }
[16:59:32.500]     }, args = future.call.arguments)
[16:59:32.500] }
[16:59:32.500] Lazy evaluation: FALSE
[16:59:32.500] Asynchronous evaluation: TRUE
[16:59:32.500] Local evaluation: TRUE
[16:59:32.500] Environment: R_GlobalEnv
[16:59:32.500] Capture standard output: TRUE
[16:59:32.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.500] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.500] Packages: <none>
[16:59:32.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.500] Resolved: FALSE
[16:59:32.500] Value: <not collected>
[16:59:32.500] Conditions captured: <none>
[16:59:32.500] Early signaling: FALSE
[16:59:32.500] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.500] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.512] Chunk #1 of 2 ... DONE
[16:59:32.512] Chunk #2 of 2 ...
[16:59:32.512]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.512]  - seeds: <none>
[16:59:32.512]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.512] getGlobalsAndPackages() ...
[16:59:32.513] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.513] Resolving globals: FALSE
[16:59:32.513] Tweak future expression to call with '...' arguments ...
[16:59:32.513] {
[16:59:32.513]     do.call(function(...) {
[16:59:32.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.513]             on.exit(options(oopts), add = TRUE)
[16:59:32.513]         }
[16:59:32.513]         {
[16:59:32.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.513]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.513]             })
[16:59:32.513]         }
[16:59:32.513]     }, args = future.call.arguments)
[16:59:32.513] }
[16:59:32.513] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.514] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.514] 
[16:59:32.514] getGlobalsAndPackages() ... DONE
[16:59:32.514] run() for ‘Future’ ...
[16:59:32.514] - state: ‘created’
[16:59:32.514] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.528] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.529]   - Field: ‘node’
[16:59:32.529]   - Field: ‘label’
[16:59:32.529]   - Field: ‘local’
[16:59:32.529]   - Field: ‘owner’
[16:59:32.529]   - Field: ‘envir’
[16:59:32.529]   - Field: ‘workers’
[16:59:32.529]   - Field: ‘packages’
[16:59:32.529]   - Field: ‘gc’
[16:59:32.529]   - Field: ‘conditions’
[16:59:32.529]   - Field: ‘persistent’
[16:59:32.530]   - Field: ‘expr’
[16:59:32.530]   - Field: ‘uuid’
[16:59:32.530]   - Field: ‘seed’
[16:59:32.530]   - Field: ‘version’
[16:59:32.530]   - Field: ‘result’
[16:59:32.530]   - Field: ‘asynchronous’
[16:59:32.530]   - Field: ‘calls’
[16:59:32.530]   - Field: ‘globals’
[16:59:32.530]   - Field: ‘stdout’
[16:59:32.530]   - Field: ‘earlySignal’
[16:59:32.530]   - Field: ‘lazy’
[16:59:32.530]   - Field: ‘state’
[16:59:32.531] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.531] - Launch lazy future ...
[16:59:32.531] Packages needed by the future expression (n = 0): <none>
[16:59:32.531] Packages needed by future strategies (n = 0): <none>
[16:59:32.532] {
[16:59:32.532]     {
[16:59:32.532]         {
[16:59:32.532]             ...future.startTime <- base::Sys.time()
[16:59:32.532]             {
[16:59:32.532]                 {
[16:59:32.532]                   {
[16:59:32.532]                     {
[16:59:32.532]                       base::local({
[16:59:32.532]                         has_future <- base::requireNamespace("future", 
[16:59:32.532]                           quietly = TRUE)
[16:59:32.532]                         if (has_future) {
[16:59:32.532]                           ns <- base::getNamespace("future")
[16:59:32.532]                           version <- ns[[".package"]][["version"]]
[16:59:32.532]                           if (is.null(version)) 
[16:59:32.532]                             version <- utils::packageVersion("future")
[16:59:32.532]                         }
[16:59:32.532]                         else {
[16:59:32.532]                           version <- NULL
[16:59:32.532]                         }
[16:59:32.532]                         if (!has_future || version < "1.8.0") {
[16:59:32.532]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.532]                             "", base::R.version$version.string), 
[16:59:32.532]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.532]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.532]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.532]                               "release", "version")], collapse = " "), 
[16:59:32.532]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.532]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.532]                             info)
[16:59:32.532]                           info <- base::paste(info, collapse = "; ")
[16:59:32.532]                           if (!has_future) {
[16:59:32.532]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.532]                               info)
[16:59:32.532]                           }
[16:59:32.532]                           else {
[16:59:32.532]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.532]                               info, version)
[16:59:32.532]                           }
[16:59:32.532]                           base::stop(msg)
[16:59:32.532]                         }
[16:59:32.532]                       })
[16:59:32.532]                     }
[16:59:32.532]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.532]                     base::options(mc.cores = 1L)
[16:59:32.532]                   }
[16:59:32.532]                   ...future.strategy.old <- future::plan("list")
[16:59:32.532]                   options(future.plan = NULL)
[16:59:32.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.532]                 }
[16:59:32.532]                 ...future.workdir <- getwd()
[16:59:32.532]             }
[16:59:32.532]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.532]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.532]         }
[16:59:32.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.532]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.532]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.532]             base::names(...future.oldOptions))
[16:59:32.532]     }
[16:59:32.532]     if (FALSE) {
[16:59:32.532]     }
[16:59:32.532]     else {
[16:59:32.532]         if (TRUE) {
[16:59:32.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.532]                 open = "w")
[16:59:32.532]         }
[16:59:32.532]         else {
[16:59:32.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.532]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.532]         }
[16:59:32.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.532]             base::sink(type = "output", split = FALSE)
[16:59:32.532]             base::close(...future.stdout)
[16:59:32.532]         }, add = TRUE)
[16:59:32.532]     }
[16:59:32.532]     ...future.frame <- base::sys.nframe()
[16:59:32.532]     ...future.conditions <- base::list()
[16:59:32.532]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.532]     if (FALSE) {
[16:59:32.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.532]     }
[16:59:32.532]     ...future.result <- base::tryCatch({
[16:59:32.532]         base::withCallingHandlers({
[16:59:32.532]             ...future.value <- base::withVisible(base::local({
[16:59:32.532]                 ...future.makeSendCondition <- base::local({
[16:59:32.532]                   sendCondition <- NULL
[16:59:32.532]                   function(frame = 1L) {
[16:59:32.532]                     if (is.function(sendCondition)) 
[16:59:32.532]                       return(sendCondition)
[16:59:32.532]                     ns <- getNamespace("parallel")
[16:59:32.532]                     if (exists("sendData", mode = "function", 
[16:59:32.532]                       envir = ns)) {
[16:59:32.532]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.532]                         envir = ns)
[16:59:32.532]                       envir <- sys.frame(frame)
[16:59:32.532]                       master <- NULL
[16:59:32.532]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.532]                         !identical(envir, emptyenv())) {
[16:59:32.532]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.532]                           inherits = FALSE)) {
[16:59:32.532]                           master <- get("master", mode = "list", 
[16:59:32.532]                             envir = envir, inherits = FALSE)
[16:59:32.532]                           if (inherits(master, c("SOCKnode", 
[16:59:32.532]                             "SOCK0node"))) {
[16:59:32.532]                             sendCondition <<- function(cond) {
[16:59:32.532]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.532]                                 success = TRUE)
[16:59:32.532]                               parallel_sendData(master, data)
[16:59:32.532]                             }
[16:59:32.532]                             return(sendCondition)
[16:59:32.532]                           }
[16:59:32.532]                         }
[16:59:32.532]                         frame <- frame + 1L
[16:59:32.532]                         envir <- sys.frame(frame)
[16:59:32.532]                       }
[16:59:32.532]                     }
[16:59:32.532]                     sendCondition <<- function(cond) NULL
[16:59:32.532]                   }
[16:59:32.532]                 })
[16:59:32.532]                 withCallingHandlers({
[16:59:32.532]                   {
[16:59:32.532]                     do.call(function(...) {
[16:59:32.532]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.532]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.532]                         ...future.globals.maxSize)) {
[16:59:32.532]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.532]                         on.exit(options(oopts), add = TRUE)
[16:59:32.532]                       }
[16:59:32.532]                       {
[16:59:32.532]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.532]                           FUN = function(jj) {
[16:59:32.532]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.532]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.532]                           })
[16:59:32.532]                       }
[16:59:32.532]                     }, args = future.call.arguments)
[16:59:32.532]                   }
[16:59:32.532]                 }, immediateCondition = function(cond) {
[16:59:32.532]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.532]                   sendCondition(cond)
[16:59:32.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.532]                   {
[16:59:32.532]                     inherits <- base::inherits
[16:59:32.532]                     invokeRestart <- base::invokeRestart
[16:59:32.532]                     is.null <- base::is.null
[16:59:32.532]                     muffled <- FALSE
[16:59:32.532]                     if (inherits(cond, "message")) {
[16:59:32.532]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.532]                       if (muffled) 
[16:59:32.532]                         invokeRestart("muffleMessage")
[16:59:32.532]                     }
[16:59:32.532]                     else if (inherits(cond, "warning")) {
[16:59:32.532]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.532]                       if (muffled) 
[16:59:32.532]                         invokeRestart("muffleWarning")
[16:59:32.532]                     }
[16:59:32.532]                     else if (inherits(cond, "condition")) {
[16:59:32.532]                       if (!is.null(pattern)) {
[16:59:32.532]                         computeRestarts <- base::computeRestarts
[16:59:32.532]                         grepl <- base::grepl
[16:59:32.532]                         restarts <- computeRestarts(cond)
[16:59:32.532]                         for (restart in restarts) {
[16:59:32.532]                           name <- restart$name
[16:59:32.532]                           if (is.null(name)) 
[16:59:32.532]                             next
[16:59:32.532]                           if (!grepl(pattern, name)) 
[16:59:32.532]                             next
[16:59:32.532]                           invokeRestart(restart)
[16:59:32.532]                           muffled <- TRUE
[16:59:32.532]                           break
[16:59:32.532]                         }
[16:59:32.532]                       }
[16:59:32.532]                     }
[16:59:32.532]                     invisible(muffled)
[16:59:32.532]                   }
[16:59:32.532]                   muffleCondition(cond)
[16:59:32.532]                 })
[16:59:32.532]             }))
[16:59:32.532]             future::FutureResult(value = ...future.value$value, 
[16:59:32.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.532]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.532]                     ...future.globalenv.names))
[16:59:32.532]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.532]         }, condition = base::local({
[16:59:32.532]             c <- base::c
[16:59:32.532]             inherits <- base::inherits
[16:59:32.532]             invokeRestart <- base::invokeRestart
[16:59:32.532]             length <- base::length
[16:59:32.532]             list <- base::list
[16:59:32.532]             seq.int <- base::seq.int
[16:59:32.532]             signalCondition <- base::signalCondition
[16:59:32.532]             sys.calls <- base::sys.calls
[16:59:32.532]             `[[` <- base::`[[`
[16:59:32.532]             `+` <- base::`+`
[16:59:32.532]             `<<-` <- base::`<<-`
[16:59:32.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.532]                   3L)]
[16:59:32.532]             }
[16:59:32.532]             function(cond) {
[16:59:32.532]                 is_error <- inherits(cond, "error")
[16:59:32.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.532]                   NULL)
[16:59:32.532]                 if (is_error) {
[16:59:32.532]                   sessionInformation <- function() {
[16:59:32.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.532]                       search = base::search(), system = base::Sys.info())
[16:59:32.532]                   }
[16:59:32.532]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.532]                     cond$call), session = sessionInformation(), 
[16:59:32.532]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.532]                   signalCondition(cond)
[16:59:32.532]                 }
[16:59:32.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.532]                 "immediateCondition"))) {
[16:59:32.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.532]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.532]                   if (TRUE && !signal) {
[16:59:32.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.532]                     {
[16:59:32.532]                       inherits <- base::inherits
[16:59:32.532]                       invokeRestart <- base::invokeRestart
[16:59:32.532]                       is.null <- base::is.null
[16:59:32.532]                       muffled <- FALSE
[16:59:32.532]                       if (inherits(cond, "message")) {
[16:59:32.532]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.532]                         if (muffled) 
[16:59:32.532]                           invokeRestart("muffleMessage")
[16:59:32.532]                       }
[16:59:32.532]                       else if (inherits(cond, "warning")) {
[16:59:32.532]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.532]                         if (muffled) 
[16:59:32.532]                           invokeRestart("muffleWarning")
[16:59:32.532]                       }
[16:59:32.532]                       else if (inherits(cond, "condition")) {
[16:59:32.532]                         if (!is.null(pattern)) {
[16:59:32.532]                           computeRestarts <- base::computeRestarts
[16:59:32.532]                           grepl <- base::grepl
[16:59:32.532]                           restarts <- computeRestarts(cond)
[16:59:32.532]                           for (restart in restarts) {
[16:59:32.532]                             name <- restart$name
[16:59:32.532]                             if (is.null(name)) 
[16:59:32.532]                               next
[16:59:32.532]                             if (!grepl(pattern, name)) 
[16:59:32.532]                               next
[16:59:32.532]                             invokeRestart(restart)
[16:59:32.532]                             muffled <- TRUE
[16:59:32.532]                             break
[16:59:32.532]                           }
[16:59:32.532]                         }
[16:59:32.532]                       }
[16:59:32.532]                       invisible(muffled)
[16:59:32.532]                     }
[16:59:32.532]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.532]                   }
[16:59:32.532]                 }
[16:59:32.532]                 else {
[16:59:32.532]                   if (TRUE) {
[16:59:32.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.532]                     {
[16:59:32.532]                       inherits <- base::inherits
[16:59:32.532]                       invokeRestart <- base::invokeRestart
[16:59:32.532]                       is.null <- base::is.null
[16:59:32.532]                       muffled <- FALSE
[16:59:32.532]                       if (inherits(cond, "message")) {
[16:59:32.532]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.532]                         if (muffled) 
[16:59:32.532]                           invokeRestart("muffleMessage")
[16:59:32.532]                       }
[16:59:32.532]                       else if (inherits(cond, "warning")) {
[16:59:32.532]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.532]                         if (muffled) 
[16:59:32.532]                           invokeRestart("muffleWarning")
[16:59:32.532]                       }
[16:59:32.532]                       else if (inherits(cond, "condition")) {
[16:59:32.532]                         if (!is.null(pattern)) {
[16:59:32.532]                           computeRestarts <- base::computeRestarts
[16:59:32.532]                           grepl <- base::grepl
[16:59:32.532]                           restarts <- computeRestarts(cond)
[16:59:32.532]                           for (restart in restarts) {
[16:59:32.532]                             name <- restart$name
[16:59:32.532]                             if (is.null(name)) 
[16:59:32.532]                               next
[16:59:32.532]                             if (!grepl(pattern, name)) 
[16:59:32.532]                               next
[16:59:32.532]                             invokeRestart(restart)
[16:59:32.532]                             muffled <- TRUE
[16:59:32.532]                             break
[16:59:32.532]                           }
[16:59:32.532]                         }
[16:59:32.532]                       }
[16:59:32.532]                       invisible(muffled)
[16:59:32.532]                     }
[16:59:32.532]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.532]                   }
[16:59:32.532]                 }
[16:59:32.532]             }
[16:59:32.532]         }))
[16:59:32.532]     }, error = function(ex) {
[16:59:32.532]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.532]                 ...future.rng), started = ...future.startTime, 
[16:59:32.532]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.532]             version = "1.8"), class = "FutureResult")
[16:59:32.532]     }, finally = {
[16:59:32.532]         if (!identical(...future.workdir, getwd())) 
[16:59:32.532]             setwd(...future.workdir)
[16:59:32.532]         {
[16:59:32.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.532]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.532]             }
[16:59:32.532]             base::options(...future.oldOptions)
[16:59:32.532]             if (.Platform$OS.type == "windows") {
[16:59:32.532]                 old_names <- names(...future.oldEnvVars)
[16:59:32.532]                 envs <- base::Sys.getenv()
[16:59:32.532]                 names <- names(envs)
[16:59:32.532]                 common <- intersect(names, old_names)
[16:59:32.532]                 added <- setdiff(names, old_names)
[16:59:32.532]                 removed <- setdiff(old_names, names)
[16:59:32.532]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.532]                   envs[common]]
[16:59:32.532]                 NAMES <- toupper(changed)
[16:59:32.532]                 args <- list()
[16:59:32.532]                 for (kk in seq_along(NAMES)) {
[16:59:32.532]                   name <- changed[[kk]]
[16:59:32.532]                   NAME <- NAMES[[kk]]
[16:59:32.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.532]                     next
[16:59:32.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.532]                 }
[16:59:32.532]                 NAMES <- toupper(added)
[16:59:32.532]                 for (kk in seq_along(NAMES)) {
[16:59:32.532]                   name <- added[[kk]]
[16:59:32.532]                   NAME <- NAMES[[kk]]
[16:59:32.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.532]                     next
[16:59:32.532]                   args[[name]] <- ""
[16:59:32.532]                 }
[16:59:32.532]                 NAMES <- toupper(removed)
[16:59:32.532]                 for (kk in seq_along(NAMES)) {
[16:59:32.532]                   name <- removed[[kk]]
[16:59:32.532]                   NAME <- NAMES[[kk]]
[16:59:32.532]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.532]                     next
[16:59:32.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.532]                 }
[16:59:32.532]                 if (length(args) > 0) 
[16:59:32.532]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.532]             }
[16:59:32.532]             else {
[16:59:32.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.532]             }
[16:59:32.532]             {
[16:59:32.532]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.532]                   0L) {
[16:59:32.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.532]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.532]                   base::options(opts)
[16:59:32.532]                 }
[16:59:32.532]                 {
[16:59:32.532]                   {
[16:59:32.532]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.532]                     NULL
[16:59:32.532]                   }
[16:59:32.532]                   options(future.plan = NULL)
[16:59:32.532]                   if (is.na(NA_character_)) 
[16:59:32.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.532]                     .init = FALSE)
[16:59:32.532]                 }
[16:59:32.532]             }
[16:59:32.532]         }
[16:59:32.532]     })
[16:59:32.532]     if (TRUE) {
[16:59:32.532]         base::sink(type = "output", split = FALSE)
[16:59:32.532]         if (TRUE) {
[16:59:32.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.532]         }
[16:59:32.532]         else {
[16:59:32.532]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.532]         }
[16:59:32.532]         base::close(...future.stdout)
[16:59:32.532]         ...future.stdout <- NULL
[16:59:32.532]     }
[16:59:32.532]     ...future.result$conditions <- ...future.conditions
[16:59:32.532]     ...future.result$finished <- base::Sys.time()
[16:59:32.532]     ...future.result
[16:59:32.532] }
[16:59:32.535] Exporting 5 global objects (0.99 KiB) to cluster node #2 ...
[16:59:32.535] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:32.535] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.535] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:59:32.536] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:59:32.536] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:59:32.536] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:59:32.536] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:32.537] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.537] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:32.537] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:32.537] Exporting 5 global objects (0.99 KiB) to cluster node #2 ... DONE
[16:59:32.538] MultisessionFuture started
[16:59:32.538] - Launch lazy future ... done
[16:59:32.538] run() for ‘MultisessionFuture’ ... done
[16:59:32.538] Created future:
[16:59:32.538] MultisessionFuture:
[16:59:32.538] Label: ‘future_apply-2’
[16:59:32.538] Expression:
[16:59:32.538] {
[16:59:32.538]     do.call(function(...) {
[16:59:32.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.538]             on.exit(options(oopts), add = TRUE)
[16:59:32.538]         }
[16:59:32.538]         {
[16:59:32.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.538]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.538]             })
[16:59:32.538]         }
[16:59:32.538]     }, args = future.call.arguments)
[16:59:32.538] }
[16:59:32.538] Lazy evaluation: FALSE
[16:59:32.538] Asynchronous evaluation: TRUE
[16:59:32.538] Local evaluation: TRUE
[16:59:32.538] Environment: R_GlobalEnv
[16:59:32.538] Capture standard output: TRUE
[16:59:32.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.538] Globals: 5 objects totaling 0.99 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.538] Packages: <none>
[16:59:32.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.538] Resolved: FALSE
[16:59:32.538] Value: <not collected>
[16:59:32.538] Conditions captured: <none>
[16:59:32.538] Early signaling: FALSE
[16:59:32.538] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.538] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.550] Chunk #2 of 2 ... DONE
[16:59:32.550] Launching 2 futures (chunks) ... DONE
[16:59:32.550] Resolving 2 futures (chunks) ...
[16:59:32.550] resolve() on list ...
[16:59:32.550]  recursive: 0
[16:59:32.550]  length: 2
[16:59:32.550] 
[16:59:32.551] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.551] - Validating connection of MultisessionFuture
[16:59:32.551] - received message: FutureResult
[16:59:32.551] - Received FutureResult
[16:59:32.551] - Erased future from FutureRegistry
[16:59:32.552] result() for ClusterFuture ...
[16:59:32.552] - result already collected: FutureResult
[16:59:32.552] result() for ClusterFuture ... done
[16:59:32.552] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.552] Future #1
[16:59:32.552] result() for ClusterFuture ...
[16:59:32.552] - result already collected: FutureResult
[16:59:32.552] result() for ClusterFuture ... done
[16:59:32.552] result() for ClusterFuture ...
[16:59:32.552] - result already collected: FutureResult
[16:59:32.552] result() for ClusterFuture ... done
[16:59:32.552] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:32.553] - nx: 2
[16:59:32.553] - relay: TRUE
[16:59:32.553] - stdout: TRUE
[16:59:32.553] - signal: TRUE
[16:59:32.553] - resignal: FALSE
[16:59:32.553] - force: TRUE
[16:59:32.553] - relayed: [n=2] FALSE, FALSE
[16:59:32.553] - queued futures: [n=2] FALSE, FALSE
[16:59:32.553]  - until=1
[16:59:32.553]  - relaying element #1
[16:59:32.553] result() for ClusterFuture ...
[16:59:32.553] - result already collected: FutureResult
[16:59:32.554] result() for ClusterFuture ... done
[16:59:32.554] result() for ClusterFuture ...
[16:59:32.554] - result already collected: FutureResult
[16:59:32.554] result() for ClusterFuture ... done
[16:59:32.554] result() for ClusterFuture ...
[16:59:32.554] - result already collected: FutureResult
[16:59:32.554] result() for ClusterFuture ... done
[16:59:32.554] result() for ClusterFuture ...
[16:59:32.554] - result already collected: FutureResult
[16:59:32.554] result() for ClusterFuture ... done
[16:59:32.554] - relayed: [n=2] TRUE, FALSE
[16:59:32.555] - queued futures: [n=2] TRUE, FALSE
[16:59:32.555] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:32.555]  length: 1 (resolved future 1)
[16:59:32.581] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.581] - Validating connection of MultisessionFuture
[16:59:32.581] - received message: FutureResult
[16:59:32.581] - Received FutureResult
[16:59:32.581] - Erased future from FutureRegistry
[16:59:32.582] result() for ClusterFuture ...
[16:59:32.582] - result already collected: FutureResult
[16:59:32.582] result() for ClusterFuture ... done
[16:59:32.582] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.582] Future #2
[16:59:32.582] result() for ClusterFuture ...
[16:59:32.582] - result already collected: FutureResult
[16:59:32.582] result() for ClusterFuture ... done
[16:59:32.582] result() for ClusterFuture ...
[16:59:32.582] - result already collected: FutureResult
[16:59:32.582] result() for ClusterFuture ... done
[16:59:32.583] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.583] - nx: 2
[16:59:32.583] - relay: TRUE
[16:59:32.583] - stdout: TRUE
[16:59:32.583] - signal: TRUE
[16:59:32.583] - resignal: FALSE
[16:59:32.583] - force: TRUE
[16:59:32.583] - relayed: [n=2] TRUE, FALSE
[16:59:32.583] - queued futures: [n=2] TRUE, FALSE
[16:59:32.583]  - until=2
[16:59:32.583]  - relaying element #2
[16:59:32.584] result() for ClusterFuture ...
[16:59:32.584] - result already collected: FutureResult
[16:59:32.584] result() for ClusterFuture ... done
[16:59:32.584] result() for ClusterFuture ...
[16:59:32.584] - result already collected: FutureResult
[16:59:32.584] result() for ClusterFuture ... done
[16:59:32.584] result() for ClusterFuture ...
[16:59:32.584] - result already collected: FutureResult
[16:59:32.584] result() for ClusterFuture ... done
[16:59:32.584] result() for ClusterFuture ...
[16:59:32.584] - result already collected: FutureResult
[16:59:32.584] result() for ClusterFuture ... done
[16:59:32.585] - relayed: [n=2] TRUE, TRUE
[16:59:32.585] - queued futures: [n=2] TRUE, TRUE
[16:59:32.585] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.585]  length: 0 (resolved future 2)
[16:59:32.585] Relaying remaining futures
[16:59:32.585] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.585] - nx: 2
[16:59:32.585] - relay: TRUE
[16:59:32.585] - stdout: TRUE
[16:59:32.585] - signal: TRUE
[16:59:32.585] - resignal: FALSE
[16:59:32.585] - force: TRUE
[16:59:32.586] - relayed: [n=2] TRUE, TRUE
[16:59:32.586] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.586] - relayed: [n=2] TRUE, TRUE
[16:59:32.586] - queued futures: [n=2] TRUE, TRUE
[16:59:32.586] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.586] resolve() on list ... DONE
[16:59:32.586] result() for ClusterFuture ...
[16:59:32.586] - result already collected: FutureResult
[16:59:32.586] result() for ClusterFuture ... done
[16:59:32.586] result() for ClusterFuture ...
[16:59:32.586] - result already collected: FutureResult
[16:59:32.587] result() for ClusterFuture ... done
[16:59:32.587] result() for ClusterFuture ...
[16:59:32.587] - result already collected: FutureResult
[16:59:32.587] result() for ClusterFuture ... done
[16:59:32.587] result() for ClusterFuture ...
[16:59:32.587] - result already collected: FutureResult
[16:59:32.587] result() for ClusterFuture ... done
[16:59:32.587]  - Number of value chunks collected: 2
[16:59:32.587] Resolving 2 futures (chunks) ... DONE
[16:59:32.587] Reducing values from 2 chunks ...
[16:59:32.587]  - Number of values collected after concatenation: 2
[16:59:32.588]  - Number of values expected: 2
[16:59:32.588] Reducing values from 2 chunks ... DONE
[16:59:32.588] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[16:59:32.588] getGlobalsAndPackagesXApply() ...
[16:59:32.588]  - future.globals: TRUE
[16:59:32.588] getGlobalsAndPackages() ...
[16:59:32.588] Searching for globals...
[16:59:32.589] - globals found: [1] ‘FUN’
[16:59:32.590] Searching for globals ... DONE
[16:59:32.590] Resolving globals: FALSE
[16:59:32.590] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:32.590] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:32.590] - globals: [1] ‘FUN’
[16:59:32.591] 
[16:59:32.591] getGlobalsAndPackages() ... DONE
[16:59:32.591]  - globals found/used: [n=1] ‘FUN’
[16:59:32.591]  - needed namespaces: [n=0] 
[16:59:32.591] Finding globals ... DONE
[16:59:32.591]  - use_args: TRUE
[16:59:32.591]  - Getting '...' globals ...
[16:59:32.591] resolve() on list ...
[16:59:32.592]  recursive: 0
[16:59:32.592]  length: 1
[16:59:32.592]  elements: ‘...’
[16:59:32.592]  length: 0 (resolved future 1)
[16:59:32.592] resolve() on list ... DONE
[16:59:32.592]    - '...' content: [n=0] 
[16:59:32.592] List of 1
[16:59:32.592]  $ ...: list()
[16:59:32.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.592]  - attr(*, "where")=List of 1
[16:59:32.592]   ..$ ...:<environment: 0x55f315035800> 
[16:59:32.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.592]  - attr(*, "resolved")= logi TRUE
[16:59:32.592]  - attr(*, "total_size")= num NA
[16:59:32.595]  - Getting '...' globals ... DONE
[16:59:32.595] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:32.595] List of 2
[16:59:32.595]  $ ...future.FUN:function (x)  
[16:59:32.595]  $ ...          : list()
[16:59:32.595]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.595]  - attr(*, "where")=List of 2
[16:59:32.595]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:32.595]   ..$ ...          :<environment: 0x55f315035800> 
[16:59:32.595]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.595]  - attr(*, "resolved")= logi FALSE
[16:59:32.595]  - attr(*, "total_size")= num 848
[16:59:32.597] Packages to be attached in all futures: [n=0] 
[16:59:32.597] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.601] future_lapply() ...
[16:59:32.605] Number of chunks: 2
[16:59:32.605] getGlobalsAndPackagesXApply() ...
[16:59:32.605]  - future.globals: <name-value list> with names ‘list()’
[16:59:32.605]  - use_args: TRUE
[16:59:32.606] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:32.606] List of 2
[16:59:32.606]  $ ...          : list()
[16:59:32.606]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.606]  $ ...future.FUN:function (x)  
[16:59:32.606]  - attr(*, "where")=List of 2
[16:59:32.606]   ..$ ...          :<environment: 0x55f315035800> 
[16:59:32.606]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:32.606]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.606]  - attr(*, "resolved")= logi FALSE
[16:59:32.606]  - attr(*, "total_size")= num NA
[16:59:32.609] Packages to be attached in all futures: [n=0] 
[16:59:32.609] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.609] Number of futures (= number of chunks): 2
[16:59:32.610] Launching 2 futures (chunks) ...
[16:59:32.610] Chunk #1 of 2 ...
[16:59:32.610]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.610]  - seeds: <none>
[16:59:32.610]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.610] getGlobalsAndPackages() ...
[16:59:32.610] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.610] Resolving globals: FALSE
[16:59:32.611] Tweak future expression to call with '...' arguments ...
[16:59:32.611] {
[16:59:32.611]     do.call(function(...) {
[16:59:32.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.611]             on.exit(options(oopts), add = TRUE)
[16:59:32.611]         }
[16:59:32.611]         {
[16:59:32.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.611]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.611]             })
[16:59:32.611]         }
[16:59:32.611]     }, args = future.call.arguments)
[16:59:32.611] }
[16:59:32.611] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.611] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.612] 
[16:59:32.612] getGlobalsAndPackages() ... DONE
[16:59:32.612] run() for ‘Future’ ...
[16:59:32.612] - state: ‘created’
[16:59:32.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.626] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.627]   - Field: ‘node’
[16:59:32.627]   - Field: ‘label’
[16:59:32.627]   - Field: ‘local’
[16:59:32.627]   - Field: ‘owner’
[16:59:32.627]   - Field: ‘envir’
[16:59:32.627]   - Field: ‘workers’
[16:59:32.627]   - Field: ‘packages’
[16:59:32.627]   - Field: ‘gc’
[16:59:32.627]   - Field: ‘conditions’
[16:59:32.628]   - Field: ‘persistent’
[16:59:32.628]   - Field: ‘expr’
[16:59:32.628]   - Field: ‘uuid’
[16:59:32.628]   - Field: ‘seed’
[16:59:32.628]   - Field: ‘version’
[16:59:32.628]   - Field: ‘result’
[16:59:32.628]   - Field: ‘asynchronous’
[16:59:32.628]   - Field: ‘calls’
[16:59:32.628]   - Field: ‘globals’
[16:59:32.628]   - Field: ‘stdout’
[16:59:32.628]   - Field: ‘earlySignal’
[16:59:32.629]   - Field: ‘lazy’
[16:59:32.629]   - Field: ‘state’
[16:59:32.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.629] - Launch lazy future ...
[16:59:32.629] Packages needed by the future expression (n = 0): <none>
[16:59:32.629] Packages needed by future strategies (n = 0): <none>
[16:59:32.630] {
[16:59:32.630]     {
[16:59:32.630]         {
[16:59:32.630]             ...future.startTime <- base::Sys.time()
[16:59:32.630]             {
[16:59:32.630]                 {
[16:59:32.630]                   {
[16:59:32.630]                     {
[16:59:32.630]                       base::local({
[16:59:32.630]                         has_future <- base::requireNamespace("future", 
[16:59:32.630]                           quietly = TRUE)
[16:59:32.630]                         if (has_future) {
[16:59:32.630]                           ns <- base::getNamespace("future")
[16:59:32.630]                           version <- ns[[".package"]][["version"]]
[16:59:32.630]                           if (is.null(version)) 
[16:59:32.630]                             version <- utils::packageVersion("future")
[16:59:32.630]                         }
[16:59:32.630]                         else {
[16:59:32.630]                           version <- NULL
[16:59:32.630]                         }
[16:59:32.630]                         if (!has_future || version < "1.8.0") {
[16:59:32.630]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.630]                             "", base::R.version$version.string), 
[16:59:32.630]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.630]                               "release", "version")], collapse = " "), 
[16:59:32.630]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.630]                             info)
[16:59:32.630]                           info <- base::paste(info, collapse = "; ")
[16:59:32.630]                           if (!has_future) {
[16:59:32.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.630]                               info)
[16:59:32.630]                           }
[16:59:32.630]                           else {
[16:59:32.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.630]                               info, version)
[16:59:32.630]                           }
[16:59:32.630]                           base::stop(msg)
[16:59:32.630]                         }
[16:59:32.630]                       })
[16:59:32.630]                     }
[16:59:32.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.630]                     base::options(mc.cores = 1L)
[16:59:32.630]                   }
[16:59:32.630]                   ...future.strategy.old <- future::plan("list")
[16:59:32.630]                   options(future.plan = NULL)
[16:59:32.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.630]                 }
[16:59:32.630]                 ...future.workdir <- getwd()
[16:59:32.630]             }
[16:59:32.630]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.630]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.630]         }
[16:59:32.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.630]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.630]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.630]             base::names(...future.oldOptions))
[16:59:32.630]     }
[16:59:32.630]     if (FALSE) {
[16:59:32.630]     }
[16:59:32.630]     else {
[16:59:32.630]         if (TRUE) {
[16:59:32.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.630]                 open = "w")
[16:59:32.630]         }
[16:59:32.630]         else {
[16:59:32.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.630]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.630]         }
[16:59:32.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.630]             base::sink(type = "output", split = FALSE)
[16:59:32.630]             base::close(...future.stdout)
[16:59:32.630]         }, add = TRUE)
[16:59:32.630]     }
[16:59:32.630]     ...future.frame <- base::sys.nframe()
[16:59:32.630]     ...future.conditions <- base::list()
[16:59:32.630]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.630]     if (FALSE) {
[16:59:32.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.630]     }
[16:59:32.630]     ...future.result <- base::tryCatch({
[16:59:32.630]         base::withCallingHandlers({
[16:59:32.630]             ...future.value <- base::withVisible(base::local({
[16:59:32.630]                 ...future.makeSendCondition <- base::local({
[16:59:32.630]                   sendCondition <- NULL
[16:59:32.630]                   function(frame = 1L) {
[16:59:32.630]                     if (is.function(sendCondition)) 
[16:59:32.630]                       return(sendCondition)
[16:59:32.630]                     ns <- getNamespace("parallel")
[16:59:32.630]                     if (exists("sendData", mode = "function", 
[16:59:32.630]                       envir = ns)) {
[16:59:32.630]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.630]                         envir = ns)
[16:59:32.630]                       envir <- sys.frame(frame)
[16:59:32.630]                       master <- NULL
[16:59:32.630]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.630]                         !identical(envir, emptyenv())) {
[16:59:32.630]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.630]                           inherits = FALSE)) {
[16:59:32.630]                           master <- get("master", mode = "list", 
[16:59:32.630]                             envir = envir, inherits = FALSE)
[16:59:32.630]                           if (inherits(master, c("SOCKnode", 
[16:59:32.630]                             "SOCK0node"))) {
[16:59:32.630]                             sendCondition <<- function(cond) {
[16:59:32.630]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.630]                                 success = TRUE)
[16:59:32.630]                               parallel_sendData(master, data)
[16:59:32.630]                             }
[16:59:32.630]                             return(sendCondition)
[16:59:32.630]                           }
[16:59:32.630]                         }
[16:59:32.630]                         frame <- frame + 1L
[16:59:32.630]                         envir <- sys.frame(frame)
[16:59:32.630]                       }
[16:59:32.630]                     }
[16:59:32.630]                     sendCondition <<- function(cond) NULL
[16:59:32.630]                   }
[16:59:32.630]                 })
[16:59:32.630]                 withCallingHandlers({
[16:59:32.630]                   {
[16:59:32.630]                     do.call(function(...) {
[16:59:32.630]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.630]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.630]                         ...future.globals.maxSize)) {
[16:59:32.630]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.630]                         on.exit(options(oopts), add = TRUE)
[16:59:32.630]                       }
[16:59:32.630]                       {
[16:59:32.630]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.630]                           FUN = function(jj) {
[16:59:32.630]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.630]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.630]                           })
[16:59:32.630]                       }
[16:59:32.630]                     }, args = future.call.arguments)
[16:59:32.630]                   }
[16:59:32.630]                 }, immediateCondition = function(cond) {
[16:59:32.630]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.630]                   sendCondition(cond)
[16:59:32.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.630]                   {
[16:59:32.630]                     inherits <- base::inherits
[16:59:32.630]                     invokeRestart <- base::invokeRestart
[16:59:32.630]                     is.null <- base::is.null
[16:59:32.630]                     muffled <- FALSE
[16:59:32.630]                     if (inherits(cond, "message")) {
[16:59:32.630]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.630]                       if (muffled) 
[16:59:32.630]                         invokeRestart("muffleMessage")
[16:59:32.630]                     }
[16:59:32.630]                     else if (inherits(cond, "warning")) {
[16:59:32.630]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.630]                       if (muffled) 
[16:59:32.630]                         invokeRestart("muffleWarning")
[16:59:32.630]                     }
[16:59:32.630]                     else if (inherits(cond, "condition")) {
[16:59:32.630]                       if (!is.null(pattern)) {
[16:59:32.630]                         computeRestarts <- base::computeRestarts
[16:59:32.630]                         grepl <- base::grepl
[16:59:32.630]                         restarts <- computeRestarts(cond)
[16:59:32.630]                         for (restart in restarts) {
[16:59:32.630]                           name <- restart$name
[16:59:32.630]                           if (is.null(name)) 
[16:59:32.630]                             next
[16:59:32.630]                           if (!grepl(pattern, name)) 
[16:59:32.630]                             next
[16:59:32.630]                           invokeRestart(restart)
[16:59:32.630]                           muffled <- TRUE
[16:59:32.630]                           break
[16:59:32.630]                         }
[16:59:32.630]                       }
[16:59:32.630]                     }
[16:59:32.630]                     invisible(muffled)
[16:59:32.630]                   }
[16:59:32.630]                   muffleCondition(cond)
[16:59:32.630]                 })
[16:59:32.630]             }))
[16:59:32.630]             future::FutureResult(value = ...future.value$value, 
[16:59:32.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.630]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.630]                     ...future.globalenv.names))
[16:59:32.630]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.630]         }, condition = base::local({
[16:59:32.630]             c <- base::c
[16:59:32.630]             inherits <- base::inherits
[16:59:32.630]             invokeRestart <- base::invokeRestart
[16:59:32.630]             length <- base::length
[16:59:32.630]             list <- base::list
[16:59:32.630]             seq.int <- base::seq.int
[16:59:32.630]             signalCondition <- base::signalCondition
[16:59:32.630]             sys.calls <- base::sys.calls
[16:59:32.630]             `[[` <- base::`[[`
[16:59:32.630]             `+` <- base::`+`
[16:59:32.630]             `<<-` <- base::`<<-`
[16:59:32.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.630]                   3L)]
[16:59:32.630]             }
[16:59:32.630]             function(cond) {
[16:59:32.630]                 is_error <- inherits(cond, "error")
[16:59:32.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.630]                   NULL)
[16:59:32.630]                 if (is_error) {
[16:59:32.630]                   sessionInformation <- function() {
[16:59:32.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.630]                       search = base::search(), system = base::Sys.info())
[16:59:32.630]                   }
[16:59:32.630]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.630]                     cond$call), session = sessionInformation(), 
[16:59:32.630]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.630]                   signalCondition(cond)
[16:59:32.630]                 }
[16:59:32.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.630]                 "immediateCondition"))) {
[16:59:32.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.630]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.630]                   if (TRUE && !signal) {
[16:59:32.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.630]                     {
[16:59:32.630]                       inherits <- base::inherits
[16:59:32.630]                       invokeRestart <- base::invokeRestart
[16:59:32.630]                       is.null <- base::is.null
[16:59:32.630]                       muffled <- FALSE
[16:59:32.630]                       if (inherits(cond, "message")) {
[16:59:32.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.630]                         if (muffled) 
[16:59:32.630]                           invokeRestart("muffleMessage")
[16:59:32.630]                       }
[16:59:32.630]                       else if (inherits(cond, "warning")) {
[16:59:32.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.630]                         if (muffled) 
[16:59:32.630]                           invokeRestart("muffleWarning")
[16:59:32.630]                       }
[16:59:32.630]                       else if (inherits(cond, "condition")) {
[16:59:32.630]                         if (!is.null(pattern)) {
[16:59:32.630]                           computeRestarts <- base::computeRestarts
[16:59:32.630]                           grepl <- base::grepl
[16:59:32.630]                           restarts <- computeRestarts(cond)
[16:59:32.630]                           for (restart in restarts) {
[16:59:32.630]                             name <- restart$name
[16:59:32.630]                             if (is.null(name)) 
[16:59:32.630]                               next
[16:59:32.630]                             if (!grepl(pattern, name)) 
[16:59:32.630]                               next
[16:59:32.630]                             invokeRestart(restart)
[16:59:32.630]                             muffled <- TRUE
[16:59:32.630]                             break
[16:59:32.630]                           }
[16:59:32.630]                         }
[16:59:32.630]                       }
[16:59:32.630]                       invisible(muffled)
[16:59:32.630]                     }
[16:59:32.630]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.630]                   }
[16:59:32.630]                 }
[16:59:32.630]                 else {
[16:59:32.630]                   if (TRUE) {
[16:59:32.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.630]                     {
[16:59:32.630]                       inherits <- base::inherits
[16:59:32.630]                       invokeRestart <- base::invokeRestart
[16:59:32.630]                       is.null <- base::is.null
[16:59:32.630]                       muffled <- FALSE
[16:59:32.630]                       if (inherits(cond, "message")) {
[16:59:32.630]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.630]                         if (muffled) 
[16:59:32.630]                           invokeRestart("muffleMessage")
[16:59:32.630]                       }
[16:59:32.630]                       else if (inherits(cond, "warning")) {
[16:59:32.630]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.630]                         if (muffled) 
[16:59:32.630]                           invokeRestart("muffleWarning")
[16:59:32.630]                       }
[16:59:32.630]                       else if (inherits(cond, "condition")) {
[16:59:32.630]                         if (!is.null(pattern)) {
[16:59:32.630]                           computeRestarts <- base::computeRestarts
[16:59:32.630]                           grepl <- base::grepl
[16:59:32.630]                           restarts <- computeRestarts(cond)
[16:59:32.630]                           for (restart in restarts) {
[16:59:32.630]                             name <- restart$name
[16:59:32.630]                             if (is.null(name)) 
[16:59:32.630]                               next
[16:59:32.630]                             if (!grepl(pattern, name)) 
[16:59:32.630]                               next
[16:59:32.630]                             invokeRestart(restart)
[16:59:32.630]                             muffled <- TRUE
[16:59:32.630]                             break
[16:59:32.630]                           }
[16:59:32.630]                         }
[16:59:32.630]                       }
[16:59:32.630]                       invisible(muffled)
[16:59:32.630]                     }
[16:59:32.630]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.630]                   }
[16:59:32.630]                 }
[16:59:32.630]             }
[16:59:32.630]         }))
[16:59:32.630]     }, error = function(ex) {
[16:59:32.630]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.630]                 ...future.rng), started = ...future.startTime, 
[16:59:32.630]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.630]             version = "1.8"), class = "FutureResult")
[16:59:32.630]     }, finally = {
[16:59:32.630]         if (!identical(...future.workdir, getwd())) 
[16:59:32.630]             setwd(...future.workdir)
[16:59:32.630]         {
[16:59:32.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.630]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.630]             }
[16:59:32.630]             base::options(...future.oldOptions)
[16:59:32.630]             if (.Platform$OS.type == "windows") {
[16:59:32.630]                 old_names <- names(...future.oldEnvVars)
[16:59:32.630]                 envs <- base::Sys.getenv()
[16:59:32.630]                 names <- names(envs)
[16:59:32.630]                 common <- intersect(names, old_names)
[16:59:32.630]                 added <- setdiff(names, old_names)
[16:59:32.630]                 removed <- setdiff(old_names, names)
[16:59:32.630]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.630]                   envs[common]]
[16:59:32.630]                 NAMES <- toupper(changed)
[16:59:32.630]                 args <- list()
[16:59:32.630]                 for (kk in seq_along(NAMES)) {
[16:59:32.630]                   name <- changed[[kk]]
[16:59:32.630]                   NAME <- NAMES[[kk]]
[16:59:32.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.630]                     next
[16:59:32.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.630]                 }
[16:59:32.630]                 NAMES <- toupper(added)
[16:59:32.630]                 for (kk in seq_along(NAMES)) {
[16:59:32.630]                   name <- added[[kk]]
[16:59:32.630]                   NAME <- NAMES[[kk]]
[16:59:32.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.630]                     next
[16:59:32.630]                   args[[name]] <- ""
[16:59:32.630]                 }
[16:59:32.630]                 NAMES <- toupper(removed)
[16:59:32.630]                 for (kk in seq_along(NAMES)) {
[16:59:32.630]                   name <- removed[[kk]]
[16:59:32.630]                   NAME <- NAMES[[kk]]
[16:59:32.630]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.630]                     next
[16:59:32.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.630]                 }
[16:59:32.630]                 if (length(args) > 0) 
[16:59:32.630]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.630]             }
[16:59:32.630]             else {
[16:59:32.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.630]             }
[16:59:32.630]             {
[16:59:32.630]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.630]                   0L) {
[16:59:32.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.630]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.630]                   base::options(opts)
[16:59:32.630]                 }
[16:59:32.630]                 {
[16:59:32.630]                   {
[16:59:32.630]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.630]                     NULL
[16:59:32.630]                   }
[16:59:32.630]                   options(future.plan = NULL)
[16:59:32.630]                   if (is.na(NA_character_)) 
[16:59:32.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.630]                     .init = FALSE)
[16:59:32.630]                 }
[16:59:32.630]             }
[16:59:32.630]         }
[16:59:32.630]     })
[16:59:32.630]     if (TRUE) {
[16:59:32.630]         base::sink(type = "output", split = FALSE)
[16:59:32.630]         if (TRUE) {
[16:59:32.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.630]         }
[16:59:32.630]         else {
[16:59:32.630]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.630]         }
[16:59:32.630]         base::close(...future.stdout)
[16:59:32.630]         ...future.stdout <- NULL
[16:59:32.630]     }
[16:59:32.630]     ...future.result$conditions <- ...future.conditions
[16:59:32.630]     ...future.result$finished <- base::Sys.time()
[16:59:32.630]     ...future.result
[16:59:32.630] }
[16:59:32.633] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:59:32.633] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.633] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.634] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:59:32.634] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:59:32.634] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:59:32.635] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:59:32.635] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.635] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.635] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.636] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.636] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:59:32.636] MultisessionFuture started
[16:59:32.636] - Launch lazy future ... done
[16:59:32.637] run() for ‘MultisessionFuture’ ... done
[16:59:32.637] Created future:
[16:59:32.639] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.639] - Validating connection of MultisessionFuture
[16:59:32.639] - received message: FutureResult
[16:59:32.639] - Received FutureResult
[16:59:32.639] - Erased future from FutureRegistry
[16:59:32.640] result() for ClusterFuture ...
[16:59:32.640] - result already collected: FutureResult
[16:59:32.640] result() for ClusterFuture ... done
[16:59:32.640] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.637] MultisessionFuture:
[16:59:32.637] Label: ‘future_apply-1’
[16:59:32.637] Expression:
[16:59:32.637] {
[16:59:32.637]     do.call(function(...) {
[16:59:32.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.637]             on.exit(options(oopts), add = TRUE)
[16:59:32.637]         }
[16:59:32.637]         {
[16:59:32.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.637]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.637]             })
[16:59:32.637]         }
[16:59:32.637]     }, args = future.call.arguments)
[16:59:32.637] }
[16:59:32.637] Lazy evaluation: FALSE
[16:59:32.637] Asynchronous evaluation: TRUE
[16:59:32.637] Local evaluation: TRUE
[16:59:32.637] Environment: R_GlobalEnv
[16:59:32.637] Capture standard output: TRUE
[16:59:32.637] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.637] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.637] Packages: <none>
[16:59:32.637] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.637] Resolved: TRUE
[16:59:32.637] Value: <not collected>
[16:59:32.637] Conditions captured: <none>
[16:59:32.637] Early signaling: FALSE
[16:59:32.637] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.637] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.640] Chunk #1 of 2 ... DONE
[16:59:32.640] Chunk #2 of 2 ...
[16:59:32.640]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.640]  - seeds: <none>
[16:59:32.640]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.641] getGlobalsAndPackages() ...
[16:59:32.641] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.641] Resolving globals: FALSE
[16:59:32.641] Tweak future expression to call with '...' arguments ...
[16:59:32.641] {
[16:59:32.641]     do.call(function(...) {
[16:59:32.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.641]             on.exit(options(oopts), add = TRUE)
[16:59:32.641]         }
[16:59:32.641]         {
[16:59:32.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.641]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.641]             })
[16:59:32.641]         }
[16:59:32.641]     }, args = future.call.arguments)
[16:59:32.641] }
[16:59:32.641] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.642] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.642] 
[16:59:32.642] getGlobalsAndPackages() ... DONE
[16:59:32.642] run() for ‘Future’ ...
[16:59:32.642] - state: ‘created’
[16:59:32.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.657]   - Field: ‘node’
[16:59:32.657]   - Field: ‘label’
[16:59:32.657]   - Field: ‘local’
[16:59:32.657]   - Field: ‘owner’
[16:59:32.657]   - Field: ‘envir’
[16:59:32.657]   - Field: ‘workers’
[16:59:32.657]   - Field: ‘packages’
[16:59:32.657]   - Field: ‘gc’
[16:59:32.658]   - Field: ‘conditions’
[16:59:32.658]   - Field: ‘persistent’
[16:59:32.658]   - Field: ‘expr’
[16:59:32.658]   - Field: ‘uuid’
[16:59:32.658]   - Field: ‘seed’
[16:59:32.658]   - Field: ‘version’
[16:59:32.658]   - Field: ‘result’
[16:59:32.658]   - Field: ‘asynchronous’
[16:59:32.658]   - Field: ‘calls’
[16:59:32.658]   - Field: ‘globals’
[16:59:32.661]   - Field: ‘stdout’
[16:59:32.661]   - Field: ‘earlySignal’
[16:59:32.661]   - Field: ‘lazy’
[16:59:32.661]   - Field: ‘state’
[16:59:32.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.661] - Launch lazy future ...
[16:59:32.661] Packages needed by the future expression (n = 0): <none>
[16:59:32.661] Packages needed by future strategies (n = 0): <none>
[16:59:32.662] {
[16:59:32.662]     {
[16:59:32.662]         {
[16:59:32.662]             ...future.startTime <- base::Sys.time()
[16:59:32.662]             {
[16:59:32.662]                 {
[16:59:32.662]                   {
[16:59:32.662]                     {
[16:59:32.662]                       base::local({
[16:59:32.662]                         has_future <- base::requireNamespace("future", 
[16:59:32.662]                           quietly = TRUE)
[16:59:32.662]                         if (has_future) {
[16:59:32.662]                           ns <- base::getNamespace("future")
[16:59:32.662]                           version <- ns[[".package"]][["version"]]
[16:59:32.662]                           if (is.null(version)) 
[16:59:32.662]                             version <- utils::packageVersion("future")
[16:59:32.662]                         }
[16:59:32.662]                         else {
[16:59:32.662]                           version <- NULL
[16:59:32.662]                         }
[16:59:32.662]                         if (!has_future || version < "1.8.0") {
[16:59:32.662]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.662]                             "", base::R.version$version.string), 
[16:59:32.662]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.662]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.662]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.662]                               "release", "version")], collapse = " "), 
[16:59:32.662]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.662]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.662]                             info)
[16:59:32.662]                           info <- base::paste(info, collapse = "; ")
[16:59:32.662]                           if (!has_future) {
[16:59:32.662]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.662]                               info)
[16:59:32.662]                           }
[16:59:32.662]                           else {
[16:59:32.662]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.662]                               info, version)
[16:59:32.662]                           }
[16:59:32.662]                           base::stop(msg)
[16:59:32.662]                         }
[16:59:32.662]                       })
[16:59:32.662]                     }
[16:59:32.662]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.662]                     base::options(mc.cores = 1L)
[16:59:32.662]                   }
[16:59:32.662]                   ...future.strategy.old <- future::plan("list")
[16:59:32.662]                   options(future.plan = NULL)
[16:59:32.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.662]                 }
[16:59:32.662]                 ...future.workdir <- getwd()
[16:59:32.662]             }
[16:59:32.662]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.662]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.662]         }
[16:59:32.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.662]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.662]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.662]             base::names(...future.oldOptions))
[16:59:32.662]     }
[16:59:32.662]     if (FALSE) {
[16:59:32.662]     }
[16:59:32.662]     else {
[16:59:32.662]         if (TRUE) {
[16:59:32.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.662]                 open = "w")
[16:59:32.662]         }
[16:59:32.662]         else {
[16:59:32.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.662]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.662]         }
[16:59:32.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.662]             base::sink(type = "output", split = FALSE)
[16:59:32.662]             base::close(...future.stdout)
[16:59:32.662]         }, add = TRUE)
[16:59:32.662]     }
[16:59:32.662]     ...future.frame <- base::sys.nframe()
[16:59:32.662]     ...future.conditions <- base::list()
[16:59:32.662]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.662]     if (FALSE) {
[16:59:32.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.662]     }
[16:59:32.662]     ...future.result <- base::tryCatch({
[16:59:32.662]         base::withCallingHandlers({
[16:59:32.662]             ...future.value <- base::withVisible(base::local({
[16:59:32.662]                 ...future.makeSendCondition <- base::local({
[16:59:32.662]                   sendCondition <- NULL
[16:59:32.662]                   function(frame = 1L) {
[16:59:32.662]                     if (is.function(sendCondition)) 
[16:59:32.662]                       return(sendCondition)
[16:59:32.662]                     ns <- getNamespace("parallel")
[16:59:32.662]                     if (exists("sendData", mode = "function", 
[16:59:32.662]                       envir = ns)) {
[16:59:32.662]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.662]                         envir = ns)
[16:59:32.662]                       envir <- sys.frame(frame)
[16:59:32.662]                       master <- NULL
[16:59:32.662]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.662]                         !identical(envir, emptyenv())) {
[16:59:32.662]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.662]                           inherits = FALSE)) {
[16:59:32.662]                           master <- get("master", mode = "list", 
[16:59:32.662]                             envir = envir, inherits = FALSE)
[16:59:32.662]                           if (inherits(master, c("SOCKnode", 
[16:59:32.662]                             "SOCK0node"))) {
[16:59:32.662]                             sendCondition <<- function(cond) {
[16:59:32.662]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.662]                                 success = TRUE)
[16:59:32.662]                               parallel_sendData(master, data)
[16:59:32.662]                             }
[16:59:32.662]                             return(sendCondition)
[16:59:32.662]                           }
[16:59:32.662]                         }
[16:59:32.662]                         frame <- frame + 1L
[16:59:32.662]                         envir <- sys.frame(frame)
[16:59:32.662]                       }
[16:59:32.662]                     }
[16:59:32.662]                     sendCondition <<- function(cond) NULL
[16:59:32.662]                   }
[16:59:32.662]                 })
[16:59:32.662]                 withCallingHandlers({
[16:59:32.662]                   {
[16:59:32.662]                     do.call(function(...) {
[16:59:32.662]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.662]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.662]                         ...future.globals.maxSize)) {
[16:59:32.662]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.662]                         on.exit(options(oopts), add = TRUE)
[16:59:32.662]                       }
[16:59:32.662]                       {
[16:59:32.662]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.662]                           FUN = function(jj) {
[16:59:32.662]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.662]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.662]                           })
[16:59:32.662]                       }
[16:59:32.662]                     }, args = future.call.arguments)
[16:59:32.662]                   }
[16:59:32.662]                 }, immediateCondition = function(cond) {
[16:59:32.662]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.662]                   sendCondition(cond)
[16:59:32.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.662]                   {
[16:59:32.662]                     inherits <- base::inherits
[16:59:32.662]                     invokeRestart <- base::invokeRestart
[16:59:32.662]                     is.null <- base::is.null
[16:59:32.662]                     muffled <- FALSE
[16:59:32.662]                     if (inherits(cond, "message")) {
[16:59:32.662]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.662]                       if (muffled) 
[16:59:32.662]                         invokeRestart("muffleMessage")
[16:59:32.662]                     }
[16:59:32.662]                     else if (inherits(cond, "warning")) {
[16:59:32.662]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.662]                       if (muffled) 
[16:59:32.662]                         invokeRestart("muffleWarning")
[16:59:32.662]                     }
[16:59:32.662]                     else if (inherits(cond, "condition")) {
[16:59:32.662]                       if (!is.null(pattern)) {
[16:59:32.662]                         computeRestarts <- base::computeRestarts
[16:59:32.662]                         grepl <- base::grepl
[16:59:32.662]                         restarts <- computeRestarts(cond)
[16:59:32.662]                         for (restart in restarts) {
[16:59:32.662]                           name <- restart$name
[16:59:32.662]                           if (is.null(name)) 
[16:59:32.662]                             next
[16:59:32.662]                           if (!grepl(pattern, name)) 
[16:59:32.662]                             next
[16:59:32.662]                           invokeRestart(restart)
[16:59:32.662]                           muffled <- TRUE
[16:59:32.662]                           break
[16:59:32.662]                         }
[16:59:32.662]                       }
[16:59:32.662]                     }
[16:59:32.662]                     invisible(muffled)
[16:59:32.662]                   }
[16:59:32.662]                   muffleCondition(cond)
[16:59:32.662]                 })
[16:59:32.662]             }))
[16:59:32.662]             future::FutureResult(value = ...future.value$value, 
[16:59:32.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.662]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.662]                     ...future.globalenv.names))
[16:59:32.662]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.662]         }, condition = base::local({
[16:59:32.662]             c <- base::c
[16:59:32.662]             inherits <- base::inherits
[16:59:32.662]             invokeRestart <- base::invokeRestart
[16:59:32.662]             length <- base::length
[16:59:32.662]             list <- base::list
[16:59:32.662]             seq.int <- base::seq.int
[16:59:32.662]             signalCondition <- base::signalCondition
[16:59:32.662]             sys.calls <- base::sys.calls
[16:59:32.662]             `[[` <- base::`[[`
[16:59:32.662]             `+` <- base::`+`
[16:59:32.662]             `<<-` <- base::`<<-`
[16:59:32.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.662]                   3L)]
[16:59:32.662]             }
[16:59:32.662]             function(cond) {
[16:59:32.662]                 is_error <- inherits(cond, "error")
[16:59:32.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.662]                   NULL)
[16:59:32.662]                 if (is_error) {
[16:59:32.662]                   sessionInformation <- function() {
[16:59:32.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.662]                       search = base::search(), system = base::Sys.info())
[16:59:32.662]                   }
[16:59:32.662]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.662]                     cond$call), session = sessionInformation(), 
[16:59:32.662]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.662]                   signalCondition(cond)
[16:59:32.662]                 }
[16:59:32.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.662]                 "immediateCondition"))) {
[16:59:32.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.662]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.662]                   if (TRUE && !signal) {
[16:59:32.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.662]                     {
[16:59:32.662]                       inherits <- base::inherits
[16:59:32.662]                       invokeRestart <- base::invokeRestart
[16:59:32.662]                       is.null <- base::is.null
[16:59:32.662]                       muffled <- FALSE
[16:59:32.662]                       if (inherits(cond, "message")) {
[16:59:32.662]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.662]                         if (muffled) 
[16:59:32.662]                           invokeRestart("muffleMessage")
[16:59:32.662]                       }
[16:59:32.662]                       else if (inherits(cond, "warning")) {
[16:59:32.662]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.662]                         if (muffled) 
[16:59:32.662]                           invokeRestart("muffleWarning")
[16:59:32.662]                       }
[16:59:32.662]                       else if (inherits(cond, "condition")) {
[16:59:32.662]                         if (!is.null(pattern)) {
[16:59:32.662]                           computeRestarts <- base::computeRestarts
[16:59:32.662]                           grepl <- base::grepl
[16:59:32.662]                           restarts <- computeRestarts(cond)
[16:59:32.662]                           for (restart in restarts) {
[16:59:32.662]                             name <- restart$name
[16:59:32.662]                             if (is.null(name)) 
[16:59:32.662]                               next
[16:59:32.662]                             if (!grepl(pattern, name)) 
[16:59:32.662]                               next
[16:59:32.662]                             invokeRestart(restart)
[16:59:32.662]                             muffled <- TRUE
[16:59:32.662]                             break
[16:59:32.662]                           }
[16:59:32.662]                         }
[16:59:32.662]                       }
[16:59:32.662]                       invisible(muffled)
[16:59:32.662]                     }
[16:59:32.662]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.662]                   }
[16:59:32.662]                 }
[16:59:32.662]                 else {
[16:59:32.662]                   if (TRUE) {
[16:59:32.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.662]                     {
[16:59:32.662]                       inherits <- base::inherits
[16:59:32.662]                       invokeRestart <- base::invokeRestart
[16:59:32.662]                       is.null <- base::is.null
[16:59:32.662]                       muffled <- FALSE
[16:59:32.662]                       if (inherits(cond, "message")) {
[16:59:32.662]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.662]                         if (muffled) 
[16:59:32.662]                           invokeRestart("muffleMessage")
[16:59:32.662]                       }
[16:59:32.662]                       else if (inherits(cond, "warning")) {
[16:59:32.662]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.662]                         if (muffled) 
[16:59:32.662]                           invokeRestart("muffleWarning")
[16:59:32.662]                       }
[16:59:32.662]                       else if (inherits(cond, "condition")) {
[16:59:32.662]                         if (!is.null(pattern)) {
[16:59:32.662]                           computeRestarts <- base::computeRestarts
[16:59:32.662]                           grepl <- base::grepl
[16:59:32.662]                           restarts <- computeRestarts(cond)
[16:59:32.662]                           for (restart in restarts) {
[16:59:32.662]                             name <- restart$name
[16:59:32.662]                             if (is.null(name)) 
[16:59:32.662]                               next
[16:59:32.662]                             if (!grepl(pattern, name)) 
[16:59:32.662]                               next
[16:59:32.662]                             invokeRestart(restart)
[16:59:32.662]                             muffled <- TRUE
[16:59:32.662]                             break
[16:59:32.662]                           }
[16:59:32.662]                         }
[16:59:32.662]                       }
[16:59:32.662]                       invisible(muffled)
[16:59:32.662]                     }
[16:59:32.662]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.662]                   }
[16:59:32.662]                 }
[16:59:32.662]             }
[16:59:32.662]         }))
[16:59:32.662]     }, error = function(ex) {
[16:59:32.662]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.662]                 ...future.rng), started = ...future.startTime, 
[16:59:32.662]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.662]             version = "1.8"), class = "FutureResult")
[16:59:32.662]     }, finally = {
[16:59:32.662]         if (!identical(...future.workdir, getwd())) 
[16:59:32.662]             setwd(...future.workdir)
[16:59:32.662]         {
[16:59:32.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.662]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.662]             }
[16:59:32.662]             base::options(...future.oldOptions)
[16:59:32.662]             if (.Platform$OS.type == "windows") {
[16:59:32.662]                 old_names <- names(...future.oldEnvVars)
[16:59:32.662]                 envs <- base::Sys.getenv()
[16:59:32.662]                 names <- names(envs)
[16:59:32.662]                 common <- intersect(names, old_names)
[16:59:32.662]                 added <- setdiff(names, old_names)
[16:59:32.662]                 removed <- setdiff(old_names, names)
[16:59:32.662]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.662]                   envs[common]]
[16:59:32.662]                 NAMES <- toupper(changed)
[16:59:32.662]                 args <- list()
[16:59:32.662]                 for (kk in seq_along(NAMES)) {
[16:59:32.662]                   name <- changed[[kk]]
[16:59:32.662]                   NAME <- NAMES[[kk]]
[16:59:32.662]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.662]                     next
[16:59:32.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.662]                 }
[16:59:32.662]                 NAMES <- toupper(added)
[16:59:32.662]                 for (kk in seq_along(NAMES)) {
[16:59:32.662]                   name <- added[[kk]]
[16:59:32.662]                   NAME <- NAMES[[kk]]
[16:59:32.662]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.662]                     next
[16:59:32.662]                   args[[name]] <- ""
[16:59:32.662]                 }
[16:59:32.662]                 NAMES <- toupper(removed)
[16:59:32.662]                 for (kk in seq_along(NAMES)) {
[16:59:32.662]                   name <- removed[[kk]]
[16:59:32.662]                   NAME <- NAMES[[kk]]
[16:59:32.662]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.662]                     next
[16:59:32.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.662]                 }
[16:59:32.662]                 if (length(args) > 0) 
[16:59:32.662]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.662]             }
[16:59:32.662]             else {
[16:59:32.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.662]             }
[16:59:32.662]             {
[16:59:32.662]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.662]                   0L) {
[16:59:32.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.662]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.662]                   base::options(opts)
[16:59:32.662]                 }
[16:59:32.662]                 {
[16:59:32.662]                   {
[16:59:32.662]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.662]                     NULL
[16:59:32.662]                   }
[16:59:32.662]                   options(future.plan = NULL)
[16:59:32.662]                   if (is.na(NA_character_)) 
[16:59:32.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.662]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.662]                     .init = FALSE)
[16:59:32.662]                 }
[16:59:32.662]             }
[16:59:32.662]         }
[16:59:32.662]     })
[16:59:32.662]     if (TRUE) {
[16:59:32.662]         base::sink(type = "output", split = FALSE)
[16:59:32.662]         if (TRUE) {
[16:59:32.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.662]         }
[16:59:32.662]         else {
[16:59:32.662]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.662]         }
[16:59:32.662]         base::close(...future.stdout)
[16:59:32.662]         ...future.stdout <- NULL
[16:59:32.662]     }
[16:59:32.662]     ...future.result$conditions <- ...future.conditions
[16:59:32.662]     ...future.result$finished <- base::Sys.time()
[16:59:32.662]     ...future.result
[16:59:32.662] }
[16:59:32.665] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:59:32.665] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.665] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.666] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:59:32.666] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:59:32.666] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ...
[16:59:32.666] Exporting ‘...future.elements_ii’ (336 bytes) to cluster node #1 ... DONE
[16:59:32.666] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.667] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.667] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.667] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.667] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:59:32.668] MultisessionFuture started
[16:59:32.668] - Launch lazy future ... done
[16:59:32.668] run() for ‘MultisessionFuture’ ... done
[16:59:32.668] Created future:
[16:59:32.668] MultisessionFuture:
[16:59:32.668] Label: ‘future_apply-2’
[16:59:32.668] Expression:
[16:59:32.668] {
[16:59:32.668]     do.call(function(...) {
[16:59:32.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.668]             on.exit(options(oopts), add = TRUE)
[16:59:32.668]         }
[16:59:32.668]         {
[16:59:32.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.668]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.668]             })
[16:59:32.668]         }
[16:59:32.668]     }, args = future.call.arguments)
[16:59:32.668] }
[16:59:32.668] Lazy evaluation: FALSE
[16:59:32.668] Asynchronous evaluation: TRUE
[16:59:32.668] Local evaluation: TRUE
[16:59:32.668] Environment: R_GlobalEnv
[16:59:32.668] Capture standard output: TRUE
[16:59:32.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.668] Globals: 5 objects totaling 1.21 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 336 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.668] Packages: <none>
[16:59:32.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.668] Resolved: FALSE
[16:59:32.668] Value: <not collected>
[16:59:32.668] Conditions captured: <none>
[16:59:32.668] Early signaling: FALSE
[16:59:32.668] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.668] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.680] Chunk #2 of 2 ... DONE
[16:59:32.680] Launching 2 futures (chunks) ... DONE
[16:59:32.680] Resolving 2 futures (chunks) ...
[16:59:32.680] resolve() on list ...
[16:59:32.680]  recursive: 0
[16:59:32.680]  length: 2
[16:59:32.680] 
[16:59:32.680] Future #1
[16:59:32.680] result() for ClusterFuture ...
[16:59:32.681] - result already collected: FutureResult
[16:59:32.681] result() for ClusterFuture ... done
[16:59:32.681] result() for ClusterFuture ...
[16:59:32.681] - result already collected: FutureResult
[16:59:32.681] result() for ClusterFuture ... done
[16:59:32.681] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:32.681] - nx: 2
[16:59:32.681] - relay: TRUE
[16:59:32.681] - stdout: TRUE
[16:59:32.681] - signal: TRUE
[16:59:32.681] - resignal: FALSE
[16:59:32.682] - force: TRUE
[16:59:32.682] - relayed: [n=2] FALSE, FALSE
[16:59:32.682] - queued futures: [n=2] FALSE, FALSE
[16:59:32.682]  - until=1
[16:59:32.682]  - relaying element #1
[16:59:32.682] result() for ClusterFuture ...
[16:59:32.682] - result already collected: FutureResult
[16:59:32.682] result() for ClusterFuture ... done
[16:59:32.682] result() for ClusterFuture ...
[16:59:32.682] - result already collected: FutureResult
[16:59:32.682] result() for ClusterFuture ... done
[16:59:32.683] result() for ClusterFuture ...
[16:59:32.683] - result already collected: FutureResult
[16:59:32.683] result() for ClusterFuture ... done
[16:59:32.683] result() for ClusterFuture ...
[16:59:32.683] - result already collected: FutureResult
[16:59:32.683] result() for ClusterFuture ... done
[16:59:32.683] - relayed: [n=2] TRUE, FALSE
[16:59:32.683] - queued futures: [n=2] TRUE, FALSE
[16:59:32.683] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:32.683]  length: 1 (resolved future 1)
[16:59:32.713] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.713] - Validating connection of MultisessionFuture
[16:59:32.713] - received message: FutureResult
[16:59:32.714] - Received FutureResult
[16:59:32.714] - Erased future from FutureRegistry
[16:59:32.714] result() for ClusterFuture ...
[16:59:32.714] - result already collected: FutureResult
[16:59:32.714] result() for ClusterFuture ... done
[16:59:32.714] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.714] Future #2
[16:59:32.714] result() for ClusterFuture ...
[16:59:32.714] - result already collected: FutureResult
[16:59:32.714] result() for ClusterFuture ... done
[16:59:32.715] result() for ClusterFuture ...
[16:59:32.715] - result already collected: FutureResult
[16:59:32.715] result() for ClusterFuture ... done
[16:59:32.715] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.715] - nx: 2
[16:59:32.715] - relay: TRUE
[16:59:32.715] - stdout: TRUE
[16:59:32.715] - signal: TRUE
[16:59:32.715] - resignal: FALSE
[16:59:32.715] - force: TRUE
[16:59:32.715] - relayed: [n=2] TRUE, FALSE
[16:59:32.715] - queued futures: [n=2] TRUE, FALSE
[16:59:32.716]  - until=2
[16:59:32.716]  - relaying element #2
[16:59:32.716] result() for ClusterFuture ...
[16:59:32.716] - result already collected: FutureResult
[16:59:32.716] result() for ClusterFuture ... done
[16:59:32.716] result() for ClusterFuture ...
[16:59:32.716] - result already collected: FutureResult
[16:59:32.716] result() for ClusterFuture ... done
[16:59:32.716] result() for ClusterFuture ...
[16:59:32.716] - result already collected: FutureResult
[16:59:32.716] result() for ClusterFuture ... done
[16:59:32.716] result() for ClusterFuture ...
[16:59:32.717] - result already collected: FutureResult
[16:59:32.717] result() for ClusterFuture ... done
[16:59:32.717] - relayed: [n=2] TRUE, TRUE
[16:59:32.717] - queued futures: [n=2] TRUE, TRUE
[16:59:32.717] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.717]  length: 0 (resolved future 2)
[16:59:32.717] Relaying remaining futures
[16:59:32.717] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.717] - nx: 2
[16:59:32.717] - relay: TRUE
[16:59:32.717] - stdout: TRUE
[16:59:32.718] - signal: TRUE
[16:59:32.718] - resignal: FALSE
[16:59:32.718] - force: TRUE
[16:59:32.718] - relayed: [n=2] TRUE, TRUE
[16:59:32.718] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.718] - relayed: [n=2] TRUE, TRUE
[16:59:32.718] - queued futures: [n=2] TRUE, TRUE
[16:59:32.718] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.718] resolve() on list ... DONE
[16:59:32.718] result() for ClusterFuture ...
[16:59:32.718] - result already collected: FutureResult
[16:59:32.718] result() for ClusterFuture ... done
[16:59:32.719] result() for ClusterFuture ...
[16:59:32.719] - result already collected: FutureResult
[16:59:32.719] result() for ClusterFuture ... done
[16:59:32.719] result() for ClusterFuture ...
[16:59:32.719] - result already collected: FutureResult
[16:59:32.719] result() for ClusterFuture ... done
[16:59:32.719] result() for ClusterFuture ...
[16:59:32.719] - result already collected: FutureResult
[16:59:32.719] result() for ClusterFuture ... done
[16:59:32.719]  - Number of value chunks collected: 2
[16:59:32.719] Resolving 2 futures (chunks) ... DONE
[16:59:32.720] Reducing values from 2 chunks ...
[16:59:32.720]  - Number of values collected after concatenation: 6
[16:59:32.720]  - Number of values expected: 6
[16:59:32.720] Reducing values from 2 chunks ... DONE
[16:59:32.720] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[16:59:32.720] getGlobalsAndPackagesXApply() ...
[16:59:32.721]  - future.globals: TRUE
[16:59:32.721] getGlobalsAndPackages() ...
[16:59:32.721] Searching for globals...
[16:59:32.722] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[16:59:32.722] Searching for globals ... DONE
[16:59:32.722] Resolving globals: FALSE
[16:59:32.723] The total size of the 1 globals is 1.73 KiB (1768 bytes)
[16:59:32.723] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 1.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.73 KiB of class ‘function’)
[16:59:32.723] - globals: [1] ‘FUN’
[16:59:32.723] 
[16:59:32.723] getGlobalsAndPackages() ... DONE
[16:59:32.723]  - globals found/used: [n=1] ‘FUN’
[16:59:32.723]  - needed namespaces: [n=0] 
[16:59:32.724] Finding globals ... DONE
[16:59:32.724]  - use_args: TRUE
[16:59:32.724]  - Getting '...' globals ...
[16:59:32.724] resolve() on list ...
[16:59:32.724]  recursive: 0
[16:59:32.724]  length: 1
[16:59:32.724]  elements: ‘...’
[16:59:32.724]  length: 0 (resolved future 1)
[16:59:32.725] resolve() on list ... DONE
[16:59:32.725]    - '...' content: [n=0] 
[16:59:32.725] List of 1
[16:59:32.725]  $ ...: list()
[16:59:32.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.725]  - attr(*, "where")=List of 1
[16:59:32.725]   ..$ ...:<environment: 0x55f311e961d0> 
[16:59:32.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.725]  - attr(*, "resolved")= logi TRUE
[16:59:32.725]  - attr(*, "total_size")= num NA
[16:59:32.727]  - Getting '...' globals ... DONE
[16:59:32.727] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:32.728] List of 2
[16:59:32.728]  $ ...future.FUN:function (x)  
[16:59:32.728]  $ ...          : list()
[16:59:32.728]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.728]  - attr(*, "where")=List of 2
[16:59:32.728]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:32.728]   ..$ ...          :<environment: 0x55f311e961d0> 
[16:59:32.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.728]  - attr(*, "resolved")= logi FALSE
[16:59:32.728]  - attr(*, "total_size")= num 1768
[16:59:32.730] Packages to be attached in all futures: [n=0] 
[16:59:32.730] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.734] future_lapply() ...
[16:59:32.738] Number of chunks: 2
[16:59:32.738] getGlobalsAndPackagesXApply() ...
[16:59:32.738]  - future.globals: <name-value list> with names ‘list()’
[16:59:32.738]  - use_args: TRUE
[16:59:32.738] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:32.738] List of 2
[16:59:32.738]  $ ...          : list()
[16:59:32.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.738]  $ ...future.FUN:function (x)  
[16:59:32.738]  - attr(*, "where")=List of 2
[16:59:32.738]   ..$ ...          :<environment: 0x55f311e961d0> 
[16:59:32.738]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:59:32.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.738]  - attr(*, "resolved")= logi FALSE
[16:59:32.738]  - attr(*, "total_size")= num NA
[16:59:32.741] Packages to be attached in all futures: [n=0] 
[16:59:32.741] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.741] Number of futures (= number of chunks): 2
[16:59:32.741] Launching 2 futures (chunks) ...
[16:59:32.742] Chunk #1 of 2 ...
[16:59:32.742]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.742]  - seeds: <none>
[16:59:32.742]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.742] getGlobalsAndPackages() ...
[16:59:32.742] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.742] Resolving globals: FALSE
[16:59:32.742] Tweak future expression to call with '...' arguments ...
[16:59:32.742] {
[16:59:32.742]     do.call(function(...) {
[16:59:32.742]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.742]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.742]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.742]             on.exit(options(oopts), add = TRUE)
[16:59:32.742]         }
[16:59:32.742]         {
[16:59:32.742]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.742]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.742]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.742]             })
[16:59:32.742]         }
[16:59:32.742]     }, args = future.call.arguments)
[16:59:32.742] }
[16:59:32.743] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.743] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.743] 
[16:59:32.743] getGlobalsAndPackages() ... DONE
[16:59:32.744] run() for ‘Future’ ...
[16:59:32.744] - state: ‘created’
[16:59:32.744] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.757] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.758]   - Field: ‘node’
[16:59:32.758]   - Field: ‘label’
[16:59:32.758]   - Field: ‘local’
[16:59:32.758]   - Field: ‘owner’
[16:59:32.758]   - Field: ‘envir’
[16:59:32.758]   - Field: ‘workers’
[16:59:32.758]   - Field: ‘packages’
[16:59:32.758]   - Field: ‘gc’
[16:59:32.758]   - Field: ‘conditions’
[16:59:32.758]   - Field: ‘persistent’
[16:59:32.759]   - Field: ‘expr’
[16:59:32.759]   - Field: ‘uuid’
[16:59:32.759]   - Field: ‘seed’
[16:59:32.759]   - Field: ‘version’
[16:59:32.759]   - Field: ‘result’
[16:59:32.759]   - Field: ‘asynchronous’
[16:59:32.759]   - Field: ‘calls’
[16:59:32.759]   - Field: ‘globals’
[16:59:32.759]   - Field: ‘stdout’
[16:59:32.759]   - Field: ‘earlySignal’
[16:59:32.759]   - Field: ‘lazy’
[16:59:32.760]   - Field: ‘state’
[16:59:32.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.760] - Launch lazy future ...
[16:59:32.760] Packages needed by the future expression (n = 0): <none>
[16:59:32.760] Packages needed by future strategies (n = 0): <none>
[16:59:32.761] {
[16:59:32.761]     {
[16:59:32.761]         {
[16:59:32.761]             ...future.startTime <- base::Sys.time()
[16:59:32.761]             {
[16:59:32.761]                 {
[16:59:32.761]                   {
[16:59:32.761]                     {
[16:59:32.761]                       base::local({
[16:59:32.761]                         has_future <- base::requireNamespace("future", 
[16:59:32.761]                           quietly = TRUE)
[16:59:32.761]                         if (has_future) {
[16:59:32.761]                           ns <- base::getNamespace("future")
[16:59:32.761]                           version <- ns[[".package"]][["version"]]
[16:59:32.761]                           if (is.null(version)) 
[16:59:32.761]                             version <- utils::packageVersion("future")
[16:59:32.761]                         }
[16:59:32.761]                         else {
[16:59:32.761]                           version <- NULL
[16:59:32.761]                         }
[16:59:32.761]                         if (!has_future || version < "1.8.0") {
[16:59:32.761]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.761]                             "", base::R.version$version.string), 
[16:59:32.761]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.761]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.761]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.761]                               "release", "version")], collapse = " "), 
[16:59:32.761]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.761]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.761]                             info)
[16:59:32.761]                           info <- base::paste(info, collapse = "; ")
[16:59:32.761]                           if (!has_future) {
[16:59:32.761]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.761]                               info)
[16:59:32.761]                           }
[16:59:32.761]                           else {
[16:59:32.761]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.761]                               info, version)
[16:59:32.761]                           }
[16:59:32.761]                           base::stop(msg)
[16:59:32.761]                         }
[16:59:32.761]                       })
[16:59:32.761]                     }
[16:59:32.761]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.761]                     base::options(mc.cores = 1L)
[16:59:32.761]                   }
[16:59:32.761]                   ...future.strategy.old <- future::plan("list")
[16:59:32.761]                   options(future.plan = NULL)
[16:59:32.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.761]                 }
[16:59:32.761]                 ...future.workdir <- getwd()
[16:59:32.761]             }
[16:59:32.761]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.761]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.761]         }
[16:59:32.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.761]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.761]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.761]             base::names(...future.oldOptions))
[16:59:32.761]     }
[16:59:32.761]     if (FALSE) {
[16:59:32.761]     }
[16:59:32.761]     else {
[16:59:32.761]         if (TRUE) {
[16:59:32.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.761]                 open = "w")
[16:59:32.761]         }
[16:59:32.761]         else {
[16:59:32.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.761]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.761]         }
[16:59:32.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.761]             base::sink(type = "output", split = FALSE)
[16:59:32.761]             base::close(...future.stdout)
[16:59:32.761]         }, add = TRUE)
[16:59:32.761]     }
[16:59:32.761]     ...future.frame <- base::sys.nframe()
[16:59:32.761]     ...future.conditions <- base::list()
[16:59:32.761]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.761]     if (FALSE) {
[16:59:32.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.761]     }
[16:59:32.761]     ...future.result <- base::tryCatch({
[16:59:32.761]         base::withCallingHandlers({
[16:59:32.761]             ...future.value <- base::withVisible(base::local({
[16:59:32.761]                 ...future.makeSendCondition <- base::local({
[16:59:32.761]                   sendCondition <- NULL
[16:59:32.761]                   function(frame = 1L) {
[16:59:32.761]                     if (is.function(sendCondition)) 
[16:59:32.761]                       return(sendCondition)
[16:59:32.761]                     ns <- getNamespace("parallel")
[16:59:32.761]                     if (exists("sendData", mode = "function", 
[16:59:32.761]                       envir = ns)) {
[16:59:32.761]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.761]                         envir = ns)
[16:59:32.761]                       envir <- sys.frame(frame)
[16:59:32.761]                       master <- NULL
[16:59:32.761]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.761]                         !identical(envir, emptyenv())) {
[16:59:32.761]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.761]                           inherits = FALSE)) {
[16:59:32.761]                           master <- get("master", mode = "list", 
[16:59:32.761]                             envir = envir, inherits = FALSE)
[16:59:32.761]                           if (inherits(master, c("SOCKnode", 
[16:59:32.761]                             "SOCK0node"))) {
[16:59:32.761]                             sendCondition <<- function(cond) {
[16:59:32.761]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.761]                                 success = TRUE)
[16:59:32.761]                               parallel_sendData(master, data)
[16:59:32.761]                             }
[16:59:32.761]                             return(sendCondition)
[16:59:32.761]                           }
[16:59:32.761]                         }
[16:59:32.761]                         frame <- frame + 1L
[16:59:32.761]                         envir <- sys.frame(frame)
[16:59:32.761]                       }
[16:59:32.761]                     }
[16:59:32.761]                     sendCondition <<- function(cond) NULL
[16:59:32.761]                   }
[16:59:32.761]                 })
[16:59:32.761]                 withCallingHandlers({
[16:59:32.761]                   {
[16:59:32.761]                     do.call(function(...) {
[16:59:32.761]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.761]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.761]                         ...future.globals.maxSize)) {
[16:59:32.761]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.761]                         on.exit(options(oopts), add = TRUE)
[16:59:32.761]                       }
[16:59:32.761]                       {
[16:59:32.761]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.761]                           FUN = function(jj) {
[16:59:32.761]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.761]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.761]                           })
[16:59:32.761]                       }
[16:59:32.761]                     }, args = future.call.arguments)
[16:59:32.761]                   }
[16:59:32.761]                 }, immediateCondition = function(cond) {
[16:59:32.761]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.761]                   sendCondition(cond)
[16:59:32.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.761]                   {
[16:59:32.761]                     inherits <- base::inherits
[16:59:32.761]                     invokeRestart <- base::invokeRestart
[16:59:32.761]                     is.null <- base::is.null
[16:59:32.761]                     muffled <- FALSE
[16:59:32.761]                     if (inherits(cond, "message")) {
[16:59:32.761]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.761]                       if (muffled) 
[16:59:32.761]                         invokeRestart("muffleMessage")
[16:59:32.761]                     }
[16:59:32.761]                     else if (inherits(cond, "warning")) {
[16:59:32.761]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.761]                       if (muffled) 
[16:59:32.761]                         invokeRestart("muffleWarning")
[16:59:32.761]                     }
[16:59:32.761]                     else if (inherits(cond, "condition")) {
[16:59:32.761]                       if (!is.null(pattern)) {
[16:59:32.761]                         computeRestarts <- base::computeRestarts
[16:59:32.761]                         grepl <- base::grepl
[16:59:32.761]                         restarts <- computeRestarts(cond)
[16:59:32.761]                         for (restart in restarts) {
[16:59:32.761]                           name <- restart$name
[16:59:32.761]                           if (is.null(name)) 
[16:59:32.761]                             next
[16:59:32.761]                           if (!grepl(pattern, name)) 
[16:59:32.761]                             next
[16:59:32.761]                           invokeRestart(restart)
[16:59:32.761]                           muffled <- TRUE
[16:59:32.761]                           break
[16:59:32.761]                         }
[16:59:32.761]                       }
[16:59:32.761]                     }
[16:59:32.761]                     invisible(muffled)
[16:59:32.761]                   }
[16:59:32.761]                   muffleCondition(cond)
[16:59:32.761]                 })
[16:59:32.761]             }))
[16:59:32.761]             future::FutureResult(value = ...future.value$value, 
[16:59:32.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.761]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.761]                     ...future.globalenv.names))
[16:59:32.761]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.761]         }, condition = base::local({
[16:59:32.761]             c <- base::c
[16:59:32.761]             inherits <- base::inherits
[16:59:32.761]             invokeRestart <- base::invokeRestart
[16:59:32.761]             length <- base::length
[16:59:32.761]             list <- base::list
[16:59:32.761]             seq.int <- base::seq.int
[16:59:32.761]             signalCondition <- base::signalCondition
[16:59:32.761]             sys.calls <- base::sys.calls
[16:59:32.761]             `[[` <- base::`[[`
[16:59:32.761]             `+` <- base::`+`
[16:59:32.761]             `<<-` <- base::`<<-`
[16:59:32.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.761]                   3L)]
[16:59:32.761]             }
[16:59:32.761]             function(cond) {
[16:59:32.761]                 is_error <- inherits(cond, "error")
[16:59:32.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.761]                   NULL)
[16:59:32.761]                 if (is_error) {
[16:59:32.761]                   sessionInformation <- function() {
[16:59:32.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.761]                       search = base::search(), system = base::Sys.info())
[16:59:32.761]                   }
[16:59:32.761]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.761]                     cond$call), session = sessionInformation(), 
[16:59:32.761]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.761]                   signalCondition(cond)
[16:59:32.761]                 }
[16:59:32.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.761]                 "immediateCondition"))) {
[16:59:32.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.761]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.761]                   if (TRUE && !signal) {
[16:59:32.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.761]                     {
[16:59:32.761]                       inherits <- base::inherits
[16:59:32.761]                       invokeRestart <- base::invokeRestart
[16:59:32.761]                       is.null <- base::is.null
[16:59:32.761]                       muffled <- FALSE
[16:59:32.761]                       if (inherits(cond, "message")) {
[16:59:32.761]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.761]                         if (muffled) 
[16:59:32.761]                           invokeRestart("muffleMessage")
[16:59:32.761]                       }
[16:59:32.761]                       else if (inherits(cond, "warning")) {
[16:59:32.761]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.761]                         if (muffled) 
[16:59:32.761]                           invokeRestart("muffleWarning")
[16:59:32.761]                       }
[16:59:32.761]                       else if (inherits(cond, "condition")) {
[16:59:32.761]                         if (!is.null(pattern)) {
[16:59:32.761]                           computeRestarts <- base::computeRestarts
[16:59:32.761]                           grepl <- base::grepl
[16:59:32.761]                           restarts <- computeRestarts(cond)
[16:59:32.761]                           for (restart in restarts) {
[16:59:32.761]                             name <- restart$name
[16:59:32.761]                             if (is.null(name)) 
[16:59:32.761]                               next
[16:59:32.761]                             if (!grepl(pattern, name)) 
[16:59:32.761]                               next
[16:59:32.761]                             invokeRestart(restart)
[16:59:32.761]                             muffled <- TRUE
[16:59:32.761]                             break
[16:59:32.761]                           }
[16:59:32.761]                         }
[16:59:32.761]                       }
[16:59:32.761]                       invisible(muffled)
[16:59:32.761]                     }
[16:59:32.761]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.761]                   }
[16:59:32.761]                 }
[16:59:32.761]                 else {
[16:59:32.761]                   if (TRUE) {
[16:59:32.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.761]                     {
[16:59:32.761]                       inherits <- base::inherits
[16:59:32.761]                       invokeRestart <- base::invokeRestart
[16:59:32.761]                       is.null <- base::is.null
[16:59:32.761]                       muffled <- FALSE
[16:59:32.761]                       if (inherits(cond, "message")) {
[16:59:32.761]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.761]                         if (muffled) 
[16:59:32.761]                           invokeRestart("muffleMessage")
[16:59:32.761]                       }
[16:59:32.761]                       else if (inherits(cond, "warning")) {
[16:59:32.761]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.761]                         if (muffled) 
[16:59:32.761]                           invokeRestart("muffleWarning")
[16:59:32.761]                       }
[16:59:32.761]                       else if (inherits(cond, "condition")) {
[16:59:32.761]                         if (!is.null(pattern)) {
[16:59:32.761]                           computeRestarts <- base::computeRestarts
[16:59:32.761]                           grepl <- base::grepl
[16:59:32.761]                           restarts <- computeRestarts(cond)
[16:59:32.761]                           for (restart in restarts) {
[16:59:32.761]                             name <- restart$name
[16:59:32.761]                             if (is.null(name)) 
[16:59:32.761]                               next
[16:59:32.761]                             if (!grepl(pattern, name)) 
[16:59:32.761]                               next
[16:59:32.761]                             invokeRestart(restart)
[16:59:32.761]                             muffled <- TRUE
[16:59:32.761]                             break
[16:59:32.761]                           }
[16:59:32.761]                         }
[16:59:32.761]                       }
[16:59:32.761]                       invisible(muffled)
[16:59:32.761]                     }
[16:59:32.761]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.761]                   }
[16:59:32.761]                 }
[16:59:32.761]             }
[16:59:32.761]         }))
[16:59:32.761]     }, error = function(ex) {
[16:59:32.761]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.761]                 ...future.rng), started = ...future.startTime, 
[16:59:32.761]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.761]             version = "1.8"), class = "FutureResult")
[16:59:32.761]     }, finally = {
[16:59:32.761]         if (!identical(...future.workdir, getwd())) 
[16:59:32.761]             setwd(...future.workdir)
[16:59:32.761]         {
[16:59:32.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.761]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.761]             }
[16:59:32.761]             base::options(...future.oldOptions)
[16:59:32.761]             if (.Platform$OS.type == "windows") {
[16:59:32.761]                 old_names <- names(...future.oldEnvVars)
[16:59:32.761]                 envs <- base::Sys.getenv()
[16:59:32.761]                 names <- names(envs)
[16:59:32.761]                 common <- intersect(names, old_names)
[16:59:32.761]                 added <- setdiff(names, old_names)
[16:59:32.761]                 removed <- setdiff(old_names, names)
[16:59:32.761]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.761]                   envs[common]]
[16:59:32.761]                 NAMES <- toupper(changed)
[16:59:32.761]                 args <- list()
[16:59:32.761]                 for (kk in seq_along(NAMES)) {
[16:59:32.761]                   name <- changed[[kk]]
[16:59:32.761]                   NAME <- NAMES[[kk]]
[16:59:32.761]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.761]                     next
[16:59:32.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.761]                 }
[16:59:32.761]                 NAMES <- toupper(added)
[16:59:32.761]                 for (kk in seq_along(NAMES)) {
[16:59:32.761]                   name <- added[[kk]]
[16:59:32.761]                   NAME <- NAMES[[kk]]
[16:59:32.761]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.761]                     next
[16:59:32.761]                   args[[name]] <- ""
[16:59:32.761]                 }
[16:59:32.761]                 NAMES <- toupper(removed)
[16:59:32.761]                 for (kk in seq_along(NAMES)) {
[16:59:32.761]                   name <- removed[[kk]]
[16:59:32.761]                   NAME <- NAMES[[kk]]
[16:59:32.761]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.761]                     next
[16:59:32.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.761]                 }
[16:59:32.761]                 if (length(args) > 0) 
[16:59:32.761]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.761]             }
[16:59:32.761]             else {
[16:59:32.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.761]             }
[16:59:32.761]             {
[16:59:32.761]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.761]                   0L) {
[16:59:32.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.761]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.761]                   base::options(opts)
[16:59:32.761]                 }
[16:59:32.761]                 {
[16:59:32.761]                   {
[16:59:32.761]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.761]                     NULL
[16:59:32.761]                   }
[16:59:32.761]                   options(future.plan = NULL)
[16:59:32.761]                   if (is.na(NA_character_)) 
[16:59:32.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.761]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.761]                     .init = FALSE)
[16:59:32.761]                 }
[16:59:32.761]             }
[16:59:32.761]         }
[16:59:32.761]     })
[16:59:32.761]     if (TRUE) {
[16:59:32.761]         base::sink(type = "output", split = FALSE)
[16:59:32.761]         if (TRUE) {
[16:59:32.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.761]         }
[16:59:32.761]         else {
[16:59:32.761]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.761]         }
[16:59:32.761]         base::close(...future.stdout)
[16:59:32.761]         ...future.stdout <- NULL
[16:59:32.761]     }
[16:59:32.761]     ...future.result$conditions <- ...future.conditions
[16:59:32.761]     ...future.result$finished <- base::Sys.time()
[16:59:32.761]     ...future.result
[16:59:32.761] }
[16:59:32.764] Exporting 5 global objects (1.97 KiB) to cluster node #1 ...
[16:59:32.764] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.764] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.764] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ...
[16:59:32.765] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #1 ... DONE
[16:59:32.765] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ...
[16:59:32.765] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #1 ... DONE
[16:59:32.765] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.766] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.766] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.766] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.766] Exporting 5 global objects (1.97 KiB) to cluster node #1 ... DONE
[16:59:32.766] MultisessionFuture started
[16:59:32.767] - Launch lazy future ... done
[16:59:32.767] run() for ‘MultisessionFuture’ ... done
[16:59:32.767] Created future:
[16:59:32.767] MultisessionFuture:
[16:59:32.767] Label: ‘future_apply-1’
[16:59:32.767] Expression:
[16:59:32.767] {
[16:59:32.767]     do.call(function(...) {
[16:59:32.767]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.767]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.767]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.767]             on.exit(options(oopts), add = TRUE)
[16:59:32.767]         }
[16:59:32.767]         {
[16:59:32.767]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.767]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.767]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.767]             })
[16:59:32.767]         }
[16:59:32.767]     }, args = future.call.arguments)
[16:59:32.767] }
[16:59:32.767] Lazy evaluation: FALSE
[16:59:32.767] Asynchronous evaluation: TRUE
[16:59:32.767] Local evaluation: TRUE
[16:59:32.767] Environment: R_GlobalEnv
[16:59:32.767] Capture standard output: TRUE
[16:59:32.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.767] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.767] Packages: <none>
[16:59:32.767] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.767] Resolved: FALSE
[16:59:32.767] Value: <not collected>
[16:59:32.767] Conditions captured: <none>
[16:59:32.767] Early signaling: FALSE
[16:59:32.767] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.767] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.778] Chunk #1 of 2 ... DONE
[16:59:32.779] Chunk #2 of 2 ...
[16:59:32.779]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.779]  - seeds: <none>
[16:59:32.779]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.779] getGlobalsAndPackages() ...
[16:59:32.779] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.779] Resolving globals: FALSE
[16:59:32.780] Tweak future expression to call with '...' arguments ...
[16:59:32.780] {
[16:59:32.780]     do.call(function(...) {
[16:59:32.780]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.780]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.780]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.780]             on.exit(options(oopts), add = TRUE)
[16:59:32.780]         }
[16:59:32.780]         {
[16:59:32.780]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.780]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.780]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.780]             })
[16:59:32.780]         }
[16:59:32.780]     }, args = future.call.arguments)
[16:59:32.780] }
[16:59:32.780] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.780] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.780] 
[16:59:32.780] getGlobalsAndPackages() ... DONE
[16:59:32.781] run() for ‘Future’ ...
[16:59:32.781] - state: ‘created’
[16:59:32.781] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.795] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.795] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.796]   - Field: ‘node’
[16:59:32.796]   - Field: ‘label’
[16:59:32.796]   - Field: ‘local’
[16:59:32.796]   - Field: ‘owner’
[16:59:32.796]   - Field: ‘envir’
[16:59:32.796]   - Field: ‘workers’
[16:59:32.796]   - Field: ‘packages’
[16:59:32.796]   - Field: ‘gc’
[16:59:32.796]   - Field: ‘conditions’
[16:59:32.796]   - Field: ‘persistent’
[16:59:32.796]   - Field: ‘expr’
[16:59:32.797]   - Field: ‘uuid’
[16:59:32.797]   - Field: ‘seed’
[16:59:32.797]   - Field: ‘version’
[16:59:32.797]   - Field: ‘result’
[16:59:32.797]   - Field: ‘asynchronous’
[16:59:32.797]   - Field: ‘calls’
[16:59:32.797]   - Field: ‘globals’
[16:59:32.797]   - Field: ‘stdout’
[16:59:32.797]   - Field: ‘earlySignal’
[16:59:32.797]   - Field: ‘lazy’
[16:59:32.798]   - Field: ‘state’
[16:59:32.798] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.798] - Launch lazy future ...
[16:59:32.798] Packages needed by the future expression (n = 0): <none>
[16:59:32.798] Packages needed by future strategies (n = 0): <none>
[16:59:32.799] {
[16:59:32.799]     {
[16:59:32.799]         {
[16:59:32.799]             ...future.startTime <- base::Sys.time()
[16:59:32.799]             {
[16:59:32.799]                 {
[16:59:32.799]                   {
[16:59:32.799]                     {
[16:59:32.799]                       base::local({
[16:59:32.799]                         has_future <- base::requireNamespace("future", 
[16:59:32.799]                           quietly = TRUE)
[16:59:32.799]                         if (has_future) {
[16:59:32.799]                           ns <- base::getNamespace("future")
[16:59:32.799]                           version <- ns[[".package"]][["version"]]
[16:59:32.799]                           if (is.null(version)) 
[16:59:32.799]                             version <- utils::packageVersion("future")
[16:59:32.799]                         }
[16:59:32.799]                         else {
[16:59:32.799]                           version <- NULL
[16:59:32.799]                         }
[16:59:32.799]                         if (!has_future || version < "1.8.0") {
[16:59:32.799]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.799]                             "", base::R.version$version.string), 
[16:59:32.799]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.799]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.799]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.799]                               "release", "version")], collapse = " "), 
[16:59:32.799]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.799]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.799]                             info)
[16:59:32.799]                           info <- base::paste(info, collapse = "; ")
[16:59:32.799]                           if (!has_future) {
[16:59:32.799]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.799]                               info)
[16:59:32.799]                           }
[16:59:32.799]                           else {
[16:59:32.799]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.799]                               info, version)
[16:59:32.799]                           }
[16:59:32.799]                           base::stop(msg)
[16:59:32.799]                         }
[16:59:32.799]                       })
[16:59:32.799]                     }
[16:59:32.799]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.799]                     base::options(mc.cores = 1L)
[16:59:32.799]                   }
[16:59:32.799]                   ...future.strategy.old <- future::plan("list")
[16:59:32.799]                   options(future.plan = NULL)
[16:59:32.799]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.799]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.799]                 }
[16:59:32.799]                 ...future.workdir <- getwd()
[16:59:32.799]             }
[16:59:32.799]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.799]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.799]         }
[16:59:32.799]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.799]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.799]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.799]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.799]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.799]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.799]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.799]             base::names(...future.oldOptions))
[16:59:32.799]     }
[16:59:32.799]     if (FALSE) {
[16:59:32.799]     }
[16:59:32.799]     else {
[16:59:32.799]         if (TRUE) {
[16:59:32.799]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.799]                 open = "w")
[16:59:32.799]         }
[16:59:32.799]         else {
[16:59:32.799]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.799]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.799]         }
[16:59:32.799]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.799]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.799]             base::sink(type = "output", split = FALSE)
[16:59:32.799]             base::close(...future.stdout)
[16:59:32.799]         }, add = TRUE)
[16:59:32.799]     }
[16:59:32.799]     ...future.frame <- base::sys.nframe()
[16:59:32.799]     ...future.conditions <- base::list()
[16:59:32.799]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.799]     if (FALSE) {
[16:59:32.799]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.799]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.799]     }
[16:59:32.799]     ...future.result <- base::tryCatch({
[16:59:32.799]         base::withCallingHandlers({
[16:59:32.799]             ...future.value <- base::withVisible(base::local({
[16:59:32.799]                 ...future.makeSendCondition <- base::local({
[16:59:32.799]                   sendCondition <- NULL
[16:59:32.799]                   function(frame = 1L) {
[16:59:32.799]                     if (is.function(sendCondition)) 
[16:59:32.799]                       return(sendCondition)
[16:59:32.799]                     ns <- getNamespace("parallel")
[16:59:32.799]                     if (exists("sendData", mode = "function", 
[16:59:32.799]                       envir = ns)) {
[16:59:32.799]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.799]                         envir = ns)
[16:59:32.799]                       envir <- sys.frame(frame)
[16:59:32.799]                       master <- NULL
[16:59:32.799]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.799]                         !identical(envir, emptyenv())) {
[16:59:32.799]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.799]                           inherits = FALSE)) {
[16:59:32.799]                           master <- get("master", mode = "list", 
[16:59:32.799]                             envir = envir, inherits = FALSE)
[16:59:32.799]                           if (inherits(master, c("SOCKnode", 
[16:59:32.799]                             "SOCK0node"))) {
[16:59:32.799]                             sendCondition <<- function(cond) {
[16:59:32.799]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.799]                                 success = TRUE)
[16:59:32.799]                               parallel_sendData(master, data)
[16:59:32.799]                             }
[16:59:32.799]                             return(sendCondition)
[16:59:32.799]                           }
[16:59:32.799]                         }
[16:59:32.799]                         frame <- frame + 1L
[16:59:32.799]                         envir <- sys.frame(frame)
[16:59:32.799]                       }
[16:59:32.799]                     }
[16:59:32.799]                     sendCondition <<- function(cond) NULL
[16:59:32.799]                   }
[16:59:32.799]                 })
[16:59:32.799]                 withCallingHandlers({
[16:59:32.799]                   {
[16:59:32.799]                     do.call(function(...) {
[16:59:32.799]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.799]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.799]                         ...future.globals.maxSize)) {
[16:59:32.799]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.799]                         on.exit(options(oopts), add = TRUE)
[16:59:32.799]                       }
[16:59:32.799]                       {
[16:59:32.799]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.799]                           FUN = function(jj) {
[16:59:32.799]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.799]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.799]                           })
[16:59:32.799]                       }
[16:59:32.799]                     }, args = future.call.arguments)
[16:59:32.799]                   }
[16:59:32.799]                 }, immediateCondition = function(cond) {
[16:59:32.799]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.799]                   sendCondition(cond)
[16:59:32.799]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.799]                   {
[16:59:32.799]                     inherits <- base::inherits
[16:59:32.799]                     invokeRestart <- base::invokeRestart
[16:59:32.799]                     is.null <- base::is.null
[16:59:32.799]                     muffled <- FALSE
[16:59:32.799]                     if (inherits(cond, "message")) {
[16:59:32.799]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.799]                       if (muffled) 
[16:59:32.799]                         invokeRestart("muffleMessage")
[16:59:32.799]                     }
[16:59:32.799]                     else if (inherits(cond, "warning")) {
[16:59:32.799]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.799]                       if (muffled) 
[16:59:32.799]                         invokeRestart("muffleWarning")
[16:59:32.799]                     }
[16:59:32.799]                     else if (inherits(cond, "condition")) {
[16:59:32.799]                       if (!is.null(pattern)) {
[16:59:32.799]                         computeRestarts <- base::computeRestarts
[16:59:32.799]                         grepl <- base::grepl
[16:59:32.799]                         restarts <- computeRestarts(cond)
[16:59:32.799]                         for (restart in restarts) {
[16:59:32.799]                           name <- restart$name
[16:59:32.799]                           if (is.null(name)) 
[16:59:32.799]                             next
[16:59:32.799]                           if (!grepl(pattern, name)) 
[16:59:32.799]                             next
[16:59:32.799]                           invokeRestart(restart)
[16:59:32.799]                           muffled <- TRUE
[16:59:32.799]                           break
[16:59:32.799]                         }
[16:59:32.799]                       }
[16:59:32.799]                     }
[16:59:32.799]                     invisible(muffled)
[16:59:32.799]                   }
[16:59:32.799]                   muffleCondition(cond)
[16:59:32.799]                 })
[16:59:32.799]             }))
[16:59:32.799]             future::FutureResult(value = ...future.value$value, 
[16:59:32.799]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.799]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.799]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.799]                     ...future.globalenv.names))
[16:59:32.799]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.799]         }, condition = base::local({
[16:59:32.799]             c <- base::c
[16:59:32.799]             inherits <- base::inherits
[16:59:32.799]             invokeRestart <- base::invokeRestart
[16:59:32.799]             length <- base::length
[16:59:32.799]             list <- base::list
[16:59:32.799]             seq.int <- base::seq.int
[16:59:32.799]             signalCondition <- base::signalCondition
[16:59:32.799]             sys.calls <- base::sys.calls
[16:59:32.799]             `[[` <- base::`[[`
[16:59:32.799]             `+` <- base::`+`
[16:59:32.799]             `<<-` <- base::`<<-`
[16:59:32.799]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.799]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.799]                   3L)]
[16:59:32.799]             }
[16:59:32.799]             function(cond) {
[16:59:32.799]                 is_error <- inherits(cond, "error")
[16:59:32.799]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.799]                   NULL)
[16:59:32.799]                 if (is_error) {
[16:59:32.799]                   sessionInformation <- function() {
[16:59:32.799]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.799]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.799]                       search = base::search(), system = base::Sys.info())
[16:59:32.799]                   }
[16:59:32.799]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.799]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.799]                     cond$call), session = sessionInformation(), 
[16:59:32.799]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.799]                   signalCondition(cond)
[16:59:32.799]                 }
[16:59:32.799]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.799]                 "immediateCondition"))) {
[16:59:32.799]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.799]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.799]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.799]                   if (TRUE && !signal) {
[16:59:32.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.799]                     {
[16:59:32.799]                       inherits <- base::inherits
[16:59:32.799]                       invokeRestart <- base::invokeRestart
[16:59:32.799]                       is.null <- base::is.null
[16:59:32.799]                       muffled <- FALSE
[16:59:32.799]                       if (inherits(cond, "message")) {
[16:59:32.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.799]                         if (muffled) 
[16:59:32.799]                           invokeRestart("muffleMessage")
[16:59:32.799]                       }
[16:59:32.799]                       else if (inherits(cond, "warning")) {
[16:59:32.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.799]                         if (muffled) 
[16:59:32.799]                           invokeRestart("muffleWarning")
[16:59:32.799]                       }
[16:59:32.799]                       else if (inherits(cond, "condition")) {
[16:59:32.799]                         if (!is.null(pattern)) {
[16:59:32.799]                           computeRestarts <- base::computeRestarts
[16:59:32.799]                           grepl <- base::grepl
[16:59:32.799]                           restarts <- computeRestarts(cond)
[16:59:32.799]                           for (restart in restarts) {
[16:59:32.799]                             name <- restart$name
[16:59:32.799]                             if (is.null(name)) 
[16:59:32.799]                               next
[16:59:32.799]                             if (!grepl(pattern, name)) 
[16:59:32.799]                               next
[16:59:32.799]                             invokeRestart(restart)
[16:59:32.799]                             muffled <- TRUE
[16:59:32.799]                             break
[16:59:32.799]                           }
[16:59:32.799]                         }
[16:59:32.799]                       }
[16:59:32.799]                       invisible(muffled)
[16:59:32.799]                     }
[16:59:32.799]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.799]                   }
[16:59:32.799]                 }
[16:59:32.799]                 else {
[16:59:32.799]                   if (TRUE) {
[16:59:32.799]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.799]                     {
[16:59:32.799]                       inherits <- base::inherits
[16:59:32.799]                       invokeRestart <- base::invokeRestart
[16:59:32.799]                       is.null <- base::is.null
[16:59:32.799]                       muffled <- FALSE
[16:59:32.799]                       if (inherits(cond, "message")) {
[16:59:32.799]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.799]                         if (muffled) 
[16:59:32.799]                           invokeRestart("muffleMessage")
[16:59:32.799]                       }
[16:59:32.799]                       else if (inherits(cond, "warning")) {
[16:59:32.799]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.799]                         if (muffled) 
[16:59:32.799]                           invokeRestart("muffleWarning")
[16:59:32.799]                       }
[16:59:32.799]                       else if (inherits(cond, "condition")) {
[16:59:32.799]                         if (!is.null(pattern)) {
[16:59:32.799]                           computeRestarts <- base::computeRestarts
[16:59:32.799]                           grepl <- base::grepl
[16:59:32.799]                           restarts <- computeRestarts(cond)
[16:59:32.799]                           for (restart in restarts) {
[16:59:32.799]                             name <- restart$name
[16:59:32.799]                             if (is.null(name)) 
[16:59:32.799]                               next
[16:59:32.799]                             if (!grepl(pattern, name)) 
[16:59:32.799]                               next
[16:59:32.799]                             invokeRestart(restart)
[16:59:32.799]                             muffled <- TRUE
[16:59:32.799]                             break
[16:59:32.799]                           }
[16:59:32.799]                         }
[16:59:32.799]                       }
[16:59:32.799]                       invisible(muffled)
[16:59:32.799]                     }
[16:59:32.799]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.799]                   }
[16:59:32.799]                 }
[16:59:32.799]             }
[16:59:32.799]         }))
[16:59:32.799]     }, error = function(ex) {
[16:59:32.799]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.799]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.799]                 ...future.rng), started = ...future.startTime, 
[16:59:32.799]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.799]             version = "1.8"), class = "FutureResult")
[16:59:32.799]     }, finally = {
[16:59:32.799]         if (!identical(...future.workdir, getwd())) 
[16:59:32.799]             setwd(...future.workdir)
[16:59:32.799]         {
[16:59:32.799]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.799]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.799]             }
[16:59:32.799]             base::options(...future.oldOptions)
[16:59:32.799]             if (.Platform$OS.type == "windows") {
[16:59:32.799]                 old_names <- names(...future.oldEnvVars)
[16:59:32.799]                 envs <- base::Sys.getenv()
[16:59:32.799]                 names <- names(envs)
[16:59:32.799]                 common <- intersect(names, old_names)
[16:59:32.799]                 added <- setdiff(names, old_names)
[16:59:32.799]                 removed <- setdiff(old_names, names)
[16:59:32.799]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.799]                   envs[common]]
[16:59:32.799]                 NAMES <- toupper(changed)
[16:59:32.799]                 args <- list()
[16:59:32.799]                 for (kk in seq_along(NAMES)) {
[16:59:32.799]                   name <- changed[[kk]]
[16:59:32.799]                   NAME <- NAMES[[kk]]
[16:59:32.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.799]                     next
[16:59:32.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.799]                 }
[16:59:32.799]                 NAMES <- toupper(added)
[16:59:32.799]                 for (kk in seq_along(NAMES)) {
[16:59:32.799]                   name <- added[[kk]]
[16:59:32.799]                   NAME <- NAMES[[kk]]
[16:59:32.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.799]                     next
[16:59:32.799]                   args[[name]] <- ""
[16:59:32.799]                 }
[16:59:32.799]                 NAMES <- toupper(removed)
[16:59:32.799]                 for (kk in seq_along(NAMES)) {
[16:59:32.799]                   name <- removed[[kk]]
[16:59:32.799]                   NAME <- NAMES[[kk]]
[16:59:32.799]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.799]                     next
[16:59:32.799]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.799]                 }
[16:59:32.799]                 if (length(args) > 0) 
[16:59:32.799]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.799]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.799]             }
[16:59:32.799]             else {
[16:59:32.799]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.799]             }
[16:59:32.799]             {
[16:59:32.799]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.799]                   0L) {
[16:59:32.799]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.799]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.799]                   base::options(opts)
[16:59:32.799]                 }
[16:59:32.799]                 {
[16:59:32.799]                   {
[16:59:32.799]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.799]                     NULL
[16:59:32.799]                   }
[16:59:32.799]                   options(future.plan = NULL)
[16:59:32.799]                   if (is.na(NA_character_)) 
[16:59:32.799]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.799]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.799]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.799]                     .init = FALSE)
[16:59:32.799]                 }
[16:59:32.799]             }
[16:59:32.799]         }
[16:59:32.799]     })
[16:59:32.799]     if (TRUE) {
[16:59:32.799]         base::sink(type = "output", split = FALSE)
[16:59:32.799]         if (TRUE) {
[16:59:32.799]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.799]         }
[16:59:32.799]         else {
[16:59:32.799]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.799]         }
[16:59:32.799]         base::close(...future.stdout)
[16:59:32.799]         ...future.stdout <- NULL
[16:59:32.799]     }
[16:59:32.799]     ...future.result$conditions <- ...future.conditions
[16:59:32.799]     ...future.result$finished <- base::Sys.time()
[16:59:32.799]     ...future.result
[16:59:32.799] }
[16:59:32.802] Exporting 5 global objects (1.97 KiB) to cluster node #2 ...
[16:59:32.802] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:32.802] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.802] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ...
[16:59:32.803] Exporting ‘...future.FUN’ (1.73 KiB) to cluster node #2 ... DONE
[16:59:32.803] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ...
[16:59:32.803] Exporting ‘...future.elements_ii’ (192 bytes) to cluster node #2 ... DONE
[16:59:32.803] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:32.804] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.804] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:32.804] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:32.804] Exporting 5 global objects (1.97 KiB) to cluster node #2 ... DONE
[16:59:32.805] MultisessionFuture started
[16:59:32.805] - Launch lazy future ... done
[16:59:32.805] run() for ‘MultisessionFuture’ ... done
[16:59:32.805] Created future:
[16:59:32.805] MultisessionFuture:
[16:59:32.805] Label: ‘future_apply-2’
[16:59:32.805] Expression:
[16:59:32.805] {
[16:59:32.805]     do.call(function(...) {
[16:59:32.805]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.805]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.805]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.805]             on.exit(options(oopts), add = TRUE)
[16:59:32.805]         }
[16:59:32.805]         {
[16:59:32.805]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.805]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.805]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.805]             })
[16:59:32.805]         }
[16:59:32.805]     }, args = future.call.arguments)
[16:59:32.805] }
[16:59:32.805] Lazy evaluation: FALSE
[16:59:32.805] Asynchronous evaluation: TRUE
[16:59:32.805] Local evaluation: TRUE
[16:59:32.805] Environment: R_GlobalEnv
[16:59:32.805] Capture standard output: TRUE
[16:59:32.805] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.805] Globals: 5 objects totaling 1.97 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 1.73 KiB, list ‘...future.elements_ii’ of 192 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.805] Packages: <none>
[16:59:32.805] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.805] Resolved: FALSE
[16:59:32.805] Value: <not collected>
[16:59:32.805] Conditions captured: <none>
[16:59:32.805] Early signaling: FALSE
[16:59:32.805] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.805] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.817] Chunk #2 of 2 ... DONE
[16:59:32.817] Launching 2 futures (chunks) ... DONE
[16:59:32.817] Resolving 2 futures (chunks) ...
[16:59:32.817] resolve() on list ...
[16:59:32.817]  recursive: 0
[16:59:32.817]  length: 2
[16:59:32.818] 
[16:59:32.818] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.818] - Validating connection of MultisessionFuture
[16:59:32.818] - received message: FutureResult
[16:59:32.818] - Received FutureResult
[16:59:32.819] - Erased future from FutureRegistry
[16:59:32.819] result() for ClusterFuture ...
[16:59:32.819] - result already collected: FutureResult
[16:59:32.819] result() for ClusterFuture ... done
[16:59:32.819] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.819] Future #1
[16:59:32.819] result() for ClusterFuture ...
[16:59:32.819] - result already collected: FutureResult
[16:59:32.819] result() for ClusterFuture ... done
[16:59:32.819] result() for ClusterFuture ...
[16:59:32.820] - result already collected: FutureResult
[16:59:32.820] result() for ClusterFuture ... done
[16:59:32.820] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:32.820] - nx: 2
[16:59:32.820] - relay: TRUE
[16:59:32.820] - stdout: TRUE
[16:59:32.820] - signal: TRUE
[16:59:32.820] - resignal: FALSE
[16:59:32.820] - force: TRUE
[16:59:32.820] - relayed: [n=2] FALSE, FALSE
[16:59:32.820] - queued futures: [n=2] FALSE, FALSE
[16:59:32.820]  - until=1
[16:59:32.821]  - relaying element #1
[16:59:32.821] result() for ClusterFuture ...
[16:59:32.821] - result already collected: FutureResult
[16:59:32.821] result() for ClusterFuture ... done
[16:59:32.821] result() for ClusterFuture ...
[16:59:32.821] - result already collected: FutureResult
[16:59:32.821] result() for ClusterFuture ... done
[16:59:32.821] result() for ClusterFuture ...
[16:59:32.821] - result already collected: FutureResult
[16:59:32.821] result() for ClusterFuture ... done
[16:59:32.821] result() for ClusterFuture ...
[16:59:32.822] - result already collected: FutureResult
[16:59:32.822] result() for ClusterFuture ... done
[16:59:32.822] - relayed: [n=2] TRUE, FALSE
[16:59:32.822] - queued futures: [n=2] TRUE, FALSE
[16:59:32.822] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:32.822]  length: 1 (resolved future 1)
[16:59:32.853] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.853] - Validating connection of MultisessionFuture
[16:59:32.853] - received message: FutureResult
[16:59:32.854] - Received FutureResult
[16:59:32.854] - Erased future from FutureRegistry
[16:59:32.854] result() for ClusterFuture ...
[16:59:32.854] - result already collected: FutureResult
[16:59:32.854] result() for ClusterFuture ... done
[16:59:32.854] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.854] Future #2
[16:59:32.854] result() for ClusterFuture ...
[16:59:32.854] - result already collected: FutureResult
[16:59:32.854] result() for ClusterFuture ... done
[16:59:32.854] result() for ClusterFuture ...
[16:59:32.855] - result already collected: FutureResult
[16:59:32.855] result() for ClusterFuture ... done
[16:59:32.855] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.855] - nx: 2
[16:59:32.855] - relay: TRUE
[16:59:32.855] - stdout: TRUE
[16:59:32.855] - signal: TRUE
[16:59:32.855] - resignal: FALSE
[16:59:32.855] - force: TRUE
[16:59:32.855] - relayed: [n=2] TRUE, FALSE
[16:59:32.855] - queued futures: [n=2] TRUE, FALSE
[16:59:32.855]  - until=2
[16:59:32.856]  - relaying element #2
[16:59:32.856] result() for ClusterFuture ...
[16:59:32.856] - result already collected: FutureResult
[16:59:32.856] result() for ClusterFuture ... done
[16:59:32.856] result() for ClusterFuture ...
[16:59:32.856] - result already collected: FutureResult
[16:59:32.856] result() for ClusterFuture ... done
[16:59:32.856] result() for ClusterFuture ...
[16:59:32.856] - result already collected: FutureResult
[16:59:32.856] result() for ClusterFuture ... done
[16:59:32.856] result() for ClusterFuture ...
[16:59:32.857] - result already collected: FutureResult
[16:59:32.857] result() for ClusterFuture ... done
[16:59:32.857] - relayed: [n=2] TRUE, TRUE
[16:59:32.857] - queued futures: [n=2] TRUE, TRUE
[16:59:32.857] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.857]  length: 0 (resolved future 2)
[16:59:32.857] Relaying remaining futures
[16:59:32.857] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.857] - nx: 2
[16:59:32.857] - relay: TRUE
[16:59:32.857] - stdout: TRUE
[16:59:32.857] - signal: TRUE
[16:59:32.858] - resignal: FALSE
[16:59:32.858] - force: TRUE
[16:59:32.858] - relayed: [n=2] TRUE, TRUE
[16:59:32.858] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.858] - relayed: [n=2] TRUE, TRUE
[16:59:32.858] - queued futures: [n=2] TRUE, TRUE
[16:59:32.858] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.858] resolve() on list ... DONE
[16:59:32.858] result() for ClusterFuture ...
[16:59:32.858] - result already collected: FutureResult
[16:59:32.858] result() for ClusterFuture ... done
[16:59:32.859] result() for ClusterFuture ...
[16:59:32.859] - result already collected: FutureResult
[16:59:32.859] result() for ClusterFuture ... done
[16:59:32.859] result() for ClusterFuture ...
[16:59:32.859] - result already collected: FutureResult
[16:59:32.859] result() for ClusterFuture ... done
[16:59:32.859] result() for ClusterFuture ...
[16:59:32.859] - result already collected: FutureResult
[16:59:32.859] result() for ClusterFuture ... done
[16:59:32.859]  - Number of value chunks collected: 2
[16:59:32.859] Resolving 2 futures (chunks) ... DONE
[16:59:32.860] Reducing values from 2 chunks ...
[16:59:32.860]  - Number of values collected after concatenation: 6
[16:59:32.860]  - Number of values expected: 6
[16:59:32.860] Reducing values from 2 chunks ... DONE
[16:59:32.860] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[16:59:32.860] getGlobalsAndPackagesXApply() ...
[16:59:32.860]  - future.globals: TRUE
[16:59:32.860] getGlobalsAndPackages() ...
[16:59:32.860] Searching for globals...
[16:59:32.862] - globals found: [1] ‘FUN’
[16:59:32.862] Searching for globals ... DONE
[16:59:32.862] Resolving globals: FALSE
[16:59:32.862] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:32.864] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:32.865] - globals: [1] ‘FUN’
[16:59:32.865] 
[16:59:32.865] getGlobalsAndPackages() ... DONE
[16:59:32.865]  - globals found/used: [n=1] ‘FUN’
[16:59:32.865]  - needed namespaces: [n=0] 
[16:59:32.865] Finding globals ... DONE
[16:59:32.865]  - use_args: TRUE
[16:59:32.865]  - Getting '...' globals ...
[16:59:32.866] resolve() on list ...
[16:59:32.866]  recursive: 0
[16:59:32.866]  length: 1
[16:59:32.866]  elements: ‘...’
[16:59:32.866]  length: 0 (resolved future 1)
[16:59:32.866] resolve() on list ... DONE
[16:59:32.866]    - '...' content: [n=0] 
[16:59:32.866] List of 1
[16:59:32.866]  $ ...: list()
[16:59:32.866]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.866]  - attr(*, "where")=List of 1
[16:59:32.866]   ..$ ...:<environment: 0x55f315becdc8> 
[16:59:32.866]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.866]  - attr(*, "resolved")= logi TRUE
[16:59:32.866]  - attr(*, "total_size")= num NA
[16:59:32.869]  - Getting '...' globals ... DONE
[16:59:32.869] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:32.869] List of 2
[16:59:32.869]  $ ...future.FUN:function (x)  
[16:59:32.869]  $ ...          : list()
[16:59:32.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.869]  - attr(*, "where")=List of 2
[16:59:32.869]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:32.869]   ..$ ...          :<environment: 0x55f315becdc8> 
[16:59:32.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.869]  - attr(*, "resolved")= logi FALSE
[16:59:32.869]  - attr(*, "total_size")= num 848
[16:59:32.871] Packages to be attached in all futures: [n=0] 
[16:59:32.872] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.875] future_lapply() ...
[16:59:32.879] Number of chunks: 2
[16:59:32.879] getGlobalsAndPackagesXApply() ...
[16:59:32.879]  - future.globals: <name-value list> with names ‘list()’
[16:59:32.879]  - use_args: TRUE
[16:59:32.879] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:32.879] List of 2
[16:59:32.879]  $ ...          : list()
[16:59:32.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:32.879]  $ ...future.FUN:function (x)  
[16:59:32.879]  - attr(*, "where")=List of 2
[16:59:32.879]   ..$ ...          :<environment: 0x55f315becdc8> 
[16:59:32.879]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:32.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:32.879]  - attr(*, "resolved")= logi FALSE
[16:59:32.879]  - attr(*, "total_size")= num NA
[16:59:32.882] Packages to be attached in all futures: [n=0] 
[16:59:32.883] getGlobalsAndPackagesXApply() ... DONE
[16:59:32.883] Number of futures (= number of chunks): 2
[16:59:32.883] Launching 2 futures (chunks) ...
[16:59:32.883] Chunk #1 of 2 ...
[16:59:32.883]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.883]  - seeds: <none>
[16:59:32.883]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.883] getGlobalsAndPackages() ...
[16:59:32.884] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.884] Resolving globals: FALSE
[16:59:32.884] Tweak future expression to call with '...' arguments ...
[16:59:32.884] {
[16:59:32.884]     do.call(function(...) {
[16:59:32.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.884]             on.exit(options(oopts), add = TRUE)
[16:59:32.884]         }
[16:59:32.884]         {
[16:59:32.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.884]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.884]             })
[16:59:32.884]         }
[16:59:32.884]     }, args = future.call.arguments)
[16:59:32.884] }
[16:59:32.884] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.884] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.885] 
[16:59:32.885] getGlobalsAndPackages() ... DONE
[16:59:32.885] run() for ‘Future’ ...
[16:59:32.885] - state: ‘created’
[16:59:32.885] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.899] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.899]   - Field: ‘node’
[16:59:32.899]   - Field: ‘label’
[16:59:32.899]   - Field: ‘local’
[16:59:32.899]   - Field: ‘owner’
[16:59:32.900]   - Field: ‘envir’
[16:59:32.900]   - Field: ‘workers’
[16:59:32.900]   - Field: ‘packages’
[16:59:32.900]   - Field: ‘gc’
[16:59:32.900]   - Field: ‘conditions’
[16:59:32.900]   - Field: ‘persistent’
[16:59:32.900]   - Field: ‘expr’
[16:59:32.900]   - Field: ‘uuid’
[16:59:32.900]   - Field: ‘seed’
[16:59:32.900]   - Field: ‘version’
[16:59:32.900]   - Field: ‘result’
[16:59:32.901]   - Field: ‘asynchronous’
[16:59:32.901]   - Field: ‘calls’
[16:59:32.901]   - Field: ‘globals’
[16:59:32.901]   - Field: ‘stdout’
[16:59:32.901]   - Field: ‘earlySignal’
[16:59:32.901]   - Field: ‘lazy’
[16:59:32.901]   - Field: ‘state’
[16:59:32.901] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.901] - Launch lazy future ...
[16:59:32.902] Packages needed by the future expression (n = 0): <none>
[16:59:32.902] Packages needed by future strategies (n = 0): <none>
[16:59:32.902] {
[16:59:32.902]     {
[16:59:32.902]         {
[16:59:32.902]             ...future.startTime <- base::Sys.time()
[16:59:32.902]             {
[16:59:32.902]                 {
[16:59:32.902]                   {
[16:59:32.902]                     {
[16:59:32.902]                       base::local({
[16:59:32.902]                         has_future <- base::requireNamespace("future", 
[16:59:32.902]                           quietly = TRUE)
[16:59:32.902]                         if (has_future) {
[16:59:32.902]                           ns <- base::getNamespace("future")
[16:59:32.902]                           version <- ns[[".package"]][["version"]]
[16:59:32.902]                           if (is.null(version)) 
[16:59:32.902]                             version <- utils::packageVersion("future")
[16:59:32.902]                         }
[16:59:32.902]                         else {
[16:59:32.902]                           version <- NULL
[16:59:32.902]                         }
[16:59:32.902]                         if (!has_future || version < "1.8.0") {
[16:59:32.902]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.902]                             "", base::R.version$version.string), 
[16:59:32.902]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.902]                               "release", "version")], collapse = " "), 
[16:59:32.902]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.902]                             info)
[16:59:32.902]                           info <- base::paste(info, collapse = "; ")
[16:59:32.902]                           if (!has_future) {
[16:59:32.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.902]                               info)
[16:59:32.902]                           }
[16:59:32.902]                           else {
[16:59:32.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.902]                               info, version)
[16:59:32.902]                           }
[16:59:32.902]                           base::stop(msg)
[16:59:32.902]                         }
[16:59:32.902]                       })
[16:59:32.902]                     }
[16:59:32.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.902]                     base::options(mc.cores = 1L)
[16:59:32.902]                   }
[16:59:32.902]                   ...future.strategy.old <- future::plan("list")
[16:59:32.902]                   options(future.plan = NULL)
[16:59:32.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.902]                 }
[16:59:32.902]                 ...future.workdir <- getwd()
[16:59:32.902]             }
[16:59:32.902]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.902]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.902]         }
[16:59:32.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.902]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.902]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.902]             base::names(...future.oldOptions))
[16:59:32.902]     }
[16:59:32.902]     if (FALSE) {
[16:59:32.902]     }
[16:59:32.902]     else {
[16:59:32.902]         if (TRUE) {
[16:59:32.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.902]                 open = "w")
[16:59:32.902]         }
[16:59:32.902]         else {
[16:59:32.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.902]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.902]         }
[16:59:32.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.902]             base::sink(type = "output", split = FALSE)
[16:59:32.902]             base::close(...future.stdout)
[16:59:32.902]         }, add = TRUE)
[16:59:32.902]     }
[16:59:32.902]     ...future.frame <- base::sys.nframe()
[16:59:32.902]     ...future.conditions <- base::list()
[16:59:32.902]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.902]     if (FALSE) {
[16:59:32.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.902]     }
[16:59:32.902]     ...future.result <- base::tryCatch({
[16:59:32.902]         base::withCallingHandlers({
[16:59:32.902]             ...future.value <- base::withVisible(base::local({
[16:59:32.902]                 ...future.makeSendCondition <- base::local({
[16:59:32.902]                   sendCondition <- NULL
[16:59:32.902]                   function(frame = 1L) {
[16:59:32.902]                     if (is.function(sendCondition)) 
[16:59:32.902]                       return(sendCondition)
[16:59:32.902]                     ns <- getNamespace("parallel")
[16:59:32.902]                     if (exists("sendData", mode = "function", 
[16:59:32.902]                       envir = ns)) {
[16:59:32.902]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.902]                         envir = ns)
[16:59:32.902]                       envir <- sys.frame(frame)
[16:59:32.902]                       master <- NULL
[16:59:32.902]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.902]                         !identical(envir, emptyenv())) {
[16:59:32.902]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.902]                           inherits = FALSE)) {
[16:59:32.902]                           master <- get("master", mode = "list", 
[16:59:32.902]                             envir = envir, inherits = FALSE)
[16:59:32.902]                           if (inherits(master, c("SOCKnode", 
[16:59:32.902]                             "SOCK0node"))) {
[16:59:32.902]                             sendCondition <<- function(cond) {
[16:59:32.902]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.902]                                 success = TRUE)
[16:59:32.902]                               parallel_sendData(master, data)
[16:59:32.902]                             }
[16:59:32.902]                             return(sendCondition)
[16:59:32.902]                           }
[16:59:32.902]                         }
[16:59:32.902]                         frame <- frame + 1L
[16:59:32.902]                         envir <- sys.frame(frame)
[16:59:32.902]                       }
[16:59:32.902]                     }
[16:59:32.902]                     sendCondition <<- function(cond) NULL
[16:59:32.902]                   }
[16:59:32.902]                 })
[16:59:32.902]                 withCallingHandlers({
[16:59:32.902]                   {
[16:59:32.902]                     do.call(function(...) {
[16:59:32.902]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.902]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.902]                         ...future.globals.maxSize)) {
[16:59:32.902]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.902]                         on.exit(options(oopts), add = TRUE)
[16:59:32.902]                       }
[16:59:32.902]                       {
[16:59:32.902]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.902]                           FUN = function(jj) {
[16:59:32.902]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.902]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.902]                           })
[16:59:32.902]                       }
[16:59:32.902]                     }, args = future.call.arguments)
[16:59:32.902]                   }
[16:59:32.902]                 }, immediateCondition = function(cond) {
[16:59:32.902]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.902]                   sendCondition(cond)
[16:59:32.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.902]                   {
[16:59:32.902]                     inherits <- base::inherits
[16:59:32.902]                     invokeRestart <- base::invokeRestart
[16:59:32.902]                     is.null <- base::is.null
[16:59:32.902]                     muffled <- FALSE
[16:59:32.902]                     if (inherits(cond, "message")) {
[16:59:32.902]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.902]                       if (muffled) 
[16:59:32.902]                         invokeRestart("muffleMessage")
[16:59:32.902]                     }
[16:59:32.902]                     else if (inherits(cond, "warning")) {
[16:59:32.902]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.902]                       if (muffled) 
[16:59:32.902]                         invokeRestart("muffleWarning")
[16:59:32.902]                     }
[16:59:32.902]                     else if (inherits(cond, "condition")) {
[16:59:32.902]                       if (!is.null(pattern)) {
[16:59:32.902]                         computeRestarts <- base::computeRestarts
[16:59:32.902]                         grepl <- base::grepl
[16:59:32.902]                         restarts <- computeRestarts(cond)
[16:59:32.902]                         for (restart in restarts) {
[16:59:32.902]                           name <- restart$name
[16:59:32.902]                           if (is.null(name)) 
[16:59:32.902]                             next
[16:59:32.902]                           if (!grepl(pattern, name)) 
[16:59:32.902]                             next
[16:59:32.902]                           invokeRestart(restart)
[16:59:32.902]                           muffled <- TRUE
[16:59:32.902]                           break
[16:59:32.902]                         }
[16:59:32.902]                       }
[16:59:32.902]                     }
[16:59:32.902]                     invisible(muffled)
[16:59:32.902]                   }
[16:59:32.902]                   muffleCondition(cond)
[16:59:32.902]                 })
[16:59:32.902]             }))
[16:59:32.902]             future::FutureResult(value = ...future.value$value, 
[16:59:32.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.902]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.902]                     ...future.globalenv.names))
[16:59:32.902]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.902]         }, condition = base::local({
[16:59:32.902]             c <- base::c
[16:59:32.902]             inherits <- base::inherits
[16:59:32.902]             invokeRestart <- base::invokeRestart
[16:59:32.902]             length <- base::length
[16:59:32.902]             list <- base::list
[16:59:32.902]             seq.int <- base::seq.int
[16:59:32.902]             signalCondition <- base::signalCondition
[16:59:32.902]             sys.calls <- base::sys.calls
[16:59:32.902]             `[[` <- base::`[[`
[16:59:32.902]             `+` <- base::`+`
[16:59:32.902]             `<<-` <- base::`<<-`
[16:59:32.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.902]                   3L)]
[16:59:32.902]             }
[16:59:32.902]             function(cond) {
[16:59:32.902]                 is_error <- inherits(cond, "error")
[16:59:32.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.902]                   NULL)
[16:59:32.902]                 if (is_error) {
[16:59:32.902]                   sessionInformation <- function() {
[16:59:32.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.902]                       search = base::search(), system = base::Sys.info())
[16:59:32.902]                   }
[16:59:32.902]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.902]                     cond$call), session = sessionInformation(), 
[16:59:32.902]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.902]                   signalCondition(cond)
[16:59:32.902]                 }
[16:59:32.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.902]                 "immediateCondition"))) {
[16:59:32.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.902]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.902]                   if (TRUE && !signal) {
[16:59:32.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.902]                     {
[16:59:32.902]                       inherits <- base::inherits
[16:59:32.902]                       invokeRestart <- base::invokeRestart
[16:59:32.902]                       is.null <- base::is.null
[16:59:32.902]                       muffled <- FALSE
[16:59:32.902]                       if (inherits(cond, "message")) {
[16:59:32.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.902]                         if (muffled) 
[16:59:32.902]                           invokeRestart("muffleMessage")
[16:59:32.902]                       }
[16:59:32.902]                       else if (inherits(cond, "warning")) {
[16:59:32.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.902]                         if (muffled) 
[16:59:32.902]                           invokeRestart("muffleWarning")
[16:59:32.902]                       }
[16:59:32.902]                       else if (inherits(cond, "condition")) {
[16:59:32.902]                         if (!is.null(pattern)) {
[16:59:32.902]                           computeRestarts <- base::computeRestarts
[16:59:32.902]                           grepl <- base::grepl
[16:59:32.902]                           restarts <- computeRestarts(cond)
[16:59:32.902]                           for (restart in restarts) {
[16:59:32.902]                             name <- restart$name
[16:59:32.902]                             if (is.null(name)) 
[16:59:32.902]                               next
[16:59:32.902]                             if (!grepl(pattern, name)) 
[16:59:32.902]                               next
[16:59:32.902]                             invokeRestart(restart)
[16:59:32.902]                             muffled <- TRUE
[16:59:32.902]                             break
[16:59:32.902]                           }
[16:59:32.902]                         }
[16:59:32.902]                       }
[16:59:32.902]                       invisible(muffled)
[16:59:32.902]                     }
[16:59:32.902]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.902]                   }
[16:59:32.902]                 }
[16:59:32.902]                 else {
[16:59:32.902]                   if (TRUE) {
[16:59:32.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.902]                     {
[16:59:32.902]                       inherits <- base::inherits
[16:59:32.902]                       invokeRestart <- base::invokeRestart
[16:59:32.902]                       is.null <- base::is.null
[16:59:32.902]                       muffled <- FALSE
[16:59:32.902]                       if (inherits(cond, "message")) {
[16:59:32.902]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.902]                         if (muffled) 
[16:59:32.902]                           invokeRestart("muffleMessage")
[16:59:32.902]                       }
[16:59:32.902]                       else if (inherits(cond, "warning")) {
[16:59:32.902]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.902]                         if (muffled) 
[16:59:32.902]                           invokeRestart("muffleWarning")
[16:59:32.902]                       }
[16:59:32.902]                       else if (inherits(cond, "condition")) {
[16:59:32.902]                         if (!is.null(pattern)) {
[16:59:32.902]                           computeRestarts <- base::computeRestarts
[16:59:32.902]                           grepl <- base::grepl
[16:59:32.902]                           restarts <- computeRestarts(cond)
[16:59:32.902]                           for (restart in restarts) {
[16:59:32.902]                             name <- restart$name
[16:59:32.902]                             if (is.null(name)) 
[16:59:32.902]                               next
[16:59:32.902]                             if (!grepl(pattern, name)) 
[16:59:32.902]                               next
[16:59:32.902]                             invokeRestart(restart)
[16:59:32.902]                             muffled <- TRUE
[16:59:32.902]                             break
[16:59:32.902]                           }
[16:59:32.902]                         }
[16:59:32.902]                       }
[16:59:32.902]                       invisible(muffled)
[16:59:32.902]                     }
[16:59:32.902]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.902]                   }
[16:59:32.902]                 }
[16:59:32.902]             }
[16:59:32.902]         }))
[16:59:32.902]     }, error = function(ex) {
[16:59:32.902]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.902]                 ...future.rng), started = ...future.startTime, 
[16:59:32.902]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.902]             version = "1.8"), class = "FutureResult")
[16:59:32.902]     }, finally = {
[16:59:32.902]         if (!identical(...future.workdir, getwd())) 
[16:59:32.902]             setwd(...future.workdir)
[16:59:32.902]         {
[16:59:32.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.902]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.902]             }
[16:59:32.902]             base::options(...future.oldOptions)
[16:59:32.902]             if (.Platform$OS.type == "windows") {
[16:59:32.902]                 old_names <- names(...future.oldEnvVars)
[16:59:32.902]                 envs <- base::Sys.getenv()
[16:59:32.902]                 names <- names(envs)
[16:59:32.902]                 common <- intersect(names, old_names)
[16:59:32.902]                 added <- setdiff(names, old_names)
[16:59:32.902]                 removed <- setdiff(old_names, names)
[16:59:32.902]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.902]                   envs[common]]
[16:59:32.902]                 NAMES <- toupper(changed)
[16:59:32.902]                 args <- list()
[16:59:32.902]                 for (kk in seq_along(NAMES)) {
[16:59:32.902]                   name <- changed[[kk]]
[16:59:32.902]                   NAME <- NAMES[[kk]]
[16:59:32.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.902]                     next
[16:59:32.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.902]                 }
[16:59:32.902]                 NAMES <- toupper(added)
[16:59:32.902]                 for (kk in seq_along(NAMES)) {
[16:59:32.902]                   name <- added[[kk]]
[16:59:32.902]                   NAME <- NAMES[[kk]]
[16:59:32.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.902]                     next
[16:59:32.902]                   args[[name]] <- ""
[16:59:32.902]                 }
[16:59:32.902]                 NAMES <- toupper(removed)
[16:59:32.902]                 for (kk in seq_along(NAMES)) {
[16:59:32.902]                   name <- removed[[kk]]
[16:59:32.902]                   NAME <- NAMES[[kk]]
[16:59:32.902]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.902]                     next
[16:59:32.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.902]                 }
[16:59:32.902]                 if (length(args) > 0) 
[16:59:32.902]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.902]             }
[16:59:32.902]             else {
[16:59:32.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.902]             }
[16:59:32.902]             {
[16:59:32.902]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.902]                   0L) {
[16:59:32.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.902]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.902]                   base::options(opts)
[16:59:32.902]                 }
[16:59:32.902]                 {
[16:59:32.902]                   {
[16:59:32.902]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.902]                     NULL
[16:59:32.902]                   }
[16:59:32.902]                   options(future.plan = NULL)
[16:59:32.902]                   if (is.na(NA_character_)) 
[16:59:32.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.902]                     .init = FALSE)
[16:59:32.902]                 }
[16:59:32.902]             }
[16:59:32.902]         }
[16:59:32.902]     })
[16:59:32.902]     if (TRUE) {
[16:59:32.902]         base::sink(type = "output", split = FALSE)
[16:59:32.902]         if (TRUE) {
[16:59:32.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.902]         }
[16:59:32.902]         else {
[16:59:32.902]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.902]         }
[16:59:32.902]         base::close(...future.stdout)
[16:59:32.902]         ...future.stdout <- NULL
[16:59:32.902]     }
[16:59:32.902]     ...future.result$conditions <- ...future.conditions
[16:59:32.902]     ...future.result$finished <- base::Sys.time()
[16:59:32.902]     ...future.result
[16:59:32.902] }
[16:59:32.905] Exporting 5 global objects (960 bytes) to cluster node #1 ...
[16:59:32.906] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:32.906] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.906] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:59:32.906] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:59:32.907] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:59:32.907] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.907] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:32.907] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:32.908] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:32.908] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:32.908] Exporting 5 global objects (960 bytes) to cluster node #1 ... DONE
[16:59:32.909] MultisessionFuture started
[16:59:32.909] - Launch lazy future ... done
[16:59:32.909] run() for ‘MultisessionFuture’ ... done
[16:59:32.909] Created future:
[16:59:32.909] MultisessionFuture:
[16:59:32.909] Label: ‘future_apply-1’
[16:59:32.909] Expression:
[16:59:32.909] {
[16:59:32.909]     do.call(function(...) {
[16:59:32.909]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.909]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.909]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.909]             on.exit(options(oopts), add = TRUE)
[16:59:32.909]         }
[16:59:32.909]         {
[16:59:32.909]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.909]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.909]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.909]             })
[16:59:32.909]         }
[16:59:32.909]     }, args = future.call.arguments)
[16:59:32.909] }
[16:59:32.909] Lazy evaluation: FALSE
[16:59:32.909] Asynchronous evaluation: TRUE
[16:59:32.909] Local evaluation: TRUE
[16:59:32.909] Environment: R_GlobalEnv
[16:59:32.909] Capture standard output: TRUE
[16:59:32.909] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.909] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.909] Packages: <none>
[16:59:32.909] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.909] Resolved: FALSE
[16:59:32.909] Value: <not collected>
[16:59:32.909] Conditions captured: <none>
[16:59:32.909] Early signaling: FALSE
[16:59:32.909] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.909] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.921] Chunk #1 of 2 ... DONE
[16:59:32.921] Chunk #2 of 2 ...
[16:59:32.921]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:32.921]  - seeds: <none>
[16:59:32.921]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.921] getGlobalsAndPackages() ...
[16:59:32.921] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.921] Resolving globals: FALSE
[16:59:32.922] Tweak future expression to call with '...' arguments ...
[16:59:32.922] {
[16:59:32.922]     do.call(function(...) {
[16:59:32.922]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.922]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.922]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.922]             on.exit(options(oopts), add = TRUE)
[16:59:32.922]         }
[16:59:32.922]         {
[16:59:32.922]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.922]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.922]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.922]             })
[16:59:32.922]         }
[16:59:32.922]     }, args = future.call.arguments)
[16:59:32.922] }
[16:59:32.922] Tweak future expression to call with '...' arguments ... DONE
[16:59:32.922] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:32.922] 
[16:59:32.923] getGlobalsAndPackages() ... DONE
[16:59:32.923] run() for ‘Future’ ...
[16:59:32.923] - state: ‘created’
[16:59:32.923] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:32.937] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.937] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:32.937]   - Field: ‘node’
[16:59:32.938]   - Field: ‘label’
[16:59:32.938]   - Field: ‘local’
[16:59:32.938]   - Field: ‘owner’
[16:59:32.938]   - Field: ‘envir’
[16:59:32.938]   - Field: ‘workers’
[16:59:32.938]   - Field: ‘packages’
[16:59:32.938]   - Field: ‘gc’
[16:59:32.938]   - Field: ‘conditions’
[16:59:32.938]   - Field: ‘persistent’
[16:59:32.938]   - Field: ‘expr’
[16:59:32.939]   - Field: ‘uuid’
[16:59:32.939]   - Field: ‘seed’
[16:59:32.939]   - Field: ‘version’
[16:59:32.939]   - Field: ‘result’
[16:59:32.939]   - Field: ‘asynchronous’
[16:59:32.939]   - Field: ‘calls’
[16:59:32.939]   - Field: ‘globals’
[16:59:32.939]   - Field: ‘stdout’
[16:59:32.939]   - Field: ‘earlySignal’
[16:59:32.939]   - Field: ‘lazy’
[16:59:32.940]   - Field: ‘state’
[16:59:32.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:32.940] - Launch lazy future ...
[16:59:32.940] Packages needed by the future expression (n = 0): <none>
[16:59:32.940] Packages needed by future strategies (n = 0): <none>
[16:59:32.941] {
[16:59:32.941]     {
[16:59:32.941]         {
[16:59:32.941]             ...future.startTime <- base::Sys.time()
[16:59:32.941]             {
[16:59:32.941]                 {
[16:59:32.941]                   {
[16:59:32.941]                     {
[16:59:32.941]                       base::local({
[16:59:32.941]                         has_future <- base::requireNamespace("future", 
[16:59:32.941]                           quietly = TRUE)
[16:59:32.941]                         if (has_future) {
[16:59:32.941]                           ns <- base::getNamespace("future")
[16:59:32.941]                           version <- ns[[".package"]][["version"]]
[16:59:32.941]                           if (is.null(version)) 
[16:59:32.941]                             version <- utils::packageVersion("future")
[16:59:32.941]                         }
[16:59:32.941]                         else {
[16:59:32.941]                           version <- NULL
[16:59:32.941]                         }
[16:59:32.941]                         if (!has_future || version < "1.8.0") {
[16:59:32.941]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:32.941]                             "", base::R.version$version.string), 
[16:59:32.941]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:32.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:32.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:32.941]                               "release", "version")], collapse = " "), 
[16:59:32.941]                             hostname = base::Sys.info()[["nodename"]])
[16:59:32.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:32.941]                             info)
[16:59:32.941]                           info <- base::paste(info, collapse = "; ")
[16:59:32.941]                           if (!has_future) {
[16:59:32.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:32.941]                               info)
[16:59:32.941]                           }
[16:59:32.941]                           else {
[16:59:32.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:32.941]                               info, version)
[16:59:32.941]                           }
[16:59:32.941]                           base::stop(msg)
[16:59:32.941]                         }
[16:59:32.941]                       })
[16:59:32.941]                     }
[16:59:32.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:32.941]                     base::options(mc.cores = 1L)
[16:59:32.941]                   }
[16:59:32.941]                   ...future.strategy.old <- future::plan("list")
[16:59:32.941]                   options(future.plan = NULL)
[16:59:32.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:32.941]                 }
[16:59:32.941]                 ...future.workdir <- getwd()
[16:59:32.941]             }
[16:59:32.941]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:32.941]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:32.941]         }
[16:59:32.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:32.941]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:32.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:32.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:32.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:32.941]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:32.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:32.941]             base::names(...future.oldOptions))
[16:59:32.941]     }
[16:59:32.941]     if (FALSE) {
[16:59:32.941]     }
[16:59:32.941]     else {
[16:59:32.941]         if (TRUE) {
[16:59:32.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:32.941]                 open = "w")
[16:59:32.941]         }
[16:59:32.941]         else {
[16:59:32.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:32.941]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:32.941]         }
[16:59:32.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:32.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:32.941]             base::sink(type = "output", split = FALSE)
[16:59:32.941]             base::close(...future.stdout)
[16:59:32.941]         }, add = TRUE)
[16:59:32.941]     }
[16:59:32.941]     ...future.frame <- base::sys.nframe()
[16:59:32.941]     ...future.conditions <- base::list()
[16:59:32.941]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:32.941]     if (FALSE) {
[16:59:32.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:32.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:32.941]     }
[16:59:32.941]     ...future.result <- base::tryCatch({
[16:59:32.941]         base::withCallingHandlers({
[16:59:32.941]             ...future.value <- base::withVisible(base::local({
[16:59:32.941]                 ...future.makeSendCondition <- base::local({
[16:59:32.941]                   sendCondition <- NULL
[16:59:32.941]                   function(frame = 1L) {
[16:59:32.941]                     if (is.function(sendCondition)) 
[16:59:32.941]                       return(sendCondition)
[16:59:32.941]                     ns <- getNamespace("parallel")
[16:59:32.941]                     if (exists("sendData", mode = "function", 
[16:59:32.941]                       envir = ns)) {
[16:59:32.941]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:32.941]                         envir = ns)
[16:59:32.941]                       envir <- sys.frame(frame)
[16:59:32.941]                       master <- NULL
[16:59:32.941]                       while (!identical(envir, .GlobalEnv) && 
[16:59:32.941]                         !identical(envir, emptyenv())) {
[16:59:32.941]                         if (exists("master", mode = "list", envir = envir, 
[16:59:32.941]                           inherits = FALSE)) {
[16:59:32.941]                           master <- get("master", mode = "list", 
[16:59:32.941]                             envir = envir, inherits = FALSE)
[16:59:32.941]                           if (inherits(master, c("SOCKnode", 
[16:59:32.941]                             "SOCK0node"))) {
[16:59:32.941]                             sendCondition <<- function(cond) {
[16:59:32.941]                               data <- list(type = "VALUE", value = cond, 
[16:59:32.941]                                 success = TRUE)
[16:59:32.941]                               parallel_sendData(master, data)
[16:59:32.941]                             }
[16:59:32.941]                             return(sendCondition)
[16:59:32.941]                           }
[16:59:32.941]                         }
[16:59:32.941]                         frame <- frame + 1L
[16:59:32.941]                         envir <- sys.frame(frame)
[16:59:32.941]                       }
[16:59:32.941]                     }
[16:59:32.941]                     sendCondition <<- function(cond) NULL
[16:59:32.941]                   }
[16:59:32.941]                 })
[16:59:32.941]                 withCallingHandlers({
[16:59:32.941]                   {
[16:59:32.941]                     do.call(function(...) {
[16:59:32.941]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.941]                       if (!identical(...future.globals.maxSize.org, 
[16:59:32.941]                         ...future.globals.maxSize)) {
[16:59:32.941]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.941]                         on.exit(options(oopts), add = TRUE)
[16:59:32.941]                       }
[16:59:32.941]                       {
[16:59:32.941]                         lapply(seq_along(...future.elements_ii), 
[16:59:32.941]                           FUN = function(jj) {
[16:59:32.941]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.941]                             ...future.FUN(...future.X_jj, ...)
[16:59:32.941]                           })
[16:59:32.941]                       }
[16:59:32.941]                     }, args = future.call.arguments)
[16:59:32.941]                   }
[16:59:32.941]                 }, immediateCondition = function(cond) {
[16:59:32.941]                   sendCondition <- ...future.makeSendCondition()
[16:59:32.941]                   sendCondition(cond)
[16:59:32.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.941]                   {
[16:59:32.941]                     inherits <- base::inherits
[16:59:32.941]                     invokeRestart <- base::invokeRestart
[16:59:32.941]                     is.null <- base::is.null
[16:59:32.941]                     muffled <- FALSE
[16:59:32.941]                     if (inherits(cond, "message")) {
[16:59:32.941]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:32.941]                       if (muffled) 
[16:59:32.941]                         invokeRestart("muffleMessage")
[16:59:32.941]                     }
[16:59:32.941]                     else if (inherits(cond, "warning")) {
[16:59:32.941]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:32.941]                       if (muffled) 
[16:59:32.941]                         invokeRestart("muffleWarning")
[16:59:32.941]                     }
[16:59:32.941]                     else if (inherits(cond, "condition")) {
[16:59:32.941]                       if (!is.null(pattern)) {
[16:59:32.941]                         computeRestarts <- base::computeRestarts
[16:59:32.941]                         grepl <- base::grepl
[16:59:32.941]                         restarts <- computeRestarts(cond)
[16:59:32.941]                         for (restart in restarts) {
[16:59:32.941]                           name <- restart$name
[16:59:32.941]                           if (is.null(name)) 
[16:59:32.941]                             next
[16:59:32.941]                           if (!grepl(pattern, name)) 
[16:59:32.941]                             next
[16:59:32.941]                           invokeRestart(restart)
[16:59:32.941]                           muffled <- TRUE
[16:59:32.941]                           break
[16:59:32.941]                         }
[16:59:32.941]                       }
[16:59:32.941]                     }
[16:59:32.941]                     invisible(muffled)
[16:59:32.941]                   }
[16:59:32.941]                   muffleCondition(cond)
[16:59:32.941]                 })
[16:59:32.941]             }))
[16:59:32.941]             future::FutureResult(value = ...future.value$value, 
[16:59:32.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.941]                   ...future.rng), globalenv = if (FALSE) 
[16:59:32.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:32.941]                     ...future.globalenv.names))
[16:59:32.941]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:32.941]         }, condition = base::local({
[16:59:32.941]             c <- base::c
[16:59:32.941]             inherits <- base::inherits
[16:59:32.941]             invokeRestart <- base::invokeRestart
[16:59:32.941]             length <- base::length
[16:59:32.941]             list <- base::list
[16:59:32.941]             seq.int <- base::seq.int
[16:59:32.941]             signalCondition <- base::signalCondition
[16:59:32.941]             sys.calls <- base::sys.calls
[16:59:32.941]             `[[` <- base::`[[`
[16:59:32.941]             `+` <- base::`+`
[16:59:32.941]             `<<-` <- base::`<<-`
[16:59:32.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:32.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:32.941]                   3L)]
[16:59:32.941]             }
[16:59:32.941]             function(cond) {
[16:59:32.941]                 is_error <- inherits(cond, "error")
[16:59:32.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:32.941]                   NULL)
[16:59:32.941]                 if (is_error) {
[16:59:32.941]                   sessionInformation <- function() {
[16:59:32.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:32.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:32.941]                       search = base::search(), system = base::Sys.info())
[16:59:32.941]                   }
[16:59:32.941]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:32.941]                     cond$call), session = sessionInformation(), 
[16:59:32.941]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:32.941]                   signalCondition(cond)
[16:59:32.941]                 }
[16:59:32.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:32.941]                 "immediateCondition"))) {
[16:59:32.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:32.941]                   ...future.conditions[[length(...future.conditions) + 
[16:59:32.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:32.941]                   if (TRUE && !signal) {
[16:59:32.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.941]                     {
[16:59:32.941]                       inherits <- base::inherits
[16:59:32.941]                       invokeRestart <- base::invokeRestart
[16:59:32.941]                       is.null <- base::is.null
[16:59:32.941]                       muffled <- FALSE
[16:59:32.941]                       if (inherits(cond, "message")) {
[16:59:32.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.941]                         if (muffled) 
[16:59:32.941]                           invokeRestart("muffleMessage")
[16:59:32.941]                       }
[16:59:32.941]                       else if (inherits(cond, "warning")) {
[16:59:32.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.941]                         if (muffled) 
[16:59:32.941]                           invokeRestart("muffleWarning")
[16:59:32.941]                       }
[16:59:32.941]                       else if (inherits(cond, "condition")) {
[16:59:32.941]                         if (!is.null(pattern)) {
[16:59:32.941]                           computeRestarts <- base::computeRestarts
[16:59:32.941]                           grepl <- base::grepl
[16:59:32.941]                           restarts <- computeRestarts(cond)
[16:59:32.941]                           for (restart in restarts) {
[16:59:32.941]                             name <- restart$name
[16:59:32.941]                             if (is.null(name)) 
[16:59:32.941]                               next
[16:59:32.941]                             if (!grepl(pattern, name)) 
[16:59:32.941]                               next
[16:59:32.941]                             invokeRestart(restart)
[16:59:32.941]                             muffled <- TRUE
[16:59:32.941]                             break
[16:59:32.941]                           }
[16:59:32.941]                         }
[16:59:32.941]                       }
[16:59:32.941]                       invisible(muffled)
[16:59:32.941]                     }
[16:59:32.941]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.941]                   }
[16:59:32.941]                 }
[16:59:32.941]                 else {
[16:59:32.941]                   if (TRUE) {
[16:59:32.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:32.941]                     {
[16:59:32.941]                       inherits <- base::inherits
[16:59:32.941]                       invokeRestart <- base::invokeRestart
[16:59:32.941]                       is.null <- base::is.null
[16:59:32.941]                       muffled <- FALSE
[16:59:32.941]                       if (inherits(cond, "message")) {
[16:59:32.941]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:32.941]                         if (muffled) 
[16:59:32.941]                           invokeRestart("muffleMessage")
[16:59:32.941]                       }
[16:59:32.941]                       else if (inherits(cond, "warning")) {
[16:59:32.941]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:32.941]                         if (muffled) 
[16:59:32.941]                           invokeRestart("muffleWarning")
[16:59:32.941]                       }
[16:59:32.941]                       else if (inherits(cond, "condition")) {
[16:59:32.941]                         if (!is.null(pattern)) {
[16:59:32.941]                           computeRestarts <- base::computeRestarts
[16:59:32.941]                           grepl <- base::grepl
[16:59:32.941]                           restarts <- computeRestarts(cond)
[16:59:32.941]                           for (restart in restarts) {
[16:59:32.941]                             name <- restart$name
[16:59:32.941]                             if (is.null(name)) 
[16:59:32.941]                               next
[16:59:32.941]                             if (!grepl(pattern, name)) 
[16:59:32.941]                               next
[16:59:32.941]                             invokeRestart(restart)
[16:59:32.941]                             muffled <- TRUE
[16:59:32.941]                             break
[16:59:32.941]                           }
[16:59:32.941]                         }
[16:59:32.941]                       }
[16:59:32.941]                       invisible(muffled)
[16:59:32.941]                     }
[16:59:32.941]                     muffleCondition(cond, pattern = "^muffle")
[16:59:32.941]                   }
[16:59:32.941]                 }
[16:59:32.941]             }
[16:59:32.941]         }))
[16:59:32.941]     }, error = function(ex) {
[16:59:32.941]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:32.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:32.941]                 ...future.rng), started = ...future.startTime, 
[16:59:32.941]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:32.941]             version = "1.8"), class = "FutureResult")
[16:59:32.941]     }, finally = {
[16:59:32.941]         if (!identical(...future.workdir, getwd())) 
[16:59:32.941]             setwd(...future.workdir)
[16:59:32.941]         {
[16:59:32.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:32.941]                 ...future.oldOptions$nwarnings <- NULL
[16:59:32.941]             }
[16:59:32.941]             base::options(...future.oldOptions)
[16:59:32.941]             if (.Platform$OS.type == "windows") {
[16:59:32.941]                 old_names <- names(...future.oldEnvVars)
[16:59:32.941]                 envs <- base::Sys.getenv()
[16:59:32.941]                 names <- names(envs)
[16:59:32.941]                 common <- intersect(names, old_names)
[16:59:32.941]                 added <- setdiff(names, old_names)
[16:59:32.941]                 removed <- setdiff(old_names, names)
[16:59:32.941]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:32.941]                   envs[common]]
[16:59:32.941]                 NAMES <- toupper(changed)
[16:59:32.941]                 args <- list()
[16:59:32.941]                 for (kk in seq_along(NAMES)) {
[16:59:32.941]                   name <- changed[[kk]]
[16:59:32.941]                   NAME <- NAMES[[kk]]
[16:59:32.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.941]                     next
[16:59:32.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.941]                 }
[16:59:32.941]                 NAMES <- toupper(added)
[16:59:32.941]                 for (kk in seq_along(NAMES)) {
[16:59:32.941]                   name <- added[[kk]]
[16:59:32.941]                   NAME <- NAMES[[kk]]
[16:59:32.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.941]                     next
[16:59:32.941]                   args[[name]] <- ""
[16:59:32.941]                 }
[16:59:32.941]                 NAMES <- toupper(removed)
[16:59:32.941]                 for (kk in seq_along(NAMES)) {
[16:59:32.941]                   name <- removed[[kk]]
[16:59:32.941]                   NAME <- NAMES[[kk]]
[16:59:32.941]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:32.941]                     next
[16:59:32.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:32.941]                 }
[16:59:32.941]                 if (length(args) > 0) 
[16:59:32.941]                   base::do.call(base::Sys.setenv, args = args)
[16:59:32.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:32.941]             }
[16:59:32.941]             else {
[16:59:32.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:32.941]             }
[16:59:32.941]             {
[16:59:32.941]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:32.941]                   0L) {
[16:59:32.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:32.941]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:32.941]                   base::options(opts)
[16:59:32.941]                 }
[16:59:32.941]                 {
[16:59:32.941]                   {
[16:59:32.941]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:32.941]                     NULL
[16:59:32.941]                   }
[16:59:32.941]                   options(future.plan = NULL)
[16:59:32.941]                   if (is.na(NA_character_)) 
[16:59:32.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:32.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:32.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:32.941]                     .init = FALSE)
[16:59:32.941]                 }
[16:59:32.941]             }
[16:59:32.941]         }
[16:59:32.941]     })
[16:59:32.941]     if (TRUE) {
[16:59:32.941]         base::sink(type = "output", split = FALSE)
[16:59:32.941]         if (TRUE) {
[16:59:32.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:32.941]         }
[16:59:32.941]         else {
[16:59:32.941]             ...future.result["stdout"] <- base::list(NULL)
[16:59:32.941]         }
[16:59:32.941]         base::close(...future.stdout)
[16:59:32.941]         ...future.stdout <- NULL
[16:59:32.941]     }
[16:59:32.941]     ...future.result$conditions <- ...future.conditions
[16:59:32.941]     ...future.result$finished <- base::Sys.time()
[16:59:32.941]     ...future.result
[16:59:32.941] }
[16:59:32.944] Exporting 5 global objects (960 bytes) to cluster node #2 ...
[16:59:32.944] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:32.944] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.944] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:59:32.945] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:59:32.945] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:59:32.945] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:59:32.945] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:32.946] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:32.946] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:32.946] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:32.946] Exporting 5 global objects (960 bytes) to cluster node #2 ... DONE
[16:59:32.947] MultisessionFuture started
[16:59:32.947] - Launch lazy future ... done
[16:59:32.947] run() for ‘MultisessionFuture’ ... done
[16:59:32.947] Created future:
[16:59:32.947] MultisessionFuture:
[16:59:32.947] Label: ‘future_apply-2’
[16:59:32.947] Expression:
[16:59:32.947] {
[16:59:32.947]     do.call(function(...) {
[16:59:32.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:32.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:32.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:32.947]             on.exit(options(oopts), add = TRUE)
[16:59:32.947]         }
[16:59:32.947]         {
[16:59:32.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:32.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:32.947]                 ...future.FUN(...future.X_jj, ...)
[16:59:32.947]             })
[16:59:32.947]         }
[16:59:32.947]     }, args = future.call.arguments)
[16:59:32.947] }
[16:59:32.947] Lazy evaluation: FALSE
[16:59:32.947] Asynchronous evaluation: TRUE
[16:59:32.947] Local evaluation: TRUE
[16:59:32.947] Environment: R_GlobalEnv
[16:59:32.947] Capture standard output: TRUE
[16:59:32.947] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:32.947] Globals: 5 objects totaling 960 bytes (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:32.947] Packages: <none>
[16:59:32.947] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:32.947] Resolved: FALSE
[16:59:32.947] Value: <not collected>
[16:59:32.947] Conditions captured: <none>
[16:59:32.947] Early signaling: FALSE
[16:59:32.947] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:32.947] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:32.959] Chunk #2 of 2 ... DONE
[16:59:32.959] Launching 2 futures (chunks) ... DONE
[16:59:32.959] Resolving 2 futures (chunks) ...
[16:59:32.959] resolve() on list ...
[16:59:32.959]  recursive: 0
[16:59:32.959]  length: 2
[16:59:32.959] 
[16:59:32.960] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.960] - Validating connection of MultisessionFuture
[16:59:32.960] - received message: FutureResult
[16:59:32.960] - Received FutureResult
[16:59:32.961] - Erased future from FutureRegistry
[16:59:32.961] result() for ClusterFuture ...
[16:59:32.961] - result already collected: FutureResult
[16:59:32.961] result() for ClusterFuture ... done
[16:59:32.961] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.961] Future #1
[16:59:32.961] result() for ClusterFuture ...
[16:59:32.961] - result already collected: FutureResult
[16:59:32.961] result() for ClusterFuture ... done
[16:59:32.961] result() for ClusterFuture ...
[16:59:32.961] - result already collected: FutureResult
[16:59:32.961] result() for ClusterFuture ... done
[16:59:32.962] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:32.962] - nx: 2
[16:59:32.962] - relay: TRUE
[16:59:32.962] - stdout: TRUE
[16:59:32.962] - signal: TRUE
[16:59:32.962] - resignal: FALSE
[16:59:32.962] - force: TRUE
[16:59:32.962] - relayed: [n=2] FALSE, FALSE
[16:59:32.962] - queued futures: [n=2] FALSE, FALSE
[16:59:32.962]  - until=1
[16:59:32.962]  - relaying element #1
[16:59:32.963] result() for ClusterFuture ...
[16:59:32.963] - result already collected: FutureResult
[16:59:32.963] result() for ClusterFuture ... done
[16:59:32.963] result() for ClusterFuture ...
[16:59:32.963] - result already collected: FutureResult
[16:59:32.963] result() for ClusterFuture ... done
[16:59:32.963] result() for ClusterFuture ...
[16:59:32.963] - result already collected: FutureResult
[16:59:32.963] result() for ClusterFuture ... done
[16:59:32.963] result() for ClusterFuture ...
[16:59:32.963] - result already collected: FutureResult
[16:59:32.964] result() for ClusterFuture ... done
[16:59:32.964] - relayed: [n=2] TRUE, FALSE
[16:59:32.964] - queued futures: [n=2] TRUE, FALSE
[16:59:32.964] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:32.964]  length: 1 (resolved future 1)
[16:59:32.989] receiveMessageFromWorker() for ClusterFuture ...
[16:59:32.989] - Validating connection of MultisessionFuture
[16:59:32.989] - received message: FutureResult
[16:59:32.990] - Received FutureResult
[16:59:32.990] - Erased future from FutureRegistry
[16:59:32.990] result() for ClusterFuture ...
[16:59:32.990] - result already collected: FutureResult
[16:59:32.990] result() for ClusterFuture ... done
[16:59:32.990] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:32.990] Future #2
[16:59:32.990] result() for ClusterFuture ...
[16:59:32.990] - result already collected: FutureResult
[16:59:32.990] result() for ClusterFuture ... done
[16:59:32.990] result() for ClusterFuture ...
[16:59:32.991] - result already collected: FutureResult
[16:59:32.991] result() for ClusterFuture ... done
[16:59:32.991] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:32.991] - nx: 2
[16:59:32.991] - relay: TRUE
[16:59:32.991] - stdout: TRUE
[16:59:32.991] - signal: TRUE
[16:59:32.991] - resignal: FALSE
[16:59:32.991] - force: TRUE
[16:59:32.991] - relayed: [n=2] TRUE, FALSE
[16:59:32.991] - queued futures: [n=2] TRUE, FALSE
[16:59:32.992]  - until=2
[16:59:32.992]  - relaying element #2
[16:59:32.992] result() for ClusterFuture ...
[16:59:32.992] - result already collected: FutureResult
[16:59:32.992] result() for ClusterFuture ... done
[16:59:32.992] result() for ClusterFuture ...
[16:59:32.992] - result already collected: FutureResult
[16:59:32.992] result() for ClusterFuture ... done
[16:59:32.992] result() for ClusterFuture ...
[16:59:32.992] - result already collected: FutureResult
[16:59:32.992] result() for ClusterFuture ... done
[16:59:32.992] result() for ClusterFuture ...
[16:59:32.993] - result already collected: FutureResult
[16:59:32.993] result() for ClusterFuture ... done
[16:59:32.993] - relayed: [n=2] TRUE, TRUE
[16:59:32.993] - queued futures: [n=2] TRUE, TRUE
[16:59:32.993] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:32.993]  length: 0 (resolved future 2)
[16:59:32.993] Relaying remaining futures
[16:59:32.993] signalConditionsASAP(NULL, pos=0) ...
[16:59:32.993] - nx: 2
[16:59:32.993] - relay: TRUE
[16:59:32.993] - stdout: TRUE
[16:59:32.993] - signal: TRUE
[16:59:32.994] - resignal: FALSE
[16:59:32.994] - force: TRUE
[16:59:32.994] - relayed: [n=2] TRUE, TRUE
[16:59:32.994] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:32.994] - relayed: [n=2] TRUE, TRUE
[16:59:32.994] - queued futures: [n=2] TRUE, TRUE
[16:59:32.994] signalConditionsASAP(NULL, pos=0) ... done
[16:59:32.994] resolve() on list ... DONE
[16:59:32.994] result() for ClusterFuture ...
[16:59:32.994] - result already collected: FutureResult
[16:59:32.994] result() for ClusterFuture ... done
[16:59:32.995] result() for ClusterFuture ...
[16:59:32.995] - result already collected: FutureResult
[16:59:32.995] result() for ClusterFuture ... done
[16:59:32.995] result() for ClusterFuture ...
[16:59:32.995] - result already collected: FutureResult
[16:59:32.995] result() for ClusterFuture ... done
[16:59:32.995] result() for ClusterFuture ...
[16:59:32.995] - result already collected: FutureResult
[16:59:32.995] result() for ClusterFuture ... done
[16:59:32.995]  - Number of value chunks collected: 2
[16:59:32.996] Resolving 2 futures (chunks) ... DONE
[16:59:32.996] Reducing values from 2 chunks ...
[16:59:32.996]  - Number of values collected after concatenation: 2
[16:59:32.996]  - Number of values expected: 2
[16:59:32.996] Reducing values from 2 chunks ... DONE
[16:59:32.996] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[16:59:32.996] getGlobalsAndPackagesXApply() ...
[16:59:32.996]  - future.globals: TRUE
[16:59:32.996] getGlobalsAndPackages() ...
[16:59:32.997] Searching for globals...
[16:59:32.998] - globals found: [1] ‘FUN’
[16:59:32.998] Searching for globals ... DONE
[16:59:32.998] Resolving globals: FALSE
[16:59:32.998] The total size of the 1 globals is 848 bytes (848 bytes)
[16:59:32.998] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 848 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (848 bytes of class ‘function’)
[16:59:32.999] - globals: [1] ‘FUN’
[16:59:32.999] 
[16:59:32.999] getGlobalsAndPackages() ... DONE
[16:59:32.999]  - globals found/used: [n=1] ‘FUN’
[16:59:32.999]  - needed namespaces: [n=0] 
[16:59:32.999] Finding globals ... DONE
[16:59:32.999]  - use_args: TRUE
[16:59:32.999]  - Getting '...' globals ...
[16:59:33.000] resolve() on list ...
[16:59:33.000]  recursive: 0
[16:59:33.000]  length: 1
[16:59:33.000]  elements: ‘...’
[16:59:33.000]  length: 0 (resolved future 1)
[16:59:33.000] resolve() on list ... DONE
[16:59:33.000]    - '...' content: [n=0] 
[16:59:33.000] List of 1
[16:59:33.000]  $ ...: list()
[16:59:33.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.000]  - attr(*, "where")=List of 1
[16:59:33.000]   ..$ ...:<environment: 0x55f3158eea58> 
[16:59:33.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.000]  - attr(*, "resolved")= logi TRUE
[16:59:33.000]  - attr(*, "total_size")= num NA
[16:59:33.003]  - Getting '...' globals ... DONE
[16:59:33.003] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:33.003] List of 2
[16:59:33.003]  $ ...future.FUN:function (x)  
[16:59:33.003]  $ ...          : list()
[16:59:33.003]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.003]  - attr(*, "where")=List of 2
[16:59:33.003]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.003]   ..$ ...          :<environment: 0x55f3158eea58> 
[16:59:33.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.003]  - attr(*, "resolved")= logi FALSE
[16:59:33.003]  - attr(*, "total_size")= num 848
[16:59:33.006] Packages to be attached in all futures: [n=0] 
[16:59:33.006] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.009] future_lapply() ...
[16:59:33.013] Number of chunks: 2
[16:59:33.013] getGlobalsAndPackagesXApply() ...
[16:59:33.013]  - future.globals: <name-value list> with names ‘list()’
[16:59:33.013]  - use_args: TRUE
[16:59:33.014] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:33.014] List of 2
[16:59:33.014]  $ ...          : list()
[16:59:33.014]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.014]  $ ...future.FUN:function (x)  
[16:59:33.014]  - attr(*, "where")=List of 2
[16:59:33.014]   ..$ ...          :<environment: 0x55f3158eea58> 
[16:59:33.014]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:33.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.014]  - attr(*, "resolved")= logi FALSE
[16:59:33.014]  - attr(*, "total_size")= num NA
[16:59:33.017] Packages to be attached in all futures: [n=0] 
[16:59:33.017] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.017] Number of futures (= number of chunks): 2
[16:59:33.017] Launching 2 futures (chunks) ...
[16:59:33.017] Chunk #1 of 2 ...
[16:59:33.018]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:33.018]  - seeds: <none>
[16:59:33.018]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.018] getGlobalsAndPackages() ...
[16:59:33.018] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.018] Resolving globals: FALSE
[16:59:33.018] Tweak future expression to call with '...' arguments ...
[16:59:33.018] {
[16:59:33.018]     do.call(function(...) {
[16:59:33.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.018]             on.exit(options(oopts), add = TRUE)
[16:59:33.018]         }
[16:59:33.018]         {
[16:59:33.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.018]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.018]             })
[16:59:33.018]         }
[16:59:33.018]     }, args = future.call.arguments)
[16:59:33.018] }
[16:59:33.019] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.019] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.019] 
[16:59:33.019] getGlobalsAndPackages() ... DONE
[16:59:33.019] run() for ‘Future’ ...
[16:59:33.020] - state: ‘created’
[16:59:33.020] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:33.033] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.033] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:33.033]   - Field: ‘node’
[16:59:33.034]   - Field: ‘label’
[16:59:33.034]   - Field: ‘local’
[16:59:33.034]   - Field: ‘owner’
[16:59:33.034]   - Field: ‘envir’
[16:59:33.034]   - Field: ‘workers’
[16:59:33.034]   - Field: ‘packages’
[16:59:33.036]   - Field: ‘gc’
[16:59:33.036]   - Field: ‘conditions’
[16:59:33.037]   - Field: ‘persistent’
[16:59:33.037]   - Field: ‘expr’
[16:59:33.037]   - Field: ‘uuid’
[16:59:33.037]   - Field: ‘seed’
[16:59:33.037]   - Field: ‘version’
[16:59:33.037]   - Field: ‘result’
[16:59:33.037]   - Field: ‘asynchronous’
[16:59:33.037]   - Field: ‘calls’
[16:59:33.037]   - Field: ‘globals’
[16:59:33.037]   - Field: ‘stdout’
[16:59:33.037]   - Field: ‘earlySignal’
[16:59:33.038]   - Field: ‘lazy’
[16:59:33.038]   - Field: ‘state’
[16:59:33.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:33.038] - Launch lazy future ...
[16:59:33.038] Packages needed by the future expression (n = 0): <none>
[16:59:33.038] Packages needed by future strategies (n = 0): <none>
[16:59:33.039] {
[16:59:33.039]     {
[16:59:33.039]         {
[16:59:33.039]             ...future.startTime <- base::Sys.time()
[16:59:33.039]             {
[16:59:33.039]                 {
[16:59:33.039]                   {
[16:59:33.039]                     {
[16:59:33.039]                       base::local({
[16:59:33.039]                         has_future <- base::requireNamespace("future", 
[16:59:33.039]                           quietly = TRUE)
[16:59:33.039]                         if (has_future) {
[16:59:33.039]                           ns <- base::getNamespace("future")
[16:59:33.039]                           version <- ns[[".package"]][["version"]]
[16:59:33.039]                           if (is.null(version)) 
[16:59:33.039]                             version <- utils::packageVersion("future")
[16:59:33.039]                         }
[16:59:33.039]                         else {
[16:59:33.039]                           version <- NULL
[16:59:33.039]                         }
[16:59:33.039]                         if (!has_future || version < "1.8.0") {
[16:59:33.039]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.039]                             "", base::R.version$version.string), 
[16:59:33.039]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.039]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.039]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.039]                               "release", "version")], collapse = " "), 
[16:59:33.039]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.039]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.039]                             info)
[16:59:33.039]                           info <- base::paste(info, collapse = "; ")
[16:59:33.039]                           if (!has_future) {
[16:59:33.039]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.039]                               info)
[16:59:33.039]                           }
[16:59:33.039]                           else {
[16:59:33.039]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.039]                               info, version)
[16:59:33.039]                           }
[16:59:33.039]                           base::stop(msg)
[16:59:33.039]                         }
[16:59:33.039]                       })
[16:59:33.039]                     }
[16:59:33.039]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:33.039]                     base::options(mc.cores = 1L)
[16:59:33.039]                   }
[16:59:33.039]                   ...future.strategy.old <- future::plan("list")
[16:59:33.039]                   options(future.plan = NULL)
[16:59:33.039]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.039]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.039]                 }
[16:59:33.039]                 ...future.workdir <- getwd()
[16:59:33.039]             }
[16:59:33.039]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.039]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.039]         }
[16:59:33.039]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.039]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:33.039]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.039]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.039]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.039]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.039]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.039]             base::names(...future.oldOptions))
[16:59:33.039]     }
[16:59:33.039]     if (FALSE) {
[16:59:33.039]     }
[16:59:33.039]     else {
[16:59:33.039]         if (TRUE) {
[16:59:33.039]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.039]                 open = "w")
[16:59:33.039]         }
[16:59:33.039]         else {
[16:59:33.039]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.039]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.039]         }
[16:59:33.039]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.039]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.039]             base::sink(type = "output", split = FALSE)
[16:59:33.039]             base::close(...future.stdout)
[16:59:33.039]         }, add = TRUE)
[16:59:33.039]     }
[16:59:33.039]     ...future.frame <- base::sys.nframe()
[16:59:33.039]     ...future.conditions <- base::list()
[16:59:33.039]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.039]     if (FALSE) {
[16:59:33.039]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.039]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.039]     }
[16:59:33.039]     ...future.result <- base::tryCatch({
[16:59:33.039]         base::withCallingHandlers({
[16:59:33.039]             ...future.value <- base::withVisible(base::local({
[16:59:33.039]                 ...future.makeSendCondition <- base::local({
[16:59:33.039]                   sendCondition <- NULL
[16:59:33.039]                   function(frame = 1L) {
[16:59:33.039]                     if (is.function(sendCondition)) 
[16:59:33.039]                       return(sendCondition)
[16:59:33.039]                     ns <- getNamespace("parallel")
[16:59:33.039]                     if (exists("sendData", mode = "function", 
[16:59:33.039]                       envir = ns)) {
[16:59:33.039]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:33.039]                         envir = ns)
[16:59:33.039]                       envir <- sys.frame(frame)
[16:59:33.039]                       master <- NULL
[16:59:33.039]                       while (!identical(envir, .GlobalEnv) && 
[16:59:33.039]                         !identical(envir, emptyenv())) {
[16:59:33.039]                         if (exists("master", mode = "list", envir = envir, 
[16:59:33.039]                           inherits = FALSE)) {
[16:59:33.039]                           master <- get("master", mode = "list", 
[16:59:33.039]                             envir = envir, inherits = FALSE)
[16:59:33.039]                           if (inherits(master, c("SOCKnode", 
[16:59:33.039]                             "SOCK0node"))) {
[16:59:33.039]                             sendCondition <<- function(cond) {
[16:59:33.039]                               data <- list(type = "VALUE", value = cond, 
[16:59:33.039]                                 success = TRUE)
[16:59:33.039]                               parallel_sendData(master, data)
[16:59:33.039]                             }
[16:59:33.039]                             return(sendCondition)
[16:59:33.039]                           }
[16:59:33.039]                         }
[16:59:33.039]                         frame <- frame + 1L
[16:59:33.039]                         envir <- sys.frame(frame)
[16:59:33.039]                       }
[16:59:33.039]                     }
[16:59:33.039]                     sendCondition <<- function(cond) NULL
[16:59:33.039]                   }
[16:59:33.039]                 })
[16:59:33.039]                 withCallingHandlers({
[16:59:33.039]                   {
[16:59:33.039]                     do.call(function(...) {
[16:59:33.039]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.039]                       if (!identical(...future.globals.maxSize.org, 
[16:59:33.039]                         ...future.globals.maxSize)) {
[16:59:33.039]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.039]                         on.exit(options(oopts), add = TRUE)
[16:59:33.039]                       }
[16:59:33.039]                       {
[16:59:33.039]                         lapply(seq_along(...future.elements_ii), 
[16:59:33.039]                           FUN = function(jj) {
[16:59:33.039]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.039]                             ...future.FUN(...future.X_jj, ...)
[16:59:33.039]                           })
[16:59:33.039]                       }
[16:59:33.039]                     }, args = future.call.arguments)
[16:59:33.039]                   }
[16:59:33.039]                 }, immediateCondition = function(cond) {
[16:59:33.039]                   sendCondition <- ...future.makeSendCondition()
[16:59:33.039]                   sendCondition(cond)
[16:59:33.039]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.039]                   {
[16:59:33.039]                     inherits <- base::inherits
[16:59:33.039]                     invokeRestart <- base::invokeRestart
[16:59:33.039]                     is.null <- base::is.null
[16:59:33.039]                     muffled <- FALSE
[16:59:33.039]                     if (inherits(cond, "message")) {
[16:59:33.039]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:33.039]                       if (muffled) 
[16:59:33.039]                         invokeRestart("muffleMessage")
[16:59:33.039]                     }
[16:59:33.039]                     else if (inherits(cond, "warning")) {
[16:59:33.039]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:33.039]                       if (muffled) 
[16:59:33.039]                         invokeRestart("muffleWarning")
[16:59:33.039]                     }
[16:59:33.039]                     else if (inherits(cond, "condition")) {
[16:59:33.039]                       if (!is.null(pattern)) {
[16:59:33.039]                         computeRestarts <- base::computeRestarts
[16:59:33.039]                         grepl <- base::grepl
[16:59:33.039]                         restarts <- computeRestarts(cond)
[16:59:33.039]                         for (restart in restarts) {
[16:59:33.039]                           name <- restart$name
[16:59:33.039]                           if (is.null(name)) 
[16:59:33.039]                             next
[16:59:33.039]                           if (!grepl(pattern, name)) 
[16:59:33.039]                             next
[16:59:33.039]                           invokeRestart(restart)
[16:59:33.039]                           muffled <- TRUE
[16:59:33.039]                           break
[16:59:33.039]                         }
[16:59:33.039]                       }
[16:59:33.039]                     }
[16:59:33.039]                     invisible(muffled)
[16:59:33.039]                   }
[16:59:33.039]                   muffleCondition(cond)
[16:59:33.039]                 })
[16:59:33.039]             }))
[16:59:33.039]             future::FutureResult(value = ...future.value$value, 
[16:59:33.039]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.039]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.039]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.039]                     ...future.globalenv.names))
[16:59:33.039]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.039]         }, condition = base::local({
[16:59:33.039]             c <- base::c
[16:59:33.039]             inherits <- base::inherits
[16:59:33.039]             invokeRestart <- base::invokeRestart
[16:59:33.039]             length <- base::length
[16:59:33.039]             list <- base::list
[16:59:33.039]             seq.int <- base::seq.int
[16:59:33.039]             signalCondition <- base::signalCondition
[16:59:33.039]             sys.calls <- base::sys.calls
[16:59:33.039]             `[[` <- base::`[[`
[16:59:33.039]             `+` <- base::`+`
[16:59:33.039]             `<<-` <- base::`<<-`
[16:59:33.039]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.039]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.039]                   3L)]
[16:59:33.039]             }
[16:59:33.039]             function(cond) {
[16:59:33.039]                 is_error <- inherits(cond, "error")
[16:59:33.039]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.039]                   NULL)
[16:59:33.039]                 if (is_error) {
[16:59:33.039]                   sessionInformation <- function() {
[16:59:33.039]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.039]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.039]                       search = base::search(), system = base::Sys.info())
[16:59:33.039]                   }
[16:59:33.039]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.039]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.039]                     cond$call), session = sessionInformation(), 
[16:59:33.039]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.039]                   signalCondition(cond)
[16:59:33.039]                 }
[16:59:33.039]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.039]                 "immediateCondition"))) {
[16:59:33.039]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.039]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.039]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.039]                   if (TRUE && !signal) {
[16:59:33.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.039]                     {
[16:59:33.039]                       inherits <- base::inherits
[16:59:33.039]                       invokeRestart <- base::invokeRestart
[16:59:33.039]                       is.null <- base::is.null
[16:59:33.039]                       muffled <- FALSE
[16:59:33.039]                       if (inherits(cond, "message")) {
[16:59:33.039]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.039]                         if (muffled) 
[16:59:33.039]                           invokeRestart("muffleMessage")
[16:59:33.039]                       }
[16:59:33.039]                       else if (inherits(cond, "warning")) {
[16:59:33.039]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.039]                         if (muffled) 
[16:59:33.039]                           invokeRestart("muffleWarning")
[16:59:33.039]                       }
[16:59:33.039]                       else if (inherits(cond, "condition")) {
[16:59:33.039]                         if (!is.null(pattern)) {
[16:59:33.039]                           computeRestarts <- base::computeRestarts
[16:59:33.039]                           grepl <- base::grepl
[16:59:33.039]                           restarts <- computeRestarts(cond)
[16:59:33.039]                           for (restart in restarts) {
[16:59:33.039]                             name <- restart$name
[16:59:33.039]                             if (is.null(name)) 
[16:59:33.039]                               next
[16:59:33.039]                             if (!grepl(pattern, name)) 
[16:59:33.039]                               next
[16:59:33.039]                             invokeRestart(restart)
[16:59:33.039]                             muffled <- TRUE
[16:59:33.039]                             break
[16:59:33.039]                           }
[16:59:33.039]                         }
[16:59:33.039]                       }
[16:59:33.039]                       invisible(muffled)
[16:59:33.039]                     }
[16:59:33.039]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.039]                   }
[16:59:33.039]                 }
[16:59:33.039]                 else {
[16:59:33.039]                   if (TRUE) {
[16:59:33.039]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.039]                     {
[16:59:33.039]                       inherits <- base::inherits
[16:59:33.039]                       invokeRestart <- base::invokeRestart
[16:59:33.039]                       is.null <- base::is.null
[16:59:33.039]                       muffled <- FALSE
[16:59:33.039]                       if (inherits(cond, "message")) {
[16:59:33.039]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.039]                         if (muffled) 
[16:59:33.039]                           invokeRestart("muffleMessage")
[16:59:33.039]                       }
[16:59:33.039]                       else if (inherits(cond, "warning")) {
[16:59:33.039]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.039]                         if (muffled) 
[16:59:33.039]                           invokeRestart("muffleWarning")
[16:59:33.039]                       }
[16:59:33.039]                       else if (inherits(cond, "condition")) {
[16:59:33.039]                         if (!is.null(pattern)) {
[16:59:33.039]                           computeRestarts <- base::computeRestarts
[16:59:33.039]                           grepl <- base::grepl
[16:59:33.039]                           restarts <- computeRestarts(cond)
[16:59:33.039]                           for (restart in restarts) {
[16:59:33.039]                             name <- restart$name
[16:59:33.039]                             if (is.null(name)) 
[16:59:33.039]                               next
[16:59:33.039]                             if (!grepl(pattern, name)) 
[16:59:33.039]                               next
[16:59:33.039]                             invokeRestart(restart)
[16:59:33.039]                             muffled <- TRUE
[16:59:33.039]                             break
[16:59:33.039]                           }
[16:59:33.039]                         }
[16:59:33.039]                       }
[16:59:33.039]                       invisible(muffled)
[16:59:33.039]                     }
[16:59:33.039]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.039]                   }
[16:59:33.039]                 }
[16:59:33.039]             }
[16:59:33.039]         }))
[16:59:33.039]     }, error = function(ex) {
[16:59:33.039]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.039]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.039]                 ...future.rng), started = ...future.startTime, 
[16:59:33.039]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.039]             version = "1.8"), class = "FutureResult")
[16:59:33.039]     }, finally = {
[16:59:33.039]         if (!identical(...future.workdir, getwd())) 
[16:59:33.039]             setwd(...future.workdir)
[16:59:33.039]         {
[16:59:33.039]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.039]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.039]             }
[16:59:33.039]             base::options(...future.oldOptions)
[16:59:33.039]             if (.Platform$OS.type == "windows") {
[16:59:33.039]                 old_names <- names(...future.oldEnvVars)
[16:59:33.039]                 envs <- base::Sys.getenv()
[16:59:33.039]                 names <- names(envs)
[16:59:33.039]                 common <- intersect(names, old_names)
[16:59:33.039]                 added <- setdiff(names, old_names)
[16:59:33.039]                 removed <- setdiff(old_names, names)
[16:59:33.039]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.039]                   envs[common]]
[16:59:33.039]                 NAMES <- toupper(changed)
[16:59:33.039]                 args <- list()
[16:59:33.039]                 for (kk in seq_along(NAMES)) {
[16:59:33.039]                   name <- changed[[kk]]
[16:59:33.039]                   NAME <- NAMES[[kk]]
[16:59:33.039]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.039]                     next
[16:59:33.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.039]                 }
[16:59:33.039]                 NAMES <- toupper(added)
[16:59:33.039]                 for (kk in seq_along(NAMES)) {
[16:59:33.039]                   name <- added[[kk]]
[16:59:33.039]                   NAME <- NAMES[[kk]]
[16:59:33.039]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.039]                     next
[16:59:33.039]                   args[[name]] <- ""
[16:59:33.039]                 }
[16:59:33.039]                 NAMES <- toupper(removed)
[16:59:33.039]                 for (kk in seq_along(NAMES)) {
[16:59:33.039]                   name <- removed[[kk]]
[16:59:33.039]                   NAME <- NAMES[[kk]]
[16:59:33.039]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.039]                     next
[16:59:33.039]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.039]                 }
[16:59:33.039]                 if (length(args) > 0) 
[16:59:33.039]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.039]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.039]             }
[16:59:33.039]             else {
[16:59:33.039]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.039]             }
[16:59:33.039]             {
[16:59:33.039]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.039]                   0L) {
[16:59:33.039]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.039]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.039]                   base::options(opts)
[16:59:33.039]                 }
[16:59:33.039]                 {
[16:59:33.039]                   {
[16:59:33.039]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:33.039]                     NULL
[16:59:33.039]                   }
[16:59:33.039]                   options(future.plan = NULL)
[16:59:33.039]                   if (is.na(NA_character_)) 
[16:59:33.039]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.039]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.039]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.039]                     .init = FALSE)
[16:59:33.039]                 }
[16:59:33.039]             }
[16:59:33.039]         }
[16:59:33.039]     })
[16:59:33.039]     if (TRUE) {
[16:59:33.039]         base::sink(type = "output", split = FALSE)
[16:59:33.039]         if (TRUE) {
[16:59:33.039]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.039]         }
[16:59:33.039]         else {
[16:59:33.039]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.039]         }
[16:59:33.039]         base::close(...future.stdout)
[16:59:33.039]         ...future.stdout <- NULL
[16:59:33.039]     }
[16:59:33.039]     ...future.result$conditions <- ...future.conditions
[16:59:33.039]     ...future.result$finished <- base::Sys.time()
[16:59:33.039]     ...future.result
[16:59:33.039] }
[16:59:33.042] Exporting 5 global objects (1.12 KiB) to cluster node #1 ...
[16:59:33.042] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:33.042] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:33.042] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ...
[16:59:33.043] Exporting ‘...future.FUN’ (848 bytes) to cluster node #1 ... DONE
[16:59:33.043] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ...
[16:59:33.043] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #1 ... DONE
[16:59:33.043] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:33.043] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:33.044] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:33.044] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.044] Exporting 5 global objects (1.12 KiB) to cluster node #1 ... DONE
[16:59:33.044] MultisessionFuture started
[16:59:33.045] - Launch lazy future ... done
[16:59:33.045] run() for ‘MultisessionFuture’ ... done
[16:59:33.045] Created future:
[16:59:33.045] MultisessionFuture:
[16:59:33.045] Label: ‘future_apply-1’
[16:59:33.045] Expression:
[16:59:33.045] {
[16:59:33.045]     do.call(function(...) {
[16:59:33.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.045]             on.exit(options(oopts), add = TRUE)
[16:59:33.045]         }
[16:59:33.045]         {
[16:59:33.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.045]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.045]             })
[16:59:33.045]         }
[16:59:33.045]     }, args = future.call.arguments)
[16:59:33.045] }
[16:59:33.045] Lazy evaluation: FALSE
[16:59:33.045] Asynchronous evaluation: TRUE
[16:59:33.045] Local evaluation: TRUE
[16:59:33.045] Environment: R_GlobalEnv
[16:59:33.045] Capture standard output: TRUE
[16:59:33.045] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.045] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:33.045] Packages: <none>
[16:59:33.045] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.045] Resolved: FALSE
[16:59:33.045] Value: <not collected>
[16:59:33.045] Conditions captured: <none>
[16:59:33.045] Early signaling: FALSE
[16:59:33.045] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:33.045] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.056] Chunk #1 of 2 ... DONE
[16:59:33.057] Chunk #2 of 2 ...
[16:59:33.057]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:33.057]  - seeds: <none>
[16:59:33.057]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.057] getGlobalsAndPackages() ...
[16:59:33.057] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.057] Resolving globals: FALSE
[16:59:33.057] Tweak future expression to call with '...' arguments ...
[16:59:33.057] {
[16:59:33.057]     do.call(function(...) {
[16:59:33.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.057]             on.exit(options(oopts), add = TRUE)
[16:59:33.057]         }
[16:59:33.057]         {
[16:59:33.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.057]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.057]             })
[16:59:33.057]         }
[16:59:33.057]     }, args = future.call.arguments)
[16:59:33.057] }
[16:59:33.058] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.058] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.058] 
[16:59:33.058] getGlobalsAndPackages() ... DONE
[16:59:33.059] run() for ‘Future’ ...
[16:59:33.059] - state: ‘created’
[16:59:33.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:33.073] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:33.073]   - Field: ‘node’
[16:59:33.073]   - Field: ‘label’
[16:59:33.074]   - Field: ‘local’
[16:59:33.074]   - Field: ‘owner’
[16:59:33.074]   - Field: ‘envir’
[16:59:33.074]   - Field: ‘workers’
[16:59:33.074]   - Field: ‘packages’
[16:59:33.074]   - Field: ‘gc’
[16:59:33.074]   - Field: ‘conditions’
[16:59:33.074]   - Field: ‘persistent’
[16:59:33.074]   - Field: ‘expr’
[16:59:33.074]   - Field: ‘uuid’
[16:59:33.074]   - Field: ‘seed’
[16:59:33.074]   - Field: ‘version’
[16:59:33.075]   - Field: ‘result’
[16:59:33.075]   - Field: ‘asynchronous’
[16:59:33.075]   - Field: ‘calls’
[16:59:33.075]   - Field: ‘globals’
[16:59:33.075]   - Field: ‘stdout’
[16:59:33.075]   - Field: ‘earlySignal’
[16:59:33.075]   - Field: ‘lazy’
[16:59:33.075]   - Field: ‘state’
[16:59:33.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:33.075] - Launch lazy future ...
[16:59:33.076] Packages needed by the future expression (n = 0): <none>
[16:59:33.076] Packages needed by future strategies (n = 0): <none>
[16:59:33.076] {
[16:59:33.076]     {
[16:59:33.076]         {
[16:59:33.076]             ...future.startTime <- base::Sys.time()
[16:59:33.076]             {
[16:59:33.076]                 {
[16:59:33.076]                   {
[16:59:33.076]                     {
[16:59:33.076]                       base::local({
[16:59:33.076]                         has_future <- base::requireNamespace("future", 
[16:59:33.076]                           quietly = TRUE)
[16:59:33.076]                         if (has_future) {
[16:59:33.076]                           ns <- base::getNamespace("future")
[16:59:33.076]                           version <- ns[[".package"]][["version"]]
[16:59:33.076]                           if (is.null(version)) 
[16:59:33.076]                             version <- utils::packageVersion("future")
[16:59:33.076]                         }
[16:59:33.076]                         else {
[16:59:33.076]                           version <- NULL
[16:59:33.076]                         }
[16:59:33.076]                         if (!has_future || version < "1.8.0") {
[16:59:33.076]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.076]                             "", base::R.version$version.string), 
[16:59:33.076]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.076]                               "release", "version")], collapse = " "), 
[16:59:33.076]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.076]                             info)
[16:59:33.076]                           info <- base::paste(info, collapse = "; ")
[16:59:33.076]                           if (!has_future) {
[16:59:33.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.076]                               info)
[16:59:33.076]                           }
[16:59:33.076]                           else {
[16:59:33.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.076]                               info, version)
[16:59:33.076]                           }
[16:59:33.076]                           base::stop(msg)
[16:59:33.076]                         }
[16:59:33.076]                       })
[16:59:33.076]                     }
[16:59:33.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:33.076]                     base::options(mc.cores = 1L)
[16:59:33.076]                   }
[16:59:33.076]                   ...future.strategy.old <- future::plan("list")
[16:59:33.076]                   options(future.plan = NULL)
[16:59:33.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.076]                 }
[16:59:33.076]                 ...future.workdir <- getwd()
[16:59:33.076]             }
[16:59:33.076]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.076]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.076]         }
[16:59:33.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.076]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:33.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.076]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.076]             base::names(...future.oldOptions))
[16:59:33.076]     }
[16:59:33.076]     if (FALSE) {
[16:59:33.076]     }
[16:59:33.076]     else {
[16:59:33.076]         if (TRUE) {
[16:59:33.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.076]                 open = "w")
[16:59:33.076]         }
[16:59:33.076]         else {
[16:59:33.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.076]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.076]         }
[16:59:33.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.076]             base::sink(type = "output", split = FALSE)
[16:59:33.076]             base::close(...future.stdout)
[16:59:33.076]         }, add = TRUE)
[16:59:33.076]     }
[16:59:33.076]     ...future.frame <- base::sys.nframe()
[16:59:33.076]     ...future.conditions <- base::list()
[16:59:33.076]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.076]     if (FALSE) {
[16:59:33.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.076]     }
[16:59:33.076]     ...future.result <- base::tryCatch({
[16:59:33.076]         base::withCallingHandlers({
[16:59:33.076]             ...future.value <- base::withVisible(base::local({
[16:59:33.076]                 ...future.makeSendCondition <- base::local({
[16:59:33.076]                   sendCondition <- NULL
[16:59:33.076]                   function(frame = 1L) {
[16:59:33.076]                     if (is.function(sendCondition)) 
[16:59:33.076]                       return(sendCondition)
[16:59:33.076]                     ns <- getNamespace("parallel")
[16:59:33.076]                     if (exists("sendData", mode = "function", 
[16:59:33.076]                       envir = ns)) {
[16:59:33.076]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:33.076]                         envir = ns)
[16:59:33.076]                       envir <- sys.frame(frame)
[16:59:33.076]                       master <- NULL
[16:59:33.076]                       while (!identical(envir, .GlobalEnv) && 
[16:59:33.076]                         !identical(envir, emptyenv())) {
[16:59:33.076]                         if (exists("master", mode = "list", envir = envir, 
[16:59:33.076]                           inherits = FALSE)) {
[16:59:33.076]                           master <- get("master", mode = "list", 
[16:59:33.076]                             envir = envir, inherits = FALSE)
[16:59:33.076]                           if (inherits(master, c("SOCKnode", 
[16:59:33.076]                             "SOCK0node"))) {
[16:59:33.076]                             sendCondition <<- function(cond) {
[16:59:33.076]                               data <- list(type = "VALUE", value = cond, 
[16:59:33.076]                                 success = TRUE)
[16:59:33.076]                               parallel_sendData(master, data)
[16:59:33.076]                             }
[16:59:33.076]                             return(sendCondition)
[16:59:33.076]                           }
[16:59:33.076]                         }
[16:59:33.076]                         frame <- frame + 1L
[16:59:33.076]                         envir <- sys.frame(frame)
[16:59:33.076]                       }
[16:59:33.076]                     }
[16:59:33.076]                     sendCondition <<- function(cond) NULL
[16:59:33.076]                   }
[16:59:33.076]                 })
[16:59:33.076]                 withCallingHandlers({
[16:59:33.076]                   {
[16:59:33.076]                     do.call(function(...) {
[16:59:33.076]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.076]                       if (!identical(...future.globals.maxSize.org, 
[16:59:33.076]                         ...future.globals.maxSize)) {
[16:59:33.076]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.076]                         on.exit(options(oopts), add = TRUE)
[16:59:33.076]                       }
[16:59:33.076]                       {
[16:59:33.076]                         lapply(seq_along(...future.elements_ii), 
[16:59:33.076]                           FUN = function(jj) {
[16:59:33.076]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.076]                             ...future.FUN(...future.X_jj, ...)
[16:59:33.076]                           })
[16:59:33.076]                       }
[16:59:33.076]                     }, args = future.call.arguments)
[16:59:33.076]                   }
[16:59:33.076]                 }, immediateCondition = function(cond) {
[16:59:33.076]                   sendCondition <- ...future.makeSendCondition()
[16:59:33.076]                   sendCondition(cond)
[16:59:33.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.076]                   {
[16:59:33.076]                     inherits <- base::inherits
[16:59:33.076]                     invokeRestart <- base::invokeRestart
[16:59:33.076]                     is.null <- base::is.null
[16:59:33.076]                     muffled <- FALSE
[16:59:33.076]                     if (inherits(cond, "message")) {
[16:59:33.076]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:33.076]                       if (muffled) 
[16:59:33.076]                         invokeRestart("muffleMessage")
[16:59:33.076]                     }
[16:59:33.076]                     else if (inherits(cond, "warning")) {
[16:59:33.076]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:33.076]                       if (muffled) 
[16:59:33.076]                         invokeRestart("muffleWarning")
[16:59:33.076]                     }
[16:59:33.076]                     else if (inherits(cond, "condition")) {
[16:59:33.076]                       if (!is.null(pattern)) {
[16:59:33.076]                         computeRestarts <- base::computeRestarts
[16:59:33.076]                         grepl <- base::grepl
[16:59:33.076]                         restarts <- computeRestarts(cond)
[16:59:33.076]                         for (restart in restarts) {
[16:59:33.076]                           name <- restart$name
[16:59:33.076]                           if (is.null(name)) 
[16:59:33.076]                             next
[16:59:33.076]                           if (!grepl(pattern, name)) 
[16:59:33.076]                             next
[16:59:33.076]                           invokeRestart(restart)
[16:59:33.076]                           muffled <- TRUE
[16:59:33.076]                           break
[16:59:33.076]                         }
[16:59:33.076]                       }
[16:59:33.076]                     }
[16:59:33.076]                     invisible(muffled)
[16:59:33.076]                   }
[16:59:33.076]                   muffleCondition(cond)
[16:59:33.076]                 })
[16:59:33.076]             }))
[16:59:33.076]             future::FutureResult(value = ...future.value$value, 
[16:59:33.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.076]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.076]                     ...future.globalenv.names))
[16:59:33.076]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.076]         }, condition = base::local({
[16:59:33.076]             c <- base::c
[16:59:33.076]             inherits <- base::inherits
[16:59:33.076]             invokeRestart <- base::invokeRestart
[16:59:33.076]             length <- base::length
[16:59:33.076]             list <- base::list
[16:59:33.076]             seq.int <- base::seq.int
[16:59:33.076]             signalCondition <- base::signalCondition
[16:59:33.076]             sys.calls <- base::sys.calls
[16:59:33.076]             `[[` <- base::`[[`
[16:59:33.076]             `+` <- base::`+`
[16:59:33.076]             `<<-` <- base::`<<-`
[16:59:33.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.076]                   3L)]
[16:59:33.076]             }
[16:59:33.076]             function(cond) {
[16:59:33.076]                 is_error <- inherits(cond, "error")
[16:59:33.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.076]                   NULL)
[16:59:33.076]                 if (is_error) {
[16:59:33.076]                   sessionInformation <- function() {
[16:59:33.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.076]                       search = base::search(), system = base::Sys.info())
[16:59:33.076]                   }
[16:59:33.076]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.076]                     cond$call), session = sessionInformation(), 
[16:59:33.076]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.076]                   signalCondition(cond)
[16:59:33.076]                 }
[16:59:33.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.076]                 "immediateCondition"))) {
[16:59:33.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.076]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.076]                   if (TRUE && !signal) {
[16:59:33.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.076]                     {
[16:59:33.076]                       inherits <- base::inherits
[16:59:33.076]                       invokeRestart <- base::invokeRestart
[16:59:33.076]                       is.null <- base::is.null
[16:59:33.076]                       muffled <- FALSE
[16:59:33.076]                       if (inherits(cond, "message")) {
[16:59:33.076]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.076]                         if (muffled) 
[16:59:33.076]                           invokeRestart("muffleMessage")
[16:59:33.076]                       }
[16:59:33.076]                       else if (inherits(cond, "warning")) {
[16:59:33.076]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.076]                         if (muffled) 
[16:59:33.076]                           invokeRestart("muffleWarning")
[16:59:33.076]                       }
[16:59:33.076]                       else if (inherits(cond, "condition")) {
[16:59:33.076]                         if (!is.null(pattern)) {
[16:59:33.076]                           computeRestarts <- base::computeRestarts
[16:59:33.076]                           grepl <- base::grepl
[16:59:33.076]                           restarts <- computeRestarts(cond)
[16:59:33.076]                           for (restart in restarts) {
[16:59:33.076]                             name <- restart$name
[16:59:33.076]                             if (is.null(name)) 
[16:59:33.076]                               next
[16:59:33.076]                             if (!grepl(pattern, name)) 
[16:59:33.076]                               next
[16:59:33.076]                             invokeRestart(restart)
[16:59:33.076]                             muffled <- TRUE
[16:59:33.076]                             break
[16:59:33.076]                           }
[16:59:33.076]                         }
[16:59:33.076]                       }
[16:59:33.076]                       invisible(muffled)
[16:59:33.076]                     }
[16:59:33.076]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.076]                   }
[16:59:33.076]                 }
[16:59:33.076]                 else {
[16:59:33.076]                   if (TRUE) {
[16:59:33.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.076]                     {
[16:59:33.076]                       inherits <- base::inherits
[16:59:33.076]                       invokeRestart <- base::invokeRestart
[16:59:33.076]                       is.null <- base::is.null
[16:59:33.076]                       muffled <- FALSE
[16:59:33.076]                       if (inherits(cond, "message")) {
[16:59:33.076]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.076]                         if (muffled) 
[16:59:33.076]                           invokeRestart("muffleMessage")
[16:59:33.076]                       }
[16:59:33.076]                       else if (inherits(cond, "warning")) {
[16:59:33.076]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.076]                         if (muffled) 
[16:59:33.076]                           invokeRestart("muffleWarning")
[16:59:33.076]                       }
[16:59:33.076]                       else if (inherits(cond, "condition")) {
[16:59:33.076]                         if (!is.null(pattern)) {
[16:59:33.076]                           computeRestarts <- base::computeRestarts
[16:59:33.076]                           grepl <- base::grepl
[16:59:33.076]                           restarts <- computeRestarts(cond)
[16:59:33.076]                           for (restart in restarts) {
[16:59:33.076]                             name <- restart$name
[16:59:33.076]                             if (is.null(name)) 
[16:59:33.076]                               next
[16:59:33.076]                             if (!grepl(pattern, name)) 
[16:59:33.076]                               next
[16:59:33.076]                             invokeRestart(restart)
[16:59:33.076]                             muffled <- TRUE
[16:59:33.076]                             break
[16:59:33.076]                           }
[16:59:33.076]                         }
[16:59:33.076]                       }
[16:59:33.076]                       invisible(muffled)
[16:59:33.076]                     }
[16:59:33.076]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.076]                   }
[16:59:33.076]                 }
[16:59:33.076]             }
[16:59:33.076]         }))
[16:59:33.076]     }, error = function(ex) {
[16:59:33.076]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.076]                 ...future.rng), started = ...future.startTime, 
[16:59:33.076]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.076]             version = "1.8"), class = "FutureResult")
[16:59:33.076]     }, finally = {
[16:59:33.076]         if (!identical(...future.workdir, getwd())) 
[16:59:33.076]             setwd(...future.workdir)
[16:59:33.076]         {
[16:59:33.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.076]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.076]             }
[16:59:33.076]             base::options(...future.oldOptions)
[16:59:33.076]             if (.Platform$OS.type == "windows") {
[16:59:33.076]                 old_names <- names(...future.oldEnvVars)
[16:59:33.076]                 envs <- base::Sys.getenv()
[16:59:33.076]                 names <- names(envs)
[16:59:33.076]                 common <- intersect(names, old_names)
[16:59:33.076]                 added <- setdiff(names, old_names)
[16:59:33.076]                 removed <- setdiff(old_names, names)
[16:59:33.076]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.076]                   envs[common]]
[16:59:33.076]                 NAMES <- toupper(changed)
[16:59:33.076]                 args <- list()
[16:59:33.076]                 for (kk in seq_along(NAMES)) {
[16:59:33.076]                   name <- changed[[kk]]
[16:59:33.076]                   NAME <- NAMES[[kk]]
[16:59:33.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.076]                     next
[16:59:33.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.076]                 }
[16:59:33.076]                 NAMES <- toupper(added)
[16:59:33.076]                 for (kk in seq_along(NAMES)) {
[16:59:33.076]                   name <- added[[kk]]
[16:59:33.076]                   NAME <- NAMES[[kk]]
[16:59:33.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.076]                     next
[16:59:33.076]                   args[[name]] <- ""
[16:59:33.076]                 }
[16:59:33.076]                 NAMES <- toupper(removed)
[16:59:33.076]                 for (kk in seq_along(NAMES)) {
[16:59:33.076]                   name <- removed[[kk]]
[16:59:33.076]                   NAME <- NAMES[[kk]]
[16:59:33.076]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.076]                     next
[16:59:33.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.076]                 }
[16:59:33.076]                 if (length(args) > 0) 
[16:59:33.076]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.076]             }
[16:59:33.076]             else {
[16:59:33.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.076]             }
[16:59:33.076]             {
[16:59:33.076]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.076]                   0L) {
[16:59:33.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.076]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.076]                   base::options(opts)
[16:59:33.076]                 }
[16:59:33.076]                 {
[16:59:33.076]                   {
[16:59:33.076]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:33.076]                     NULL
[16:59:33.076]                   }
[16:59:33.076]                   options(future.plan = NULL)
[16:59:33.076]                   if (is.na(NA_character_)) 
[16:59:33.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.076]                     .init = FALSE)
[16:59:33.076]                 }
[16:59:33.076]             }
[16:59:33.076]         }
[16:59:33.076]     })
[16:59:33.076]     if (TRUE) {
[16:59:33.076]         base::sink(type = "output", split = FALSE)
[16:59:33.076]         if (TRUE) {
[16:59:33.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.076]         }
[16:59:33.076]         else {
[16:59:33.076]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.076]         }
[16:59:33.076]         base::close(...future.stdout)
[16:59:33.076]         ...future.stdout <- NULL
[16:59:33.076]     }
[16:59:33.076]     ...future.result$conditions <- ...future.conditions
[16:59:33.076]     ...future.result$finished <- base::Sys.time()
[16:59:33.076]     ...future.result
[16:59:33.076] }
[16:59:33.079] Exporting 5 global objects (1.12 KiB) to cluster node #2 ...
[16:59:33.080] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:33.080] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:33.080] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ...
[16:59:33.080] Exporting ‘...future.FUN’ (848 bytes) to cluster node #2 ... DONE
[16:59:33.081] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ...
[16:59:33.081] Exporting ‘...future.elements_ii’ (248 bytes) to cluster node #2 ... DONE
[16:59:33.081] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:33.081] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:33.081] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:33.082] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:33.082] Exporting 5 global objects (1.12 KiB) to cluster node #2 ... DONE
[16:59:33.082] MultisessionFuture started
[16:59:33.082] - Launch lazy future ... done
[16:59:33.083] run() for ‘MultisessionFuture’ ... done
[16:59:33.083] Created future:
[16:59:33.083] MultisessionFuture:
[16:59:33.083] Label: ‘future_apply-2’
[16:59:33.083] Expression:
[16:59:33.083] {
[16:59:33.083]     do.call(function(...) {
[16:59:33.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.083]             on.exit(options(oopts), add = TRUE)
[16:59:33.083]         }
[16:59:33.083]         {
[16:59:33.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.083]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.083]             })
[16:59:33.083]         }
[16:59:33.083]     }, args = future.call.arguments)
[16:59:33.083] }
[16:59:33.083] Lazy evaluation: FALSE
[16:59:33.083] Asynchronous evaluation: TRUE
[16:59:33.083] Local evaluation: TRUE
[16:59:33.083] Environment: R_GlobalEnv
[16:59:33.083] Capture standard output: TRUE
[16:59:33.083] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.083] Globals: 5 objects totaling 1.12 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 848 bytes, list ‘...future.elements_ii’ of 248 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:33.083] Packages: <none>
[16:59:33.083] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.083] Resolved: FALSE
[16:59:33.083] Value: <not collected>
[16:59:33.083] Conditions captured: <none>
[16:59:33.083] Early signaling: FALSE
[16:59:33.083] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:33.083] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.094] Chunk #2 of 2 ... DONE
[16:59:33.094] Launching 2 futures (chunks) ... DONE
[16:59:33.095] Resolving 2 futures (chunks) ...
[16:59:33.095] resolve() on list ...
[16:59:33.095]  recursive: 0
[16:59:33.095]  length: 2
[16:59:33.095] 
[16:59:33.096] receiveMessageFromWorker() for ClusterFuture ...
[16:59:33.096] - Validating connection of MultisessionFuture
[16:59:33.096] - received message: FutureResult
[16:59:33.096] - Received FutureResult
[16:59:33.096] - Erased future from FutureRegistry
[16:59:33.096] result() for ClusterFuture ...
[16:59:33.096] - result already collected: FutureResult
[16:59:33.096] result() for ClusterFuture ... done
[16:59:33.096] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:33.097] Future #1
[16:59:33.097] result() for ClusterFuture ...
[16:59:33.097] - result already collected: FutureResult
[16:59:33.097] result() for ClusterFuture ... done
[16:59:33.097] result() for ClusterFuture ...
[16:59:33.097] - result already collected: FutureResult
[16:59:33.097] result() for ClusterFuture ... done
[16:59:33.097] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:33.097] - nx: 2
[16:59:33.097] - relay: TRUE
[16:59:33.097] - stdout: TRUE
[16:59:33.097] - signal: TRUE
[16:59:33.098] - resignal: FALSE
[16:59:33.098] - force: TRUE
[16:59:33.098] - relayed: [n=2] FALSE, FALSE
[16:59:33.098] - queued futures: [n=2] FALSE, FALSE
[16:59:33.098]  - until=1
[16:59:33.098]  - relaying element #1
[16:59:33.098] result() for ClusterFuture ...
[16:59:33.098] - result already collected: FutureResult
[16:59:33.098] result() for ClusterFuture ... done
[16:59:33.098] result() for ClusterFuture ...
[16:59:33.098] - result already collected: FutureResult
[16:59:33.098] result() for ClusterFuture ... done
[16:59:33.099] result() for ClusterFuture ...
[16:59:33.099] - result already collected: FutureResult
[16:59:33.099] result() for ClusterFuture ... done
[16:59:33.099] result() for ClusterFuture ...
[16:59:33.099] - result already collected: FutureResult
[16:59:33.099] result() for ClusterFuture ... done
[16:59:33.099] - relayed: [n=2] TRUE, FALSE
[16:59:33.099] - queued futures: [n=2] TRUE, FALSE
[16:59:33.099] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:33.099]  length: 1 (resolved future 1)
[16:59:33.125] receiveMessageFromWorker() for ClusterFuture ...
[16:59:33.125] - Validating connection of MultisessionFuture
[16:59:33.125] - received message: FutureResult
[16:59:33.125] - Received FutureResult
[16:59:33.126] - Erased future from FutureRegistry
[16:59:33.126] result() for ClusterFuture ...
[16:59:33.126] - result already collected: FutureResult
[16:59:33.126] result() for ClusterFuture ... done
[16:59:33.126] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:33.126] Future #2
[16:59:33.126] result() for ClusterFuture ...
[16:59:33.126] - result already collected: FutureResult
[16:59:33.126] result() for ClusterFuture ... done
[16:59:33.126] result() for ClusterFuture ...
[16:59:33.127] - result already collected: FutureResult
[16:59:33.127] result() for ClusterFuture ... done
[16:59:33.127] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:33.127] - nx: 2
[16:59:33.127] - relay: TRUE
[16:59:33.127] - stdout: TRUE
[16:59:33.127] - signal: TRUE
[16:59:33.127] - resignal: FALSE
[16:59:33.127] - force: TRUE
[16:59:33.127] - relayed: [n=2] TRUE, FALSE
[16:59:33.127] - queued futures: [n=2] TRUE, FALSE
[16:59:33.128]  - until=2
[16:59:33.128]  - relaying element #2
[16:59:33.128] result() for ClusterFuture ...
[16:59:33.128] - result already collected: FutureResult
[16:59:33.128] result() for ClusterFuture ... done
[16:59:33.128] result() for ClusterFuture ...
[16:59:33.128] - result already collected: FutureResult
[16:59:33.128] result() for ClusterFuture ... done
[16:59:33.128] result() for ClusterFuture ...
[16:59:33.128] - result already collected: FutureResult
[16:59:33.128] result() for ClusterFuture ... done
[16:59:33.129] result() for ClusterFuture ...
[16:59:33.129] - result already collected: FutureResult
[16:59:33.129] result() for ClusterFuture ... done
[16:59:33.129] - relayed: [n=2] TRUE, TRUE
[16:59:33.129] - queued futures: [n=2] TRUE, TRUE
[16:59:33.129] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:33.129]  length: 0 (resolved future 2)
[16:59:33.129] Relaying remaining futures
[16:59:33.129] signalConditionsASAP(NULL, pos=0) ...
[16:59:33.129] - nx: 2
[16:59:33.129] - relay: TRUE
[16:59:33.129] - stdout: TRUE
[16:59:33.130] - signal: TRUE
[16:59:33.130] - resignal: FALSE
[16:59:33.130] - force: TRUE
[16:59:33.130] - relayed: [n=2] TRUE, TRUE
[16:59:33.130] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:33.130] - relayed: [n=2] TRUE, TRUE
[16:59:33.130] - queued futures: [n=2] TRUE, TRUE
[16:59:33.130] signalConditionsASAP(NULL, pos=0) ... done
[16:59:33.130] resolve() on list ... DONE
[16:59:33.130] result() for ClusterFuture ...
[16:59:33.130] - result already collected: FutureResult
[16:59:33.130] result() for ClusterFuture ... done
[16:59:33.131] result() for ClusterFuture ...
[16:59:33.131] - result already collected: FutureResult
[16:59:33.131] result() for ClusterFuture ... done
[16:59:33.131] result() for ClusterFuture ...
[16:59:33.131] - result already collected: FutureResult
[16:59:33.131] result() for ClusterFuture ... done
[16:59:33.131] result() for ClusterFuture ...
[16:59:33.131] - result already collected: FutureResult
[16:59:33.131] result() for ClusterFuture ... done
[16:59:33.131]  - Number of value chunks collected: 2
[16:59:33.131] Resolving 2 futures (chunks) ... DONE
[16:59:33.132] Reducing values from 2 chunks ...
[16:59:33.132]  - Number of values collected after concatenation: 2
[16:59:33.132]  - Number of values expected: 2
[16:59:33.132] Reducing values from 2 chunks ... DONE
[16:59:33.132] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[16:59:33.132] getGlobalsAndPackagesXApply() ...
[16:59:33.132]  - future.globals: TRUE
[16:59:33.132] getGlobalsAndPackages() ...
[16:59:33.133] Searching for globals...
[16:59:33.135] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[16:59:33.135] Searching for globals ... DONE
[16:59:33.135] Resolving globals: FALSE
[16:59:33.136] The total size of the 1 globals is 9.66 KiB (9888 bytes)
[16:59:33.136] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 9.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (9.66 KiB of class ‘function’)
[16:59:33.136] - globals: [1] ‘FUN’
[16:59:33.136] 
[16:59:33.136] getGlobalsAndPackages() ... DONE
[16:59:33.137]  - globals found/used: [n=1] ‘FUN’
[16:59:33.137]  - needed namespaces: [n=0] 
[16:59:33.137] Finding globals ... DONE
[16:59:33.137]  - use_args: TRUE
[16:59:33.137]  - Getting '...' globals ...
[16:59:33.137] resolve() on list ...
[16:59:33.137]  recursive: 0
[16:59:33.137]  length: 1
[16:59:33.138]  elements: ‘...’
[16:59:33.138]  length: 0 (resolved future 1)
[16:59:33.138] resolve() on list ... DONE
[16:59:33.138]    - '...' content: [n=0] 
[16:59:33.138] List of 1
[16:59:33.138]  $ ...: list()
[16:59:33.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.138]  - attr(*, "where")=List of 1
[16:59:33.138]   ..$ ...:<environment: 0x55f315184130> 
[16:59:33.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.138]  - attr(*, "resolved")= logi TRUE
[16:59:33.138]  - attr(*, "total_size")= num NA
[16:59:33.140]  - Getting '...' globals ... DONE
[16:59:33.141] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:33.141] List of 2
[16:59:33.141]  $ ...future.FUN:function (x)  
[16:59:33.141]  $ ...          : list()
[16:59:33.141]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.141]  - attr(*, "where")=List of 2
[16:59:33.141]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.141]   ..$ ...          :<environment: 0x55f315184130> 
[16:59:33.141]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.141]  - attr(*, "resolved")= logi FALSE
[16:59:33.141]  - attr(*, "total_size")= num 9888
[16:59:33.143] Packages to be attached in all futures: [n=0] 
[16:59:33.143] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.147] future_lapply() ...
[16:59:33.152] Number of chunks: 2
[16:59:33.152] getGlobalsAndPackagesXApply() ...
[16:59:33.152]  - future.globals: <name-value list> with names ‘list()’
[16:59:33.152]  - use_args: TRUE
[16:59:33.152] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:33.152] List of 2
[16:59:33.152]  $ ...          : list()
[16:59:33.152]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.152]  $ ...future.FUN:function (x)  
[16:59:33.152]  - attr(*, "where")=List of 2
[16:59:33.152]   ..$ ...          :<environment: 0x55f315184130> 
[16:59:33.152]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[16:59:33.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.152]  - attr(*, "resolved")= logi FALSE
[16:59:33.152]  - attr(*, "total_size")= num NA
[16:59:33.155] Packages to be attached in all futures: [n=0] 
[16:59:33.155] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.155] Number of futures (= number of chunks): 2
[16:59:33.155] Launching 2 futures (chunks) ...
[16:59:33.156] Chunk #1 of 2 ...
[16:59:33.156]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:33.156]  - seeds: <none>
[16:59:33.156]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.156] getGlobalsAndPackages() ...
[16:59:33.156] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.156] Resolving globals: FALSE
[16:59:33.156] Tweak future expression to call with '...' arguments ...
[16:59:33.156] {
[16:59:33.156]     do.call(function(...) {
[16:59:33.156]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.156]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.156]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.156]             on.exit(options(oopts), add = TRUE)
[16:59:33.156]         }
[16:59:33.156]         {
[16:59:33.156]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.156]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.156]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.156]             })
[16:59:33.156]         }
[16:59:33.156]     }, args = future.call.arguments)
[16:59:33.156] }
[16:59:33.157] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.157] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.157] 
[16:59:33.157] getGlobalsAndPackages() ... DONE
[16:59:33.158] run() for ‘Future’ ...
[16:59:33.158] - state: ‘created’
[16:59:33.158] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:33.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:33.172]   - Field: ‘node’
[16:59:33.172]   - Field: ‘label’
[16:59:33.172]   - Field: ‘local’
[16:59:33.172]   - Field: ‘owner’
[16:59:33.172]   - Field: ‘envir’
[16:59:33.172]   - Field: ‘workers’
[16:59:33.172]   - Field: ‘packages’
[16:59:33.172]   - Field: ‘gc’
[16:59:33.173]   - Field: ‘conditions’
[16:59:33.173]   - Field: ‘persistent’
[16:59:33.173]   - Field: ‘expr’
[16:59:33.173]   - Field: ‘uuid’
[16:59:33.173]   - Field: ‘seed’
[16:59:33.173]   - Field: ‘version’
[16:59:33.173]   - Field: ‘result’
[16:59:33.173]   - Field: ‘asynchronous’
[16:59:33.173]   - Field: ‘calls’
[16:59:33.173]   - Field: ‘globals’
[16:59:33.173]   - Field: ‘stdout’
[16:59:33.173]   - Field: ‘earlySignal’
[16:59:33.174]   - Field: ‘lazy’
[16:59:33.174]   - Field: ‘state’
[16:59:33.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:33.174] - Launch lazy future ...
[16:59:33.174] Packages needed by the future expression (n = 0): <none>
[16:59:33.174] Packages needed by future strategies (n = 0): <none>
[16:59:33.175] {
[16:59:33.175]     {
[16:59:33.175]         {
[16:59:33.175]             ...future.startTime <- base::Sys.time()
[16:59:33.175]             {
[16:59:33.175]                 {
[16:59:33.175]                   {
[16:59:33.175]                     {
[16:59:33.175]                       base::local({
[16:59:33.175]                         has_future <- base::requireNamespace("future", 
[16:59:33.175]                           quietly = TRUE)
[16:59:33.175]                         if (has_future) {
[16:59:33.175]                           ns <- base::getNamespace("future")
[16:59:33.175]                           version <- ns[[".package"]][["version"]]
[16:59:33.175]                           if (is.null(version)) 
[16:59:33.175]                             version <- utils::packageVersion("future")
[16:59:33.175]                         }
[16:59:33.175]                         else {
[16:59:33.175]                           version <- NULL
[16:59:33.175]                         }
[16:59:33.175]                         if (!has_future || version < "1.8.0") {
[16:59:33.175]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.175]                             "", base::R.version$version.string), 
[16:59:33.175]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.175]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.175]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.175]                               "release", "version")], collapse = " "), 
[16:59:33.175]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.175]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.175]                             info)
[16:59:33.175]                           info <- base::paste(info, collapse = "; ")
[16:59:33.175]                           if (!has_future) {
[16:59:33.175]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.175]                               info)
[16:59:33.175]                           }
[16:59:33.175]                           else {
[16:59:33.175]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.175]                               info, version)
[16:59:33.175]                           }
[16:59:33.175]                           base::stop(msg)
[16:59:33.175]                         }
[16:59:33.175]                       })
[16:59:33.175]                     }
[16:59:33.175]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:33.175]                     base::options(mc.cores = 1L)
[16:59:33.175]                   }
[16:59:33.175]                   ...future.strategy.old <- future::plan("list")
[16:59:33.175]                   options(future.plan = NULL)
[16:59:33.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.175]                 }
[16:59:33.175]                 ...future.workdir <- getwd()
[16:59:33.175]             }
[16:59:33.175]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.175]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.175]         }
[16:59:33.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.175]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:33.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.175]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.175]             base::names(...future.oldOptions))
[16:59:33.175]     }
[16:59:33.175]     if (FALSE) {
[16:59:33.175]     }
[16:59:33.175]     else {
[16:59:33.175]         if (TRUE) {
[16:59:33.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.175]                 open = "w")
[16:59:33.175]         }
[16:59:33.175]         else {
[16:59:33.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.175]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.175]         }
[16:59:33.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.175]             base::sink(type = "output", split = FALSE)
[16:59:33.175]             base::close(...future.stdout)
[16:59:33.175]         }, add = TRUE)
[16:59:33.175]     }
[16:59:33.175]     ...future.frame <- base::sys.nframe()
[16:59:33.175]     ...future.conditions <- base::list()
[16:59:33.175]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.175]     if (FALSE) {
[16:59:33.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.175]     }
[16:59:33.175]     ...future.result <- base::tryCatch({
[16:59:33.175]         base::withCallingHandlers({
[16:59:33.175]             ...future.value <- base::withVisible(base::local({
[16:59:33.175]                 ...future.makeSendCondition <- base::local({
[16:59:33.175]                   sendCondition <- NULL
[16:59:33.175]                   function(frame = 1L) {
[16:59:33.175]                     if (is.function(sendCondition)) 
[16:59:33.175]                       return(sendCondition)
[16:59:33.175]                     ns <- getNamespace("parallel")
[16:59:33.175]                     if (exists("sendData", mode = "function", 
[16:59:33.175]                       envir = ns)) {
[16:59:33.175]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:33.175]                         envir = ns)
[16:59:33.175]                       envir <- sys.frame(frame)
[16:59:33.175]                       master <- NULL
[16:59:33.175]                       while (!identical(envir, .GlobalEnv) && 
[16:59:33.175]                         !identical(envir, emptyenv())) {
[16:59:33.175]                         if (exists("master", mode = "list", envir = envir, 
[16:59:33.175]                           inherits = FALSE)) {
[16:59:33.175]                           master <- get("master", mode = "list", 
[16:59:33.175]                             envir = envir, inherits = FALSE)
[16:59:33.175]                           if (inherits(master, c("SOCKnode", 
[16:59:33.175]                             "SOCK0node"))) {
[16:59:33.175]                             sendCondition <<- function(cond) {
[16:59:33.175]                               data <- list(type = "VALUE", value = cond, 
[16:59:33.175]                                 success = TRUE)
[16:59:33.175]                               parallel_sendData(master, data)
[16:59:33.175]                             }
[16:59:33.175]                             return(sendCondition)
[16:59:33.175]                           }
[16:59:33.175]                         }
[16:59:33.175]                         frame <- frame + 1L
[16:59:33.175]                         envir <- sys.frame(frame)
[16:59:33.175]                       }
[16:59:33.175]                     }
[16:59:33.175]                     sendCondition <<- function(cond) NULL
[16:59:33.175]                   }
[16:59:33.175]                 })
[16:59:33.175]                 withCallingHandlers({
[16:59:33.175]                   {
[16:59:33.175]                     do.call(function(...) {
[16:59:33.175]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.175]                       if (!identical(...future.globals.maxSize.org, 
[16:59:33.175]                         ...future.globals.maxSize)) {
[16:59:33.175]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.175]                         on.exit(options(oopts), add = TRUE)
[16:59:33.175]                       }
[16:59:33.175]                       {
[16:59:33.175]                         lapply(seq_along(...future.elements_ii), 
[16:59:33.175]                           FUN = function(jj) {
[16:59:33.175]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.175]                             ...future.FUN(...future.X_jj, ...)
[16:59:33.175]                           })
[16:59:33.175]                       }
[16:59:33.175]                     }, args = future.call.arguments)
[16:59:33.175]                   }
[16:59:33.175]                 }, immediateCondition = function(cond) {
[16:59:33.175]                   sendCondition <- ...future.makeSendCondition()
[16:59:33.175]                   sendCondition(cond)
[16:59:33.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.175]                   {
[16:59:33.175]                     inherits <- base::inherits
[16:59:33.175]                     invokeRestart <- base::invokeRestart
[16:59:33.175]                     is.null <- base::is.null
[16:59:33.175]                     muffled <- FALSE
[16:59:33.175]                     if (inherits(cond, "message")) {
[16:59:33.175]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:33.175]                       if (muffled) 
[16:59:33.175]                         invokeRestart("muffleMessage")
[16:59:33.175]                     }
[16:59:33.175]                     else if (inherits(cond, "warning")) {
[16:59:33.175]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:33.175]                       if (muffled) 
[16:59:33.175]                         invokeRestart("muffleWarning")
[16:59:33.175]                     }
[16:59:33.175]                     else if (inherits(cond, "condition")) {
[16:59:33.175]                       if (!is.null(pattern)) {
[16:59:33.175]                         computeRestarts <- base::computeRestarts
[16:59:33.175]                         grepl <- base::grepl
[16:59:33.175]                         restarts <- computeRestarts(cond)
[16:59:33.175]                         for (restart in restarts) {
[16:59:33.175]                           name <- restart$name
[16:59:33.175]                           if (is.null(name)) 
[16:59:33.175]                             next
[16:59:33.175]                           if (!grepl(pattern, name)) 
[16:59:33.175]                             next
[16:59:33.175]                           invokeRestart(restart)
[16:59:33.175]                           muffled <- TRUE
[16:59:33.175]                           break
[16:59:33.175]                         }
[16:59:33.175]                       }
[16:59:33.175]                     }
[16:59:33.175]                     invisible(muffled)
[16:59:33.175]                   }
[16:59:33.175]                   muffleCondition(cond)
[16:59:33.175]                 })
[16:59:33.175]             }))
[16:59:33.175]             future::FutureResult(value = ...future.value$value, 
[16:59:33.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.175]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.175]                     ...future.globalenv.names))
[16:59:33.175]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.175]         }, condition = base::local({
[16:59:33.175]             c <- base::c
[16:59:33.175]             inherits <- base::inherits
[16:59:33.175]             invokeRestart <- base::invokeRestart
[16:59:33.175]             length <- base::length
[16:59:33.175]             list <- base::list
[16:59:33.175]             seq.int <- base::seq.int
[16:59:33.175]             signalCondition <- base::signalCondition
[16:59:33.175]             sys.calls <- base::sys.calls
[16:59:33.175]             `[[` <- base::`[[`
[16:59:33.175]             `+` <- base::`+`
[16:59:33.175]             `<<-` <- base::`<<-`
[16:59:33.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.175]                   3L)]
[16:59:33.175]             }
[16:59:33.175]             function(cond) {
[16:59:33.175]                 is_error <- inherits(cond, "error")
[16:59:33.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.175]                   NULL)
[16:59:33.175]                 if (is_error) {
[16:59:33.175]                   sessionInformation <- function() {
[16:59:33.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.175]                       search = base::search(), system = base::Sys.info())
[16:59:33.175]                   }
[16:59:33.175]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.175]                     cond$call), session = sessionInformation(), 
[16:59:33.175]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.175]                   signalCondition(cond)
[16:59:33.175]                 }
[16:59:33.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.175]                 "immediateCondition"))) {
[16:59:33.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.175]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.175]                   if (TRUE && !signal) {
[16:59:33.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.175]                     {
[16:59:33.175]                       inherits <- base::inherits
[16:59:33.175]                       invokeRestart <- base::invokeRestart
[16:59:33.175]                       is.null <- base::is.null
[16:59:33.175]                       muffled <- FALSE
[16:59:33.175]                       if (inherits(cond, "message")) {
[16:59:33.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.175]                         if (muffled) 
[16:59:33.175]                           invokeRestart("muffleMessage")
[16:59:33.175]                       }
[16:59:33.175]                       else if (inherits(cond, "warning")) {
[16:59:33.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.175]                         if (muffled) 
[16:59:33.175]                           invokeRestart("muffleWarning")
[16:59:33.175]                       }
[16:59:33.175]                       else if (inherits(cond, "condition")) {
[16:59:33.175]                         if (!is.null(pattern)) {
[16:59:33.175]                           computeRestarts <- base::computeRestarts
[16:59:33.175]                           grepl <- base::grepl
[16:59:33.175]                           restarts <- computeRestarts(cond)
[16:59:33.175]                           for (restart in restarts) {
[16:59:33.175]                             name <- restart$name
[16:59:33.175]                             if (is.null(name)) 
[16:59:33.175]                               next
[16:59:33.175]                             if (!grepl(pattern, name)) 
[16:59:33.175]                               next
[16:59:33.175]                             invokeRestart(restart)
[16:59:33.175]                             muffled <- TRUE
[16:59:33.175]                             break
[16:59:33.175]                           }
[16:59:33.175]                         }
[16:59:33.175]                       }
[16:59:33.175]                       invisible(muffled)
[16:59:33.175]                     }
[16:59:33.175]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.175]                   }
[16:59:33.175]                 }
[16:59:33.175]                 else {
[16:59:33.175]                   if (TRUE) {
[16:59:33.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.175]                     {
[16:59:33.175]                       inherits <- base::inherits
[16:59:33.175]                       invokeRestart <- base::invokeRestart
[16:59:33.175]                       is.null <- base::is.null
[16:59:33.175]                       muffled <- FALSE
[16:59:33.175]                       if (inherits(cond, "message")) {
[16:59:33.175]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.175]                         if (muffled) 
[16:59:33.175]                           invokeRestart("muffleMessage")
[16:59:33.175]                       }
[16:59:33.175]                       else if (inherits(cond, "warning")) {
[16:59:33.175]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.175]                         if (muffled) 
[16:59:33.175]                           invokeRestart("muffleWarning")
[16:59:33.175]                       }
[16:59:33.175]                       else if (inherits(cond, "condition")) {
[16:59:33.175]                         if (!is.null(pattern)) {
[16:59:33.175]                           computeRestarts <- base::computeRestarts
[16:59:33.175]                           grepl <- base::grepl
[16:59:33.175]                           restarts <- computeRestarts(cond)
[16:59:33.175]                           for (restart in restarts) {
[16:59:33.175]                             name <- restart$name
[16:59:33.175]                             if (is.null(name)) 
[16:59:33.175]                               next
[16:59:33.175]                             if (!grepl(pattern, name)) 
[16:59:33.175]                               next
[16:59:33.175]                             invokeRestart(restart)
[16:59:33.175]                             muffled <- TRUE
[16:59:33.175]                             break
[16:59:33.175]                           }
[16:59:33.175]                         }
[16:59:33.175]                       }
[16:59:33.175]                       invisible(muffled)
[16:59:33.175]                     }
[16:59:33.175]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.175]                   }
[16:59:33.175]                 }
[16:59:33.175]             }
[16:59:33.175]         }))
[16:59:33.175]     }, error = function(ex) {
[16:59:33.175]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.175]                 ...future.rng), started = ...future.startTime, 
[16:59:33.175]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.175]             version = "1.8"), class = "FutureResult")
[16:59:33.175]     }, finally = {
[16:59:33.175]         if (!identical(...future.workdir, getwd())) 
[16:59:33.175]             setwd(...future.workdir)
[16:59:33.175]         {
[16:59:33.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.175]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.175]             }
[16:59:33.175]             base::options(...future.oldOptions)
[16:59:33.175]             if (.Platform$OS.type == "windows") {
[16:59:33.175]                 old_names <- names(...future.oldEnvVars)
[16:59:33.175]                 envs <- base::Sys.getenv()
[16:59:33.175]                 names <- names(envs)
[16:59:33.175]                 common <- intersect(names, old_names)
[16:59:33.175]                 added <- setdiff(names, old_names)
[16:59:33.175]                 removed <- setdiff(old_names, names)
[16:59:33.175]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.175]                   envs[common]]
[16:59:33.175]                 NAMES <- toupper(changed)
[16:59:33.175]                 args <- list()
[16:59:33.175]                 for (kk in seq_along(NAMES)) {
[16:59:33.175]                   name <- changed[[kk]]
[16:59:33.175]                   NAME <- NAMES[[kk]]
[16:59:33.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.175]                     next
[16:59:33.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.175]                 }
[16:59:33.175]                 NAMES <- toupper(added)
[16:59:33.175]                 for (kk in seq_along(NAMES)) {
[16:59:33.175]                   name <- added[[kk]]
[16:59:33.175]                   NAME <- NAMES[[kk]]
[16:59:33.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.175]                     next
[16:59:33.175]                   args[[name]] <- ""
[16:59:33.175]                 }
[16:59:33.175]                 NAMES <- toupper(removed)
[16:59:33.175]                 for (kk in seq_along(NAMES)) {
[16:59:33.175]                   name <- removed[[kk]]
[16:59:33.175]                   NAME <- NAMES[[kk]]
[16:59:33.175]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.175]                     next
[16:59:33.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.175]                 }
[16:59:33.175]                 if (length(args) > 0) 
[16:59:33.175]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.175]             }
[16:59:33.175]             else {
[16:59:33.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.175]             }
[16:59:33.175]             {
[16:59:33.175]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.175]                   0L) {
[16:59:33.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.175]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.175]                   base::options(opts)
[16:59:33.175]                 }
[16:59:33.175]                 {
[16:59:33.175]                   {
[16:59:33.175]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:33.175]                     NULL
[16:59:33.175]                   }
[16:59:33.175]                   options(future.plan = NULL)
[16:59:33.175]                   if (is.na(NA_character_)) 
[16:59:33.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.175]                     .init = FALSE)
[16:59:33.175]                 }
[16:59:33.175]             }
[16:59:33.175]         }
[16:59:33.175]     })
[16:59:33.175]     if (TRUE) {
[16:59:33.175]         base::sink(type = "output", split = FALSE)
[16:59:33.175]         if (TRUE) {
[16:59:33.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.175]         }
[16:59:33.175]         else {
[16:59:33.175]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.175]         }
[16:59:33.175]         base::close(...future.stdout)
[16:59:33.175]         ...future.stdout <- NULL
[16:59:33.175]     }
[16:59:33.175]     ...future.result$conditions <- ...future.conditions
[16:59:33.175]     ...future.result$finished <- base::Sys.time()
[16:59:33.175]     ...future.result
[16:59:33.175] }
[16:59:33.178] Exporting 5 global objects (9.77 KiB) to cluster node #1 ...
[16:59:33.178] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:33.178] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:33.178] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ...
[16:59:33.179] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #1 ... DONE
[16:59:33.179] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:59:33.179] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.179] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:33.180] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:33.180] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:33.180] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.180] Exporting 5 global objects (9.77 KiB) to cluster node #1 ... DONE
[16:59:33.181] MultisessionFuture started
[16:59:33.181] - Launch lazy future ... done
[16:59:33.181] run() for ‘MultisessionFuture’ ... done
[16:59:33.181] Created future:
[16:59:33.181] MultisessionFuture:
[16:59:33.181] Label: ‘future_apply-1’
[16:59:33.181] Expression:
[16:59:33.181] {
[16:59:33.181]     do.call(function(...) {
[16:59:33.181]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.181]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.181]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.181]             on.exit(options(oopts), add = TRUE)
[16:59:33.181]         }
[16:59:33.181]         {
[16:59:33.181]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.181]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.181]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.181]             })
[16:59:33.181]         }
[16:59:33.181]     }, args = future.call.arguments)
[16:59:33.181] }
[16:59:33.181] Lazy evaluation: FALSE
[16:59:33.181] Asynchronous evaluation: TRUE
[16:59:33.181] Local evaluation: TRUE
[16:59:33.181] Environment: R_GlobalEnv
[16:59:33.181] Capture standard output: TRUE
[16:59:33.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.181] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:33.181] Packages: <none>
[16:59:33.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.181] Resolved: FALSE
[16:59:33.181] Value: <not collected>
[16:59:33.181] Conditions captured: <none>
[16:59:33.181] Early signaling: FALSE
[16:59:33.181] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:33.181] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.193] Chunk #1 of 2 ... DONE
[16:59:33.193] Chunk #2 of 2 ...
[16:59:33.193]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:33.193]  - seeds: <none>
[16:59:33.193]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.193] getGlobalsAndPackages() ...
[16:59:33.193] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.193] Resolving globals: FALSE
[16:59:33.193] Tweak future expression to call with '...' arguments ...
[16:59:33.194] {
[16:59:33.194]     do.call(function(...) {
[16:59:33.194]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.194]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.194]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.194]             on.exit(options(oopts), add = TRUE)
[16:59:33.194]         }
[16:59:33.194]         {
[16:59:33.194]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.194]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.194]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.194]             })
[16:59:33.194]         }
[16:59:33.194]     }, args = future.call.arguments)
[16:59:33.194] }
[16:59:33.194] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.194] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.194] 
[16:59:33.194] getGlobalsAndPackages() ... DONE
[16:59:33.195] run() for ‘Future’ ...
[16:59:33.195] - state: ‘created’
[16:59:33.195] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:33.209] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.209] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:33.209]   - Field: ‘node’
[16:59:33.209]   - Field: ‘label’
[16:59:33.210]   - Field: ‘local’
[16:59:33.210]   - Field: ‘owner’
[16:59:33.210]   - Field: ‘envir’
[16:59:33.210]   - Field: ‘workers’
[16:59:33.210]   - Field: ‘packages’
[16:59:33.210]   - Field: ‘gc’
[16:59:33.210]   - Field: ‘conditions’
[16:59:33.210]   - Field: ‘persistent’
[16:59:33.210]   - Field: ‘expr’
[16:59:33.210]   - Field: ‘uuid’
[16:59:33.210]   - Field: ‘seed’
[16:59:33.211]   - Field: ‘version’
[16:59:33.211]   - Field: ‘result’
[16:59:33.211]   - Field: ‘asynchronous’
[16:59:33.211]   - Field: ‘calls’
[16:59:33.211]   - Field: ‘globals’
[16:59:33.211]   - Field: ‘stdout’
[16:59:33.211]   - Field: ‘earlySignal’
[16:59:33.211]   - Field: ‘lazy’
[16:59:33.211]   - Field: ‘state’
[16:59:33.211] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:33.211] - Launch lazy future ...
[16:59:33.212] Packages needed by the future expression (n = 0): <none>
[16:59:33.212] Packages needed by future strategies (n = 0): <none>
[16:59:33.212] {
[16:59:33.212]     {
[16:59:33.212]         {
[16:59:33.212]             ...future.startTime <- base::Sys.time()
[16:59:33.212]             {
[16:59:33.212]                 {
[16:59:33.212]                   {
[16:59:33.212]                     {
[16:59:33.212]                       base::local({
[16:59:33.212]                         has_future <- base::requireNamespace("future", 
[16:59:33.212]                           quietly = TRUE)
[16:59:33.212]                         if (has_future) {
[16:59:33.212]                           ns <- base::getNamespace("future")
[16:59:33.212]                           version <- ns[[".package"]][["version"]]
[16:59:33.212]                           if (is.null(version)) 
[16:59:33.212]                             version <- utils::packageVersion("future")
[16:59:33.212]                         }
[16:59:33.212]                         else {
[16:59:33.212]                           version <- NULL
[16:59:33.212]                         }
[16:59:33.212]                         if (!has_future || version < "1.8.0") {
[16:59:33.212]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.212]                             "", base::R.version$version.string), 
[16:59:33.212]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.212]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.212]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.212]                               "release", "version")], collapse = " "), 
[16:59:33.212]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.212]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.212]                             info)
[16:59:33.212]                           info <- base::paste(info, collapse = "; ")
[16:59:33.212]                           if (!has_future) {
[16:59:33.212]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.212]                               info)
[16:59:33.212]                           }
[16:59:33.212]                           else {
[16:59:33.212]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.212]                               info, version)
[16:59:33.212]                           }
[16:59:33.212]                           base::stop(msg)
[16:59:33.212]                         }
[16:59:33.212]                       })
[16:59:33.212]                     }
[16:59:33.212]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:33.212]                     base::options(mc.cores = 1L)
[16:59:33.212]                   }
[16:59:33.212]                   ...future.strategy.old <- future::plan("list")
[16:59:33.212]                   options(future.plan = NULL)
[16:59:33.212]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.212]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.212]                 }
[16:59:33.212]                 ...future.workdir <- getwd()
[16:59:33.212]             }
[16:59:33.212]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.212]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.212]         }
[16:59:33.212]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.212]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:33.212]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.212]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.212]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.212]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.212]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.212]             base::names(...future.oldOptions))
[16:59:33.212]     }
[16:59:33.212]     if (FALSE) {
[16:59:33.212]     }
[16:59:33.212]     else {
[16:59:33.212]         if (TRUE) {
[16:59:33.212]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.212]                 open = "w")
[16:59:33.212]         }
[16:59:33.212]         else {
[16:59:33.212]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.212]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.212]         }
[16:59:33.212]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.212]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.212]             base::sink(type = "output", split = FALSE)
[16:59:33.212]             base::close(...future.stdout)
[16:59:33.212]         }, add = TRUE)
[16:59:33.212]     }
[16:59:33.212]     ...future.frame <- base::sys.nframe()
[16:59:33.212]     ...future.conditions <- base::list()
[16:59:33.212]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.212]     if (FALSE) {
[16:59:33.212]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.212]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.212]     }
[16:59:33.212]     ...future.result <- base::tryCatch({
[16:59:33.212]         base::withCallingHandlers({
[16:59:33.212]             ...future.value <- base::withVisible(base::local({
[16:59:33.212]                 ...future.makeSendCondition <- base::local({
[16:59:33.212]                   sendCondition <- NULL
[16:59:33.212]                   function(frame = 1L) {
[16:59:33.212]                     if (is.function(sendCondition)) 
[16:59:33.212]                       return(sendCondition)
[16:59:33.212]                     ns <- getNamespace("parallel")
[16:59:33.212]                     if (exists("sendData", mode = "function", 
[16:59:33.212]                       envir = ns)) {
[16:59:33.212]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:33.212]                         envir = ns)
[16:59:33.212]                       envir <- sys.frame(frame)
[16:59:33.212]                       master <- NULL
[16:59:33.212]                       while (!identical(envir, .GlobalEnv) && 
[16:59:33.212]                         !identical(envir, emptyenv())) {
[16:59:33.212]                         if (exists("master", mode = "list", envir = envir, 
[16:59:33.212]                           inherits = FALSE)) {
[16:59:33.212]                           master <- get("master", mode = "list", 
[16:59:33.212]                             envir = envir, inherits = FALSE)
[16:59:33.212]                           if (inherits(master, c("SOCKnode", 
[16:59:33.212]                             "SOCK0node"))) {
[16:59:33.212]                             sendCondition <<- function(cond) {
[16:59:33.212]                               data <- list(type = "VALUE", value = cond, 
[16:59:33.212]                                 success = TRUE)
[16:59:33.212]                               parallel_sendData(master, data)
[16:59:33.212]                             }
[16:59:33.212]                             return(sendCondition)
[16:59:33.212]                           }
[16:59:33.212]                         }
[16:59:33.212]                         frame <- frame + 1L
[16:59:33.212]                         envir <- sys.frame(frame)
[16:59:33.212]                       }
[16:59:33.212]                     }
[16:59:33.212]                     sendCondition <<- function(cond) NULL
[16:59:33.212]                   }
[16:59:33.212]                 })
[16:59:33.212]                 withCallingHandlers({
[16:59:33.212]                   {
[16:59:33.212]                     do.call(function(...) {
[16:59:33.212]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.212]                       if (!identical(...future.globals.maxSize.org, 
[16:59:33.212]                         ...future.globals.maxSize)) {
[16:59:33.212]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.212]                         on.exit(options(oopts), add = TRUE)
[16:59:33.212]                       }
[16:59:33.212]                       {
[16:59:33.212]                         lapply(seq_along(...future.elements_ii), 
[16:59:33.212]                           FUN = function(jj) {
[16:59:33.212]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.212]                             ...future.FUN(...future.X_jj, ...)
[16:59:33.212]                           })
[16:59:33.212]                       }
[16:59:33.212]                     }, args = future.call.arguments)
[16:59:33.212]                   }
[16:59:33.212]                 }, immediateCondition = function(cond) {
[16:59:33.212]                   sendCondition <- ...future.makeSendCondition()
[16:59:33.212]                   sendCondition(cond)
[16:59:33.212]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.212]                   {
[16:59:33.212]                     inherits <- base::inherits
[16:59:33.212]                     invokeRestart <- base::invokeRestart
[16:59:33.212]                     is.null <- base::is.null
[16:59:33.212]                     muffled <- FALSE
[16:59:33.212]                     if (inherits(cond, "message")) {
[16:59:33.212]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:33.212]                       if (muffled) 
[16:59:33.212]                         invokeRestart("muffleMessage")
[16:59:33.212]                     }
[16:59:33.212]                     else if (inherits(cond, "warning")) {
[16:59:33.212]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:33.212]                       if (muffled) 
[16:59:33.212]                         invokeRestart("muffleWarning")
[16:59:33.212]                     }
[16:59:33.212]                     else if (inherits(cond, "condition")) {
[16:59:33.212]                       if (!is.null(pattern)) {
[16:59:33.212]                         computeRestarts <- base::computeRestarts
[16:59:33.212]                         grepl <- base::grepl
[16:59:33.212]                         restarts <- computeRestarts(cond)
[16:59:33.212]                         for (restart in restarts) {
[16:59:33.212]                           name <- restart$name
[16:59:33.212]                           if (is.null(name)) 
[16:59:33.212]                             next
[16:59:33.212]                           if (!grepl(pattern, name)) 
[16:59:33.212]                             next
[16:59:33.212]                           invokeRestart(restart)
[16:59:33.212]                           muffled <- TRUE
[16:59:33.212]                           break
[16:59:33.212]                         }
[16:59:33.212]                       }
[16:59:33.212]                     }
[16:59:33.212]                     invisible(muffled)
[16:59:33.212]                   }
[16:59:33.212]                   muffleCondition(cond)
[16:59:33.212]                 })
[16:59:33.212]             }))
[16:59:33.212]             future::FutureResult(value = ...future.value$value, 
[16:59:33.212]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.212]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.212]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.212]                     ...future.globalenv.names))
[16:59:33.212]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.212]         }, condition = base::local({
[16:59:33.212]             c <- base::c
[16:59:33.212]             inherits <- base::inherits
[16:59:33.212]             invokeRestart <- base::invokeRestart
[16:59:33.212]             length <- base::length
[16:59:33.212]             list <- base::list
[16:59:33.212]             seq.int <- base::seq.int
[16:59:33.212]             signalCondition <- base::signalCondition
[16:59:33.212]             sys.calls <- base::sys.calls
[16:59:33.212]             `[[` <- base::`[[`
[16:59:33.212]             `+` <- base::`+`
[16:59:33.212]             `<<-` <- base::`<<-`
[16:59:33.212]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.212]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.212]                   3L)]
[16:59:33.212]             }
[16:59:33.212]             function(cond) {
[16:59:33.212]                 is_error <- inherits(cond, "error")
[16:59:33.212]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.212]                   NULL)
[16:59:33.212]                 if (is_error) {
[16:59:33.212]                   sessionInformation <- function() {
[16:59:33.212]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.212]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.212]                       search = base::search(), system = base::Sys.info())
[16:59:33.212]                   }
[16:59:33.212]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.212]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.212]                     cond$call), session = sessionInformation(), 
[16:59:33.212]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.212]                   signalCondition(cond)
[16:59:33.212]                 }
[16:59:33.212]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.212]                 "immediateCondition"))) {
[16:59:33.212]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.212]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.212]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.212]                   if (TRUE && !signal) {
[16:59:33.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.212]                     {
[16:59:33.212]                       inherits <- base::inherits
[16:59:33.212]                       invokeRestart <- base::invokeRestart
[16:59:33.212]                       is.null <- base::is.null
[16:59:33.212]                       muffled <- FALSE
[16:59:33.212]                       if (inherits(cond, "message")) {
[16:59:33.212]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.212]                         if (muffled) 
[16:59:33.212]                           invokeRestart("muffleMessage")
[16:59:33.212]                       }
[16:59:33.212]                       else if (inherits(cond, "warning")) {
[16:59:33.212]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.212]                         if (muffled) 
[16:59:33.212]                           invokeRestart("muffleWarning")
[16:59:33.212]                       }
[16:59:33.212]                       else if (inherits(cond, "condition")) {
[16:59:33.212]                         if (!is.null(pattern)) {
[16:59:33.212]                           computeRestarts <- base::computeRestarts
[16:59:33.212]                           grepl <- base::grepl
[16:59:33.212]                           restarts <- computeRestarts(cond)
[16:59:33.212]                           for (restart in restarts) {
[16:59:33.212]                             name <- restart$name
[16:59:33.212]                             if (is.null(name)) 
[16:59:33.212]                               next
[16:59:33.212]                             if (!grepl(pattern, name)) 
[16:59:33.212]                               next
[16:59:33.212]                             invokeRestart(restart)
[16:59:33.212]                             muffled <- TRUE
[16:59:33.212]                             break
[16:59:33.212]                           }
[16:59:33.212]                         }
[16:59:33.212]                       }
[16:59:33.212]                       invisible(muffled)
[16:59:33.212]                     }
[16:59:33.212]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.212]                   }
[16:59:33.212]                 }
[16:59:33.212]                 else {
[16:59:33.212]                   if (TRUE) {
[16:59:33.212]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.212]                     {
[16:59:33.212]                       inherits <- base::inherits
[16:59:33.212]                       invokeRestart <- base::invokeRestart
[16:59:33.212]                       is.null <- base::is.null
[16:59:33.212]                       muffled <- FALSE
[16:59:33.212]                       if (inherits(cond, "message")) {
[16:59:33.212]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.212]                         if (muffled) 
[16:59:33.212]                           invokeRestart("muffleMessage")
[16:59:33.212]                       }
[16:59:33.212]                       else if (inherits(cond, "warning")) {
[16:59:33.212]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.212]                         if (muffled) 
[16:59:33.212]                           invokeRestart("muffleWarning")
[16:59:33.212]                       }
[16:59:33.212]                       else if (inherits(cond, "condition")) {
[16:59:33.212]                         if (!is.null(pattern)) {
[16:59:33.212]                           computeRestarts <- base::computeRestarts
[16:59:33.212]                           grepl <- base::grepl
[16:59:33.212]                           restarts <- computeRestarts(cond)
[16:59:33.212]                           for (restart in restarts) {
[16:59:33.212]                             name <- restart$name
[16:59:33.212]                             if (is.null(name)) 
[16:59:33.212]                               next
[16:59:33.212]                             if (!grepl(pattern, name)) 
[16:59:33.212]                               next
[16:59:33.212]                             invokeRestart(restart)
[16:59:33.212]                             muffled <- TRUE
[16:59:33.212]                             break
[16:59:33.212]                           }
[16:59:33.212]                         }
[16:59:33.212]                       }
[16:59:33.212]                       invisible(muffled)
[16:59:33.212]                     }
[16:59:33.212]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.212]                   }
[16:59:33.212]                 }
[16:59:33.212]             }
[16:59:33.212]         }))
[16:59:33.212]     }, error = function(ex) {
[16:59:33.212]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.212]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.212]                 ...future.rng), started = ...future.startTime, 
[16:59:33.212]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.212]             version = "1.8"), class = "FutureResult")
[16:59:33.212]     }, finally = {
[16:59:33.212]         if (!identical(...future.workdir, getwd())) 
[16:59:33.212]             setwd(...future.workdir)
[16:59:33.212]         {
[16:59:33.212]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.212]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.212]             }
[16:59:33.212]             base::options(...future.oldOptions)
[16:59:33.212]             if (.Platform$OS.type == "windows") {
[16:59:33.212]                 old_names <- names(...future.oldEnvVars)
[16:59:33.212]                 envs <- base::Sys.getenv()
[16:59:33.212]                 names <- names(envs)
[16:59:33.212]                 common <- intersect(names, old_names)
[16:59:33.212]                 added <- setdiff(names, old_names)
[16:59:33.212]                 removed <- setdiff(old_names, names)
[16:59:33.212]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.212]                   envs[common]]
[16:59:33.212]                 NAMES <- toupper(changed)
[16:59:33.212]                 args <- list()
[16:59:33.212]                 for (kk in seq_along(NAMES)) {
[16:59:33.212]                   name <- changed[[kk]]
[16:59:33.212]                   NAME <- NAMES[[kk]]
[16:59:33.212]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.212]                     next
[16:59:33.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.212]                 }
[16:59:33.212]                 NAMES <- toupper(added)
[16:59:33.212]                 for (kk in seq_along(NAMES)) {
[16:59:33.212]                   name <- added[[kk]]
[16:59:33.212]                   NAME <- NAMES[[kk]]
[16:59:33.212]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.212]                     next
[16:59:33.212]                   args[[name]] <- ""
[16:59:33.212]                 }
[16:59:33.212]                 NAMES <- toupper(removed)
[16:59:33.212]                 for (kk in seq_along(NAMES)) {
[16:59:33.212]                   name <- removed[[kk]]
[16:59:33.212]                   NAME <- NAMES[[kk]]
[16:59:33.212]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.212]                     next
[16:59:33.212]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.212]                 }
[16:59:33.212]                 if (length(args) > 0) 
[16:59:33.212]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.212]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.212]             }
[16:59:33.212]             else {
[16:59:33.212]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.212]             }
[16:59:33.212]             {
[16:59:33.212]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.212]                   0L) {
[16:59:33.212]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.212]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.212]                   base::options(opts)
[16:59:33.212]                 }
[16:59:33.212]                 {
[16:59:33.212]                   {
[16:59:33.212]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:33.212]                     NULL
[16:59:33.212]                   }
[16:59:33.212]                   options(future.plan = NULL)
[16:59:33.212]                   if (is.na(NA_character_)) 
[16:59:33.212]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.212]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.212]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.212]                     .init = FALSE)
[16:59:33.212]                 }
[16:59:33.212]             }
[16:59:33.212]         }
[16:59:33.212]     })
[16:59:33.212]     if (TRUE) {
[16:59:33.212]         base::sink(type = "output", split = FALSE)
[16:59:33.212]         if (TRUE) {
[16:59:33.212]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.212]         }
[16:59:33.212]         else {
[16:59:33.212]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.212]         }
[16:59:33.212]         base::close(...future.stdout)
[16:59:33.212]         ...future.stdout <- NULL
[16:59:33.212]     }
[16:59:33.212]     ...future.result$conditions <- ...future.conditions
[16:59:33.212]     ...future.result$finished <- base::Sys.time()
[16:59:33.212]     ...future.result
[16:59:33.212] }
[16:59:33.216] Exporting 5 global objects (9.77 KiB) to cluster node #2 ...
[16:59:33.216] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:33.216] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:33.216] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ...
[16:59:33.219] Exporting ‘...future.FUN’ (9.66 KiB) to cluster node #2 ... DONE
[16:59:33.219] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:59:33.220] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:59:33.220] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:33.220] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:33.220] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ...
[16:59:33.220] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #2 ... DONE
[16:59:33.221] Exporting 5 global objects (9.77 KiB) to cluster node #2 ... DONE
[16:59:33.221] MultisessionFuture started
[16:59:33.221] - Launch lazy future ... done
[16:59:33.221] run() for ‘MultisessionFuture’ ... done
[16:59:33.221] Created future:
[16:59:33.222] MultisessionFuture:
[16:59:33.222] Label: ‘future_apply-2’
[16:59:33.222] Expression:
[16:59:33.222] {
[16:59:33.222]     do.call(function(...) {
[16:59:33.222]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.222]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.222]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.222]             on.exit(options(oopts), add = TRUE)
[16:59:33.222]         }
[16:59:33.222]         {
[16:59:33.222]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.222]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.222]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.222]             })
[16:59:33.222]         }
[16:59:33.222]     }, args = future.call.arguments)
[16:59:33.222] }
[16:59:33.222] Lazy evaluation: FALSE
[16:59:33.222] Asynchronous evaluation: TRUE
[16:59:33.222] Local evaluation: TRUE
[16:59:33.222] Environment: R_GlobalEnv
[16:59:33.222] Capture standard output: TRUE
[16:59:33.222] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.222] Globals: 5 objects totaling 9.77 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 9.66 KiB, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:33.222] Packages: <none>
[16:59:33.222] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.222] Resolved: FALSE
[16:59:33.222] Value: <not collected>
[16:59:33.222] Conditions captured: <none>
[16:59:33.222] Early signaling: FALSE
[16:59:33.222] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:33.222] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.233] Chunk #2 of 2 ... DONE
[16:59:33.233] Launching 2 futures (chunks) ... DONE
[16:59:33.233] Resolving 2 futures (chunks) ...
[16:59:33.233] resolve() on list ...
[16:59:33.234]  recursive: 0
[16:59:33.234]  length: 2
[16:59:33.234] 
[16:59:33.234] receiveMessageFromWorker() for ClusterFuture ...
[16:59:33.234] - Validating connection of MultisessionFuture
[16:59:33.235] - received message: FutureResult
[16:59:33.235] - Received FutureResult
[16:59:33.235] - Erased future from FutureRegistry
[16:59:33.235] result() for ClusterFuture ...
[16:59:33.235] - result already collected: FutureResult
[16:59:33.235] result() for ClusterFuture ... done
[16:59:33.235] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:33.235] Future #1
[16:59:33.235] result() for ClusterFuture ...
[16:59:33.235] - result already collected: FutureResult
[16:59:33.236] result() for ClusterFuture ... done
[16:59:33.236] result() for ClusterFuture ...
[16:59:33.236] - result already collected: FutureResult
[16:59:33.236] result() for ClusterFuture ... done
[16:59:33.236] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:33.236] - nx: 2
[16:59:33.236] - relay: TRUE
[16:59:33.236] - stdout: TRUE
[16:59:33.236] - signal: TRUE
[16:59:33.236] - resignal: FALSE
[16:59:33.236] - force: TRUE
[16:59:33.236] - relayed: [n=2] FALSE, FALSE
[16:59:33.237] - queued futures: [n=2] FALSE, FALSE
[16:59:33.237]  - until=1
[16:59:33.237]  - relaying element #1
[16:59:33.237] result() for ClusterFuture ...
[16:59:33.237] - result already collected: FutureResult
[16:59:33.237] result() for ClusterFuture ... done
[16:59:33.237] result() for ClusterFuture ...
[16:59:33.237] - result already collected: FutureResult
[16:59:33.237] result() for ClusterFuture ... done
[16:59:33.237] result() for ClusterFuture ...
[16:59:33.237] - result already collected: FutureResult
[16:59:33.237] result() for ClusterFuture ... done
[16:59:33.238] result() for ClusterFuture ...
[16:59:33.238] - result already collected: FutureResult
[16:59:33.238] result() for ClusterFuture ... done
[16:59:33.238] - relayed: [n=2] TRUE, FALSE
[16:59:33.238] - queued futures: [n=2] TRUE, FALSE
[16:59:33.238] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:33.238]  length: 1 (resolved future 1)
[16:59:33.265] receiveMessageFromWorker() for ClusterFuture ...
[16:59:33.265] - Validating connection of MultisessionFuture
[16:59:33.265] - received message: FutureResult
[16:59:33.266] - Received FutureResult
[16:59:33.266] - Erased future from FutureRegistry
[16:59:33.266] result() for ClusterFuture ...
[16:59:33.266] - result already collected: FutureResult
[16:59:33.266] result() for ClusterFuture ... done
[16:59:33.266] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:33.266] Future #2
[16:59:33.266] result() for ClusterFuture ...
[16:59:33.266] - result already collected: FutureResult
[16:59:33.266] result() for ClusterFuture ... done
[16:59:33.267] result() for ClusterFuture ...
[16:59:33.267] - result already collected: FutureResult
[16:59:33.267] result() for ClusterFuture ... done
[16:59:33.267] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:33.267] - nx: 2
[16:59:33.267] - relay: TRUE
[16:59:33.267] - stdout: TRUE
[16:59:33.267] - signal: TRUE
[16:59:33.267] - resignal: FALSE
[16:59:33.267] - force: TRUE
[16:59:33.267] - relayed: [n=2] TRUE, FALSE
[16:59:33.268] - queued futures: [n=2] TRUE, FALSE
[16:59:33.268]  - until=2
[16:59:33.268]  - relaying element #2
[16:59:33.268] result() for ClusterFuture ...
[16:59:33.268] - result already collected: FutureResult
[16:59:33.268] result() for ClusterFuture ... done
[16:59:33.268] result() for ClusterFuture ...
[16:59:33.268] - result already collected: FutureResult
[16:59:33.268] result() for ClusterFuture ... done
[16:59:33.268] result() for ClusterFuture ...
[16:59:33.268] - result already collected: FutureResult
[16:59:33.269] result() for ClusterFuture ... done
[16:59:33.269] result() for ClusterFuture ...
[16:59:33.269] - result already collected: FutureResult
[16:59:33.269] result() for ClusterFuture ... done
[16:59:33.269] - relayed: [n=2] TRUE, TRUE
[16:59:33.269] - queued futures: [n=2] TRUE, TRUE
[16:59:33.269] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:33.269]  length: 0 (resolved future 2)
[16:59:33.269] Relaying remaining futures
[16:59:33.269] signalConditionsASAP(NULL, pos=0) ...
[16:59:33.269] - nx: 2
[16:59:33.269] - relay: TRUE
[16:59:33.269] - stdout: TRUE
[16:59:33.270] - signal: TRUE
[16:59:33.270] - resignal: FALSE
[16:59:33.270] - force: TRUE
[16:59:33.270] - relayed: [n=2] TRUE, TRUE
[16:59:33.270] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:33.270] - relayed: [n=2] TRUE, TRUE
[16:59:33.270] - queued futures: [n=2] TRUE, TRUE
[16:59:33.270] signalConditionsASAP(NULL, pos=0) ... done
[16:59:33.270] resolve() on list ... DONE
[16:59:33.270] result() for ClusterFuture ...
[16:59:33.270] - result already collected: FutureResult
[16:59:33.271] result() for ClusterFuture ... done
[16:59:33.271] result() for ClusterFuture ...
[16:59:33.271] - result already collected: FutureResult
[16:59:33.271] result() for ClusterFuture ... done
[16:59:33.271] result() for ClusterFuture ...
[16:59:33.271] - result already collected: FutureResult
[16:59:33.271] result() for ClusterFuture ... done
[16:59:33.271] result() for ClusterFuture ...
[16:59:33.271] - result already collected: FutureResult
[16:59:33.271] result() for ClusterFuture ... done
[16:59:33.271]  - Number of value chunks collected: 2
[16:59:33.272] Resolving 2 futures (chunks) ... DONE
[16:59:33.272] Reducing values from 2 chunks ...
[16:59:33.272]  - Number of values collected after concatenation: 2
[16:59:33.272]  - Number of values expected: 2
[16:59:33.272] Reducing values from 2 chunks ... DONE
[16:59:33.272] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[16:59:33.272] getGlobalsAndPackagesXApply() ...
[16:59:33.272]  - future.globals: TRUE
[16:59:33.272] getGlobalsAndPackages() ...
[16:59:33.273] Searching for globals...
[16:59:33.275] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[16:59:33.276] Searching for globals ... DONE
[16:59:33.276] Resolving globals: FALSE
[16:59:33.276] The total size of the 1 globals is 35.45 KiB (36296 bytes)
[16:59:33.277] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 35.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (35.45 KiB of class ‘function’)
[16:59:33.277] - globals: [1] ‘FUN’
[16:59:33.277] 
[16:59:33.277] getGlobalsAndPackages() ... DONE
[16:59:33.277]  - globals found/used: [n=1] ‘FUN’
[16:59:33.277]  - needed namespaces: [n=0] 
[16:59:33.277] Finding globals ... DONE
[16:59:33.277]  - use_args: TRUE
[16:59:33.277]  - Getting '...' globals ...
[16:59:33.278] resolve() on list ...
[16:59:33.278]  recursive: 0
[16:59:33.278]  length: 1
[16:59:33.278]  elements: ‘...’
[16:59:33.278]  length: 0 (resolved future 1)
[16:59:33.278] resolve() on list ... DONE
[16:59:33.278]    - '...' content: [n=0] 
[16:59:33.278] List of 1
[16:59:33.278]  $ ...: list()
[16:59:33.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.278]  - attr(*, "where")=List of 1
[16:59:33.278]   ..$ ...:<environment: 0x55f31330ed30> 
[16:59:33.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.278]  - attr(*, "resolved")= logi TRUE
[16:59:33.278]  - attr(*, "total_size")= num NA
[16:59:33.281]  - Getting '...' globals ... DONE
[16:59:33.281] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:33.281] List of 2
[16:59:33.281]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:59:33.281]  $ ...          : list()
[16:59:33.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.281]  - attr(*, "where")=List of 2
[16:59:33.281]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.281]   ..$ ...          :<environment: 0x55f31330ed30> 
[16:59:33.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.281]  - attr(*, "resolved")= logi FALSE
[16:59:33.281]  - attr(*, "total_size")= num 36296
[16:59:33.284] Packages to be attached in all futures: [n=0] 
[16:59:33.284] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.288] future_lapply() ...
[16:59:33.290] Generating random seeds ...
[16:59:33.290] Generating random seed streams for 2 elements ...
[16:59:33.290] Generating random seed streams for 2 elements ... DONE
[16:59:33.290] Generating random seeds ... DONE
[16:59:33.290] Will set RNG state on exit: 10407, -1062665225, 1579417608, -1749765423, -1073504926, -2017359487, 1279462046
[16:59:33.294] Number of chunks: 2
[16:59:33.294] getGlobalsAndPackagesXApply() ...
[16:59:33.294]  - future.globals: <name-value list> with names ‘list()’
[16:59:33.294]  - use_args: TRUE
[16:59:33.294] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[16:59:33.294] List of 2
[16:59:33.294]  $ ...          : list()
[16:59:33.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.294]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[16:59:33.294]  - attr(*, "where")=List of 2
[16:59:33.294]   ..$ ...          :<environment: 0x55f31330ed30> 
[16:59:33.294]   ..$ ...future.FUN:<environment: namespace:base> 
[16:59:33.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.294]  - attr(*, "resolved")= logi FALSE
[16:59:33.294]  - attr(*, "total_size")= num NA
[16:59:33.298] Packages to be attached in all futures: [n=0] 
[16:59:33.298] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.298] Number of futures (= number of chunks): 2
[16:59:33.298] Launching 2 futures (chunks) ...
[16:59:33.298] Chunk #1 of 2 ...
[16:59:33.298]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:33.298]  - seeds: [1] <seeds>
[16:59:33.299]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.299] getGlobalsAndPackages() ...
[16:59:33.299] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.299] Resolving globals: FALSE
[16:59:33.299] Tweak future expression to call with '...' arguments ...
[16:59:33.299] {
[16:59:33.299]     do.call(function(...) {
[16:59:33.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.299]             on.exit(options(oopts), add = TRUE)
[16:59:33.299]         }
[16:59:33.299]         {
[16:59:33.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.299]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:33.299]                   envir = globalenv(), inherits = FALSE)
[16:59:33.299]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.299]             })
[16:59:33.299]         }
[16:59:33.299]     }, args = future.call.arguments)
[16:59:33.299] }
[16:59:33.299] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.300] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.300] 
[16:59:33.300] getGlobalsAndPackages() ... DONE
[16:59:33.300] run() for ‘Future’ ...
[16:59:33.300] - state: ‘created’
[16:59:33.300] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:33.314] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:33.314]   - Field: ‘node’
[16:59:33.315]   - Field: ‘label’
[16:59:33.315]   - Field: ‘local’
[16:59:33.315]   - Field: ‘owner’
[16:59:33.315]   - Field: ‘envir’
[16:59:33.315]   - Field: ‘workers’
[16:59:33.315]   - Field: ‘packages’
[16:59:33.315]   - Field: ‘gc’
[16:59:33.315]   - Field: ‘conditions’
[16:59:33.315]   - Field: ‘persistent’
[16:59:33.315]   - Field: ‘expr’
[16:59:33.316]   - Field: ‘uuid’
[16:59:33.316]   - Field: ‘seed’
[16:59:33.316]   - Field: ‘version’
[16:59:33.316]   - Field: ‘result’
[16:59:33.316]   - Field: ‘asynchronous’
[16:59:33.316]   - Field: ‘calls’
[16:59:33.316]   - Field: ‘globals’
[16:59:33.316]   - Field: ‘stdout’
[16:59:33.316]   - Field: ‘earlySignal’
[16:59:33.316]   - Field: ‘lazy’
[16:59:33.316]   - Field: ‘state’
[16:59:33.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:33.317] - Launch lazy future ...
[16:59:33.317] Packages needed by the future expression (n = 0): <none>
[16:59:33.317] Packages needed by future strategies (n = 0): <none>
[16:59:33.317] {
[16:59:33.317]     {
[16:59:33.317]         {
[16:59:33.317]             ...future.startTime <- base::Sys.time()
[16:59:33.317]             {
[16:59:33.317]                 {
[16:59:33.317]                   {
[16:59:33.317]                     {
[16:59:33.317]                       base::local({
[16:59:33.317]                         has_future <- base::requireNamespace("future", 
[16:59:33.317]                           quietly = TRUE)
[16:59:33.317]                         if (has_future) {
[16:59:33.317]                           ns <- base::getNamespace("future")
[16:59:33.317]                           version <- ns[[".package"]][["version"]]
[16:59:33.317]                           if (is.null(version)) 
[16:59:33.317]                             version <- utils::packageVersion("future")
[16:59:33.317]                         }
[16:59:33.317]                         else {
[16:59:33.317]                           version <- NULL
[16:59:33.317]                         }
[16:59:33.317]                         if (!has_future || version < "1.8.0") {
[16:59:33.317]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.317]                             "", base::R.version$version.string), 
[16:59:33.317]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.317]                               "release", "version")], collapse = " "), 
[16:59:33.317]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.317]                             info)
[16:59:33.317]                           info <- base::paste(info, collapse = "; ")
[16:59:33.317]                           if (!has_future) {
[16:59:33.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.317]                               info)
[16:59:33.317]                           }
[16:59:33.317]                           else {
[16:59:33.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.317]                               info, version)
[16:59:33.317]                           }
[16:59:33.317]                           base::stop(msg)
[16:59:33.317]                         }
[16:59:33.317]                       })
[16:59:33.317]                     }
[16:59:33.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:33.317]                     base::options(mc.cores = 1L)
[16:59:33.317]                   }
[16:59:33.317]                   ...future.strategy.old <- future::plan("list")
[16:59:33.317]                   options(future.plan = NULL)
[16:59:33.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.317]                 }
[16:59:33.317]                 ...future.workdir <- getwd()
[16:59:33.317]             }
[16:59:33.317]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.317]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.317]         }
[16:59:33.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.317]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:33.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.317]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.317]             base::names(...future.oldOptions))
[16:59:33.317]     }
[16:59:33.317]     if (FALSE) {
[16:59:33.317]     }
[16:59:33.317]     else {
[16:59:33.317]         if (TRUE) {
[16:59:33.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.317]                 open = "w")
[16:59:33.317]         }
[16:59:33.317]         else {
[16:59:33.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.317]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.317]         }
[16:59:33.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.317]             base::sink(type = "output", split = FALSE)
[16:59:33.317]             base::close(...future.stdout)
[16:59:33.317]         }, add = TRUE)
[16:59:33.317]     }
[16:59:33.317]     ...future.frame <- base::sys.nframe()
[16:59:33.317]     ...future.conditions <- base::list()
[16:59:33.317]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.317]     if (FALSE) {
[16:59:33.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.317]     }
[16:59:33.317]     ...future.result <- base::tryCatch({
[16:59:33.317]         base::withCallingHandlers({
[16:59:33.317]             ...future.value <- base::withVisible(base::local({
[16:59:33.317]                 ...future.makeSendCondition <- base::local({
[16:59:33.317]                   sendCondition <- NULL
[16:59:33.317]                   function(frame = 1L) {
[16:59:33.317]                     if (is.function(sendCondition)) 
[16:59:33.317]                       return(sendCondition)
[16:59:33.317]                     ns <- getNamespace("parallel")
[16:59:33.317]                     if (exists("sendData", mode = "function", 
[16:59:33.317]                       envir = ns)) {
[16:59:33.317]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:33.317]                         envir = ns)
[16:59:33.317]                       envir <- sys.frame(frame)
[16:59:33.317]                       master <- NULL
[16:59:33.317]                       while (!identical(envir, .GlobalEnv) && 
[16:59:33.317]                         !identical(envir, emptyenv())) {
[16:59:33.317]                         if (exists("master", mode = "list", envir = envir, 
[16:59:33.317]                           inherits = FALSE)) {
[16:59:33.317]                           master <- get("master", mode = "list", 
[16:59:33.317]                             envir = envir, inherits = FALSE)
[16:59:33.317]                           if (inherits(master, c("SOCKnode", 
[16:59:33.317]                             "SOCK0node"))) {
[16:59:33.317]                             sendCondition <<- function(cond) {
[16:59:33.317]                               data <- list(type = "VALUE", value = cond, 
[16:59:33.317]                                 success = TRUE)
[16:59:33.317]                               parallel_sendData(master, data)
[16:59:33.317]                             }
[16:59:33.317]                             return(sendCondition)
[16:59:33.317]                           }
[16:59:33.317]                         }
[16:59:33.317]                         frame <- frame + 1L
[16:59:33.317]                         envir <- sys.frame(frame)
[16:59:33.317]                       }
[16:59:33.317]                     }
[16:59:33.317]                     sendCondition <<- function(cond) NULL
[16:59:33.317]                   }
[16:59:33.317]                 })
[16:59:33.317]                 withCallingHandlers({
[16:59:33.317]                   {
[16:59:33.317]                     do.call(function(...) {
[16:59:33.317]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.317]                       if (!identical(...future.globals.maxSize.org, 
[16:59:33.317]                         ...future.globals.maxSize)) {
[16:59:33.317]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.317]                         on.exit(options(oopts), add = TRUE)
[16:59:33.317]                       }
[16:59:33.317]                       {
[16:59:33.317]                         lapply(seq_along(...future.elements_ii), 
[16:59:33.317]                           FUN = function(jj) {
[16:59:33.317]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.317]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:33.317]                               envir = globalenv(), inherits = FALSE)
[16:59:33.317]                             ...future.FUN(...future.X_jj, ...)
[16:59:33.317]                           })
[16:59:33.317]                       }
[16:59:33.317]                     }, args = future.call.arguments)
[16:59:33.317]                   }
[16:59:33.317]                 }, immediateCondition = function(cond) {
[16:59:33.317]                   sendCondition <- ...future.makeSendCondition()
[16:59:33.317]                   sendCondition(cond)
[16:59:33.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.317]                   {
[16:59:33.317]                     inherits <- base::inherits
[16:59:33.317]                     invokeRestart <- base::invokeRestart
[16:59:33.317]                     is.null <- base::is.null
[16:59:33.317]                     muffled <- FALSE
[16:59:33.317]                     if (inherits(cond, "message")) {
[16:59:33.317]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:33.317]                       if (muffled) 
[16:59:33.317]                         invokeRestart("muffleMessage")
[16:59:33.317]                     }
[16:59:33.317]                     else if (inherits(cond, "warning")) {
[16:59:33.317]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:33.317]                       if (muffled) 
[16:59:33.317]                         invokeRestart("muffleWarning")
[16:59:33.317]                     }
[16:59:33.317]                     else if (inherits(cond, "condition")) {
[16:59:33.317]                       if (!is.null(pattern)) {
[16:59:33.317]                         computeRestarts <- base::computeRestarts
[16:59:33.317]                         grepl <- base::grepl
[16:59:33.317]                         restarts <- computeRestarts(cond)
[16:59:33.317]                         for (restart in restarts) {
[16:59:33.317]                           name <- restart$name
[16:59:33.317]                           if (is.null(name)) 
[16:59:33.317]                             next
[16:59:33.317]                           if (!grepl(pattern, name)) 
[16:59:33.317]                             next
[16:59:33.317]                           invokeRestart(restart)
[16:59:33.317]                           muffled <- TRUE
[16:59:33.317]                           break
[16:59:33.317]                         }
[16:59:33.317]                       }
[16:59:33.317]                     }
[16:59:33.317]                     invisible(muffled)
[16:59:33.317]                   }
[16:59:33.317]                   muffleCondition(cond)
[16:59:33.317]                 })
[16:59:33.317]             }))
[16:59:33.317]             future::FutureResult(value = ...future.value$value, 
[16:59:33.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.317]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.317]                     ...future.globalenv.names))
[16:59:33.317]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.317]         }, condition = base::local({
[16:59:33.317]             c <- base::c
[16:59:33.317]             inherits <- base::inherits
[16:59:33.317]             invokeRestart <- base::invokeRestart
[16:59:33.317]             length <- base::length
[16:59:33.317]             list <- base::list
[16:59:33.317]             seq.int <- base::seq.int
[16:59:33.317]             signalCondition <- base::signalCondition
[16:59:33.317]             sys.calls <- base::sys.calls
[16:59:33.317]             `[[` <- base::`[[`
[16:59:33.317]             `+` <- base::`+`
[16:59:33.317]             `<<-` <- base::`<<-`
[16:59:33.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.317]                   3L)]
[16:59:33.317]             }
[16:59:33.317]             function(cond) {
[16:59:33.317]                 is_error <- inherits(cond, "error")
[16:59:33.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.317]                   NULL)
[16:59:33.317]                 if (is_error) {
[16:59:33.317]                   sessionInformation <- function() {
[16:59:33.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.317]                       search = base::search(), system = base::Sys.info())
[16:59:33.317]                   }
[16:59:33.317]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.317]                     cond$call), session = sessionInformation(), 
[16:59:33.317]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.317]                   signalCondition(cond)
[16:59:33.317]                 }
[16:59:33.317]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:59:33.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.317]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.317]                   if (TRUE && !signal) {
[16:59:33.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.317]                     {
[16:59:33.317]                       inherits <- base::inherits
[16:59:33.317]                       invokeRestart <- base::invokeRestart
[16:59:33.317]                       is.null <- base::is.null
[16:59:33.317]                       muffled <- FALSE
[16:59:33.317]                       if (inherits(cond, "message")) {
[16:59:33.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.317]                         if (muffled) 
[16:59:33.317]                           invokeRestart("muffleMessage")
[16:59:33.317]                       }
[16:59:33.317]                       else if (inherits(cond, "warning")) {
[16:59:33.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.317]                         if (muffled) 
[16:59:33.317]                           invokeRestart("muffleWarning")
[16:59:33.317]                       }
[16:59:33.317]                       else if (inherits(cond, "condition")) {
[16:59:33.317]                         if (!is.null(pattern)) {
[16:59:33.317]                           computeRestarts <- base::computeRestarts
[16:59:33.317]                           grepl <- base::grepl
[16:59:33.317]                           restarts <- computeRestarts(cond)
[16:59:33.317]                           for (restart in restarts) {
[16:59:33.317]                             name <- restart$name
[16:59:33.317]                             if (is.null(name)) 
[16:59:33.317]                               next
[16:59:33.317]                             if (!grepl(pattern, name)) 
[16:59:33.317]                               next
[16:59:33.317]                             invokeRestart(restart)
[16:59:33.317]                             muffled <- TRUE
[16:59:33.317]                             break
[16:59:33.317]                           }
[16:59:33.317]                         }
[16:59:33.317]                       }
[16:59:33.317]                       invisible(muffled)
[16:59:33.317]                     }
[16:59:33.317]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.317]                   }
[16:59:33.317]                 }
[16:59:33.317]                 else {
[16:59:33.317]                   if (TRUE) {
[16:59:33.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.317]                     {
[16:59:33.317]                       inherits <- base::inherits
[16:59:33.317]                       invokeRestart <- base::invokeRestart
[16:59:33.317]                       is.null <- base::is.null
[16:59:33.317]                       muffled <- FALSE
[16:59:33.317]                       if (inherits(cond, "message")) {
[16:59:33.317]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.317]                         if (muffled) 
[16:59:33.317]                           invokeRestart("muffleMessage")
[16:59:33.317]                       }
[16:59:33.317]                       else if (inherits(cond, "warning")) {
[16:59:33.317]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.317]                         if (muffled) 
[16:59:33.317]                           invokeRestart("muffleWarning")
[16:59:33.317]                       }
[16:59:33.317]                       else if (inherits(cond, "condition")) {
[16:59:33.317]                         if (!is.null(pattern)) {
[16:59:33.317]                           computeRestarts <- base::computeRestarts
[16:59:33.317]                           grepl <- base::grepl
[16:59:33.317]                           restarts <- computeRestarts(cond)
[16:59:33.317]                           for (restart in restarts) {
[16:59:33.317]                             name <- restart$name
[16:59:33.317]                             if (is.null(name)) 
[16:59:33.317]                               next
[16:59:33.317]                             if (!grepl(pattern, name)) 
[16:59:33.317]                               next
[16:59:33.317]                             invokeRestart(restart)
[16:59:33.317]                             muffled <- TRUE
[16:59:33.317]                             break
[16:59:33.317]                           }
[16:59:33.317]                         }
[16:59:33.317]                       }
[16:59:33.317]                       invisible(muffled)
[16:59:33.317]                     }
[16:59:33.317]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.317]                   }
[16:59:33.317]                 }
[16:59:33.317]             }
[16:59:33.317]         }))
[16:59:33.317]     }, error = function(ex) {
[16:59:33.317]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.317]                 ...future.rng), started = ...future.startTime, 
[16:59:33.317]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.317]             version = "1.8"), class = "FutureResult")
[16:59:33.317]     }, finally = {
[16:59:33.317]         if (!identical(...future.workdir, getwd())) 
[16:59:33.317]             setwd(...future.workdir)
[16:59:33.317]         {
[16:59:33.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.317]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.317]             }
[16:59:33.317]             base::options(...future.oldOptions)
[16:59:33.317]             if (.Platform$OS.type == "windows") {
[16:59:33.317]                 old_names <- names(...future.oldEnvVars)
[16:59:33.317]                 envs <- base::Sys.getenv()
[16:59:33.317]                 names <- names(envs)
[16:59:33.317]                 common <- intersect(names, old_names)
[16:59:33.317]                 added <- setdiff(names, old_names)
[16:59:33.317]                 removed <- setdiff(old_names, names)
[16:59:33.317]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.317]                   envs[common]]
[16:59:33.317]                 NAMES <- toupper(changed)
[16:59:33.317]                 args <- list()
[16:59:33.317]                 for (kk in seq_along(NAMES)) {
[16:59:33.317]                   name <- changed[[kk]]
[16:59:33.317]                   NAME <- NAMES[[kk]]
[16:59:33.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.317]                     next
[16:59:33.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.317]                 }
[16:59:33.317]                 NAMES <- toupper(added)
[16:59:33.317]                 for (kk in seq_along(NAMES)) {
[16:59:33.317]                   name <- added[[kk]]
[16:59:33.317]                   NAME <- NAMES[[kk]]
[16:59:33.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.317]                     next
[16:59:33.317]                   args[[name]] <- ""
[16:59:33.317]                 }
[16:59:33.317]                 NAMES <- toupper(removed)
[16:59:33.317]                 for (kk in seq_along(NAMES)) {
[16:59:33.317]                   name <- removed[[kk]]
[16:59:33.317]                   NAME <- NAMES[[kk]]
[16:59:33.317]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.317]                     next
[16:59:33.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.317]                 }
[16:59:33.317]                 if (length(args) > 0) 
[16:59:33.317]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.317]             }
[16:59:33.317]             else {
[16:59:33.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.317]             }
[16:59:33.317]             {
[16:59:33.317]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.317]                   0L) {
[16:59:33.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.317]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.317]                   base::options(opts)
[16:59:33.317]                 }
[16:59:33.317]                 {
[16:59:33.317]                   {
[16:59:33.317]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:33.317]                     NULL
[16:59:33.317]                   }
[16:59:33.317]                   options(future.plan = NULL)
[16:59:33.317]                   if (is.na(NA_character_)) 
[16:59:33.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.317]                     .init = FALSE)
[16:59:33.317]                 }
[16:59:33.317]             }
[16:59:33.317]         }
[16:59:33.317]     })
[16:59:33.317]     if (TRUE) {
[16:59:33.317]         base::sink(type = "output", split = FALSE)
[16:59:33.317]         if (TRUE) {
[16:59:33.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.317]         }
[16:59:33.317]         else {
[16:59:33.317]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.317]         }
[16:59:33.317]         base::close(...future.stdout)
[16:59:33.317]         ...future.stdout <- NULL
[16:59:33.317]     }
[16:59:33.317]     ...future.result$conditions <- ...future.conditions
[16:59:33.317]     ...future.result$finished <- base::Sys.time()
[16:59:33.317]     ...future.result
[16:59:33.317] }
[16:59:33.321] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[16:59:33.321] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:33.321] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:33.321] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[16:59:33.364] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[16:59:33.364] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:59:33.365] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.365] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[16:59:33.365] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[16:59:33.365] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:33.366] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.366] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[16:59:33.366] MultisessionFuture started
[16:59:33.366] - Launch lazy future ... done
[16:59:33.366] run() for ‘MultisessionFuture’ ... done
[16:59:33.367] Created future:
[16:59:33.368] receiveMessageFromWorker() for ClusterFuture ...
[16:59:33.368] - Validating connection of MultisessionFuture
[16:59:33.368] - received message: FutureResult
[16:59:33.368] - Received FutureResult
[16:59:33.368] - Erased future from FutureRegistry
[16:59:33.369] result() for ClusterFuture ...
[16:59:33.369] - result already collected: FutureResult
[16:59:33.369] result() for ClusterFuture ... done
[16:59:33.369] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:33.367] MultisessionFuture:
[16:59:33.367] Label: ‘future_apply-1’
[16:59:33.367] Expression:
[16:59:33.367] {
[16:59:33.367]     do.call(function(...) {
[16:59:33.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.367]             on.exit(options(oopts), add = TRUE)
[16:59:33.367]         }
[16:59:33.367]         {
[16:59:33.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.367]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:33.367]                   envir = globalenv(), inherits = FALSE)
[16:59:33.367]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.367]             })
[16:59:33.367]         }
[16:59:33.367]     }, args = future.call.arguments)
[16:59:33.367] }
[16:59:33.367] Lazy evaluation: FALSE
[16:59:33.367] Asynchronous evaluation: TRUE
[16:59:33.367] Local evaluation: TRUE
[16:59:33.367] Environment: R_GlobalEnv
[16:59:33.367] Capture standard output: TRUE
[16:59:33.367] Capture condition classes: <none>
[16:59:33.367] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:33.367] Packages: <none>
[16:59:33.367] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:59:33.367] Resolved: TRUE
[16:59:33.367] Value: <not collected>
[16:59:33.367] Conditions captured: <none>
[16:59:33.367] Early signaling: FALSE
[16:59:33.367] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:33.367] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.369] Chunk #1 of 2 ... DONE
[16:59:33.369] Chunk #2 of 2 ...
[16:59:33.369]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[16:59:33.369]  - seeds: [1] <seeds>
[16:59:33.370]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.370] getGlobalsAndPackages() ...
[16:59:33.370] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.370] Resolving globals: FALSE
[16:59:33.370] Tweak future expression to call with '...' arguments ...
[16:59:33.370] {
[16:59:33.370]     do.call(function(...) {
[16:59:33.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.370]             on.exit(options(oopts), add = TRUE)
[16:59:33.370]         }
[16:59:33.370]         {
[16:59:33.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.370]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:33.370]                   envir = globalenv(), inherits = FALSE)
[16:59:33.370]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.370]             })
[16:59:33.370]         }
[16:59:33.370]     }, args = future.call.arguments)
[16:59:33.370] }
[16:59:33.370] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.371] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.371] 
[16:59:33.371] getGlobalsAndPackages() ... DONE
[16:59:33.371] run() for ‘Future’ ...
[16:59:33.371] - state: ‘created’
[16:59:33.372] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:33.385] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.385] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:33.386]   - Field: ‘node’
[16:59:33.386]   - Field: ‘label’
[16:59:33.386]   - Field: ‘local’
[16:59:33.386]   - Field: ‘owner’
[16:59:33.386]   - Field: ‘envir’
[16:59:33.386]   - Field: ‘workers’
[16:59:33.386]   - Field: ‘packages’
[16:59:33.386]   - Field: ‘gc’
[16:59:33.386]   - Field: ‘conditions’
[16:59:33.386]   - Field: ‘persistent’
[16:59:33.386]   - Field: ‘expr’
[16:59:33.387]   - Field: ‘uuid’
[16:59:33.387]   - Field: ‘seed’
[16:59:33.387]   - Field: ‘version’
[16:59:33.387]   - Field: ‘result’
[16:59:33.387]   - Field: ‘asynchronous’
[16:59:33.387]   - Field: ‘calls’
[16:59:33.387]   - Field: ‘globals’
[16:59:33.387]   - Field: ‘stdout’
[16:59:33.387]   - Field: ‘earlySignal’
[16:59:33.387]   - Field: ‘lazy’
[16:59:33.388]   - Field: ‘state’
[16:59:33.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:33.388] - Launch lazy future ...
[16:59:33.388] Packages needed by the future expression (n = 0): <none>
[16:59:33.388] Packages needed by future strategies (n = 0): <none>
[16:59:33.389] {
[16:59:33.389]     {
[16:59:33.389]         {
[16:59:33.389]             ...future.startTime <- base::Sys.time()
[16:59:33.389]             {
[16:59:33.389]                 {
[16:59:33.389]                   {
[16:59:33.389]                     {
[16:59:33.389]                       base::local({
[16:59:33.389]                         has_future <- base::requireNamespace("future", 
[16:59:33.389]                           quietly = TRUE)
[16:59:33.389]                         if (has_future) {
[16:59:33.389]                           ns <- base::getNamespace("future")
[16:59:33.389]                           version <- ns[[".package"]][["version"]]
[16:59:33.389]                           if (is.null(version)) 
[16:59:33.389]                             version <- utils::packageVersion("future")
[16:59:33.389]                         }
[16:59:33.389]                         else {
[16:59:33.389]                           version <- NULL
[16:59:33.389]                         }
[16:59:33.389]                         if (!has_future || version < "1.8.0") {
[16:59:33.389]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.389]                             "", base::R.version$version.string), 
[16:59:33.389]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.389]                               "release", "version")], collapse = " "), 
[16:59:33.389]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.389]                             info)
[16:59:33.389]                           info <- base::paste(info, collapse = "; ")
[16:59:33.389]                           if (!has_future) {
[16:59:33.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.389]                               info)
[16:59:33.389]                           }
[16:59:33.389]                           else {
[16:59:33.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.389]                               info, version)
[16:59:33.389]                           }
[16:59:33.389]                           base::stop(msg)
[16:59:33.389]                         }
[16:59:33.389]                       })
[16:59:33.389]                     }
[16:59:33.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:33.389]                     base::options(mc.cores = 1L)
[16:59:33.389]                   }
[16:59:33.389]                   ...future.strategy.old <- future::plan("list")
[16:59:33.389]                   options(future.plan = NULL)
[16:59:33.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.389]                 }
[16:59:33.389]                 ...future.workdir <- getwd()
[16:59:33.389]             }
[16:59:33.389]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.389]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.389]         }
[16:59:33.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.389]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[16:59:33.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.389]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.389]             base::names(...future.oldOptions))
[16:59:33.389]     }
[16:59:33.389]     if (FALSE) {
[16:59:33.389]     }
[16:59:33.389]     else {
[16:59:33.389]         if (TRUE) {
[16:59:33.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.389]                 open = "w")
[16:59:33.389]         }
[16:59:33.389]         else {
[16:59:33.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.389]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.389]         }
[16:59:33.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.389]             base::sink(type = "output", split = FALSE)
[16:59:33.389]             base::close(...future.stdout)
[16:59:33.389]         }, add = TRUE)
[16:59:33.389]     }
[16:59:33.389]     ...future.frame <- base::sys.nframe()
[16:59:33.389]     ...future.conditions <- base::list()
[16:59:33.389]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.389]     if (FALSE) {
[16:59:33.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.389]     }
[16:59:33.389]     ...future.result <- base::tryCatch({
[16:59:33.389]         base::withCallingHandlers({
[16:59:33.389]             ...future.value <- base::withVisible(base::local({
[16:59:33.389]                 ...future.makeSendCondition <- base::local({
[16:59:33.389]                   sendCondition <- NULL
[16:59:33.389]                   function(frame = 1L) {
[16:59:33.389]                     if (is.function(sendCondition)) 
[16:59:33.389]                       return(sendCondition)
[16:59:33.389]                     ns <- getNamespace("parallel")
[16:59:33.389]                     if (exists("sendData", mode = "function", 
[16:59:33.389]                       envir = ns)) {
[16:59:33.389]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:33.389]                         envir = ns)
[16:59:33.389]                       envir <- sys.frame(frame)
[16:59:33.389]                       master <- NULL
[16:59:33.389]                       while (!identical(envir, .GlobalEnv) && 
[16:59:33.389]                         !identical(envir, emptyenv())) {
[16:59:33.389]                         if (exists("master", mode = "list", envir = envir, 
[16:59:33.389]                           inherits = FALSE)) {
[16:59:33.389]                           master <- get("master", mode = "list", 
[16:59:33.389]                             envir = envir, inherits = FALSE)
[16:59:33.389]                           if (inherits(master, c("SOCKnode", 
[16:59:33.389]                             "SOCK0node"))) {
[16:59:33.389]                             sendCondition <<- function(cond) {
[16:59:33.389]                               data <- list(type = "VALUE", value = cond, 
[16:59:33.389]                                 success = TRUE)
[16:59:33.389]                               parallel_sendData(master, data)
[16:59:33.389]                             }
[16:59:33.389]                             return(sendCondition)
[16:59:33.389]                           }
[16:59:33.389]                         }
[16:59:33.389]                         frame <- frame + 1L
[16:59:33.389]                         envir <- sys.frame(frame)
[16:59:33.389]                       }
[16:59:33.389]                     }
[16:59:33.389]                     sendCondition <<- function(cond) NULL
[16:59:33.389]                   }
[16:59:33.389]                 })
[16:59:33.389]                 withCallingHandlers({
[16:59:33.389]                   {
[16:59:33.389]                     do.call(function(...) {
[16:59:33.389]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.389]                       if (!identical(...future.globals.maxSize.org, 
[16:59:33.389]                         ...future.globals.maxSize)) {
[16:59:33.389]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.389]                         on.exit(options(oopts), add = TRUE)
[16:59:33.389]                       }
[16:59:33.389]                       {
[16:59:33.389]                         lapply(seq_along(...future.elements_ii), 
[16:59:33.389]                           FUN = function(jj) {
[16:59:33.389]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.389]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:33.389]                               envir = globalenv(), inherits = FALSE)
[16:59:33.389]                             ...future.FUN(...future.X_jj, ...)
[16:59:33.389]                           })
[16:59:33.389]                       }
[16:59:33.389]                     }, args = future.call.arguments)
[16:59:33.389]                   }
[16:59:33.389]                 }, immediateCondition = function(cond) {
[16:59:33.389]                   sendCondition <- ...future.makeSendCondition()
[16:59:33.389]                   sendCondition(cond)
[16:59:33.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.389]                   {
[16:59:33.389]                     inherits <- base::inherits
[16:59:33.389]                     invokeRestart <- base::invokeRestart
[16:59:33.389]                     is.null <- base::is.null
[16:59:33.389]                     muffled <- FALSE
[16:59:33.389]                     if (inherits(cond, "message")) {
[16:59:33.389]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:33.389]                       if (muffled) 
[16:59:33.389]                         invokeRestart("muffleMessage")
[16:59:33.389]                     }
[16:59:33.389]                     else if (inherits(cond, "warning")) {
[16:59:33.389]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:33.389]                       if (muffled) 
[16:59:33.389]                         invokeRestart("muffleWarning")
[16:59:33.389]                     }
[16:59:33.389]                     else if (inherits(cond, "condition")) {
[16:59:33.389]                       if (!is.null(pattern)) {
[16:59:33.389]                         computeRestarts <- base::computeRestarts
[16:59:33.389]                         grepl <- base::grepl
[16:59:33.389]                         restarts <- computeRestarts(cond)
[16:59:33.389]                         for (restart in restarts) {
[16:59:33.389]                           name <- restart$name
[16:59:33.389]                           if (is.null(name)) 
[16:59:33.389]                             next
[16:59:33.389]                           if (!grepl(pattern, name)) 
[16:59:33.389]                             next
[16:59:33.389]                           invokeRestart(restart)
[16:59:33.389]                           muffled <- TRUE
[16:59:33.389]                           break
[16:59:33.389]                         }
[16:59:33.389]                       }
[16:59:33.389]                     }
[16:59:33.389]                     invisible(muffled)
[16:59:33.389]                   }
[16:59:33.389]                   muffleCondition(cond)
[16:59:33.389]                 })
[16:59:33.389]             }))
[16:59:33.389]             future::FutureResult(value = ...future.value$value, 
[16:59:33.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.389]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.389]                     ...future.globalenv.names))
[16:59:33.389]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.389]         }, condition = base::local({
[16:59:33.389]             c <- base::c
[16:59:33.389]             inherits <- base::inherits
[16:59:33.389]             invokeRestart <- base::invokeRestart
[16:59:33.389]             length <- base::length
[16:59:33.389]             list <- base::list
[16:59:33.389]             seq.int <- base::seq.int
[16:59:33.389]             signalCondition <- base::signalCondition
[16:59:33.389]             sys.calls <- base::sys.calls
[16:59:33.389]             `[[` <- base::`[[`
[16:59:33.389]             `+` <- base::`+`
[16:59:33.389]             `<<-` <- base::`<<-`
[16:59:33.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.389]                   3L)]
[16:59:33.389]             }
[16:59:33.389]             function(cond) {
[16:59:33.389]                 is_error <- inherits(cond, "error")
[16:59:33.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.389]                   NULL)
[16:59:33.389]                 if (is_error) {
[16:59:33.389]                   sessionInformation <- function() {
[16:59:33.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.389]                       search = base::search(), system = base::Sys.info())
[16:59:33.389]                   }
[16:59:33.389]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.389]                     cond$call), session = sessionInformation(), 
[16:59:33.389]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.389]                   signalCondition(cond)
[16:59:33.389]                 }
[16:59:33.389]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[16:59:33.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.389]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.389]                   if (TRUE && !signal) {
[16:59:33.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.389]                     {
[16:59:33.389]                       inherits <- base::inherits
[16:59:33.389]                       invokeRestart <- base::invokeRestart
[16:59:33.389]                       is.null <- base::is.null
[16:59:33.389]                       muffled <- FALSE
[16:59:33.389]                       if (inherits(cond, "message")) {
[16:59:33.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.389]                         if (muffled) 
[16:59:33.389]                           invokeRestart("muffleMessage")
[16:59:33.389]                       }
[16:59:33.389]                       else if (inherits(cond, "warning")) {
[16:59:33.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.389]                         if (muffled) 
[16:59:33.389]                           invokeRestart("muffleWarning")
[16:59:33.389]                       }
[16:59:33.389]                       else if (inherits(cond, "condition")) {
[16:59:33.389]                         if (!is.null(pattern)) {
[16:59:33.389]                           computeRestarts <- base::computeRestarts
[16:59:33.389]                           grepl <- base::grepl
[16:59:33.389]                           restarts <- computeRestarts(cond)
[16:59:33.389]                           for (restart in restarts) {
[16:59:33.389]                             name <- restart$name
[16:59:33.389]                             if (is.null(name)) 
[16:59:33.389]                               next
[16:59:33.389]                             if (!grepl(pattern, name)) 
[16:59:33.389]                               next
[16:59:33.389]                             invokeRestart(restart)
[16:59:33.389]                             muffled <- TRUE
[16:59:33.389]                             break
[16:59:33.389]                           }
[16:59:33.389]                         }
[16:59:33.389]                       }
[16:59:33.389]                       invisible(muffled)
[16:59:33.389]                     }
[16:59:33.389]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.389]                   }
[16:59:33.389]                 }
[16:59:33.389]                 else {
[16:59:33.389]                   if (TRUE) {
[16:59:33.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.389]                     {
[16:59:33.389]                       inherits <- base::inherits
[16:59:33.389]                       invokeRestart <- base::invokeRestart
[16:59:33.389]                       is.null <- base::is.null
[16:59:33.389]                       muffled <- FALSE
[16:59:33.389]                       if (inherits(cond, "message")) {
[16:59:33.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.389]                         if (muffled) 
[16:59:33.389]                           invokeRestart("muffleMessage")
[16:59:33.389]                       }
[16:59:33.389]                       else if (inherits(cond, "warning")) {
[16:59:33.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.389]                         if (muffled) 
[16:59:33.389]                           invokeRestart("muffleWarning")
[16:59:33.389]                       }
[16:59:33.389]                       else if (inherits(cond, "condition")) {
[16:59:33.389]                         if (!is.null(pattern)) {
[16:59:33.389]                           computeRestarts <- base::computeRestarts
[16:59:33.389]                           grepl <- base::grepl
[16:59:33.389]                           restarts <- computeRestarts(cond)
[16:59:33.389]                           for (restart in restarts) {
[16:59:33.389]                             name <- restart$name
[16:59:33.389]                             if (is.null(name)) 
[16:59:33.389]                               next
[16:59:33.389]                             if (!grepl(pattern, name)) 
[16:59:33.389]                               next
[16:59:33.389]                             invokeRestart(restart)
[16:59:33.389]                             muffled <- TRUE
[16:59:33.389]                             break
[16:59:33.389]                           }
[16:59:33.389]                         }
[16:59:33.389]                       }
[16:59:33.389]                       invisible(muffled)
[16:59:33.389]                     }
[16:59:33.389]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.389]                   }
[16:59:33.389]                 }
[16:59:33.389]             }
[16:59:33.389]         }))
[16:59:33.389]     }, error = function(ex) {
[16:59:33.389]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.389]                 ...future.rng), started = ...future.startTime, 
[16:59:33.389]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.389]             version = "1.8"), class = "FutureResult")
[16:59:33.389]     }, finally = {
[16:59:33.389]         if (!identical(...future.workdir, getwd())) 
[16:59:33.389]             setwd(...future.workdir)
[16:59:33.389]         {
[16:59:33.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.389]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.389]             }
[16:59:33.389]             base::options(...future.oldOptions)
[16:59:33.389]             if (.Platform$OS.type == "windows") {
[16:59:33.389]                 old_names <- names(...future.oldEnvVars)
[16:59:33.389]                 envs <- base::Sys.getenv()
[16:59:33.389]                 names <- names(envs)
[16:59:33.389]                 common <- intersect(names, old_names)
[16:59:33.389]                 added <- setdiff(names, old_names)
[16:59:33.389]                 removed <- setdiff(old_names, names)
[16:59:33.389]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.389]                   envs[common]]
[16:59:33.389]                 NAMES <- toupper(changed)
[16:59:33.389]                 args <- list()
[16:59:33.389]                 for (kk in seq_along(NAMES)) {
[16:59:33.389]                   name <- changed[[kk]]
[16:59:33.389]                   NAME <- NAMES[[kk]]
[16:59:33.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.389]                     next
[16:59:33.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.389]                 }
[16:59:33.389]                 NAMES <- toupper(added)
[16:59:33.389]                 for (kk in seq_along(NAMES)) {
[16:59:33.389]                   name <- added[[kk]]
[16:59:33.389]                   NAME <- NAMES[[kk]]
[16:59:33.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.389]                     next
[16:59:33.389]                   args[[name]] <- ""
[16:59:33.389]                 }
[16:59:33.389]                 NAMES <- toupper(removed)
[16:59:33.389]                 for (kk in seq_along(NAMES)) {
[16:59:33.389]                   name <- removed[[kk]]
[16:59:33.389]                   NAME <- NAMES[[kk]]
[16:59:33.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.389]                     next
[16:59:33.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.389]                 }
[16:59:33.389]                 if (length(args) > 0) 
[16:59:33.389]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.389]             }
[16:59:33.389]             else {
[16:59:33.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.389]             }
[16:59:33.389]             {
[16:59:33.389]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.389]                   0L) {
[16:59:33.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.389]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.389]                   base::options(opts)
[16:59:33.389]                 }
[16:59:33.389]                 {
[16:59:33.389]                   {
[16:59:33.389]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:33.389]                     NULL
[16:59:33.389]                   }
[16:59:33.389]                   options(future.plan = NULL)
[16:59:33.389]                   if (is.na(NA_character_)) 
[16:59:33.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.389]                     .init = FALSE)
[16:59:33.389]                 }
[16:59:33.389]             }
[16:59:33.389]         }
[16:59:33.389]     })
[16:59:33.389]     if (TRUE) {
[16:59:33.389]         base::sink(type = "output", split = FALSE)
[16:59:33.389]         if (TRUE) {
[16:59:33.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.389]         }
[16:59:33.389]         else {
[16:59:33.389]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.389]         }
[16:59:33.389]         base::close(...future.stdout)
[16:59:33.389]         ...future.stdout <- NULL
[16:59:33.389]     }
[16:59:33.389]     ...future.result$conditions <- ...future.conditions
[16:59:33.389]     ...future.result$finished <- base::Sys.time()
[16:59:33.389]     ...future.result
[16:59:33.389] }
[16:59:33.392] Exporting 5 global objects (35.63 KiB) to cluster node #1 ...
[16:59:33.392] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:33.392] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:33.392] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ...
[16:59:33.436] Exporting ‘...future.FUN’ (35.45 KiB) to cluster node #1 ... DONE
[16:59:33.436] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:59:33.437] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.437] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[16:59:33.437] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[16:59:33.437] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ...
[16:59:33.437] Exporting ‘...future.globals.maxSize’ (56 bytes) to cluster node #1 ... DONE
[16:59:33.438] Exporting 5 global objects (35.63 KiB) to cluster node #1 ... DONE
[16:59:33.438] MultisessionFuture started
[16:59:33.438] - Launch lazy future ... done
[16:59:33.438] run() for ‘MultisessionFuture’ ... done
[16:59:33.438] Created future:
[16:59:33.440] receiveMessageFromWorker() for ClusterFuture ...
[16:59:33.440] - Validating connection of MultisessionFuture
[16:59:33.440] - received message: FutureResult
[16:59:33.440] - Received FutureResult
[16:59:33.440] - Erased future from FutureRegistry
[16:59:33.441] result() for ClusterFuture ...
[16:59:33.441] - result already collected: FutureResult
[16:59:33.441] result() for ClusterFuture ... done
[16:59:33.441] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:33.439] MultisessionFuture:
[16:59:33.439] Label: ‘future_apply-2’
[16:59:33.439] Expression:
[16:59:33.439] {
[16:59:33.439]     do.call(function(...) {
[16:59:33.439]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.439]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.439]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.439]             on.exit(options(oopts), add = TRUE)
[16:59:33.439]         }
[16:59:33.439]         {
[16:59:33.439]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.439]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.439]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[16:59:33.439]                   envir = globalenv(), inherits = FALSE)
[16:59:33.439]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.439]             })
[16:59:33.439]         }
[16:59:33.439]     }, args = future.call.arguments)
[16:59:33.439] }
[16:59:33.439] Lazy evaluation: FALSE
[16:59:33.439] Asynchronous evaluation: TRUE
[16:59:33.439] Local evaluation: TRUE
[16:59:33.439] Environment: R_GlobalEnv
[16:59:33.439] Capture standard output: TRUE
[16:59:33.439] Capture condition classes: <none>
[16:59:33.439] Globals: 5 objects totaling 35.63 KiB (DotDotDotList ‘future.call.arguments’ of 0 bytes, function ‘...future.FUN’ of 35.45 KiB, list ‘...future.elements_ii’ of 56 bytes, list ‘...future.seeds_ii’ of 80 bytes, numeric ‘...future.globals.maxSize’ of 56 bytes)
[16:59:33.439] Packages: <none>
[16:59:33.439] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[16:59:33.439] Resolved: TRUE
[16:59:33.439] Value: <not collected>
[16:59:33.439] Conditions captured: <none>
[16:59:33.439] Early signaling: FALSE
[16:59:33.439] Owner process: d5e68531-d029-ef10-f4e2-f4de09b7cfce
[16:59:33.439] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:33.441] Chunk #2 of 2 ... DONE
[16:59:33.441] Launching 2 futures (chunks) ... DONE
[16:59:33.441] Resolving 2 futures (chunks) ...
[16:59:33.441] resolve() on list ...
[16:59:33.441]  recursive: 0
[16:59:33.442]  length: 2
[16:59:33.442] 
[16:59:33.442] Future #1
[16:59:33.442] result() for ClusterFuture ...
[16:59:33.442] - result already collected: FutureResult
[16:59:33.442] result() for ClusterFuture ... done
[16:59:33.442] result() for ClusterFuture ...
[16:59:33.442] - result already collected: FutureResult
[16:59:33.442] result() for ClusterFuture ... done
[16:59:33.442] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:33.442] - nx: 2
[16:59:33.442] - relay: TRUE
[16:59:33.443] - stdout: TRUE
[16:59:33.443] - signal: TRUE
[16:59:33.443] - resignal: FALSE
[16:59:33.443] - force: TRUE
[16:59:33.443] - relayed: [n=2] FALSE, FALSE
[16:59:33.443] - queued futures: [n=2] FALSE, FALSE
[16:59:33.443]  - until=1
[16:59:33.443]  - relaying element #1
[16:59:33.443] result() for ClusterFuture ...
[16:59:33.443] - result already collected: FutureResult
[16:59:33.443] result() for ClusterFuture ... done
[16:59:33.444] result() for ClusterFuture ...
[16:59:33.444] - result already collected: FutureResult
[16:59:33.444] result() for ClusterFuture ... done
[16:59:33.444] result() for ClusterFuture ...
[16:59:33.444] - result already collected: FutureResult
[16:59:33.444] result() for ClusterFuture ... done
[16:59:33.444] result() for ClusterFuture ...
[16:59:33.444] - result already collected: FutureResult
[16:59:33.444] result() for ClusterFuture ... done
[16:59:33.444] - relayed: [n=2] TRUE, FALSE
[16:59:33.444] - queued futures: [n=2] TRUE, FALSE
[16:59:33.444] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:33.445]  length: 1 (resolved future 1)
[16:59:33.445] Future #2
[16:59:33.445] result() for ClusterFuture ...
[16:59:33.445] - result already collected: FutureResult
[16:59:33.445] result() for ClusterFuture ... done
[16:59:33.445] result() for ClusterFuture ...
[16:59:33.445] - result already collected: FutureResult
[16:59:33.445] result() for ClusterFuture ... done
[16:59:33.445] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:33.445] - nx: 2
[16:59:33.445] - relay: TRUE
[16:59:33.446] - stdout: TRUE
[16:59:33.446] - signal: TRUE
[16:59:33.446] - resignal: FALSE
[16:59:33.446] - force: TRUE
[16:59:33.446] - relayed: [n=2] TRUE, FALSE
[16:59:33.446] - queued futures: [n=2] TRUE, FALSE
[16:59:33.446]  - until=2
[16:59:33.446]  - relaying element #2
[16:59:33.446] result() for ClusterFuture ...
[16:59:33.446] - result already collected: FutureResult
[16:59:33.446] result() for ClusterFuture ... done
[16:59:33.446] result() for ClusterFuture ...
[16:59:33.446] - result already collected: FutureResult
[16:59:33.447] result() for ClusterFuture ... done
[16:59:33.447] result() for ClusterFuture ...
[16:59:33.447] - result already collected: FutureResult
[16:59:33.447] result() for ClusterFuture ... done
[16:59:33.447] result() for ClusterFuture ...
[16:59:33.447] - result already collected: FutureResult
[16:59:33.447] result() for ClusterFuture ... done
[16:59:33.447] - relayed: [n=2] TRUE, TRUE
[16:59:33.447] - queued futures: [n=2] TRUE, TRUE
[16:59:33.447] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:33.447]  length: 0 (resolved future 2)
[16:59:33.448] Relaying remaining futures
[16:59:33.448] signalConditionsASAP(NULL, pos=0) ...
[16:59:33.448] - nx: 2
[16:59:33.448] - relay: TRUE
[16:59:33.448] - stdout: TRUE
[16:59:33.448] - signal: TRUE
[16:59:33.448] - resignal: FALSE
[16:59:33.448] - force: TRUE
[16:59:33.448] - relayed: [n=2] TRUE, TRUE
[16:59:33.448] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:33.448] - relayed: [n=2] TRUE, TRUE
[16:59:33.448] - queued futures: [n=2] TRUE, TRUE
[16:59:33.449] signalConditionsASAP(NULL, pos=0) ... done
[16:59:33.449] resolve() on list ... DONE
[16:59:33.449] result() for ClusterFuture ...
[16:59:33.449] - result already collected: FutureResult
[16:59:33.449] result() for ClusterFuture ... done
[16:59:33.449] result() for ClusterFuture ...
[16:59:33.449] - result already collected: FutureResult
[16:59:33.449] result() for ClusterFuture ... done
[16:59:33.449] result() for ClusterFuture ...
[16:59:33.449] - result already collected: FutureResult
[16:59:33.449] result() for ClusterFuture ... done
[16:59:33.452] result() for ClusterFuture ...
[16:59:33.452] - result already collected: FutureResult
[16:59:33.452] result() for ClusterFuture ... done
[16:59:33.452]  - Number of value chunks collected: 2
[16:59:33.452] Resolving 2 futures (chunks) ... DONE
[16:59:33.452] Reducing values from 2 chunks ...
[16:59:33.452]  - Number of values collected after concatenation: 2
[16:59:33.452]  - Number of values expected: 2
[16:59:33.453] Reducing values from 2 chunks ... DONE
[16:59:33.453] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[16:59:33.453] plan(): Setting new future strategy stack:
[16:59:33.453] List of future strategies:
[16:59:33.453] 1. sequential:
[16:59:33.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.453]    - tweaked: FALSE
[16:59:33.453]    - call: plan(sequential)
[16:59:33.454] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[16:59:33.456] plan(): Setting new future strategy stack:
[16:59:33.456] List of future strategies:
[16:59:33.456] 1. FutureStrategy:
[16:59:33.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.456]    - tweaked: FALSE
[16:59:33.456]    - call: future::plan(oplan)
[16:59:33.456] plan(): nbrOfWorkers() = 1
> 
