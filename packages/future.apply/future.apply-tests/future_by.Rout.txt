
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:59:33.750] plan(): Setting new future strategy stack:
[16:59:33.751] List of future strategies:
[16:59:33.751] 1. sequential:
[16:59:33.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.751]    - tweaked: FALSE
[16:59:33.751]    - call: future::plan("sequential")
[16:59:33.765] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> all_equal_but_call <- function(target, current, ...) {
+   attr(target, "call") <- NULL
+   attr(current, "call") <- NULL
+   all.equal(target = target, current = current, ...)
+ }
> 
> message("*** future_by() ...")
*** future_by() ...
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> if (require("datasets") && require("stats")) { ## warpbreaks & lm()
+   ## Use a local variable to test that it is properly exported, because
+   ## 'warpbreaks' is available in all R sessions
+   data <- warpbreaks
+   
+   y0 <- by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+   y1 <- by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+   y2 <- by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+     lm(breaks ~ wool, data = x, ...)
+   }, singular.ok = FALSE)
+   
+   ## now suppose we want to extract the coefficients by group
+   tmp <- with(data, by(data, INDICES = tension, FUN = function(x) {
+     lm(breaks ~ wool, data = x)
+   }))
+   y3 <- sapply(tmp, coef)
+ 
+   ## Source: {r-source}/tests/reg-tests-1d.R
+   by2 <- function(data, INDICES, FUN) {
+     by(data, INDICES = INDICES, FUN = FUN)
+   }
+   future_by2 <- function(data, INDICES, FUN) {
+     future_by(data, INDICES = INDICES, FUN = FUN)
+   }
+   y4 <- by2(data, INDICES = data[,"tension"], FUN = summary)
+ 
+   for (cores in 1:availCores) {
+     message(sprintf("Testing with %d cores ...", cores))
+     options(mc.cores = cores)
+     strategies <- supportedStrategies(cores)
+   
+     for (strategy in supportedStrategies()) {
+       message(sprintf("- plan('%s') ...", strategy))
+       plan(strategy)
+     
+       y0f <- future_by(data[, 1:2], INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y0f, y0, check.attributes = FALSE))
+       
+       y1f <- future_by(data[, 1], INDICES = data[, -1], FUN = summary, digits = 2L)
+       stopifnot(all_equal_but_call(y1f, y1))
+       
+       y2f <- future_by(data, INDICES = data[,"tension"], FUN = function(x, ...) {
+         lm(breaks ~ wool, data = x, ...)
+       }, singular.ok = FALSE)
+       stopifnot(all_equal_but_call(y2f, y2))
+       
+       ## now suppose we want to extract the coefficients by group
+       tmp <- with(data, future_by(data, INDICES = tension, FUN = function(x) {
+         lm(breaks ~ wool, data = x)
+       }))
+       y3f <- sapply(tmp, coef)
+       stopifnot(all_equal_but_call(y3f, y3))
+       
+       y4f <- future_by2(data, INDICES = data[,"tension"], FUN = summary)
+       stopifnot(all_equal_but_call(y4f, y4))
+ 
+       ## Deprecated /HB 2022-10-24
+       y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       stopifnot(all_equal_but_call(y4f2, y4))
+ 
+       res <- tryCatch({
+         y4f2 <- future_by2(data, INDICES = data[,"tension"], FUN = "summary")
+       }, warning = identity)
+       stopifnot(inherits(res, "warning"))
+       if (getRversion() >= "3.6.0") {
+         stopifnot(inherits(res, "deprecatedWarning"))
+       }
+     } ## for (strategy ...)
+     
+     message(sprintf("Testing with %d cores ... DONE", cores))
+   } ## for (cores ...)
+ } ## if (require("stats"))
Testing with 1 cores ...
- plan('sequential') ...
[16:59:33.821] plan(): Setting new future strategy stack:
[16:59:33.821] List of future strategies:
[16:59:33.821] 1. sequential:
[16:59:33.821]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.821]    - tweaked: FALSE
[16:59:33.821]    - call: plan(strategy)
[16:59:33.834] plan(): nbrOfWorkers() = 1
[16:59:33.834] future_by_internal() ...
[16:59:33.835] future_lapply() ...
[16:59:33.839] Number of chunks: 1
[16:59:33.839] getGlobalsAndPackagesXApply() ...
[16:59:33.839]  - future.globals: TRUE
[16:59:33.840] getGlobalsAndPackages() ...
[16:59:33.840] Searching for globals...
[16:59:33.842] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:33.842] Searching for globals ... DONE
[16:59:33.842] Resolving globals: FALSE
[16:59:33.843] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:33.843] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:33.844] - globals: [1] ‘FUN’
[16:59:33.844] 
[16:59:33.844] getGlobalsAndPackages() ... DONE
[16:59:33.844]  - globals found/used: [n=1] ‘FUN’
[16:59:33.844]  - needed namespaces: [n=0] 
[16:59:33.844] Finding globals ... DONE
[16:59:33.844]  - use_args: TRUE
[16:59:33.844]  - Getting '...' globals ...
[16:59:33.845] resolve() on list ...
[16:59:33.845]  recursive: 0
[16:59:33.845]  length: 1
[16:59:33.845]  elements: ‘...’
[16:59:33.846]  length: 0 (resolved future 1)
[16:59:33.846] resolve() on list ... DONE
[16:59:33.846]    - '...' content: [n=0] 
[16:59:33.846] List of 1
[16:59:33.846]  $ ...: list()
[16:59:33.846]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.846]  - attr(*, "where")=List of 1
[16:59:33.846]   ..$ ...:<environment: 0x5620511fe9e0> 
[16:59:33.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.846]  - attr(*, "resolved")= logi TRUE
[16:59:33.846]  - attr(*, "total_size")= num NA
[16:59:33.850]  - Getting '...' globals ... DONE
[16:59:33.850] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:33.850] List of 2
[16:59:33.850]  $ ...future.FUN:function (object, ...)  
[16:59:33.850]  $ ...          : list()
[16:59:33.850]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.850]  - attr(*, "where")=List of 2
[16:59:33.850]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.850]   ..$ ...          :<environment: 0x5620511fe9e0> 
[16:59:33.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.850]  - attr(*, "resolved")= logi FALSE
[16:59:33.850]  - attr(*, "total_size")= num 1240
[16:59:33.853] Packages to be attached in all futures: [n=0] 
[16:59:33.853] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.853] Number of futures (= number of chunks): 1
[16:59:33.853] Launching 1 futures (chunks) ...
[16:59:33.853] Chunk #1 of 1 ...
[16:59:33.854]  - Finding globals in 'X' for chunk #1 ...
[16:59:33.854] getGlobalsAndPackages() ...
[16:59:33.854] Searching for globals...
[16:59:33.854] 
[16:59:33.854] Searching for globals ... DONE
[16:59:33.855] - globals: [0] <none>
[16:59:33.855] getGlobalsAndPackages() ... DONE
[16:59:33.855]    + additional globals found: [n=0] 
[16:59:33.855]    + additional namespaces needed: [n=0] 
[16:59:33.855]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:33.855]  - seeds: <none>
[16:59:33.855]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.855] getGlobalsAndPackages() ...
[16:59:33.855] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.855] Resolving globals: FALSE
[16:59:33.856] Tweak future expression to call with '...' arguments ...
[16:59:33.856] {
[16:59:33.856]     do.call(function(...) {
[16:59:33.856]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.856]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.856]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.856]             on.exit(options(oopts), add = TRUE)
[16:59:33.856]         }
[16:59:33.856]         {
[16:59:33.856]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.856]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.856]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.856]             })
[16:59:33.856]         }
[16:59:33.856]     }, args = future.call.arguments)
[16:59:33.856] }
[16:59:33.856] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.856] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.856] 
[16:59:33.856] getGlobalsAndPackages() ... DONE
[16:59:33.857] run() for ‘Future’ ...
[16:59:33.857] - state: ‘created’
[16:59:33.857] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:33.858] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:33.858]   - Field: ‘label’
[16:59:33.858]   - Field: ‘local’
[16:59:33.858]   - Field: ‘owner’
[16:59:33.858]   - Field: ‘envir’
[16:59:33.858]   - Field: ‘packages’
[16:59:33.858]   - Field: ‘gc’
[16:59:33.859]   - Field: ‘conditions’
[16:59:33.859]   - Field: ‘expr’
[16:59:33.859]   - Field: ‘uuid’
[16:59:33.859]   - Field: ‘seed’
[16:59:33.859]   - Field: ‘version’
[16:59:33.859]   - Field: ‘result’
[16:59:33.859]   - Field: ‘asynchronous’
[16:59:33.859]   - Field: ‘calls’
[16:59:33.859]   - Field: ‘globals’
[16:59:33.859]   - Field: ‘stdout’
[16:59:33.859]   - Field: ‘earlySignal’
[16:59:33.860]   - Field: ‘lazy’
[16:59:33.860]   - Field: ‘state’
[16:59:33.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:33.860] - Launch lazy future ...
[16:59:33.861] Packages needed by the future expression (n = 0): <none>
[16:59:33.861] Packages needed by future strategies (n = 0): <none>
[16:59:33.861] {
[16:59:33.861]     {
[16:59:33.861]         {
[16:59:33.861]             ...future.startTime <- base::Sys.time()
[16:59:33.861]             {
[16:59:33.861]                 {
[16:59:33.861]                   {
[16:59:33.861]                     base::local({
[16:59:33.861]                       has_future <- base::requireNamespace("future", 
[16:59:33.861]                         quietly = TRUE)
[16:59:33.861]                       if (has_future) {
[16:59:33.861]                         ns <- base::getNamespace("future")
[16:59:33.861]                         version <- ns[[".package"]][["version"]]
[16:59:33.861]                         if (is.null(version)) 
[16:59:33.861]                           version <- utils::packageVersion("future")
[16:59:33.861]                       }
[16:59:33.861]                       else {
[16:59:33.861]                         version <- NULL
[16:59:33.861]                       }
[16:59:33.861]                       if (!has_future || version < "1.8.0") {
[16:59:33.861]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.861]                           "", base::R.version$version.string), 
[16:59:33.861]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:33.861]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.861]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.861]                             "release", "version")], collapse = " "), 
[16:59:33.861]                           hostname = base::Sys.info()[["nodename"]])
[16:59:33.861]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.861]                           info)
[16:59:33.861]                         info <- base::paste(info, collapse = "; ")
[16:59:33.861]                         if (!has_future) {
[16:59:33.861]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.861]                             info)
[16:59:33.861]                         }
[16:59:33.861]                         else {
[16:59:33.861]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.861]                             info, version)
[16:59:33.861]                         }
[16:59:33.861]                         base::stop(msg)
[16:59:33.861]                       }
[16:59:33.861]                     })
[16:59:33.861]                   }
[16:59:33.861]                   ...future.strategy.old <- future::plan("list")
[16:59:33.861]                   options(future.plan = NULL)
[16:59:33.861]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.861]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.861]                 }
[16:59:33.861]                 ...future.workdir <- getwd()
[16:59:33.861]             }
[16:59:33.861]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.861]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.861]         }
[16:59:33.861]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.861]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:33.861]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.861]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.861]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.861]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.861]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.861]             base::names(...future.oldOptions))
[16:59:33.861]     }
[16:59:33.861]     if (FALSE) {
[16:59:33.861]     }
[16:59:33.861]     else {
[16:59:33.861]         if (TRUE) {
[16:59:33.861]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.861]                 open = "w")
[16:59:33.861]         }
[16:59:33.861]         else {
[16:59:33.861]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.861]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.861]         }
[16:59:33.861]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.861]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.861]             base::sink(type = "output", split = FALSE)
[16:59:33.861]             base::close(...future.stdout)
[16:59:33.861]         }, add = TRUE)
[16:59:33.861]     }
[16:59:33.861]     ...future.frame <- base::sys.nframe()
[16:59:33.861]     ...future.conditions <- base::list()
[16:59:33.861]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.861]     if (FALSE) {
[16:59:33.861]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.861]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.861]     }
[16:59:33.861]     ...future.result <- base::tryCatch({
[16:59:33.861]         base::withCallingHandlers({
[16:59:33.861]             ...future.value <- base::withVisible(base::local({
[16:59:33.861]                 do.call(function(...) {
[16:59:33.861]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.861]                   if (!identical(...future.globals.maxSize.org, 
[16:59:33.861]                     ...future.globals.maxSize)) {
[16:59:33.861]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.861]                     on.exit(options(oopts), add = TRUE)
[16:59:33.861]                   }
[16:59:33.861]                   {
[16:59:33.861]                     lapply(seq_along(...future.elements_ii), 
[16:59:33.861]                       FUN = function(jj) {
[16:59:33.861]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.861]                         ...future.FUN(...future.X_jj, ...)
[16:59:33.861]                       })
[16:59:33.861]                   }
[16:59:33.861]                 }, args = future.call.arguments)
[16:59:33.861]             }))
[16:59:33.861]             future::FutureResult(value = ...future.value$value, 
[16:59:33.861]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.861]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.861]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.861]                     ...future.globalenv.names))
[16:59:33.861]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.861]         }, condition = base::local({
[16:59:33.861]             c <- base::c
[16:59:33.861]             inherits <- base::inherits
[16:59:33.861]             invokeRestart <- base::invokeRestart
[16:59:33.861]             length <- base::length
[16:59:33.861]             list <- base::list
[16:59:33.861]             seq.int <- base::seq.int
[16:59:33.861]             signalCondition <- base::signalCondition
[16:59:33.861]             sys.calls <- base::sys.calls
[16:59:33.861]             `[[` <- base::`[[`
[16:59:33.861]             `+` <- base::`+`
[16:59:33.861]             `<<-` <- base::`<<-`
[16:59:33.861]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.861]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.861]                   3L)]
[16:59:33.861]             }
[16:59:33.861]             function(cond) {
[16:59:33.861]                 is_error <- inherits(cond, "error")
[16:59:33.861]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.861]                   NULL)
[16:59:33.861]                 if (is_error) {
[16:59:33.861]                   sessionInformation <- function() {
[16:59:33.861]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.861]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.861]                       search = base::search(), system = base::Sys.info())
[16:59:33.861]                   }
[16:59:33.861]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.861]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.861]                     cond$call), session = sessionInformation(), 
[16:59:33.861]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.861]                   signalCondition(cond)
[16:59:33.861]                 }
[16:59:33.861]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.861]                 "immediateCondition"))) {
[16:59:33.861]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.861]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.861]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.861]                   if (TRUE && !signal) {
[16:59:33.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.861]                     {
[16:59:33.861]                       inherits <- base::inherits
[16:59:33.861]                       invokeRestart <- base::invokeRestart
[16:59:33.861]                       is.null <- base::is.null
[16:59:33.861]                       muffled <- FALSE
[16:59:33.861]                       if (inherits(cond, "message")) {
[16:59:33.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.861]                         if (muffled) 
[16:59:33.861]                           invokeRestart("muffleMessage")
[16:59:33.861]                       }
[16:59:33.861]                       else if (inherits(cond, "warning")) {
[16:59:33.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.861]                         if (muffled) 
[16:59:33.861]                           invokeRestart("muffleWarning")
[16:59:33.861]                       }
[16:59:33.861]                       else if (inherits(cond, "condition")) {
[16:59:33.861]                         if (!is.null(pattern)) {
[16:59:33.861]                           computeRestarts <- base::computeRestarts
[16:59:33.861]                           grepl <- base::grepl
[16:59:33.861]                           restarts <- computeRestarts(cond)
[16:59:33.861]                           for (restart in restarts) {
[16:59:33.861]                             name <- restart$name
[16:59:33.861]                             if (is.null(name)) 
[16:59:33.861]                               next
[16:59:33.861]                             if (!grepl(pattern, name)) 
[16:59:33.861]                               next
[16:59:33.861]                             invokeRestart(restart)
[16:59:33.861]                             muffled <- TRUE
[16:59:33.861]                             break
[16:59:33.861]                           }
[16:59:33.861]                         }
[16:59:33.861]                       }
[16:59:33.861]                       invisible(muffled)
[16:59:33.861]                     }
[16:59:33.861]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.861]                   }
[16:59:33.861]                 }
[16:59:33.861]                 else {
[16:59:33.861]                   if (TRUE) {
[16:59:33.861]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.861]                     {
[16:59:33.861]                       inherits <- base::inherits
[16:59:33.861]                       invokeRestart <- base::invokeRestart
[16:59:33.861]                       is.null <- base::is.null
[16:59:33.861]                       muffled <- FALSE
[16:59:33.861]                       if (inherits(cond, "message")) {
[16:59:33.861]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.861]                         if (muffled) 
[16:59:33.861]                           invokeRestart("muffleMessage")
[16:59:33.861]                       }
[16:59:33.861]                       else if (inherits(cond, "warning")) {
[16:59:33.861]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.861]                         if (muffled) 
[16:59:33.861]                           invokeRestart("muffleWarning")
[16:59:33.861]                       }
[16:59:33.861]                       else if (inherits(cond, "condition")) {
[16:59:33.861]                         if (!is.null(pattern)) {
[16:59:33.861]                           computeRestarts <- base::computeRestarts
[16:59:33.861]                           grepl <- base::grepl
[16:59:33.861]                           restarts <- computeRestarts(cond)
[16:59:33.861]                           for (restart in restarts) {
[16:59:33.861]                             name <- restart$name
[16:59:33.861]                             if (is.null(name)) 
[16:59:33.861]                               next
[16:59:33.861]                             if (!grepl(pattern, name)) 
[16:59:33.861]                               next
[16:59:33.861]                             invokeRestart(restart)
[16:59:33.861]                             muffled <- TRUE
[16:59:33.861]                             break
[16:59:33.861]                           }
[16:59:33.861]                         }
[16:59:33.861]                       }
[16:59:33.861]                       invisible(muffled)
[16:59:33.861]                     }
[16:59:33.861]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.861]                   }
[16:59:33.861]                 }
[16:59:33.861]             }
[16:59:33.861]         }))
[16:59:33.861]     }, error = function(ex) {
[16:59:33.861]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.861]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.861]                 ...future.rng), started = ...future.startTime, 
[16:59:33.861]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.861]             version = "1.8"), class = "FutureResult")
[16:59:33.861]     }, finally = {
[16:59:33.861]         if (!identical(...future.workdir, getwd())) 
[16:59:33.861]             setwd(...future.workdir)
[16:59:33.861]         {
[16:59:33.861]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.861]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.861]             }
[16:59:33.861]             base::options(...future.oldOptions)
[16:59:33.861]             if (.Platform$OS.type == "windows") {
[16:59:33.861]                 old_names <- names(...future.oldEnvVars)
[16:59:33.861]                 envs <- base::Sys.getenv()
[16:59:33.861]                 names <- names(envs)
[16:59:33.861]                 common <- intersect(names, old_names)
[16:59:33.861]                 added <- setdiff(names, old_names)
[16:59:33.861]                 removed <- setdiff(old_names, names)
[16:59:33.861]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.861]                   envs[common]]
[16:59:33.861]                 NAMES <- toupper(changed)
[16:59:33.861]                 args <- list()
[16:59:33.861]                 for (kk in seq_along(NAMES)) {
[16:59:33.861]                   name <- changed[[kk]]
[16:59:33.861]                   NAME <- NAMES[[kk]]
[16:59:33.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.861]                     next
[16:59:33.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.861]                 }
[16:59:33.861]                 NAMES <- toupper(added)
[16:59:33.861]                 for (kk in seq_along(NAMES)) {
[16:59:33.861]                   name <- added[[kk]]
[16:59:33.861]                   NAME <- NAMES[[kk]]
[16:59:33.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.861]                     next
[16:59:33.861]                   args[[name]] <- ""
[16:59:33.861]                 }
[16:59:33.861]                 NAMES <- toupper(removed)
[16:59:33.861]                 for (kk in seq_along(NAMES)) {
[16:59:33.861]                   name <- removed[[kk]]
[16:59:33.861]                   NAME <- NAMES[[kk]]
[16:59:33.861]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.861]                     next
[16:59:33.861]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.861]                 }
[16:59:33.861]                 if (length(args) > 0) 
[16:59:33.861]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.861]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.861]             }
[16:59:33.861]             else {
[16:59:33.861]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.861]             }
[16:59:33.861]             {
[16:59:33.861]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.861]                   0L) {
[16:59:33.861]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.861]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.861]                   base::options(opts)
[16:59:33.861]                 }
[16:59:33.861]                 {
[16:59:33.861]                   {
[16:59:33.861]                     NULL
[16:59:33.861]                     RNGkind("Mersenne-Twister")
[16:59:33.861]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:33.861]                       inherits = FALSE)
[16:59:33.861]                   }
[16:59:33.861]                   options(future.plan = NULL)
[16:59:33.861]                   if (is.na(NA_character_)) 
[16:59:33.861]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.861]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.861]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.861]                     .init = FALSE)
[16:59:33.861]                 }
[16:59:33.861]             }
[16:59:33.861]         }
[16:59:33.861]     })
[16:59:33.861]     if (TRUE) {
[16:59:33.861]         base::sink(type = "output", split = FALSE)
[16:59:33.861]         if (TRUE) {
[16:59:33.861]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.861]         }
[16:59:33.861]         else {
[16:59:33.861]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.861]         }
[16:59:33.861]         base::close(...future.stdout)
[16:59:33.861]         ...future.stdout <- NULL
[16:59:33.861]     }
[16:59:33.861]     ...future.result$conditions <- ...future.conditions
[16:59:33.861]     ...future.result$finished <- base::Sys.time()
[16:59:33.861]     ...future.result
[16:59:33.861] }
[16:59:33.864] assign_globals() ...
[16:59:33.864] List of 5
[16:59:33.864]  $ ...future.FUN            :function (object, ...)  
[16:59:33.864]  $ future.call.arguments    : list()
[16:59:33.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.864]  $ ...future.elements_ii    :List of 3
[16:59:33.864]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:33.864]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:33.864]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.864]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:33.864]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:33.864]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.864]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:33.864]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:33.864]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.864]  $ ...future.seeds_ii       : NULL
[16:59:33.864]  $ ...future.globals.maxSize: NULL
[16:59:33.864]  - attr(*, "where")=List of 5
[16:59:33.864]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:33.864]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:33.864]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:33.864]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:33.864]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:33.864]  - attr(*, "resolved")= logi FALSE
[16:59:33.864]  - attr(*, "total_size")= num 1240
[16:59:33.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.864]  - attr(*, "already-done")= logi TRUE
[16:59:33.874] - copied ‘...future.FUN’ to environment
[16:59:33.874] - copied ‘future.call.arguments’ to environment
[16:59:33.874] - copied ‘...future.elements_ii’ to environment
[16:59:33.874] - copied ‘...future.seeds_ii’ to environment
[16:59:33.874] - copied ‘...future.globals.maxSize’ to environment
[16:59:33.874] assign_globals() ... done
[16:59:33.875] plan(): Setting new future strategy stack:
[16:59:33.875] List of future strategies:
[16:59:33.875] 1. sequential:
[16:59:33.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.875]    - tweaked: FALSE
[16:59:33.875]    - call: NULL
[16:59:33.875] plan(): nbrOfWorkers() = 1
[16:59:33.878] plan(): Setting new future strategy stack:
[16:59:33.878] List of future strategies:
[16:59:33.878] 1. sequential:
[16:59:33.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.878]    - tweaked: FALSE
[16:59:33.878]    - call: plan(strategy)
[16:59:33.878] plan(): nbrOfWorkers() = 1
[16:59:33.878] SequentialFuture started (and completed)
[16:59:33.879] - Launch lazy future ... done
[16:59:33.879] run() for ‘SequentialFuture’ ... done
[16:59:33.879] Created future:
[16:59:33.879] SequentialFuture:
[16:59:33.879] Label: ‘future_by-1’
[16:59:33.879] Expression:
[16:59:33.879] {
[16:59:33.879]     do.call(function(...) {
[16:59:33.879]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.879]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.879]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.879]             on.exit(options(oopts), add = TRUE)
[16:59:33.879]         }
[16:59:33.879]         {
[16:59:33.879]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.879]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.879]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.879]             })
[16:59:33.879]         }
[16:59:33.879]     }, args = future.call.arguments)
[16:59:33.879] }
[16:59:33.879] Lazy evaluation: FALSE
[16:59:33.879] Asynchronous evaluation: FALSE
[16:59:33.879] Local evaluation: TRUE
[16:59:33.879] Environment: R_GlobalEnv
[16:59:33.879] Capture standard output: TRUE
[16:59:33.879] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.879] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:33.879] Packages: <none>
[16:59:33.879] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.879] Resolved: TRUE
[16:59:33.879] Value: 4.62 KiB of class ‘list’
[16:59:33.879] Early signaling: FALSE
[16:59:33.879] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:33.879] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.881] Chunk #1 of 1 ... DONE
[16:59:33.881] Launching 1 futures (chunks) ... DONE
[16:59:33.881] Resolving 1 futures (chunks) ...
[16:59:33.881] resolve() on list ...
[16:59:33.881]  recursive: 0
[16:59:33.881]  length: 1
[16:59:33.881] 
[16:59:33.881] resolved() for ‘SequentialFuture’ ...
[16:59:33.882] - state: ‘finished’
[16:59:33.882] - run: TRUE
[16:59:33.882] - result: ‘FutureResult’
[16:59:33.882] resolved() for ‘SequentialFuture’ ... done
[16:59:33.882] Future #1
[16:59:33.882] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:33.882] - nx: 1
[16:59:33.882] - relay: TRUE
[16:59:33.883] - stdout: TRUE
[16:59:33.883] - signal: TRUE
[16:59:33.883] - resignal: FALSE
[16:59:33.883] - force: TRUE
[16:59:33.883] - relayed: [n=1] FALSE
[16:59:33.883] - queued futures: [n=1] FALSE
[16:59:33.883]  - until=1
[16:59:33.883]  - relaying element #1
[16:59:33.883] - relayed: [n=1] TRUE
[16:59:33.883] - queued futures: [n=1] TRUE
[16:59:33.884] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:33.884]  length: 0 (resolved future 1)
[16:59:33.884] Relaying remaining futures
[16:59:33.884] signalConditionsASAP(NULL, pos=0) ...
[16:59:33.884] - nx: 1
[16:59:33.884] - relay: TRUE
[16:59:33.884] - stdout: TRUE
[16:59:33.884] - signal: TRUE
[16:59:33.884] - resignal: FALSE
[16:59:33.884] - force: TRUE
[16:59:33.884] - relayed: [n=1] TRUE
[16:59:33.885] - queued futures: [n=1] TRUE
 - flush all
[16:59:33.885] - relayed: [n=1] TRUE
[16:59:33.885] - queued futures: [n=1] TRUE
[16:59:33.885] signalConditionsASAP(NULL, pos=0) ... done
[16:59:33.885] resolve() on list ... DONE
[16:59:33.885]  - Number of value chunks collected: 1
[16:59:33.885] Resolving 1 futures (chunks) ... DONE
[16:59:33.885] Reducing values from 1 chunks ...
[16:59:33.885]  - Number of values collected after concatenation: 3
[16:59:33.885]  - Number of values expected: 3
[16:59:33.886] Reducing values from 1 chunks ... DONE
[16:59:33.886] future_lapply() ... DONE
[16:59:33.886] future_by_internal() ... DONE
[16:59:33.886] future_by_internal() ...
[16:59:33.887] future_lapply() ...
[16:59:33.887] Number of chunks: 1
[16:59:33.887] getGlobalsAndPackagesXApply() ...
[16:59:33.887]  - future.globals: TRUE
[16:59:33.888] getGlobalsAndPackages() ...
[16:59:33.888] Searching for globals...
[16:59:33.889] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:33.889] Searching for globals ... DONE
[16:59:33.889] Resolving globals: FALSE
[16:59:33.889] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:33.890] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:33.890] - globals: [1] ‘FUN’
[16:59:33.890] 
[16:59:33.890] getGlobalsAndPackages() ... DONE
[16:59:33.890]  - globals found/used: [n=1] ‘FUN’
[16:59:33.890]  - needed namespaces: [n=0] 
[16:59:33.890] Finding globals ... DONE
[16:59:33.890]  - use_args: TRUE
[16:59:33.890]  - Getting '...' globals ...
[16:59:33.891] resolve() on list ...
[16:59:33.891]  recursive: 0
[16:59:33.891]  length: 1
[16:59:33.891]  elements: ‘...’
[16:59:33.891]  length: 0 (resolved future 1)
[16:59:33.891] resolve() on list ... DONE
[16:59:33.891]    - '...' content: [n=1] ‘digits’
[16:59:33.891] List of 1
[16:59:33.891]  $ ...:List of 1
[16:59:33.891]   ..$ digits: int 2
[16:59:33.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.891]  - attr(*, "where")=List of 1
[16:59:33.891]   ..$ ...:<environment: 0x562052b302e8> 
[16:59:33.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.891]  - attr(*, "resolved")= logi TRUE
[16:59:33.891]  - attr(*, "total_size")= num NA
[16:59:33.896]  - Getting '...' globals ... DONE
[16:59:33.896] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:33.896] List of 2
[16:59:33.896]  $ ...future.FUN:function (object, ...)  
[16:59:33.896]  $ ...          :List of 1
[16:59:33.896]   ..$ digits: int 2
[16:59:33.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.896]  - attr(*, "where")=List of 2
[16:59:33.896]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.896]   ..$ ...          :<environment: 0x562052b302e8> 
[16:59:33.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.896]  - attr(*, "resolved")= logi FALSE
[16:59:33.896]  - attr(*, "total_size")= num 1296
[16:59:33.899] Packages to be attached in all futures: [n=0] 
[16:59:33.899] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.899] Number of futures (= number of chunks): 1
[16:59:33.900] Launching 1 futures (chunks) ...
[16:59:33.900] Chunk #1 of 1 ...
[16:59:33.900]  - Finding globals in 'X' for chunk #1 ...
[16:59:33.900] getGlobalsAndPackages() ...
[16:59:33.900] Searching for globals...
[16:59:33.900] 
[16:59:33.900] Searching for globals ... DONE
[16:59:33.900] - globals: [0] <none>
[16:59:33.900] getGlobalsAndPackages() ... DONE
[16:59:33.901]    + additional globals found: [n=0] 
[16:59:33.901]    + additional namespaces needed: [n=0] 
[16:59:33.901]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:33.901]  - seeds: <none>
[16:59:33.901]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.901] getGlobalsAndPackages() ...
[16:59:33.901] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.901] Resolving globals: FALSE
[16:59:33.901] Tweak future expression to call with '...' arguments ...
[16:59:33.901] {
[16:59:33.901]     do.call(function(...) {
[16:59:33.901]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.901]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.901]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.901]             on.exit(options(oopts), add = TRUE)
[16:59:33.901]         }
[16:59:33.901]         {
[16:59:33.901]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.901]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.901]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.901]             })
[16:59:33.901]         }
[16:59:33.901]     }, args = future.call.arguments)
[16:59:33.901] }
[16:59:33.902] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.902] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.902] 
[16:59:33.902] getGlobalsAndPackages() ... DONE
[16:59:33.902] run() for ‘Future’ ...
[16:59:33.903] - state: ‘created’
[16:59:33.903] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:33.903] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.903] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:33.903]   - Field: ‘label’
[16:59:33.903]   - Field: ‘local’
[16:59:33.903]   - Field: ‘owner’
[16:59:33.903]   - Field: ‘envir’
[16:59:33.904]   - Field: ‘packages’
[16:59:33.904]   - Field: ‘gc’
[16:59:33.904]   - Field: ‘conditions’
[16:59:33.904]   - Field: ‘expr’
[16:59:33.904]   - Field: ‘uuid’
[16:59:33.904]   - Field: ‘seed’
[16:59:33.904]   - Field: ‘version’
[16:59:33.904]   - Field: ‘result’
[16:59:33.904]   - Field: ‘asynchronous’
[16:59:33.904]   - Field: ‘calls’
[16:59:33.904]   - Field: ‘globals’
[16:59:33.905]   - Field: ‘stdout’
[16:59:33.905]   - Field: ‘earlySignal’
[16:59:33.905]   - Field: ‘lazy’
[16:59:33.905]   - Field: ‘state’
[16:59:33.905] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:33.905] - Launch lazy future ...
[16:59:33.905] Packages needed by the future expression (n = 0): <none>
[16:59:33.905] Packages needed by future strategies (n = 0): <none>
[16:59:33.906] {
[16:59:33.906]     {
[16:59:33.906]         {
[16:59:33.906]             ...future.startTime <- base::Sys.time()
[16:59:33.906]             {
[16:59:33.906]                 {
[16:59:33.906]                   {
[16:59:33.906]                     base::local({
[16:59:33.906]                       has_future <- base::requireNamespace("future", 
[16:59:33.906]                         quietly = TRUE)
[16:59:33.906]                       if (has_future) {
[16:59:33.906]                         ns <- base::getNamespace("future")
[16:59:33.906]                         version <- ns[[".package"]][["version"]]
[16:59:33.906]                         if (is.null(version)) 
[16:59:33.906]                           version <- utils::packageVersion("future")
[16:59:33.906]                       }
[16:59:33.906]                       else {
[16:59:33.906]                         version <- NULL
[16:59:33.906]                       }
[16:59:33.906]                       if (!has_future || version < "1.8.0") {
[16:59:33.906]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.906]                           "", base::R.version$version.string), 
[16:59:33.906]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:33.906]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.906]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.906]                             "release", "version")], collapse = " "), 
[16:59:33.906]                           hostname = base::Sys.info()[["nodename"]])
[16:59:33.906]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.906]                           info)
[16:59:33.906]                         info <- base::paste(info, collapse = "; ")
[16:59:33.906]                         if (!has_future) {
[16:59:33.906]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.906]                             info)
[16:59:33.906]                         }
[16:59:33.906]                         else {
[16:59:33.906]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.906]                             info, version)
[16:59:33.906]                         }
[16:59:33.906]                         base::stop(msg)
[16:59:33.906]                       }
[16:59:33.906]                     })
[16:59:33.906]                   }
[16:59:33.906]                   ...future.strategy.old <- future::plan("list")
[16:59:33.906]                   options(future.plan = NULL)
[16:59:33.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.906]                 }
[16:59:33.906]                 ...future.workdir <- getwd()
[16:59:33.906]             }
[16:59:33.906]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.906]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.906]         }
[16:59:33.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:33.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.906]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.906]             base::names(...future.oldOptions))
[16:59:33.906]     }
[16:59:33.906]     if (FALSE) {
[16:59:33.906]     }
[16:59:33.906]     else {
[16:59:33.906]         if (TRUE) {
[16:59:33.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.906]                 open = "w")
[16:59:33.906]         }
[16:59:33.906]         else {
[16:59:33.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.906]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.906]         }
[16:59:33.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.906]             base::sink(type = "output", split = FALSE)
[16:59:33.906]             base::close(...future.stdout)
[16:59:33.906]         }, add = TRUE)
[16:59:33.906]     }
[16:59:33.906]     ...future.frame <- base::sys.nframe()
[16:59:33.906]     ...future.conditions <- base::list()
[16:59:33.906]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.906]     if (FALSE) {
[16:59:33.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.906]     }
[16:59:33.906]     ...future.result <- base::tryCatch({
[16:59:33.906]         base::withCallingHandlers({
[16:59:33.906]             ...future.value <- base::withVisible(base::local({
[16:59:33.906]                 do.call(function(...) {
[16:59:33.906]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.906]                   if (!identical(...future.globals.maxSize.org, 
[16:59:33.906]                     ...future.globals.maxSize)) {
[16:59:33.906]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.906]                     on.exit(options(oopts), add = TRUE)
[16:59:33.906]                   }
[16:59:33.906]                   {
[16:59:33.906]                     lapply(seq_along(...future.elements_ii), 
[16:59:33.906]                       FUN = function(jj) {
[16:59:33.906]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.906]                         ...future.FUN(...future.X_jj, ...)
[16:59:33.906]                       })
[16:59:33.906]                   }
[16:59:33.906]                 }, args = future.call.arguments)
[16:59:33.906]             }))
[16:59:33.906]             future::FutureResult(value = ...future.value$value, 
[16:59:33.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.906]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.906]                     ...future.globalenv.names))
[16:59:33.906]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.906]         }, condition = base::local({
[16:59:33.906]             c <- base::c
[16:59:33.906]             inherits <- base::inherits
[16:59:33.906]             invokeRestart <- base::invokeRestart
[16:59:33.906]             length <- base::length
[16:59:33.906]             list <- base::list
[16:59:33.906]             seq.int <- base::seq.int
[16:59:33.906]             signalCondition <- base::signalCondition
[16:59:33.906]             sys.calls <- base::sys.calls
[16:59:33.906]             `[[` <- base::`[[`
[16:59:33.906]             `+` <- base::`+`
[16:59:33.906]             `<<-` <- base::`<<-`
[16:59:33.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.906]                   3L)]
[16:59:33.906]             }
[16:59:33.906]             function(cond) {
[16:59:33.906]                 is_error <- inherits(cond, "error")
[16:59:33.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.906]                   NULL)
[16:59:33.906]                 if (is_error) {
[16:59:33.906]                   sessionInformation <- function() {
[16:59:33.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.906]                       search = base::search(), system = base::Sys.info())
[16:59:33.906]                   }
[16:59:33.906]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.906]                     cond$call), session = sessionInformation(), 
[16:59:33.906]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.906]                   signalCondition(cond)
[16:59:33.906]                 }
[16:59:33.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.906]                 "immediateCondition"))) {
[16:59:33.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.906]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.906]                   if (TRUE && !signal) {
[16:59:33.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.906]                     {
[16:59:33.906]                       inherits <- base::inherits
[16:59:33.906]                       invokeRestart <- base::invokeRestart
[16:59:33.906]                       is.null <- base::is.null
[16:59:33.906]                       muffled <- FALSE
[16:59:33.906]                       if (inherits(cond, "message")) {
[16:59:33.906]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.906]                         if (muffled) 
[16:59:33.906]                           invokeRestart("muffleMessage")
[16:59:33.906]                       }
[16:59:33.906]                       else if (inherits(cond, "warning")) {
[16:59:33.906]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.906]                         if (muffled) 
[16:59:33.906]                           invokeRestart("muffleWarning")
[16:59:33.906]                       }
[16:59:33.906]                       else if (inherits(cond, "condition")) {
[16:59:33.906]                         if (!is.null(pattern)) {
[16:59:33.906]                           computeRestarts <- base::computeRestarts
[16:59:33.906]                           grepl <- base::grepl
[16:59:33.906]                           restarts <- computeRestarts(cond)
[16:59:33.906]                           for (restart in restarts) {
[16:59:33.906]                             name <- restart$name
[16:59:33.906]                             if (is.null(name)) 
[16:59:33.906]                               next
[16:59:33.906]                             if (!grepl(pattern, name)) 
[16:59:33.906]                               next
[16:59:33.906]                             invokeRestart(restart)
[16:59:33.906]                             muffled <- TRUE
[16:59:33.906]                             break
[16:59:33.906]                           }
[16:59:33.906]                         }
[16:59:33.906]                       }
[16:59:33.906]                       invisible(muffled)
[16:59:33.906]                     }
[16:59:33.906]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.906]                   }
[16:59:33.906]                 }
[16:59:33.906]                 else {
[16:59:33.906]                   if (TRUE) {
[16:59:33.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.906]                     {
[16:59:33.906]                       inherits <- base::inherits
[16:59:33.906]                       invokeRestart <- base::invokeRestart
[16:59:33.906]                       is.null <- base::is.null
[16:59:33.906]                       muffled <- FALSE
[16:59:33.906]                       if (inherits(cond, "message")) {
[16:59:33.906]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.906]                         if (muffled) 
[16:59:33.906]                           invokeRestart("muffleMessage")
[16:59:33.906]                       }
[16:59:33.906]                       else if (inherits(cond, "warning")) {
[16:59:33.906]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.906]                         if (muffled) 
[16:59:33.906]                           invokeRestart("muffleWarning")
[16:59:33.906]                       }
[16:59:33.906]                       else if (inherits(cond, "condition")) {
[16:59:33.906]                         if (!is.null(pattern)) {
[16:59:33.906]                           computeRestarts <- base::computeRestarts
[16:59:33.906]                           grepl <- base::grepl
[16:59:33.906]                           restarts <- computeRestarts(cond)
[16:59:33.906]                           for (restart in restarts) {
[16:59:33.906]                             name <- restart$name
[16:59:33.906]                             if (is.null(name)) 
[16:59:33.906]                               next
[16:59:33.906]                             if (!grepl(pattern, name)) 
[16:59:33.906]                               next
[16:59:33.906]                             invokeRestart(restart)
[16:59:33.906]                             muffled <- TRUE
[16:59:33.906]                             break
[16:59:33.906]                           }
[16:59:33.906]                         }
[16:59:33.906]                       }
[16:59:33.906]                       invisible(muffled)
[16:59:33.906]                     }
[16:59:33.906]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.906]                   }
[16:59:33.906]                 }
[16:59:33.906]             }
[16:59:33.906]         }))
[16:59:33.906]     }, error = function(ex) {
[16:59:33.906]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.906]                 ...future.rng), started = ...future.startTime, 
[16:59:33.906]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.906]             version = "1.8"), class = "FutureResult")
[16:59:33.906]     }, finally = {
[16:59:33.906]         if (!identical(...future.workdir, getwd())) 
[16:59:33.906]             setwd(...future.workdir)
[16:59:33.906]         {
[16:59:33.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.906]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.906]             }
[16:59:33.906]             base::options(...future.oldOptions)
[16:59:33.906]             if (.Platform$OS.type == "windows") {
[16:59:33.906]                 old_names <- names(...future.oldEnvVars)
[16:59:33.906]                 envs <- base::Sys.getenv()
[16:59:33.906]                 names <- names(envs)
[16:59:33.906]                 common <- intersect(names, old_names)
[16:59:33.906]                 added <- setdiff(names, old_names)
[16:59:33.906]                 removed <- setdiff(old_names, names)
[16:59:33.906]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.906]                   envs[common]]
[16:59:33.906]                 NAMES <- toupper(changed)
[16:59:33.906]                 args <- list()
[16:59:33.906]                 for (kk in seq_along(NAMES)) {
[16:59:33.906]                   name <- changed[[kk]]
[16:59:33.906]                   NAME <- NAMES[[kk]]
[16:59:33.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.906]                     next
[16:59:33.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.906]                 }
[16:59:33.906]                 NAMES <- toupper(added)
[16:59:33.906]                 for (kk in seq_along(NAMES)) {
[16:59:33.906]                   name <- added[[kk]]
[16:59:33.906]                   NAME <- NAMES[[kk]]
[16:59:33.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.906]                     next
[16:59:33.906]                   args[[name]] <- ""
[16:59:33.906]                 }
[16:59:33.906]                 NAMES <- toupper(removed)
[16:59:33.906]                 for (kk in seq_along(NAMES)) {
[16:59:33.906]                   name <- removed[[kk]]
[16:59:33.906]                   NAME <- NAMES[[kk]]
[16:59:33.906]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.906]                     next
[16:59:33.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.906]                 }
[16:59:33.906]                 if (length(args) > 0) 
[16:59:33.906]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.906]             }
[16:59:33.906]             else {
[16:59:33.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.906]             }
[16:59:33.906]             {
[16:59:33.906]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.906]                   0L) {
[16:59:33.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.906]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.906]                   base::options(opts)
[16:59:33.906]                 }
[16:59:33.906]                 {
[16:59:33.906]                   {
[16:59:33.906]                     NULL
[16:59:33.906]                     RNGkind("Mersenne-Twister")
[16:59:33.906]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:33.906]                       inherits = FALSE)
[16:59:33.906]                   }
[16:59:33.906]                   options(future.plan = NULL)
[16:59:33.906]                   if (is.na(NA_character_)) 
[16:59:33.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.906]                     .init = FALSE)
[16:59:33.906]                 }
[16:59:33.906]             }
[16:59:33.906]         }
[16:59:33.906]     })
[16:59:33.906]     if (TRUE) {
[16:59:33.906]         base::sink(type = "output", split = FALSE)
[16:59:33.906]         if (TRUE) {
[16:59:33.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.906]         }
[16:59:33.906]         else {
[16:59:33.906]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.906]         }
[16:59:33.906]         base::close(...future.stdout)
[16:59:33.906]         ...future.stdout <- NULL
[16:59:33.906]     }
[16:59:33.906]     ...future.result$conditions <- ...future.conditions
[16:59:33.906]     ...future.result$finished <- base::Sys.time()
[16:59:33.906]     ...future.result
[16:59:33.906] }
[16:59:33.907] assign_globals() ...
[16:59:33.907] List of 5
[16:59:33.907]  $ ...future.FUN            :function (object, ...)  
[16:59:33.907]  $ future.call.arguments    :List of 1
[16:59:33.907]   ..$ digits: int 2
[16:59:33.907]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.907]  $ ...future.elements_ii    :List of 6
[16:59:33.907]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:59:33.907]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:59:33.907]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:59:33.907]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:59:33.907]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:59:33.907]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:59:33.907]  $ ...future.seeds_ii       : NULL
[16:59:33.907]  $ ...future.globals.maxSize: NULL
[16:59:33.907]  - attr(*, "where")=List of 5
[16:59:33.907]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:33.907]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:33.907]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:33.907]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:33.907]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:33.907]  - attr(*, "resolved")= logi FALSE
[16:59:33.907]  - attr(*, "total_size")= num 1296
[16:59:33.907]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.907]  - attr(*, "already-done")= logi TRUE
[16:59:33.914] - copied ‘...future.FUN’ to environment
[16:59:33.914] - copied ‘future.call.arguments’ to environment
[16:59:33.914] - copied ‘...future.elements_ii’ to environment
[16:59:33.914] - copied ‘...future.seeds_ii’ to environment
[16:59:33.914] - copied ‘...future.globals.maxSize’ to environment
[16:59:33.914] assign_globals() ... done
[16:59:33.915] plan(): Setting new future strategy stack:
[16:59:33.915] List of future strategies:
[16:59:33.915] 1. sequential:
[16:59:33.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.915]    - tweaked: FALSE
[16:59:33.915]    - call: NULL
[16:59:33.915] plan(): nbrOfWorkers() = 1
[16:59:33.918] plan(): Setting new future strategy stack:
[16:59:33.918] List of future strategies:
[16:59:33.918] 1. sequential:
[16:59:33.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.918]    - tweaked: FALSE
[16:59:33.918]    - call: plan(strategy)
[16:59:33.919] plan(): nbrOfWorkers() = 1
[16:59:33.919] SequentialFuture started (and completed)
[16:59:33.919] - Launch lazy future ... done
[16:59:33.919] run() for ‘SequentialFuture’ ... done
[16:59:33.919] Created future:
[16:59:33.919] SequentialFuture:
[16:59:33.919] Label: ‘future_by-1’
[16:59:33.919] Expression:
[16:59:33.919] {
[16:59:33.919]     do.call(function(...) {
[16:59:33.919]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.919]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.919]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.919]             on.exit(options(oopts), add = TRUE)
[16:59:33.919]         }
[16:59:33.919]         {
[16:59:33.919]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.919]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.919]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.919]             })
[16:59:33.919]         }
[16:59:33.919]     }, args = future.call.arguments)
[16:59:33.919] }
[16:59:33.919] Lazy evaluation: FALSE
[16:59:33.919] Asynchronous evaluation: FALSE
[16:59:33.919] Local evaluation: TRUE
[16:59:33.919] Environment: R_GlobalEnv
[16:59:33.919] Capture standard output: TRUE
[16:59:33.919] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.919] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:33.919] Packages: <none>
[16:59:33.919] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.919] Resolved: TRUE
[16:59:33.919] Value: 5.48 KiB of class ‘list’
[16:59:33.919] Early signaling: FALSE
[16:59:33.919] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:33.919] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.920] Chunk #1 of 1 ... DONE
[16:59:33.920] Launching 1 futures (chunks) ... DONE
[16:59:33.920] Resolving 1 futures (chunks) ...
[16:59:33.921] resolve() on list ...
[16:59:33.921]  recursive: 0
[16:59:33.921]  length: 1
[16:59:33.921] 
[16:59:33.921] resolved() for ‘SequentialFuture’ ...
[16:59:33.921] - state: ‘finished’
[16:59:33.921] - run: TRUE
[16:59:33.921] - result: ‘FutureResult’
[16:59:33.921] resolved() for ‘SequentialFuture’ ... done
[16:59:33.921] Future #1
[16:59:33.922] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:33.922] - nx: 1
[16:59:33.922] - relay: TRUE
[16:59:33.922] - stdout: TRUE
[16:59:33.922] - signal: TRUE
[16:59:33.922] - resignal: FALSE
[16:59:33.922] - force: TRUE
[16:59:33.922] - relayed: [n=1] FALSE
[16:59:33.922] - queued futures: [n=1] FALSE
[16:59:33.922]  - until=1
[16:59:33.922]  - relaying element #1
[16:59:33.923] - relayed: [n=1] TRUE
[16:59:33.923] - queued futures: [n=1] TRUE
[16:59:33.923] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:33.923]  length: 0 (resolved future 1)
[16:59:33.923] Relaying remaining futures
[16:59:33.923] signalConditionsASAP(NULL, pos=0) ...
[16:59:33.923] - nx: 1
[16:59:33.923] - relay: TRUE
[16:59:33.923] - stdout: TRUE
[16:59:33.923] - signal: TRUE
[16:59:33.924] - resignal: FALSE
[16:59:33.924] - force: TRUE
[16:59:33.924] - relayed: [n=1] TRUE
[16:59:33.924] - queued futures: [n=1] TRUE
 - flush all
[16:59:33.924] - relayed: [n=1] TRUE
[16:59:33.924] - queued futures: [n=1] TRUE
[16:59:33.924] signalConditionsASAP(NULL, pos=0) ... done
[16:59:33.924] resolve() on list ... DONE
[16:59:33.924]  - Number of value chunks collected: 1
[16:59:33.924] Resolving 1 futures (chunks) ... DONE
[16:59:33.924] Reducing values from 1 chunks ...
[16:59:33.925]  - Number of values collected after concatenation: 6
[16:59:33.925]  - Number of values expected: 6
[16:59:33.925] Reducing values from 1 chunks ... DONE
[16:59:33.925] future_lapply() ... DONE
[16:59:33.925] future_by_internal() ... DONE
[16:59:33.928] future_by_internal() ...
[16:59:33.928] future_lapply() ...
[16:59:33.929] Number of chunks: 1
[16:59:33.929] getGlobalsAndPackagesXApply() ...
[16:59:33.930]  - future.globals: TRUE
[16:59:33.930] getGlobalsAndPackages() ...
[16:59:33.930] Searching for globals...
[16:59:33.931] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:33.931] Searching for globals ... DONE
[16:59:33.931] Resolving globals: FALSE
[16:59:33.932] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:59:33.932] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:59:33.932] - globals: [1] ‘FUN’
[16:59:33.932] - packages: [1] ‘stats’
[16:59:33.933] getGlobalsAndPackages() ... DONE
[16:59:33.933]  - globals found/used: [n=1] ‘FUN’
[16:59:33.933]  - needed namespaces: [n=1] ‘stats’
[16:59:33.933] Finding globals ... DONE
[16:59:33.933]  - use_args: TRUE
[16:59:33.933]  - Getting '...' globals ...
[16:59:33.933] resolve() on list ...
[16:59:33.933]  recursive: 0
[16:59:33.933]  length: 1
[16:59:33.934]  elements: ‘...’
[16:59:33.934]  length: 0 (resolved future 1)
[16:59:33.934] resolve() on list ... DONE
[16:59:33.934]    - '...' content: [n=1] ‘singular.ok’
[16:59:33.934] List of 1
[16:59:33.934]  $ ...:List of 1
[16:59:33.934]   ..$ singular.ok: logi FALSE
[16:59:33.934]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.934]  - attr(*, "where")=List of 1
[16:59:33.934]   ..$ ...:<environment: 0x5620527f8730> 
[16:59:33.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.934]  - attr(*, "resolved")= logi TRUE
[16:59:33.934]  - attr(*, "total_size")= num NA
[16:59:33.937]  - Getting '...' globals ... DONE
[16:59:33.937] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:33.937] List of 2
[16:59:33.937]  $ ...future.FUN:function (x, ...)  
[16:59:33.937]  $ ...          :List of 1
[16:59:33.937]   ..$ singular.ok: logi FALSE
[16:59:33.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.937]  - attr(*, "where")=List of 2
[16:59:33.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.937]   ..$ ...          :<environment: 0x5620527f8730> 
[16:59:33.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.937]  - attr(*, "resolved")= logi FALSE
[16:59:33.937]  - attr(*, "total_size")= num 5384
[16:59:33.942] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:33.942] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.942] Number of futures (= number of chunks): 1
[16:59:33.942] Launching 1 futures (chunks) ...
[16:59:33.942] Chunk #1 of 1 ...
[16:59:33.942]  - Finding globals in 'X' for chunk #1 ...
[16:59:33.942] getGlobalsAndPackages() ...
[16:59:33.942] Searching for globals...
[16:59:33.943] 
[16:59:33.943] Searching for globals ... DONE
[16:59:33.943] - globals: [0] <none>
[16:59:33.943] getGlobalsAndPackages() ... DONE
[16:59:33.943]    + additional globals found: [n=0] 
[16:59:33.943]    + additional namespaces needed: [n=0] 
[16:59:33.944]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:33.944]  - seeds: <none>
[16:59:33.944]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.944] getGlobalsAndPackages() ...
[16:59:33.944] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.944] Resolving globals: FALSE
[16:59:33.944] Tweak future expression to call with '...' arguments ...
[16:59:33.944] {
[16:59:33.944]     do.call(function(...) {
[16:59:33.944]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.944]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.944]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.944]             on.exit(options(oopts), add = TRUE)
[16:59:33.944]         }
[16:59:33.944]         {
[16:59:33.944]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.944]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.944]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.944]             })
[16:59:33.944]         }
[16:59:33.944]     }, args = future.call.arguments)
[16:59:33.944] }
[16:59:33.944] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.945] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.945] 
[16:59:33.945] getGlobalsAndPackages() ... DONE
[16:59:33.945] run() for ‘Future’ ...
[16:59:33.945] - state: ‘created’
[16:59:33.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:33.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:33.946]   - Field: ‘label’
[16:59:33.946]   - Field: ‘local’
[16:59:33.946]   - Field: ‘owner’
[16:59:33.946]   - Field: ‘envir’
[16:59:33.946]   - Field: ‘packages’
[16:59:33.946]   - Field: ‘gc’
[16:59:33.947]   - Field: ‘conditions’
[16:59:33.947]   - Field: ‘expr’
[16:59:33.947]   - Field: ‘uuid’
[16:59:33.947]   - Field: ‘seed’
[16:59:33.947]   - Field: ‘version’
[16:59:33.947]   - Field: ‘result’
[16:59:33.947]   - Field: ‘asynchronous’
[16:59:33.947]   - Field: ‘calls’
[16:59:33.947]   - Field: ‘globals’
[16:59:33.947]   - Field: ‘stdout’
[16:59:33.947]   - Field: ‘earlySignal’
[16:59:33.948]   - Field: ‘lazy’
[16:59:33.948]   - Field: ‘state’
[16:59:33.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:33.948] - Launch lazy future ...
[16:59:33.948] Packages needed by the future expression (n = 1): ‘stats’
[16:59:33.948] Packages needed by future strategies (n = 0): <none>
[16:59:33.949] {
[16:59:33.949]     {
[16:59:33.949]         {
[16:59:33.949]             ...future.startTime <- base::Sys.time()
[16:59:33.949]             {
[16:59:33.949]                 {
[16:59:33.949]                   {
[16:59:33.949]                     {
[16:59:33.949]                       base::local({
[16:59:33.949]                         has_future <- base::requireNamespace("future", 
[16:59:33.949]                           quietly = TRUE)
[16:59:33.949]                         if (has_future) {
[16:59:33.949]                           ns <- base::getNamespace("future")
[16:59:33.949]                           version <- ns[[".package"]][["version"]]
[16:59:33.949]                           if (is.null(version)) 
[16:59:33.949]                             version <- utils::packageVersion("future")
[16:59:33.949]                         }
[16:59:33.949]                         else {
[16:59:33.949]                           version <- NULL
[16:59:33.949]                         }
[16:59:33.949]                         if (!has_future || version < "1.8.0") {
[16:59:33.949]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.949]                             "", base::R.version$version.string), 
[16:59:33.949]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.949]                               "release", "version")], collapse = " "), 
[16:59:33.949]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.949]                             info)
[16:59:33.949]                           info <- base::paste(info, collapse = "; ")
[16:59:33.949]                           if (!has_future) {
[16:59:33.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.949]                               info)
[16:59:33.949]                           }
[16:59:33.949]                           else {
[16:59:33.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.949]                               info, version)
[16:59:33.949]                           }
[16:59:33.949]                           base::stop(msg)
[16:59:33.949]                         }
[16:59:33.949]                       })
[16:59:33.949]                     }
[16:59:33.949]                     base::local({
[16:59:33.949]                       for (pkg in "stats") {
[16:59:33.949]                         base::loadNamespace(pkg)
[16:59:33.949]                         base::library(pkg, character.only = TRUE)
[16:59:33.949]                       }
[16:59:33.949]                     })
[16:59:33.949]                   }
[16:59:33.949]                   ...future.strategy.old <- future::plan("list")
[16:59:33.949]                   options(future.plan = NULL)
[16:59:33.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.949]                 }
[16:59:33.949]                 ...future.workdir <- getwd()
[16:59:33.949]             }
[16:59:33.949]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.949]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.949]         }
[16:59:33.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:33.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.949]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.949]             base::names(...future.oldOptions))
[16:59:33.949]     }
[16:59:33.949]     if (FALSE) {
[16:59:33.949]     }
[16:59:33.949]     else {
[16:59:33.949]         if (TRUE) {
[16:59:33.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.949]                 open = "w")
[16:59:33.949]         }
[16:59:33.949]         else {
[16:59:33.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.949]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.949]         }
[16:59:33.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.949]             base::sink(type = "output", split = FALSE)
[16:59:33.949]             base::close(...future.stdout)
[16:59:33.949]         }, add = TRUE)
[16:59:33.949]     }
[16:59:33.949]     ...future.frame <- base::sys.nframe()
[16:59:33.949]     ...future.conditions <- base::list()
[16:59:33.949]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.949]     if (FALSE) {
[16:59:33.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.949]     }
[16:59:33.949]     ...future.result <- base::tryCatch({
[16:59:33.949]         base::withCallingHandlers({
[16:59:33.949]             ...future.value <- base::withVisible(base::local({
[16:59:33.949]                 do.call(function(...) {
[16:59:33.949]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.949]                   if (!identical(...future.globals.maxSize.org, 
[16:59:33.949]                     ...future.globals.maxSize)) {
[16:59:33.949]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.949]                     on.exit(options(oopts), add = TRUE)
[16:59:33.949]                   }
[16:59:33.949]                   {
[16:59:33.949]                     lapply(seq_along(...future.elements_ii), 
[16:59:33.949]                       FUN = function(jj) {
[16:59:33.949]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.949]                         ...future.FUN(...future.X_jj, ...)
[16:59:33.949]                       })
[16:59:33.949]                   }
[16:59:33.949]                 }, args = future.call.arguments)
[16:59:33.949]             }))
[16:59:33.949]             future::FutureResult(value = ...future.value$value, 
[16:59:33.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.949]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.949]                     ...future.globalenv.names))
[16:59:33.949]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.949]         }, condition = base::local({
[16:59:33.949]             c <- base::c
[16:59:33.949]             inherits <- base::inherits
[16:59:33.949]             invokeRestart <- base::invokeRestart
[16:59:33.949]             length <- base::length
[16:59:33.949]             list <- base::list
[16:59:33.949]             seq.int <- base::seq.int
[16:59:33.949]             signalCondition <- base::signalCondition
[16:59:33.949]             sys.calls <- base::sys.calls
[16:59:33.949]             `[[` <- base::`[[`
[16:59:33.949]             `+` <- base::`+`
[16:59:33.949]             `<<-` <- base::`<<-`
[16:59:33.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.949]                   3L)]
[16:59:33.949]             }
[16:59:33.949]             function(cond) {
[16:59:33.949]                 is_error <- inherits(cond, "error")
[16:59:33.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.949]                   NULL)
[16:59:33.949]                 if (is_error) {
[16:59:33.949]                   sessionInformation <- function() {
[16:59:33.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.949]                       search = base::search(), system = base::Sys.info())
[16:59:33.949]                   }
[16:59:33.949]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.949]                     cond$call), session = sessionInformation(), 
[16:59:33.949]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.949]                   signalCondition(cond)
[16:59:33.949]                 }
[16:59:33.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.949]                 "immediateCondition"))) {
[16:59:33.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.949]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.949]                   if (TRUE && !signal) {
[16:59:33.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.949]                     {
[16:59:33.949]                       inherits <- base::inherits
[16:59:33.949]                       invokeRestart <- base::invokeRestart
[16:59:33.949]                       is.null <- base::is.null
[16:59:33.949]                       muffled <- FALSE
[16:59:33.949]                       if (inherits(cond, "message")) {
[16:59:33.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.949]                         if (muffled) 
[16:59:33.949]                           invokeRestart("muffleMessage")
[16:59:33.949]                       }
[16:59:33.949]                       else if (inherits(cond, "warning")) {
[16:59:33.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.949]                         if (muffled) 
[16:59:33.949]                           invokeRestart("muffleWarning")
[16:59:33.949]                       }
[16:59:33.949]                       else if (inherits(cond, "condition")) {
[16:59:33.949]                         if (!is.null(pattern)) {
[16:59:33.949]                           computeRestarts <- base::computeRestarts
[16:59:33.949]                           grepl <- base::grepl
[16:59:33.949]                           restarts <- computeRestarts(cond)
[16:59:33.949]                           for (restart in restarts) {
[16:59:33.949]                             name <- restart$name
[16:59:33.949]                             if (is.null(name)) 
[16:59:33.949]                               next
[16:59:33.949]                             if (!grepl(pattern, name)) 
[16:59:33.949]                               next
[16:59:33.949]                             invokeRestart(restart)
[16:59:33.949]                             muffled <- TRUE
[16:59:33.949]                             break
[16:59:33.949]                           }
[16:59:33.949]                         }
[16:59:33.949]                       }
[16:59:33.949]                       invisible(muffled)
[16:59:33.949]                     }
[16:59:33.949]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.949]                   }
[16:59:33.949]                 }
[16:59:33.949]                 else {
[16:59:33.949]                   if (TRUE) {
[16:59:33.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.949]                     {
[16:59:33.949]                       inherits <- base::inherits
[16:59:33.949]                       invokeRestart <- base::invokeRestart
[16:59:33.949]                       is.null <- base::is.null
[16:59:33.949]                       muffled <- FALSE
[16:59:33.949]                       if (inherits(cond, "message")) {
[16:59:33.949]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.949]                         if (muffled) 
[16:59:33.949]                           invokeRestart("muffleMessage")
[16:59:33.949]                       }
[16:59:33.949]                       else if (inherits(cond, "warning")) {
[16:59:33.949]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.949]                         if (muffled) 
[16:59:33.949]                           invokeRestart("muffleWarning")
[16:59:33.949]                       }
[16:59:33.949]                       else if (inherits(cond, "condition")) {
[16:59:33.949]                         if (!is.null(pattern)) {
[16:59:33.949]                           computeRestarts <- base::computeRestarts
[16:59:33.949]                           grepl <- base::grepl
[16:59:33.949]                           restarts <- computeRestarts(cond)
[16:59:33.949]                           for (restart in restarts) {
[16:59:33.949]                             name <- restart$name
[16:59:33.949]                             if (is.null(name)) 
[16:59:33.949]                               next
[16:59:33.949]                             if (!grepl(pattern, name)) 
[16:59:33.949]                               next
[16:59:33.949]                             invokeRestart(restart)
[16:59:33.949]                             muffled <- TRUE
[16:59:33.949]                             break
[16:59:33.949]                           }
[16:59:33.949]                         }
[16:59:33.949]                       }
[16:59:33.949]                       invisible(muffled)
[16:59:33.949]                     }
[16:59:33.949]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.949]                   }
[16:59:33.949]                 }
[16:59:33.949]             }
[16:59:33.949]         }))
[16:59:33.949]     }, error = function(ex) {
[16:59:33.949]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.949]                 ...future.rng), started = ...future.startTime, 
[16:59:33.949]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.949]             version = "1.8"), class = "FutureResult")
[16:59:33.949]     }, finally = {
[16:59:33.949]         if (!identical(...future.workdir, getwd())) 
[16:59:33.949]             setwd(...future.workdir)
[16:59:33.949]         {
[16:59:33.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.949]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.949]             }
[16:59:33.949]             base::options(...future.oldOptions)
[16:59:33.949]             if (.Platform$OS.type == "windows") {
[16:59:33.949]                 old_names <- names(...future.oldEnvVars)
[16:59:33.949]                 envs <- base::Sys.getenv()
[16:59:33.949]                 names <- names(envs)
[16:59:33.949]                 common <- intersect(names, old_names)
[16:59:33.949]                 added <- setdiff(names, old_names)
[16:59:33.949]                 removed <- setdiff(old_names, names)
[16:59:33.949]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.949]                   envs[common]]
[16:59:33.949]                 NAMES <- toupper(changed)
[16:59:33.949]                 args <- list()
[16:59:33.949]                 for (kk in seq_along(NAMES)) {
[16:59:33.949]                   name <- changed[[kk]]
[16:59:33.949]                   NAME <- NAMES[[kk]]
[16:59:33.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.949]                     next
[16:59:33.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.949]                 }
[16:59:33.949]                 NAMES <- toupper(added)
[16:59:33.949]                 for (kk in seq_along(NAMES)) {
[16:59:33.949]                   name <- added[[kk]]
[16:59:33.949]                   NAME <- NAMES[[kk]]
[16:59:33.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.949]                     next
[16:59:33.949]                   args[[name]] <- ""
[16:59:33.949]                 }
[16:59:33.949]                 NAMES <- toupper(removed)
[16:59:33.949]                 for (kk in seq_along(NAMES)) {
[16:59:33.949]                   name <- removed[[kk]]
[16:59:33.949]                   NAME <- NAMES[[kk]]
[16:59:33.949]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.949]                     next
[16:59:33.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.949]                 }
[16:59:33.949]                 if (length(args) > 0) 
[16:59:33.949]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.949]             }
[16:59:33.949]             else {
[16:59:33.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.949]             }
[16:59:33.949]             {
[16:59:33.949]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.949]                   0L) {
[16:59:33.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.949]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.949]                   base::options(opts)
[16:59:33.949]                 }
[16:59:33.949]                 {
[16:59:33.949]                   {
[16:59:33.949]                     NULL
[16:59:33.949]                     RNGkind("Mersenne-Twister")
[16:59:33.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:33.949]                       inherits = FALSE)
[16:59:33.949]                   }
[16:59:33.949]                   options(future.plan = NULL)
[16:59:33.949]                   if (is.na(NA_character_)) 
[16:59:33.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.949]                     .init = FALSE)
[16:59:33.949]                 }
[16:59:33.949]             }
[16:59:33.949]         }
[16:59:33.949]     })
[16:59:33.949]     if (TRUE) {
[16:59:33.949]         base::sink(type = "output", split = FALSE)
[16:59:33.949]         if (TRUE) {
[16:59:33.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.949]         }
[16:59:33.949]         else {
[16:59:33.949]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.949]         }
[16:59:33.949]         base::close(...future.stdout)
[16:59:33.949]         ...future.stdout <- NULL
[16:59:33.949]     }
[16:59:33.949]     ...future.result$conditions <- ...future.conditions
[16:59:33.949]     ...future.result$finished <- base::Sys.time()
[16:59:33.949]     ...future.result
[16:59:33.949] }
[16:59:33.950] assign_globals() ...
[16:59:33.950] List of 5
[16:59:33.950]  $ ...future.FUN            :function (x, ...)  
[16:59:33.950]  $ future.call.arguments    :List of 1
[16:59:33.950]   ..$ singular.ok: logi FALSE
[16:59:33.950]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.950]  $ ...future.elements_ii    :List of 3
[16:59:33.950]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:33.950]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:33.950]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.950]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:33.950]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:33.950]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:33.950]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.950]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:33.950]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:33.950]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:33.950]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.950]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:33.950]  $ ...future.seeds_ii       : NULL
[16:59:33.950]  $ ...future.globals.maxSize: NULL
[16:59:33.950]  - attr(*, "where")=List of 5
[16:59:33.950]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:33.950]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:33.950]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:33.950]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:33.950]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:33.950]  - attr(*, "resolved")= logi FALSE
[16:59:33.950]  - attr(*, "total_size")= num 5384
[16:59:33.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.950]  - attr(*, "already-done")= logi TRUE
[16:59:33.959] - reassign environment for ‘...future.FUN’
[16:59:33.959] - copied ‘...future.FUN’ to environment
[16:59:33.959] - copied ‘future.call.arguments’ to environment
[16:59:33.959] - copied ‘...future.elements_ii’ to environment
[16:59:33.959] - copied ‘...future.seeds_ii’ to environment
[16:59:33.959] - copied ‘...future.globals.maxSize’ to environment
[16:59:33.960] assign_globals() ... done
[16:59:33.960] plan(): Setting new future strategy stack:
[16:59:33.960] List of future strategies:
[16:59:33.960] 1. sequential:
[16:59:33.960]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.960]    - tweaked: FALSE
[16:59:33.960]    - call: NULL
[16:59:33.961] plan(): nbrOfWorkers() = 1
[16:59:33.965] plan(): Setting new future strategy stack:
[16:59:33.965] List of future strategies:
[16:59:33.965] 1. sequential:
[16:59:33.965]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:33.965]    - tweaked: FALSE
[16:59:33.965]    - call: plan(strategy)
[16:59:33.965] plan(): nbrOfWorkers() = 1
[16:59:33.966] SequentialFuture started (and completed)
[16:59:33.966] - Launch lazy future ... done
[16:59:33.966] run() for ‘SequentialFuture’ ... done
[16:59:33.966] Created future:
[16:59:33.966] SequentialFuture:
[16:59:33.966] Label: ‘future_by-1’
[16:59:33.966] Expression:
[16:59:33.966] {
[16:59:33.966]     do.call(function(...) {
[16:59:33.966]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.966]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.966]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.966]             on.exit(options(oopts), add = TRUE)
[16:59:33.966]         }
[16:59:33.966]         {
[16:59:33.966]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.966]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.966]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.966]             })
[16:59:33.966]         }
[16:59:33.966]     }, args = future.call.arguments)
[16:59:33.966] }
[16:59:33.966] Lazy evaluation: FALSE
[16:59:33.966] Asynchronous evaluation: FALSE
[16:59:33.966] Local evaluation: TRUE
[16:59:33.966] Environment: R_GlobalEnv
[16:59:33.966] Capture standard output: TRUE
[16:59:33.966] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:33.966] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:33.966] Packages: 1 packages (‘stats’)
[16:59:33.966] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:33.966] Resolved: TRUE
[16:59:33.966] Value: 26.06 KiB of class ‘list’
[16:59:33.966] Early signaling: FALSE
[16:59:33.966] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:33.966] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.968] Chunk #1 of 1 ... DONE
[16:59:33.968] Launching 1 futures (chunks) ... DONE
[16:59:33.968] Resolving 1 futures (chunks) ...
[16:59:33.968] resolve() on list ...
[16:59:33.968]  recursive: 0
[16:59:33.968]  length: 1
[16:59:33.968] 
[16:59:33.968] resolved() for ‘SequentialFuture’ ...
[16:59:33.968] - state: ‘finished’
[16:59:33.968] - run: TRUE
[16:59:33.969] - result: ‘FutureResult’
[16:59:33.969] resolved() for ‘SequentialFuture’ ... done
[16:59:33.969] Future #1
[16:59:33.969] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:33.969] - nx: 1
[16:59:33.969] - relay: TRUE
[16:59:33.969] - stdout: TRUE
[16:59:33.969] - signal: TRUE
[16:59:33.969] - resignal: FALSE
[16:59:33.969] - force: TRUE
[16:59:33.969] - relayed: [n=1] FALSE
[16:59:33.970] - queued futures: [n=1] FALSE
[16:59:33.970]  - until=1
[16:59:33.970]  - relaying element #1
[16:59:33.970] - relayed: [n=1] TRUE
[16:59:33.970] - queued futures: [n=1] TRUE
[16:59:33.970] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:33.970]  length: 0 (resolved future 1)
[16:59:33.970] Relaying remaining futures
[16:59:33.970] signalConditionsASAP(NULL, pos=0) ...
[16:59:33.970] - nx: 1
[16:59:33.971] - relay: TRUE
[16:59:33.971] - stdout: TRUE
[16:59:33.971] - signal: TRUE
[16:59:33.971] - resignal: FALSE
[16:59:33.971] - force: TRUE
[16:59:33.971] - relayed: [n=1] TRUE
[16:59:33.971] - queued futures: [n=1] TRUE
 - flush all
[16:59:33.971] - relayed: [n=1] TRUE
[16:59:33.971] - queued futures: [n=1] TRUE
[16:59:33.971] signalConditionsASAP(NULL, pos=0) ... done
[16:59:33.971] resolve() on list ... DONE
[16:59:33.972]  - Number of value chunks collected: 1
[16:59:33.972] Resolving 1 futures (chunks) ... DONE
[16:59:33.972] Reducing values from 1 chunks ...
[16:59:33.972]  - Number of values collected after concatenation: 3
[16:59:33.972]  - Number of values expected: 3
[16:59:33.972] Reducing values from 1 chunks ... DONE
[16:59:33.972] future_lapply() ... DONE
[16:59:33.972] future_by_internal() ... DONE
[16:59:33.976] future_by_internal() ...
[16:59:33.977] future_lapply() ...
[16:59:33.977] Number of chunks: 1
[16:59:33.977] getGlobalsAndPackagesXApply() ...
[16:59:33.978]  - future.globals: TRUE
[16:59:33.978] getGlobalsAndPackages() ...
[16:59:33.978] Searching for globals...
[16:59:33.979] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:33.979] Searching for globals ... DONE
[16:59:33.980] Resolving globals: FALSE
[16:59:33.980] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:59:33.980] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:59:33.981] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:33.981] - packages: [1] ‘stats’
[16:59:33.981] getGlobalsAndPackages() ... DONE
[16:59:33.981]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:33.981]  - needed namespaces: [n=1] ‘stats’
[16:59:33.981] Finding globals ... DONE
[16:59:33.981]  - use_args: TRUE
[16:59:33.981]  - Getting '...' globals ...
[16:59:33.983] resolve() on list ...
[16:59:33.983]  recursive: 0
[16:59:33.983]  length: 1
[16:59:33.983]  elements: ‘...’
[16:59:33.983]  length: 0 (resolved future 1)
[16:59:33.983] resolve() on list ... DONE
[16:59:33.984]    - '...' content: [n=0] 
[16:59:33.984] List of 1
[16:59:33.984]  $ ...: list()
[16:59:33.984]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.984]  - attr(*, "where")=List of 1
[16:59:33.984]   ..$ ...:<environment: 0x562052ab7a48> 
[16:59:33.984]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.984]  - attr(*, "resolved")= logi TRUE
[16:59:33.984]  - attr(*, "total_size")= num NA
[16:59:33.986]  - Getting '...' globals ... DONE
[16:59:33.986] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:59:33.986] List of 4
[16:59:33.986]  $ ...future.FUN:function (x)  
[16:59:33.986]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:33.986]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:33.986]  $ ...          : list()
[16:59:33.986]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.986]  - attr(*, "where")=List of 4
[16:59:33.986]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:33.986]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:59:33.986]   ..$ wool         :<environment: R_EmptyEnv> 
[16:59:33.986]   ..$ ...          :<environment: 0x562052ab7a48> 
[16:59:33.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.986]  - attr(*, "resolved")= logi FALSE
[16:59:33.986]  - attr(*, "total_size")= num 2320
[16:59:33.990] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:33.990] getGlobalsAndPackagesXApply() ... DONE
[16:59:33.990] Number of futures (= number of chunks): 1
[16:59:33.990] Launching 1 futures (chunks) ...
[16:59:33.991] Chunk #1 of 1 ...
[16:59:33.991]  - Finding globals in 'X' for chunk #1 ...
[16:59:33.991] getGlobalsAndPackages() ...
[16:59:33.991] Searching for globals...
[16:59:33.991] 
[16:59:33.991] Searching for globals ... DONE
[16:59:33.991] - globals: [0] <none>
[16:59:33.992] getGlobalsAndPackages() ... DONE
[16:59:33.992]    + additional globals found: [n=0] 
[16:59:33.992]    + additional namespaces needed: [n=0] 
[16:59:33.992]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:33.992]  - seeds: <none>
[16:59:33.992]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.992] getGlobalsAndPackages() ...
[16:59:33.992] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.992] Resolving globals: FALSE
[16:59:33.992] Tweak future expression to call with '...' arguments ...
[16:59:33.993] {
[16:59:33.993]     do.call(function(...) {
[16:59:33.993]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.993]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:33.993]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.993]             on.exit(options(oopts), add = TRUE)
[16:59:33.993]         }
[16:59:33.993]         {
[16:59:33.993]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:33.993]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.993]                 ...future.FUN(...future.X_jj, ...)
[16:59:33.993]             })
[16:59:33.993]         }
[16:59:33.993]     }, args = future.call.arguments)
[16:59:33.993] }
[16:59:33.993] Tweak future expression to call with '...' arguments ... DONE
[16:59:33.993] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:33.993] 
[16:59:33.993] getGlobalsAndPackages() ... DONE
[16:59:33.994] run() for ‘Future’ ...
[16:59:33.994] - state: ‘created’
[16:59:33.994] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:33.994] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:33.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:33.994]   - Field: ‘label’
[16:59:33.994]   - Field: ‘local’
[16:59:33.995]   - Field: ‘owner’
[16:59:33.995]   - Field: ‘envir’
[16:59:33.995]   - Field: ‘packages’
[16:59:33.995]   - Field: ‘gc’
[16:59:33.995]   - Field: ‘conditions’
[16:59:33.995]   - Field: ‘expr’
[16:59:33.995]   - Field: ‘uuid’
[16:59:33.995]   - Field: ‘seed’
[16:59:33.995]   - Field: ‘version’
[16:59:33.995]   - Field: ‘result’
[16:59:33.995]   - Field: ‘asynchronous’
[16:59:33.996]   - Field: ‘calls’
[16:59:33.996]   - Field: ‘globals’
[16:59:33.996]   - Field: ‘stdout’
[16:59:33.996]   - Field: ‘earlySignal’
[16:59:33.996]   - Field: ‘lazy’
[16:59:33.996]   - Field: ‘state’
[16:59:33.996] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:33.996] - Launch lazy future ...
[16:59:33.996] Packages needed by the future expression (n = 1): ‘stats’
[16:59:33.996] Packages needed by future strategies (n = 0): <none>
[16:59:33.997] {
[16:59:33.997]     {
[16:59:33.997]         {
[16:59:33.997]             ...future.startTime <- base::Sys.time()
[16:59:33.997]             {
[16:59:33.997]                 {
[16:59:33.997]                   {
[16:59:33.997]                     {
[16:59:33.997]                       base::local({
[16:59:33.997]                         has_future <- base::requireNamespace("future", 
[16:59:33.997]                           quietly = TRUE)
[16:59:33.997]                         if (has_future) {
[16:59:33.997]                           ns <- base::getNamespace("future")
[16:59:33.997]                           version <- ns[[".package"]][["version"]]
[16:59:33.997]                           if (is.null(version)) 
[16:59:33.997]                             version <- utils::packageVersion("future")
[16:59:33.997]                         }
[16:59:33.997]                         else {
[16:59:33.997]                           version <- NULL
[16:59:33.997]                         }
[16:59:33.997]                         if (!has_future || version < "1.8.0") {
[16:59:33.997]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:33.997]                             "", base::R.version$version.string), 
[16:59:33.997]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:33.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:33.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:33.997]                               "release", "version")], collapse = " "), 
[16:59:33.997]                             hostname = base::Sys.info()[["nodename"]])
[16:59:33.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:33.997]                             info)
[16:59:33.997]                           info <- base::paste(info, collapse = "; ")
[16:59:33.997]                           if (!has_future) {
[16:59:33.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:33.997]                               info)
[16:59:33.997]                           }
[16:59:33.997]                           else {
[16:59:33.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:33.997]                               info, version)
[16:59:33.997]                           }
[16:59:33.997]                           base::stop(msg)
[16:59:33.997]                         }
[16:59:33.997]                       })
[16:59:33.997]                     }
[16:59:33.997]                     base::local({
[16:59:33.997]                       for (pkg in "stats") {
[16:59:33.997]                         base::loadNamespace(pkg)
[16:59:33.997]                         base::library(pkg, character.only = TRUE)
[16:59:33.997]                       }
[16:59:33.997]                     })
[16:59:33.997]                   }
[16:59:33.997]                   ...future.strategy.old <- future::plan("list")
[16:59:33.997]                   options(future.plan = NULL)
[16:59:33.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:33.997]                 }
[16:59:33.997]                 ...future.workdir <- getwd()
[16:59:33.997]             }
[16:59:33.997]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:33.997]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:33.997]         }
[16:59:33.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:33.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:33.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:33.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:33.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:33.997]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:33.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:33.997]             base::names(...future.oldOptions))
[16:59:33.997]     }
[16:59:33.997]     if (FALSE) {
[16:59:33.997]     }
[16:59:33.997]     else {
[16:59:33.997]         if (TRUE) {
[16:59:33.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:33.997]                 open = "w")
[16:59:33.997]         }
[16:59:33.997]         else {
[16:59:33.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:33.997]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:33.997]         }
[16:59:33.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:33.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:33.997]             base::sink(type = "output", split = FALSE)
[16:59:33.997]             base::close(...future.stdout)
[16:59:33.997]         }, add = TRUE)
[16:59:33.997]     }
[16:59:33.997]     ...future.frame <- base::sys.nframe()
[16:59:33.997]     ...future.conditions <- base::list()
[16:59:33.997]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:33.997]     if (FALSE) {
[16:59:33.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:33.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:33.997]     }
[16:59:33.997]     ...future.result <- base::tryCatch({
[16:59:33.997]         base::withCallingHandlers({
[16:59:33.997]             ...future.value <- base::withVisible(base::local({
[16:59:33.997]                 do.call(function(...) {
[16:59:33.997]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:33.997]                   if (!identical(...future.globals.maxSize.org, 
[16:59:33.997]                     ...future.globals.maxSize)) {
[16:59:33.997]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:33.997]                     on.exit(options(oopts), add = TRUE)
[16:59:33.997]                   }
[16:59:33.997]                   {
[16:59:33.997]                     lapply(seq_along(...future.elements_ii), 
[16:59:33.997]                       FUN = function(jj) {
[16:59:33.997]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:33.997]                         ...future.FUN(...future.X_jj, ...)
[16:59:33.997]                       })
[16:59:33.997]                   }
[16:59:33.997]                 }, args = future.call.arguments)
[16:59:33.997]             }))
[16:59:33.997]             future::FutureResult(value = ...future.value$value, 
[16:59:33.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.997]                   ...future.rng), globalenv = if (FALSE) 
[16:59:33.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:33.997]                     ...future.globalenv.names))
[16:59:33.997]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:33.997]         }, condition = base::local({
[16:59:33.997]             c <- base::c
[16:59:33.997]             inherits <- base::inherits
[16:59:33.997]             invokeRestart <- base::invokeRestart
[16:59:33.997]             length <- base::length
[16:59:33.997]             list <- base::list
[16:59:33.997]             seq.int <- base::seq.int
[16:59:33.997]             signalCondition <- base::signalCondition
[16:59:33.997]             sys.calls <- base::sys.calls
[16:59:33.997]             `[[` <- base::`[[`
[16:59:33.997]             `+` <- base::`+`
[16:59:33.997]             `<<-` <- base::`<<-`
[16:59:33.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:33.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:33.997]                   3L)]
[16:59:33.997]             }
[16:59:33.997]             function(cond) {
[16:59:33.997]                 is_error <- inherits(cond, "error")
[16:59:33.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:33.997]                   NULL)
[16:59:33.997]                 if (is_error) {
[16:59:33.997]                   sessionInformation <- function() {
[16:59:33.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:33.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:33.997]                       search = base::search(), system = base::Sys.info())
[16:59:33.997]                   }
[16:59:33.997]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:33.997]                     cond$call), session = sessionInformation(), 
[16:59:33.997]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:33.997]                   signalCondition(cond)
[16:59:33.997]                 }
[16:59:33.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:33.997]                 "immediateCondition"))) {
[16:59:33.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:33.997]                   ...future.conditions[[length(...future.conditions) + 
[16:59:33.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:33.997]                   if (TRUE && !signal) {
[16:59:33.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.997]                     {
[16:59:33.997]                       inherits <- base::inherits
[16:59:33.997]                       invokeRestart <- base::invokeRestart
[16:59:33.997]                       is.null <- base::is.null
[16:59:33.997]                       muffled <- FALSE
[16:59:33.997]                       if (inherits(cond, "message")) {
[16:59:33.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.997]                         if (muffled) 
[16:59:33.997]                           invokeRestart("muffleMessage")
[16:59:33.997]                       }
[16:59:33.997]                       else if (inherits(cond, "warning")) {
[16:59:33.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.997]                         if (muffled) 
[16:59:33.997]                           invokeRestart("muffleWarning")
[16:59:33.997]                       }
[16:59:33.997]                       else if (inherits(cond, "condition")) {
[16:59:33.997]                         if (!is.null(pattern)) {
[16:59:33.997]                           computeRestarts <- base::computeRestarts
[16:59:33.997]                           grepl <- base::grepl
[16:59:33.997]                           restarts <- computeRestarts(cond)
[16:59:33.997]                           for (restart in restarts) {
[16:59:33.997]                             name <- restart$name
[16:59:33.997]                             if (is.null(name)) 
[16:59:33.997]                               next
[16:59:33.997]                             if (!grepl(pattern, name)) 
[16:59:33.997]                               next
[16:59:33.997]                             invokeRestart(restart)
[16:59:33.997]                             muffled <- TRUE
[16:59:33.997]                             break
[16:59:33.997]                           }
[16:59:33.997]                         }
[16:59:33.997]                       }
[16:59:33.997]                       invisible(muffled)
[16:59:33.997]                     }
[16:59:33.997]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.997]                   }
[16:59:33.997]                 }
[16:59:33.997]                 else {
[16:59:33.997]                   if (TRUE) {
[16:59:33.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:33.997]                     {
[16:59:33.997]                       inherits <- base::inherits
[16:59:33.997]                       invokeRestart <- base::invokeRestart
[16:59:33.997]                       is.null <- base::is.null
[16:59:33.997]                       muffled <- FALSE
[16:59:33.997]                       if (inherits(cond, "message")) {
[16:59:33.997]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:33.997]                         if (muffled) 
[16:59:33.997]                           invokeRestart("muffleMessage")
[16:59:33.997]                       }
[16:59:33.997]                       else if (inherits(cond, "warning")) {
[16:59:33.997]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:33.997]                         if (muffled) 
[16:59:33.997]                           invokeRestart("muffleWarning")
[16:59:33.997]                       }
[16:59:33.997]                       else if (inherits(cond, "condition")) {
[16:59:33.997]                         if (!is.null(pattern)) {
[16:59:33.997]                           computeRestarts <- base::computeRestarts
[16:59:33.997]                           grepl <- base::grepl
[16:59:33.997]                           restarts <- computeRestarts(cond)
[16:59:33.997]                           for (restart in restarts) {
[16:59:33.997]                             name <- restart$name
[16:59:33.997]                             if (is.null(name)) 
[16:59:33.997]                               next
[16:59:33.997]                             if (!grepl(pattern, name)) 
[16:59:33.997]                               next
[16:59:33.997]                             invokeRestart(restart)
[16:59:33.997]                             muffled <- TRUE
[16:59:33.997]                             break
[16:59:33.997]                           }
[16:59:33.997]                         }
[16:59:33.997]                       }
[16:59:33.997]                       invisible(muffled)
[16:59:33.997]                     }
[16:59:33.997]                     muffleCondition(cond, pattern = "^muffle")
[16:59:33.997]                   }
[16:59:33.997]                 }
[16:59:33.997]             }
[16:59:33.997]         }))
[16:59:33.997]     }, error = function(ex) {
[16:59:33.997]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:33.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:33.997]                 ...future.rng), started = ...future.startTime, 
[16:59:33.997]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:33.997]             version = "1.8"), class = "FutureResult")
[16:59:33.997]     }, finally = {
[16:59:33.997]         if (!identical(...future.workdir, getwd())) 
[16:59:33.997]             setwd(...future.workdir)
[16:59:33.997]         {
[16:59:33.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:33.997]                 ...future.oldOptions$nwarnings <- NULL
[16:59:33.997]             }
[16:59:33.997]             base::options(...future.oldOptions)
[16:59:33.997]             if (.Platform$OS.type == "windows") {
[16:59:33.997]                 old_names <- names(...future.oldEnvVars)
[16:59:33.997]                 envs <- base::Sys.getenv()
[16:59:33.997]                 names <- names(envs)
[16:59:33.997]                 common <- intersect(names, old_names)
[16:59:33.997]                 added <- setdiff(names, old_names)
[16:59:33.997]                 removed <- setdiff(old_names, names)
[16:59:33.997]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:33.997]                   envs[common]]
[16:59:33.997]                 NAMES <- toupper(changed)
[16:59:33.997]                 args <- list()
[16:59:33.997]                 for (kk in seq_along(NAMES)) {
[16:59:33.997]                   name <- changed[[kk]]
[16:59:33.997]                   NAME <- NAMES[[kk]]
[16:59:33.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.997]                     next
[16:59:33.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.997]                 }
[16:59:33.997]                 NAMES <- toupper(added)
[16:59:33.997]                 for (kk in seq_along(NAMES)) {
[16:59:33.997]                   name <- added[[kk]]
[16:59:33.997]                   NAME <- NAMES[[kk]]
[16:59:33.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.997]                     next
[16:59:33.997]                   args[[name]] <- ""
[16:59:33.997]                 }
[16:59:33.997]                 NAMES <- toupper(removed)
[16:59:33.997]                 for (kk in seq_along(NAMES)) {
[16:59:33.997]                   name <- removed[[kk]]
[16:59:33.997]                   NAME <- NAMES[[kk]]
[16:59:33.997]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:33.997]                     next
[16:59:33.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:33.997]                 }
[16:59:33.997]                 if (length(args) > 0) 
[16:59:33.997]                   base::do.call(base::Sys.setenv, args = args)
[16:59:33.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:33.997]             }
[16:59:33.997]             else {
[16:59:33.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:33.997]             }
[16:59:33.997]             {
[16:59:33.997]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:33.997]                   0L) {
[16:59:33.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:33.997]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:33.997]                   base::options(opts)
[16:59:33.997]                 }
[16:59:33.997]                 {
[16:59:33.997]                   {
[16:59:33.997]                     NULL
[16:59:33.997]                     RNGkind("Mersenne-Twister")
[16:59:33.997]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:33.997]                       inherits = FALSE)
[16:59:33.997]                   }
[16:59:33.997]                   options(future.plan = NULL)
[16:59:33.997]                   if (is.na(NA_character_)) 
[16:59:33.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:33.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:33.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:33.997]                     .init = FALSE)
[16:59:33.997]                 }
[16:59:33.997]             }
[16:59:33.997]         }
[16:59:33.997]     })
[16:59:33.997]     if (TRUE) {
[16:59:33.997]         base::sink(type = "output", split = FALSE)
[16:59:33.997]         if (TRUE) {
[16:59:33.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:33.997]         }
[16:59:33.997]         else {
[16:59:33.997]             ...future.result["stdout"] <- base::list(NULL)
[16:59:33.997]         }
[16:59:33.997]         base::close(...future.stdout)
[16:59:33.997]         ...future.stdout <- NULL
[16:59:33.997]     }
[16:59:33.997]     ...future.result$conditions <- ...future.conditions
[16:59:33.997]     ...future.result$finished <- base::Sys.time()
[16:59:33.997]     ...future.result
[16:59:33.997] }
[16:59:33.999] assign_globals() ...
[16:59:33.999] List of 7
[16:59:33.999]  $ ...future.FUN            :function (x)  
[16:59:33.999]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:33.999]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:33.999]  $ future.call.arguments    : list()
[16:59:33.999]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:33.999]  $ ...future.elements_ii    :List of 3
[16:59:33.999]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:33.999]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:33.999]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.999]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:33.999]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:33.999]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:33.999]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.999]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:33.999]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:33.999]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:33.999]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:33.999]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:33.999]  $ ...future.seeds_ii       : NULL
[16:59:33.999]  $ ...future.globals.maxSize: NULL
[16:59:33.999]  - attr(*, "where")=List of 7
[16:59:33.999]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:33.999]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:59:33.999]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:59:33.999]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:33.999]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:33.999]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:33.999]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:33.999]  - attr(*, "resolved")= logi FALSE
[16:59:33.999]  - attr(*, "total_size")= num 2320
[16:59:33.999]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:33.999]  - attr(*, "already-done")= logi TRUE
[16:59:34.009] - reassign environment for ‘...future.FUN’
[16:59:34.010] - copied ‘...future.FUN’ to environment
[16:59:34.010] - copied ‘breaks’ to environment
[16:59:34.010] - copied ‘wool’ to environment
[16:59:34.010] - copied ‘future.call.arguments’ to environment
[16:59:34.010] - copied ‘...future.elements_ii’ to environment
[16:59:34.010] - copied ‘...future.seeds_ii’ to environment
[16:59:34.010] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.010] assign_globals() ... done
[16:59:34.011] plan(): Setting new future strategy stack:
[16:59:34.011] List of future strategies:
[16:59:34.011] 1. sequential:
[16:59:34.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.011]    - tweaked: FALSE
[16:59:34.011]    - call: NULL
[16:59:34.011] plan(): nbrOfWorkers() = 1
[16:59:34.014] plan(): Setting new future strategy stack:
[16:59:34.014] List of future strategies:
[16:59:34.014] 1. sequential:
[16:59:34.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.014]    - tweaked: FALSE
[16:59:34.014]    - call: plan(strategy)
[16:59:34.015] plan(): nbrOfWorkers() = 1
[16:59:34.015] SequentialFuture started (and completed)
[16:59:34.015] - Launch lazy future ... done
[16:59:34.015] run() for ‘SequentialFuture’ ... done
[16:59:34.015] Created future:
[16:59:34.015] SequentialFuture:
[16:59:34.015] Label: ‘future_by-1’
[16:59:34.015] Expression:
[16:59:34.015] {
[16:59:34.015]     do.call(function(...) {
[16:59:34.015]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.015]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.015]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.015]             on.exit(options(oopts), add = TRUE)
[16:59:34.015]         }
[16:59:34.015]         {
[16:59:34.015]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.015]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.015]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.015]             })
[16:59:34.015]         }
[16:59:34.015]     }, args = future.call.arguments)
[16:59:34.015] }
[16:59:34.015] Lazy evaluation: FALSE
[16:59:34.015] Asynchronous evaluation: FALSE
[16:59:34.015] Local evaluation: TRUE
[16:59:34.015] Environment: 0x562052a73cc0
[16:59:34.015] Capture standard output: TRUE
[16:59:34.015] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.015] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:59:34.015] Packages: 1 packages (‘stats’)
[16:59:34.015] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.015] Resolved: TRUE
[16:59:34.015] Value: 25.57 KiB of class ‘list’
[16:59:34.015] Early signaling: FALSE
[16:59:34.015] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.015] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.017] Chunk #1 of 1 ... DONE
[16:59:34.017] Launching 1 futures (chunks) ... DONE
[16:59:34.017] Resolving 1 futures (chunks) ...
[16:59:34.017] resolve() on list ...
[16:59:34.017]  recursive: 0
[16:59:34.017]  length: 1
[16:59:34.017] 
[16:59:34.017] resolved() for ‘SequentialFuture’ ...
[16:59:34.017] - state: ‘finished’
[16:59:34.018] - run: TRUE
[16:59:34.018] - result: ‘FutureResult’
[16:59:34.018] resolved() for ‘SequentialFuture’ ... done
[16:59:34.018] Future #1
[16:59:34.018] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.018] - nx: 1
[16:59:34.018] - relay: TRUE
[16:59:34.018] - stdout: TRUE
[16:59:34.018] - signal: TRUE
[16:59:34.018] - resignal: FALSE
[16:59:34.018] - force: TRUE
[16:59:34.019] - relayed: [n=1] FALSE
[16:59:34.019] - queued futures: [n=1] FALSE
[16:59:34.019]  - until=1
[16:59:34.019]  - relaying element #1
[16:59:34.019] - relayed: [n=1] TRUE
[16:59:34.019] - queued futures: [n=1] TRUE
[16:59:34.019] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.019]  length: 0 (resolved future 1)
[16:59:34.019] Relaying remaining futures
[16:59:34.020] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.020] - nx: 1
[16:59:34.020] - relay: TRUE
[16:59:34.020] - stdout: TRUE
[16:59:34.020] - signal: TRUE
[16:59:34.020] - resignal: FALSE
[16:59:34.020] - force: TRUE
[16:59:34.020] - relayed: [n=1] TRUE
[16:59:34.020] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.020] - relayed: [n=1] TRUE
[16:59:34.020] - queued futures: [n=1] TRUE
[16:59:34.020] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.021] resolve() on list ... DONE
[16:59:34.021]  - Number of value chunks collected: 1
[16:59:34.021] Resolving 1 futures (chunks) ... DONE
[16:59:34.021] Reducing values from 1 chunks ...
[16:59:34.021]  - Number of values collected after concatenation: 3
[16:59:34.021]  - Number of values expected: 3
[16:59:34.021] Reducing values from 1 chunks ... DONE
[16:59:34.021] future_lapply() ... DONE
[16:59:34.021] future_by_internal() ... DONE
[16:59:34.022] future_by_internal() ...
[16:59:34.022] future_lapply() ...
[16:59:34.023] Number of chunks: 1
[16:59:34.023] getGlobalsAndPackagesXApply() ...
[16:59:34.023]  - future.globals: TRUE
[16:59:34.023] getGlobalsAndPackages() ...
[16:59:34.023] Searching for globals...
[16:59:34.024] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.024] Searching for globals ... DONE
[16:59:34.024] Resolving globals: FALSE
[16:59:34.024] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.025] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.025] - globals: [1] ‘FUN’
[16:59:34.025] 
[16:59:34.025] getGlobalsAndPackages() ... DONE
[16:59:34.027]  - globals found/used: [n=1] ‘FUN’
[16:59:34.027]  - needed namespaces: [n=0] 
[16:59:34.027] Finding globals ... DONE
[16:59:34.027]  - use_args: TRUE
[16:59:34.027]  - Getting '...' globals ...
[16:59:34.027] resolve() on list ...
[16:59:34.028]  recursive: 0
[16:59:34.028]  length: 1
[16:59:34.028]  elements: ‘...’
[16:59:34.028]  length: 0 (resolved future 1)
[16:59:34.028] resolve() on list ... DONE
[16:59:34.028]    - '...' content: [n=0] 
[16:59:34.028] List of 1
[16:59:34.028]  $ ...: list()
[16:59:34.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.028]  - attr(*, "where")=List of 1
[16:59:34.028]   ..$ ...:<environment: 0x562052c4fde0> 
[16:59:34.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.028]  - attr(*, "resolved")= logi TRUE
[16:59:34.028]  - attr(*, "total_size")= num NA
[16:59:34.031]  - Getting '...' globals ... DONE
[16:59:34.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.031] List of 2
[16:59:34.031]  $ ...future.FUN:function (object, ...)  
[16:59:34.031]  $ ...          : list()
[16:59:34.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.031]  - attr(*, "where")=List of 2
[16:59:34.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.031]   ..$ ...          :<environment: 0x562052c4fde0> 
[16:59:34.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.031]  - attr(*, "resolved")= logi FALSE
[16:59:34.031]  - attr(*, "total_size")= num 1240
[16:59:34.033] Packages to be attached in all futures: [n=0] 
[16:59:34.034] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.034] Number of futures (= number of chunks): 1
[16:59:34.034] Launching 1 futures (chunks) ...
[16:59:34.034] Chunk #1 of 1 ...
[16:59:34.034]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.034] getGlobalsAndPackages() ...
[16:59:34.034] Searching for globals...
[16:59:34.035] 
[16:59:34.035] Searching for globals ... DONE
[16:59:34.035] - globals: [0] <none>
[16:59:34.035] getGlobalsAndPackages() ... DONE
[16:59:34.035]    + additional globals found: [n=0] 
[16:59:34.035]    + additional namespaces needed: [n=0] 
[16:59:34.035]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.035]  - seeds: <none>
[16:59:34.035]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.036] getGlobalsAndPackages() ...
[16:59:34.036] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.036] Resolving globals: FALSE
[16:59:34.036] Tweak future expression to call with '...' arguments ...
[16:59:34.036] {
[16:59:34.036]     do.call(function(...) {
[16:59:34.036]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.036]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.036]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.036]             on.exit(options(oopts), add = TRUE)
[16:59:34.036]         }
[16:59:34.036]         {
[16:59:34.036]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.036]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.036]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.036]             })
[16:59:34.036]         }
[16:59:34.036]     }, args = future.call.arguments)
[16:59:34.036] }
[16:59:34.036] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.037] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.037] 
[16:59:34.037] getGlobalsAndPackages() ... DONE
[16:59:34.037] run() for ‘Future’ ...
[16:59:34.037] - state: ‘created’
[16:59:34.037] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:34.038] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.038] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.038]   - Field: ‘label’
[16:59:34.038]   - Field: ‘local’
[16:59:34.038]   - Field: ‘owner’
[16:59:34.038]   - Field: ‘envir’
[16:59:34.038]   - Field: ‘packages’
[16:59:34.038]   - Field: ‘gc’
[16:59:34.038]   - Field: ‘conditions’
[16:59:34.038]   - Field: ‘expr’
[16:59:34.039]   - Field: ‘uuid’
[16:59:34.039]   - Field: ‘seed’
[16:59:34.039]   - Field: ‘version’
[16:59:34.039]   - Field: ‘result’
[16:59:34.039]   - Field: ‘asynchronous’
[16:59:34.039]   - Field: ‘calls’
[16:59:34.039]   - Field: ‘globals’
[16:59:34.039]   - Field: ‘stdout’
[16:59:34.039]   - Field: ‘earlySignal’
[16:59:34.039]   - Field: ‘lazy’
[16:59:34.039]   - Field: ‘state’
[16:59:34.039] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.040] - Launch lazy future ...
[16:59:34.040] Packages needed by the future expression (n = 0): <none>
[16:59:34.040] Packages needed by future strategies (n = 0): <none>
[16:59:34.040] {
[16:59:34.040]     {
[16:59:34.040]         {
[16:59:34.040]             ...future.startTime <- base::Sys.time()
[16:59:34.040]             {
[16:59:34.040]                 {
[16:59:34.040]                   {
[16:59:34.040]                     base::local({
[16:59:34.040]                       has_future <- base::requireNamespace("future", 
[16:59:34.040]                         quietly = TRUE)
[16:59:34.040]                       if (has_future) {
[16:59:34.040]                         ns <- base::getNamespace("future")
[16:59:34.040]                         version <- ns[[".package"]][["version"]]
[16:59:34.040]                         if (is.null(version)) 
[16:59:34.040]                           version <- utils::packageVersion("future")
[16:59:34.040]                       }
[16:59:34.040]                       else {
[16:59:34.040]                         version <- NULL
[16:59:34.040]                       }
[16:59:34.040]                       if (!has_future || version < "1.8.0") {
[16:59:34.040]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.040]                           "", base::R.version$version.string), 
[16:59:34.040]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.040]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.040]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.040]                             "release", "version")], collapse = " "), 
[16:59:34.040]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.040]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.040]                           info)
[16:59:34.040]                         info <- base::paste(info, collapse = "; ")
[16:59:34.040]                         if (!has_future) {
[16:59:34.040]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.040]                             info)
[16:59:34.040]                         }
[16:59:34.040]                         else {
[16:59:34.040]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.040]                             info, version)
[16:59:34.040]                         }
[16:59:34.040]                         base::stop(msg)
[16:59:34.040]                       }
[16:59:34.040]                     })
[16:59:34.040]                   }
[16:59:34.040]                   ...future.strategy.old <- future::plan("list")
[16:59:34.040]                   options(future.plan = NULL)
[16:59:34.040]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.040]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.040]                 }
[16:59:34.040]                 ...future.workdir <- getwd()
[16:59:34.040]             }
[16:59:34.040]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.040]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.040]         }
[16:59:34.040]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.040]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.040]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.040]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.040]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.040]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.040]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.040]             base::names(...future.oldOptions))
[16:59:34.040]     }
[16:59:34.040]     if (FALSE) {
[16:59:34.040]     }
[16:59:34.040]     else {
[16:59:34.040]         if (TRUE) {
[16:59:34.040]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.040]                 open = "w")
[16:59:34.040]         }
[16:59:34.040]         else {
[16:59:34.040]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.040]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.040]         }
[16:59:34.040]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.040]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.040]             base::sink(type = "output", split = FALSE)
[16:59:34.040]             base::close(...future.stdout)
[16:59:34.040]         }, add = TRUE)
[16:59:34.040]     }
[16:59:34.040]     ...future.frame <- base::sys.nframe()
[16:59:34.040]     ...future.conditions <- base::list()
[16:59:34.040]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.040]     if (FALSE) {
[16:59:34.040]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.040]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.040]     }
[16:59:34.040]     ...future.result <- base::tryCatch({
[16:59:34.040]         base::withCallingHandlers({
[16:59:34.040]             ...future.value <- base::withVisible(base::local({
[16:59:34.040]                 do.call(function(...) {
[16:59:34.040]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.040]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.040]                     ...future.globals.maxSize)) {
[16:59:34.040]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.040]                     on.exit(options(oopts), add = TRUE)
[16:59:34.040]                   }
[16:59:34.040]                   {
[16:59:34.040]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.040]                       FUN = function(jj) {
[16:59:34.040]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.040]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.040]                       })
[16:59:34.040]                   }
[16:59:34.040]                 }, args = future.call.arguments)
[16:59:34.040]             }))
[16:59:34.040]             future::FutureResult(value = ...future.value$value, 
[16:59:34.040]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.040]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.040]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.040]                     ...future.globalenv.names))
[16:59:34.040]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.040]         }, condition = base::local({
[16:59:34.040]             c <- base::c
[16:59:34.040]             inherits <- base::inherits
[16:59:34.040]             invokeRestart <- base::invokeRestart
[16:59:34.040]             length <- base::length
[16:59:34.040]             list <- base::list
[16:59:34.040]             seq.int <- base::seq.int
[16:59:34.040]             signalCondition <- base::signalCondition
[16:59:34.040]             sys.calls <- base::sys.calls
[16:59:34.040]             `[[` <- base::`[[`
[16:59:34.040]             `+` <- base::`+`
[16:59:34.040]             `<<-` <- base::`<<-`
[16:59:34.040]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.040]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.040]                   3L)]
[16:59:34.040]             }
[16:59:34.040]             function(cond) {
[16:59:34.040]                 is_error <- inherits(cond, "error")
[16:59:34.040]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.040]                   NULL)
[16:59:34.040]                 if (is_error) {
[16:59:34.040]                   sessionInformation <- function() {
[16:59:34.040]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.040]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.040]                       search = base::search(), system = base::Sys.info())
[16:59:34.040]                   }
[16:59:34.040]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.040]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.040]                     cond$call), session = sessionInformation(), 
[16:59:34.040]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.040]                   signalCondition(cond)
[16:59:34.040]                 }
[16:59:34.040]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.040]                 "immediateCondition"))) {
[16:59:34.040]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.040]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.040]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.040]                   if (TRUE && !signal) {
[16:59:34.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.040]                     {
[16:59:34.040]                       inherits <- base::inherits
[16:59:34.040]                       invokeRestart <- base::invokeRestart
[16:59:34.040]                       is.null <- base::is.null
[16:59:34.040]                       muffled <- FALSE
[16:59:34.040]                       if (inherits(cond, "message")) {
[16:59:34.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.040]                         if (muffled) 
[16:59:34.040]                           invokeRestart("muffleMessage")
[16:59:34.040]                       }
[16:59:34.040]                       else if (inherits(cond, "warning")) {
[16:59:34.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.040]                         if (muffled) 
[16:59:34.040]                           invokeRestart("muffleWarning")
[16:59:34.040]                       }
[16:59:34.040]                       else if (inherits(cond, "condition")) {
[16:59:34.040]                         if (!is.null(pattern)) {
[16:59:34.040]                           computeRestarts <- base::computeRestarts
[16:59:34.040]                           grepl <- base::grepl
[16:59:34.040]                           restarts <- computeRestarts(cond)
[16:59:34.040]                           for (restart in restarts) {
[16:59:34.040]                             name <- restart$name
[16:59:34.040]                             if (is.null(name)) 
[16:59:34.040]                               next
[16:59:34.040]                             if (!grepl(pattern, name)) 
[16:59:34.040]                               next
[16:59:34.040]                             invokeRestart(restart)
[16:59:34.040]                             muffled <- TRUE
[16:59:34.040]                             break
[16:59:34.040]                           }
[16:59:34.040]                         }
[16:59:34.040]                       }
[16:59:34.040]                       invisible(muffled)
[16:59:34.040]                     }
[16:59:34.040]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.040]                   }
[16:59:34.040]                 }
[16:59:34.040]                 else {
[16:59:34.040]                   if (TRUE) {
[16:59:34.040]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.040]                     {
[16:59:34.040]                       inherits <- base::inherits
[16:59:34.040]                       invokeRestart <- base::invokeRestart
[16:59:34.040]                       is.null <- base::is.null
[16:59:34.040]                       muffled <- FALSE
[16:59:34.040]                       if (inherits(cond, "message")) {
[16:59:34.040]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.040]                         if (muffled) 
[16:59:34.040]                           invokeRestart("muffleMessage")
[16:59:34.040]                       }
[16:59:34.040]                       else if (inherits(cond, "warning")) {
[16:59:34.040]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.040]                         if (muffled) 
[16:59:34.040]                           invokeRestart("muffleWarning")
[16:59:34.040]                       }
[16:59:34.040]                       else if (inherits(cond, "condition")) {
[16:59:34.040]                         if (!is.null(pattern)) {
[16:59:34.040]                           computeRestarts <- base::computeRestarts
[16:59:34.040]                           grepl <- base::grepl
[16:59:34.040]                           restarts <- computeRestarts(cond)
[16:59:34.040]                           for (restart in restarts) {
[16:59:34.040]                             name <- restart$name
[16:59:34.040]                             if (is.null(name)) 
[16:59:34.040]                               next
[16:59:34.040]                             if (!grepl(pattern, name)) 
[16:59:34.040]                               next
[16:59:34.040]                             invokeRestart(restart)
[16:59:34.040]                             muffled <- TRUE
[16:59:34.040]                             break
[16:59:34.040]                           }
[16:59:34.040]                         }
[16:59:34.040]                       }
[16:59:34.040]                       invisible(muffled)
[16:59:34.040]                     }
[16:59:34.040]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.040]                   }
[16:59:34.040]                 }
[16:59:34.040]             }
[16:59:34.040]         }))
[16:59:34.040]     }, error = function(ex) {
[16:59:34.040]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.040]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.040]                 ...future.rng), started = ...future.startTime, 
[16:59:34.040]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.040]             version = "1.8"), class = "FutureResult")
[16:59:34.040]     }, finally = {
[16:59:34.040]         if (!identical(...future.workdir, getwd())) 
[16:59:34.040]             setwd(...future.workdir)
[16:59:34.040]         {
[16:59:34.040]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.040]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.040]             }
[16:59:34.040]             base::options(...future.oldOptions)
[16:59:34.040]             if (.Platform$OS.type == "windows") {
[16:59:34.040]                 old_names <- names(...future.oldEnvVars)
[16:59:34.040]                 envs <- base::Sys.getenv()
[16:59:34.040]                 names <- names(envs)
[16:59:34.040]                 common <- intersect(names, old_names)
[16:59:34.040]                 added <- setdiff(names, old_names)
[16:59:34.040]                 removed <- setdiff(old_names, names)
[16:59:34.040]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.040]                   envs[common]]
[16:59:34.040]                 NAMES <- toupper(changed)
[16:59:34.040]                 args <- list()
[16:59:34.040]                 for (kk in seq_along(NAMES)) {
[16:59:34.040]                   name <- changed[[kk]]
[16:59:34.040]                   NAME <- NAMES[[kk]]
[16:59:34.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.040]                     next
[16:59:34.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.040]                 }
[16:59:34.040]                 NAMES <- toupper(added)
[16:59:34.040]                 for (kk in seq_along(NAMES)) {
[16:59:34.040]                   name <- added[[kk]]
[16:59:34.040]                   NAME <- NAMES[[kk]]
[16:59:34.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.040]                     next
[16:59:34.040]                   args[[name]] <- ""
[16:59:34.040]                 }
[16:59:34.040]                 NAMES <- toupper(removed)
[16:59:34.040]                 for (kk in seq_along(NAMES)) {
[16:59:34.040]                   name <- removed[[kk]]
[16:59:34.040]                   NAME <- NAMES[[kk]]
[16:59:34.040]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.040]                     next
[16:59:34.040]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.040]                 }
[16:59:34.040]                 if (length(args) > 0) 
[16:59:34.040]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.040]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.040]             }
[16:59:34.040]             else {
[16:59:34.040]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.040]             }
[16:59:34.040]             {
[16:59:34.040]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.040]                   0L) {
[16:59:34.040]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.040]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.040]                   base::options(opts)
[16:59:34.040]                 }
[16:59:34.040]                 {
[16:59:34.040]                   {
[16:59:34.040]                     NULL
[16:59:34.040]                     RNGkind("Mersenne-Twister")
[16:59:34.040]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.040]                       inherits = FALSE)
[16:59:34.040]                   }
[16:59:34.040]                   options(future.plan = NULL)
[16:59:34.040]                   if (is.na(NA_character_)) 
[16:59:34.040]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.040]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.040]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.040]                     .init = FALSE)
[16:59:34.040]                 }
[16:59:34.040]             }
[16:59:34.040]         }
[16:59:34.040]     })
[16:59:34.040]     if (TRUE) {
[16:59:34.040]         base::sink(type = "output", split = FALSE)
[16:59:34.040]         if (TRUE) {
[16:59:34.040]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.040]         }
[16:59:34.040]         else {
[16:59:34.040]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.040]         }
[16:59:34.040]         base::close(...future.stdout)
[16:59:34.040]         ...future.stdout <- NULL
[16:59:34.040]     }
[16:59:34.040]     ...future.result$conditions <- ...future.conditions
[16:59:34.040]     ...future.result$finished <- base::Sys.time()
[16:59:34.040]     ...future.result
[16:59:34.040] }
[16:59:34.042] assign_globals() ...
[16:59:34.042] List of 5
[16:59:34.042]  $ ...future.FUN            :function (object, ...)  
[16:59:34.042]  $ future.call.arguments    : list()
[16:59:34.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.042]  $ ...future.elements_ii    :List of 3
[16:59:34.042]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.042]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.042]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.042]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.042]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.042]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.042]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.042]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.042]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.042]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.042]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.042]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.042]  $ ...future.seeds_ii       : NULL
[16:59:34.042]  $ ...future.globals.maxSize: NULL
[16:59:34.042]  - attr(*, "where")=List of 5
[16:59:34.042]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.042]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.042]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.042]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.042]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.042]  - attr(*, "resolved")= logi FALSE
[16:59:34.042]  - attr(*, "total_size")= num 1240
[16:59:34.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.042]  - attr(*, "already-done")= logi TRUE
[16:59:34.052] - copied ‘...future.FUN’ to environment
[16:59:34.052] - copied ‘future.call.arguments’ to environment
[16:59:34.052] - copied ‘...future.elements_ii’ to environment
[16:59:34.052] - copied ‘...future.seeds_ii’ to environment
[16:59:34.052] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.052] assign_globals() ... done
[16:59:34.053] plan(): Setting new future strategy stack:
[16:59:34.053] List of future strategies:
[16:59:34.053] 1. sequential:
[16:59:34.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.053]    - tweaked: FALSE
[16:59:34.053]    - call: NULL
[16:59:34.053] plan(): nbrOfWorkers() = 1
[16:59:34.055] plan(): Setting new future strategy stack:
[16:59:34.056] List of future strategies:
[16:59:34.056] 1. sequential:
[16:59:34.056]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.056]    - tweaked: FALSE
[16:59:34.056]    - call: plan(strategy)
[16:59:34.056] plan(): nbrOfWorkers() = 1
[16:59:34.056] SequentialFuture started (and completed)
[16:59:34.056] - Launch lazy future ... done
[16:59:34.056] run() for ‘SequentialFuture’ ... done
[16:59:34.057] Created future:
[16:59:34.057] SequentialFuture:
[16:59:34.057] Label: ‘future_by-1’
[16:59:34.057] Expression:
[16:59:34.057] {
[16:59:34.057]     do.call(function(...) {
[16:59:34.057]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.057]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.057]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.057]             on.exit(options(oopts), add = TRUE)
[16:59:34.057]         }
[16:59:34.057]         {
[16:59:34.057]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.057]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.057]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.057]             })
[16:59:34.057]         }
[16:59:34.057]     }, args = future.call.arguments)
[16:59:34.057] }
[16:59:34.057] Lazy evaluation: FALSE
[16:59:34.057] Asynchronous evaluation: FALSE
[16:59:34.057] Local evaluation: TRUE
[16:59:34.057] Environment: 0x562052be9be8
[16:59:34.057] Capture standard output: TRUE
[16:59:34.057] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.057] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.057] Packages: <none>
[16:59:34.057] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.057] Resolved: TRUE
[16:59:34.057] Value: 5.37 KiB of class ‘list’
[16:59:34.057] Early signaling: FALSE
[16:59:34.057] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.057] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.058] Chunk #1 of 1 ... DONE
[16:59:34.058] Launching 1 futures (chunks) ... DONE
[16:59:34.058] Resolving 1 futures (chunks) ...
[16:59:34.058] resolve() on list ...
[16:59:34.058]  recursive: 0
[16:59:34.058]  length: 1
[16:59:34.058] 
[16:59:34.059] resolved() for ‘SequentialFuture’ ...
[16:59:34.059] - state: ‘finished’
[16:59:34.059] - run: TRUE
[16:59:34.059] - result: ‘FutureResult’
[16:59:34.059] resolved() for ‘SequentialFuture’ ... done
[16:59:34.059] Future #1
[16:59:34.059] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.059] - nx: 1
[16:59:34.059] - relay: TRUE
[16:59:34.059] - stdout: TRUE
[16:59:34.060] - signal: TRUE
[16:59:34.060] - resignal: FALSE
[16:59:34.060] - force: TRUE
[16:59:34.060] - relayed: [n=1] FALSE
[16:59:34.060] - queued futures: [n=1] FALSE
[16:59:34.060]  - until=1
[16:59:34.060]  - relaying element #1
[16:59:34.060] - relayed: [n=1] TRUE
[16:59:34.060] - queued futures: [n=1] TRUE
[16:59:34.060] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.061]  length: 0 (resolved future 1)
[16:59:34.061] Relaying remaining futures
[16:59:34.061] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.061] - nx: 1
[16:59:34.061] - relay: TRUE
[16:59:34.061] - stdout: TRUE
[16:59:34.061] - signal: TRUE
[16:59:34.061] - resignal: FALSE
[16:59:34.061] - force: TRUE
[16:59:34.061] - relayed: [n=1] TRUE
[16:59:34.061] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.061] - relayed: [n=1] TRUE
[16:59:34.062] - queued futures: [n=1] TRUE
[16:59:34.062] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.062] resolve() on list ... DONE
[16:59:34.062]  - Number of value chunks collected: 1
[16:59:34.062] Resolving 1 futures (chunks) ... DONE
[16:59:34.062] Reducing values from 1 chunks ...
[16:59:34.062]  - Number of values collected after concatenation: 3
[16:59:34.062]  - Number of values expected: 3
[16:59:34.062] Reducing values from 1 chunks ... DONE
[16:59:34.062] future_lapply() ... DONE
[16:59:34.062] future_by_internal() ... DONE
[16:59:34.064] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:59:34.065] future_lapply() ...
[16:59:34.066] Number of chunks: 1
[16:59:34.066] getGlobalsAndPackagesXApply() ...
[16:59:34.066]  - future.globals: TRUE
[16:59:34.066] getGlobalsAndPackages() ...
[16:59:34.066] Searching for globals...
[16:59:34.067] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.067] Searching for globals ... DONE
[16:59:34.067] Resolving globals: FALSE
[16:59:34.068] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.068] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.068] - globals: [1] ‘FUN’
[16:59:34.068] 
[16:59:34.068] getGlobalsAndPackages() ... DONE
[16:59:34.068]  - globals found/used: [n=1] ‘FUN’
[16:59:34.068]  - needed namespaces: [n=0] 
[16:59:34.068] Finding globals ... DONE
[16:59:34.069]  - use_args: TRUE
[16:59:34.069]  - Getting '...' globals ...
[16:59:34.071] resolve() on list ...
[16:59:34.071]  recursive: 0
[16:59:34.071]  length: 1
[16:59:34.071]  elements: ‘...’
[16:59:34.071]  length: 0 (resolved future 1)
[16:59:34.071] resolve() on list ... DONE
[16:59:34.071]    - '...' content: [n=0] 
[16:59:34.071] List of 1
[16:59:34.071]  $ ...: list()
[16:59:34.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.071]  - attr(*, "where")=List of 1
[16:59:34.071]   ..$ ...:<environment: 0x562052babfb8> 
[16:59:34.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.071]  - attr(*, "resolved")= logi TRUE
[16:59:34.071]  - attr(*, "total_size")= num NA
[16:59:34.074]  - Getting '...' globals ... DONE
[16:59:34.074] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.074] List of 2
[16:59:34.074]  $ ...future.FUN:function (object, ...)  
[16:59:34.074]  $ ...          : list()
[16:59:34.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.074]  - attr(*, "where")=List of 2
[16:59:34.074]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.074]   ..$ ...          :<environment: 0x562052babfb8> 
[16:59:34.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.074]  - attr(*, "resolved")= logi FALSE
[16:59:34.074]  - attr(*, "total_size")= num 1240
[16:59:34.077] Packages to be attached in all futures: [n=0] 
[16:59:34.077] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.077] Number of futures (= number of chunks): 1
[16:59:34.077] Launching 1 futures (chunks) ...
[16:59:34.077] Chunk #1 of 1 ...
[16:59:34.077]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.077] getGlobalsAndPackages() ...
[16:59:34.078] Searching for globals...
[16:59:34.078] 
[16:59:34.078] Searching for globals ... DONE
[16:59:34.078] - globals: [0] <none>
[16:59:34.078] getGlobalsAndPackages() ... DONE
[16:59:34.078]    + additional globals found: [n=0] 
[16:59:34.079]    + additional namespaces needed: [n=0] 
[16:59:34.079]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.079]  - seeds: <none>
[16:59:34.079]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.079] getGlobalsAndPackages() ...
[16:59:34.079] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.079] Resolving globals: FALSE
[16:59:34.079] Tweak future expression to call with '...' arguments ...
[16:59:34.079] {
[16:59:34.079]     do.call(function(...) {
[16:59:34.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.079]             on.exit(options(oopts), add = TRUE)
[16:59:34.079]         }
[16:59:34.079]         {
[16:59:34.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.079]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.079]             })
[16:59:34.079]         }
[16:59:34.079]     }, args = future.call.arguments)
[16:59:34.079] }
[16:59:34.080] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.080] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.080] 
[16:59:34.080] getGlobalsAndPackages() ... DONE
[16:59:34.080] run() for ‘Future’ ...
[16:59:34.081] - state: ‘created’
[16:59:34.081] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:34.081] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.081]   - Field: ‘label’
[16:59:34.081]   - Field: ‘local’
[16:59:34.081]   - Field: ‘owner’
[16:59:34.081]   - Field: ‘envir’
[16:59:34.082]   - Field: ‘packages’
[16:59:34.082]   - Field: ‘gc’
[16:59:34.082]   - Field: ‘conditions’
[16:59:34.082]   - Field: ‘expr’
[16:59:34.082]   - Field: ‘uuid’
[16:59:34.082]   - Field: ‘seed’
[16:59:34.082]   - Field: ‘version’
[16:59:34.082]   - Field: ‘result’
[16:59:34.082]   - Field: ‘asynchronous’
[16:59:34.082]   - Field: ‘calls’
[16:59:34.082]   - Field: ‘globals’
[16:59:34.083]   - Field: ‘stdout’
[16:59:34.083]   - Field: ‘earlySignal’
[16:59:34.083]   - Field: ‘lazy’
[16:59:34.083]   - Field: ‘state’
[16:59:34.083] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.083] - Launch lazy future ...
[16:59:34.083] Packages needed by the future expression (n = 0): <none>
[16:59:34.083] Packages needed by future strategies (n = 0): <none>
[16:59:34.084] {
[16:59:34.084]     {
[16:59:34.084]         {
[16:59:34.084]             ...future.startTime <- base::Sys.time()
[16:59:34.084]             {
[16:59:34.084]                 {
[16:59:34.084]                   {
[16:59:34.084]                     base::local({
[16:59:34.084]                       has_future <- base::requireNamespace("future", 
[16:59:34.084]                         quietly = TRUE)
[16:59:34.084]                       if (has_future) {
[16:59:34.084]                         ns <- base::getNamespace("future")
[16:59:34.084]                         version <- ns[[".package"]][["version"]]
[16:59:34.084]                         if (is.null(version)) 
[16:59:34.084]                           version <- utils::packageVersion("future")
[16:59:34.084]                       }
[16:59:34.084]                       else {
[16:59:34.084]                         version <- NULL
[16:59:34.084]                       }
[16:59:34.084]                       if (!has_future || version < "1.8.0") {
[16:59:34.084]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.084]                           "", base::R.version$version.string), 
[16:59:34.084]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.084]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.084]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.084]                             "release", "version")], collapse = " "), 
[16:59:34.084]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.084]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.084]                           info)
[16:59:34.084]                         info <- base::paste(info, collapse = "; ")
[16:59:34.084]                         if (!has_future) {
[16:59:34.084]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.084]                             info)
[16:59:34.084]                         }
[16:59:34.084]                         else {
[16:59:34.084]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.084]                             info, version)
[16:59:34.084]                         }
[16:59:34.084]                         base::stop(msg)
[16:59:34.084]                       }
[16:59:34.084]                     })
[16:59:34.084]                   }
[16:59:34.084]                   ...future.strategy.old <- future::plan("list")
[16:59:34.084]                   options(future.plan = NULL)
[16:59:34.084]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.084]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.084]                 }
[16:59:34.084]                 ...future.workdir <- getwd()
[16:59:34.084]             }
[16:59:34.084]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.084]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.084]         }
[16:59:34.084]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.084]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.084]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.084]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.084]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.084]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.084]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.084]             base::names(...future.oldOptions))
[16:59:34.084]     }
[16:59:34.084]     if (FALSE) {
[16:59:34.084]     }
[16:59:34.084]     else {
[16:59:34.084]         if (TRUE) {
[16:59:34.084]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.084]                 open = "w")
[16:59:34.084]         }
[16:59:34.084]         else {
[16:59:34.084]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.084]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.084]         }
[16:59:34.084]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.084]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.084]             base::sink(type = "output", split = FALSE)
[16:59:34.084]             base::close(...future.stdout)
[16:59:34.084]         }, add = TRUE)
[16:59:34.084]     }
[16:59:34.084]     ...future.frame <- base::sys.nframe()
[16:59:34.084]     ...future.conditions <- base::list()
[16:59:34.084]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.084]     if (FALSE) {
[16:59:34.084]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.084]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.084]     }
[16:59:34.084]     ...future.result <- base::tryCatch({
[16:59:34.084]         base::withCallingHandlers({
[16:59:34.084]             ...future.value <- base::withVisible(base::local({
[16:59:34.084]                 do.call(function(...) {
[16:59:34.084]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.084]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.084]                     ...future.globals.maxSize)) {
[16:59:34.084]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.084]                     on.exit(options(oopts), add = TRUE)
[16:59:34.084]                   }
[16:59:34.084]                   {
[16:59:34.084]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.084]                       FUN = function(jj) {
[16:59:34.084]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.084]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.084]                       })
[16:59:34.084]                   }
[16:59:34.084]                 }, args = future.call.arguments)
[16:59:34.084]             }))
[16:59:34.084]             future::FutureResult(value = ...future.value$value, 
[16:59:34.084]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.084]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.084]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.084]                     ...future.globalenv.names))
[16:59:34.084]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.084]         }, condition = base::local({
[16:59:34.084]             c <- base::c
[16:59:34.084]             inherits <- base::inherits
[16:59:34.084]             invokeRestart <- base::invokeRestart
[16:59:34.084]             length <- base::length
[16:59:34.084]             list <- base::list
[16:59:34.084]             seq.int <- base::seq.int
[16:59:34.084]             signalCondition <- base::signalCondition
[16:59:34.084]             sys.calls <- base::sys.calls
[16:59:34.084]             `[[` <- base::`[[`
[16:59:34.084]             `+` <- base::`+`
[16:59:34.084]             `<<-` <- base::`<<-`
[16:59:34.084]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.084]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.084]                   3L)]
[16:59:34.084]             }
[16:59:34.084]             function(cond) {
[16:59:34.084]                 is_error <- inherits(cond, "error")
[16:59:34.084]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.084]                   NULL)
[16:59:34.084]                 if (is_error) {
[16:59:34.084]                   sessionInformation <- function() {
[16:59:34.084]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.084]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.084]                       search = base::search(), system = base::Sys.info())
[16:59:34.084]                   }
[16:59:34.084]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.084]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.084]                     cond$call), session = sessionInformation(), 
[16:59:34.084]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.084]                   signalCondition(cond)
[16:59:34.084]                 }
[16:59:34.084]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.084]                 "immediateCondition"))) {
[16:59:34.084]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.084]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.084]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.084]                   if (TRUE && !signal) {
[16:59:34.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.084]                     {
[16:59:34.084]                       inherits <- base::inherits
[16:59:34.084]                       invokeRestart <- base::invokeRestart
[16:59:34.084]                       is.null <- base::is.null
[16:59:34.084]                       muffled <- FALSE
[16:59:34.084]                       if (inherits(cond, "message")) {
[16:59:34.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.084]                         if (muffled) 
[16:59:34.084]                           invokeRestart("muffleMessage")
[16:59:34.084]                       }
[16:59:34.084]                       else if (inherits(cond, "warning")) {
[16:59:34.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.084]                         if (muffled) 
[16:59:34.084]                           invokeRestart("muffleWarning")
[16:59:34.084]                       }
[16:59:34.084]                       else if (inherits(cond, "condition")) {
[16:59:34.084]                         if (!is.null(pattern)) {
[16:59:34.084]                           computeRestarts <- base::computeRestarts
[16:59:34.084]                           grepl <- base::grepl
[16:59:34.084]                           restarts <- computeRestarts(cond)
[16:59:34.084]                           for (restart in restarts) {
[16:59:34.084]                             name <- restart$name
[16:59:34.084]                             if (is.null(name)) 
[16:59:34.084]                               next
[16:59:34.084]                             if (!grepl(pattern, name)) 
[16:59:34.084]                               next
[16:59:34.084]                             invokeRestart(restart)
[16:59:34.084]                             muffled <- TRUE
[16:59:34.084]                             break
[16:59:34.084]                           }
[16:59:34.084]                         }
[16:59:34.084]                       }
[16:59:34.084]                       invisible(muffled)
[16:59:34.084]                     }
[16:59:34.084]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.084]                   }
[16:59:34.084]                 }
[16:59:34.084]                 else {
[16:59:34.084]                   if (TRUE) {
[16:59:34.084]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.084]                     {
[16:59:34.084]                       inherits <- base::inherits
[16:59:34.084]                       invokeRestart <- base::invokeRestart
[16:59:34.084]                       is.null <- base::is.null
[16:59:34.084]                       muffled <- FALSE
[16:59:34.084]                       if (inherits(cond, "message")) {
[16:59:34.084]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.084]                         if (muffled) 
[16:59:34.084]                           invokeRestart("muffleMessage")
[16:59:34.084]                       }
[16:59:34.084]                       else if (inherits(cond, "warning")) {
[16:59:34.084]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.084]                         if (muffled) 
[16:59:34.084]                           invokeRestart("muffleWarning")
[16:59:34.084]                       }
[16:59:34.084]                       else if (inherits(cond, "condition")) {
[16:59:34.084]                         if (!is.null(pattern)) {
[16:59:34.084]                           computeRestarts <- base::computeRestarts
[16:59:34.084]                           grepl <- base::grepl
[16:59:34.084]                           restarts <- computeRestarts(cond)
[16:59:34.084]                           for (restart in restarts) {
[16:59:34.084]                             name <- restart$name
[16:59:34.084]                             if (is.null(name)) 
[16:59:34.084]                               next
[16:59:34.084]                             if (!grepl(pattern, name)) 
[16:59:34.084]                               next
[16:59:34.084]                             invokeRestart(restart)
[16:59:34.084]                             muffled <- TRUE
[16:59:34.084]                             break
[16:59:34.084]                           }
[16:59:34.084]                         }
[16:59:34.084]                       }
[16:59:34.084]                       invisible(muffled)
[16:59:34.084]                     }
[16:59:34.084]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.084]                   }
[16:59:34.084]                 }
[16:59:34.084]             }
[16:59:34.084]         }))
[16:59:34.084]     }, error = function(ex) {
[16:59:34.084]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.084]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.084]                 ...future.rng), started = ...future.startTime, 
[16:59:34.084]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.084]             version = "1.8"), class = "FutureResult")
[16:59:34.084]     }, finally = {
[16:59:34.084]         if (!identical(...future.workdir, getwd())) 
[16:59:34.084]             setwd(...future.workdir)
[16:59:34.084]         {
[16:59:34.084]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.084]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.084]             }
[16:59:34.084]             base::options(...future.oldOptions)
[16:59:34.084]             if (.Platform$OS.type == "windows") {
[16:59:34.084]                 old_names <- names(...future.oldEnvVars)
[16:59:34.084]                 envs <- base::Sys.getenv()
[16:59:34.084]                 names <- names(envs)
[16:59:34.084]                 common <- intersect(names, old_names)
[16:59:34.084]                 added <- setdiff(names, old_names)
[16:59:34.084]                 removed <- setdiff(old_names, names)
[16:59:34.084]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.084]                   envs[common]]
[16:59:34.084]                 NAMES <- toupper(changed)
[16:59:34.084]                 args <- list()
[16:59:34.084]                 for (kk in seq_along(NAMES)) {
[16:59:34.084]                   name <- changed[[kk]]
[16:59:34.084]                   NAME <- NAMES[[kk]]
[16:59:34.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.084]                     next
[16:59:34.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.084]                 }
[16:59:34.084]                 NAMES <- toupper(added)
[16:59:34.084]                 for (kk in seq_along(NAMES)) {
[16:59:34.084]                   name <- added[[kk]]
[16:59:34.084]                   NAME <- NAMES[[kk]]
[16:59:34.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.084]                     next
[16:59:34.084]                   args[[name]] <- ""
[16:59:34.084]                 }
[16:59:34.084]                 NAMES <- toupper(removed)
[16:59:34.084]                 for (kk in seq_along(NAMES)) {
[16:59:34.084]                   name <- removed[[kk]]
[16:59:34.084]                   NAME <- NAMES[[kk]]
[16:59:34.084]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.084]                     next
[16:59:34.084]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.084]                 }
[16:59:34.084]                 if (length(args) > 0) 
[16:59:34.084]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.084]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.084]             }
[16:59:34.084]             else {
[16:59:34.084]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.084]             }
[16:59:34.084]             {
[16:59:34.084]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.084]                   0L) {
[16:59:34.084]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.084]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.084]                   base::options(opts)
[16:59:34.084]                 }
[16:59:34.084]                 {
[16:59:34.084]                   {
[16:59:34.084]                     NULL
[16:59:34.084]                     RNGkind("Mersenne-Twister")
[16:59:34.084]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.084]                       inherits = FALSE)
[16:59:34.084]                   }
[16:59:34.084]                   options(future.plan = NULL)
[16:59:34.084]                   if (is.na(NA_character_)) 
[16:59:34.084]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.084]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.084]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.084]                     .init = FALSE)
[16:59:34.084]                 }
[16:59:34.084]             }
[16:59:34.084]         }
[16:59:34.084]     })
[16:59:34.084]     if (TRUE) {
[16:59:34.084]         base::sink(type = "output", split = FALSE)
[16:59:34.084]         if (TRUE) {
[16:59:34.084]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.084]         }
[16:59:34.084]         else {
[16:59:34.084]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.084]         }
[16:59:34.084]         base::close(...future.stdout)
[16:59:34.084]         ...future.stdout <- NULL
[16:59:34.084]     }
[16:59:34.084]     ...future.result$conditions <- ...future.conditions
[16:59:34.084]     ...future.result$finished <- base::Sys.time()
[16:59:34.084]     ...future.result
[16:59:34.084] }
[16:59:34.085] assign_globals() ...
[16:59:34.086] List of 5
[16:59:34.086]  $ ...future.FUN            :function (object, ...)  
[16:59:34.086]  $ future.call.arguments    : list()
[16:59:34.086]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.086]  $ ...future.elements_ii    :List of 3
[16:59:34.086]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.086]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.086]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.086]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.086]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.086]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.086]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.086]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.086]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.086]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.086]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.086]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.086]  $ ...future.seeds_ii       : NULL
[16:59:34.086]  $ ...future.globals.maxSize: NULL
[16:59:34.086]  - attr(*, "where")=List of 5
[16:59:34.086]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.086]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.086]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.086]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.086]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.086]  - attr(*, "resolved")= logi FALSE
[16:59:34.086]  - attr(*, "total_size")= num 1240
[16:59:34.086]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.086]  - attr(*, "already-done")= logi TRUE
[16:59:34.096] - copied ‘...future.FUN’ to environment
[16:59:34.096] - copied ‘future.call.arguments’ to environment
[16:59:34.096] - copied ‘...future.elements_ii’ to environment
[16:59:34.096] - copied ‘...future.seeds_ii’ to environment
[16:59:34.096] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.096] assign_globals() ... done
[16:59:34.097] plan(): Setting new future strategy stack:
[16:59:34.097] List of future strategies:
[16:59:34.097] 1. sequential:
[16:59:34.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.097]    - tweaked: FALSE
[16:59:34.097]    - call: NULL
[16:59:34.097] plan(): nbrOfWorkers() = 1
[16:59:34.099] plan(): Setting new future strategy stack:
[16:59:34.099] List of future strategies:
[16:59:34.099] 1. sequential:
[16:59:34.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.099]    - tweaked: FALSE
[16:59:34.099]    - call: plan(strategy)
[16:59:34.100] plan(): nbrOfWorkers() = 1
[16:59:34.100] SequentialFuture started (and completed)
[16:59:34.100] - Launch lazy future ... done
[16:59:34.100] run() for ‘SequentialFuture’ ... done
[16:59:34.100] Created future:
[16:59:34.100] SequentialFuture:
[16:59:34.100] Label: ‘future_by-1’
[16:59:34.100] Expression:
[16:59:34.100] {
[16:59:34.100]     do.call(function(...) {
[16:59:34.100]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.100]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.100]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.100]             on.exit(options(oopts), add = TRUE)
[16:59:34.100]         }
[16:59:34.100]         {
[16:59:34.100]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.100]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.100]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.100]             })
[16:59:34.100]         }
[16:59:34.100]     }, args = future.call.arguments)
[16:59:34.100] }
[16:59:34.100] Lazy evaluation: FALSE
[16:59:34.100] Asynchronous evaluation: FALSE
[16:59:34.100] Local evaluation: TRUE
[16:59:34.100] Environment: 0x562052a55cc0
[16:59:34.100] Capture standard output: TRUE
[16:59:34.100] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.100] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.100] Packages: <none>
[16:59:34.100] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.100] Resolved: TRUE
[16:59:34.100] Value: 5.37 KiB of class ‘list’
[16:59:34.100] Early signaling: FALSE
[16:59:34.100] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.100] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.102] Chunk #1 of 1 ... DONE
[16:59:34.102] Launching 1 futures (chunks) ... DONE
[16:59:34.102] Resolving 1 futures (chunks) ...
[16:59:34.102] resolve() on list ...
[16:59:34.102]  recursive: 0
[16:59:34.102]  length: 1
[16:59:34.102] 
[16:59:34.102] resolved() for ‘SequentialFuture’ ...
[16:59:34.103] - state: ‘finished’
[16:59:34.103] - run: TRUE
[16:59:34.103] - result: ‘FutureResult’
[16:59:34.103] resolved() for ‘SequentialFuture’ ... done
[16:59:34.103] Future #1
[16:59:34.103] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.103] - nx: 1
[16:59:34.103] - relay: TRUE
[16:59:34.103] - stdout: TRUE
[16:59:34.103] - signal: TRUE
[16:59:34.104] - resignal: FALSE
[16:59:34.104] - force: TRUE
[16:59:34.104] - relayed: [n=1] FALSE
[16:59:34.104] - queued futures: [n=1] FALSE
[16:59:34.104]  - until=1
[16:59:34.104]  - relaying element #1
[16:59:34.104] - relayed: [n=1] TRUE
[16:59:34.104] - queued futures: [n=1] TRUE
[16:59:34.104] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.104]  length: 0 (resolved future 1)
[16:59:34.105] Relaying remaining futures
[16:59:34.105] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.105] - nx: 1
[16:59:34.105] - relay: TRUE
[16:59:34.105] - stdout: TRUE
[16:59:34.105] - signal: TRUE
[16:59:34.105] - resignal: FALSE
[16:59:34.105] - force: TRUE
[16:59:34.105] - relayed: [n=1] TRUE
[16:59:34.105] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.105] - relayed: [n=1] TRUE
[16:59:34.106] - queued futures: [n=1] TRUE
[16:59:34.106] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.106] resolve() on list ... DONE
[16:59:34.106]  - Number of value chunks collected: 1
[16:59:34.106] Resolving 1 futures (chunks) ... DONE
[16:59:34.106] Reducing values from 1 chunks ...
[16:59:34.106]  - Number of values collected after concatenation: 3
[16:59:34.106]  - Number of values expected: 3
[16:59:34.106] Reducing values from 1 chunks ... DONE
[16:59:34.106] future_lapply() ... DONE
[16:59:34.106] future_by_internal() ... DONE
[16:59:34.107] future_by_internal() ...
- plan('multicore') ...
[16:59:34.108] plan(): Setting new future strategy stack:
[16:59:34.108] List of future strategies:
[16:59:34.108] 1. multicore:
[16:59:34.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.108]    - tweaked: FALSE
[16:59:34.108]    - call: plan(strategy)
[16:59:34.112] plan(): nbrOfWorkers() = 1
[16:59:34.112] future_by_internal() ...
[16:59:34.113] future_lapply() ...
[16:59:34.116] Number of chunks: 1
[16:59:34.116] getGlobalsAndPackagesXApply() ...
[16:59:34.116]  - future.globals: TRUE
[16:59:34.116] getGlobalsAndPackages() ...
[16:59:34.116] Searching for globals...
[16:59:34.118] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.118] Searching for globals ... DONE
[16:59:34.118] Resolving globals: FALSE
[16:59:34.120] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.120] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.121] - globals: [1] ‘FUN’
[16:59:34.121] 
[16:59:34.121] getGlobalsAndPackages() ... DONE
[16:59:34.121]  - globals found/used: [n=1] ‘FUN’
[16:59:34.121]  - needed namespaces: [n=0] 
[16:59:34.121] Finding globals ... DONE
[16:59:34.121]  - use_args: TRUE
[16:59:34.121]  - Getting '...' globals ...
[16:59:34.122] resolve() on list ...
[16:59:34.122]  recursive: 0
[16:59:34.122]  length: 1
[16:59:34.122]  elements: ‘...’
[16:59:34.122]  length: 0 (resolved future 1)
[16:59:34.122] resolve() on list ... DONE
[16:59:34.122]    - '...' content: [n=0] 
[16:59:34.122] List of 1
[16:59:34.122]  $ ...: list()
[16:59:34.122]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.122]  - attr(*, "where")=List of 1
[16:59:34.122]   ..$ ...:<environment: 0x562052bc5ed8> 
[16:59:34.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.122]  - attr(*, "resolved")= logi TRUE
[16:59:34.122]  - attr(*, "total_size")= num NA
[16:59:34.125]  - Getting '...' globals ... DONE
[16:59:34.125] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.125] List of 2
[16:59:34.125]  $ ...future.FUN:function (object, ...)  
[16:59:34.125]  $ ...          : list()
[16:59:34.125]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.125]  - attr(*, "where")=List of 2
[16:59:34.125]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.125]   ..$ ...          :<environment: 0x562052bc5ed8> 
[16:59:34.125]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.125]  - attr(*, "resolved")= logi FALSE
[16:59:34.125]  - attr(*, "total_size")= num 1240
[16:59:34.128] Packages to be attached in all futures: [n=0] 
[16:59:34.128] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.128] Number of futures (= number of chunks): 1
[16:59:34.128] Launching 1 futures (chunks) ...
[16:59:34.128] Chunk #1 of 1 ...
[16:59:34.128]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.129] getGlobalsAndPackages() ...
[16:59:34.129] Searching for globals...
[16:59:34.129] 
[16:59:34.129] Searching for globals ... DONE
[16:59:34.129] - globals: [0] <none>
[16:59:34.129] getGlobalsAndPackages() ... DONE
[16:59:34.129]    + additional globals found: [n=0] 
[16:59:34.130]    + additional namespaces needed: [n=0] 
[16:59:34.130]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.130]  - seeds: <none>
[16:59:34.130]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.130] getGlobalsAndPackages() ...
[16:59:34.130] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.130] Resolving globals: FALSE
[16:59:34.130] Tweak future expression to call with '...' arguments ...
[16:59:34.130] {
[16:59:34.130]     do.call(function(...) {
[16:59:34.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.130]             on.exit(options(oopts), add = TRUE)
[16:59:34.130]         }
[16:59:34.130]         {
[16:59:34.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.130]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.130]             })
[16:59:34.130]         }
[16:59:34.130]     }, args = future.call.arguments)
[16:59:34.130] }
[16:59:34.131] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.131] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.131] 
[16:59:34.131] getGlobalsAndPackages() ... DONE
[16:59:34.131] run() for ‘Future’ ...
[16:59:34.132] - state: ‘created’
[16:59:34.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.135] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.136]   - Field: ‘label’
[16:59:34.136]   - Field: ‘local’
[16:59:34.136]   - Field: ‘owner’
[16:59:34.136]   - Field: ‘envir’
[16:59:34.136]   - Field: ‘packages’
[16:59:34.136]   - Field: ‘gc’
[16:59:34.136]   - Field: ‘conditions’
[16:59:34.136]   - Field: ‘expr’
[16:59:34.136]   - Field: ‘uuid’
[16:59:34.136]   - Field: ‘seed’
[16:59:34.137]   - Field: ‘version’
[16:59:34.137]   - Field: ‘result’
[16:59:34.137]   - Field: ‘asynchronous’
[16:59:34.137]   - Field: ‘calls’
[16:59:34.137]   - Field: ‘globals’
[16:59:34.137]   - Field: ‘stdout’
[16:59:34.137]   - Field: ‘earlySignal’
[16:59:34.137]   - Field: ‘lazy’
[16:59:34.137]   - Field: ‘state’
[16:59:34.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.138] - Launch lazy future ...
[16:59:34.138] Packages needed by the future expression (n = 0): <none>
[16:59:34.138] Packages needed by future strategies (n = 0): <none>
[16:59:34.138] {
[16:59:34.138]     {
[16:59:34.138]         {
[16:59:34.138]             ...future.startTime <- base::Sys.time()
[16:59:34.138]             {
[16:59:34.138]                 {
[16:59:34.138]                   {
[16:59:34.138]                     base::local({
[16:59:34.138]                       has_future <- base::requireNamespace("future", 
[16:59:34.138]                         quietly = TRUE)
[16:59:34.138]                       if (has_future) {
[16:59:34.138]                         ns <- base::getNamespace("future")
[16:59:34.138]                         version <- ns[[".package"]][["version"]]
[16:59:34.138]                         if (is.null(version)) 
[16:59:34.138]                           version <- utils::packageVersion("future")
[16:59:34.138]                       }
[16:59:34.138]                       else {
[16:59:34.138]                         version <- NULL
[16:59:34.138]                       }
[16:59:34.138]                       if (!has_future || version < "1.8.0") {
[16:59:34.138]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.138]                           "", base::R.version$version.string), 
[16:59:34.138]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.138]                             "release", "version")], collapse = " "), 
[16:59:34.138]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.138]                           info)
[16:59:34.138]                         info <- base::paste(info, collapse = "; ")
[16:59:34.138]                         if (!has_future) {
[16:59:34.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.138]                             info)
[16:59:34.138]                         }
[16:59:34.138]                         else {
[16:59:34.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.138]                             info, version)
[16:59:34.138]                         }
[16:59:34.138]                         base::stop(msg)
[16:59:34.138]                       }
[16:59:34.138]                     })
[16:59:34.138]                   }
[16:59:34.138]                   ...future.strategy.old <- future::plan("list")
[16:59:34.138]                   options(future.plan = NULL)
[16:59:34.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.138]                 }
[16:59:34.138]                 ...future.workdir <- getwd()
[16:59:34.138]             }
[16:59:34.138]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.138]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.138]         }
[16:59:34.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.138]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.138]             base::names(...future.oldOptions))
[16:59:34.138]     }
[16:59:34.138]     if (FALSE) {
[16:59:34.138]     }
[16:59:34.138]     else {
[16:59:34.138]         if (TRUE) {
[16:59:34.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.138]                 open = "w")
[16:59:34.138]         }
[16:59:34.138]         else {
[16:59:34.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.138]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.138]         }
[16:59:34.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.138]             base::sink(type = "output", split = FALSE)
[16:59:34.138]             base::close(...future.stdout)
[16:59:34.138]         }, add = TRUE)
[16:59:34.138]     }
[16:59:34.138]     ...future.frame <- base::sys.nframe()
[16:59:34.138]     ...future.conditions <- base::list()
[16:59:34.138]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.138]     if (FALSE) {
[16:59:34.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.138]     }
[16:59:34.138]     ...future.result <- base::tryCatch({
[16:59:34.138]         base::withCallingHandlers({
[16:59:34.138]             ...future.value <- base::withVisible(base::local({
[16:59:34.138]                 do.call(function(...) {
[16:59:34.138]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.138]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.138]                     ...future.globals.maxSize)) {
[16:59:34.138]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.138]                     on.exit(options(oopts), add = TRUE)
[16:59:34.138]                   }
[16:59:34.138]                   {
[16:59:34.138]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.138]                       FUN = function(jj) {
[16:59:34.138]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.138]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.138]                       })
[16:59:34.138]                   }
[16:59:34.138]                 }, args = future.call.arguments)
[16:59:34.138]             }))
[16:59:34.138]             future::FutureResult(value = ...future.value$value, 
[16:59:34.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.138]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.138]                     ...future.globalenv.names))
[16:59:34.138]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.138]         }, condition = base::local({
[16:59:34.138]             c <- base::c
[16:59:34.138]             inherits <- base::inherits
[16:59:34.138]             invokeRestart <- base::invokeRestart
[16:59:34.138]             length <- base::length
[16:59:34.138]             list <- base::list
[16:59:34.138]             seq.int <- base::seq.int
[16:59:34.138]             signalCondition <- base::signalCondition
[16:59:34.138]             sys.calls <- base::sys.calls
[16:59:34.138]             `[[` <- base::`[[`
[16:59:34.138]             `+` <- base::`+`
[16:59:34.138]             `<<-` <- base::`<<-`
[16:59:34.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.138]                   3L)]
[16:59:34.138]             }
[16:59:34.138]             function(cond) {
[16:59:34.138]                 is_error <- inherits(cond, "error")
[16:59:34.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.138]                   NULL)
[16:59:34.138]                 if (is_error) {
[16:59:34.138]                   sessionInformation <- function() {
[16:59:34.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.138]                       search = base::search(), system = base::Sys.info())
[16:59:34.138]                   }
[16:59:34.138]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.138]                     cond$call), session = sessionInformation(), 
[16:59:34.138]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.138]                   signalCondition(cond)
[16:59:34.138]                 }
[16:59:34.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.138]                 "immediateCondition"))) {
[16:59:34.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.138]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.138]                   if (TRUE && !signal) {
[16:59:34.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.138]                     {
[16:59:34.138]                       inherits <- base::inherits
[16:59:34.138]                       invokeRestart <- base::invokeRestart
[16:59:34.138]                       is.null <- base::is.null
[16:59:34.138]                       muffled <- FALSE
[16:59:34.138]                       if (inherits(cond, "message")) {
[16:59:34.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.138]                         if (muffled) 
[16:59:34.138]                           invokeRestart("muffleMessage")
[16:59:34.138]                       }
[16:59:34.138]                       else if (inherits(cond, "warning")) {
[16:59:34.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.138]                         if (muffled) 
[16:59:34.138]                           invokeRestart("muffleWarning")
[16:59:34.138]                       }
[16:59:34.138]                       else if (inherits(cond, "condition")) {
[16:59:34.138]                         if (!is.null(pattern)) {
[16:59:34.138]                           computeRestarts <- base::computeRestarts
[16:59:34.138]                           grepl <- base::grepl
[16:59:34.138]                           restarts <- computeRestarts(cond)
[16:59:34.138]                           for (restart in restarts) {
[16:59:34.138]                             name <- restart$name
[16:59:34.138]                             if (is.null(name)) 
[16:59:34.138]                               next
[16:59:34.138]                             if (!grepl(pattern, name)) 
[16:59:34.138]                               next
[16:59:34.138]                             invokeRestart(restart)
[16:59:34.138]                             muffled <- TRUE
[16:59:34.138]                             break
[16:59:34.138]                           }
[16:59:34.138]                         }
[16:59:34.138]                       }
[16:59:34.138]                       invisible(muffled)
[16:59:34.138]                     }
[16:59:34.138]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.138]                   }
[16:59:34.138]                 }
[16:59:34.138]                 else {
[16:59:34.138]                   if (TRUE) {
[16:59:34.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.138]                     {
[16:59:34.138]                       inherits <- base::inherits
[16:59:34.138]                       invokeRestart <- base::invokeRestart
[16:59:34.138]                       is.null <- base::is.null
[16:59:34.138]                       muffled <- FALSE
[16:59:34.138]                       if (inherits(cond, "message")) {
[16:59:34.138]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.138]                         if (muffled) 
[16:59:34.138]                           invokeRestart("muffleMessage")
[16:59:34.138]                       }
[16:59:34.138]                       else if (inherits(cond, "warning")) {
[16:59:34.138]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.138]                         if (muffled) 
[16:59:34.138]                           invokeRestart("muffleWarning")
[16:59:34.138]                       }
[16:59:34.138]                       else if (inherits(cond, "condition")) {
[16:59:34.138]                         if (!is.null(pattern)) {
[16:59:34.138]                           computeRestarts <- base::computeRestarts
[16:59:34.138]                           grepl <- base::grepl
[16:59:34.138]                           restarts <- computeRestarts(cond)
[16:59:34.138]                           for (restart in restarts) {
[16:59:34.138]                             name <- restart$name
[16:59:34.138]                             if (is.null(name)) 
[16:59:34.138]                               next
[16:59:34.138]                             if (!grepl(pattern, name)) 
[16:59:34.138]                               next
[16:59:34.138]                             invokeRestart(restart)
[16:59:34.138]                             muffled <- TRUE
[16:59:34.138]                             break
[16:59:34.138]                           }
[16:59:34.138]                         }
[16:59:34.138]                       }
[16:59:34.138]                       invisible(muffled)
[16:59:34.138]                     }
[16:59:34.138]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.138]                   }
[16:59:34.138]                 }
[16:59:34.138]             }
[16:59:34.138]         }))
[16:59:34.138]     }, error = function(ex) {
[16:59:34.138]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.138]                 ...future.rng), started = ...future.startTime, 
[16:59:34.138]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.138]             version = "1.8"), class = "FutureResult")
[16:59:34.138]     }, finally = {
[16:59:34.138]         if (!identical(...future.workdir, getwd())) 
[16:59:34.138]             setwd(...future.workdir)
[16:59:34.138]         {
[16:59:34.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.138]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.138]             }
[16:59:34.138]             base::options(...future.oldOptions)
[16:59:34.138]             if (.Platform$OS.type == "windows") {
[16:59:34.138]                 old_names <- names(...future.oldEnvVars)
[16:59:34.138]                 envs <- base::Sys.getenv()
[16:59:34.138]                 names <- names(envs)
[16:59:34.138]                 common <- intersect(names, old_names)
[16:59:34.138]                 added <- setdiff(names, old_names)
[16:59:34.138]                 removed <- setdiff(old_names, names)
[16:59:34.138]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.138]                   envs[common]]
[16:59:34.138]                 NAMES <- toupper(changed)
[16:59:34.138]                 args <- list()
[16:59:34.138]                 for (kk in seq_along(NAMES)) {
[16:59:34.138]                   name <- changed[[kk]]
[16:59:34.138]                   NAME <- NAMES[[kk]]
[16:59:34.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.138]                     next
[16:59:34.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.138]                 }
[16:59:34.138]                 NAMES <- toupper(added)
[16:59:34.138]                 for (kk in seq_along(NAMES)) {
[16:59:34.138]                   name <- added[[kk]]
[16:59:34.138]                   NAME <- NAMES[[kk]]
[16:59:34.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.138]                     next
[16:59:34.138]                   args[[name]] <- ""
[16:59:34.138]                 }
[16:59:34.138]                 NAMES <- toupper(removed)
[16:59:34.138]                 for (kk in seq_along(NAMES)) {
[16:59:34.138]                   name <- removed[[kk]]
[16:59:34.138]                   NAME <- NAMES[[kk]]
[16:59:34.138]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.138]                     next
[16:59:34.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.138]                 }
[16:59:34.138]                 if (length(args) > 0) 
[16:59:34.138]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.138]             }
[16:59:34.138]             else {
[16:59:34.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.138]             }
[16:59:34.138]             {
[16:59:34.138]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.138]                   0L) {
[16:59:34.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.138]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.138]                   base::options(opts)
[16:59:34.138]                 }
[16:59:34.138]                 {
[16:59:34.138]                   {
[16:59:34.138]                     NULL
[16:59:34.138]                     RNGkind("Mersenne-Twister")
[16:59:34.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.138]                       inherits = FALSE)
[16:59:34.138]                   }
[16:59:34.138]                   options(future.plan = NULL)
[16:59:34.138]                   if (is.na(NA_character_)) 
[16:59:34.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.138]                     .init = FALSE)
[16:59:34.138]                 }
[16:59:34.138]             }
[16:59:34.138]         }
[16:59:34.138]     })
[16:59:34.138]     if (TRUE) {
[16:59:34.138]         base::sink(type = "output", split = FALSE)
[16:59:34.138]         if (TRUE) {
[16:59:34.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.138]         }
[16:59:34.138]         else {
[16:59:34.138]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.138]         }
[16:59:34.138]         base::close(...future.stdout)
[16:59:34.138]         ...future.stdout <- NULL
[16:59:34.138]     }
[16:59:34.138]     ...future.result$conditions <- ...future.conditions
[16:59:34.138]     ...future.result$finished <- base::Sys.time()
[16:59:34.138]     ...future.result
[16:59:34.138] }
[16:59:34.140] assign_globals() ...
[16:59:34.140] List of 5
[16:59:34.140]  $ ...future.FUN            :function (object, ...)  
[16:59:34.140]  $ future.call.arguments    : list()
[16:59:34.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.140]  $ ...future.elements_ii    :List of 3
[16:59:34.140]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.140]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.140]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.140]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.140]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.140]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.140]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.140]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.140]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.140]  $ ...future.seeds_ii       : NULL
[16:59:34.140]  $ ...future.globals.maxSize: NULL
[16:59:34.140]  - attr(*, "where")=List of 5
[16:59:34.140]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.140]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.140]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.140]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.140]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.140]  - attr(*, "resolved")= logi FALSE
[16:59:34.140]  - attr(*, "total_size")= num 1240
[16:59:34.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.140]  - attr(*, "already-done")= logi TRUE
[16:59:34.149] - copied ‘...future.FUN’ to environment
[16:59:34.150] - copied ‘future.call.arguments’ to environment
[16:59:34.150] - copied ‘...future.elements_ii’ to environment
[16:59:34.150] - copied ‘...future.seeds_ii’ to environment
[16:59:34.150] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.150] assign_globals() ... done
[16:59:34.150] plan(): Setting new future strategy stack:
[16:59:34.150] List of future strategies:
[16:59:34.150] 1. sequential:
[16:59:34.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.150]    - tweaked: FALSE
[16:59:34.150]    - call: NULL
[16:59:34.151] plan(): nbrOfWorkers() = 1
[16:59:34.153] plan(): Setting new future strategy stack:
[16:59:34.153] List of future strategies:
[16:59:34.153] 1. multicore:
[16:59:34.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.153]    - tweaked: FALSE
[16:59:34.153]    - call: plan(strategy)
[16:59:34.157] plan(): nbrOfWorkers() = 1
[16:59:34.157] SequentialFuture started (and completed)
[16:59:34.157] - Launch lazy future ... done
[16:59:34.157] run() for ‘SequentialFuture’ ... done
[16:59:34.157] Created future:
[16:59:34.157] SequentialFuture:
[16:59:34.157] Label: ‘future_by-1’
[16:59:34.157] Expression:
[16:59:34.157] {
[16:59:34.157]     do.call(function(...) {
[16:59:34.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.157]             on.exit(options(oopts), add = TRUE)
[16:59:34.157]         }
[16:59:34.157]         {
[16:59:34.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.157]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.157]             })
[16:59:34.157]         }
[16:59:34.157]     }, args = future.call.arguments)
[16:59:34.157] }
[16:59:34.157] Lazy evaluation: FALSE
[16:59:34.157] Asynchronous evaluation: FALSE
[16:59:34.157] Local evaluation: TRUE
[16:59:34.157] Environment: R_GlobalEnv
[16:59:34.157] Capture standard output: TRUE
[16:59:34.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.157] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.157] Packages: <none>
[16:59:34.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.157] Resolved: TRUE
[16:59:34.157] Value: 4.62 KiB of class ‘list’
[16:59:34.157] Early signaling: FALSE
[16:59:34.157] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.157] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.159] Chunk #1 of 1 ... DONE
[16:59:34.159] Launching 1 futures (chunks) ... DONE
[16:59:34.159] Resolving 1 futures (chunks) ...
[16:59:34.159] resolve() on list ...
[16:59:34.159]  recursive: 0
[16:59:34.159]  length: 1
[16:59:34.159] 
[16:59:34.159] resolved() for ‘SequentialFuture’ ...
[16:59:34.159] - state: ‘finished’
[16:59:34.160] - run: TRUE
[16:59:34.160] - result: ‘FutureResult’
[16:59:34.160] resolved() for ‘SequentialFuture’ ... done
[16:59:34.160] Future #1
[16:59:34.160] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.160] - nx: 1
[16:59:34.160] - relay: TRUE
[16:59:34.160] - stdout: TRUE
[16:59:34.160] - signal: TRUE
[16:59:34.160] - resignal: FALSE
[16:59:34.160] - force: TRUE
[16:59:34.161] - relayed: [n=1] FALSE
[16:59:34.161] - queued futures: [n=1] FALSE
[16:59:34.161]  - until=1
[16:59:34.161]  - relaying element #1
[16:59:34.161] - relayed: [n=1] TRUE
[16:59:34.161] - queued futures: [n=1] TRUE
[16:59:34.161] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.161]  length: 0 (resolved future 1)
[16:59:34.161] Relaying remaining futures
[16:59:34.161] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.162] - nx: 1
[16:59:34.162] - relay: TRUE
[16:59:34.162] - stdout: TRUE
[16:59:34.162] - signal: TRUE
[16:59:34.162] - resignal: FALSE
[16:59:34.162] - force: TRUE
[16:59:34.162] - relayed: [n=1] TRUE
[16:59:34.162] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.162] - relayed: [n=1] TRUE
[16:59:34.162] - queued futures: [n=1] TRUE
[16:59:34.162] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.163] resolve() on list ... DONE
[16:59:34.163]  - Number of value chunks collected: 1
[16:59:34.163] Resolving 1 futures (chunks) ... DONE
[16:59:34.163] Reducing values from 1 chunks ...
[16:59:34.163]  - Number of values collected after concatenation: 3
[16:59:34.163]  - Number of values expected: 3
[16:59:34.163] Reducing values from 1 chunks ... DONE
[16:59:34.163] future_lapply() ... DONE
[16:59:34.163] future_by_internal() ... DONE
[16:59:34.164] future_by_internal() ...
[16:59:34.164] future_lapply() ...
[16:59:34.168] Number of chunks: 1
[16:59:34.168] getGlobalsAndPackagesXApply() ...
[16:59:34.168]  - future.globals: TRUE
[16:59:34.168] getGlobalsAndPackages() ...
[16:59:34.168] Searching for globals...
[16:59:34.169] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.169] Searching for globals ... DONE
[16:59:34.169] Resolving globals: FALSE
[16:59:34.170] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.170] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.170] - globals: [1] ‘FUN’
[16:59:34.170] 
[16:59:34.172] getGlobalsAndPackages() ... DONE
[16:59:34.172]  - globals found/used: [n=1] ‘FUN’
[16:59:34.172]  - needed namespaces: [n=0] 
[16:59:34.173] Finding globals ... DONE
[16:59:34.173]  - use_args: TRUE
[16:59:34.173]  - Getting '...' globals ...
[16:59:34.173] resolve() on list ...
[16:59:34.173]  recursive: 0
[16:59:34.173]  length: 1
[16:59:34.173]  elements: ‘...’
[16:59:34.173]  length: 0 (resolved future 1)
[16:59:34.174] resolve() on list ... DONE
[16:59:34.174]    - '...' content: [n=1] ‘digits’
[16:59:34.174] List of 1
[16:59:34.174]  $ ...:List of 1
[16:59:34.174]   ..$ digits: int 2
[16:59:34.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.174]  - attr(*, "where")=List of 1
[16:59:34.174]   ..$ ...:<environment: 0x562052b571f0> 
[16:59:34.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.174]  - attr(*, "resolved")= logi TRUE
[16:59:34.174]  - attr(*, "total_size")= num NA
[16:59:34.177]  - Getting '...' globals ... DONE
[16:59:34.177] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.177] List of 2
[16:59:34.177]  $ ...future.FUN:function (object, ...)  
[16:59:34.177]  $ ...          :List of 1
[16:59:34.177]   ..$ digits: int 2
[16:59:34.177]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.177]  - attr(*, "where")=List of 2
[16:59:34.177]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.177]   ..$ ...          :<environment: 0x562052b571f0> 
[16:59:34.177]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.177]  - attr(*, "resolved")= logi FALSE
[16:59:34.177]  - attr(*, "total_size")= num 1296
[16:59:34.180] Packages to be attached in all futures: [n=0] 
[16:59:34.180] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.180] Number of futures (= number of chunks): 1
[16:59:34.181] Launching 1 futures (chunks) ...
[16:59:34.181] Chunk #1 of 1 ...
[16:59:34.181]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.181] getGlobalsAndPackages() ...
[16:59:34.181] Searching for globals...
[16:59:34.181] 
[16:59:34.181] Searching for globals ... DONE
[16:59:34.181] - globals: [0] <none>
[16:59:34.182] getGlobalsAndPackages() ... DONE
[16:59:34.182]    + additional globals found: [n=0] 
[16:59:34.182]    + additional namespaces needed: [n=0] 
[16:59:34.182]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.182]  - seeds: <none>
[16:59:34.182]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.182] getGlobalsAndPackages() ...
[16:59:34.182] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.182] Resolving globals: FALSE
[16:59:34.182] Tweak future expression to call with '...' arguments ...
[16:59:34.182] {
[16:59:34.182]     do.call(function(...) {
[16:59:34.182]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.182]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.182]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.182]             on.exit(options(oopts), add = TRUE)
[16:59:34.182]         }
[16:59:34.182]         {
[16:59:34.182]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.182]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.182]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.182]             })
[16:59:34.182]         }
[16:59:34.182]     }, args = future.call.arguments)
[16:59:34.182] }
[16:59:34.183] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.183] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.183] 
[16:59:34.183] getGlobalsAndPackages() ... DONE
[16:59:34.184] run() for ‘Future’ ...
[16:59:34.184] - state: ‘created’
[16:59:34.184] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.188] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.188] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.188]   - Field: ‘label’
[16:59:34.188]   - Field: ‘local’
[16:59:34.188]   - Field: ‘owner’
[16:59:34.188]   - Field: ‘envir’
[16:59:34.188]   - Field: ‘packages’
[16:59:34.188]   - Field: ‘gc’
[16:59:34.188]   - Field: ‘conditions’
[16:59:34.188]   - Field: ‘expr’
[16:59:34.189]   - Field: ‘uuid’
[16:59:34.189]   - Field: ‘seed’
[16:59:34.189]   - Field: ‘version’
[16:59:34.189]   - Field: ‘result’
[16:59:34.189]   - Field: ‘asynchronous’
[16:59:34.189]   - Field: ‘calls’
[16:59:34.189]   - Field: ‘globals’
[16:59:34.189]   - Field: ‘stdout’
[16:59:34.189]   - Field: ‘earlySignal’
[16:59:34.189]   - Field: ‘lazy’
[16:59:34.189]   - Field: ‘state’
[16:59:34.190] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.190] - Launch lazy future ...
[16:59:34.190] Packages needed by the future expression (n = 0): <none>
[16:59:34.190] Packages needed by future strategies (n = 0): <none>
[16:59:34.190] {
[16:59:34.190]     {
[16:59:34.190]         {
[16:59:34.190]             ...future.startTime <- base::Sys.time()
[16:59:34.190]             {
[16:59:34.190]                 {
[16:59:34.190]                   {
[16:59:34.190]                     base::local({
[16:59:34.190]                       has_future <- base::requireNamespace("future", 
[16:59:34.190]                         quietly = TRUE)
[16:59:34.190]                       if (has_future) {
[16:59:34.190]                         ns <- base::getNamespace("future")
[16:59:34.190]                         version <- ns[[".package"]][["version"]]
[16:59:34.190]                         if (is.null(version)) 
[16:59:34.190]                           version <- utils::packageVersion("future")
[16:59:34.190]                       }
[16:59:34.190]                       else {
[16:59:34.190]                         version <- NULL
[16:59:34.190]                       }
[16:59:34.190]                       if (!has_future || version < "1.8.0") {
[16:59:34.190]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.190]                           "", base::R.version$version.string), 
[16:59:34.190]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.190]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.190]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.190]                             "release", "version")], collapse = " "), 
[16:59:34.190]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.190]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.190]                           info)
[16:59:34.190]                         info <- base::paste(info, collapse = "; ")
[16:59:34.190]                         if (!has_future) {
[16:59:34.190]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.190]                             info)
[16:59:34.190]                         }
[16:59:34.190]                         else {
[16:59:34.190]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.190]                             info, version)
[16:59:34.190]                         }
[16:59:34.190]                         base::stop(msg)
[16:59:34.190]                       }
[16:59:34.190]                     })
[16:59:34.190]                   }
[16:59:34.190]                   ...future.strategy.old <- future::plan("list")
[16:59:34.190]                   options(future.plan = NULL)
[16:59:34.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.190]                 }
[16:59:34.190]                 ...future.workdir <- getwd()
[16:59:34.190]             }
[16:59:34.190]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.190]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.190]         }
[16:59:34.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.190]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.190]             base::names(...future.oldOptions))
[16:59:34.190]     }
[16:59:34.190]     if (FALSE) {
[16:59:34.190]     }
[16:59:34.190]     else {
[16:59:34.190]         if (TRUE) {
[16:59:34.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.190]                 open = "w")
[16:59:34.190]         }
[16:59:34.190]         else {
[16:59:34.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.190]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.190]         }
[16:59:34.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.190]             base::sink(type = "output", split = FALSE)
[16:59:34.190]             base::close(...future.stdout)
[16:59:34.190]         }, add = TRUE)
[16:59:34.190]     }
[16:59:34.190]     ...future.frame <- base::sys.nframe()
[16:59:34.190]     ...future.conditions <- base::list()
[16:59:34.190]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.190]     if (FALSE) {
[16:59:34.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.190]     }
[16:59:34.190]     ...future.result <- base::tryCatch({
[16:59:34.190]         base::withCallingHandlers({
[16:59:34.190]             ...future.value <- base::withVisible(base::local({
[16:59:34.190]                 do.call(function(...) {
[16:59:34.190]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.190]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.190]                     ...future.globals.maxSize)) {
[16:59:34.190]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.190]                     on.exit(options(oopts), add = TRUE)
[16:59:34.190]                   }
[16:59:34.190]                   {
[16:59:34.190]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.190]                       FUN = function(jj) {
[16:59:34.190]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.190]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.190]                       })
[16:59:34.190]                   }
[16:59:34.190]                 }, args = future.call.arguments)
[16:59:34.190]             }))
[16:59:34.190]             future::FutureResult(value = ...future.value$value, 
[16:59:34.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.190]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.190]                     ...future.globalenv.names))
[16:59:34.190]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.190]         }, condition = base::local({
[16:59:34.190]             c <- base::c
[16:59:34.190]             inherits <- base::inherits
[16:59:34.190]             invokeRestart <- base::invokeRestart
[16:59:34.190]             length <- base::length
[16:59:34.190]             list <- base::list
[16:59:34.190]             seq.int <- base::seq.int
[16:59:34.190]             signalCondition <- base::signalCondition
[16:59:34.190]             sys.calls <- base::sys.calls
[16:59:34.190]             `[[` <- base::`[[`
[16:59:34.190]             `+` <- base::`+`
[16:59:34.190]             `<<-` <- base::`<<-`
[16:59:34.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.190]                   3L)]
[16:59:34.190]             }
[16:59:34.190]             function(cond) {
[16:59:34.190]                 is_error <- inherits(cond, "error")
[16:59:34.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.190]                   NULL)
[16:59:34.190]                 if (is_error) {
[16:59:34.190]                   sessionInformation <- function() {
[16:59:34.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.190]                       search = base::search(), system = base::Sys.info())
[16:59:34.190]                   }
[16:59:34.190]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.190]                     cond$call), session = sessionInformation(), 
[16:59:34.190]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.190]                   signalCondition(cond)
[16:59:34.190]                 }
[16:59:34.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.190]                 "immediateCondition"))) {
[16:59:34.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.190]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.190]                   if (TRUE && !signal) {
[16:59:34.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.190]                     {
[16:59:34.190]                       inherits <- base::inherits
[16:59:34.190]                       invokeRestart <- base::invokeRestart
[16:59:34.190]                       is.null <- base::is.null
[16:59:34.190]                       muffled <- FALSE
[16:59:34.190]                       if (inherits(cond, "message")) {
[16:59:34.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.190]                         if (muffled) 
[16:59:34.190]                           invokeRestart("muffleMessage")
[16:59:34.190]                       }
[16:59:34.190]                       else if (inherits(cond, "warning")) {
[16:59:34.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.190]                         if (muffled) 
[16:59:34.190]                           invokeRestart("muffleWarning")
[16:59:34.190]                       }
[16:59:34.190]                       else if (inherits(cond, "condition")) {
[16:59:34.190]                         if (!is.null(pattern)) {
[16:59:34.190]                           computeRestarts <- base::computeRestarts
[16:59:34.190]                           grepl <- base::grepl
[16:59:34.190]                           restarts <- computeRestarts(cond)
[16:59:34.190]                           for (restart in restarts) {
[16:59:34.190]                             name <- restart$name
[16:59:34.190]                             if (is.null(name)) 
[16:59:34.190]                               next
[16:59:34.190]                             if (!grepl(pattern, name)) 
[16:59:34.190]                               next
[16:59:34.190]                             invokeRestart(restart)
[16:59:34.190]                             muffled <- TRUE
[16:59:34.190]                             break
[16:59:34.190]                           }
[16:59:34.190]                         }
[16:59:34.190]                       }
[16:59:34.190]                       invisible(muffled)
[16:59:34.190]                     }
[16:59:34.190]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.190]                   }
[16:59:34.190]                 }
[16:59:34.190]                 else {
[16:59:34.190]                   if (TRUE) {
[16:59:34.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.190]                     {
[16:59:34.190]                       inherits <- base::inherits
[16:59:34.190]                       invokeRestart <- base::invokeRestart
[16:59:34.190]                       is.null <- base::is.null
[16:59:34.190]                       muffled <- FALSE
[16:59:34.190]                       if (inherits(cond, "message")) {
[16:59:34.190]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.190]                         if (muffled) 
[16:59:34.190]                           invokeRestart("muffleMessage")
[16:59:34.190]                       }
[16:59:34.190]                       else if (inherits(cond, "warning")) {
[16:59:34.190]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.190]                         if (muffled) 
[16:59:34.190]                           invokeRestart("muffleWarning")
[16:59:34.190]                       }
[16:59:34.190]                       else if (inherits(cond, "condition")) {
[16:59:34.190]                         if (!is.null(pattern)) {
[16:59:34.190]                           computeRestarts <- base::computeRestarts
[16:59:34.190]                           grepl <- base::grepl
[16:59:34.190]                           restarts <- computeRestarts(cond)
[16:59:34.190]                           for (restart in restarts) {
[16:59:34.190]                             name <- restart$name
[16:59:34.190]                             if (is.null(name)) 
[16:59:34.190]                               next
[16:59:34.190]                             if (!grepl(pattern, name)) 
[16:59:34.190]                               next
[16:59:34.190]                             invokeRestart(restart)
[16:59:34.190]                             muffled <- TRUE
[16:59:34.190]                             break
[16:59:34.190]                           }
[16:59:34.190]                         }
[16:59:34.190]                       }
[16:59:34.190]                       invisible(muffled)
[16:59:34.190]                     }
[16:59:34.190]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.190]                   }
[16:59:34.190]                 }
[16:59:34.190]             }
[16:59:34.190]         }))
[16:59:34.190]     }, error = function(ex) {
[16:59:34.190]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.190]                 ...future.rng), started = ...future.startTime, 
[16:59:34.190]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.190]             version = "1.8"), class = "FutureResult")
[16:59:34.190]     }, finally = {
[16:59:34.190]         if (!identical(...future.workdir, getwd())) 
[16:59:34.190]             setwd(...future.workdir)
[16:59:34.190]         {
[16:59:34.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.190]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.190]             }
[16:59:34.190]             base::options(...future.oldOptions)
[16:59:34.190]             if (.Platform$OS.type == "windows") {
[16:59:34.190]                 old_names <- names(...future.oldEnvVars)
[16:59:34.190]                 envs <- base::Sys.getenv()
[16:59:34.190]                 names <- names(envs)
[16:59:34.190]                 common <- intersect(names, old_names)
[16:59:34.190]                 added <- setdiff(names, old_names)
[16:59:34.190]                 removed <- setdiff(old_names, names)
[16:59:34.190]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.190]                   envs[common]]
[16:59:34.190]                 NAMES <- toupper(changed)
[16:59:34.190]                 args <- list()
[16:59:34.190]                 for (kk in seq_along(NAMES)) {
[16:59:34.190]                   name <- changed[[kk]]
[16:59:34.190]                   NAME <- NAMES[[kk]]
[16:59:34.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.190]                     next
[16:59:34.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.190]                 }
[16:59:34.190]                 NAMES <- toupper(added)
[16:59:34.190]                 for (kk in seq_along(NAMES)) {
[16:59:34.190]                   name <- added[[kk]]
[16:59:34.190]                   NAME <- NAMES[[kk]]
[16:59:34.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.190]                     next
[16:59:34.190]                   args[[name]] <- ""
[16:59:34.190]                 }
[16:59:34.190]                 NAMES <- toupper(removed)
[16:59:34.190]                 for (kk in seq_along(NAMES)) {
[16:59:34.190]                   name <- removed[[kk]]
[16:59:34.190]                   NAME <- NAMES[[kk]]
[16:59:34.190]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.190]                     next
[16:59:34.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.190]                 }
[16:59:34.190]                 if (length(args) > 0) 
[16:59:34.190]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.190]             }
[16:59:34.190]             else {
[16:59:34.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.190]             }
[16:59:34.190]             {
[16:59:34.190]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.190]                   0L) {
[16:59:34.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.190]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.190]                   base::options(opts)
[16:59:34.190]                 }
[16:59:34.190]                 {
[16:59:34.190]                   {
[16:59:34.190]                     NULL
[16:59:34.190]                     RNGkind("Mersenne-Twister")
[16:59:34.190]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.190]                       inherits = FALSE)
[16:59:34.190]                   }
[16:59:34.190]                   options(future.plan = NULL)
[16:59:34.190]                   if (is.na(NA_character_)) 
[16:59:34.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.190]                     .init = FALSE)
[16:59:34.190]                 }
[16:59:34.190]             }
[16:59:34.190]         }
[16:59:34.190]     })
[16:59:34.190]     if (TRUE) {
[16:59:34.190]         base::sink(type = "output", split = FALSE)
[16:59:34.190]         if (TRUE) {
[16:59:34.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.190]         }
[16:59:34.190]         else {
[16:59:34.190]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.190]         }
[16:59:34.190]         base::close(...future.stdout)
[16:59:34.190]         ...future.stdout <- NULL
[16:59:34.190]     }
[16:59:34.190]     ...future.result$conditions <- ...future.conditions
[16:59:34.190]     ...future.result$finished <- base::Sys.time()
[16:59:34.190]     ...future.result
[16:59:34.190] }
[16:59:34.192] assign_globals() ...
[16:59:34.192] List of 5
[16:59:34.192]  $ ...future.FUN            :function (object, ...)  
[16:59:34.192]  $ future.call.arguments    :List of 1
[16:59:34.192]   ..$ digits: int 2
[16:59:34.192]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.192]  $ ...future.elements_ii    :List of 6
[16:59:34.192]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:59:34.192]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:59:34.192]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:59:34.192]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:59:34.192]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:59:34.192]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:59:34.192]  $ ...future.seeds_ii       : NULL
[16:59:34.192]  $ ...future.globals.maxSize: NULL
[16:59:34.192]  - attr(*, "where")=List of 5
[16:59:34.192]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.192]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.192]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.192]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.192]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.192]  - attr(*, "resolved")= logi FALSE
[16:59:34.192]  - attr(*, "total_size")= num 1296
[16:59:34.192]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.192]  - attr(*, "already-done")= logi TRUE
[16:59:34.201] - copied ‘...future.FUN’ to environment
[16:59:34.201] - copied ‘future.call.arguments’ to environment
[16:59:34.201] - copied ‘...future.elements_ii’ to environment
[16:59:34.201] - copied ‘...future.seeds_ii’ to environment
[16:59:34.201] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.201] assign_globals() ... done
[16:59:34.201] plan(): Setting new future strategy stack:
[16:59:34.202] List of future strategies:
[16:59:34.202] 1. sequential:
[16:59:34.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.202]    - tweaked: FALSE
[16:59:34.202]    - call: NULL
[16:59:34.202] plan(): nbrOfWorkers() = 1
[16:59:34.203] plan(): Setting new future strategy stack:
[16:59:34.204] List of future strategies:
[16:59:34.204] 1. multicore:
[16:59:34.204]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.204]    - tweaked: FALSE
[16:59:34.204]    - call: plan(strategy)
[16:59:34.207] plan(): nbrOfWorkers() = 1
[16:59:34.207] SequentialFuture started (and completed)
[16:59:34.208] - Launch lazy future ... done
[16:59:34.208] run() for ‘SequentialFuture’ ... done
[16:59:34.208] Created future:
[16:59:34.208] SequentialFuture:
[16:59:34.208] Label: ‘future_by-1’
[16:59:34.208] Expression:
[16:59:34.208] {
[16:59:34.208]     do.call(function(...) {
[16:59:34.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.208]             on.exit(options(oopts), add = TRUE)
[16:59:34.208]         }
[16:59:34.208]         {
[16:59:34.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.208]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.208]             })
[16:59:34.208]         }
[16:59:34.208]     }, args = future.call.arguments)
[16:59:34.208] }
[16:59:34.208] Lazy evaluation: FALSE
[16:59:34.208] Asynchronous evaluation: FALSE
[16:59:34.208] Local evaluation: TRUE
[16:59:34.208] Environment: R_GlobalEnv
[16:59:34.208] Capture standard output: TRUE
[16:59:34.208] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.208] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.208] Packages: <none>
[16:59:34.208] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.208] Resolved: TRUE
[16:59:34.208] Value: 5.48 KiB of class ‘list’
[16:59:34.208] Early signaling: FALSE
[16:59:34.208] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.208] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.209] Chunk #1 of 1 ... DONE
[16:59:34.209] Launching 1 futures (chunks) ... DONE
[16:59:34.209] Resolving 1 futures (chunks) ...
[16:59:34.209] resolve() on list ...
[16:59:34.209]  recursive: 0
[16:59:34.210]  length: 1
[16:59:34.210] 
[16:59:34.210] resolved() for ‘SequentialFuture’ ...
[16:59:34.210] - state: ‘finished’
[16:59:34.210] - run: TRUE
[16:59:34.210] - result: ‘FutureResult’
[16:59:34.210] resolved() for ‘SequentialFuture’ ... done
[16:59:34.210] Future #1
[16:59:34.210] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.210] - nx: 1
[16:59:34.211] - relay: TRUE
[16:59:34.211] - stdout: TRUE
[16:59:34.211] - signal: TRUE
[16:59:34.211] - resignal: FALSE
[16:59:34.211] - force: TRUE
[16:59:34.211] - relayed: [n=1] FALSE
[16:59:34.211] - queued futures: [n=1] FALSE
[16:59:34.211]  - until=1
[16:59:34.211]  - relaying element #1
[16:59:34.211] - relayed: [n=1] TRUE
[16:59:34.212] - queued futures: [n=1] TRUE
[16:59:34.212] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.212]  length: 0 (resolved future 1)
[16:59:34.212] Relaying remaining futures
[16:59:34.212] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.212] - nx: 1
[16:59:34.212] - relay: TRUE
[16:59:34.212] - stdout: TRUE
[16:59:34.212] - signal: TRUE
[16:59:34.212] - resignal: FALSE
[16:59:34.212] - force: TRUE
[16:59:34.212] - relayed: [n=1] TRUE
[16:59:34.213] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.213] - relayed: [n=1] TRUE
[16:59:34.213] - queued futures: [n=1] TRUE
[16:59:34.213] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.213] resolve() on list ... DONE
[16:59:34.213]  - Number of value chunks collected: 1
[16:59:34.213] Resolving 1 futures (chunks) ... DONE
[16:59:34.213] Reducing values from 1 chunks ...
[16:59:34.213]  - Number of values collected after concatenation: 6
[16:59:34.213]  - Number of values expected: 6
[16:59:34.214] Reducing values from 1 chunks ... DONE
[16:59:34.214] future_lapply() ... DONE
[16:59:34.214] future_by_internal() ... DONE
[16:59:34.215] future_by_internal() ...
[16:59:34.215] future_lapply() ...
[16:59:34.219] Number of chunks: 1
[16:59:34.220] getGlobalsAndPackagesXApply() ...
[16:59:34.220]  - future.globals: TRUE
[16:59:34.220] getGlobalsAndPackages() ...
[16:59:34.220] Searching for globals...
[16:59:34.223] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:34.223] Searching for globals ... DONE
[16:59:34.224] Resolving globals: FALSE
[16:59:34.224] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:59:34.224] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:59:34.224] - globals: [1] ‘FUN’
[16:59:34.225] - packages: [1] ‘stats’
[16:59:34.225] getGlobalsAndPackages() ... DONE
[16:59:34.225]  - globals found/used: [n=1] ‘FUN’
[16:59:34.225]  - needed namespaces: [n=1] ‘stats’
[16:59:34.225] Finding globals ... DONE
[16:59:34.225]  - use_args: TRUE
[16:59:34.225]  - Getting '...' globals ...
[16:59:34.226] resolve() on list ...
[16:59:34.226]  recursive: 0
[16:59:34.226]  length: 1
[16:59:34.226]  elements: ‘...’
[16:59:34.226]  length: 0 (resolved future 1)
[16:59:34.226] resolve() on list ... DONE
[16:59:34.226]    - '...' content: [n=1] ‘singular.ok’
[16:59:34.226] List of 1
[16:59:34.226]  $ ...:List of 1
[16:59:34.226]   ..$ singular.ok: logi FALSE
[16:59:34.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.226]  - attr(*, "where")=List of 1
[16:59:34.226]   ..$ ...:<environment: 0x562052b8ca00> 
[16:59:34.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.226]  - attr(*, "resolved")= logi TRUE
[16:59:34.226]  - attr(*, "total_size")= num NA
[16:59:34.229]  - Getting '...' globals ... DONE
[16:59:34.229] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.230] List of 2
[16:59:34.230]  $ ...future.FUN:function (x, ...)  
[16:59:34.230]  $ ...          :List of 1
[16:59:34.230]   ..$ singular.ok: logi FALSE
[16:59:34.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.230]  - attr(*, "where")=List of 2
[16:59:34.230]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.230]   ..$ ...          :<environment: 0x562052b8ca00> 
[16:59:34.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.230]  - attr(*, "resolved")= logi FALSE
[16:59:34.230]  - attr(*, "total_size")= num 5384
[16:59:34.233] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:34.233] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.233] Number of futures (= number of chunks): 1
[16:59:34.233] Launching 1 futures (chunks) ...
[16:59:34.233] Chunk #1 of 1 ...
[16:59:34.233]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.233] getGlobalsAndPackages() ...
[16:59:34.233] Searching for globals...
[16:59:34.234] 
[16:59:34.234] Searching for globals ... DONE
[16:59:34.234] - globals: [0] <none>
[16:59:34.234] getGlobalsAndPackages() ... DONE
[16:59:34.234]    + additional globals found: [n=0] 
[16:59:34.234]    + additional namespaces needed: [n=0] 
[16:59:34.234]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.235]  - seeds: <none>
[16:59:34.235]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.235] getGlobalsAndPackages() ...
[16:59:34.235] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.235] Resolving globals: FALSE
[16:59:34.235] Tweak future expression to call with '...' arguments ...
[16:59:34.235] {
[16:59:34.235]     do.call(function(...) {
[16:59:34.235]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.235]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.235]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.235]             on.exit(options(oopts), add = TRUE)
[16:59:34.235]         }
[16:59:34.235]         {
[16:59:34.235]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.235]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.235]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.235]             })
[16:59:34.235]         }
[16:59:34.235]     }, args = future.call.arguments)
[16:59:34.235] }
[16:59:34.235] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.236] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.236] 
[16:59:34.236] getGlobalsAndPackages() ... DONE
[16:59:34.236] run() for ‘Future’ ...
[16:59:34.236] - state: ‘created’
[16:59:34.237] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.240] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.240] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.240]   - Field: ‘label’
[16:59:34.241]   - Field: ‘local’
[16:59:34.241]   - Field: ‘owner’
[16:59:34.241]   - Field: ‘envir’
[16:59:34.241]   - Field: ‘packages’
[16:59:34.241]   - Field: ‘gc’
[16:59:34.241]   - Field: ‘conditions’
[16:59:34.241]   - Field: ‘expr’
[16:59:34.241]   - Field: ‘uuid’
[16:59:34.241]   - Field: ‘seed’
[16:59:34.241]   - Field: ‘version’
[16:59:34.242]   - Field: ‘result’
[16:59:34.242]   - Field: ‘asynchronous’
[16:59:34.242]   - Field: ‘calls’
[16:59:34.242]   - Field: ‘globals’
[16:59:34.242]   - Field: ‘stdout’
[16:59:34.242]   - Field: ‘earlySignal’
[16:59:34.242]   - Field: ‘lazy’
[16:59:34.242]   - Field: ‘state’
[16:59:34.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.242] - Launch lazy future ...
[16:59:34.243] Packages needed by the future expression (n = 1): ‘stats’
[16:59:34.243] Packages needed by future strategies (n = 0): <none>
[16:59:34.243] {
[16:59:34.243]     {
[16:59:34.243]         {
[16:59:34.243]             ...future.startTime <- base::Sys.time()
[16:59:34.243]             {
[16:59:34.243]                 {
[16:59:34.243]                   {
[16:59:34.243]                     {
[16:59:34.243]                       base::local({
[16:59:34.243]                         has_future <- base::requireNamespace("future", 
[16:59:34.243]                           quietly = TRUE)
[16:59:34.243]                         if (has_future) {
[16:59:34.243]                           ns <- base::getNamespace("future")
[16:59:34.243]                           version <- ns[[".package"]][["version"]]
[16:59:34.243]                           if (is.null(version)) 
[16:59:34.243]                             version <- utils::packageVersion("future")
[16:59:34.243]                         }
[16:59:34.243]                         else {
[16:59:34.243]                           version <- NULL
[16:59:34.243]                         }
[16:59:34.243]                         if (!has_future || version < "1.8.0") {
[16:59:34.243]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.243]                             "", base::R.version$version.string), 
[16:59:34.243]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:34.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.243]                               "release", "version")], collapse = " "), 
[16:59:34.243]                             hostname = base::Sys.info()[["nodename"]])
[16:59:34.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.243]                             info)
[16:59:34.243]                           info <- base::paste(info, collapse = "; ")
[16:59:34.243]                           if (!has_future) {
[16:59:34.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.243]                               info)
[16:59:34.243]                           }
[16:59:34.243]                           else {
[16:59:34.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.243]                               info, version)
[16:59:34.243]                           }
[16:59:34.243]                           base::stop(msg)
[16:59:34.243]                         }
[16:59:34.243]                       })
[16:59:34.243]                     }
[16:59:34.243]                     base::local({
[16:59:34.243]                       for (pkg in "stats") {
[16:59:34.243]                         base::loadNamespace(pkg)
[16:59:34.243]                         base::library(pkg, character.only = TRUE)
[16:59:34.243]                       }
[16:59:34.243]                     })
[16:59:34.243]                   }
[16:59:34.243]                   ...future.strategy.old <- future::plan("list")
[16:59:34.243]                   options(future.plan = NULL)
[16:59:34.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.243]                 }
[16:59:34.243]                 ...future.workdir <- getwd()
[16:59:34.243]             }
[16:59:34.243]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.243]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.243]         }
[16:59:34.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.243]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.243]             base::names(...future.oldOptions))
[16:59:34.243]     }
[16:59:34.243]     if (FALSE) {
[16:59:34.243]     }
[16:59:34.243]     else {
[16:59:34.243]         if (TRUE) {
[16:59:34.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.243]                 open = "w")
[16:59:34.243]         }
[16:59:34.243]         else {
[16:59:34.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.243]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.243]         }
[16:59:34.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.243]             base::sink(type = "output", split = FALSE)
[16:59:34.243]             base::close(...future.stdout)
[16:59:34.243]         }, add = TRUE)
[16:59:34.243]     }
[16:59:34.243]     ...future.frame <- base::sys.nframe()
[16:59:34.243]     ...future.conditions <- base::list()
[16:59:34.243]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.243]     if (FALSE) {
[16:59:34.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.243]     }
[16:59:34.243]     ...future.result <- base::tryCatch({
[16:59:34.243]         base::withCallingHandlers({
[16:59:34.243]             ...future.value <- base::withVisible(base::local({
[16:59:34.243]                 do.call(function(...) {
[16:59:34.243]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.243]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.243]                     ...future.globals.maxSize)) {
[16:59:34.243]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.243]                     on.exit(options(oopts), add = TRUE)
[16:59:34.243]                   }
[16:59:34.243]                   {
[16:59:34.243]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.243]                       FUN = function(jj) {
[16:59:34.243]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.243]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.243]                       })
[16:59:34.243]                   }
[16:59:34.243]                 }, args = future.call.arguments)
[16:59:34.243]             }))
[16:59:34.243]             future::FutureResult(value = ...future.value$value, 
[16:59:34.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.243]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.243]                     ...future.globalenv.names))
[16:59:34.243]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.243]         }, condition = base::local({
[16:59:34.243]             c <- base::c
[16:59:34.243]             inherits <- base::inherits
[16:59:34.243]             invokeRestart <- base::invokeRestart
[16:59:34.243]             length <- base::length
[16:59:34.243]             list <- base::list
[16:59:34.243]             seq.int <- base::seq.int
[16:59:34.243]             signalCondition <- base::signalCondition
[16:59:34.243]             sys.calls <- base::sys.calls
[16:59:34.243]             `[[` <- base::`[[`
[16:59:34.243]             `+` <- base::`+`
[16:59:34.243]             `<<-` <- base::`<<-`
[16:59:34.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.243]                   3L)]
[16:59:34.243]             }
[16:59:34.243]             function(cond) {
[16:59:34.243]                 is_error <- inherits(cond, "error")
[16:59:34.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.243]                   NULL)
[16:59:34.243]                 if (is_error) {
[16:59:34.243]                   sessionInformation <- function() {
[16:59:34.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.243]                       search = base::search(), system = base::Sys.info())
[16:59:34.243]                   }
[16:59:34.243]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.243]                     cond$call), session = sessionInformation(), 
[16:59:34.243]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.243]                   signalCondition(cond)
[16:59:34.243]                 }
[16:59:34.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.243]                 "immediateCondition"))) {
[16:59:34.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.243]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.243]                   if (TRUE && !signal) {
[16:59:34.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.243]                     {
[16:59:34.243]                       inherits <- base::inherits
[16:59:34.243]                       invokeRestart <- base::invokeRestart
[16:59:34.243]                       is.null <- base::is.null
[16:59:34.243]                       muffled <- FALSE
[16:59:34.243]                       if (inherits(cond, "message")) {
[16:59:34.243]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.243]                         if (muffled) 
[16:59:34.243]                           invokeRestart("muffleMessage")
[16:59:34.243]                       }
[16:59:34.243]                       else if (inherits(cond, "warning")) {
[16:59:34.243]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.243]                         if (muffled) 
[16:59:34.243]                           invokeRestart("muffleWarning")
[16:59:34.243]                       }
[16:59:34.243]                       else if (inherits(cond, "condition")) {
[16:59:34.243]                         if (!is.null(pattern)) {
[16:59:34.243]                           computeRestarts <- base::computeRestarts
[16:59:34.243]                           grepl <- base::grepl
[16:59:34.243]                           restarts <- computeRestarts(cond)
[16:59:34.243]                           for (restart in restarts) {
[16:59:34.243]                             name <- restart$name
[16:59:34.243]                             if (is.null(name)) 
[16:59:34.243]                               next
[16:59:34.243]                             if (!grepl(pattern, name)) 
[16:59:34.243]                               next
[16:59:34.243]                             invokeRestart(restart)
[16:59:34.243]                             muffled <- TRUE
[16:59:34.243]                             break
[16:59:34.243]                           }
[16:59:34.243]                         }
[16:59:34.243]                       }
[16:59:34.243]                       invisible(muffled)
[16:59:34.243]                     }
[16:59:34.243]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.243]                   }
[16:59:34.243]                 }
[16:59:34.243]                 else {
[16:59:34.243]                   if (TRUE) {
[16:59:34.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.243]                     {
[16:59:34.243]                       inherits <- base::inherits
[16:59:34.243]                       invokeRestart <- base::invokeRestart
[16:59:34.243]                       is.null <- base::is.null
[16:59:34.243]                       muffled <- FALSE
[16:59:34.243]                       if (inherits(cond, "message")) {
[16:59:34.243]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.243]                         if (muffled) 
[16:59:34.243]                           invokeRestart("muffleMessage")
[16:59:34.243]                       }
[16:59:34.243]                       else if (inherits(cond, "warning")) {
[16:59:34.243]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.243]                         if (muffled) 
[16:59:34.243]                           invokeRestart("muffleWarning")
[16:59:34.243]                       }
[16:59:34.243]                       else if (inherits(cond, "condition")) {
[16:59:34.243]                         if (!is.null(pattern)) {
[16:59:34.243]                           computeRestarts <- base::computeRestarts
[16:59:34.243]                           grepl <- base::grepl
[16:59:34.243]                           restarts <- computeRestarts(cond)
[16:59:34.243]                           for (restart in restarts) {
[16:59:34.243]                             name <- restart$name
[16:59:34.243]                             if (is.null(name)) 
[16:59:34.243]                               next
[16:59:34.243]                             if (!grepl(pattern, name)) 
[16:59:34.243]                               next
[16:59:34.243]                             invokeRestart(restart)
[16:59:34.243]                             muffled <- TRUE
[16:59:34.243]                             break
[16:59:34.243]                           }
[16:59:34.243]                         }
[16:59:34.243]                       }
[16:59:34.243]                       invisible(muffled)
[16:59:34.243]                     }
[16:59:34.243]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.243]                   }
[16:59:34.243]                 }
[16:59:34.243]             }
[16:59:34.243]         }))
[16:59:34.243]     }, error = function(ex) {
[16:59:34.243]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.243]                 ...future.rng), started = ...future.startTime, 
[16:59:34.243]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.243]             version = "1.8"), class = "FutureResult")
[16:59:34.243]     }, finally = {
[16:59:34.243]         if (!identical(...future.workdir, getwd())) 
[16:59:34.243]             setwd(...future.workdir)
[16:59:34.243]         {
[16:59:34.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.243]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.243]             }
[16:59:34.243]             base::options(...future.oldOptions)
[16:59:34.243]             if (.Platform$OS.type == "windows") {
[16:59:34.243]                 old_names <- names(...future.oldEnvVars)
[16:59:34.243]                 envs <- base::Sys.getenv()
[16:59:34.243]                 names <- names(envs)
[16:59:34.243]                 common <- intersect(names, old_names)
[16:59:34.243]                 added <- setdiff(names, old_names)
[16:59:34.243]                 removed <- setdiff(old_names, names)
[16:59:34.243]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.243]                   envs[common]]
[16:59:34.243]                 NAMES <- toupper(changed)
[16:59:34.243]                 args <- list()
[16:59:34.243]                 for (kk in seq_along(NAMES)) {
[16:59:34.243]                   name <- changed[[kk]]
[16:59:34.243]                   NAME <- NAMES[[kk]]
[16:59:34.243]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.243]                     next
[16:59:34.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.243]                 }
[16:59:34.243]                 NAMES <- toupper(added)
[16:59:34.243]                 for (kk in seq_along(NAMES)) {
[16:59:34.243]                   name <- added[[kk]]
[16:59:34.243]                   NAME <- NAMES[[kk]]
[16:59:34.243]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.243]                     next
[16:59:34.243]                   args[[name]] <- ""
[16:59:34.243]                 }
[16:59:34.243]                 NAMES <- toupper(removed)
[16:59:34.243]                 for (kk in seq_along(NAMES)) {
[16:59:34.243]                   name <- removed[[kk]]
[16:59:34.243]                   NAME <- NAMES[[kk]]
[16:59:34.243]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.243]                     next
[16:59:34.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.243]                 }
[16:59:34.243]                 if (length(args) > 0) 
[16:59:34.243]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.243]             }
[16:59:34.243]             else {
[16:59:34.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.243]             }
[16:59:34.243]             {
[16:59:34.243]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.243]                   0L) {
[16:59:34.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.243]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.243]                   base::options(opts)
[16:59:34.243]                 }
[16:59:34.243]                 {
[16:59:34.243]                   {
[16:59:34.243]                     NULL
[16:59:34.243]                     RNGkind("Mersenne-Twister")
[16:59:34.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.243]                       inherits = FALSE)
[16:59:34.243]                   }
[16:59:34.243]                   options(future.plan = NULL)
[16:59:34.243]                   if (is.na(NA_character_)) 
[16:59:34.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.243]                     .init = FALSE)
[16:59:34.243]                 }
[16:59:34.243]             }
[16:59:34.243]         }
[16:59:34.243]     })
[16:59:34.243]     if (TRUE) {
[16:59:34.243]         base::sink(type = "output", split = FALSE)
[16:59:34.243]         if (TRUE) {
[16:59:34.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.243]         }
[16:59:34.243]         else {
[16:59:34.243]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.243]         }
[16:59:34.243]         base::close(...future.stdout)
[16:59:34.243]         ...future.stdout <- NULL
[16:59:34.243]     }
[16:59:34.243]     ...future.result$conditions <- ...future.conditions
[16:59:34.243]     ...future.result$finished <- base::Sys.time()
[16:59:34.243]     ...future.result
[16:59:34.243] }
[16:59:34.245] assign_globals() ...
[16:59:34.245] List of 5
[16:59:34.245]  $ ...future.FUN            :function (x, ...)  
[16:59:34.245]  $ future.call.arguments    :List of 1
[16:59:34.245]   ..$ singular.ok: logi FALSE
[16:59:34.245]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.245]  $ ...future.elements_ii    :List of 3
[16:59:34.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.245]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.245]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.245]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.245]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.245]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.245]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.245]  $ ...future.seeds_ii       : NULL
[16:59:34.245]  $ ...future.globals.maxSize: NULL
[16:59:34.245]  - attr(*, "where")=List of 5
[16:59:34.245]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.245]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.245]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.245]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.245]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.245]  - attr(*, "resolved")= logi FALSE
[16:59:34.245]  - attr(*, "total_size")= num 5384
[16:59:34.245]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.245]  - attr(*, "already-done")= logi TRUE
[16:59:34.286] - reassign environment for ‘...future.FUN’
[16:59:34.286] - copied ‘...future.FUN’ to environment
[16:59:34.286] - copied ‘future.call.arguments’ to environment
[16:59:34.286] - copied ‘...future.elements_ii’ to environment
[16:59:34.286] - copied ‘...future.seeds_ii’ to environment
[16:59:34.286] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.287] assign_globals() ... done
[16:59:34.287] plan(): Setting new future strategy stack:
[16:59:34.287] List of future strategies:
[16:59:34.287] 1. sequential:
[16:59:34.287]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.287]    - tweaked: FALSE
[16:59:34.287]    - call: NULL
[16:59:34.288] plan(): nbrOfWorkers() = 1
[16:59:34.290] plan(): Setting new future strategy stack:
[16:59:34.291] List of future strategies:
[16:59:34.291] 1. multicore:
[16:59:34.291]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.291]    - tweaked: FALSE
[16:59:34.291]    - call: plan(strategy)
[16:59:34.294] plan(): nbrOfWorkers() = 1
[16:59:34.294] SequentialFuture started (and completed)
[16:59:34.295] - Launch lazy future ... done
[16:59:34.295] run() for ‘SequentialFuture’ ... done
[16:59:34.295] Created future:
[16:59:34.295] SequentialFuture:
[16:59:34.295] Label: ‘future_by-1’
[16:59:34.295] Expression:
[16:59:34.295] {
[16:59:34.295]     do.call(function(...) {
[16:59:34.295]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.295]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.295]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.295]             on.exit(options(oopts), add = TRUE)
[16:59:34.295]         }
[16:59:34.295]         {
[16:59:34.295]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.295]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.295]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.295]             })
[16:59:34.295]         }
[16:59:34.295]     }, args = future.call.arguments)
[16:59:34.295] }
[16:59:34.295] Lazy evaluation: FALSE
[16:59:34.295] Asynchronous evaluation: FALSE
[16:59:34.295] Local evaluation: TRUE
[16:59:34.295] Environment: R_GlobalEnv
[16:59:34.295] Capture standard output: TRUE
[16:59:34.295] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.295] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.295] Packages: 1 packages (‘stats’)
[16:59:34.295] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.295] Resolved: TRUE
[16:59:34.295] Value: 26.06 KiB of class ‘list’
[16:59:34.295] Early signaling: FALSE
[16:59:34.295] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.295] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.296] Chunk #1 of 1 ... DONE
[16:59:34.297] Launching 1 futures (chunks) ... DONE
[16:59:34.297] Resolving 1 futures (chunks) ...
[16:59:34.297] resolve() on list ...
[16:59:34.297]  recursive: 0
[16:59:34.297]  length: 1
[16:59:34.297] 
[16:59:34.297] resolved() for ‘SequentialFuture’ ...
[16:59:34.297] - state: ‘finished’
[16:59:34.297] - run: TRUE
[16:59:34.297] - result: ‘FutureResult’
[16:59:34.297] resolved() for ‘SequentialFuture’ ... done
[16:59:34.298] Future #1
[16:59:34.298] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.298] - nx: 1
[16:59:34.298] - relay: TRUE
[16:59:34.298] - stdout: TRUE
[16:59:34.298] - signal: TRUE
[16:59:34.298] - resignal: FALSE
[16:59:34.298] - force: TRUE
[16:59:34.298] - relayed: [n=1] FALSE
[16:59:34.298] - queued futures: [n=1] FALSE
[16:59:34.299]  - until=1
[16:59:34.299]  - relaying element #1
[16:59:34.299] - relayed: [n=1] TRUE
[16:59:34.299] - queued futures: [n=1] TRUE
[16:59:34.299] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.299]  length: 0 (resolved future 1)
[16:59:34.299] Relaying remaining futures
[16:59:34.299] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.299] - nx: 1
[16:59:34.299] - relay: TRUE
[16:59:34.300] - stdout: TRUE
[16:59:34.300] - signal: TRUE
[16:59:34.300] - resignal: FALSE
[16:59:34.300] - force: TRUE
[16:59:34.300] - relayed: [n=1] TRUE
[16:59:34.300] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.300] - relayed: [n=1] TRUE
[16:59:34.300] - queued futures: [n=1] TRUE
[16:59:34.300] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.300] resolve() on list ... DONE
[16:59:34.301]  - Number of value chunks collected: 1
[16:59:34.301] Resolving 1 futures (chunks) ... DONE
[16:59:34.301] Reducing values from 1 chunks ...
[16:59:34.301]  - Number of values collected after concatenation: 3
[16:59:34.301]  - Number of values expected: 3
[16:59:34.301] Reducing values from 1 chunks ... DONE
[16:59:34.301] future_lapply() ... DONE
[16:59:34.301] future_by_internal() ... DONE
[16:59:34.307] future_by_internal() ...
[16:59:34.308] future_lapply() ...
[16:59:34.312] Number of chunks: 1
[16:59:34.312] getGlobalsAndPackagesXApply() ...
[16:59:34.312]  - future.globals: TRUE
[16:59:34.312] getGlobalsAndPackages() ...
[16:59:34.312] Searching for globals...
[16:59:34.314] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:34.314] Searching for globals ... DONE
[16:59:34.314] Resolving globals: FALSE
[16:59:34.315] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:59:34.315] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:59:34.315] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:34.315] - packages: [1] ‘stats’
[16:59:34.316] getGlobalsAndPackages() ... DONE
[16:59:34.316]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:34.316]  - needed namespaces: [n=1] ‘stats’
[16:59:34.316] Finding globals ... DONE
[16:59:34.316]  - use_args: TRUE
[16:59:34.316]  - Getting '...' globals ...
[16:59:34.316] resolve() on list ...
[16:59:34.316]  recursive: 0
[16:59:34.317]  length: 1
[16:59:34.317]  elements: ‘...’
[16:59:34.317]  length: 0 (resolved future 1)
[16:59:34.317] resolve() on list ... DONE
[16:59:34.317]    - '...' content: [n=0] 
[16:59:34.317] List of 1
[16:59:34.317]  $ ...: list()
[16:59:34.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.317]  - attr(*, "where")=List of 1
[16:59:34.317]   ..$ ...:<environment: 0x562051393ae8> 
[16:59:34.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.317]  - attr(*, "resolved")= logi TRUE
[16:59:34.317]  - attr(*, "total_size")= num NA
[16:59:34.320]  - Getting '...' globals ... DONE
[16:59:34.320] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:59:34.320] List of 4
[16:59:34.320]  $ ...future.FUN:function (x)  
[16:59:34.320]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:34.320]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.320]  $ ...          : list()
[16:59:34.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.320]  - attr(*, "where")=List of 4
[16:59:34.320]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.320]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:59:34.320]   ..$ wool         :<environment: R_EmptyEnv> 
[16:59:34.320]   ..$ ...          :<environment: 0x562051393ae8> 
[16:59:34.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.320]  - attr(*, "resolved")= logi FALSE
[16:59:34.320]  - attr(*, "total_size")= num 2320
[16:59:34.324] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:34.324] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.324] Number of futures (= number of chunks): 1
[16:59:34.324] Launching 1 futures (chunks) ...
[16:59:34.324] Chunk #1 of 1 ...
[16:59:34.324]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.324] getGlobalsAndPackages() ...
[16:59:34.325] Searching for globals...
[16:59:34.325] 
[16:59:34.325] Searching for globals ... DONE
[16:59:34.325] - globals: [0] <none>
[16:59:34.325] getGlobalsAndPackages() ... DONE
[16:59:34.325]    + additional globals found: [n=0] 
[16:59:34.325]    + additional namespaces needed: [n=0] 
[16:59:34.326]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.326]  - seeds: <none>
[16:59:34.326]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.326] getGlobalsAndPackages() ...
[16:59:34.326] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.326] Resolving globals: FALSE
[16:59:34.326] Tweak future expression to call with '...' arguments ...
[16:59:34.326] {
[16:59:34.326]     do.call(function(...) {
[16:59:34.326]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.326]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.326]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.326]             on.exit(options(oopts), add = TRUE)
[16:59:34.326]         }
[16:59:34.326]         {
[16:59:34.326]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.326]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.326]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.326]             })
[16:59:34.326]         }
[16:59:34.326]     }, args = future.call.arguments)
[16:59:34.326] }
[16:59:34.327] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.327] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.327] 
[16:59:34.327] getGlobalsAndPackages() ... DONE
[16:59:34.329] run() for ‘Future’ ...
[16:59:34.329] - state: ‘created’
[16:59:34.329] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.333] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.333] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.334]   - Field: ‘label’
[16:59:34.334]   - Field: ‘local’
[16:59:34.334]   - Field: ‘owner’
[16:59:34.334]   - Field: ‘envir’
[16:59:34.334]   - Field: ‘packages’
[16:59:34.334]   - Field: ‘gc’
[16:59:34.334]   - Field: ‘conditions’
[16:59:34.334]   - Field: ‘expr’
[16:59:34.334]   - Field: ‘uuid’
[16:59:34.335]   - Field: ‘seed’
[16:59:34.335]   - Field: ‘version’
[16:59:34.335]   - Field: ‘result’
[16:59:34.335]   - Field: ‘asynchronous’
[16:59:34.335]   - Field: ‘calls’
[16:59:34.335]   - Field: ‘globals’
[16:59:34.335]   - Field: ‘stdout’
[16:59:34.335]   - Field: ‘earlySignal’
[16:59:34.335]   - Field: ‘lazy’
[16:59:34.335]   - Field: ‘state’
[16:59:34.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.336] - Launch lazy future ...
[16:59:34.336] Packages needed by the future expression (n = 1): ‘stats’
[16:59:34.336] Packages needed by future strategies (n = 0): <none>
[16:59:34.336] {
[16:59:34.336]     {
[16:59:34.336]         {
[16:59:34.336]             ...future.startTime <- base::Sys.time()
[16:59:34.336]             {
[16:59:34.336]                 {
[16:59:34.336]                   {
[16:59:34.336]                     {
[16:59:34.336]                       base::local({
[16:59:34.336]                         has_future <- base::requireNamespace("future", 
[16:59:34.336]                           quietly = TRUE)
[16:59:34.336]                         if (has_future) {
[16:59:34.336]                           ns <- base::getNamespace("future")
[16:59:34.336]                           version <- ns[[".package"]][["version"]]
[16:59:34.336]                           if (is.null(version)) 
[16:59:34.336]                             version <- utils::packageVersion("future")
[16:59:34.336]                         }
[16:59:34.336]                         else {
[16:59:34.336]                           version <- NULL
[16:59:34.336]                         }
[16:59:34.336]                         if (!has_future || version < "1.8.0") {
[16:59:34.336]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.336]                             "", base::R.version$version.string), 
[16:59:34.336]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:34.336]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.336]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.336]                               "release", "version")], collapse = " "), 
[16:59:34.336]                             hostname = base::Sys.info()[["nodename"]])
[16:59:34.336]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.336]                             info)
[16:59:34.336]                           info <- base::paste(info, collapse = "; ")
[16:59:34.336]                           if (!has_future) {
[16:59:34.336]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.336]                               info)
[16:59:34.336]                           }
[16:59:34.336]                           else {
[16:59:34.336]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.336]                               info, version)
[16:59:34.336]                           }
[16:59:34.336]                           base::stop(msg)
[16:59:34.336]                         }
[16:59:34.336]                       })
[16:59:34.336]                     }
[16:59:34.336]                     base::local({
[16:59:34.336]                       for (pkg in "stats") {
[16:59:34.336]                         base::loadNamespace(pkg)
[16:59:34.336]                         base::library(pkg, character.only = TRUE)
[16:59:34.336]                       }
[16:59:34.336]                     })
[16:59:34.336]                   }
[16:59:34.336]                   ...future.strategy.old <- future::plan("list")
[16:59:34.336]                   options(future.plan = NULL)
[16:59:34.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.336]                 }
[16:59:34.336]                 ...future.workdir <- getwd()
[16:59:34.336]             }
[16:59:34.336]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.336]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.336]         }
[16:59:34.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.336]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.336]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.336]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.336]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.336]             base::names(...future.oldOptions))
[16:59:34.336]     }
[16:59:34.336]     if (FALSE) {
[16:59:34.336]     }
[16:59:34.336]     else {
[16:59:34.336]         if (TRUE) {
[16:59:34.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.336]                 open = "w")
[16:59:34.336]         }
[16:59:34.336]         else {
[16:59:34.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.336]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.336]         }
[16:59:34.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.336]             base::sink(type = "output", split = FALSE)
[16:59:34.336]             base::close(...future.stdout)
[16:59:34.336]         }, add = TRUE)
[16:59:34.336]     }
[16:59:34.336]     ...future.frame <- base::sys.nframe()
[16:59:34.336]     ...future.conditions <- base::list()
[16:59:34.336]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.336]     if (FALSE) {
[16:59:34.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.336]     }
[16:59:34.336]     ...future.result <- base::tryCatch({
[16:59:34.336]         base::withCallingHandlers({
[16:59:34.336]             ...future.value <- base::withVisible(base::local({
[16:59:34.336]                 do.call(function(...) {
[16:59:34.336]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.336]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.336]                     ...future.globals.maxSize)) {
[16:59:34.336]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.336]                     on.exit(options(oopts), add = TRUE)
[16:59:34.336]                   }
[16:59:34.336]                   {
[16:59:34.336]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.336]                       FUN = function(jj) {
[16:59:34.336]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.336]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.336]                       })
[16:59:34.336]                   }
[16:59:34.336]                 }, args = future.call.arguments)
[16:59:34.336]             }))
[16:59:34.336]             future::FutureResult(value = ...future.value$value, 
[16:59:34.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.336]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.336]                     ...future.globalenv.names))
[16:59:34.336]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.336]         }, condition = base::local({
[16:59:34.336]             c <- base::c
[16:59:34.336]             inherits <- base::inherits
[16:59:34.336]             invokeRestart <- base::invokeRestart
[16:59:34.336]             length <- base::length
[16:59:34.336]             list <- base::list
[16:59:34.336]             seq.int <- base::seq.int
[16:59:34.336]             signalCondition <- base::signalCondition
[16:59:34.336]             sys.calls <- base::sys.calls
[16:59:34.336]             `[[` <- base::`[[`
[16:59:34.336]             `+` <- base::`+`
[16:59:34.336]             `<<-` <- base::`<<-`
[16:59:34.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.336]                   3L)]
[16:59:34.336]             }
[16:59:34.336]             function(cond) {
[16:59:34.336]                 is_error <- inherits(cond, "error")
[16:59:34.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.336]                   NULL)
[16:59:34.336]                 if (is_error) {
[16:59:34.336]                   sessionInformation <- function() {
[16:59:34.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.336]                       search = base::search(), system = base::Sys.info())
[16:59:34.336]                   }
[16:59:34.336]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.336]                     cond$call), session = sessionInformation(), 
[16:59:34.336]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.336]                   signalCondition(cond)
[16:59:34.336]                 }
[16:59:34.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.336]                 "immediateCondition"))) {
[16:59:34.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.336]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.336]                   if (TRUE && !signal) {
[16:59:34.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.336]                     {
[16:59:34.336]                       inherits <- base::inherits
[16:59:34.336]                       invokeRestart <- base::invokeRestart
[16:59:34.336]                       is.null <- base::is.null
[16:59:34.336]                       muffled <- FALSE
[16:59:34.336]                       if (inherits(cond, "message")) {
[16:59:34.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.336]                         if (muffled) 
[16:59:34.336]                           invokeRestart("muffleMessage")
[16:59:34.336]                       }
[16:59:34.336]                       else if (inherits(cond, "warning")) {
[16:59:34.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.336]                         if (muffled) 
[16:59:34.336]                           invokeRestart("muffleWarning")
[16:59:34.336]                       }
[16:59:34.336]                       else if (inherits(cond, "condition")) {
[16:59:34.336]                         if (!is.null(pattern)) {
[16:59:34.336]                           computeRestarts <- base::computeRestarts
[16:59:34.336]                           grepl <- base::grepl
[16:59:34.336]                           restarts <- computeRestarts(cond)
[16:59:34.336]                           for (restart in restarts) {
[16:59:34.336]                             name <- restart$name
[16:59:34.336]                             if (is.null(name)) 
[16:59:34.336]                               next
[16:59:34.336]                             if (!grepl(pattern, name)) 
[16:59:34.336]                               next
[16:59:34.336]                             invokeRestart(restart)
[16:59:34.336]                             muffled <- TRUE
[16:59:34.336]                             break
[16:59:34.336]                           }
[16:59:34.336]                         }
[16:59:34.336]                       }
[16:59:34.336]                       invisible(muffled)
[16:59:34.336]                     }
[16:59:34.336]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.336]                   }
[16:59:34.336]                 }
[16:59:34.336]                 else {
[16:59:34.336]                   if (TRUE) {
[16:59:34.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.336]                     {
[16:59:34.336]                       inherits <- base::inherits
[16:59:34.336]                       invokeRestart <- base::invokeRestart
[16:59:34.336]                       is.null <- base::is.null
[16:59:34.336]                       muffled <- FALSE
[16:59:34.336]                       if (inherits(cond, "message")) {
[16:59:34.336]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.336]                         if (muffled) 
[16:59:34.336]                           invokeRestart("muffleMessage")
[16:59:34.336]                       }
[16:59:34.336]                       else if (inherits(cond, "warning")) {
[16:59:34.336]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.336]                         if (muffled) 
[16:59:34.336]                           invokeRestart("muffleWarning")
[16:59:34.336]                       }
[16:59:34.336]                       else if (inherits(cond, "condition")) {
[16:59:34.336]                         if (!is.null(pattern)) {
[16:59:34.336]                           computeRestarts <- base::computeRestarts
[16:59:34.336]                           grepl <- base::grepl
[16:59:34.336]                           restarts <- computeRestarts(cond)
[16:59:34.336]                           for (restart in restarts) {
[16:59:34.336]                             name <- restart$name
[16:59:34.336]                             if (is.null(name)) 
[16:59:34.336]                               next
[16:59:34.336]                             if (!grepl(pattern, name)) 
[16:59:34.336]                               next
[16:59:34.336]                             invokeRestart(restart)
[16:59:34.336]                             muffled <- TRUE
[16:59:34.336]                             break
[16:59:34.336]                           }
[16:59:34.336]                         }
[16:59:34.336]                       }
[16:59:34.336]                       invisible(muffled)
[16:59:34.336]                     }
[16:59:34.336]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.336]                   }
[16:59:34.336]                 }
[16:59:34.336]             }
[16:59:34.336]         }))
[16:59:34.336]     }, error = function(ex) {
[16:59:34.336]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.336]                 ...future.rng), started = ...future.startTime, 
[16:59:34.336]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.336]             version = "1.8"), class = "FutureResult")
[16:59:34.336]     }, finally = {
[16:59:34.336]         if (!identical(...future.workdir, getwd())) 
[16:59:34.336]             setwd(...future.workdir)
[16:59:34.336]         {
[16:59:34.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.336]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.336]             }
[16:59:34.336]             base::options(...future.oldOptions)
[16:59:34.336]             if (.Platform$OS.type == "windows") {
[16:59:34.336]                 old_names <- names(...future.oldEnvVars)
[16:59:34.336]                 envs <- base::Sys.getenv()
[16:59:34.336]                 names <- names(envs)
[16:59:34.336]                 common <- intersect(names, old_names)
[16:59:34.336]                 added <- setdiff(names, old_names)
[16:59:34.336]                 removed <- setdiff(old_names, names)
[16:59:34.336]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.336]                   envs[common]]
[16:59:34.336]                 NAMES <- toupper(changed)
[16:59:34.336]                 args <- list()
[16:59:34.336]                 for (kk in seq_along(NAMES)) {
[16:59:34.336]                   name <- changed[[kk]]
[16:59:34.336]                   NAME <- NAMES[[kk]]
[16:59:34.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.336]                     next
[16:59:34.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.336]                 }
[16:59:34.336]                 NAMES <- toupper(added)
[16:59:34.336]                 for (kk in seq_along(NAMES)) {
[16:59:34.336]                   name <- added[[kk]]
[16:59:34.336]                   NAME <- NAMES[[kk]]
[16:59:34.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.336]                     next
[16:59:34.336]                   args[[name]] <- ""
[16:59:34.336]                 }
[16:59:34.336]                 NAMES <- toupper(removed)
[16:59:34.336]                 for (kk in seq_along(NAMES)) {
[16:59:34.336]                   name <- removed[[kk]]
[16:59:34.336]                   NAME <- NAMES[[kk]]
[16:59:34.336]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.336]                     next
[16:59:34.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.336]                 }
[16:59:34.336]                 if (length(args) > 0) 
[16:59:34.336]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.336]             }
[16:59:34.336]             else {
[16:59:34.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.336]             }
[16:59:34.336]             {
[16:59:34.336]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.336]                   0L) {
[16:59:34.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.336]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.336]                   base::options(opts)
[16:59:34.336]                 }
[16:59:34.336]                 {
[16:59:34.336]                   {
[16:59:34.336]                     NULL
[16:59:34.336]                     RNGkind("Mersenne-Twister")
[16:59:34.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.336]                       inherits = FALSE)
[16:59:34.336]                   }
[16:59:34.336]                   options(future.plan = NULL)
[16:59:34.336]                   if (is.na(NA_character_)) 
[16:59:34.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.336]                     .init = FALSE)
[16:59:34.336]                 }
[16:59:34.336]             }
[16:59:34.336]         }
[16:59:34.336]     })
[16:59:34.336]     if (TRUE) {
[16:59:34.336]         base::sink(type = "output", split = FALSE)
[16:59:34.336]         if (TRUE) {
[16:59:34.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.336]         }
[16:59:34.336]         else {
[16:59:34.336]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.336]         }
[16:59:34.336]         base::close(...future.stdout)
[16:59:34.336]         ...future.stdout <- NULL
[16:59:34.336]     }
[16:59:34.336]     ...future.result$conditions <- ...future.conditions
[16:59:34.336]     ...future.result$finished <- base::Sys.time()
[16:59:34.336]     ...future.result
[16:59:34.336] }
[16:59:34.338] assign_globals() ...
[16:59:34.338] List of 7
[16:59:34.338]  $ ...future.FUN            :function (x)  
[16:59:34.338]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:34.338]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.338]  $ future.call.arguments    : list()
[16:59:34.338]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.338]  $ ...future.elements_ii    :List of 3
[16:59:34.338]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.338]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.338]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.338]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.338]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.338]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.338]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.338]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.338]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.338]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.338]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.338]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.338]  $ ...future.seeds_ii       : NULL
[16:59:34.338]  $ ...future.globals.maxSize: NULL
[16:59:34.338]  - attr(*, "where")=List of 7
[16:59:34.338]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.338]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:59:34.338]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:59:34.338]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.338]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.338]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.338]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.338]  - attr(*, "resolved")= logi FALSE
[16:59:34.338]  - attr(*, "total_size")= num 2320
[16:59:34.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.338]  - attr(*, "already-done")= logi TRUE
[16:59:34.348] - reassign environment for ‘...future.FUN’
[16:59:34.348] - copied ‘...future.FUN’ to environment
[16:59:34.348] - copied ‘breaks’ to environment
[16:59:34.348] - copied ‘wool’ to environment
[16:59:34.349] - copied ‘future.call.arguments’ to environment
[16:59:34.349] - copied ‘...future.elements_ii’ to environment
[16:59:34.349] - copied ‘...future.seeds_ii’ to environment
[16:59:34.349] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.349] assign_globals() ... done
[16:59:34.349] plan(): Setting new future strategy stack:
[16:59:34.349] List of future strategies:
[16:59:34.349] 1. sequential:
[16:59:34.349]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.349]    - tweaked: FALSE
[16:59:34.349]    - call: NULL
[16:59:34.350] plan(): nbrOfWorkers() = 1
[16:59:34.353] plan(): Setting new future strategy stack:
[16:59:34.353] List of future strategies:
[16:59:34.353] 1. multicore:
[16:59:34.353]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.353]    - tweaked: FALSE
[16:59:34.353]    - call: plan(strategy)
[16:59:34.357] plan(): nbrOfWorkers() = 1
[16:59:34.357] SequentialFuture started (and completed)
[16:59:34.357] - Launch lazy future ... done
[16:59:34.357] run() for ‘SequentialFuture’ ... done
[16:59:34.357] Created future:
[16:59:34.357] SequentialFuture:
[16:59:34.357] Label: ‘future_by-1’
[16:59:34.357] Expression:
[16:59:34.357] {
[16:59:34.357]     do.call(function(...) {
[16:59:34.357]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.357]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.357]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.357]             on.exit(options(oopts), add = TRUE)
[16:59:34.357]         }
[16:59:34.357]         {
[16:59:34.357]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.357]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.357]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.357]             })
[16:59:34.357]         }
[16:59:34.357]     }, args = future.call.arguments)
[16:59:34.357] }
[16:59:34.357] Lazy evaluation: FALSE
[16:59:34.357] Asynchronous evaluation: FALSE
[16:59:34.357] Local evaluation: TRUE
[16:59:34.357] Environment: 0x562051568d10
[16:59:34.357] Capture standard output: TRUE
[16:59:34.357] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.357] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:59:34.357] Packages: 1 packages (‘stats’)
[16:59:34.357] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.357] Resolved: TRUE
[16:59:34.357] Value: 25.57 KiB of class ‘list’
[16:59:34.357] Early signaling: FALSE
[16:59:34.357] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.357] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.361] Chunk #1 of 1 ... DONE
[16:59:34.361] Launching 1 futures (chunks) ... DONE
[16:59:34.361] Resolving 1 futures (chunks) ...
[16:59:34.361] resolve() on list ...
[16:59:34.361]  recursive: 0
[16:59:34.361]  length: 1
[16:59:34.362] 
[16:59:34.362] resolved() for ‘SequentialFuture’ ...
[16:59:34.362] - state: ‘finished’
[16:59:34.362] - run: TRUE
[16:59:34.362] - result: ‘FutureResult’
[16:59:34.362] resolved() for ‘SequentialFuture’ ... done
[16:59:34.362] Future #1
[16:59:34.362] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.363] - nx: 1
[16:59:34.363] - relay: TRUE
[16:59:34.363] - stdout: TRUE
[16:59:34.363] - signal: TRUE
[16:59:34.363] - resignal: FALSE
[16:59:34.363] - force: TRUE
[16:59:34.363] - relayed: [n=1] FALSE
[16:59:34.363] - queued futures: [n=1] FALSE
[16:59:34.363]  - until=1
[16:59:34.363]  - relaying element #1
[16:59:34.364] - relayed: [n=1] TRUE
[16:59:34.364] - queued futures: [n=1] TRUE
[16:59:34.364] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.364]  length: 0 (resolved future 1)
[16:59:34.364] Relaying remaining futures
[16:59:34.364] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.364] - nx: 1
[16:59:34.364] - relay: TRUE
[16:59:34.364] - stdout: TRUE
[16:59:34.364] - signal: TRUE
[16:59:34.364] - resignal: FALSE
[16:59:34.365] - force: TRUE
[16:59:34.365] - relayed: [n=1] TRUE
[16:59:34.365] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.365] - relayed: [n=1] TRUE
[16:59:34.365] - queued futures: [n=1] TRUE
[16:59:34.365] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.365] resolve() on list ... DONE
[16:59:34.365]  - Number of value chunks collected: 1
[16:59:34.365] Resolving 1 futures (chunks) ... DONE
[16:59:34.365] Reducing values from 1 chunks ...
[16:59:34.366]  - Number of values collected after concatenation: 3
[16:59:34.366]  - Number of values expected: 3
[16:59:34.366] Reducing values from 1 chunks ... DONE
[16:59:34.366] future_lapply() ... DONE
[16:59:34.366] future_by_internal() ... DONE
[16:59:34.366] future_by_internal() ...
[16:59:34.367] future_lapply() ...
[16:59:34.370] Number of chunks: 1
[16:59:34.371] getGlobalsAndPackagesXApply() ...
[16:59:34.371]  - future.globals: TRUE
[16:59:34.371] getGlobalsAndPackages() ...
[16:59:34.371] Searching for globals...
[16:59:34.372] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.372] Searching for globals ... DONE
[16:59:34.372] Resolving globals: FALSE
[16:59:34.373] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.373] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.373] - globals: [1] ‘FUN’
[16:59:34.373] 
[16:59:34.373] getGlobalsAndPackages() ... DONE
[16:59:34.373]  - globals found/used: [n=1] ‘FUN’
[16:59:34.373]  - needed namespaces: [n=0] 
[16:59:34.373] Finding globals ... DONE
[16:59:34.374]  - use_args: TRUE
[16:59:34.374]  - Getting '...' globals ...
[16:59:34.374] resolve() on list ...
[16:59:34.374]  recursive: 0
[16:59:34.374]  length: 1
[16:59:34.374]  elements: ‘...’
[16:59:34.374]  length: 0 (resolved future 1)
[16:59:34.374] resolve() on list ... DONE
[16:59:34.375]    - '...' content: [n=0] 
[16:59:34.375] List of 1
[16:59:34.375]  $ ...: list()
[16:59:34.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.375]  - attr(*, "where")=List of 1
[16:59:34.375]   ..$ ...:<environment: 0x562050426270> 
[16:59:34.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.375]  - attr(*, "resolved")= logi TRUE
[16:59:34.375]  - attr(*, "total_size")= num NA
[16:59:34.377]  - Getting '...' globals ... DONE
[16:59:34.377] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.377] List of 2
[16:59:34.377]  $ ...future.FUN:function (object, ...)  
[16:59:34.377]  $ ...          : list()
[16:59:34.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.377]  - attr(*, "where")=List of 2
[16:59:34.377]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.377]   ..$ ...          :<environment: 0x562050426270> 
[16:59:34.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.377]  - attr(*, "resolved")= logi FALSE
[16:59:34.377]  - attr(*, "total_size")= num 1240
[16:59:34.380] Packages to be attached in all futures: [n=0] 
[16:59:34.380] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.380] Number of futures (= number of chunks): 1
[16:59:34.380] Launching 1 futures (chunks) ...
[16:59:34.381] Chunk #1 of 1 ...
[16:59:34.381]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.381] getGlobalsAndPackages() ...
[16:59:34.381] Searching for globals...
[16:59:34.381] 
[16:59:34.381] Searching for globals ... DONE
[16:59:34.382] - globals: [0] <none>
[16:59:34.382] getGlobalsAndPackages() ... DONE
[16:59:34.382]    + additional globals found: [n=0] 
[16:59:34.382]    + additional namespaces needed: [n=0] 
[16:59:34.382]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.382]  - seeds: <none>
[16:59:34.382]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.382] getGlobalsAndPackages() ...
[16:59:34.382] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.382] Resolving globals: FALSE
[16:59:34.382] Tweak future expression to call with '...' arguments ...
[16:59:34.383] {
[16:59:34.383]     do.call(function(...) {
[16:59:34.383]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.383]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.383]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.383]             on.exit(options(oopts), add = TRUE)
[16:59:34.383]         }
[16:59:34.383]         {
[16:59:34.383]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.383]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.383]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.383]             })
[16:59:34.383]         }
[16:59:34.383]     }, args = future.call.arguments)
[16:59:34.383] }
[16:59:34.383] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.383] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.383] 
[16:59:34.383] getGlobalsAndPackages() ... DONE
[16:59:34.384] run() for ‘Future’ ...
[16:59:34.384] - state: ‘created’
[16:59:34.384] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.389] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.389]   - Field: ‘label’
[16:59:34.390]   - Field: ‘local’
[16:59:34.390]   - Field: ‘owner’
[16:59:34.390]   - Field: ‘envir’
[16:59:34.390]   - Field: ‘packages’
[16:59:34.390]   - Field: ‘gc’
[16:59:34.390]   - Field: ‘conditions’
[16:59:34.390]   - Field: ‘expr’
[16:59:34.390]   - Field: ‘uuid’
[16:59:34.390]   - Field: ‘seed’
[16:59:34.391]   - Field: ‘version’
[16:59:34.391]   - Field: ‘result’
[16:59:34.391]   - Field: ‘asynchronous’
[16:59:34.391]   - Field: ‘calls’
[16:59:34.391]   - Field: ‘globals’
[16:59:34.391]   - Field: ‘stdout’
[16:59:34.391]   - Field: ‘earlySignal’
[16:59:34.391]   - Field: ‘lazy’
[16:59:34.392]   - Field: ‘state’
[16:59:34.392] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.392] - Launch lazy future ...
[16:59:34.392] Packages needed by the future expression (n = 0): <none>
[16:59:34.392] Packages needed by future strategies (n = 0): <none>
[16:59:34.393] {
[16:59:34.393]     {
[16:59:34.393]         {
[16:59:34.393]             ...future.startTime <- base::Sys.time()
[16:59:34.393]             {
[16:59:34.393]                 {
[16:59:34.393]                   {
[16:59:34.393]                     base::local({
[16:59:34.393]                       has_future <- base::requireNamespace("future", 
[16:59:34.393]                         quietly = TRUE)
[16:59:34.393]                       if (has_future) {
[16:59:34.393]                         ns <- base::getNamespace("future")
[16:59:34.393]                         version <- ns[[".package"]][["version"]]
[16:59:34.393]                         if (is.null(version)) 
[16:59:34.393]                           version <- utils::packageVersion("future")
[16:59:34.393]                       }
[16:59:34.393]                       else {
[16:59:34.393]                         version <- NULL
[16:59:34.393]                       }
[16:59:34.393]                       if (!has_future || version < "1.8.0") {
[16:59:34.393]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.393]                           "", base::R.version$version.string), 
[16:59:34.393]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.393]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.393]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.393]                             "release", "version")], collapse = " "), 
[16:59:34.393]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.393]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.393]                           info)
[16:59:34.393]                         info <- base::paste(info, collapse = "; ")
[16:59:34.393]                         if (!has_future) {
[16:59:34.393]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.393]                             info)
[16:59:34.393]                         }
[16:59:34.393]                         else {
[16:59:34.393]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.393]                             info, version)
[16:59:34.393]                         }
[16:59:34.393]                         base::stop(msg)
[16:59:34.393]                       }
[16:59:34.393]                     })
[16:59:34.393]                   }
[16:59:34.393]                   ...future.strategy.old <- future::plan("list")
[16:59:34.393]                   options(future.plan = NULL)
[16:59:34.393]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.393]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.393]                 }
[16:59:34.393]                 ...future.workdir <- getwd()
[16:59:34.393]             }
[16:59:34.393]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.393]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.393]         }
[16:59:34.393]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.393]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.393]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.393]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.393]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.393]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.393]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.393]             base::names(...future.oldOptions))
[16:59:34.393]     }
[16:59:34.393]     if (FALSE) {
[16:59:34.393]     }
[16:59:34.393]     else {
[16:59:34.393]         if (TRUE) {
[16:59:34.393]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.393]                 open = "w")
[16:59:34.393]         }
[16:59:34.393]         else {
[16:59:34.393]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.393]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.393]         }
[16:59:34.393]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.393]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.393]             base::sink(type = "output", split = FALSE)
[16:59:34.393]             base::close(...future.stdout)
[16:59:34.393]         }, add = TRUE)
[16:59:34.393]     }
[16:59:34.393]     ...future.frame <- base::sys.nframe()
[16:59:34.393]     ...future.conditions <- base::list()
[16:59:34.393]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.393]     if (FALSE) {
[16:59:34.393]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.393]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.393]     }
[16:59:34.393]     ...future.result <- base::tryCatch({
[16:59:34.393]         base::withCallingHandlers({
[16:59:34.393]             ...future.value <- base::withVisible(base::local({
[16:59:34.393]                 do.call(function(...) {
[16:59:34.393]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.393]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.393]                     ...future.globals.maxSize)) {
[16:59:34.393]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.393]                     on.exit(options(oopts), add = TRUE)
[16:59:34.393]                   }
[16:59:34.393]                   {
[16:59:34.393]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.393]                       FUN = function(jj) {
[16:59:34.393]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.393]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.393]                       })
[16:59:34.393]                   }
[16:59:34.393]                 }, args = future.call.arguments)
[16:59:34.393]             }))
[16:59:34.393]             future::FutureResult(value = ...future.value$value, 
[16:59:34.393]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.393]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.393]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.393]                     ...future.globalenv.names))
[16:59:34.393]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.393]         }, condition = base::local({
[16:59:34.393]             c <- base::c
[16:59:34.393]             inherits <- base::inherits
[16:59:34.393]             invokeRestart <- base::invokeRestart
[16:59:34.393]             length <- base::length
[16:59:34.393]             list <- base::list
[16:59:34.393]             seq.int <- base::seq.int
[16:59:34.393]             signalCondition <- base::signalCondition
[16:59:34.393]             sys.calls <- base::sys.calls
[16:59:34.393]             `[[` <- base::`[[`
[16:59:34.393]             `+` <- base::`+`
[16:59:34.393]             `<<-` <- base::`<<-`
[16:59:34.393]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.393]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.393]                   3L)]
[16:59:34.393]             }
[16:59:34.393]             function(cond) {
[16:59:34.393]                 is_error <- inherits(cond, "error")
[16:59:34.393]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.393]                   NULL)
[16:59:34.393]                 if (is_error) {
[16:59:34.393]                   sessionInformation <- function() {
[16:59:34.393]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.393]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.393]                       search = base::search(), system = base::Sys.info())
[16:59:34.393]                   }
[16:59:34.393]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.393]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.393]                     cond$call), session = sessionInformation(), 
[16:59:34.393]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.393]                   signalCondition(cond)
[16:59:34.393]                 }
[16:59:34.393]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.393]                 "immediateCondition"))) {
[16:59:34.393]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.393]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.393]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.393]                   if (TRUE && !signal) {
[16:59:34.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.393]                     {
[16:59:34.393]                       inherits <- base::inherits
[16:59:34.393]                       invokeRestart <- base::invokeRestart
[16:59:34.393]                       is.null <- base::is.null
[16:59:34.393]                       muffled <- FALSE
[16:59:34.393]                       if (inherits(cond, "message")) {
[16:59:34.393]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.393]                         if (muffled) 
[16:59:34.393]                           invokeRestart("muffleMessage")
[16:59:34.393]                       }
[16:59:34.393]                       else if (inherits(cond, "warning")) {
[16:59:34.393]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.393]                         if (muffled) 
[16:59:34.393]                           invokeRestart("muffleWarning")
[16:59:34.393]                       }
[16:59:34.393]                       else if (inherits(cond, "condition")) {
[16:59:34.393]                         if (!is.null(pattern)) {
[16:59:34.393]                           computeRestarts <- base::computeRestarts
[16:59:34.393]                           grepl <- base::grepl
[16:59:34.393]                           restarts <- computeRestarts(cond)
[16:59:34.393]                           for (restart in restarts) {
[16:59:34.393]                             name <- restart$name
[16:59:34.393]                             if (is.null(name)) 
[16:59:34.393]                               next
[16:59:34.393]                             if (!grepl(pattern, name)) 
[16:59:34.393]                               next
[16:59:34.393]                             invokeRestart(restart)
[16:59:34.393]                             muffled <- TRUE
[16:59:34.393]                             break
[16:59:34.393]                           }
[16:59:34.393]                         }
[16:59:34.393]                       }
[16:59:34.393]                       invisible(muffled)
[16:59:34.393]                     }
[16:59:34.393]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.393]                   }
[16:59:34.393]                 }
[16:59:34.393]                 else {
[16:59:34.393]                   if (TRUE) {
[16:59:34.393]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.393]                     {
[16:59:34.393]                       inherits <- base::inherits
[16:59:34.393]                       invokeRestart <- base::invokeRestart
[16:59:34.393]                       is.null <- base::is.null
[16:59:34.393]                       muffled <- FALSE
[16:59:34.393]                       if (inherits(cond, "message")) {
[16:59:34.393]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.393]                         if (muffled) 
[16:59:34.393]                           invokeRestart("muffleMessage")
[16:59:34.393]                       }
[16:59:34.393]                       else if (inherits(cond, "warning")) {
[16:59:34.393]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.393]                         if (muffled) 
[16:59:34.393]                           invokeRestart("muffleWarning")
[16:59:34.393]                       }
[16:59:34.393]                       else if (inherits(cond, "condition")) {
[16:59:34.393]                         if (!is.null(pattern)) {
[16:59:34.393]                           computeRestarts <- base::computeRestarts
[16:59:34.393]                           grepl <- base::grepl
[16:59:34.393]                           restarts <- computeRestarts(cond)
[16:59:34.393]                           for (restart in restarts) {
[16:59:34.393]                             name <- restart$name
[16:59:34.393]                             if (is.null(name)) 
[16:59:34.393]                               next
[16:59:34.393]                             if (!grepl(pattern, name)) 
[16:59:34.393]                               next
[16:59:34.393]                             invokeRestart(restart)
[16:59:34.393]                             muffled <- TRUE
[16:59:34.393]                             break
[16:59:34.393]                           }
[16:59:34.393]                         }
[16:59:34.393]                       }
[16:59:34.393]                       invisible(muffled)
[16:59:34.393]                     }
[16:59:34.393]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.393]                   }
[16:59:34.393]                 }
[16:59:34.393]             }
[16:59:34.393]         }))
[16:59:34.393]     }, error = function(ex) {
[16:59:34.393]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.393]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.393]                 ...future.rng), started = ...future.startTime, 
[16:59:34.393]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.393]             version = "1.8"), class = "FutureResult")
[16:59:34.393]     }, finally = {
[16:59:34.393]         if (!identical(...future.workdir, getwd())) 
[16:59:34.393]             setwd(...future.workdir)
[16:59:34.393]         {
[16:59:34.393]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.393]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.393]             }
[16:59:34.393]             base::options(...future.oldOptions)
[16:59:34.393]             if (.Platform$OS.type == "windows") {
[16:59:34.393]                 old_names <- names(...future.oldEnvVars)
[16:59:34.393]                 envs <- base::Sys.getenv()
[16:59:34.393]                 names <- names(envs)
[16:59:34.393]                 common <- intersect(names, old_names)
[16:59:34.393]                 added <- setdiff(names, old_names)
[16:59:34.393]                 removed <- setdiff(old_names, names)
[16:59:34.393]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.393]                   envs[common]]
[16:59:34.393]                 NAMES <- toupper(changed)
[16:59:34.393]                 args <- list()
[16:59:34.393]                 for (kk in seq_along(NAMES)) {
[16:59:34.393]                   name <- changed[[kk]]
[16:59:34.393]                   NAME <- NAMES[[kk]]
[16:59:34.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.393]                     next
[16:59:34.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.393]                 }
[16:59:34.393]                 NAMES <- toupper(added)
[16:59:34.393]                 for (kk in seq_along(NAMES)) {
[16:59:34.393]                   name <- added[[kk]]
[16:59:34.393]                   NAME <- NAMES[[kk]]
[16:59:34.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.393]                     next
[16:59:34.393]                   args[[name]] <- ""
[16:59:34.393]                 }
[16:59:34.393]                 NAMES <- toupper(removed)
[16:59:34.393]                 for (kk in seq_along(NAMES)) {
[16:59:34.393]                   name <- removed[[kk]]
[16:59:34.393]                   NAME <- NAMES[[kk]]
[16:59:34.393]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.393]                     next
[16:59:34.393]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.393]                 }
[16:59:34.393]                 if (length(args) > 0) 
[16:59:34.393]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.393]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.393]             }
[16:59:34.393]             else {
[16:59:34.393]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.393]             }
[16:59:34.393]             {
[16:59:34.393]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.393]                   0L) {
[16:59:34.393]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.393]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.393]                   base::options(opts)
[16:59:34.393]                 }
[16:59:34.393]                 {
[16:59:34.393]                   {
[16:59:34.393]                     NULL
[16:59:34.393]                     RNGkind("Mersenne-Twister")
[16:59:34.393]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.393]                       inherits = FALSE)
[16:59:34.393]                   }
[16:59:34.393]                   options(future.plan = NULL)
[16:59:34.393]                   if (is.na(NA_character_)) 
[16:59:34.393]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.393]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.393]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.393]                     .init = FALSE)
[16:59:34.393]                 }
[16:59:34.393]             }
[16:59:34.393]         }
[16:59:34.393]     })
[16:59:34.393]     if (TRUE) {
[16:59:34.393]         base::sink(type = "output", split = FALSE)
[16:59:34.393]         if (TRUE) {
[16:59:34.393]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.393]         }
[16:59:34.393]         else {
[16:59:34.393]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.393]         }
[16:59:34.393]         base::close(...future.stdout)
[16:59:34.393]         ...future.stdout <- NULL
[16:59:34.393]     }
[16:59:34.393]     ...future.result$conditions <- ...future.conditions
[16:59:34.393]     ...future.result$finished <- base::Sys.time()
[16:59:34.393]     ...future.result
[16:59:34.393] }
[16:59:34.394] assign_globals() ...
[16:59:34.394] List of 5
[16:59:34.394]  $ ...future.FUN            :function (object, ...)  
[16:59:34.394]  $ future.call.arguments    : list()
[16:59:34.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.394]  $ ...future.elements_ii    :List of 3
[16:59:34.394]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.394]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.394]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.394]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.394]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.394]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.394]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.394]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.394]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.394]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.394]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.394]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.394]  $ ...future.seeds_ii       : NULL
[16:59:34.394]  $ ...future.globals.maxSize: NULL
[16:59:34.394]  - attr(*, "where")=List of 5
[16:59:34.394]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.394]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.394]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.394]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.394]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.394]  - attr(*, "resolved")= logi FALSE
[16:59:34.394]  - attr(*, "total_size")= num 1240
[16:59:34.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.394]  - attr(*, "already-done")= logi TRUE
[16:59:34.403] - copied ‘...future.FUN’ to environment
[16:59:34.403] - copied ‘future.call.arguments’ to environment
[16:59:34.403] - copied ‘...future.elements_ii’ to environment
[16:59:34.403] - copied ‘...future.seeds_ii’ to environment
[16:59:34.403] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.403] assign_globals() ... done
[16:59:34.404] plan(): Setting new future strategy stack:
[16:59:34.404] List of future strategies:
[16:59:34.404] 1. sequential:
[16:59:34.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.404]    - tweaked: FALSE
[16:59:34.404]    - call: NULL
[16:59:34.404] plan(): nbrOfWorkers() = 1
[16:59:34.406] plan(): Setting new future strategy stack:
[16:59:34.406] List of future strategies:
[16:59:34.406] 1. multicore:
[16:59:34.406]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.406]    - tweaked: FALSE
[16:59:34.406]    - call: plan(strategy)
[16:59:34.410] plan(): nbrOfWorkers() = 1
[16:59:34.410] SequentialFuture started (and completed)
[16:59:34.410] - Launch lazy future ... done
[16:59:34.411] run() for ‘SequentialFuture’ ... done
[16:59:34.411] Created future:
[16:59:34.411] SequentialFuture:
[16:59:34.411] Label: ‘future_by-1’
[16:59:34.411] Expression:
[16:59:34.411] {
[16:59:34.411]     do.call(function(...) {
[16:59:34.411]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.411]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.411]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.411]             on.exit(options(oopts), add = TRUE)
[16:59:34.411]         }
[16:59:34.411]         {
[16:59:34.411]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.411]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.411]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.411]             })
[16:59:34.411]         }
[16:59:34.411]     }, args = future.call.arguments)
[16:59:34.411] }
[16:59:34.411] Lazy evaluation: FALSE
[16:59:34.411] Asynchronous evaluation: FALSE
[16:59:34.411] Local evaluation: TRUE
[16:59:34.411] Environment: 0x56205075ded0
[16:59:34.411] Capture standard output: TRUE
[16:59:34.411] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.411] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.411] Packages: <none>
[16:59:34.411] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.411] Resolved: TRUE
[16:59:34.411] Value: 5.37 KiB of class ‘list’
[16:59:34.411] Early signaling: FALSE
[16:59:34.411] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.411] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.412] Chunk #1 of 1 ... DONE
[16:59:34.412] Launching 1 futures (chunks) ... DONE
[16:59:34.412] Resolving 1 futures (chunks) ...
[16:59:34.413] resolve() on list ...
[16:59:34.413]  recursive: 0
[16:59:34.413]  length: 1
[16:59:34.413] 
[16:59:34.413] resolved() for ‘SequentialFuture’ ...
[16:59:34.413] - state: ‘finished’
[16:59:34.413] - run: TRUE
[16:59:34.413] - result: ‘FutureResult’
[16:59:34.413] resolved() for ‘SequentialFuture’ ... done
[16:59:34.413] Future #1
[16:59:34.414] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.414] - nx: 1
[16:59:34.414] - relay: TRUE
[16:59:34.414] - stdout: TRUE
[16:59:34.414] - signal: TRUE
[16:59:34.414] - resignal: FALSE
[16:59:34.414] - force: TRUE
[16:59:34.414] - relayed: [n=1] FALSE
[16:59:34.414] - queued futures: [n=1] FALSE
[16:59:34.414]  - until=1
[16:59:34.414]  - relaying element #1
[16:59:34.415] - relayed: [n=1] TRUE
[16:59:34.415] - queued futures: [n=1] TRUE
[16:59:34.415] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.415]  length: 0 (resolved future 1)
[16:59:34.416] Relaying remaining futures
[16:59:34.417] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.417] - nx: 1
[16:59:34.417] - relay: TRUE
[16:59:34.417] - stdout: TRUE
[16:59:34.417] - signal: TRUE
[16:59:34.417] - resignal: FALSE
[16:59:34.417] - force: TRUE
[16:59:34.417] - relayed: [n=1] TRUE
[16:59:34.417] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.418] - relayed: [n=1] TRUE
[16:59:34.418] - queued futures: [n=1] TRUE
[16:59:34.418] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.418] resolve() on list ... DONE
[16:59:34.418]  - Number of value chunks collected: 1
[16:59:34.418] Resolving 1 futures (chunks) ... DONE
[16:59:34.418] Reducing values from 1 chunks ...
[16:59:34.418]  - Number of values collected after concatenation: 3
[16:59:34.418]  - Number of values expected: 3
[16:59:34.419] Reducing values from 1 chunks ... DONE
[16:59:34.419] future_lapply() ... DONE
[16:59:34.419] future_by_internal() ... DONE
[16:59:34.420] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:59:34.420] future_lapply() ...
[16:59:34.424] Number of chunks: 1
[16:59:34.424] getGlobalsAndPackagesXApply() ...
[16:59:34.424]  - future.globals: TRUE
[16:59:34.424] getGlobalsAndPackages() ...
[16:59:34.425] Searching for globals...
[16:59:34.426] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.426] Searching for globals ... DONE
[16:59:34.426] Resolving globals: FALSE
[16:59:34.426] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.426] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.427] - globals: [1] ‘FUN’
[16:59:34.427] 
[16:59:34.427] getGlobalsAndPackages() ... DONE
[16:59:34.427]  - globals found/used: [n=1] ‘FUN’
[16:59:34.427]  - needed namespaces: [n=0] 
[16:59:34.427] Finding globals ... DONE
[16:59:34.427]  - use_args: TRUE
[16:59:34.427]  - Getting '...' globals ...
[16:59:34.428] resolve() on list ...
[16:59:34.428]  recursive: 0
[16:59:34.428]  length: 1
[16:59:34.428]  elements: ‘...’
[16:59:34.428]  length: 0 (resolved future 1)
[16:59:34.428] resolve() on list ... DONE
[16:59:34.428]    - '...' content: [n=0] 
[16:59:34.428] List of 1
[16:59:34.428]  $ ...: list()
[16:59:34.428]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.428]  - attr(*, "where")=List of 1
[16:59:34.428]   ..$ ...:<environment: 0x562051cc45b8> 
[16:59:34.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.428]  - attr(*, "resolved")= logi TRUE
[16:59:34.428]  - attr(*, "total_size")= num NA
[16:59:34.431]  - Getting '...' globals ... DONE
[16:59:34.431] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.431] List of 2
[16:59:34.431]  $ ...future.FUN:function (object, ...)  
[16:59:34.431]  $ ...          : list()
[16:59:34.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.431]  - attr(*, "where")=List of 2
[16:59:34.431]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.431]   ..$ ...          :<environment: 0x562051cc45b8> 
[16:59:34.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.431]  - attr(*, "resolved")= logi FALSE
[16:59:34.431]  - attr(*, "total_size")= num 1240
[16:59:34.434] Packages to be attached in all futures: [n=0] 
[16:59:34.434] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.434] Number of futures (= number of chunks): 1
[16:59:34.434] Launching 1 futures (chunks) ...
[16:59:34.434] Chunk #1 of 1 ...
[16:59:34.434]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.434] getGlobalsAndPackages() ...
[16:59:34.435] Searching for globals...
[16:59:34.435] 
[16:59:34.435] Searching for globals ... DONE
[16:59:34.435] - globals: [0] <none>
[16:59:34.435] getGlobalsAndPackages() ... DONE
[16:59:34.435]    + additional globals found: [n=0] 
[16:59:34.436]    + additional namespaces needed: [n=0] 
[16:59:34.436]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.436]  - seeds: <none>
[16:59:34.436]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.436] getGlobalsAndPackages() ...
[16:59:34.436] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.436] Resolving globals: FALSE
[16:59:34.436] Tweak future expression to call with '...' arguments ...
[16:59:34.436] {
[16:59:34.436]     do.call(function(...) {
[16:59:34.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.436]             on.exit(options(oopts), add = TRUE)
[16:59:34.436]         }
[16:59:34.436]         {
[16:59:34.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.436]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.436]             })
[16:59:34.436]         }
[16:59:34.436]     }, args = future.call.arguments)
[16:59:34.436] }
[16:59:34.437] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.437] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.437] 
[16:59:34.437] getGlobalsAndPackages() ... DONE
[16:59:34.437] run() for ‘Future’ ...
[16:59:34.438] - state: ‘created’
[16:59:34.438] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.441] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.442]   - Field: ‘label’
[16:59:34.442]   - Field: ‘local’
[16:59:34.442]   - Field: ‘owner’
[16:59:34.442]   - Field: ‘envir’
[16:59:34.442]   - Field: ‘packages’
[16:59:34.442]   - Field: ‘gc’
[16:59:34.442]   - Field: ‘conditions’
[16:59:34.442]   - Field: ‘expr’
[16:59:34.442]   - Field: ‘uuid’
[16:59:34.442]   - Field: ‘seed’
[16:59:34.442]   - Field: ‘version’
[16:59:34.443]   - Field: ‘result’
[16:59:34.443]   - Field: ‘asynchronous’
[16:59:34.443]   - Field: ‘calls’
[16:59:34.443]   - Field: ‘globals’
[16:59:34.443]   - Field: ‘stdout’
[16:59:34.443]   - Field: ‘earlySignal’
[16:59:34.443]   - Field: ‘lazy’
[16:59:34.443]   - Field: ‘state’
[16:59:34.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.445] - Launch lazy future ...
[16:59:34.445] Packages needed by the future expression (n = 0): <none>
[16:59:34.445] Packages needed by future strategies (n = 0): <none>
[16:59:34.446] {
[16:59:34.446]     {
[16:59:34.446]         {
[16:59:34.446]             ...future.startTime <- base::Sys.time()
[16:59:34.446]             {
[16:59:34.446]                 {
[16:59:34.446]                   {
[16:59:34.446]                     base::local({
[16:59:34.446]                       has_future <- base::requireNamespace("future", 
[16:59:34.446]                         quietly = TRUE)
[16:59:34.446]                       if (has_future) {
[16:59:34.446]                         ns <- base::getNamespace("future")
[16:59:34.446]                         version <- ns[[".package"]][["version"]]
[16:59:34.446]                         if (is.null(version)) 
[16:59:34.446]                           version <- utils::packageVersion("future")
[16:59:34.446]                       }
[16:59:34.446]                       else {
[16:59:34.446]                         version <- NULL
[16:59:34.446]                       }
[16:59:34.446]                       if (!has_future || version < "1.8.0") {
[16:59:34.446]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.446]                           "", base::R.version$version.string), 
[16:59:34.446]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.446]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.446]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.446]                             "release", "version")], collapse = " "), 
[16:59:34.446]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.446]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.446]                           info)
[16:59:34.446]                         info <- base::paste(info, collapse = "; ")
[16:59:34.446]                         if (!has_future) {
[16:59:34.446]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.446]                             info)
[16:59:34.446]                         }
[16:59:34.446]                         else {
[16:59:34.446]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.446]                             info, version)
[16:59:34.446]                         }
[16:59:34.446]                         base::stop(msg)
[16:59:34.446]                       }
[16:59:34.446]                     })
[16:59:34.446]                   }
[16:59:34.446]                   ...future.strategy.old <- future::plan("list")
[16:59:34.446]                   options(future.plan = NULL)
[16:59:34.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.446]                 }
[16:59:34.446]                 ...future.workdir <- getwd()
[16:59:34.446]             }
[16:59:34.446]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.446]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.446]         }
[16:59:34.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.446]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.446]             base::names(...future.oldOptions))
[16:59:34.446]     }
[16:59:34.446]     if (FALSE) {
[16:59:34.446]     }
[16:59:34.446]     else {
[16:59:34.446]         if (TRUE) {
[16:59:34.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.446]                 open = "w")
[16:59:34.446]         }
[16:59:34.446]         else {
[16:59:34.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.446]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.446]         }
[16:59:34.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.446]             base::sink(type = "output", split = FALSE)
[16:59:34.446]             base::close(...future.stdout)
[16:59:34.446]         }, add = TRUE)
[16:59:34.446]     }
[16:59:34.446]     ...future.frame <- base::sys.nframe()
[16:59:34.446]     ...future.conditions <- base::list()
[16:59:34.446]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.446]     if (FALSE) {
[16:59:34.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.446]     }
[16:59:34.446]     ...future.result <- base::tryCatch({
[16:59:34.446]         base::withCallingHandlers({
[16:59:34.446]             ...future.value <- base::withVisible(base::local({
[16:59:34.446]                 do.call(function(...) {
[16:59:34.446]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.446]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.446]                     ...future.globals.maxSize)) {
[16:59:34.446]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.446]                     on.exit(options(oopts), add = TRUE)
[16:59:34.446]                   }
[16:59:34.446]                   {
[16:59:34.446]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.446]                       FUN = function(jj) {
[16:59:34.446]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.446]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.446]                       })
[16:59:34.446]                   }
[16:59:34.446]                 }, args = future.call.arguments)
[16:59:34.446]             }))
[16:59:34.446]             future::FutureResult(value = ...future.value$value, 
[16:59:34.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.446]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.446]                     ...future.globalenv.names))
[16:59:34.446]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.446]         }, condition = base::local({
[16:59:34.446]             c <- base::c
[16:59:34.446]             inherits <- base::inherits
[16:59:34.446]             invokeRestart <- base::invokeRestart
[16:59:34.446]             length <- base::length
[16:59:34.446]             list <- base::list
[16:59:34.446]             seq.int <- base::seq.int
[16:59:34.446]             signalCondition <- base::signalCondition
[16:59:34.446]             sys.calls <- base::sys.calls
[16:59:34.446]             `[[` <- base::`[[`
[16:59:34.446]             `+` <- base::`+`
[16:59:34.446]             `<<-` <- base::`<<-`
[16:59:34.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.446]                   3L)]
[16:59:34.446]             }
[16:59:34.446]             function(cond) {
[16:59:34.446]                 is_error <- inherits(cond, "error")
[16:59:34.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.446]                   NULL)
[16:59:34.446]                 if (is_error) {
[16:59:34.446]                   sessionInformation <- function() {
[16:59:34.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.446]                       search = base::search(), system = base::Sys.info())
[16:59:34.446]                   }
[16:59:34.446]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.446]                     cond$call), session = sessionInformation(), 
[16:59:34.446]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.446]                   signalCondition(cond)
[16:59:34.446]                 }
[16:59:34.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.446]                 "immediateCondition"))) {
[16:59:34.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.446]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.446]                   if (TRUE && !signal) {
[16:59:34.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.446]                     {
[16:59:34.446]                       inherits <- base::inherits
[16:59:34.446]                       invokeRestart <- base::invokeRestart
[16:59:34.446]                       is.null <- base::is.null
[16:59:34.446]                       muffled <- FALSE
[16:59:34.446]                       if (inherits(cond, "message")) {
[16:59:34.446]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.446]                         if (muffled) 
[16:59:34.446]                           invokeRestart("muffleMessage")
[16:59:34.446]                       }
[16:59:34.446]                       else if (inherits(cond, "warning")) {
[16:59:34.446]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.446]                         if (muffled) 
[16:59:34.446]                           invokeRestart("muffleWarning")
[16:59:34.446]                       }
[16:59:34.446]                       else if (inherits(cond, "condition")) {
[16:59:34.446]                         if (!is.null(pattern)) {
[16:59:34.446]                           computeRestarts <- base::computeRestarts
[16:59:34.446]                           grepl <- base::grepl
[16:59:34.446]                           restarts <- computeRestarts(cond)
[16:59:34.446]                           for (restart in restarts) {
[16:59:34.446]                             name <- restart$name
[16:59:34.446]                             if (is.null(name)) 
[16:59:34.446]                               next
[16:59:34.446]                             if (!grepl(pattern, name)) 
[16:59:34.446]                               next
[16:59:34.446]                             invokeRestart(restart)
[16:59:34.446]                             muffled <- TRUE
[16:59:34.446]                             break
[16:59:34.446]                           }
[16:59:34.446]                         }
[16:59:34.446]                       }
[16:59:34.446]                       invisible(muffled)
[16:59:34.446]                     }
[16:59:34.446]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.446]                   }
[16:59:34.446]                 }
[16:59:34.446]                 else {
[16:59:34.446]                   if (TRUE) {
[16:59:34.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.446]                     {
[16:59:34.446]                       inherits <- base::inherits
[16:59:34.446]                       invokeRestart <- base::invokeRestart
[16:59:34.446]                       is.null <- base::is.null
[16:59:34.446]                       muffled <- FALSE
[16:59:34.446]                       if (inherits(cond, "message")) {
[16:59:34.446]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.446]                         if (muffled) 
[16:59:34.446]                           invokeRestart("muffleMessage")
[16:59:34.446]                       }
[16:59:34.446]                       else if (inherits(cond, "warning")) {
[16:59:34.446]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.446]                         if (muffled) 
[16:59:34.446]                           invokeRestart("muffleWarning")
[16:59:34.446]                       }
[16:59:34.446]                       else if (inherits(cond, "condition")) {
[16:59:34.446]                         if (!is.null(pattern)) {
[16:59:34.446]                           computeRestarts <- base::computeRestarts
[16:59:34.446]                           grepl <- base::grepl
[16:59:34.446]                           restarts <- computeRestarts(cond)
[16:59:34.446]                           for (restart in restarts) {
[16:59:34.446]                             name <- restart$name
[16:59:34.446]                             if (is.null(name)) 
[16:59:34.446]                               next
[16:59:34.446]                             if (!grepl(pattern, name)) 
[16:59:34.446]                               next
[16:59:34.446]                             invokeRestart(restart)
[16:59:34.446]                             muffled <- TRUE
[16:59:34.446]                             break
[16:59:34.446]                           }
[16:59:34.446]                         }
[16:59:34.446]                       }
[16:59:34.446]                       invisible(muffled)
[16:59:34.446]                     }
[16:59:34.446]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.446]                   }
[16:59:34.446]                 }
[16:59:34.446]             }
[16:59:34.446]         }))
[16:59:34.446]     }, error = function(ex) {
[16:59:34.446]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.446]                 ...future.rng), started = ...future.startTime, 
[16:59:34.446]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.446]             version = "1.8"), class = "FutureResult")
[16:59:34.446]     }, finally = {
[16:59:34.446]         if (!identical(...future.workdir, getwd())) 
[16:59:34.446]             setwd(...future.workdir)
[16:59:34.446]         {
[16:59:34.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.446]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.446]             }
[16:59:34.446]             base::options(...future.oldOptions)
[16:59:34.446]             if (.Platform$OS.type == "windows") {
[16:59:34.446]                 old_names <- names(...future.oldEnvVars)
[16:59:34.446]                 envs <- base::Sys.getenv()
[16:59:34.446]                 names <- names(envs)
[16:59:34.446]                 common <- intersect(names, old_names)
[16:59:34.446]                 added <- setdiff(names, old_names)
[16:59:34.446]                 removed <- setdiff(old_names, names)
[16:59:34.446]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.446]                   envs[common]]
[16:59:34.446]                 NAMES <- toupper(changed)
[16:59:34.446]                 args <- list()
[16:59:34.446]                 for (kk in seq_along(NAMES)) {
[16:59:34.446]                   name <- changed[[kk]]
[16:59:34.446]                   NAME <- NAMES[[kk]]
[16:59:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.446]                     next
[16:59:34.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.446]                 }
[16:59:34.446]                 NAMES <- toupper(added)
[16:59:34.446]                 for (kk in seq_along(NAMES)) {
[16:59:34.446]                   name <- added[[kk]]
[16:59:34.446]                   NAME <- NAMES[[kk]]
[16:59:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.446]                     next
[16:59:34.446]                   args[[name]] <- ""
[16:59:34.446]                 }
[16:59:34.446]                 NAMES <- toupper(removed)
[16:59:34.446]                 for (kk in seq_along(NAMES)) {
[16:59:34.446]                   name <- removed[[kk]]
[16:59:34.446]                   NAME <- NAMES[[kk]]
[16:59:34.446]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.446]                     next
[16:59:34.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.446]                 }
[16:59:34.446]                 if (length(args) > 0) 
[16:59:34.446]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.446]             }
[16:59:34.446]             else {
[16:59:34.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.446]             }
[16:59:34.446]             {
[16:59:34.446]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.446]                   0L) {
[16:59:34.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.446]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.446]                   base::options(opts)
[16:59:34.446]                 }
[16:59:34.446]                 {
[16:59:34.446]                   {
[16:59:34.446]                     NULL
[16:59:34.446]                     RNGkind("Mersenne-Twister")
[16:59:34.446]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.446]                       inherits = FALSE)
[16:59:34.446]                   }
[16:59:34.446]                   options(future.plan = NULL)
[16:59:34.446]                   if (is.na(NA_character_)) 
[16:59:34.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.446]                     .init = FALSE)
[16:59:34.446]                 }
[16:59:34.446]             }
[16:59:34.446]         }
[16:59:34.446]     })
[16:59:34.446]     if (TRUE) {
[16:59:34.446]         base::sink(type = "output", split = FALSE)
[16:59:34.446]         if (TRUE) {
[16:59:34.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.446]         }
[16:59:34.446]         else {
[16:59:34.446]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.446]         }
[16:59:34.446]         base::close(...future.stdout)
[16:59:34.446]         ...future.stdout <- NULL
[16:59:34.446]     }
[16:59:34.446]     ...future.result$conditions <- ...future.conditions
[16:59:34.446]     ...future.result$finished <- base::Sys.time()
[16:59:34.446]     ...future.result
[16:59:34.446] }
[16:59:34.448] assign_globals() ...
[16:59:34.448] List of 5
[16:59:34.448]  $ ...future.FUN            :function (object, ...)  
[16:59:34.448]  $ future.call.arguments    : list()
[16:59:34.448]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.448]  $ ...future.elements_ii    :List of 3
[16:59:34.448]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.448]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.448]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.448]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.448]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.448]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.448]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.448]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.448]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.448]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.448]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.448]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.448]  $ ...future.seeds_ii       : NULL
[16:59:34.448]  $ ...future.globals.maxSize: NULL
[16:59:34.448]  - attr(*, "where")=List of 5
[16:59:34.448]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.448]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.448]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.448]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.448]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.448]  - attr(*, "resolved")= logi FALSE
[16:59:34.448]  - attr(*, "total_size")= num 1240
[16:59:34.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.448]  - attr(*, "already-done")= logi TRUE
[16:59:34.457] - copied ‘...future.FUN’ to environment
[16:59:34.457] - copied ‘future.call.arguments’ to environment
[16:59:34.457] - copied ‘...future.elements_ii’ to environment
[16:59:34.457] - copied ‘...future.seeds_ii’ to environment
[16:59:34.457] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.457] assign_globals() ... done
[16:59:34.457] plan(): Setting new future strategy stack:
[16:59:34.458] List of future strategies:
[16:59:34.458] 1. sequential:
[16:59:34.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.458]    - tweaked: FALSE
[16:59:34.458]    - call: NULL
[16:59:34.458] plan(): nbrOfWorkers() = 1
[16:59:34.460] plan(): Setting new future strategy stack:
[16:59:34.460] List of future strategies:
[16:59:34.460] 1. multicore:
[16:59:34.460]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:34.460]    - tweaked: FALSE
[16:59:34.460]    - call: plan(strategy)
[16:59:34.464] plan(): nbrOfWorkers() = 1
[16:59:34.464] SequentialFuture started (and completed)
[16:59:34.464] - Launch lazy future ... done
[16:59:34.465] run() for ‘SequentialFuture’ ... done
[16:59:34.465] Created future:
[16:59:34.465] SequentialFuture:
[16:59:34.465] Label: ‘future_by-1’
[16:59:34.465] Expression:
[16:59:34.465] {
[16:59:34.465]     do.call(function(...) {
[16:59:34.465]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.465]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.465]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.465]             on.exit(options(oopts), add = TRUE)
[16:59:34.465]         }
[16:59:34.465]         {
[16:59:34.465]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.465]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.465]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.465]             })
[16:59:34.465]         }
[16:59:34.465]     }, args = future.call.arguments)
[16:59:34.465] }
[16:59:34.465] Lazy evaluation: FALSE
[16:59:34.465] Asynchronous evaluation: FALSE
[16:59:34.465] Local evaluation: TRUE
[16:59:34.465] Environment: 0x562051d26248
[16:59:34.465] Capture standard output: TRUE
[16:59:34.465] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.465] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.465] Packages: <none>
[16:59:34.465] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.465] Resolved: TRUE
[16:59:34.465] Value: 5.37 KiB of class ‘list’
[16:59:34.465] Early signaling: FALSE
[16:59:34.465] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.465] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.466] Chunk #1 of 1 ... DONE
[16:59:34.466] Launching 1 futures (chunks) ... DONE
[16:59:34.466] Resolving 1 futures (chunks) ...
[16:59:34.466] resolve() on list ...
[16:59:34.466]  recursive: 0
[16:59:34.467]  length: 1
[16:59:34.467] 
[16:59:34.467] resolved() for ‘SequentialFuture’ ...
[16:59:34.467] - state: ‘finished’
[16:59:34.467] - run: TRUE
[16:59:34.467] - result: ‘FutureResult’
[16:59:34.467] resolved() for ‘SequentialFuture’ ... done
[16:59:34.467] Future #1
[16:59:34.467] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.468] - nx: 1
[16:59:34.468] - relay: TRUE
[16:59:34.468] - stdout: TRUE
[16:59:34.468] - signal: TRUE
[16:59:34.468] - resignal: FALSE
[16:59:34.468] - force: TRUE
[16:59:34.468] - relayed: [n=1] FALSE
[16:59:34.468] - queued futures: [n=1] FALSE
[16:59:34.468]  - until=1
[16:59:34.468]  - relaying element #1
[16:59:34.468] - relayed: [n=1] TRUE
[16:59:34.469] - queued futures: [n=1] TRUE
[16:59:34.469] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.469]  length: 0 (resolved future 1)
[16:59:34.469] Relaying remaining futures
[16:59:34.469] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.469] - nx: 1
[16:59:34.469] - relay: TRUE
[16:59:34.469] - stdout: TRUE
[16:59:34.469] - signal: TRUE
[16:59:34.469] - resignal: FALSE
[16:59:34.469] - force: TRUE
[16:59:34.470] - relayed: [n=1] TRUE
[16:59:34.470] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.470] - relayed: [n=1] TRUE
[16:59:34.470] - queued futures: [n=1] TRUE
[16:59:34.470] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.470] resolve() on list ... DONE
[16:59:34.470]  - Number of value chunks collected: 1
[16:59:34.470] Resolving 1 futures (chunks) ... DONE
[16:59:34.470] Reducing values from 1 chunks ...
[16:59:34.470]  - Number of values collected after concatenation: 3
[16:59:34.471]  - Number of values expected: 3
[16:59:34.471] Reducing values from 1 chunks ... DONE
[16:59:34.471] future_lapply() ... DONE
[16:59:34.471] future_by_internal() ... DONE
[16:59:34.473] future_by_internal() ...
- plan('multisession') ...
[16:59:34.474] plan(): Setting new future strategy stack:
[16:59:34.474] List of future strategies:
[16:59:34.474] 1. multisession:
[16:59:34.474]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.474]    - tweaked: FALSE
[16:59:34.474]    - call: plan(strategy)
[16:59:34.475] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:59:34.475] multisession:
[16:59:34.475] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.475] - tweaked: FALSE
[16:59:34.475] - call: plan(strategy)
[16:59:34.479] getGlobalsAndPackages() ...
[16:59:34.479] Not searching for globals
[16:59:34.479] - globals: [0] <none>
[16:59:34.479] getGlobalsAndPackages() ... DONE
[16:59:34.479] Packages needed by the future expression (n = 0): <none>
[16:59:34.479] Packages needed by future strategies (n = 0): <none>
[16:59:34.480] {
[16:59:34.480]     {
[16:59:34.480]         {
[16:59:34.480]             ...future.startTime <- base::Sys.time()
[16:59:34.480]             {
[16:59:34.480]                 {
[16:59:34.480]                   {
[16:59:34.480]                     base::local({
[16:59:34.480]                       has_future <- base::requireNamespace("future", 
[16:59:34.480]                         quietly = TRUE)
[16:59:34.480]                       if (has_future) {
[16:59:34.480]                         ns <- base::getNamespace("future")
[16:59:34.480]                         version <- ns[[".package"]][["version"]]
[16:59:34.480]                         if (is.null(version)) 
[16:59:34.480]                           version <- utils::packageVersion("future")
[16:59:34.480]                       }
[16:59:34.480]                       else {
[16:59:34.480]                         version <- NULL
[16:59:34.480]                       }
[16:59:34.480]                       if (!has_future || version < "1.8.0") {
[16:59:34.480]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.480]                           "", base::R.version$version.string), 
[16:59:34.480]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.480]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.480]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.480]                             "release", "version")], collapse = " "), 
[16:59:34.480]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.480]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.480]                           info)
[16:59:34.480]                         info <- base::paste(info, collapse = "; ")
[16:59:34.480]                         if (!has_future) {
[16:59:34.480]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.480]                             info)
[16:59:34.480]                         }
[16:59:34.480]                         else {
[16:59:34.480]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.480]                             info, version)
[16:59:34.480]                         }
[16:59:34.480]                         base::stop(msg)
[16:59:34.480]                       }
[16:59:34.480]                     })
[16:59:34.480]                   }
[16:59:34.480]                   ...future.strategy.old <- future::plan("list")
[16:59:34.480]                   options(future.plan = NULL)
[16:59:34.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.480]                 }
[16:59:34.480]                 ...future.workdir <- getwd()
[16:59:34.480]             }
[16:59:34.480]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.480]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.480]         }
[16:59:34.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.480]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.480]             base::names(...future.oldOptions))
[16:59:34.480]     }
[16:59:34.480]     if (FALSE) {
[16:59:34.480]     }
[16:59:34.480]     else {
[16:59:34.480]         if (TRUE) {
[16:59:34.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.480]                 open = "w")
[16:59:34.480]         }
[16:59:34.480]         else {
[16:59:34.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.480]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.480]         }
[16:59:34.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.480]             base::sink(type = "output", split = FALSE)
[16:59:34.480]             base::close(...future.stdout)
[16:59:34.480]         }, add = TRUE)
[16:59:34.480]     }
[16:59:34.480]     ...future.frame <- base::sys.nframe()
[16:59:34.480]     ...future.conditions <- base::list()
[16:59:34.480]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.480]     if (FALSE) {
[16:59:34.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.480]     }
[16:59:34.480]     ...future.result <- base::tryCatch({
[16:59:34.480]         base::withCallingHandlers({
[16:59:34.480]             ...future.value <- base::withVisible(base::local(NA))
[16:59:34.480]             future::FutureResult(value = ...future.value$value, 
[16:59:34.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.480]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.480]                     ...future.globalenv.names))
[16:59:34.480]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.480]         }, condition = base::local({
[16:59:34.480]             c <- base::c
[16:59:34.480]             inherits <- base::inherits
[16:59:34.480]             invokeRestart <- base::invokeRestart
[16:59:34.480]             length <- base::length
[16:59:34.480]             list <- base::list
[16:59:34.480]             seq.int <- base::seq.int
[16:59:34.480]             signalCondition <- base::signalCondition
[16:59:34.480]             sys.calls <- base::sys.calls
[16:59:34.480]             `[[` <- base::`[[`
[16:59:34.480]             `+` <- base::`+`
[16:59:34.480]             `<<-` <- base::`<<-`
[16:59:34.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.480]                   3L)]
[16:59:34.480]             }
[16:59:34.480]             function(cond) {
[16:59:34.480]                 is_error <- inherits(cond, "error")
[16:59:34.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.480]                   NULL)
[16:59:34.480]                 if (is_error) {
[16:59:34.480]                   sessionInformation <- function() {
[16:59:34.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.480]                       search = base::search(), system = base::Sys.info())
[16:59:34.480]                   }
[16:59:34.480]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.480]                     cond$call), session = sessionInformation(), 
[16:59:34.480]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.480]                   signalCondition(cond)
[16:59:34.480]                 }
[16:59:34.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.480]                 "immediateCondition"))) {
[16:59:34.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.480]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.480]                   if (TRUE && !signal) {
[16:59:34.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.480]                     {
[16:59:34.480]                       inherits <- base::inherits
[16:59:34.480]                       invokeRestart <- base::invokeRestart
[16:59:34.480]                       is.null <- base::is.null
[16:59:34.480]                       muffled <- FALSE
[16:59:34.480]                       if (inherits(cond, "message")) {
[16:59:34.480]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.480]                         if (muffled) 
[16:59:34.480]                           invokeRestart("muffleMessage")
[16:59:34.480]                       }
[16:59:34.480]                       else if (inherits(cond, "warning")) {
[16:59:34.480]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.480]                         if (muffled) 
[16:59:34.480]                           invokeRestart("muffleWarning")
[16:59:34.480]                       }
[16:59:34.480]                       else if (inherits(cond, "condition")) {
[16:59:34.480]                         if (!is.null(pattern)) {
[16:59:34.480]                           computeRestarts <- base::computeRestarts
[16:59:34.480]                           grepl <- base::grepl
[16:59:34.480]                           restarts <- computeRestarts(cond)
[16:59:34.480]                           for (restart in restarts) {
[16:59:34.480]                             name <- restart$name
[16:59:34.480]                             if (is.null(name)) 
[16:59:34.480]                               next
[16:59:34.480]                             if (!grepl(pattern, name)) 
[16:59:34.480]                               next
[16:59:34.480]                             invokeRestart(restart)
[16:59:34.480]                             muffled <- TRUE
[16:59:34.480]                             break
[16:59:34.480]                           }
[16:59:34.480]                         }
[16:59:34.480]                       }
[16:59:34.480]                       invisible(muffled)
[16:59:34.480]                     }
[16:59:34.480]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.480]                   }
[16:59:34.480]                 }
[16:59:34.480]                 else {
[16:59:34.480]                   if (TRUE) {
[16:59:34.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.480]                     {
[16:59:34.480]                       inherits <- base::inherits
[16:59:34.480]                       invokeRestart <- base::invokeRestart
[16:59:34.480]                       is.null <- base::is.null
[16:59:34.480]                       muffled <- FALSE
[16:59:34.480]                       if (inherits(cond, "message")) {
[16:59:34.480]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.480]                         if (muffled) 
[16:59:34.480]                           invokeRestart("muffleMessage")
[16:59:34.480]                       }
[16:59:34.480]                       else if (inherits(cond, "warning")) {
[16:59:34.480]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.480]                         if (muffled) 
[16:59:34.480]                           invokeRestart("muffleWarning")
[16:59:34.480]                       }
[16:59:34.480]                       else if (inherits(cond, "condition")) {
[16:59:34.480]                         if (!is.null(pattern)) {
[16:59:34.480]                           computeRestarts <- base::computeRestarts
[16:59:34.480]                           grepl <- base::grepl
[16:59:34.480]                           restarts <- computeRestarts(cond)
[16:59:34.480]                           for (restart in restarts) {
[16:59:34.480]                             name <- restart$name
[16:59:34.480]                             if (is.null(name)) 
[16:59:34.480]                               next
[16:59:34.480]                             if (!grepl(pattern, name)) 
[16:59:34.480]                               next
[16:59:34.480]                             invokeRestart(restart)
[16:59:34.480]                             muffled <- TRUE
[16:59:34.480]                             break
[16:59:34.480]                           }
[16:59:34.480]                         }
[16:59:34.480]                       }
[16:59:34.480]                       invisible(muffled)
[16:59:34.480]                     }
[16:59:34.480]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.480]                   }
[16:59:34.480]                 }
[16:59:34.480]             }
[16:59:34.480]         }))
[16:59:34.480]     }, error = function(ex) {
[16:59:34.480]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.480]                 ...future.rng), started = ...future.startTime, 
[16:59:34.480]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.480]             version = "1.8"), class = "FutureResult")
[16:59:34.480]     }, finally = {
[16:59:34.480]         if (!identical(...future.workdir, getwd())) 
[16:59:34.480]             setwd(...future.workdir)
[16:59:34.480]         {
[16:59:34.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.480]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.480]             }
[16:59:34.480]             base::options(...future.oldOptions)
[16:59:34.480]             if (.Platform$OS.type == "windows") {
[16:59:34.480]                 old_names <- names(...future.oldEnvVars)
[16:59:34.480]                 envs <- base::Sys.getenv()
[16:59:34.480]                 names <- names(envs)
[16:59:34.480]                 common <- intersect(names, old_names)
[16:59:34.480]                 added <- setdiff(names, old_names)
[16:59:34.480]                 removed <- setdiff(old_names, names)
[16:59:34.480]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.480]                   envs[common]]
[16:59:34.480]                 NAMES <- toupper(changed)
[16:59:34.480]                 args <- list()
[16:59:34.480]                 for (kk in seq_along(NAMES)) {
[16:59:34.480]                   name <- changed[[kk]]
[16:59:34.480]                   NAME <- NAMES[[kk]]
[16:59:34.480]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.480]                     next
[16:59:34.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.480]                 }
[16:59:34.480]                 NAMES <- toupper(added)
[16:59:34.480]                 for (kk in seq_along(NAMES)) {
[16:59:34.480]                   name <- added[[kk]]
[16:59:34.480]                   NAME <- NAMES[[kk]]
[16:59:34.480]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.480]                     next
[16:59:34.480]                   args[[name]] <- ""
[16:59:34.480]                 }
[16:59:34.480]                 NAMES <- toupper(removed)
[16:59:34.480]                 for (kk in seq_along(NAMES)) {
[16:59:34.480]                   name <- removed[[kk]]
[16:59:34.480]                   NAME <- NAMES[[kk]]
[16:59:34.480]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.480]                     next
[16:59:34.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.480]                 }
[16:59:34.480]                 if (length(args) > 0) 
[16:59:34.480]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.480]             }
[16:59:34.480]             else {
[16:59:34.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.480]             }
[16:59:34.480]             {
[16:59:34.480]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.480]                   0L) {
[16:59:34.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.480]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.480]                   base::options(opts)
[16:59:34.480]                 }
[16:59:34.480]                 {
[16:59:34.480]                   {
[16:59:34.480]                     NULL
[16:59:34.480]                     RNGkind("Mersenne-Twister")
[16:59:34.480]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.480]                       inherits = FALSE)
[16:59:34.480]                   }
[16:59:34.480]                   options(future.plan = NULL)
[16:59:34.480]                   if (is.na(NA_character_)) 
[16:59:34.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.480]                     .init = FALSE)
[16:59:34.480]                 }
[16:59:34.480]             }
[16:59:34.480]         }
[16:59:34.480]     })
[16:59:34.480]     if (TRUE) {
[16:59:34.480]         base::sink(type = "output", split = FALSE)
[16:59:34.480]         if (TRUE) {
[16:59:34.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.480]         }
[16:59:34.480]         else {
[16:59:34.480]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.480]         }
[16:59:34.480]         base::close(...future.stdout)
[16:59:34.480]         ...future.stdout <- NULL
[16:59:34.480]     }
[16:59:34.480]     ...future.result$conditions <- ...future.conditions
[16:59:34.480]     ...future.result$finished <- base::Sys.time()
[16:59:34.480]     ...future.result
[16:59:34.480] }
[16:59:34.482] plan(): Setting new future strategy stack:
[16:59:34.482] List of future strategies:
[16:59:34.482] 1. sequential:
[16:59:34.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.482]    - tweaked: FALSE
[16:59:34.482]    - call: NULL
[16:59:34.482] plan(): nbrOfWorkers() = 1
[16:59:34.483] plan(): Setting new future strategy stack:
[16:59:34.483] List of future strategies:
[16:59:34.483] 1. multisession:
[16:59:34.483]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.483]    - tweaked: FALSE
[16:59:34.483]    - call: plan(strategy)
[16:59:34.486] plan(): nbrOfWorkers() = 1
[16:59:34.487] SequentialFuture started (and completed)
[16:59:34.487] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:59:34.490] plan(): nbrOfWorkers() = 1
[16:59:34.490] future_by_internal() ...
[16:59:34.490] future_lapply() ...
[16:59:34.494] Number of chunks: 1
[16:59:34.494] getGlobalsAndPackagesXApply() ...
[16:59:34.494]  - future.globals: TRUE
[16:59:34.494] getGlobalsAndPackages() ...
[16:59:34.494] Searching for globals...
[16:59:34.495] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.496] Searching for globals ... DONE
[16:59:34.496] Resolving globals: FALSE
[16:59:34.496] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.496] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.496] - globals: [1] ‘FUN’
[16:59:34.497] 
[16:59:34.497] getGlobalsAndPackages() ... DONE
[16:59:34.497]  - globals found/used: [n=1] ‘FUN’
[16:59:34.497]  - needed namespaces: [n=0] 
[16:59:34.497] Finding globals ... DONE
[16:59:34.497]  - use_args: TRUE
[16:59:34.497]  - Getting '...' globals ...
[16:59:34.497] resolve() on list ...
[16:59:34.498]  recursive: 0
[16:59:34.498]  length: 1
[16:59:34.498]  elements: ‘...’
[16:59:34.498]  length: 0 (resolved future 1)
[16:59:34.498] resolve() on list ... DONE
[16:59:34.498]    - '...' content: [n=0] 
[16:59:34.498] List of 1
[16:59:34.498]  $ ...: list()
[16:59:34.498]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.498]  - attr(*, "where")=List of 1
[16:59:34.498]   ..$ ...:<environment: 0x562051fa8818> 
[16:59:34.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.498]  - attr(*, "resolved")= logi TRUE
[16:59:34.498]  - attr(*, "total_size")= num NA
[16:59:34.501]  - Getting '...' globals ... DONE
[16:59:34.501] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.501] List of 2
[16:59:34.501]  $ ...future.FUN:function (object, ...)  
[16:59:34.501]  $ ...          : list()
[16:59:34.501]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.501]  - attr(*, "where")=List of 2
[16:59:34.501]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.501]   ..$ ...          :<environment: 0x562051fa8818> 
[16:59:34.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.501]  - attr(*, "resolved")= logi FALSE
[16:59:34.501]  - attr(*, "total_size")= num 1240
[16:59:34.504] Packages to be attached in all futures: [n=0] 
[16:59:34.504] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.504] Number of futures (= number of chunks): 1
[16:59:34.504] Launching 1 futures (chunks) ...
[16:59:34.504] Chunk #1 of 1 ...
[16:59:34.504]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.504] getGlobalsAndPackages() ...
[16:59:34.504] Searching for globals...
[16:59:34.505] 
[16:59:34.505] Searching for globals ... DONE
[16:59:34.505] - globals: [0] <none>
[16:59:34.505] getGlobalsAndPackages() ... DONE
[16:59:34.505]    + additional globals found: [n=0] 
[16:59:34.505]    + additional namespaces needed: [n=0] 
[16:59:34.505]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.507]  - seeds: <none>
[16:59:34.507]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.507] getGlobalsAndPackages() ...
[16:59:34.508] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.508] Resolving globals: FALSE
[16:59:34.508] Tweak future expression to call with '...' arguments ...
[16:59:34.508] {
[16:59:34.508]     do.call(function(...) {
[16:59:34.508]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.508]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.508]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.508]             on.exit(options(oopts), add = TRUE)
[16:59:34.508]         }
[16:59:34.508]         {
[16:59:34.508]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.508]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.508]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.508]             })
[16:59:34.508]         }
[16:59:34.508]     }, args = future.call.arguments)
[16:59:34.508] }
[16:59:34.508] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.509] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.509] 
[16:59:34.509] getGlobalsAndPackages() ... DONE
[16:59:34.509] run() for ‘Future’ ...
[16:59:34.509] - state: ‘created’
[16:59:34.510] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.513] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.513] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.514]   - Field: ‘label’
[16:59:34.514]   - Field: ‘local’
[16:59:34.514]   - Field: ‘owner’
[16:59:34.514]   - Field: ‘envir’
[16:59:34.514]   - Field: ‘packages’
[16:59:34.514]   - Field: ‘gc’
[16:59:34.514]   - Field: ‘conditions’
[16:59:34.514]   - Field: ‘expr’
[16:59:34.514]   - Field: ‘uuid’
[16:59:34.514]   - Field: ‘seed’
[16:59:34.514]   - Field: ‘version’
[16:59:34.515]   - Field: ‘result’
[16:59:34.515]   - Field: ‘asynchronous’
[16:59:34.515]   - Field: ‘calls’
[16:59:34.515]   - Field: ‘globals’
[16:59:34.515]   - Field: ‘stdout’
[16:59:34.515]   - Field: ‘earlySignal’
[16:59:34.515]   - Field: ‘lazy’
[16:59:34.515]   - Field: ‘state’
[16:59:34.515] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.515] - Launch lazy future ...
[16:59:34.516] Packages needed by the future expression (n = 0): <none>
[16:59:34.516] Packages needed by future strategies (n = 0): <none>
[16:59:34.516] {
[16:59:34.516]     {
[16:59:34.516]         {
[16:59:34.516]             ...future.startTime <- base::Sys.time()
[16:59:34.516]             {
[16:59:34.516]                 {
[16:59:34.516]                   {
[16:59:34.516]                     base::local({
[16:59:34.516]                       has_future <- base::requireNamespace("future", 
[16:59:34.516]                         quietly = TRUE)
[16:59:34.516]                       if (has_future) {
[16:59:34.516]                         ns <- base::getNamespace("future")
[16:59:34.516]                         version <- ns[[".package"]][["version"]]
[16:59:34.516]                         if (is.null(version)) 
[16:59:34.516]                           version <- utils::packageVersion("future")
[16:59:34.516]                       }
[16:59:34.516]                       else {
[16:59:34.516]                         version <- NULL
[16:59:34.516]                       }
[16:59:34.516]                       if (!has_future || version < "1.8.0") {
[16:59:34.516]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.516]                           "", base::R.version$version.string), 
[16:59:34.516]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.516]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.516]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.516]                             "release", "version")], collapse = " "), 
[16:59:34.516]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.516]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.516]                           info)
[16:59:34.516]                         info <- base::paste(info, collapse = "; ")
[16:59:34.516]                         if (!has_future) {
[16:59:34.516]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.516]                             info)
[16:59:34.516]                         }
[16:59:34.516]                         else {
[16:59:34.516]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.516]                             info, version)
[16:59:34.516]                         }
[16:59:34.516]                         base::stop(msg)
[16:59:34.516]                       }
[16:59:34.516]                     })
[16:59:34.516]                   }
[16:59:34.516]                   ...future.strategy.old <- future::plan("list")
[16:59:34.516]                   options(future.plan = NULL)
[16:59:34.516]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.516]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.516]                 }
[16:59:34.516]                 ...future.workdir <- getwd()
[16:59:34.516]             }
[16:59:34.516]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.516]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.516]         }
[16:59:34.516]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.516]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.516]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.516]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.516]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.516]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.516]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.516]             base::names(...future.oldOptions))
[16:59:34.516]     }
[16:59:34.516]     if (FALSE) {
[16:59:34.516]     }
[16:59:34.516]     else {
[16:59:34.516]         if (TRUE) {
[16:59:34.516]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.516]                 open = "w")
[16:59:34.516]         }
[16:59:34.516]         else {
[16:59:34.516]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.516]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.516]         }
[16:59:34.516]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.516]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.516]             base::sink(type = "output", split = FALSE)
[16:59:34.516]             base::close(...future.stdout)
[16:59:34.516]         }, add = TRUE)
[16:59:34.516]     }
[16:59:34.516]     ...future.frame <- base::sys.nframe()
[16:59:34.516]     ...future.conditions <- base::list()
[16:59:34.516]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.516]     if (FALSE) {
[16:59:34.516]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.516]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.516]     }
[16:59:34.516]     ...future.result <- base::tryCatch({
[16:59:34.516]         base::withCallingHandlers({
[16:59:34.516]             ...future.value <- base::withVisible(base::local({
[16:59:34.516]                 do.call(function(...) {
[16:59:34.516]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.516]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.516]                     ...future.globals.maxSize)) {
[16:59:34.516]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.516]                     on.exit(options(oopts), add = TRUE)
[16:59:34.516]                   }
[16:59:34.516]                   {
[16:59:34.516]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.516]                       FUN = function(jj) {
[16:59:34.516]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.516]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.516]                       })
[16:59:34.516]                   }
[16:59:34.516]                 }, args = future.call.arguments)
[16:59:34.516]             }))
[16:59:34.516]             future::FutureResult(value = ...future.value$value, 
[16:59:34.516]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.516]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.516]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.516]                     ...future.globalenv.names))
[16:59:34.516]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.516]         }, condition = base::local({
[16:59:34.516]             c <- base::c
[16:59:34.516]             inherits <- base::inherits
[16:59:34.516]             invokeRestart <- base::invokeRestart
[16:59:34.516]             length <- base::length
[16:59:34.516]             list <- base::list
[16:59:34.516]             seq.int <- base::seq.int
[16:59:34.516]             signalCondition <- base::signalCondition
[16:59:34.516]             sys.calls <- base::sys.calls
[16:59:34.516]             `[[` <- base::`[[`
[16:59:34.516]             `+` <- base::`+`
[16:59:34.516]             `<<-` <- base::`<<-`
[16:59:34.516]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.516]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.516]                   3L)]
[16:59:34.516]             }
[16:59:34.516]             function(cond) {
[16:59:34.516]                 is_error <- inherits(cond, "error")
[16:59:34.516]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.516]                   NULL)
[16:59:34.516]                 if (is_error) {
[16:59:34.516]                   sessionInformation <- function() {
[16:59:34.516]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.516]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.516]                       search = base::search(), system = base::Sys.info())
[16:59:34.516]                   }
[16:59:34.516]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.516]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.516]                     cond$call), session = sessionInformation(), 
[16:59:34.516]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.516]                   signalCondition(cond)
[16:59:34.516]                 }
[16:59:34.516]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.516]                 "immediateCondition"))) {
[16:59:34.516]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.516]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.516]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.516]                   if (TRUE && !signal) {
[16:59:34.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.516]                     {
[16:59:34.516]                       inherits <- base::inherits
[16:59:34.516]                       invokeRestart <- base::invokeRestart
[16:59:34.516]                       is.null <- base::is.null
[16:59:34.516]                       muffled <- FALSE
[16:59:34.516]                       if (inherits(cond, "message")) {
[16:59:34.516]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.516]                         if (muffled) 
[16:59:34.516]                           invokeRestart("muffleMessage")
[16:59:34.516]                       }
[16:59:34.516]                       else if (inherits(cond, "warning")) {
[16:59:34.516]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.516]                         if (muffled) 
[16:59:34.516]                           invokeRestart("muffleWarning")
[16:59:34.516]                       }
[16:59:34.516]                       else if (inherits(cond, "condition")) {
[16:59:34.516]                         if (!is.null(pattern)) {
[16:59:34.516]                           computeRestarts <- base::computeRestarts
[16:59:34.516]                           grepl <- base::grepl
[16:59:34.516]                           restarts <- computeRestarts(cond)
[16:59:34.516]                           for (restart in restarts) {
[16:59:34.516]                             name <- restart$name
[16:59:34.516]                             if (is.null(name)) 
[16:59:34.516]                               next
[16:59:34.516]                             if (!grepl(pattern, name)) 
[16:59:34.516]                               next
[16:59:34.516]                             invokeRestart(restart)
[16:59:34.516]                             muffled <- TRUE
[16:59:34.516]                             break
[16:59:34.516]                           }
[16:59:34.516]                         }
[16:59:34.516]                       }
[16:59:34.516]                       invisible(muffled)
[16:59:34.516]                     }
[16:59:34.516]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.516]                   }
[16:59:34.516]                 }
[16:59:34.516]                 else {
[16:59:34.516]                   if (TRUE) {
[16:59:34.516]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.516]                     {
[16:59:34.516]                       inherits <- base::inherits
[16:59:34.516]                       invokeRestart <- base::invokeRestart
[16:59:34.516]                       is.null <- base::is.null
[16:59:34.516]                       muffled <- FALSE
[16:59:34.516]                       if (inherits(cond, "message")) {
[16:59:34.516]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.516]                         if (muffled) 
[16:59:34.516]                           invokeRestart("muffleMessage")
[16:59:34.516]                       }
[16:59:34.516]                       else if (inherits(cond, "warning")) {
[16:59:34.516]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.516]                         if (muffled) 
[16:59:34.516]                           invokeRestart("muffleWarning")
[16:59:34.516]                       }
[16:59:34.516]                       else if (inherits(cond, "condition")) {
[16:59:34.516]                         if (!is.null(pattern)) {
[16:59:34.516]                           computeRestarts <- base::computeRestarts
[16:59:34.516]                           grepl <- base::grepl
[16:59:34.516]                           restarts <- computeRestarts(cond)
[16:59:34.516]                           for (restart in restarts) {
[16:59:34.516]                             name <- restart$name
[16:59:34.516]                             if (is.null(name)) 
[16:59:34.516]                               next
[16:59:34.516]                             if (!grepl(pattern, name)) 
[16:59:34.516]                               next
[16:59:34.516]                             invokeRestart(restart)
[16:59:34.516]                             muffled <- TRUE
[16:59:34.516]                             break
[16:59:34.516]                           }
[16:59:34.516]                         }
[16:59:34.516]                       }
[16:59:34.516]                       invisible(muffled)
[16:59:34.516]                     }
[16:59:34.516]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.516]                   }
[16:59:34.516]                 }
[16:59:34.516]             }
[16:59:34.516]         }))
[16:59:34.516]     }, error = function(ex) {
[16:59:34.516]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.516]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.516]                 ...future.rng), started = ...future.startTime, 
[16:59:34.516]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.516]             version = "1.8"), class = "FutureResult")
[16:59:34.516]     }, finally = {
[16:59:34.516]         if (!identical(...future.workdir, getwd())) 
[16:59:34.516]             setwd(...future.workdir)
[16:59:34.516]         {
[16:59:34.516]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.516]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.516]             }
[16:59:34.516]             base::options(...future.oldOptions)
[16:59:34.516]             if (.Platform$OS.type == "windows") {
[16:59:34.516]                 old_names <- names(...future.oldEnvVars)
[16:59:34.516]                 envs <- base::Sys.getenv()
[16:59:34.516]                 names <- names(envs)
[16:59:34.516]                 common <- intersect(names, old_names)
[16:59:34.516]                 added <- setdiff(names, old_names)
[16:59:34.516]                 removed <- setdiff(old_names, names)
[16:59:34.516]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.516]                   envs[common]]
[16:59:34.516]                 NAMES <- toupper(changed)
[16:59:34.516]                 args <- list()
[16:59:34.516]                 for (kk in seq_along(NAMES)) {
[16:59:34.516]                   name <- changed[[kk]]
[16:59:34.516]                   NAME <- NAMES[[kk]]
[16:59:34.516]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.516]                     next
[16:59:34.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.516]                 }
[16:59:34.516]                 NAMES <- toupper(added)
[16:59:34.516]                 for (kk in seq_along(NAMES)) {
[16:59:34.516]                   name <- added[[kk]]
[16:59:34.516]                   NAME <- NAMES[[kk]]
[16:59:34.516]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.516]                     next
[16:59:34.516]                   args[[name]] <- ""
[16:59:34.516]                 }
[16:59:34.516]                 NAMES <- toupper(removed)
[16:59:34.516]                 for (kk in seq_along(NAMES)) {
[16:59:34.516]                   name <- removed[[kk]]
[16:59:34.516]                   NAME <- NAMES[[kk]]
[16:59:34.516]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.516]                     next
[16:59:34.516]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.516]                 }
[16:59:34.516]                 if (length(args) > 0) 
[16:59:34.516]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.516]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.516]             }
[16:59:34.516]             else {
[16:59:34.516]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.516]             }
[16:59:34.516]             {
[16:59:34.516]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.516]                   0L) {
[16:59:34.516]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.516]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.516]                   base::options(opts)
[16:59:34.516]                 }
[16:59:34.516]                 {
[16:59:34.516]                   {
[16:59:34.516]                     NULL
[16:59:34.516]                     RNGkind("Mersenne-Twister")
[16:59:34.516]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.516]                       inherits = FALSE)
[16:59:34.516]                   }
[16:59:34.516]                   options(future.plan = NULL)
[16:59:34.516]                   if (is.na(NA_character_)) 
[16:59:34.516]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.516]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.516]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.516]                     .init = FALSE)
[16:59:34.516]                 }
[16:59:34.516]             }
[16:59:34.516]         }
[16:59:34.516]     })
[16:59:34.516]     if (TRUE) {
[16:59:34.516]         base::sink(type = "output", split = FALSE)
[16:59:34.516]         if (TRUE) {
[16:59:34.516]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.516]         }
[16:59:34.516]         else {
[16:59:34.516]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.516]         }
[16:59:34.516]         base::close(...future.stdout)
[16:59:34.516]         ...future.stdout <- NULL
[16:59:34.516]     }
[16:59:34.516]     ...future.result$conditions <- ...future.conditions
[16:59:34.516]     ...future.result$finished <- base::Sys.time()
[16:59:34.516]     ...future.result
[16:59:34.516] }
[16:59:34.518] assign_globals() ...
[16:59:34.518] List of 5
[16:59:34.518]  $ ...future.FUN            :function (object, ...)  
[16:59:34.518]  $ future.call.arguments    : list()
[16:59:34.518]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.518]  $ ...future.elements_ii    :List of 3
[16:59:34.518]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.518]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.518]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.518]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.518]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.518]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.518]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.518]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.518]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.518]  $ ...future.seeds_ii       : NULL
[16:59:34.518]  $ ...future.globals.maxSize: NULL
[16:59:34.518]  - attr(*, "where")=List of 5
[16:59:34.518]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.518]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.518]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.518]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.518]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.518]  - attr(*, "resolved")= logi FALSE
[16:59:34.518]  - attr(*, "total_size")= num 1240
[16:59:34.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.518]  - attr(*, "already-done")= logi TRUE
[16:59:34.525] - copied ‘...future.FUN’ to environment
[16:59:34.525] - copied ‘future.call.arguments’ to environment
[16:59:34.526] - copied ‘...future.elements_ii’ to environment
[16:59:34.526] - copied ‘...future.seeds_ii’ to environment
[16:59:34.526] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.526] assign_globals() ... done
[16:59:34.526] plan(): Setting new future strategy stack:
[16:59:34.526] List of future strategies:
[16:59:34.526] 1. sequential:
[16:59:34.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.526]    - tweaked: FALSE
[16:59:34.526]    - call: NULL
[16:59:34.527] plan(): nbrOfWorkers() = 1
[16:59:34.529] plan(): Setting new future strategy stack:
[16:59:34.529] List of future strategies:
[16:59:34.529] 1. multisession:
[16:59:34.529]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.529]    - tweaked: FALSE
[16:59:34.529]    - call: plan(strategy)
[16:59:34.532] plan(): nbrOfWorkers() = 1
[16:59:34.532] SequentialFuture started (and completed)
[16:59:34.533] - Launch lazy future ... done
[16:59:34.533] run() for ‘SequentialFuture’ ... done
[16:59:34.533] Created future:
[16:59:34.533] SequentialFuture:
[16:59:34.533] Label: ‘future_by-1’
[16:59:34.533] Expression:
[16:59:34.533] {
[16:59:34.533]     do.call(function(...) {
[16:59:34.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.533]             on.exit(options(oopts), add = TRUE)
[16:59:34.533]         }
[16:59:34.533]         {
[16:59:34.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.533]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.533]             })
[16:59:34.533]         }
[16:59:34.533]     }, args = future.call.arguments)
[16:59:34.533] }
[16:59:34.533] Lazy evaluation: FALSE
[16:59:34.533] Asynchronous evaluation: FALSE
[16:59:34.533] Local evaluation: TRUE
[16:59:34.533] Environment: R_GlobalEnv
[16:59:34.533] Capture standard output: TRUE
[16:59:34.533] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.533] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.533] Packages: <none>
[16:59:34.533] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.533] Resolved: TRUE
[16:59:34.533] Value: 4.62 KiB of class ‘list’
[16:59:34.533] Early signaling: FALSE
[16:59:34.533] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.533] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.534] Chunk #1 of 1 ... DONE
[16:59:34.534] Launching 1 futures (chunks) ... DONE
[16:59:34.534] Resolving 1 futures (chunks) ...
[16:59:34.534] resolve() on list ...
[16:59:34.534]  recursive: 0
[16:59:34.535]  length: 1
[16:59:34.535] 
[16:59:34.535] resolved() for ‘SequentialFuture’ ...
[16:59:34.535] - state: ‘finished’
[16:59:34.535] - run: TRUE
[16:59:34.535] - result: ‘FutureResult’
[16:59:34.535] resolved() for ‘SequentialFuture’ ... done
[16:59:34.535] Future #1
[16:59:34.535] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.535] - nx: 1
[16:59:34.536] - relay: TRUE
[16:59:34.537] - stdout: TRUE
[16:59:34.537] - signal: TRUE
[16:59:34.537] - resignal: FALSE
[16:59:34.537] - force: TRUE
[16:59:34.538] - relayed: [n=1] FALSE
[16:59:34.538] - queued futures: [n=1] FALSE
[16:59:34.538]  - until=1
[16:59:34.538]  - relaying element #1
[16:59:34.538] - relayed: [n=1] TRUE
[16:59:34.538] - queued futures: [n=1] TRUE
[16:59:34.538] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.539]  length: 0 (resolved future 1)
[16:59:34.539] Relaying remaining futures
[16:59:34.539] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.539] - nx: 1
[16:59:34.539] - relay: TRUE
[16:59:34.539] - stdout: TRUE
[16:59:34.539] - signal: TRUE
[16:59:34.539] - resignal: FALSE
[16:59:34.539] - force: TRUE
[16:59:34.539] - relayed: [n=1] TRUE
[16:59:34.540] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.540] - relayed: [n=1] TRUE
[16:59:34.540] - queued futures: [n=1] TRUE
[16:59:34.540] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.540] resolve() on list ... DONE
[16:59:34.540]  - Number of value chunks collected: 1
[16:59:34.540] Resolving 1 futures (chunks) ... DONE
[16:59:34.540] Reducing values from 1 chunks ...
[16:59:34.540]  - Number of values collected after concatenation: 3
[16:59:34.541]  - Number of values expected: 3
[16:59:34.541] Reducing values from 1 chunks ... DONE
[16:59:34.541] future_lapply() ... DONE
[16:59:34.541] future_by_internal() ... DONE
[16:59:34.541] future_by_internal() ...
[16:59:34.541] future_lapply() ...
[16:59:34.545] Number of chunks: 1
[16:59:34.545] getGlobalsAndPackagesXApply() ...
[16:59:34.545]  - future.globals: TRUE
[16:59:34.545] getGlobalsAndPackages() ...
[16:59:34.546] Searching for globals...
[16:59:34.547] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.547] Searching for globals ... DONE
[16:59:34.547] Resolving globals: FALSE
[16:59:34.547] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.548] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.548] - globals: [1] ‘FUN’
[16:59:34.548] 
[16:59:34.548] getGlobalsAndPackages() ... DONE
[16:59:34.548]  - globals found/used: [n=1] ‘FUN’
[16:59:34.548]  - needed namespaces: [n=0] 
[16:59:34.548] Finding globals ... DONE
[16:59:34.548]  - use_args: TRUE
[16:59:34.548]  - Getting '...' globals ...
[16:59:34.549] resolve() on list ...
[16:59:34.549]  recursive: 0
[16:59:34.549]  length: 1
[16:59:34.549]  elements: ‘...’
[16:59:34.549]  length: 0 (resolved future 1)
[16:59:34.549] resolve() on list ... DONE
[16:59:34.549]    - '...' content: [n=1] ‘digits’
[16:59:34.549] List of 1
[16:59:34.549]  $ ...:List of 1
[16:59:34.549]   ..$ digits: int 2
[16:59:34.549]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.549]  - attr(*, "where")=List of 1
[16:59:34.549]   ..$ ...:<environment: 0x562051c88560> 
[16:59:34.549]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.549]  - attr(*, "resolved")= logi TRUE
[16:59:34.549]  - attr(*, "total_size")= num NA
[16:59:34.552]  - Getting '...' globals ... DONE
[16:59:34.553] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.553] List of 2
[16:59:34.553]  $ ...future.FUN:function (object, ...)  
[16:59:34.553]  $ ...          :List of 1
[16:59:34.553]   ..$ digits: int 2
[16:59:34.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.553]  - attr(*, "where")=List of 2
[16:59:34.553]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.553]   ..$ ...          :<environment: 0x562051c88560> 
[16:59:34.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.553]  - attr(*, "resolved")= logi FALSE
[16:59:34.553]  - attr(*, "total_size")= num 1296
[16:59:34.556] Packages to be attached in all futures: [n=0] 
[16:59:34.556] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.556] Number of futures (= number of chunks): 1
[16:59:34.556] Launching 1 futures (chunks) ...
[16:59:34.556] Chunk #1 of 1 ...
[16:59:34.556]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.556] getGlobalsAndPackages() ...
[16:59:34.556] Searching for globals...
[16:59:34.557] 
[16:59:34.557] Searching for globals ... DONE
[16:59:34.557] - globals: [0] <none>
[16:59:34.557] getGlobalsAndPackages() ... DONE
[16:59:34.557]    + additional globals found: [n=0] 
[16:59:34.557]    + additional namespaces needed: [n=0] 
[16:59:34.557]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.557]  - seeds: <none>
[16:59:34.557]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.558] getGlobalsAndPackages() ...
[16:59:34.558] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.558] Resolving globals: FALSE
[16:59:34.558] Tweak future expression to call with '...' arguments ...
[16:59:34.558] {
[16:59:34.558]     do.call(function(...) {
[16:59:34.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.558]             on.exit(options(oopts), add = TRUE)
[16:59:34.558]         }
[16:59:34.558]         {
[16:59:34.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.558]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.558]             })
[16:59:34.558]         }
[16:59:34.558]     }, args = future.call.arguments)
[16:59:34.558] }
[16:59:34.558] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.559] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.559] 
[16:59:34.559] getGlobalsAndPackages() ... DONE
[16:59:34.559] run() for ‘Future’ ...
[16:59:34.559] - state: ‘created’
[16:59:34.559] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.563] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.563]   - Field: ‘label’
[16:59:34.563]   - Field: ‘local’
[16:59:34.563]   - Field: ‘owner’
[16:59:34.563]   - Field: ‘envir’
[16:59:34.564]   - Field: ‘packages’
[16:59:34.564]   - Field: ‘gc’
[16:59:34.565]   - Field: ‘conditions’
[16:59:34.566]   - Field: ‘expr’
[16:59:34.566]   - Field: ‘uuid’
[16:59:34.566]   - Field: ‘seed’
[16:59:34.566]   - Field: ‘version’
[16:59:34.566]   - Field: ‘result’
[16:59:34.566]   - Field: ‘asynchronous’
[16:59:34.566]   - Field: ‘calls’
[16:59:34.566]   - Field: ‘globals’
[16:59:34.566]   - Field: ‘stdout’
[16:59:34.567]   - Field: ‘earlySignal’
[16:59:34.567]   - Field: ‘lazy’
[16:59:34.567]   - Field: ‘state’
[16:59:34.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.567] - Launch lazy future ...
[16:59:34.567] Packages needed by the future expression (n = 0): <none>
[16:59:34.567] Packages needed by future strategies (n = 0): <none>
[16:59:34.568] {
[16:59:34.568]     {
[16:59:34.568]         {
[16:59:34.568]             ...future.startTime <- base::Sys.time()
[16:59:34.568]             {
[16:59:34.568]                 {
[16:59:34.568]                   {
[16:59:34.568]                     base::local({
[16:59:34.568]                       has_future <- base::requireNamespace("future", 
[16:59:34.568]                         quietly = TRUE)
[16:59:34.568]                       if (has_future) {
[16:59:34.568]                         ns <- base::getNamespace("future")
[16:59:34.568]                         version <- ns[[".package"]][["version"]]
[16:59:34.568]                         if (is.null(version)) 
[16:59:34.568]                           version <- utils::packageVersion("future")
[16:59:34.568]                       }
[16:59:34.568]                       else {
[16:59:34.568]                         version <- NULL
[16:59:34.568]                       }
[16:59:34.568]                       if (!has_future || version < "1.8.0") {
[16:59:34.568]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.568]                           "", base::R.version$version.string), 
[16:59:34.568]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.568]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.568]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.568]                             "release", "version")], collapse = " "), 
[16:59:34.568]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.568]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.568]                           info)
[16:59:34.568]                         info <- base::paste(info, collapse = "; ")
[16:59:34.568]                         if (!has_future) {
[16:59:34.568]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.568]                             info)
[16:59:34.568]                         }
[16:59:34.568]                         else {
[16:59:34.568]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.568]                             info, version)
[16:59:34.568]                         }
[16:59:34.568]                         base::stop(msg)
[16:59:34.568]                       }
[16:59:34.568]                     })
[16:59:34.568]                   }
[16:59:34.568]                   ...future.strategy.old <- future::plan("list")
[16:59:34.568]                   options(future.plan = NULL)
[16:59:34.568]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.568]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.568]                 }
[16:59:34.568]                 ...future.workdir <- getwd()
[16:59:34.568]             }
[16:59:34.568]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.568]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.568]         }
[16:59:34.568]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.568]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.568]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.568]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.568]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.568]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.568]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.568]             base::names(...future.oldOptions))
[16:59:34.568]     }
[16:59:34.568]     if (FALSE) {
[16:59:34.568]     }
[16:59:34.568]     else {
[16:59:34.568]         if (TRUE) {
[16:59:34.568]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.568]                 open = "w")
[16:59:34.568]         }
[16:59:34.568]         else {
[16:59:34.568]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.568]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.568]         }
[16:59:34.568]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.568]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.568]             base::sink(type = "output", split = FALSE)
[16:59:34.568]             base::close(...future.stdout)
[16:59:34.568]         }, add = TRUE)
[16:59:34.568]     }
[16:59:34.568]     ...future.frame <- base::sys.nframe()
[16:59:34.568]     ...future.conditions <- base::list()
[16:59:34.568]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.568]     if (FALSE) {
[16:59:34.568]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.568]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.568]     }
[16:59:34.568]     ...future.result <- base::tryCatch({
[16:59:34.568]         base::withCallingHandlers({
[16:59:34.568]             ...future.value <- base::withVisible(base::local({
[16:59:34.568]                 do.call(function(...) {
[16:59:34.568]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.568]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.568]                     ...future.globals.maxSize)) {
[16:59:34.568]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.568]                     on.exit(options(oopts), add = TRUE)
[16:59:34.568]                   }
[16:59:34.568]                   {
[16:59:34.568]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.568]                       FUN = function(jj) {
[16:59:34.568]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.568]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.568]                       })
[16:59:34.568]                   }
[16:59:34.568]                 }, args = future.call.arguments)
[16:59:34.568]             }))
[16:59:34.568]             future::FutureResult(value = ...future.value$value, 
[16:59:34.568]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.568]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.568]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.568]                     ...future.globalenv.names))
[16:59:34.568]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.568]         }, condition = base::local({
[16:59:34.568]             c <- base::c
[16:59:34.568]             inherits <- base::inherits
[16:59:34.568]             invokeRestart <- base::invokeRestart
[16:59:34.568]             length <- base::length
[16:59:34.568]             list <- base::list
[16:59:34.568]             seq.int <- base::seq.int
[16:59:34.568]             signalCondition <- base::signalCondition
[16:59:34.568]             sys.calls <- base::sys.calls
[16:59:34.568]             `[[` <- base::`[[`
[16:59:34.568]             `+` <- base::`+`
[16:59:34.568]             `<<-` <- base::`<<-`
[16:59:34.568]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.568]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.568]                   3L)]
[16:59:34.568]             }
[16:59:34.568]             function(cond) {
[16:59:34.568]                 is_error <- inherits(cond, "error")
[16:59:34.568]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.568]                   NULL)
[16:59:34.568]                 if (is_error) {
[16:59:34.568]                   sessionInformation <- function() {
[16:59:34.568]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.568]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.568]                       search = base::search(), system = base::Sys.info())
[16:59:34.568]                   }
[16:59:34.568]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.568]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.568]                     cond$call), session = sessionInformation(), 
[16:59:34.568]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.568]                   signalCondition(cond)
[16:59:34.568]                 }
[16:59:34.568]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.568]                 "immediateCondition"))) {
[16:59:34.568]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.568]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.568]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.568]                   if (TRUE && !signal) {
[16:59:34.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.568]                     {
[16:59:34.568]                       inherits <- base::inherits
[16:59:34.568]                       invokeRestart <- base::invokeRestart
[16:59:34.568]                       is.null <- base::is.null
[16:59:34.568]                       muffled <- FALSE
[16:59:34.568]                       if (inherits(cond, "message")) {
[16:59:34.568]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.568]                         if (muffled) 
[16:59:34.568]                           invokeRestart("muffleMessage")
[16:59:34.568]                       }
[16:59:34.568]                       else if (inherits(cond, "warning")) {
[16:59:34.568]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.568]                         if (muffled) 
[16:59:34.568]                           invokeRestart("muffleWarning")
[16:59:34.568]                       }
[16:59:34.568]                       else if (inherits(cond, "condition")) {
[16:59:34.568]                         if (!is.null(pattern)) {
[16:59:34.568]                           computeRestarts <- base::computeRestarts
[16:59:34.568]                           grepl <- base::grepl
[16:59:34.568]                           restarts <- computeRestarts(cond)
[16:59:34.568]                           for (restart in restarts) {
[16:59:34.568]                             name <- restart$name
[16:59:34.568]                             if (is.null(name)) 
[16:59:34.568]                               next
[16:59:34.568]                             if (!grepl(pattern, name)) 
[16:59:34.568]                               next
[16:59:34.568]                             invokeRestart(restart)
[16:59:34.568]                             muffled <- TRUE
[16:59:34.568]                             break
[16:59:34.568]                           }
[16:59:34.568]                         }
[16:59:34.568]                       }
[16:59:34.568]                       invisible(muffled)
[16:59:34.568]                     }
[16:59:34.568]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.568]                   }
[16:59:34.568]                 }
[16:59:34.568]                 else {
[16:59:34.568]                   if (TRUE) {
[16:59:34.568]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.568]                     {
[16:59:34.568]                       inherits <- base::inherits
[16:59:34.568]                       invokeRestart <- base::invokeRestart
[16:59:34.568]                       is.null <- base::is.null
[16:59:34.568]                       muffled <- FALSE
[16:59:34.568]                       if (inherits(cond, "message")) {
[16:59:34.568]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.568]                         if (muffled) 
[16:59:34.568]                           invokeRestart("muffleMessage")
[16:59:34.568]                       }
[16:59:34.568]                       else if (inherits(cond, "warning")) {
[16:59:34.568]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.568]                         if (muffled) 
[16:59:34.568]                           invokeRestart("muffleWarning")
[16:59:34.568]                       }
[16:59:34.568]                       else if (inherits(cond, "condition")) {
[16:59:34.568]                         if (!is.null(pattern)) {
[16:59:34.568]                           computeRestarts <- base::computeRestarts
[16:59:34.568]                           grepl <- base::grepl
[16:59:34.568]                           restarts <- computeRestarts(cond)
[16:59:34.568]                           for (restart in restarts) {
[16:59:34.568]                             name <- restart$name
[16:59:34.568]                             if (is.null(name)) 
[16:59:34.568]                               next
[16:59:34.568]                             if (!grepl(pattern, name)) 
[16:59:34.568]                               next
[16:59:34.568]                             invokeRestart(restart)
[16:59:34.568]                             muffled <- TRUE
[16:59:34.568]                             break
[16:59:34.568]                           }
[16:59:34.568]                         }
[16:59:34.568]                       }
[16:59:34.568]                       invisible(muffled)
[16:59:34.568]                     }
[16:59:34.568]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.568]                   }
[16:59:34.568]                 }
[16:59:34.568]             }
[16:59:34.568]         }))
[16:59:34.568]     }, error = function(ex) {
[16:59:34.568]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.568]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.568]                 ...future.rng), started = ...future.startTime, 
[16:59:34.568]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.568]             version = "1.8"), class = "FutureResult")
[16:59:34.568]     }, finally = {
[16:59:34.568]         if (!identical(...future.workdir, getwd())) 
[16:59:34.568]             setwd(...future.workdir)
[16:59:34.568]         {
[16:59:34.568]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.568]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.568]             }
[16:59:34.568]             base::options(...future.oldOptions)
[16:59:34.568]             if (.Platform$OS.type == "windows") {
[16:59:34.568]                 old_names <- names(...future.oldEnvVars)
[16:59:34.568]                 envs <- base::Sys.getenv()
[16:59:34.568]                 names <- names(envs)
[16:59:34.568]                 common <- intersect(names, old_names)
[16:59:34.568]                 added <- setdiff(names, old_names)
[16:59:34.568]                 removed <- setdiff(old_names, names)
[16:59:34.568]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.568]                   envs[common]]
[16:59:34.568]                 NAMES <- toupper(changed)
[16:59:34.568]                 args <- list()
[16:59:34.568]                 for (kk in seq_along(NAMES)) {
[16:59:34.568]                   name <- changed[[kk]]
[16:59:34.568]                   NAME <- NAMES[[kk]]
[16:59:34.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.568]                     next
[16:59:34.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.568]                 }
[16:59:34.568]                 NAMES <- toupper(added)
[16:59:34.568]                 for (kk in seq_along(NAMES)) {
[16:59:34.568]                   name <- added[[kk]]
[16:59:34.568]                   NAME <- NAMES[[kk]]
[16:59:34.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.568]                     next
[16:59:34.568]                   args[[name]] <- ""
[16:59:34.568]                 }
[16:59:34.568]                 NAMES <- toupper(removed)
[16:59:34.568]                 for (kk in seq_along(NAMES)) {
[16:59:34.568]                   name <- removed[[kk]]
[16:59:34.568]                   NAME <- NAMES[[kk]]
[16:59:34.568]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.568]                     next
[16:59:34.568]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.568]                 }
[16:59:34.568]                 if (length(args) > 0) 
[16:59:34.568]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.568]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.568]             }
[16:59:34.568]             else {
[16:59:34.568]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.568]             }
[16:59:34.568]             {
[16:59:34.568]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.568]                   0L) {
[16:59:34.568]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.568]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.568]                   base::options(opts)
[16:59:34.568]                 }
[16:59:34.568]                 {
[16:59:34.568]                   {
[16:59:34.568]                     NULL
[16:59:34.568]                     RNGkind("Mersenne-Twister")
[16:59:34.568]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.568]                       inherits = FALSE)
[16:59:34.568]                   }
[16:59:34.568]                   options(future.plan = NULL)
[16:59:34.568]                   if (is.na(NA_character_)) 
[16:59:34.568]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.568]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.568]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.568]                     .init = FALSE)
[16:59:34.568]                 }
[16:59:34.568]             }
[16:59:34.568]         }
[16:59:34.568]     })
[16:59:34.568]     if (TRUE) {
[16:59:34.568]         base::sink(type = "output", split = FALSE)
[16:59:34.568]         if (TRUE) {
[16:59:34.568]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.568]         }
[16:59:34.568]         else {
[16:59:34.568]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.568]         }
[16:59:34.568]         base::close(...future.stdout)
[16:59:34.568]         ...future.stdout <- NULL
[16:59:34.568]     }
[16:59:34.568]     ...future.result$conditions <- ...future.conditions
[16:59:34.568]     ...future.result$finished <- base::Sys.time()
[16:59:34.568]     ...future.result
[16:59:34.568] }
[16:59:34.570] assign_globals() ...
[16:59:34.570] List of 5
[16:59:34.570]  $ ...future.FUN            :function (object, ...)  
[16:59:34.570]  $ future.call.arguments    :List of 1
[16:59:34.570]   ..$ digits: int 2
[16:59:34.570]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.570]  $ ...future.elements_ii    :List of 6
[16:59:34.570]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:59:34.570]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:59:34.570]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:59:34.570]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:59:34.570]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:59:34.570]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:59:34.570]  $ ...future.seeds_ii       : NULL
[16:59:34.570]  $ ...future.globals.maxSize: NULL
[16:59:34.570]  - attr(*, "where")=List of 5
[16:59:34.570]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.570]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.570]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.570]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.570]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.570]  - attr(*, "resolved")= logi FALSE
[16:59:34.570]  - attr(*, "total_size")= num 1296
[16:59:34.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.570]  - attr(*, "already-done")= logi TRUE
[16:59:34.577] - copied ‘...future.FUN’ to environment
[16:59:34.577] - copied ‘future.call.arguments’ to environment
[16:59:34.577] - copied ‘...future.elements_ii’ to environment
[16:59:34.577] - copied ‘...future.seeds_ii’ to environment
[16:59:34.577] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.577] assign_globals() ... done
[16:59:34.577] plan(): Setting new future strategy stack:
[16:59:34.577] List of future strategies:
[16:59:34.577] 1. sequential:
[16:59:34.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.577]    - tweaked: FALSE
[16:59:34.577]    - call: NULL
[16:59:34.578] plan(): nbrOfWorkers() = 1
[16:59:34.579] plan(): Setting new future strategy stack:
[16:59:34.579] List of future strategies:
[16:59:34.579] 1. multisession:
[16:59:34.579]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.579]    - tweaked: FALSE
[16:59:34.579]    - call: plan(strategy)
[16:59:34.583] plan(): nbrOfWorkers() = 1
[16:59:34.583] SequentialFuture started (and completed)
[16:59:34.583] - Launch lazy future ... done
[16:59:34.583] run() for ‘SequentialFuture’ ... done
[16:59:34.583] Created future:
[16:59:34.584] SequentialFuture:
[16:59:34.584] Label: ‘future_by-1’
[16:59:34.584] Expression:
[16:59:34.584] {
[16:59:34.584]     do.call(function(...) {
[16:59:34.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.584]             on.exit(options(oopts), add = TRUE)
[16:59:34.584]         }
[16:59:34.584]         {
[16:59:34.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.584]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.584]             })
[16:59:34.584]         }
[16:59:34.584]     }, args = future.call.arguments)
[16:59:34.584] }
[16:59:34.584] Lazy evaluation: FALSE
[16:59:34.584] Asynchronous evaluation: FALSE
[16:59:34.584] Local evaluation: TRUE
[16:59:34.584] Environment: R_GlobalEnv
[16:59:34.584] Capture standard output: TRUE
[16:59:34.584] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.584] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.584] Packages: <none>
[16:59:34.584] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.584] Resolved: TRUE
[16:59:34.584] Value: 5.48 KiB of class ‘list’
[16:59:34.584] Early signaling: FALSE
[16:59:34.584] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.584] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.585] Chunk #1 of 1 ... DONE
[16:59:34.585] Launching 1 futures (chunks) ... DONE
[16:59:34.585] Resolving 1 futures (chunks) ...
[16:59:34.585] resolve() on list ...
[16:59:34.585]  recursive: 0
[16:59:34.585]  length: 1
[16:59:34.585] 
[16:59:34.585] resolved() for ‘SequentialFuture’ ...
[16:59:34.585] - state: ‘finished’
[16:59:34.586] - run: TRUE
[16:59:34.586] - result: ‘FutureResult’
[16:59:34.586] resolved() for ‘SequentialFuture’ ... done
[16:59:34.586] Future #1
[16:59:34.586] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.586] - nx: 1
[16:59:34.586] - relay: TRUE
[16:59:34.586] - stdout: TRUE
[16:59:34.586] - signal: TRUE
[16:59:34.586] - resignal: FALSE
[16:59:34.586] - force: TRUE
[16:59:34.587] - relayed: [n=1] FALSE
[16:59:34.587] - queued futures: [n=1] FALSE
[16:59:34.587]  - until=1
[16:59:34.587]  - relaying element #1
[16:59:34.587] - relayed: [n=1] TRUE
[16:59:34.587] - queued futures: [n=1] TRUE
[16:59:34.587] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.587]  length: 0 (resolved future 1)
[16:59:34.587] Relaying remaining futures
[16:59:34.587] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.588] - nx: 1
[16:59:34.588] - relay: TRUE
[16:59:34.588] - stdout: TRUE
[16:59:34.588] - signal: TRUE
[16:59:34.588] - resignal: FALSE
[16:59:34.588] - force: TRUE
[16:59:34.588] - relayed: [n=1] TRUE
[16:59:34.588] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.588] - relayed: [n=1] TRUE
[16:59:34.588] - queued futures: [n=1] TRUE
[16:59:34.588] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.589] resolve() on list ... DONE
[16:59:34.589]  - Number of value chunks collected: 1
[16:59:34.589] Resolving 1 futures (chunks) ... DONE
[16:59:34.589] Reducing values from 1 chunks ...
[16:59:34.589]  - Number of values collected after concatenation: 6
[16:59:34.589]  - Number of values expected: 6
[16:59:34.589] Reducing values from 1 chunks ... DONE
[16:59:34.589] future_lapply() ... DONE
[16:59:34.589] future_by_internal() ... DONE
[16:59:34.590] future_by_internal() ...
[16:59:34.592] future_lapply() ...
[16:59:34.597] Number of chunks: 1
[16:59:34.597] getGlobalsAndPackagesXApply() ...
[16:59:34.597]  - future.globals: TRUE
[16:59:34.597] getGlobalsAndPackages() ...
[16:59:34.597] Searching for globals...
[16:59:34.599] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:34.599] Searching for globals ... DONE
[16:59:34.599] Resolving globals: FALSE
[16:59:34.600] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:59:34.600] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:59:34.600] - globals: [1] ‘FUN’
[16:59:34.600] - packages: [1] ‘stats’
[16:59:34.600] getGlobalsAndPackages() ... DONE
[16:59:34.600]  - globals found/used: [n=1] ‘FUN’
[16:59:34.601]  - needed namespaces: [n=1] ‘stats’
[16:59:34.601] Finding globals ... DONE
[16:59:34.601]  - use_args: TRUE
[16:59:34.601]  - Getting '...' globals ...
[16:59:34.601] resolve() on list ...
[16:59:34.601]  recursive: 0
[16:59:34.601]  length: 1
[16:59:34.601]  elements: ‘...’
[16:59:34.602]  length: 0 (resolved future 1)
[16:59:34.602] resolve() on list ... DONE
[16:59:34.602]    - '...' content: [n=1] ‘singular.ok’
[16:59:34.602] List of 1
[16:59:34.602]  $ ...:List of 1
[16:59:34.602]   ..$ singular.ok: logi FALSE
[16:59:34.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.602]  - attr(*, "where")=List of 1
[16:59:34.602]   ..$ ...:<environment: 0x562052a35498> 
[16:59:34.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.602]  - attr(*, "resolved")= logi TRUE
[16:59:34.602]  - attr(*, "total_size")= num NA
[16:59:34.605]  - Getting '...' globals ... DONE
[16:59:34.605] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.605] List of 2
[16:59:34.605]  $ ...future.FUN:function (x, ...)  
[16:59:34.605]  $ ...          :List of 1
[16:59:34.605]   ..$ singular.ok: logi FALSE
[16:59:34.605]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.605]  - attr(*, "where")=List of 2
[16:59:34.605]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.605]   ..$ ...          :<environment: 0x562052a35498> 
[16:59:34.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.605]  - attr(*, "resolved")= logi FALSE
[16:59:34.605]  - attr(*, "total_size")= num 5384
[16:59:34.608] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:34.608] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.608] Number of futures (= number of chunks): 1
[16:59:34.609] Launching 1 futures (chunks) ...
[16:59:34.609] Chunk #1 of 1 ...
[16:59:34.609]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.609] getGlobalsAndPackages() ...
[16:59:34.609] Searching for globals...
[16:59:34.609] 
[16:59:34.610] Searching for globals ... DONE
[16:59:34.610] - globals: [0] <none>
[16:59:34.610] getGlobalsAndPackages() ... DONE
[16:59:34.610]    + additional globals found: [n=0] 
[16:59:34.610]    + additional namespaces needed: [n=0] 
[16:59:34.610]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.610]  - seeds: <none>
[16:59:34.610]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.610] getGlobalsAndPackages() ...
[16:59:34.610] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.610] Resolving globals: FALSE
[16:59:34.611] Tweak future expression to call with '...' arguments ...
[16:59:34.611] {
[16:59:34.611]     do.call(function(...) {
[16:59:34.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.611]             on.exit(options(oopts), add = TRUE)
[16:59:34.611]         }
[16:59:34.611]         {
[16:59:34.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.611]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.611]             })
[16:59:34.611]         }
[16:59:34.611]     }, args = future.call.arguments)
[16:59:34.611] }
[16:59:34.611] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.611] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.611] 
[16:59:34.612] getGlobalsAndPackages() ... DONE
[16:59:34.612] run() for ‘Future’ ...
[16:59:34.612] - state: ‘created’
[16:59:34.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.615] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.616]   - Field: ‘label’
[16:59:34.616]   - Field: ‘local’
[16:59:34.616]   - Field: ‘owner’
[16:59:34.616]   - Field: ‘envir’
[16:59:34.616]   - Field: ‘packages’
[16:59:34.616]   - Field: ‘gc’
[16:59:34.616]   - Field: ‘conditions’
[16:59:34.616]   - Field: ‘expr’
[16:59:34.616]   - Field: ‘uuid’
[16:59:34.617]   - Field: ‘seed’
[16:59:34.617]   - Field: ‘version’
[16:59:34.617]   - Field: ‘result’
[16:59:34.617]   - Field: ‘asynchronous’
[16:59:34.617]   - Field: ‘calls’
[16:59:34.617]   - Field: ‘globals’
[16:59:34.617]   - Field: ‘stdout’
[16:59:34.617]   - Field: ‘earlySignal’
[16:59:34.617]   - Field: ‘lazy’
[16:59:34.617]   - Field: ‘state’
[16:59:34.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.618] - Launch lazy future ...
[16:59:34.618] Packages needed by the future expression (n = 1): ‘stats’
[16:59:34.620] Packages needed by future strategies (n = 0): <none>
[16:59:34.620] {
[16:59:34.620]     {
[16:59:34.620]         {
[16:59:34.620]             ...future.startTime <- base::Sys.time()
[16:59:34.620]             {
[16:59:34.620]                 {
[16:59:34.620]                   {
[16:59:34.620]                     {
[16:59:34.620]                       base::local({
[16:59:34.620]                         has_future <- base::requireNamespace("future", 
[16:59:34.620]                           quietly = TRUE)
[16:59:34.620]                         if (has_future) {
[16:59:34.620]                           ns <- base::getNamespace("future")
[16:59:34.620]                           version <- ns[[".package"]][["version"]]
[16:59:34.620]                           if (is.null(version)) 
[16:59:34.620]                             version <- utils::packageVersion("future")
[16:59:34.620]                         }
[16:59:34.620]                         else {
[16:59:34.620]                           version <- NULL
[16:59:34.620]                         }
[16:59:34.620]                         if (!has_future || version < "1.8.0") {
[16:59:34.620]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.620]                             "", base::R.version$version.string), 
[16:59:34.620]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:34.620]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.620]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.620]                               "release", "version")], collapse = " "), 
[16:59:34.620]                             hostname = base::Sys.info()[["nodename"]])
[16:59:34.620]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.620]                             info)
[16:59:34.620]                           info <- base::paste(info, collapse = "; ")
[16:59:34.620]                           if (!has_future) {
[16:59:34.620]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.620]                               info)
[16:59:34.620]                           }
[16:59:34.620]                           else {
[16:59:34.620]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.620]                               info, version)
[16:59:34.620]                           }
[16:59:34.620]                           base::stop(msg)
[16:59:34.620]                         }
[16:59:34.620]                       })
[16:59:34.620]                     }
[16:59:34.620]                     base::local({
[16:59:34.620]                       for (pkg in "stats") {
[16:59:34.620]                         base::loadNamespace(pkg)
[16:59:34.620]                         base::library(pkg, character.only = TRUE)
[16:59:34.620]                       }
[16:59:34.620]                     })
[16:59:34.620]                   }
[16:59:34.620]                   ...future.strategy.old <- future::plan("list")
[16:59:34.620]                   options(future.plan = NULL)
[16:59:34.620]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.620]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.620]                 }
[16:59:34.620]                 ...future.workdir <- getwd()
[16:59:34.620]             }
[16:59:34.620]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.620]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.620]         }
[16:59:34.620]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.620]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.620]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.620]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.620]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.620]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.620]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.620]             base::names(...future.oldOptions))
[16:59:34.620]     }
[16:59:34.620]     if (FALSE) {
[16:59:34.620]     }
[16:59:34.620]     else {
[16:59:34.620]         if (TRUE) {
[16:59:34.620]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.620]                 open = "w")
[16:59:34.620]         }
[16:59:34.620]         else {
[16:59:34.620]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.620]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.620]         }
[16:59:34.620]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.620]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.620]             base::sink(type = "output", split = FALSE)
[16:59:34.620]             base::close(...future.stdout)
[16:59:34.620]         }, add = TRUE)
[16:59:34.620]     }
[16:59:34.620]     ...future.frame <- base::sys.nframe()
[16:59:34.620]     ...future.conditions <- base::list()
[16:59:34.620]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.620]     if (FALSE) {
[16:59:34.620]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.620]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.620]     }
[16:59:34.620]     ...future.result <- base::tryCatch({
[16:59:34.620]         base::withCallingHandlers({
[16:59:34.620]             ...future.value <- base::withVisible(base::local({
[16:59:34.620]                 do.call(function(...) {
[16:59:34.620]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.620]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.620]                     ...future.globals.maxSize)) {
[16:59:34.620]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.620]                     on.exit(options(oopts), add = TRUE)
[16:59:34.620]                   }
[16:59:34.620]                   {
[16:59:34.620]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.620]                       FUN = function(jj) {
[16:59:34.620]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.620]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.620]                       })
[16:59:34.620]                   }
[16:59:34.620]                 }, args = future.call.arguments)
[16:59:34.620]             }))
[16:59:34.620]             future::FutureResult(value = ...future.value$value, 
[16:59:34.620]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.620]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.620]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.620]                     ...future.globalenv.names))
[16:59:34.620]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.620]         }, condition = base::local({
[16:59:34.620]             c <- base::c
[16:59:34.620]             inherits <- base::inherits
[16:59:34.620]             invokeRestart <- base::invokeRestart
[16:59:34.620]             length <- base::length
[16:59:34.620]             list <- base::list
[16:59:34.620]             seq.int <- base::seq.int
[16:59:34.620]             signalCondition <- base::signalCondition
[16:59:34.620]             sys.calls <- base::sys.calls
[16:59:34.620]             `[[` <- base::`[[`
[16:59:34.620]             `+` <- base::`+`
[16:59:34.620]             `<<-` <- base::`<<-`
[16:59:34.620]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.620]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.620]                   3L)]
[16:59:34.620]             }
[16:59:34.620]             function(cond) {
[16:59:34.620]                 is_error <- inherits(cond, "error")
[16:59:34.620]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.620]                   NULL)
[16:59:34.620]                 if (is_error) {
[16:59:34.620]                   sessionInformation <- function() {
[16:59:34.620]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.620]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.620]                       search = base::search(), system = base::Sys.info())
[16:59:34.620]                   }
[16:59:34.620]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.620]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.620]                     cond$call), session = sessionInformation(), 
[16:59:34.620]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.620]                   signalCondition(cond)
[16:59:34.620]                 }
[16:59:34.620]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.620]                 "immediateCondition"))) {
[16:59:34.620]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.620]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.620]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.620]                   if (TRUE && !signal) {
[16:59:34.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.620]                     {
[16:59:34.620]                       inherits <- base::inherits
[16:59:34.620]                       invokeRestart <- base::invokeRestart
[16:59:34.620]                       is.null <- base::is.null
[16:59:34.620]                       muffled <- FALSE
[16:59:34.620]                       if (inherits(cond, "message")) {
[16:59:34.620]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.620]                         if (muffled) 
[16:59:34.620]                           invokeRestart("muffleMessage")
[16:59:34.620]                       }
[16:59:34.620]                       else if (inherits(cond, "warning")) {
[16:59:34.620]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.620]                         if (muffled) 
[16:59:34.620]                           invokeRestart("muffleWarning")
[16:59:34.620]                       }
[16:59:34.620]                       else if (inherits(cond, "condition")) {
[16:59:34.620]                         if (!is.null(pattern)) {
[16:59:34.620]                           computeRestarts <- base::computeRestarts
[16:59:34.620]                           grepl <- base::grepl
[16:59:34.620]                           restarts <- computeRestarts(cond)
[16:59:34.620]                           for (restart in restarts) {
[16:59:34.620]                             name <- restart$name
[16:59:34.620]                             if (is.null(name)) 
[16:59:34.620]                               next
[16:59:34.620]                             if (!grepl(pattern, name)) 
[16:59:34.620]                               next
[16:59:34.620]                             invokeRestart(restart)
[16:59:34.620]                             muffled <- TRUE
[16:59:34.620]                             break
[16:59:34.620]                           }
[16:59:34.620]                         }
[16:59:34.620]                       }
[16:59:34.620]                       invisible(muffled)
[16:59:34.620]                     }
[16:59:34.620]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.620]                   }
[16:59:34.620]                 }
[16:59:34.620]                 else {
[16:59:34.620]                   if (TRUE) {
[16:59:34.620]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.620]                     {
[16:59:34.620]                       inherits <- base::inherits
[16:59:34.620]                       invokeRestart <- base::invokeRestart
[16:59:34.620]                       is.null <- base::is.null
[16:59:34.620]                       muffled <- FALSE
[16:59:34.620]                       if (inherits(cond, "message")) {
[16:59:34.620]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.620]                         if (muffled) 
[16:59:34.620]                           invokeRestart("muffleMessage")
[16:59:34.620]                       }
[16:59:34.620]                       else if (inherits(cond, "warning")) {
[16:59:34.620]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.620]                         if (muffled) 
[16:59:34.620]                           invokeRestart("muffleWarning")
[16:59:34.620]                       }
[16:59:34.620]                       else if (inherits(cond, "condition")) {
[16:59:34.620]                         if (!is.null(pattern)) {
[16:59:34.620]                           computeRestarts <- base::computeRestarts
[16:59:34.620]                           grepl <- base::grepl
[16:59:34.620]                           restarts <- computeRestarts(cond)
[16:59:34.620]                           for (restart in restarts) {
[16:59:34.620]                             name <- restart$name
[16:59:34.620]                             if (is.null(name)) 
[16:59:34.620]                               next
[16:59:34.620]                             if (!grepl(pattern, name)) 
[16:59:34.620]                               next
[16:59:34.620]                             invokeRestart(restart)
[16:59:34.620]                             muffled <- TRUE
[16:59:34.620]                             break
[16:59:34.620]                           }
[16:59:34.620]                         }
[16:59:34.620]                       }
[16:59:34.620]                       invisible(muffled)
[16:59:34.620]                     }
[16:59:34.620]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.620]                   }
[16:59:34.620]                 }
[16:59:34.620]             }
[16:59:34.620]         }))
[16:59:34.620]     }, error = function(ex) {
[16:59:34.620]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.620]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.620]                 ...future.rng), started = ...future.startTime, 
[16:59:34.620]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.620]             version = "1.8"), class = "FutureResult")
[16:59:34.620]     }, finally = {
[16:59:34.620]         if (!identical(...future.workdir, getwd())) 
[16:59:34.620]             setwd(...future.workdir)
[16:59:34.620]         {
[16:59:34.620]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.620]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.620]             }
[16:59:34.620]             base::options(...future.oldOptions)
[16:59:34.620]             if (.Platform$OS.type == "windows") {
[16:59:34.620]                 old_names <- names(...future.oldEnvVars)
[16:59:34.620]                 envs <- base::Sys.getenv()
[16:59:34.620]                 names <- names(envs)
[16:59:34.620]                 common <- intersect(names, old_names)
[16:59:34.620]                 added <- setdiff(names, old_names)
[16:59:34.620]                 removed <- setdiff(old_names, names)
[16:59:34.620]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.620]                   envs[common]]
[16:59:34.620]                 NAMES <- toupper(changed)
[16:59:34.620]                 args <- list()
[16:59:34.620]                 for (kk in seq_along(NAMES)) {
[16:59:34.620]                   name <- changed[[kk]]
[16:59:34.620]                   NAME <- NAMES[[kk]]
[16:59:34.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.620]                     next
[16:59:34.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.620]                 }
[16:59:34.620]                 NAMES <- toupper(added)
[16:59:34.620]                 for (kk in seq_along(NAMES)) {
[16:59:34.620]                   name <- added[[kk]]
[16:59:34.620]                   NAME <- NAMES[[kk]]
[16:59:34.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.620]                     next
[16:59:34.620]                   args[[name]] <- ""
[16:59:34.620]                 }
[16:59:34.620]                 NAMES <- toupper(removed)
[16:59:34.620]                 for (kk in seq_along(NAMES)) {
[16:59:34.620]                   name <- removed[[kk]]
[16:59:34.620]                   NAME <- NAMES[[kk]]
[16:59:34.620]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.620]                     next
[16:59:34.620]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.620]                 }
[16:59:34.620]                 if (length(args) > 0) 
[16:59:34.620]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.620]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.620]             }
[16:59:34.620]             else {
[16:59:34.620]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.620]             }
[16:59:34.620]             {
[16:59:34.620]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.620]                   0L) {
[16:59:34.620]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.620]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.620]                   base::options(opts)
[16:59:34.620]                 }
[16:59:34.620]                 {
[16:59:34.620]                   {
[16:59:34.620]                     NULL
[16:59:34.620]                     RNGkind("Mersenne-Twister")
[16:59:34.620]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.620]                       inherits = FALSE)
[16:59:34.620]                   }
[16:59:34.620]                   options(future.plan = NULL)
[16:59:34.620]                   if (is.na(NA_character_)) 
[16:59:34.620]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.620]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.620]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.620]                     .init = FALSE)
[16:59:34.620]                 }
[16:59:34.620]             }
[16:59:34.620]         }
[16:59:34.620]     })
[16:59:34.620]     if (TRUE) {
[16:59:34.620]         base::sink(type = "output", split = FALSE)
[16:59:34.620]         if (TRUE) {
[16:59:34.620]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.620]         }
[16:59:34.620]         else {
[16:59:34.620]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.620]         }
[16:59:34.620]         base::close(...future.stdout)
[16:59:34.620]         ...future.stdout <- NULL
[16:59:34.620]     }
[16:59:34.620]     ...future.result$conditions <- ...future.conditions
[16:59:34.620]     ...future.result$finished <- base::Sys.time()
[16:59:34.620]     ...future.result
[16:59:34.620] }
[16:59:34.622] assign_globals() ...
[16:59:34.622] List of 5
[16:59:34.622]  $ ...future.FUN            :function (x, ...)  
[16:59:34.622]  $ future.call.arguments    :List of 1
[16:59:34.622]   ..$ singular.ok: logi FALSE
[16:59:34.622]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.622]  $ ...future.elements_ii    :List of 3
[16:59:34.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.622]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.622]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.622]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.622]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.622]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.622]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.622]  $ ...future.seeds_ii       : NULL
[16:59:34.622]  $ ...future.globals.maxSize: NULL
[16:59:34.622]  - attr(*, "where")=List of 5
[16:59:34.622]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.622]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.622]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.622]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.622]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.622]  - attr(*, "resolved")= logi FALSE
[16:59:34.622]  - attr(*, "total_size")= num 5384
[16:59:34.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.622]  - attr(*, "already-done")= logi TRUE
[16:59:34.632] - reassign environment for ‘...future.FUN’
[16:59:34.632] - copied ‘...future.FUN’ to environment
[16:59:34.632] - copied ‘future.call.arguments’ to environment
[16:59:34.632] - copied ‘...future.elements_ii’ to environment
[16:59:34.632] - copied ‘...future.seeds_ii’ to environment
[16:59:34.632] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.632] assign_globals() ... done
[16:59:34.633] plan(): Setting new future strategy stack:
[16:59:34.633] List of future strategies:
[16:59:34.633] 1. sequential:
[16:59:34.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.633]    - tweaked: FALSE
[16:59:34.633]    - call: NULL
[16:59:34.633] plan(): nbrOfWorkers() = 1
[16:59:34.636] plan(): Setting new future strategy stack:
[16:59:34.636] List of future strategies:
[16:59:34.636] 1. multisession:
[16:59:34.636]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.636]    - tweaked: FALSE
[16:59:34.636]    - call: plan(strategy)
[16:59:34.640] plan(): nbrOfWorkers() = 1
[16:59:34.640] SequentialFuture started (and completed)
[16:59:34.640] - Launch lazy future ... done
[16:59:34.640] run() for ‘SequentialFuture’ ... done
[16:59:34.640] Created future:
[16:59:34.641] SequentialFuture:
[16:59:34.641] Label: ‘future_by-1’
[16:59:34.641] Expression:
[16:59:34.641] {
[16:59:34.641]     do.call(function(...) {
[16:59:34.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.641]             on.exit(options(oopts), add = TRUE)
[16:59:34.641]         }
[16:59:34.641]         {
[16:59:34.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.641]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.641]             })
[16:59:34.641]         }
[16:59:34.641]     }, args = future.call.arguments)
[16:59:34.641] }
[16:59:34.641] Lazy evaluation: FALSE
[16:59:34.641] Asynchronous evaluation: FALSE
[16:59:34.641] Local evaluation: TRUE
[16:59:34.641] Environment: R_GlobalEnv
[16:59:34.641] Capture standard output: TRUE
[16:59:34.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.641] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.641] Packages: 1 packages (‘stats’)
[16:59:34.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.641] Resolved: TRUE
[16:59:34.641] Value: 26.06 KiB of class ‘list’
[16:59:34.641] Early signaling: FALSE
[16:59:34.641] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.641] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.642] Chunk #1 of 1 ... DONE
[16:59:34.642] Launching 1 futures (chunks) ... DONE
[16:59:34.643] Resolving 1 futures (chunks) ...
[16:59:34.643] resolve() on list ...
[16:59:34.643]  recursive: 0
[16:59:34.643]  length: 1
[16:59:34.643] 
[16:59:34.643] resolved() for ‘SequentialFuture’ ...
[16:59:34.643] - state: ‘finished’
[16:59:34.643] - run: TRUE
[16:59:34.643] - result: ‘FutureResult’
[16:59:34.643] resolved() for ‘SequentialFuture’ ... done
[16:59:34.644] Future #1
[16:59:34.644] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.644] - nx: 1
[16:59:34.644] - relay: TRUE
[16:59:34.644] - stdout: TRUE
[16:59:34.644] - signal: TRUE
[16:59:34.644] - resignal: FALSE
[16:59:34.644] - force: TRUE
[16:59:34.644] - relayed: [n=1] FALSE
[16:59:34.644] - queued futures: [n=1] FALSE
[16:59:34.644]  - until=1
[16:59:34.645]  - relaying element #1
[16:59:34.645] - relayed: [n=1] TRUE
[16:59:34.645] - queued futures: [n=1] TRUE
[16:59:34.645] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.645]  length: 0 (resolved future 1)
[16:59:34.645] Relaying remaining futures
[16:59:34.645] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.645] - nx: 1
[16:59:34.645] - relay: TRUE
[16:59:34.647] - stdout: TRUE
[16:59:34.647] - signal: TRUE
[16:59:34.647] - resignal: FALSE
[16:59:34.648] - force: TRUE
[16:59:34.648] - relayed: [n=1] TRUE
[16:59:34.648] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.648] - relayed: [n=1] TRUE
[16:59:34.648] - queued futures: [n=1] TRUE
[16:59:34.648] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.648] resolve() on list ... DONE
[16:59:34.648]  - Number of value chunks collected: 1
[16:59:34.649] Resolving 1 futures (chunks) ... DONE
[16:59:34.649] Reducing values from 1 chunks ...
[16:59:34.649]  - Number of values collected after concatenation: 3
[16:59:34.649]  - Number of values expected: 3
[16:59:34.649] Reducing values from 1 chunks ... DONE
[16:59:34.649] future_lapply() ... DONE
[16:59:34.649] future_by_internal() ... DONE
[16:59:34.653] future_by_internal() ...
[16:59:34.654] future_lapply() ...
[16:59:34.658] Number of chunks: 1
[16:59:34.658] getGlobalsAndPackagesXApply() ...
[16:59:34.658]  - future.globals: TRUE
[16:59:34.658] getGlobalsAndPackages() ...
[16:59:34.658] Searching for globals...
[16:59:34.660] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:34.661] Searching for globals ... DONE
[16:59:34.661] Resolving globals: FALSE
[16:59:34.661] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:59:34.662] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:59:34.662] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:34.662] - packages: [1] ‘stats’
[16:59:34.662] getGlobalsAndPackages() ... DONE
[16:59:34.662]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:34.662]  - needed namespaces: [n=1] ‘stats’
[16:59:34.662] Finding globals ... DONE
[16:59:34.662]  - use_args: TRUE
[16:59:34.662]  - Getting '...' globals ...
[16:59:34.663] resolve() on list ...
[16:59:34.663]  recursive: 0
[16:59:34.663]  length: 1
[16:59:34.663]  elements: ‘...’
[16:59:34.663]  length: 0 (resolved future 1)
[16:59:34.663] resolve() on list ... DONE
[16:59:34.663]    - '...' content: [n=0] 
[16:59:34.663] List of 1
[16:59:34.663]  $ ...: list()
[16:59:34.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.663]  - attr(*, "where")=List of 1
[16:59:34.663]   ..$ ...:<environment: 0x56205109d338> 
[16:59:34.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.663]  - attr(*, "resolved")= logi TRUE
[16:59:34.663]  - attr(*, "total_size")= num NA
[16:59:34.666]  - Getting '...' globals ... DONE
[16:59:34.666] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:59:34.666] List of 4
[16:59:34.666]  $ ...future.FUN:function (x)  
[16:59:34.666]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:34.666]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.666]  $ ...          : list()
[16:59:34.666]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.666]  - attr(*, "where")=List of 4
[16:59:34.666]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.666]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:59:34.666]   ..$ wool         :<environment: R_EmptyEnv> 
[16:59:34.666]   ..$ ...          :<environment: 0x56205109d338> 
[16:59:34.666]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.666]  - attr(*, "resolved")= logi FALSE
[16:59:34.666]  - attr(*, "total_size")= num 2320
[16:59:34.672] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:34.672] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.672] Number of futures (= number of chunks): 1
[16:59:34.672] Launching 1 futures (chunks) ...
[16:59:34.672] Chunk #1 of 1 ...
[16:59:34.673]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.673] getGlobalsAndPackages() ...
[16:59:34.673] Searching for globals...
[16:59:34.673] 
[16:59:34.674] Searching for globals ... DONE
[16:59:34.674] - globals: [0] <none>
[16:59:34.674] getGlobalsAndPackages() ... DONE
[16:59:34.674]    + additional globals found: [n=0] 
[16:59:34.674]    + additional namespaces needed: [n=0] 
[16:59:34.674]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.674]  - seeds: <none>
[16:59:34.674]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.674] getGlobalsAndPackages() ...
[16:59:34.674] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.674] Resolving globals: FALSE
[16:59:34.675] Tweak future expression to call with '...' arguments ...
[16:59:34.675] {
[16:59:34.675]     do.call(function(...) {
[16:59:34.675]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.675]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.675]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.675]             on.exit(options(oopts), add = TRUE)
[16:59:34.675]         }
[16:59:34.675]         {
[16:59:34.675]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.675]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.675]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.675]             })
[16:59:34.675]         }
[16:59:34.675]     }, args = future.call.arguments)
[16:59:34.675] }
[16:59:34.675] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.675] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.675] 
[16:59:34.676] getGlobalsAndPackages() ... DONE
[16:59:34.676] run() for ‘Future’ ...
[16:59:34.676] - state: ‘created’
[16:59:34.676] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.680] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.680]   - Field: ‘label’
[16:59:34.680]   - Field: ‘local’
[16:59:34.680]   - Field: ‘owner’
[16:59:34.680]   - Field: ‘envir’
[16:59:34.680]   - Field: ‘packages’
[16:59:34.680]   - Field: ‘gc’
[16:59:34.680]   - Field: ‘conditions’
[16:59:34.680]   - Field: ‘expr’
[16:59:34.681]   - Field: ‘uuid’
[16:59:34.681]   - Field: ‘seed’
[16:59:34.681]   - Field: ‘version’
[16:59:34.681]   - Field: ‘result’
[16:59:34.681]   - Field: ‘asynchronous’
[16:59:34.681]   - Field: ‘calls’
[16:59:34.681]   - Field: ‘globals’
[16:59:34.681]   - Field: ‘stdout’
[16:59:34.681]   - Field: ‘earlySignal’
[16:59:34.681]   - Field: ‘lazy’
[16:59:34.681]   - Field: ‘state’
[16:59:34.681] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.682] - Launch lazy future ...
[16:59:34.682] Packages needed by the future expression (n = 1): ‘stats’
[16:59:34.682] Packages needed by future strategies (n = 0): <none>
[16:59:34.682] {
[16:59:34.682]     {
[16:59:34.682]         {
[16:59:34.682]             ...future.startTime <- base::Sys.time()
[16:59:34.682]             {
[16:59:34.682]                 {
[16:59:34.682]                   {
[16:59:34.682]                     {
[16:59:34.682]                       base::local({
[16:59:34.682]                         has_future <- base::requireNamespace("future", 
[16:59:34.682]                           quietly = TRUE)
[16:59:34.682]                         if (has_future) {
[16:59:34.682]                           ns <- base::getNamespace("future")
[16:59:34.682]                           version <- ns[[".package"]][["version"]]
[16:59:34.682]                           if (is.null(version)) 
[16:59:34.682]                             version <- utils::packageVersion("future")
[16:59:34.682]                         }
[16:59:34.682]                         else {
[16:59:34.682]                           version <- NULL
[16:59:34.682]                         }
[16:59:34.682]                         if (!has_future || version < "1.8.0") {
[16:59:34.682]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.682]                             "", base::R.version$version.string), 
[16:59:34.682]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:34.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.682]                               "release", "version")], collapse = " "), 
[16:59:34.682]                             hostname = base::Sys.info()[["nodename"]])
[16:59:34.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.682]                             info)
[16:59:34.682]                           info <- base::paste(info, collapse = "; ")
[16:59:34.682]                           if (!has_future) {
[16:59:34.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.682]                               info)
[16:59:34.682]                           }
[16:59:34.682]                           else {
[16:59:34.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.682]                               info, version)
[16:59:34.682]                           }
[16:59:34.682]                           base::stop(msg)
[16:59:34.682]                         }
[16:59:34.682]                       })
[16:59:34.682]                     }
[16:59:34.682]                     base::local({
[16:59:34.682]                       for (pkg in "stats") {
[16:59:34.682]                         base::loadNamespace(pkg)
[16:59:34.682]                         base::library(pkg, character.only = TRUE)
[16:59:34.682]                       }
[16:59:34.682]                     })
[16:59:34.682]                   }
[16:59:34.682]                   ...future.strategy.old <- future::plan("list")
[16:59:34.682]                   options(future.plan = NULL)
[16:59:34.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.682]                 }
[16:59:34.682]                 ...future.workdir <- getwd()
[16:59:34.682]             }
[16:59:34.682]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.682]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.682]         }
[16:59:34.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.682]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.682]             base::names(...future.oldOptions))
[16:59:34.682]     }
[16:59:34.682]     if (FALSE) {
[16:59:34.682]     }
[16:59:34.682]     else {
[16:59:34.682]         if (TRUE) {
[16:59:34.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.682]                 open = "w")
[16:59:34.682]         }
[16:59:34.682]         else {
[16:59:34.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.682]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.682]         }
[16:59:34.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.682]             base::sink(type = "output", split = FALSE)
[16:59:34.682]             base::close(...future.stdout)
[16:59:34.682]         }, add = TRUE)
[16:59:34.682]     }
[16:59:34.682]     ...future.frame <- base::sys.nframe()
[16:59:34.682]     ...future.conditions <- base::list()
[16:59:34.682]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.682]     if (FALSE) {
[16:59:34.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.682]     }
[16:59:34.682]     ...future.result <- base::tryCatch({
[16:59:34.682]         base::withCallingHandlers({
[16:59:34.682]             ...future.value <- base::withVisible(base::local({
[16:59:34.682]                 do.call(function(...) {
[16:59:34.682]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.682]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.682]                     ...future.globals.maxSize)) {
[16:59:34.682]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.682]                     on.exit(options(oopts), add = TRUE)
[16:59:34.682]                   }
[16:59:34.682]                   {
[16:59:34.682]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.682]                       FUN = function(jj) {
[16:59:34.682]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.682]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.682]                       })
[16:59:34.682]                   }
[16:59:34.682]                 }, args = future.call.arguments)
[16:59:34.682]             }))
[16:59:34.682]             future::FutureResult(value = ...future.value$value, 
[16:59:34.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.682]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.682]                     ...future.globalenv.names))
[16:59:34.682]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.682]         }, condition = base::local({
[16:59:34.682]             c <- base::c
[16:59:34.682]             inherits <- base::inherits
[16:59:34.682]             invokeRestart <- base::invokeRestart
[16:59:34.682]             length <- base::length
[16:59:34.682]             list <- base::list
[16:59:34.682]             seq.int <- base::seq.int
[16:59:34.682]             signalCondition <- base::signalCondition
[16:59:34.682]             sys.calls <- base::sys.calls
[16:59:34.682]             `[[` <- base::`[[`
[16:59:34.682]             `+` <- base::`+`
[16:59:34.682]             `<<-` <- base::`<<-`
[16:59:34.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.682]                   3L)]
[16:59:34.682]             }
[16:59:34.682]             function(cond) {
[16:59:34.682]                 is_error <- inherits(cond, "error")
[16:59:34.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.682]                   NULL)
[16:59:34.682]                 if (is_error) {
[16:59:34.682]                   sessionInformation <- function() {
[16:59:34.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.682]                       search = base::search(), system = base::Sys.info())
[16:59:34.682]                   }
[16:59:34.682]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.682]                     cond$call), session = sessionInformation(), 
[16:59:34.682]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.682]                   signalCondition(cond)
[16:59:34.682]                 }
[16:59:34.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.682]                 "immediateCondition"))) {
[16:59:34.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.682]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.682]                   if (TRUE && !signal) {
[16:59:34.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.682]                     {
[16:59:34.682]                       inherits <- base::inherits
[16:59:34.682]                       invokeRestart <- base::invokeRestart
[16:59:34.682]                       is.null <- base::is.null
[16:59:34.682]                       muffled <- FALSE
[16:59:34.682]                       if (inherits(cond, "message")) {
[16:59:34.682]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.682]                         if (muffled) 
[16:59:34.682]                           invokeRestart("muffleMessage")
[16:59:34.682]                       }
[16:59:34.682]                       else if (inherits(cond, "warning")) {
[16:59:34.682]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.682]                         if (muffled) 
[16:59:34.682]                           invokeRestart("muffleWarning")
[16:59:34.682]                       }
[16:59:34.682]                       else if (inherits(cond, "condition")) {
[16:59:34.682]                         if (!is.null(pattern)) {
[16:59:34.682]                           computeRestarts <- base::computeRestarts
[16:59:34.682]                           grepl <- base::grepl
[16:59:34.682]                           restarts <- computeRestarts(cond)
[16:59:34.682]                           for (restart in restarts) {
[16:59:34.682]                             name <- restart$name
[16:59:34.682]                             if (is.null(name)) 
[16:59:34.682]                               next
[16:59:34.682]                             if (!grepl(pattern, name)) 
[16:59:34.682]                               next
[16:59:34.682]                             invokeRestart(restart)
[16:59:34.682]                             muffled <- TRUE
[16:59:34.682]                             break
[16:59:34.682]                           }
[16:59:34.682]                         }
[16:59:34.682]                       }
[16:59:34.682]                       invisible(muffled)
[16:59:34.682]                     }
[16:59:34.682]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.682]                   }
[16:59:34.682]                 }
[16:59:34.682]                 else {
[16:59:34.682]                   if (TRUE) {
[16:59:34.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.682]                     {
[16:59:34.682]                       inherits <- base::inherits
[16:59:34.682]                       invokeRestart <- base::invokeRestart
[16:59:34.682]                       is.null <- base::is.null
[16:59:34.682]                       muffled <- FALSE
[16:59:34.682]                       if (inherits(cond, "message")) {
[16:59:34.682]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.682]                         if (muffled) 
[16:59:34.682]                           invokeRestart("muffleMessage")
[16:59:34.682]                       }
[16:59:34.682]                       else if (inherits(cond, "warning")) {
[16:59:34.682]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.682]                         if (muffled) 
[16:59:34.682]                           invokeRestart("muffleWarning")
[16:59:34.682]                       }
[16:59:34.682]                       else if (inherits(cond, "condition")) {
[16:59:34.682]                         if (!is.null(pattern)) {
[16:59:34.682]                           computeRestarts <- base::computeRestarts
[16:59:34.682]                           grepl <- base::grepl
[16:59:34.682]                           restarts <- computeRestarts(cond)
[16:59:34.682]                           for (restart in restarts) {
[16:59:34.682]                             name <- restart$name
[16:59:34.682]                             if (is.null(name)) 
[16:59:34.682]                               next
[16:59:34.682]                             if (!grepl(pattern, name)) 
[16:59:34.682]                               next
[16:59:34.682]                             invokeRestart(restart)
[16:59:34.682]                             muffled <- TRUE
[16:59:34.682]                             break
[16:59:34.682]                           }
[16:59:34.682]                         }
[16:59:34.682]                       }
[16:59:34.682]                       invisible(muffled)
[16:59:34.682]                     }
[16:59:34.682]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.682]                   }
[16:59:34.682]                 }
[16:59:34.682]             }
[16:59:34.682]         }))
[16:59:34.682]     }, error = function(ex) {
[16:59:34.682]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.682]                 ...future.rng), started = ...future.startTime, 
[16:59:34.682]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.682]             version = "1.8"), class = "FutureResult")
[16:59:34.682]     }, finally = {
[16:59:34.682]         if (!identical(...future.workdir, getwd())) 
[16:59:34.682]             setwd(...future.workdir)
[16:59:34.682]         {
[16:59:34.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.682]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.682]             }
[16:59:34.682]             base::options(...future.oldOptions)
[16:59:34.682]             if (.Platform$OS.type == "windows") {
[16:59:34.682]                 old_names <- names(...future.oldEnvVars)
[16:59:34.682]                 envs <- base::Sys.getenv()
[16:59:34.682]                 names <- names(envs)
[16:59:34.682]                 common <- intersect(names, old_names)
[16:59:34.682]                 added <- setdiff(names, old_names)
[16:59:34.682]                 removed <- setdiff(old_names, names)
[16:59:34.682]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.682]                   envs[common]]
[16:59:34.682]                 NAMES <- toupper(changed)
[16:59:34.682]                 args <- list()
[16:59:34.682]                 for (kk in seq_along(NAMES)) {
[16:59:34.682]                   name <- changed[[kk]]
[16:59:34.682]                   NAME <- NAMES[[kk]]
[16:59:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.682]                     next
[16:59:34.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.682]                 }
[16:59:34.682]                 NAMES <- toupper(added)
[16:59:34.682]                 for (kk in seq_along(NAMES)) {
[16:59:34.682]                   name <- added[[kk]]
[16:59:34.682]                   NAME <- NAMES[[kk]]
[16:59:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.682]                     next
[16:59:34.682]                   args[[name]] <- ""
[16:59:34.682]                 }
[16:59:34.682]                 NAMES <- toupper(removed)
[16:59:34.682]                 for (kk in seq_along(NAMES)) {
[16:59:34.682]                   name <- removed[[kk]]
[16:59:34.682]                   NAME <- NAMES[[kk]]
[16:59:34.682]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.682]                     next
[16:59:34.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.682]                 }
[16:59:34.682]                 if (length(args) > 0) 
[16:59:34.682]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.682]             }
[16:59:34.682]             else {
[16:59:34.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.682]             }
[16:59:34.682]             {
[16:59:34.682]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.682]                   0L) {
[16:59:34.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.682]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.682]                   base::options(opts)
[16:59:34.682]                 }
[16:59:34.682]                 {
[16:59:34.682]                   {
[16:59:34.682]                     NULL
[16:59:34.682]                     RNGkind("Mersenne-Twister")
[16:59:34.682]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.682]                       inherits = FALSE)
[16:59:34.682]                   }
[16:59:34.682]                   options(future.plan = NULL)
[16:59:34.682]                   if (is.na(NA_character_)) 
[16:59:34.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.682]                     .init = FALSE)
[16:59:34.682]                 }
[16:59:34.682]             }
[16:59:34.682]         }
[16:59:34.682]     })
[16:59:34.682]     if (TRUE) {
[16:59:34.682]         base::sink(type = "output", split = FALSE)
[16:59:34.682]         if (TRUE) {
[16:59:34.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.682]         }
[16:59:34.682]         else {
[16:59:34.682]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.682]         }
[16:59:34.682]         base::close(...future.stdout)
[16:59:34.682]         ...future.stdout <- NULL
[16:59:34.682]     }
[16:59:34.682]     ...future.result$conditions <- ...future.conditions
[16:59:34.682]     ...future.result$finished <- base::Sys.time()
[16:59:34.682]     ...future.result
[16:59:34.682] }
[16:59:34.684] assign_globals() ...
[16:59:34.684] List of 7
[16:59:34.684]  $ ...future.FUN            :function (x)  
[16:59:34.684]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:34.684]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.684]  $ future.call.arguments    : list()
[16:59:34.684]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.684]  $ ...future.elements_ii    :List of 3
[16:59:34.684]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.684]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.684]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.684]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.684]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.684]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.684]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.684]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.684]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.684]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.684]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.684]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.684]  $ ...future.seeds_ii       : NULL
[16:59:34.684]  $ ...future.globals.maxSize: NULL
[16:59:34.684]  - attr(*, "where")=List of 7
[16:59:34.684]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.684]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:59:34.684]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:59:34.684]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.684]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.684]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.684]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.684]  - attr(*, "resolved")= logi FALSE
[16:59:34.684]  - attr(*, "total_size")= num 2320
[16:59:34.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.684]  - attr(*, "already-done")= logi TRUE
[16:59:34.694] - reassign environment for ‘...future.FUN’
[16:59:34.694] - copied ‘...future.FUN’ to environment
[16:59:34.694] - copied ‘breaks’ to environment
[16:59:34.694] - copied ‘wool’ to environment
[16:59:34.694] - copied ‘future.call.arguments’ to environment
[16:59:34.694] - copied ‘...future.elements_ii’ to environment
[16:59:34.694] - copied ‘...future.seeds_ii’ to environment
[16:59:34.696] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.696] assign_globals() ... done
[16:59:34.697] plan(): Setting new future strategy stack:
[16:59:34.697] List of future strategies:
[16:59:34.697] 1. sequential:
[16:59:34.697]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.697]    - tweaked: FALSE
[16:59:34.697]    - call: NULL
[16:59:34.697] plan(): nbrOfWorkers() = 1
[16:59:34.700] plan(): Setting new future strategy stack:
[16:59:34.700] List of future strategies:
[16:59:34.700] 1. multisession:
[16:59:34.700]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.700]    - tweaked: FALSE
[16:59:34.700]    - call: plan(strategy)
[16:59:34.704] plan(): nbrOfWorkers() = 1
[16:59:34.704] SequentialFuture started (and completed)
[16:59:34.704] - Launch lazy future ... done
[16:59:34.704] run() for ‘SequentialFuture’ ... done
[16:59:34.705] Created future:
[16:59:34.705] SequentialFuture:
[16:59:34.705] Label: ‘future_by-1’
[16:59:34.705] Expression:
[16:59:34.705] {
[16:59:34.705]     do.call(function(...) {
[16:59:34.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.705]             on.exit(options(oopts), add = TRUE)
[16:59:34.705]         }
[16:59:34.705]         {
[16:59:34.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.705]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.705]             })
[16:59:34.705]         }
[16:59:34.705]     }, args = future.call.arguments)
[16:59:34.705] }
[16:59:34.705] Lazy evaluation: FALSE
[16:59:34.705] Asynchronous evaluation: FALSE
[16:59:34.705] Local evaluation: TRUE
[16:59:34.705] Environment: 0x562050b4ac50
[16:59:34.705] Capture standard output: TRUE
[16:59:34.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.705] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:59:34.705] Packages: 1 packages (‘stats’)
[16:59:34.705] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.705] Resolved: TRUE
[16:59:34.705] Value: 25.57 KiB of class ‘list’
[16:59:34.705] Early signaling: FALSE
[16:59:34.705] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.705] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.706] Chunk #1 of 1 ... DONE
[16:59:34.706] Launching 1 futures (chunks) ... DONE
[16:59:34.706] Resolving 1 futures (chunks) ...
[16:59:34.707] resolve() on list ...
[16:59:34.707]  recursive: 0
[16:59:34.707]  length: 1
[16:59:34.707] 
[16:59:34.707] resolved() for ‘SequentialFuture’ ...
[16:59:34.707] - state: ‘finished’
[16:59:34.707] - run: TRUE
[16:59:34.707] - result: ‘FutureResult’
[16:59:34.707] resolved() for ‘SequentialFuture’ ... done
[16:59:34.707] Future #1
[16:59:34.708] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.708] - nx: 1
[16:59:34.708] - relay: TRUE
[16:59:34.708] - stdout: TRUE
[16:59:34.708] - signal: TRUE
[16:59:34.708] - resignal: FALSE
[16:59:34.708] - force: TRUE
[16:59:34.708] - relayed: [n=1] FALSE
[16:59:34.708] - queued futures: [n=1] FALSE
[16:59:34.708]  - until=1
[16:59:34.708]  - relaying element #1
[16:59:34.709] - relayed: [n=1] TRUE
[16:59:34.709] - queued futures: [n=1] TRUE
[16:59:34.709] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.709]  length: 0 (resolved future 1)
[16:59:34.709] Relaying remaining futures
[16:59:34.709] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.709] - nx: 1
[16:59:34.709] - relay: TRUE
[16:59:34.709] - stdout: TRUE
[16:59:34.709] - signal: TRUE
[16:59:34.710] - resignal: FALSE
[16:59:34.710] - force: TRUE
[16:59:34.710] - relayed: [n=1] TRUE
[16:59:34.710] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.710] - relayed: [n=1] TRUE
[16:59:34.710] - queued futures: [n=1] TRUE
[16:59:34.710] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.710] resolve() on list ... DONE
[16:59:34.710]  - Number of value chunks collected: 1
[16:59:34.710] Resolving 1 futures (chunks) ... DONE
[16:59:34.710] Reducing values from 1 chunks ...
[16:59:34.711]  - Number of values collected after concatenation: 3
[16:59:34.711]  - Number of values expected: 3
[16:59:34.711] Reducing values from 1 chunks ... DONE
[16:59:34.711] future_lapply() ... DONE
[16:59:34.711] future_by_internal() ... DONE
[16:59:34.711] future_by_internal() ...
[16:59:34.712] future_lapply() ...
[16:59:34.715] Number of chunks: 1
[16:59:34.716] getGlobalsAndPackagesXApply() ...
[16:59:34.716]  - future.globals: TRUE
[16:59:34.716] getGlobalsAndPackages() ...
[16:59:34.716] Searching for globals...
[16:59:34.717] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.717] Searching for globals ... DONE
[16:59:34.717] Resolving globals: FALSE
[16:59:34.718] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.718] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.718] - globals: [1] ‘FUN’
[16:59:34.718] 
[16:59:34.718] getGlobalsAndPackages() ... DONE
[16:59:34.718]  - globals found/used: [n=1] ‘FUN’
[16:59:34.718]  - needed namespaces: [n=0] 
[16:59:34.718] Finding globals ... DONE
[16:59:34.719]  - use_args: TRUE
[16:59:34.719]  - Getting '...' globals ...
[16:59:34.719] resolve() on list ...
[16:59:34.719]  recursive: 0
[16:59:34.719]  length: 1
[16:59:34.719]  elements: ‘...’
[16:59:34.719]  length: 0 (resolved future 1)
[16:59:34.719] resolve() on list ... DONE
[16:59:34.720]    - '...' content: [n=0] 
[16:59:34.720] List of 1
[16:59:34.720]  $ ...: list()
[16:59:34.720]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.720]  - attr(*, "where")=List of 1
[16:59:34.720]   ..$ ...:<environment: 0x5620527c0b60> 
[16:59:34.720]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.720]  - attr(*, "resolved")= logi TRUE
[16:59:34.720]  - attr(*, "total_size")= num NA
[16:59:34.724]  - Getting '...' globals ... DONE
[16:59:34.724] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.724] List of 2
[16:59:34.724]  $ ...future.FUN:function (object, ...)  
[16:59:34.724]  $ ...          : list()
[16:59:34.724]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.724]  - attr(*, "where")=List of 2
[16:59:34.724]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.724]   ..$ ...          :<environment: 0x5620527c0b60> 
[16:59:34.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.724]  - attr(*, "resolved")= logi FALSE
[16:59:34.724]  - attr(*, "total_size")= num 1240
[16:59:34.727] Packages to be attached in all futures: [n=0] 
[16:59:34.727] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.728] Number of futures (= number of chunks): 1
[16:59:34.728] Launching 1 futures (chunks) ...
[16:59:34.728] Chunk #1 of 1 ...
[16:59:34.728]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.728] getGlobalsAndPackages() ...
[16:59:34.728] Searching for globals...
[16:59:34.729] 
[16:59:34.729] Searching for globals ... DONE
[16:59:34.729] - globals: [0] <none>
[16:59:34.729] getGlobalsAndPackages() ... DONE
[16:59:34.729]    + additional globals found: [n=0] 
[16:59:34.729]    + additional namespaces needed: [n=0] 
[16:59:34.729]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.729]  - seeds: <none>
[16:59:34.729]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.730] getGlobalsAndPackages() ...
[16:59:34.730] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.730] Resolving globals: FALSE
[16:59:34.730] Tweak future expression to call with '...' arguments ...
[16:59:34.730] {
[16:59:34.730]     do.call(function(...) {
[16:59:34.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.730]             on.exit(options(oopts), add = TRUE)
[16:59:34.730]         }
[16:59:34.730]         {
[16:59:34.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.730]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.730]             })
[16:59:34.730]         }
[16:59:34.730]     }, args = future.call.arguments)
[16:59:34.730] }
[16:59:34.730] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.731] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.731] 
[16:59:34.731] getGlobalsAndPackages() ... DONE
[16:59:34.731] run() for ‘Future’ ...
[16:59:34.731] - state: ‘created’
[16:59:34.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.735] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.735] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.735]   - Field: ‘label’
[16:59:34.735]   - Field: ‘local’
[16:59:34.735]   - Field: ‘owner’
[16:59:34.735]   - Field: ‘envir’
[16:59:34.735]   - Field: ‘packages’
[16:59:34.736]   - Field: ‘gc’
[16:59:34.736]   - Field: ‘conditions’
[16:59:34.736]   - Field: ‘expr’
[16:59:34.736]   - Field: ‘uuid’
[16:59:34.736]   - Field: ‘seed’
[16:59:34.736]   - Field: ‘version’
[16:59:34.736]   - Field: ‘result’
[16:59:34.736]   - Field: ‘asynchronous’
[16:59:34.736]   - Field: ‘calls’
[16:59:34.736]   - Field: ‘globals’
[16:59:34.736]   - Field: ‘stdout’
[16:59:34.737]   - Field: ‘earlySignal’
[16:59:34.737]   - Field: ‘lazy’
[16:59:34.737]   - Field: ‘state’
[16:59:34.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.737] - Launch lazy future ...
[16:59:34.737] Packages needed by the future expression (n = 0): <none>
[16:59:34.737] Packages needed by future strategies (n = 0): <none>
[16:59:34.738] {
[16:59:34.738]     {
[16:59:34.738]         {
[16:59:34.738]             ...future.startTime <- base::Sys.time()
[16:59:34.738]             {
[16:59:34.738]                 {
[16:59:34.738]                   {
[16:59:34.738]                     base::local({
[16:59:34.738]                       has_future <- base::requireNamespace("future", 
[16:59:34.738]                         quietly = TRUE)
[16:59:34.738]                       if (has_future) {
[16:59:34.738]                         ns <- base::getNamespace("future")
[16:59:34.738]                         version <- ns[[".package"]][["version"]]
[16:59:34.738]                         if (is.null(version)) 
[16:59:34.738]                           version <- utils::packageVersion("future")
[16:59:34.738]                       }
[16:59:34.738]                       else {
[16:59:34.738]                         version <- NULL
[16:59:34.738]                       }
[16:59:34.738]                       if (!has_future || version < "1.8.0") {
[16:59:34.738]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.738]                           "", base::R.version$version.string), 
[16:59:34.738]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.738]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.738]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.738]                             "release", "version")], collapse = " "), 
[16:59:34.738]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.738]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.738]                           info)
[16:59:34.738]                         info <- base::paste(info, collapse = "; ")
[16:59:34.738]                         if (!has_future) {
[16:59:34.738]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.738]                             info)
[16:59:34.738]                         }
[16:59:34.738]                         else {
[16:59:34.738]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.738]                             info, version)
[16:59:34.738]                         }
[16:59:34.738]                         base::stop(msg)
[16:59:34.738]                       }
[16:59:34.738]                     })
[16:59:34.738]                   }
[16:59:34.738]                   ...future.strategy.old <- future::plan("list")
[16:59:34.738]                   options(future.plan = NULL)
[16:59:34.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.738]                 }
[16:59:34.738]                 ...future.workdir <- getwd()
[16:59:34.738]             }
[16:59:34.738]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.738]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.738]         }
[16:59:34.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.738]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.738]             base::names(...future.oldOptions))
[16:59:34.738]     }
[16:59:34.738]     if (FALSE) {
[16:59:34.738]     }
[16:59:34.738]     else {
[16:59:34.738]         if (TRUE) {
[16:59:34.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.738]                 open = "w")
[16:59:34.738]         }
[16:59:34.738]         else {
[16:59:34.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.738]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.738]         }
[16:59:34.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.738]             base::sink(type = "output", split = FALSE)
[16:59:34.738]             base::close(...future.stdout)
[16:59:34.738]         }, add = TRUE)
[16:59:34.738]     }
[16:59:34.738]     ...future.frame <- base::sys.nframe()
[16:59:34.738]     ...future.conditions <- base::list()
[16:59:34.738]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.738]     if (FALSE) {
[16:59:34.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.738]     }
[16:59:34.738]     ...future.result <- base::tryCatch({
[16:59:34.738]         base::withCallingHandlers({
[16:59:34.738]             ...future.value <- base::withVisible(base::local({
[16:59:34.738]                 do.call(function(...) {
[16:59:34.738]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.738]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.738]                     ...future.globals.maxSize)) {
[16:59:34.738]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.738]                     on.exit(options(oopts), add = TRUE)
[16:59:34.738]                   }
[16:59:34.738]                   {
[16:59:34.738]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.738]                       FUN = function(jj) {
[16:59:34.738]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.738]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.738]                       })
[16:59:34.738]                   }
[16:59:34.738]                 }, args = future.call.arguments)
[16:59:34.738]             }))
[16:59:34.738]             future::FutureResult(value = ...future.value$value, 
[16:59:34.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.738]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.738]                     ...future.globalenv.names))
[16:59:34.738]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.738]         }, condition = base::local({
[16:59:34.738]             c <- base::c
[16:59:34.738]             inherits <- base::inherits
[16:59:34.738]             invokeRestart <- base::invokeRestart
[16:59:34.738]             length <- base::length
[16:59:34.738]             list <- base::list
[16:59:34.738]             seq.int <- base::seq.int
[16:59:34.738]             signalCondition <- base::signalCondition
[16:59:34.738]             sys.calls <- base::sys.calls
[16:59:34.738]             `[[` <- base::`[[`
[16:59:34.738]             `+` <- base::`+`
[16:59:34.738]             `<<-` <- base::`<<-`
[16:59:34.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.738]                   3L)]
[16:59:34.738]             }
[16:59:34.738]             function(cond) {
[16:59:34.738]                 is_error <- inherits(cond, "error")
[16:59:34.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.738]                   NULL)
[16:59:34.738]                 if (is_error) {
[16:59:34.738]                   sessionInformation <- function() {
[16:59:34.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.738]                       search = base::search(), system = base::Sys.info())
[16:59:34.738]                   }
[16:59:34.738]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.738]                     cond$call), session = sessionInformation(), 
[16:59:34.738]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.738]                   signalCondition(cond)
[16:59:34.738]                 }
[16:59:34.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.738]                 "immediateCondition"))) {
[16:59:34.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.738]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.738]                   if (TRUE && !signal) {
[16:59:34.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.738]                     {
[16:59:34.738]                       inherits <- base::inherits
[16:59:34.738]                       invokeRestart <- base::invokeRestart
[16:59:34.738]                       is.null <- base::is.null
[16:59:34.738]                       muffled <- FALSE
[16:59:34.738]                       if (inherits(cond, "message")) {
[16:59:34.738]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.738]                         if (muffled) 
[16:59:34.738]                           invokeRestart("muffleMessage")
[16:59:34.738]                       }
[16:59:34.738]                       else if (inherits(cond, "warning")) {
[16:59:34.738]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.738]                         if (muffled) 
[16:59:34.738]                           invokeRestart("muffleWarning")
[16:59:34.738]                       }
[16:59:34.738]                       else if (inherits(cond, "condition")) {
[16:59:34.738]                         if (!is.null(pattern)) {
[16:59:34.738]                           computeRestarts <- base::computeRestarts
[16:59:34.738]                           grepl <- base::grepl
[16:59:34.738]                           restarts <- computeRestarts(cond)
[16:59:34.738]                           for (restart in restarts) {
[16:59:34.738]                             name <- restart$name
[16:59:34.738]                             if (is.null(name)) 
[16:59:34.738]                               next
[16:59:34.738]                             if (!grepl(pattern, name)) 
[16:59:34.738]                               next
[16:59:34.738]                             invokeRestart(restart)
[16:59:34.738]                             muffled <- TRUE
[16:59:34.738]                             break
[16:59:34.738]                           }
[16:59:34.738]                         }
[16:59:34.738]                       }
[16:59:34.738]                       invisible(muffled)
[16:59:34.738]                     }
[16:59:34.738]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.738]                   }
[16:59:34.738]                 }
[16:59:34.738]                 else {
[16:59:34.738]                   if (TRUE) {
[16:59:34.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.738]                     {
[16:59:34.738]                       inherits <- base::inherits
[16:59:34.738]                       invokeRestart <- base::invokeRestart
[16:59:34.738]                       is.null <- base::is.null
[16:59:34.738]                       muffled <- FALSE
[16:59:34.738]                       if (inherits(cond, "message")) {
[16:59:34.738]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.738]                         if (muffled) 
[16:59:34.738]                           invokeRestart("muffleMessage")
[16:59:34.738]                       }
[16:59:34.738]                       else if (inherits(cond, "warning")) {
[16:59:34.738]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.738]                         if (muffled) 
[16:59:34.738]                           invokeRestart("muffleWarning")
[16:59:34.738]                       }
[16:59:34.738]                       else if (inherits(cond, "condition")) {
[16:59:34.738]                         if (!is.null(pattern)) {
[16:59:34.738]                           computeRestarts <- base::computeRestarts
[16:59:34.738]                           grepl <- base::grepl
[16:59:34.738]                           restarts <- computeRestarts(cond)
[16:59:34.738]                           for (restart in restarts) {
[16:59:34.738]                             name <- restart$name
[16:59:34.738]                             if (is.null(name)) 
[16:59:34.738]                               next
[16:59:34.738]                             if (!grepl(pattern, name)) 
[16:59:34.738]                               next
[16:59:34.738]                             invokeRestart(restart)
[16:59:34.738]                             muffled <- TRUE
[16:59:34.738]                             break
[16:59:34.738]                           }
[16:59:34.738]                         }
[16:59:34.738]                       }
[16:59:34.738]                       invisible(muffled)
[16:59:34.738]                     }
[16:59:34.738]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.738]                   }
[16:59:34.738]                 }
[16:59:34.738]             }
[16:59:34.738]         }))
[16:59:34.738]     }, error = function(ex) {
[16:59:34.738]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.738]                 ...future.rng), started = ...future.startTime, 
[16:59:34.738]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.738]             version = "1.8"), class = "FutureResult")
[16:59:34.738]     }, finally = {
[16:59:34.738]         if (!identical(...future.workdir, getwd())) 
[16:59:34.738]             setwd(...future.workdir)
[16:59:34.738]         {
[16:59:34.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.738]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.738]             }
[16:59:34.738]             base::options(...future.oldOptions)
[16:59:34.738]             if (.Platform$OS.type == "windows") {
[16:59:34.738]                 old_names <- names(...future.oldEnvVars)
[16:59:34.738]                 envs <- base::Sys.getenv()
[16:59:34.738]                 names <- names(envs)
[16:59:34.738]                 common <- intersect(names, old_names)
[16:59:34.738]                 added <- setdiff(names, old_names)
[16:59:34.738]                 removed <- setdiff(old_names, names)
[16:59:34.738]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.738]                   envs[common]]
[16:59:34.738]                 NAMES <- toupper(changed)
[16:59:34.738]                 args <- list()
[16:59:34.738]                 for (kk in seq_along(NAMES)) {
[16:59:34.738]                   name <- changed[[kk]]
[16:59:34.738]                   NAME <- NAMES[[kk]]
[16:59:34.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.738]                     next
[16:59:34.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.738]                 }
[16:59:34.738]                 NAMES <- toupper(added)
[16:59:34.738]                 for (kk in seq_along(NAMES)) {
[16:59:34.738]                   name <- added[[kk]]
[16:59:34.738]                   NAME <- NAMES[[kk]]
[16:59:34.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.738]                     next
[16:59:34.738]                   args[[name]] <- ""
[16:59:34.738]                 }
[16:59:34.738]                 NAMES <- toupper(removed)
[16:59:34.738]                 for (kk in seq_along(NAMES)) {
[16:59:34.738]                   name <- removed[[kk]]
[16:59:34.738]                   NAME <- NAMES[[kk]]
[16:59:34.738]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.738]                     next
[16:59:34.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.738]                 }
[16:59:34.738]                 if (length(args) > 0) 
[16:59:34.738]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.738]             }
[16:59:34.738]             else {
[16:59:34.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.738]             }
[16:59:34.738]             {
[16:59:34.738]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.738]                   0L) {
[16:59:34.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.738]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.738]                   base::options(opts)
[16:59:34.738]                 }
[16:59:34.738]                 {
[16:59:34.738]                   {
[16:59:34.738]                     NULL
[16:59:34.738]                     RNGkind("Mersenne-Twister")
[16:59:34.738]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.738]                       inherits = FALSE)
[16:59:34.738]                   }
[16:59:34.738]                   options(future.plan = NULL)
[16:59:34.738]                   if (is.na(NA_character_)) 
[16:59:34.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.738]                     .init = FALSE)
[16:59:34.738]                 }
[16:59:34.738]             }
[16:59:34.738]         }
[16:59:34.738]     })
[16:59:34.738]     if (TRUE) {
[16:59:34.738]         base::sink(type = "output", split = FALSE)
[16:59:34.738]         if (TRUE) {
[16:59:34.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.738]         }
[16:59:34.738]         else {
[16:59:34.738]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.738]         }
[16:59:34.738]         base::close(...future.stdout)
[16:59:34.738]         ...future.stdout <- NULL
[16:59:34.738]     }
[16:59:34.738]     ...future.result$conditions <- ...future.conditions
[16:59:34.738]     ...future.result$finished <- base::Sys.time()
[16:59:34.738]     ...future.result
[16:59:34.738] }
[16:59:34.739] assign_globals() ...
[16:59:34.739] List of 5
[16:59:34.739]  $ ...future.FUN            :function (object, ...)  
[16:59:34.739]  $ future.call.arguments    : list()
[16:59:34.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.739]  $ ...future.elements_ii    :List of 3
[16:59:34.739]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.739]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.739]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.739]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.739]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.739]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.739]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.739]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.739]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.739]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.739]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.739]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.739]  $ ...future.seeds_ii       : NULL
[16:59:34.739]  $ ...future.globals.maxSize: NULL
[16:59:34.739]  - attr(*, "where")=List of 5
[16:59:34.739]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.739]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.739]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.739]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.739]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.739]  - attr(*, "resolved")= logi FALSE
[16:59:34.739]  - attr(*, "total_size")= num 1240
[16:59:34.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.739]  - attr(*, "already-done")= logi TRUE
[16:59:34.750] - copied ‘...future.FUN’ to environment
[16:59:34.750] - copied ‘future.call.arguments’ to environment
[16:59:34.750] - copied ‘...future.elements_ii’ to environment
[16:59:34.750] - copied ‘...future.seeds_ii’ to environment
[16:59:34.750] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.750] assign_globals() ... done
[16:59:34.751] plan(): Setting new future strategy stack:
[16:59:34.751] List of future strategies:
[16:59:34.751] 1. sequential:
[16:59:34.751]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.751]    - tweaked: FALSE
[16:59:34.751]    - call: NULL
[16:59:34.751] plan(): nbrOfWorkers() = 1
[16:59:34.754] plan(): Setting new future strategy stack:
[16:59:34.754] List of future strategies:
[16:59:34.754] 1. multisession:
[16:59:34.754]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.754]    - tweaked: FALSE
[16:59:34.754]    - call: plan(strategy)
[16:59:34.757] plan(): nbrOfWorkers() = 1
[16:59:34.758] SequentialFuture started (and completed)
[16:59:34.758] - Launch lazy future ... done
[16:59:34.758] run() for ‘SequentialFuture’ ... done
[16:59:34.758] Created future:
[16:59:34.758] SequentialFuture:
[16:59:34.758] Label: ‘future_by-1’
[16:59:34.758] Expression:
[16:59:34.758] {
[16:59:34.758]     do.call(function(...) {
[16:59:34.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.758]             on.exit(options(oopts), add = TRUE)
[16:59:34.758]         }
[16:59:34.758]         {
[16:59:34.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.758]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.758]             })
[16:59:34.758]         }
[16:59:34.758]     }, args = future.call.arguments)
[16:59:34.758] }
[16:59:34.758] Lazy evaluation: FALSE
[16:59:34.758] Asynchronous evaluation: FALSE
[16:59:34.758] Local evaluation: TRUE
[16:59:34.758] Environment: 0x562052784458
[16:59:34.758] Capture standard output: TRUE
[16:59:34.758] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.758] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.758] Packages: <none>
[16:59:34.758] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.758] Resolved: TRUE
[16:59:34.758] Value: 5.37 KiB of class ‘list’
[16:59:34.758] Early signaling: FALSE
[16:59:34.758] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.758] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.759] Chunk #1 of 1 ... DONE
[16:59:34.760] Launching 1 futures (chunks) ... DONE
[16:59:34.760] Resolving 1 futures (chunks) ...
[16:59:34.760] resolve() on list ...
[16:59:34.760]  recursive: 0
[16:59:34.760]  length: 1
[16:59:34.760] 
[16:59:34.760] resolved() for ‘SequentialFuture’ ...
[16:59:34.760] - state: ‘finished’
[16:59:34.760] - run: TRUE
[16:59:34.760] - result: ‘FutureResult’
[16:59:34.761] resolved() for ‘SequentialFuture’ ... done
[16:59:34.761] Future #1
[16:59:34.761] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.761] - nx: 1
[16:59:34.761] - relay: TRUE
[16:59:34.761] - stdout: TRUE
[16:59:34.761] - signal: TRUE
[16:59:34.761] - resignal: FALSE
[16:59:34.761] - force: TRUE
[16:59:34.761] - relayed: [n=1] FALSE
[16:59:34.761] - queued futures: [n=1] FALSE
[16:59:34.762]  - until=1
[16:59:34.762]  - relaying element #1
[16:59:34.762] - relayed: [n=1] TRUE
[16:59:34.762] - queued futures: [n=1] TRUE
[16:59:34.762] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.762]  length: 0 (resolved future 1)
[16:59:34.762] Relaying remaining futures
[16:59:34.762] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.762] - nx: 1
[16:59:34.762] - relay: TRUE
[16:59:34.763] - stdout: TRUE
[16:59:34.763] - signal: TRUE
[16:59:34.763] - resignal: FALSE
[16:59:34.763] - force: TRUE
[16:59:34.763] - relayed: [n=1] TRUE
[16:59:34.763] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.763] - relayed: [n=1] TRUE
[16:59:34.763] - queued futures: [n=1] TRUE
[16:59:34.763] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.763] resolve() on list ... DONE
[16:59:34.764]  - Number of value chunks collected: 1
[16:59:34.764] Resolving 1 futures (chunks) ... DONE
[16:59:34.764] Reducing values from 1 chunks ...
[16:59:34.764]  - Number of values collected after concatenation: 3
[16:59:34.764]  - Number of values expected: 3
[16:59:34.764] Reducing values from 1 chunks ... DONE
[16:59:34.764] future_lapply() ... DONE
[16:59:34.764] future_by_internal() ... DONE
[16:59:34.765] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:59:34.765] future_lapply() ...
[16:59:34.769] Number of chunks: 1
[16:59:34.770] getGlobalsAndPackagesXApply() ...
[16:59:34.770]  - future.globals: TRUE
[16:59:34.770] getGlobalsAndPackages() ...
[16:59:34.770] Searching for globals...
[16:59:34.771] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.771] Searching for globals ... DONE
[16:59:34.771] Resolving globals: FALSE
[16:59:34.772] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.772] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.772] - globals: [1] ‘FUN’
[16:59:34.772] 
[16:59:34.772] getGlobalsAndPackages() ... DONE
[16:59:34.773]  - globals found/used: [n=1] ‘FUN’
[16:59:34.773]  - needed namespaces: [n=0] 
[16:59:34.773] Finding globals ... DONE
[16:59:34.773]  - use_args: TRUE
[16:59:34.773]  - Getting '...' globals ...
[16:59:34.773] resolve() on list ...
[16:59:34.773]  recursive: 0
[16:59:34.773]  length: 1
[16:59:34.774]  elements: ‘...’
[16:59:34.774]  length: 0 (resolved future 1)
[16:59:34.774] resolve() on list ... DONE
[16:59:34.774]    - '...' content: [n=0] 
[16:59:34.774] List of 1
[16:59:34.774]  $ ...: list()
[16:59:34.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.774]  - attr(*, "where")=List of 1
[16:59:34.774]   ..$ ...:<environment: 0x5620527f2ab0> 
[16:59:34.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.774]  - attr(*, "resolved")= logi TRUE
[16:59:34.774]  - attr(*, "total_size")= num NA
[16:59:34.778]  - Getting '...' globals ... DONE
[16:59:34.779] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.779] List of 2
[16:59:34.779]  $ ...future.FUN:function (object, ...)  
[16:59:34.779]  $ ...          : list()
[16:59:34.779]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.779]  - attr(*, "where")=List of 2
[16:59:34.779]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.779]   ..$ ...          :<environment: 0x5620527f2ab0> 
[16:59:34.779]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.779]  - attr(*, "resolved")= logi FALSE
[16:59:34.779]  - attr(*, "total_size")= num 1240
[16:59:34.782] Packages to be attached in all futures: [n=0] 
[16:59:34.782] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.782] Number of futures (= number of chunks): 1
[16:59:34.782] Launching 1 futures (chunks) ...
[16:59:34.782] Chunk #1 of 1 ...
[16:59:34.782]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.782] getGlobalsAndPackages() ...
[16:59:34.783] Searching for globals...
[16:59:34.783] 
[16:59:34.783] Searching for globals ... DONE
[16:59:34.783] - globals: [0] <none>
[16:59:34.783] getGlobalsAndPackages() ... DONE
[16:59:34.783]    + additional globals found: [n=0] 
[16:59:34.784]    + additional namespaces needed: [n=0] 
[16:59:34.784]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.784]  - seeds: <none>
[16:59:34.784]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.784] getGlobalsAndPackages() ...
[16:59:34.784] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.784] Resolving globals: FALSE
[16:59:34.784] Tweak future expression to call with '...' arguments ...
[16:59:34.784] {
[16:59:34.784]     do.call(function(...) {
[16:59:34.784]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.784]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.784]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.784]             on.exit(options(oopts), add = TRUE)
[16:59:34.784]         }
[16:59:34.784]         {
[16:59:34.784]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.784]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.784]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.784]             })
[16:59:34.784]         }
[16:59:34.784]     }, args = future.call.arguments)
[16:59:34.784] }
[16:59:34.785] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.785] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.785] 
[16:59:34.785] getGlobalsAndPackages() ... DONE
[16:59:34.785] run() for ‘Future’ ...
[16:59:34.786] - state: ‘created’
[16:59:34.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:34.789] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.789] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.789]   - Field: ‘label’
[16:59:34.790]   - Field: ‘local’
[16:59:34.790]   - Field: ‘owner’
[16:59:34.790]   - Field: ‘envir’
[16:59:34.790]   - Field: ‘packages’
[16:59:34.790]   - Field: ‘gc’
[16:59:34.790]   - Field: ‘conditions’
[16:59:34.790]   - Field: ‘expr’
[16:59:34.790]   - Field: ‘uuid’
[16:59:34.790]   - Field: ‘seed’
[16:59:34.790]   - Field: ‘version’
[16:59:34.790]   - Field: ‘result’
[16:59:34.791]   - Field: ‘asynchronous’
[16:59:34.791]   - Field: ‘calls’
[16:59:34.791]   - Field: ‘globals’
[16:59:34.791]   - Field: ‘stdout’
[16:59:34.791]   - Field: ‘earlySignal’
[16:59:34.791]   - Field: ‘lazy’
[16:59:34.791]   - Field: ‘state’
[16:59:34.791] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.791] - Launch lazy future ...
[16:59:34.792] Packages needed by the future expression (n = 0): <none>
[16:59:34.792] Packages needed by future strategies (n = 0): <none>
[16:59:34.792] {
[16:59:34.792]     {
[16:59:34.792]         {
[16:59:34.792]             ...future.startTime <- base::Sys.time()
[16:59:34.792]             {
[16:59:34.792]                 {
[16:59:34.792]                   {
[16:59:34.792]                     base::local({
[16:59:34.792]                       has_future <- base::requireNamespace("future", 
[16:59:34.792]                         quietly = TRUE)
[16:59:34.792]                       if (has_future) {
[16:59:34.792]                         ns <- base::getNamespace("future")
[16:59:34.792]                         version <- ns[[".package"]][["version"]]
[16:59:34.792]                         if (is.null(version)) 
[16:59:34.792]                           version <- utils::packageVersion("future")
[16:59:34.792]                       }
[16:59:34.792]                       else {
[16:59:34.792]                         version <- NULL
[16:59:34.792]                       }
[16:59:34.792]                       if (!has_future || version < "1.8.0") {
[16:59:34.792]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.792]                           "", base::R.version$version.string), 
[16:59:34.792]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.792]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.792]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.792]                             "release", "version")], collapse = " "), 
[16:59:34.792]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.792]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.792]                           info)
[16:59:34.792]                         info <- base::paste(info, collapse = "; ")
[16:59:34.792]                         if (!has_future) {
[16:59:34.792]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.792]                             info)
[16:59:34.792]                         }
[16:59:34.792]                         else {
[16:59:34.792]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.792]                             info, version)
[16:59:34.792]                         }
[16:59:34.792]                         base::stop(msg)
[16:59:34.792]                       }
[16:59:34.792]                     })
[16:59:34.792]                   }
[16:59:34.792]                   ...future.strategy.old <- future::plan("list")
[16:59:34.792]                   options(future.plan = NULL)
[16:59:34.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.792]                 }
[16:59:34.792]                 ...future.workdir <- getwd()
[16:59:34.792]             }
[16:59:34.792]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.792]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.792]         }
[16:59:34.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.792]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.792]             base::names(...future.oldOptions))
[16:59:34.792]     }
[16:59:34.792]     if (FALSE) {
[16:59:34.792]     }
[16:59:34.792]     else {
[16:59:34.792]         if (TRUE) {
[16:59:34.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.792]                 open = "w")
[16:59:34.792]         }
[16:59:34.792]         else {
[16:59:34.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.792]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.792]         }
[16:59:34.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.792]             base::sink(type = "output", split = FALSE)
[16:59:34.792]             base::close(...future.stdout)
[16:59:34.792]         }, add = TRUE)
[16:59:34.792]     }
[16:59:34.792]     ...future.frame <- base::sys.nframe()
[16:59:34.792]     ...future.conditions <- base::list()
[16:59:34.792]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.792]     if (FALSE) {
[16:59:34.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.792]     }
[16:59:34.792]     ...future.result <- base::tryCatch({
[16:59:34.792]         base::withCallingHandlers({
[16:59:34.792]             ...future.value <- base::withVisible(base::local({
[16:59:34.792]                 do.call(function(...) {
[16:59:34.792]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.792]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.792]                     ...future.globals.maxSize)) {
[16:59:34.792]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.792]                     on.exit(options(oopts), add = TRUE)
[16:59:34.792]                   }
[16:59:34.792]                   {
[16:59:34.792]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.792]                       FUN = function(jj) {
[16:59:34.792]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.792]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.792]                       })
[16:59:34.792]                   }
[16:59:34.792]                 }, args = future.call.arguments)
[16:59:34.792]             }))
[16:59:34.792]             future::FutureResult(value = ...future.value$value, 
[16:59:34.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.792]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.792]                     ...future.globalenv.names))
[16:59:34.792]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.792]         }, condition = base::local({
[16:59:34.792]             c <- base::c
[16:59:34.792]             inherits <- base::inherits
[16:59:34.792]             invokeRestart <- base::invokeRestart
[16:59:34.792]             length <- base::length
[16:59:34.792]             list <- base::list
[16:59:34.792]             seq.int <- base::seq.int
[16:59:34.792]             signalCondition <- base::signalCondition
[16:59:34.792]             sys.calls <- base::sys.calls
[16:59:34.792]             `[[` <- base::`[[`
[16:59:34.792]             `+` <- base::`+`
[16:59:34.792]             `<<-` <- base::`<<-`
[16:59:34.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.792]                   3L)]
[16:59:34.792]             }
[16:59:34.792]             function(cond) {
[16:59:34.792]                 is_error <- inherits(cond, "error")
[16:59:34.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.792]                   NULL)
[16:59:34.792]                 if (is_error) {
[16:59:34.792]                   sessionInformation <- function() {
[16:59:34.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.792]                       search = base::search(), system = base::Sys.info())
[16:59:34.792]                   }
[16:59:34.792]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.792]                     cond$call), session = sessionInformation(), 
[16:59:34.792]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.792]                   signalCondition(cond)
[16:59:34.792]                 }
[16:59:34.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.792]                 "immediateCondition"))) {
[16:59:34.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.792]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.792]                   if (TRUE && !signal) {
[16:59:34.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.792]                     {
[16:59:34.792]                       inherits <- base::inherits
[16:59:34.792]                       invokeRestart <- base::invokeRestart
[16:59:34.792]                       is.null <- base::is.null
[16:59:34.792]                       muffled <- FALSE
[16:59:34.792]                       if (inherits(cond, "message")) {
[16:59:34.792]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.792]                         if (muffled) 
[16:59:34.792]                           invokeRestart("muffleMessage")
[16:59:34.792]                       }
[16:59:34.792]                       else if (inherits(cond, "warning")) {
[16:59:34.792]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.792]                         if (muffled) 
[16:59:34.792]                           invokeRestart("muffleWarning")
[16:59:34.792]                       }
[16:59:34.792]                       else if (inherits(cond, "condition")) {
[16:59:34.792]                         if (!is.null(pattern)) {
[16:59:34.792]                           computeRestarts <- base::computeRestarts
[16:59:34.792]                           grepl <- base::grepl
[16:59:34.792]                           restarts <- computeRestarts(cond)
[16:59:34.792]                           for (restart in restarts) {
[16:59:34.792]                             name <- restart$name
[16:59:34.792]                             if (is.null(name)) 
[16:59:34.792]                               next
[16:59:34.792]                             if (!grepl(pattern, name)) 
[16:59:34.792]                               next
[16:59:34.792]                             invokeRestart(restart)
[16:59:34.792]                             muffled <- TRUE
[16:59:34.792]                             break
[16:59:34.792]                           }
[16:59:34.792]                         }
[16:59:34.792]                       }
[16:59:34.792]                       invisible(muffled)
[16:59:34.792]                     }
[16:59:34.792]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.792]                   }
[16:59:34.792]                 }
[16:59:34.792]                 else {
[16:59:34.792]                   if (TRUE) {
[16:59:34.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.792]                     {
[16:59:34.792]                       inherits <- base::inherits
[16:59:34.792]                       invokeRestart <- base::invokeRestart
[16:59:34.792]                       is.null <- base::is.null
[16:59:34.792]                       muffled <- FALSE
[16:59:34.792]                       if (inherits(cond, "message")) {
[16:59:34.792]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.792]                         if (muffled) 
[16:59:34.792]                           invokeRestart("muffleMessage")
[16:59:34.792]                       }
[16:59:34.792]                       else if (inherits(cond, "warning")) {
[16:59:34.792]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.792]                         if (muffled) 
[16:59:34.792]                           invokeRestart("muffleWarning")
[16:59:34.792]                       }
[16:59:34.792]                       else if (inherits(cond, "condition")) {
[16:59:34.792]                         if (!is.null(pattern)) {
[16:59:34.792]                           computeRestarts <- base::computeRestarts
[16:59:34.792]                           grepl <- base::grepl
[16:59:34.792]                           restarts <- computeRestarts(cond)
[16:59:34.792]                           for (restart in restarts) {
[16:59:34.792]                             name <- restart$name
[16:59:34.792]                             if (is.null(name)) 
[16:59:34.792]                               next
[16:59:34.792]                             if (!grepl(pattern, name)) 
[16:59:34.792]                               next
[16:59:34.792]                             invokeRestart(restart)
[16:59:34.792]                             muffled <- TRUE
[16:59:34.792]                             break
[16:59:34.792]                           }
[16:59:34.792]                         }
[16:59:34.792]                       }
[16:59:34.792]                       invisible(muffled)
[16:59:34.792]                     }
[16:59:34.792]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.792]                   }
[16:59:34.792]                 }
[16:59:34.792]             }
[16:59:34.792]         }))
[16:59:34.792]     }, error = function(ex) {
[16:59:34.792]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.792]                 ...future.rng), started = ...future.startTime, 
[16:59:34.792]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.792]             version = "1.8"), class = "FutureResult")
[16:59:34.792]     }, finally = {
[16:59:34.792]         if (!identical(...future.workdir, getwd())) 
[16:59:34.792]             setwd(...future.workdir)
[16:59:34.792]         {
[16:59:34.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.792]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.792]             }
[16:59:34.792]             base::options(...future.oldOptions)
[16:59:34.792]             if (.Platform$OS.type == "windows") {
[16:59:34.792]                 old_names <- names(...future.oldEnvVars)
[16:59:34.792]                 envs <- base::Sys.getenv()
[16:59:34.792]                 names <- names(envs)
[16:59:34.792]                 common <- intersect(names, old_names)
[16:59:34.792]                 added <- setdiff(names, old_names)
[16:59:34.792]                 removed <- setdiff(old_names, names)
[16:59:34.792]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.792]                   envs[common]]
[16:59:34.792]                 NAMES <- toupper(changed)
[16:59:34.792]                 args <- list()
[16:59:34.792]                 for (kk in seq_along(NAMES)) {
[16:59:34.792]                   name <- changed[[kk]]
[16:59:34.792]                   NAME <- NAMES[[kk]]
[16:59:34.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.792]                     next
[16:59:34.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.792]                 }
[16:59:34.792]                 NAMES <- toupper(added)
[16:59:34.792]                 for (kk in seq_along(NAMES)) {
[16:59:34.792]                   name <- added[[kk]]
[16:59:34.792]                   NAME <- NAMES[[kk]]
[16:59:34.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.792]                     next
[16:59:34.792]                   args[[name]] <- ""
[16:59:34.792]                 }
[16:59:34.792]                 NAMES <- toupper(removed)
[16:59:34.792]                 for (kk in seq_along(NAMES)) {
[16:59:34.792]                   name <- removed[[kk]]
[16:59:34.792]                   NAME <- NAMES[[kk]]
[16:59:34.792]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.792]                     next
[16:59:34.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.792]                 }
[16:59:34.792]                 if (length(args) > 0) 
[16:59:34.792]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.792]             }
[16:59:34.792]             else {
[16:59:34.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.792]             }
[16:59:34.792]             {
[16:59:34.792]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.792]                   0L) {
[16:59:34.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.792]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.792]                   base::options(opts)
[16:59:34.792]                 }
[16:59:34.792]                 {
[16:59:34.792]                   {
[16:59:34.792]                     NULL
[16:59:34.792]                     RNGkind("Mersenne-Twister")
[16:59:34.792]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.792]                       inherits = FALSE)
[16:59:34.792]                   }
[16:59:34.792]                   options(future.plan = NULL)
[16:59:34.792]                   if (is.na(NA_character_)) 
[16:59:34.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.792]                     .init = FALSE)
[16:59:34.792]                 }
[16:59:34.792]             }
[16:59:34.792]         }
[16:59:34.792]     })
[16:59:34.792]     if (TRUE) {
[16:59:34.792]         base::sink(type = "output", split = FALSE)
[16:59:34.792]         if (TRUE) {
[16:59:34.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.792]         }
[16:59:34.792]         else {
[16:59:34.792]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.792]         }
[16:59:34.792]         base::close(...future.stdout)
[16:59:34.792]         ...future.stdout <- NULL
[16:59:34.792]     }
[16:59:34.792]     ...future.result$conditions <- ...future.conditions
[16:59:34.792]     ...future.result$finished <- base::Sys.time()
[16:59:34.792]     ...future.result
[16:59:34.792] }
[16:59:34.794] assign_globals() ...
[16:59:34.794] List of 5
[16:59:34.794]  $ ...future.FUN            :function (object, ...)  
[16:59:34.794]  $ future.call.arguments    : list()
[16:59:34.794]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.794]  $ ...future.elements_ii    :List of 3
[16:59:34.794]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.794]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.794]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.794]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.794]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.794]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.794]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.794]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.794]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.794]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.794]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.794]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.794]  $ ...future.seeds_ii       : NULL
[16:59:34.794]  $ ...future.globals.maxSize: NULL
[16:59:34.794]  - attr(*, "where")=List of 5
[16:59:34.794]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.794]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.794]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.794]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.794]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.794]  - attr(*, "resolved")= logi FALSE
[16:59:34.794]  - attr(*, "total_size")= num 1240
[16:59:34.794]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.794]  - attr(*, "already-done")= logi TRUE
[16:59:34.804] - copied ‘...future.FUN’ to environment
[16:59:34.804] - copied ‘future.call.arguments’ to environment
[16:59:34.804] - copied ‘...future.elements_ii’ to environment
[16:59:34.805] - copied ‘...future.seeds_ii’ to environment
[16:59:34.805] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.805] assign_globals() ... done
[16:59:34.805] plan(): Setting new future strategy stack:
[16:59:34.805] List of future strategies:
[16:59:34.805] 1. sequential:
[16:59:34.805]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.805]    - tweaked: FALSE
[16:59:34.805]    - call: NULL
[16:59:34.806] plan(): nbrOfWorkers() = 1
[16:59:34.808] plan(): Setting new future strategy stack:
[16:59:34.808] List of future strategies:
[16:59:34.808] 1. multisession:
[16:59:34.808]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:34.808]    - tweaked: FALSE
[16:59:34.808]    - call: plan(strategy)
[16:59:34.812] plan(): nbrOfWorkers() = 1
[16:59:34.812] SequentialFuture started (and completed)
[16:59:34.812] - Launch lazy future ... done
[16:59:34.812] run() for ‘SequentialFuture’ ... done
[16:59:34.813] Created future:
[16:59:34.813] SequentialFuture:
[16:59:34.813] Label: ‘future_by-1’
[16:59:34.813] Expression:
[16:59:34.813] {
[16:59:34.813]     do.call(function(...) {
[16:59:34.813]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.813]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.813]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.813]             on.exit(options(oopts), add = TRUE)
[16:59:34.813]         }
[16:59:34.813]         {
[16:59:34.813]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.813]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.813]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.813]             })
[16:59:34.813]         }
[16:59:34.813]     }, args = future.call.arguments)
[16:59:34.813] }
[16:59:34.813] Lazy evaluation: FALSE
[16:59:34.813] Asynchronous evaluation: FALSE
[16:59:34.813] Local evaluation: TRUE
[16:59:34.813] Environment: 0x5620527ae6c0
[16:59:34.813] Capture standard output: TRUE
[16:59:34.813] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.813] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.813] Packages: <none>
[16:59:34.813] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.813] Resolved: TRUE
[16:59:34.813] Value: 5.37 KiB of class ‘list’
[16:59:34.813] Early signaling: FALSE
[16:59:34.813] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.813] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.814] Chunk #1 of 1 ... DONE
[16:59:34.814] Launching 1 futures (chunks) ... DONE
[16:59:34.814] Resolving 1 futures (chunks) ...
[16:59:34.815] resolve() on list ...
[16:59:34.815]  recursive: 0
[16:59:34.815]  length: 1
[16:59:34.815] 
[16:59:34.815] resolved() for ‘SequentialFuture’ ...
[16:59:34.815] - state: ‘finished’
[16:59:34.815] - run: TRUE
[16:59:34.815] - result: ‘FutureResult’
[16:59:34.815] resolved() for ‘SequentialFuture’ ... done
[16:59:34.815] Future #1
[16:59:34.816] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.816] - nx: 1
[16:59:34.816] - relay: TRUE
[16:59:34.816] - stdout: TRUE
[16:59:34.816] - signal: TRUE
[16:59:34.816] - resignal: FALSE
[16:59:34.816] - force: TRUE
[16:59:34.816] - relayed: [n=1] FALSE
[16:59:34.816] - queued futures: [n=1] FALSE
[16:59:34.816]  - until=1
[16:59:34.816]  - relaying element #1
[16:59:34.817] - relayed: [n=1] TRUE
[16:59:34.817] - queued futures: [n=1] TRUE
[16:59:34.817] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.817]  length: 0 (resolved future 1)
[16:59:34.817] Relaying remaining futures
[16:59:34.817] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.817] - nx: 1
[16:59:34.817] - relay: TRUE
[16:59:34.817] - stdout: TRUE
[16:59:34.817] - signal: TRUE
[16:59:34.818] - resignal: FALSE
[16:59:34.818] - force: TRUE
[16:59:34.818] - relayed: [n=1] TRUE
[16:59:34.818] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.818] - relayed: [n=1] TRUE
[16:59:34.818] - queued futures: [n=1] TRUE
[16:59:34.818] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.818] resolve() on list ... DONE
[16:59:34.818]  - Number of value chunks collected: 1
[16:59:34.818] Resolving 1 futures (chunks) ... DONE
[16:59:34.818] Reducing values from 1 chunks ...
[16:59:34.819]  - Number of values collected after concatenation: 3
[16:59:34.819]  - Number of values expected: 3
[16:59:34.819] Reducing values from 1 chunks ... DONE
[16:59:34.819] future_lapply() ... DONE
[16:59:34.819] future_by_internal() ... DONE
[16:59:34.820] future_by_internal() ...
Testing with 1 cores ... DONE
Testing with 2 cores ...
- plan('sequential') ...
[16:59:34.821] plan(): Setting new future strategy stack:
[16:59:34.821] List of future strategies:
[16:59:34.821] 1. sequential:
[16:59:34.821]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.821]    - tweaked: FALSE
[16:59:34.821]    - call: plan(strategy)
[16:59:34.821] plan(): nbrOfWorkers() = 1
[16:59:34.821] future_by_internal() ...
[16:59:34.822] future_lapply() ...
[16:59:34.822] Number of chunks: 1
[16:59:34.822] getGlobalsAndPackagesXApply() ...
[16:59:34.822]  - future.globals: TRUE
[16:59:34.822] getGlobalsAndPackages() ...
[16:59:34.823] Searching for globals...
[16:59:34.824] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.824] Searching for globals ... DONE
[16:59:34.824] Resolving globals: FALSE
[16:59:34.824] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.825] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.825] - globals: [1] ‘FUN’
[16:59:34.825] 
[16:59:34.825] getGlobalsAndPackages() ... DONE
[16:59:34.825]  - globals found/used: [n=1] ‘FUN’
[16:59:34.825]  - needed namespaces: [n=0] 
[16:59:34.825] Finding globals ... DONE
[16:59:34.825]  - use_args: TRUE
[16:59:34.825]  - Getting '...' globals ...
[16:59:34.826] resolve() on list ...
[16:59:34.826]  recursive: 0
[16:59:34.826]  length: 1
[16:59:34.826]  elements: ‘...’
[16:59:34.826]  length: 0 (resolved future 1)
[16:59:34.826] resolve() on list ... DONE
[16:59:34.826]    - '...' content: [n=0] 
[16:59:34.826] List of 1
[16:59:34.826]  $ ...: list()
[16:59:34.826]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.826]  - attr(*, "where")=List of 1
[16:59:34.826]   ..$ ...:<environment: 0x5620529a43b8> 
[16:59:34.826]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.826]  - attr(*, "resolved")= logi TRUE
[16:59:34.826]  - attr(*, "total_size")= num NA
[16:59:34.831]  - Getting '...' globals ... DONE
[16:59:34.831] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.831] List of 2
[16:59:34.831]  $ ...future.FUN:function (object, ...)  
[16:59:34.831]  $ ...          : list()
[16:59:34.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.831]  - attr(*, "where")=List of 2
[16:59:34.831]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.831]   ..$ ...          :<environment: 0x5620529a43b8> 
[16:59:34.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.831]  - attr(*, "resolved")= logi FALSE
[16:59:34.831]  - attr(*, "total_size")= num 1240
[16:59:34.834] Packages to be attached in all futures: [n=0] 
[16:59:34.834] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.834] Number of futures (= number of chunks): 1
[16:59:34.834] Launching 1 futures (chunks) ...
[16:59:34.834] Chunk #1 of 1 ...
[16:59:34.835]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.835] getGlobalsAndPackages() ...
[16:59:34.835] Searching for globals...
[16:59:34.835] 
[16:59:34.835] Searching for globals ... DONE
[16:59:34.835] - globals: [0] <none>
[16:59:34.835] getGlobalsAndPackages() ... DONE
[16:59:34.836]    + additional globals found: [n=0] 
[16:59:34.836]    + additional namespaces needed: [n=0] 
[16:59:34.836]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.836]  - seeds: <none>
[16:59:34.836]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.836] getGlobalsAndPackages() ...
[16:59:34.836] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.836] Resolving globals: FALSE
[16:59:34.836] Tweak future expression to call with '...' arguments ...
[16:59:34.836] {
[16:59:34.836]     do.call(function(...) {
[16:59:34.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.836]             on.exit(options(oopts), add = TRUE)
[16:59:34.836]         }
[16:59:34.836]         {
[16:59:34.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.836]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.836]             })
[16:59:34.836]         }
[16:59:34.836]     }, args = future.call.arguments)
[16:59:34.836] }
[16:59:34.837] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.837] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.837] 
[16:59:34.837] getGlobalsAndPackages() ... DONE
[16:59:34.838] run() for ‘Future’ ...
[16:59:34.838] - state: ‘created’
[16:59:34.838] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:34.838] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.838]   - Field: ‘label’
[16:59:34.838]   - Field: ‘local’
[16:59:34.838]   - Field: ‘owner’
[16:59:34.839]   - Field: ‘envir’
[16:59:34.839]   - Field: ‘packages’
[16:59:34.839]   - Field: ‘gc’
[16:59:34.839]   - Field: ‘conditions’
[16:59:34.839]   - Field: ‘expr’
[16:59:34.839]   - Field: ‘uuid’
[16:59:34.839]   - Field: ‘seed’
[16:59:34.839]   - Field: ‘version’
[16:59:34.839]   - Field: ‘result’
[16:59:34.839]   - Field: ‘asynchronous’
[16:59:34.840]   - Field: ‘calls’
[16:59:34.840]   - Field: ‘globals’
[16:59:34.840]   - Field: ‘stdout’
[16:59:34.840]   - Field: ‘earlySignal’
[16:59:34.840]   - Field: ‘lazy’
[16:59:34.840]   - Field: ‘state’
[16:59:34.840] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.840] - Launch lazy future ...
[16:59:34.840] Packages needed by the future expression (n = 0): <none>
[16:59:34.840] Packages needed by future strategies (n = 0): <none>
[16:59:34.841] {
[16:59:34.841]     {
[16:59:34.841]         {
[16:59:34.841]             ...future.startTime <- base::Sys.time()
[16:59:34.841]             {
[16:59:34.841]                 {
[16:59:34.841]                   {
[16:59:34.841]                     base::local({
[16:59:34.841]                       has_future <- base::requireNamespace("future", 
[16:59:34.841]                         quietly = TRUE)
[16:59:34.841]                       if (has_future) {
[16:59:34.841]                         ns <- base::getNamespace("future")
[16:59:34.841]                         version <- ns[[".package"]][["version"]]
[16:59:34.841]                         if (is.null(version)) 
[16:59:34.841]                           version <- utils::packageVersion("future")
[16:59:34.841]                       }
[16:59:34.841]                       else {
[16:59:34.841]                         version <- NULL
[16:59:34.841]                       }
[16:59:34.841]                       if (!has_future || version < "1.8.0") {
[16:59:34.841]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.841]                           "", base::R.version$version.string), 
[16:59:34.841]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.841]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.841]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.841]                             "release", "version")], collapse = " "), 
[16:59:34.841]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.841]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.841]                           info)
[16:59:34.841]                         info <- base::paste(info, collapse = "; ")
[16:59:34.841]                         if (!has_future) {
[16:59:34.841]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.841]                             info)
[16:59:34.841]                         }
[16:59:34.841]                         else {
[16:59:34.841]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.841]                             info, version)
[16:59:34.841]                         }
[16:59:34.841]                         base::stop(msg)
[16:59:34.841]                       }
[16:59:34.841]                     })
[16:59:34.841]                   }
[16:59:34.841]                   ...future.strategy.old <- future::plan("list")
[16:59:34.841]                   options(future.plan = NULL)
[16:59:34.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.841]                 }
[16:59:34.841]                 ...future.workdir <- getwd()
[16:59:34.841]             }
[16:59:34.841]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.841]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.841]         }
[16:59:34.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.841]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.841]             base::names(...future.oldOptions))
[16:59:34.841]     }
[16:59:34.841]     if (FALSE) {
[16:59:34.841]     }
[16:59:34.841]     else {
[16:59:34.841]         if (TRUE) {
[16:59:34.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.841]                 open = "w")
[16:59:34.841]         }
[16:59:34.841]         else {
[16:59:34.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.841]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.841]         }
[16:59:34.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.841]             base::sink(type = "output", split = FALSE)
[16:59:34.841]             base::close(...future.stdout)
[16:59:34.841]         }, add = TRUE)
[16:59:34.841]     }
[16:59:34.841]     ...future.frame <- base::sys.nframe()
[16:59:34.841]     ...future.conditions <- base::list()
[16:59:34.841]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.841]     if (FALSE) {
[16:59:34.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.841]     }
[16:59:34.841]     ...future.result <- base::tryCatch({
[16:59:34.841]         base::withCallingHandlers({
[16:59:34.841]             ...future.value <- base::withVisible(base::local({
[16:59:34.841]                 do.call(function(...) {
[16:59:34.841]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.841]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.841]                     ...future.globals.maxSize)) {
[16:59:34.841]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.841]                     on.exit(options(oopts), add = TRUE)
[16:59:34.841]                   }
[16:59:34.841]                   {
[16:59:34.841]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.841]                       FUN = function(jj) {
[16:59:34.841]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.841]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.841]                       })
[16:59:34.841]                   }
[16:59:34.841]                 }, args = future.call.arguments)
[16:59:34.841]             }))
[16:59:34.841]             future::FutureResult(value = ...future.value$value, 
[16:59:34.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.841]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.841]                     ...future.globalenv.names))
[16:59:34.841]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.841]         }, condition = base::local({
[16:59:34.841]             c <- base::c
[16:59:34.841]             inherits <- base::inherits
[16:59:34.841]             invokeRestart <- base::invokeRestart
[16:59:34.841]             length <- base::length
[16:59:34.841]             list <- base::list
[16:59:34.841]             seq.int <- base::seq.int
[16:59:34.841]             signalCondition <- base::signalCondition
[16:59:34.841]             sys.calls <- base::sys.calls
[16:59:34.841]             `[[` <- base::`[[`
[16:59:34.841]             `+` <- base::`+`
[16:59:34.841]             `<<-` <- base::`<<-`
[16:59:34.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.841]                   3L)]
[16:59:34.841]             }
[16:59:34.841]             function(cond) {
[16:59:34.841]                 is_error <- inherits(cond, "error")
[16:59:34.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.841]                   NULL)
[16:59:34.841]                 if (is_error) {
[16:59:34.841]                   sessionInformation <- function() {
[16:59:34.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.841]                       search = base::search(), system = base::Sys.info())
[16:59:34.841]                   }
[16:59:34.841]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.841]                     cond$call), session = sessionInformation(), 
[16:59:34.841]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.841]                   signalCondition(cond)
[16:59:34.841]                 }
[16:59:34.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.841]                 "immediateCondition"))) {
[16:59:34.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.841]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.841]                   if (TRUE && !signal) {
[16:59:34.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.841]                     {
[16:59:34.841]                       inherits <- base::inherits
[16:59:34.841]                       invokeRestart <- base::invokeRestart
[16:59:34.841]                       is.null <- base::is.null
[16:59:34.841]                       muffled <- FALSE
[16:59:34.841]                       if (inherits(cond, "message")) {
[16:59:34.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.841]                         if (muffled) 
[16:59:34.841]                           invokeRestart("muffleMessage")
[16:59:34.841]                       }
[16:59:34.841]                       else if (inherits(cond, "warning")) {
[16:59:34.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.841]                         if (muffled) 
[16:59:34.841]                           invokeRestart("muffleWarning")
[16:59:34.841]                       }
[16:59:34.841]                       else if (inherits(cond, "condition")) {
[16:59:34.841]                         if (!is.null(pattern)) {
[16:59:34.841]                           computeRestarts <- base::computeRestarts
[16:59:34.841]                           grepl <- base::grepl
[16:59:34.841]                           restarts <- computeRestarts(cond)
[16:59:34.841]                           for (restart in restarts) {
[16:59:34.841]                             name <- restart$name
[16:59:34.841]                             if (is.null(name)) 
[16:59:34.841]                               next
[16:59:34.841]                             if (!grepl(pattern, name)) 
[16:59:34.841]                               next
[16:59:34.841]                             invokeRestart(restart)
[16:59:34.841]                             muffled <- TRUE
[16:59:34.841]                             break
[16:59:34.841]                           }
[16:59:34.841]                         }
[16:59:34.841]                       }
[16:59:34.841]                       invisible(muffled)
[16:59:34.841]                     }
[16:59:34.841]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.841]                   }
[16:59:34.841]                 }
[16:59:34.841]                 else {
[16:59:34.841]                   if (TRUE) {
[16:59:34.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.841]                     {
[16:59:34.841]                       inherits <- base::inherits
[16:59:34.841]                       invokeRestart <- base::invokeRestart
[16:59:34.841]                       is.null <- base::is.null
[16:59:34.841]                       muffled <- FALSE
[16:59:34.841]                       if (inherits(cond, "message")) {
[16:59:34.841]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.841]                         if (muffled) 
[16:59:34.841]                           invokeRestart("muffleMessage")
[16:59:34.841]                       }
[16:59:34.841]                       else if (inherits(cond, "warning")) {
[16:59:34.841]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.841]                         if (muffled) 
[16:59:34.841]                           invokeRestart("muffleWarning")
[16:59:34.841]                       }
[16:59:34.841]                       else if (inherits(cond, "condition")) {
[16:59:34.841]                         if (!is.null(pattern)) {
[16:59:34.841]                           computeRestarts <- base::computeRestarts
[16:59:34.841]                           grepl <- base::grepl
[16:59:34.841]                           restarts <- computeRestarts(cond)
[16:59:34.841]                           for (restart in restarts) {
[16:59:34.841]                             name <- restart$name
[16:59:34.841]                             if (is.null(name)) 
[16:59:34.841]                               next
[16:59:34.841]                             if (!grepl(pattern, name)) 
[16:59:34.841]                               next
[16:59:34.841]                             invokeRestart(restart)
[16:59:34.841]                             muffled <- TRUE
[16:59:34.841]                             break
[16:59:34.841]                           }
[16:59:34.841]                         }
[16:59:34.841]                       }
[16:59:34.841]                       invisible(muffled)
[16:59:34.841]                     }
[16:59:34.841]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.841]                   }
[16:59:34.841]                 }
[16:59:34.841]             }
[16:59:34.841]         }))
[16:59:34.841]     }, error = function(ex) {
[16:59:34.841]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.841]                 ...future.rng), started = ...future.startTime, 
[16:59:34.841]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.841]             version = "1.8"), class = "FutureResult")
[16:59:34.841]     }, finally = {
[16:59:34.841]         if (!identical(...future.workdir, getwd())) 
[16:59:34.841]             setwd(...future.workdir)
[16:59:34.841]         {
[16:59:34.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.841]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.841]             }
[16:59:34.841]             base::options(...future.oldOptions)
[16:59:34.841]             if (.Platform$OS.type == "windows") {
[16:59:34.841]                 old_names <- names(...future.oldEnvVars)
[16:59:34.841]                 envs <- base::Sys.getenv()
[16:59:34.841]                 names <- names(envs)
[16:59:34.841]                 common <- intersect(names, old_names)
[16:59:34.841]                 added <- setdiff(names, old_names)
[16:59:34.841]                 removed <- setdiff(old_names, names)
[16:59:34.841]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.841]                   envs[common]]
[16:59:34.841]                 NAMES <- toupper(changed)
[16:59:34.841]                 args <- list()
[16:59:34.841]                 for (kk in seq_along(NAMES)) {
[16:59:34.841]                   name <- changed[[kk]]
[16:59:34.841]                   NAME <- NAMES[[kk]]
[16:59:34.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.841]                     next
[16:59:34.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.841]                 }
[16:59:34.841]                 NAMES <- toupper(added)
[16:59:34.841]                 for (kk in seq_along(NAMES)) {
[16:59:34.841]                   name <- added[[kk]]
[16:59:34.841]                   NAME <- NAMES[[kk]]
[16:59:34.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.841]                     next
[16:59:34.841]                   args[[name]] <- ""
[16:59:34.841]                 }
[16:59:34.841]                 NAMES <- toupper(removed)
[16:59:34.841]                 for (kk in seq_along(NAMES)) {
[16:59:34.841]                   name <- removed[[kk]]
[16:59:34.841]                   NAME <- NAMES[[kk]]
[16:59:34.841]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.841]                     next
[16:59:34.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.841]                 }
[16:59:34.841]                 if (length(args) > 0) 
[16:59:34.841]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.841]             }
[16:59:34.841]             else {
[16:59:34.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.841]             }
[16:59:34.841]             {
[16:59:34.841]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.841]                   0L) {
[16:59:34.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.841]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.841]                   base::options(opts)
[16:59:34.841]                 }
[16:59:34.841]                 {
[16:59:34.841]                   {
[16:59:34.841]                     NULL
[16:59:34.841]                     RNGkind("Mersenne-Twister")
[16:59:34.841]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.841]                       inherits = FALSE)
[16:59:34.841]                   }
[16:59:34.841]                   options(future.plan = NULL)
[16:59:34.841]                   if (is.na(NA_character_)) 
[16:59:34.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.841]                     .init = FALSE)
[16:59:34.841]                 }
[16:59:34.841]             }
[16:59:34.841]         }
[16:59:34.841]     })
[16:59:34.841]     if (TRUE) {
[16:59:34.841]         base::sink(type = "output", split = FALSE)
[16:59:34.841]         if (TRUE) {
[16:59:34.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.841]         }
[16:59:34.841]         else {
[16:59:34.841]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.841]         }
[16:59:34.841]         base::close(...future.stdout)
[16:59:34.841]         ...future.stdout <- NULL
[16:59:34.841]     }
[16:59:34.841]     ...future.result$conditions <- ...future.conditions
[16:59:34.841]     ...future.result$finished <- base::Sys.time()
[16:59:34.841]     ...future.result
[16:59:34.841] }
[16:59:34.843] assign_globals() ...
[16:59:34.843] List of 5
[16:59:34.843]  $ ...future.FUN            :function (object, ...)  
[16:59:34.843]  $ future.call.arguments    : list()
[16:59:34.843]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.843]  $ ...future.elements_ii    :List of 3
[16:59:34.843]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.843]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.843]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.843]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.843]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.843]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.843]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:34.843]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.843]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.843]  $ ...future.seeds_ii       : NULL
[16:59:34.843]  $ ...future.globals.maxSize: NULL
[16:59:34.843]  - attr(*, "where")=List of 5
[16:59:34.843]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.843]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.843]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.843]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.843]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.843]  - attr(*, "resolved")= logi FALSE
[16:59:34.843]  - attr(*, "total_size")= num 1240
[16:59:34.843]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.843]  - attr(*, "already-done")= logi TRUE
[16:59:34.853] - copied ‘...future.FUN’ to environment
[16:59:34.854] - copied ‘future.call.arguments’ to environment
[16:59:34.854] - copied ‘...future.elements_ii’ to environment
[16:59:34.854] - copied ‘...future.seeds_ii’ to environment
[16:59:34.854] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.854] assign_globals() ... done
[16:59:34.854] plan(): Setting new future strategy stack:
[16:59:34.854] List of future strategies:
[16:59:34.854] 1. sequential:
[16:59:34.854]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.854]    - tweaked: FALSE
[16:59:34.854]    - call: NULL
[16:59:34.855] plan(): nbrOfWorkers() = 1
[16:59:34.857] plan(): Setting new future strategy stack:
[16:59:34.857] List of future strategies:
[16:59:34.857] 1. sequential:
[16:59:34.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.857]    - tweaked: FALSE
[16:59:34.857]    - call: plan(strategy)
[16:59:34.858] plan(): nbrOfWorkers() = 1
[16:59:34.858] SequentialFuture started (and completed)
[16:59:34.858] - Launch lazy future ... done
[16:59:34.858] run() for ‘SequentialFuture’ ... done
[16:59:34.858] Created future:
[16:59:34.858] SequentialFuture:
[16:59:34.858] Label: ‘future_by-1’
[16:59:34.858] Expression:
[16:59:34.858] {
[16:59:34.858]     do.call(function(...) {
[16:59:34.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.858]             on.exit(options(oopts), add = TRUE)
[16:59:34.858]         }
[16:59:34.858]         {
[16:59:34.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.858]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.858]             })
[16:59:34.858]         }
[16:59:34.858]     }, args = future.call.arguments)
[16:59:34.858] }
[16:59:34.858] Lazy evaluation: FALSE
[16:59:34.858] Asynchronous evaluation: FALSE
[16:59:34.858] Local evaluation: TRUE
[16:59:34.858] Environment: R_GlobalEnv
[16:59:34.858] Capture standard output: TRUE
[16:59:34.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.858] Globals: 5 objects totaling 3.79 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 2.58 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.858] Packages: <none>
[16:59:34.858] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.858] Resolved: TRUE
[16:59:34.858] Value: 4.62 KiB of class ‘list’
[16:59:34.858] Early signaling: FALSE
[16:59:34.858] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.858] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.859] Chunk #1 of 1 ... DONE
[16:59:34.860] Launching 1 futures (chunks) ... DONE
[16:59:34.860] Resolving 1 futures (chunks) ...
[16:59:34.860] resolve() on list ...
[16:59:34.860]  recursive: 0
[16:59:34.860]  length: 1
[16:59:34.860] 
[16:59:34.860] resolved() for ‘SequentialFuture’ ...
[16:59:34.860] - state: ‘finished’
[16:59:34.860] - run: TRUE
[16:59:34.860] - result: ‘FutureResult’
[16:59:34.860] resolved() for ‘SequentialFuture’ ... done
[16:59:34.861] Future #1
[16:59:34.861] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.861] - nx: 1
[16:59:34.861] - relay: TRUE
[16:59:34.861] - stdout: TRUE
[16:59:34.861] - signal: TRUE
[16:59:34.861] - resignal: FALSE
[16:59:34.861] - force: TRUE
[16:59:34.861] - relayed: [n=1] FALSE
[16:59:34.861] - queued futures: [n=1] FALSE
[16:59:34.861]  - until=1
[16:59:34.862]  - relaying element #1
[16:59:34.862] - relayed: [n=1] TRUE
[16:59:34.862] - queued futures: [n=1] TRUE
[16:59:34.862] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.862]  length: 0 (resolved future 1)
[16:59:34.862] Relaying remaining futures
[16:59:34.862] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.862] - nx: 1
[16:59:34.862] - relay: TRUE
[16:59:34.862] - stdout: TRUE
[16:59:34.863] - signal: TRUE
[16:59:34.863] - resignal: FALSE
[16:59:34.863] - force: TRUE
[16:59:34.863] - relayed: [n=1] TRUE
[16:59:34.863] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.863] - relayed: [n=1] TRUE
[16:59:34.863] - queued futures: [n=1] TRUE
[16:59:34.863] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.863] resolve() on list ... DONE
[16:59:34.863]  - Number of value chunks collected: 1
[16:59:34.864] Resolving 1 futures (chunks) ... DONE
[16:59:34.864] Reducing values from 1 chunks ...
[16:59:34.864]  - Number of values collected after concatenation: 3
[16:59:34.864]  - Number of values expected: 3
[16:59:34.864] Reducing values from 1 chunks ... DONE
[16:59:34.864] future_lapply() ... DONE
[16:59:34.864] future_by_internal() ... DONE
[16:59:34.864] future_by_internal() ...
[16:59:34.865] future_lapply() ...
[16:59:34.865] Number of chunks: 1
[16:59:34.865] getGlobalsAndPackagesXApply() ...
[16:59:34.865]  - future.globals: TRUE
[16:59:34.865] getGlobalsAndPackages() ...
[16:59:34.866] Searching for globals...
[16:59:34.867] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:34.867] Searching for globals ... DONE
[16:59:34.867] Resolving globals: FALSE
[16:59:34.867] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:34.867] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:34.868] - globals: [1] ‘FUN’
[16:59:34.868] 
[16:59:34.868] getGlobalsAndPackages() ... DONE
[16:59:34.868]  - globals found/used: [n=1] ‘FUN’
[16:59:34.868]  - needed namespaces: [n=0] 
[16:59:34.868] Finding globals ... DONE
[16:59:34.868]  - use_args: TRUE
[16:59:34.868]  - Getting '...' globals ...
[16:59:34.868] resolve() on list ...
[16:59:34.869]  recursive: 0
[16:59:34.869]  length: 1
[16:59:34.869]  elements: ‘...’
[16:59:34.869]  length: 0 (resolved future 1)
[16:59:34.869] resolve() on list ... DONE
[16:59:34.869]    - '...' content: [n=1] ‘digits’
[16:59:34.869] List of 1
[16:59:34.869]  $ ...:List of 1
[16:59:34.869]   ..$ digits: int 2
[16:59:34.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.869]  - attr(*, "where")=List of 1
[16:59:34.869]   ..$ ...:<environment: 0x56205215cbb8> 
[16:59:34.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.869]  - attr(*, "resolved")= logi TRUE
[16:59:34.869]  - attr(*, "total_size")= num NA
[16:59:34.872]  - Getting '...' globals ... DONE
[16:59:34.872] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.872] List of 2
[16:59:34.872]  $ ...future.FUN:function (object, ...)  
[16:59:34.872]  $ ...          :List of 1
[16:59:34.872]   ..$ digits: int 2
[16:59:34.872]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.872]  - attr(*, "where")=List of 2
[16:59:34.872]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.872]   ..$ ...          :<environment: 0x56205215cbb8> 
[16:59:34.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.872]  - attr(*, "resolved")= logi FALSE
[16:59:34.872]  - attr(*, "total_size")= num 1296
[16:59:34.877] Packages to be attached in all futures: [n=0] 
[16:59:34.877] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.877] Number of futures (= number of chunks): 1
[16:59:34.878] Launching 1 futures (chunks) ...
[16:59:34.878] Chunk #1 of 1 ...
[16:59:34.878]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.878] getGlobalsAndPackages() ...
[16:59:34.878] Searching for globals...
[16:59:34.878] 
[16:59:34.878] Searching for globals ... DONE
[16:59:34.879] - globals: [0] <none>
[16:59:34.879] getGlobalsAndPackages() ... DONE
[16:59:34.879]    + additional globals found: [n=0] 
[16:59:34.879]    + additional namespaces needed: [n=0] 
[16:59:34.879]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.879]  - seeds: <none>
[16:59:34.879]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.879] getGlobalsAndPackages() ...
[16:59:34.879] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.880] Resolving globals: FALSE
[16:59:34.880] Tweak future expression to call with '...' arguments ...
[16:59:34.880] {
[16:59:34.880]     do.call(function(...) {
[16:59:34.880]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.880]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.880]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.880]             on.exit(options(oopts), add = TRUE)
[16:59:34.880]         }
[16:59:34.880]         {
[16:59:34.880]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.880]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.880]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.880]             })
[16:59:34.880]         }
[16:59:34.880]     }, args = future.call.arguments)
[16:59:34.880] }
[16:59:34.880] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.880] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.881] 
[16:59:34.881] getGlobalsAndPackages() ... DONE
[16:59:34.881] run() for ‘Future’ ...
[16:59:34.881] - state: ‘created’
[16:59:34.881] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:34.881] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.882]   - Field: ‘label’
[16:59:34.882]   - Field: ‘local’
[16:59:34.882]   - Field: ‘owner’
[16:59:34.882]   - Field: ‘envir’
[16:59:34.882]   - Field: ‘packages’
[16:59:34.882]   - Field: ‘gc’
[16:59:34.882]   - Field: ‘conditions’
[16:59:34.882]   - Field: ‘expr’
[16:59:34.882]   - Field: ‘uuid’
[16:59:34.882]   - Field: ‘seed’
[16:59:34.883]   - Field: ‘version’
[16:59:34.883]   - Field: ‘result’
[16:59:34.883]   - Field: ‘asynchronous’
[16:59:34.883]   - Field: ‘calls’
[16:59:34.883]   - Field: ‘globals’
[16:59:34.883]   - Field: ‘stdout’
[16:59:34.883]   - Field: ‘earlySignal’
[16:59:34.883]   - Field: ‘lazy’
[16:59:34.883]   - Field: ‘state’
[16:59:34.883] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.884] - Launch lazy future ...
[16:59:34.884] Packages needed by the future expression (n = 0): <none>
[16:59:34.884] Packages needed by future strategies (n = 0): <none>
[16:59:34.884] {
[16:59:34.884]     {
[16:59:34.884]         {
[16:59:34.884]             ...future.startTime <- base::Sys.time()
[16:59:34.884]             {
[16:59:34.884]                 {
[16:59:34.884]                   {
[16:59:34.884]                     base::local({
[16:59:34.884]                       has_future <- base::requireNamespace("future", 
[16:59:34.884]                         quietly = TRUE)
[16:59:34.884]                       if (has_future) {
[16:59:34.884]                         ns <- base::getNamespace("future")
[16:59:34.884]                         version <- ns[[".package"]][["version"]]
[16:59:34.884]                         if (is.null(version)) 
[16:59:34.884]                           version <- utils::packageVersion("future")
[16:59:34.884]                       }
[16:59:34.884]                       else {
[16:59:34.884]                         version <- NULL
[16:59:34.884]                       }
[16:59:34.884]                       if (!has_future || version < "1.8.0") {
[16:59:34.884]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.884]                           "", base::R.version$version.string), 
[16:59:34.884]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:34.884]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.884]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.884]                             "release", "version")], collapse = " "), 
[16:59:34.884]                           hostname = base::Sys.info()[["nodename"]])
[16:59:34.884]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.884]                           info)
[16:59:34.884]                         info <- base::paste(info, collapse = "; ")
[16:59:34.884]                         if (!has_future) {
[16:59:34.884]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.884]                             info)
[16:59:34.884]                         }
[16:59:34.884]                         else {
[16:59:34.884]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.884]                             info, version)
[16:59:34.884]                         }
[16:59:34.884]                         base::stop(msg)
[16:59:34.884]                       }
[16:59:34.884]                     })
[16:59:34.884]                   }
[16:59:34.884]                   ...future.strategy.old <- future::plan("list")
[16:59:34.884]                   options(future.plan = NULL)
[16:59:34.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.884]                 }
[16:59:34.884]                 ...future.workdir <- getwd()
[16:59:34.884]             }
[16:59:34.884]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.884]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.884]         }
[16:59:34.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.884]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.884]             base::names(...future.oldOptions))
[16:59:34.884]     }
[16:59:34.884]     if (FALSE) {
[16:59:34.884]     }
[16:59:34.884]     else {
[16:59:34.884]         if (TRUE) {
[16:59:34.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.884]                 open = "w")
[16:59:34.884]         }
[16:59:34.884]         else {
[16:59:34.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.884]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.884]         }
[16:59:34.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.884]             base::sink(type = "output", split = FALSE)
[16:59:34.884]             base::close(...future.stdout)
[16:59:34.884]         }, add = TRUE)
[16:59:34.884]     }
[16:59:34.884]     ...future.frame <- base::sys.nframe()
[16:59:34.884]     ...future.conditions <- base::list()
[16:59:34.884]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.884]     if (FALSE) {
[16:59:34.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.884]     }
[16:59:34.884]     ...future.result <- base::tryCatch({
[16:59:34.884]         base::withCallingHandlers({
[16:59:34.884]             ...future.value <- base::withVisible(base::local({
[16:59:34.884]                 do.call(function(...) {
[16:59:34.884]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.884]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.884]                     ...future.globals.maxSize)) {
[16:59:34.884]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.884]                     on.exit(options(oopts), add = TRUE)
[16:59:34.884]                   }
[16:59:34.884]                   {
[16:59:34.884]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.884]                       FUN = function(jj) {
[16:59:34.884]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.884]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.884]                       })
[16:59:34.884]                   }
[16:59:34.884]                 }, args = future.call.arguments)
[16:59:34.884]             }))
[16:59:34.884]             future::FutureResult(value = ...future.value$value, 
[16:59:34.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.884]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.884]                     ...future.globalenv.names))
[16:59:34.884]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.884]         }, condition = base::local({
[16:59:34.884]             c <- base::c
[16:59:34.884]             inherits <- base::inherits
[16:59:34.884]             invokeRestart <- base::invokeRestart
[16:59:34.884]             length <- base::length
[16:59:34.884]             list <- base::list
[16:59:34.884]             seq.int <- base::seq.int
[16:59:34.884]             signalCondition <- base::signalCondition
[16:59:34.884]             sys.calls <- base::sys.calls
[16:59:34.884]             `[[` <- base::`[[`
[16:59:34.884]             `+` <- base::`+`
[16:59:34.884]             `<<-` <- base::`<<-`
[16:59:34.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.884]                   3L)]
[16:59:34.884]             }
[16:59:34.884]             function(cond) {
[16:59:34.884]                 is_error <- inherits(cond, "error")
[16:59:34.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.884]                   NULL)
[16:59:34.884]                 if (is_error) {
[16:59:34.884]                   sessionInformation <- function() {
[16:59:34.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.884]                       search = base::search(), system = base::Sys.info())
[16:59:34.884]                   }
[16:59:34.884]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.884]                     cond$call), session = sessionInformation(), 
[16:59:34.884]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.884]                   signalCondition(cond)
[16:59:34.884]                 }
[16:59:34.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.884]                 "immediateCondition"))) {
[16:59:34.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.884]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.884]                   if (TRUE && !signal) {
[16:59:34.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.884]                     {
[16:59:34.884]                       inherits <- base::inherits
[16:59:34.884]                       invokeRestart <- base::invokeRestart
[16:59:34.884]                       is.null <- base::is.null
[16:59:34.884]                       muffled <- FALSE
[16:59:34.884]                       if (inherits(cond, "message")) {
[16:59:34.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.884]                         if (muffled) 
[16:59:34.884]                           invokeRestart("muffleMessage")
[16:59:34.884]                       }
[16:59:34.884]                       else if (inherits(cond, "warning")) {
[16:59:34.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.884]                         if (muffled) 
[16:59:34.884]                           invokeRestart("muffleWarning")
[16:59:34.884]                       }
[16:59:34.884]                       else if (inherits(cond, "condition")) {
[16:59:34.884]                         if (!is.null(pattern)) {
[16:59:34.884]                           computeRestarts <- base::computeRestarts
[16:59:34.884]                           grepl <- base::grepl
[16:59:34.884]                           restarts <- computeRestarts(cond)
[16:59:34.884]                           for (restart in restarts) {
[16:59:34.884]                             name <- restart$name
[16:59:34.884]                             if (is.null(name)) 
[16:59:34.884]                               next
[16:59:34.884]                             if (!grepl(pattern, name)) 
[16:59:34.884]                               next
[16:59:34.884]                             invokeRestart(restart)
[16:59:34.884]                             muffled <- TRUE
[16:59:34.884]                             break
[16:59:34.884]                           }
[16:59:34.884]                         }
[16:59:34.884]                       }
[16:59:34.884]                       invisible(muffled)
[16:59:34.884]                     }
[16:59:34.884]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.884]                   }
[16:59:34.884]                 }
[16:59:34.884]                 else {
[16:59:34.884]                   if (TRUE) {
[16:59:34.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.884]                     {
[16:59:34.884]                       inherits <- base::inherits
[16:59:34.884]                       invokeRestart <- base::invokeRestart
[16:59:34.884]                       is.null <- base::is.null
[16:59:34.884]                       muffled <- FALSE
[16:59:34.884]                       if (inherits(cond, "message")) {
[16:59:34.884]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.884]                         if (muffled) 
[16:59:34.884]                           invokeRestart("muffleMessage")
[16:59:34.884]                       }
[16:59:34.884]                       else if (inherits(cond, "warning")) {
[16:59:34.884]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.884]                         if (muffled) 
[16:59:34.884]                           invokeRestart("muffleWarning")
[16:59:34.884]                       }
[16:59:34.884]                       else if (inherits(cond, "condition")) {
[16:59:34.884]                         if (!is.null(pattern)) {
[16:59:34.884]                           computeRestarts <- base::computeRestarts
[16:59:34.884]                           grepl <- base::grepl
[16:59:34.884]                           restarts <- computeRestarts(cond)
[16:59:34.884]                           for (restart in restarts) {
[16:59:34.884]                             name <- restart$name
[16:59:34.884]                             if (is.null(name)) 
[16:59:34.884]                               next
[16:59:34.884]                             if (!grepl(pattern, name)) 
[16:59:34.884]                               next
[16:59:34.884]                             invokeRestart(restart)
[16:59:34.884]                             muffled <- TRUE
[16:59:34.884]                             break
[16:59:34.884]                           }
[16:59:34.884]                         }
[16:59:34.884]                       }
[16:59:34.884]                       invisible(muffled)
[16:59:34.884]                     }
[16:59:34.884]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.884]                   }
[16:59:34.884]                 }
[16:59:34.884]             }
[16:59:34.884]         }))
[16:59:34.884]     }, error = function(ex) {
[16:59:34.884]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.884]                 ...future.rng), started = ...future.startTime, 
[16:59:34.884]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.884]             version = "1.8"), class = "FutureResult")
[16:59:34.884]     }, finally = {
[16:59:34.884]         if (!identical(...future.workdir, getwd())) 
[16:59:34.884]             setwd(...future.workdir)
[16:59:34.884]         {
[16:59:34.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.884]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.884]             }
[16:59:34.884]             base::options(...future.oldOptions)
[16:59:34.884]             if (.Platform$OS.type == "windows") {
[16:59:34.884]                 old_names <- names(...future.oldEnvVars)
[16:59:34.884]                 envs <- base::Sys.getenv()
[16:59:34.884]                 names <- names(envs)
[16:59:34.884]                 common <- intersect(names, old_names)
[16:59:34.884]                 added <- setdiff(names, old_names)
[16:59:34.884]                 removed <- setdiff(old_names, names)
[16:59:34.884]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.884]                   envs[common]]
[16:59:34.884]                 NAMES <- toupper(changed)
[16:59:34.884]                 args <- list()
[16:59:34.884]                 for (kk in seq_along(NAMES)) {
[16:59:34.884]                   name <- changed[[kk]]
[16:59:34.884]                   NAME <- NAMES[[kk]]
[16:59:34.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.884]                     next
[16:59:34.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.884]                 }
[16:59:34.884]                 NAMES <- toupper(added)
[16:59:34.884]                 for (kk in seq_along(NAMES)) {
[16:59:34.884]                   name <- added[[kk]]
[16:59:34.884]                   NAME <- NAMES[[kk]]
[16:59:34.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.884]                     next
[16:59:34.884]                   args[[name]] <- ""
[16:59:34.884]                 }
[16:59:34.884]                 NAMES <- toupper(removed)
[16:59:34.884]                 for (kk in seq_along(NAMES)) {
[16:59:34.884]                   name <- removed[[kk]]
[16:59:34.884]                   NAME <- NAMES[[kk]]
[16:59:34.884]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.884]                     next
[16:59:34.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.884]                 }
[16:59:34.884]                 if (length(args) > 0) 
[16:59:34.884]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.884]             }
[16:59:34.884]             else {
[16:59:34.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.884]             }
[16:59:34.884]             {
[16:59:34.884]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.884]                   0L) {
[16:59:34.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.884]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.884]                   base::options(opts)
[16:59:34.884]                 }
[16:59:34.884]                 {
[16:59:34.884]                   {
[16:59:34.884]                     NULL
[16:59:34.884]                     RNGkind("Mersenne-Twister")
[16:59:34.884]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.884]                       inherits = FALSE)
[16:59:34.884]                   }
[16:59:34.884]                   options(future.plan = NULL)
[16:59:34.884]                   if (is.na(NA_character_)) 
[16:59:34.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.884]                     .init = FALSE)
[16:59:34.884]                 }
[16:59:34.884]             }
[16:59:34.884]         }
[16:59:34.884]     })
[16:59:34.884]     if (TRUE) {
[16:59:34.884]         base::sink(type = "output", split = FALSE)
[16:59:34.884]         if (TRUE) {
[16:59:34.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.884]         }
[16:59:34.884]         else {
[16:59:34.884]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.884]         }
[16:59:34.884]         base::close(...future.stdout)
[16:59:34.884]         ...future.stdout <- NULL
[16:59:34.884]     }
[16:59:34.884]     ...future.result$conditions <- ...future.conditions
[16:59:34.884]     ...future.result$finished <- base::Sys.time()
[16:59:34.884]     ...future.result
[16:59:34.884] }
[16:59:34.886] assign_globals() ...
[16:59:34.886] List of 5
[16:59:34.886]  $ ...future.FUN            :function (object, ...)  
[16:59:34.886]  $ future.call.arguments    :List of 1
[16:59:34.886]   ..$ digits: int 2
[16:59:34.886]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.886]  $ ...future.elements_ii    :List of 6
[16:59:34.886]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:59:34.886]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:59:34.886]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:59:34.886]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:59:34.886]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:59:34.886]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:59:34.886]  $ ...future.seeds_ii       : NULL
[16:59:34.886]  $ ...future.globals.maxSize: NULL
[16:59:34.886]  - attr(*, "where")=List of 5
[16:59:34.886]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.886]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.886]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.886]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.886]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.886]  - attr(*, "resolved")= logi FALSE
[16:59:34.886]  - attr(*, "total_size")= num 1296
[16:59:34.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.886]  - attr(*, "already-done")= logi TRUE
[16:59:34.893] - copied ‘...future.FUN’ to environment
[16:59:34.893] - copied ‘future.call.arguments’ to environment
[16:59:34.893] - copied ‘...future.elements_ii’ to environment
[16:59:34.893] - copied ‘...future.seeds_ii’ to environment
[16:59:34.893] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.893] assign_globals() ... done
[16:59:34.893] plan(): Setting new future strategy stack:
[16:59:34.893] List of future strategies:
[16:59:34.893] 1. sequential:
[16:59:34.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.893]    - tweaked: FALSE
[16:59:34.893]    - call: NULL
[16:59:34.894] plan(): nbrOfWorkers() = 1
[16:59:34.895] plan(): Setting new future strategy stack:
[16:59:34.895] List of future strategies:
[16:59:34.895] 1. sequential:
[16:59:34.895]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.895]    - tweaked: FALSE
[16:59:34.895]    - call: plan(strategy)
[16:59:34.896] plan(): nbrOfWorkers() = 1
[16:59:34.896] SequentialFuture started (and completed)
[16:59:34.896] - Launch lazy future ... done
[16:59:34.896] run() for ‘SequentialFuture’ ... done
[16:59:34.896] Created future:
[16:59:34.896] SequentialFuture:
[16:59:34.896] Label: ‘future_by-1’
[16:59:34.896] Expression:
[16:59:34.896] {
[16:59:34.896]     do.call(function(...) {
[16:59:34.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.896]             on.exit(options(oopts), add = TRUE)
[16:59:34.896]         }
[16:59:34.896]         {
[16:59:34.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.896]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.896]             })
[16:59:34.896]         }
[16:59:34.896]     }, args = future.call.arguments)
[16:59:34.896] }
[16:59:34.896] Lazy evaluation: FALSE
[16:59:34.896] Asynchronous evaluation: FALSE
[16:59:34.896] Local evaluation: TRUE
[16:59:34.896] Environment: R_GlobalEnv
[16:59:34.896] Capture standard output: TRUE
[16:59:34.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.896] Globals: 5 objects totaling 2.30 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.03 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.896] Packages: <none>
[16:59:34.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.896] Resolved: TRUE
[16:59:34.896] Value: 5.48 KiB of class ‘list’
[16:59:34.896] Early signaling: FALSE
[16:59:34.896] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.896] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.898] Chunk #1 of 1 ... DONE
[16:59:34.898] Launching 1 futures (chunks) ... DONE
[16:59:34.898] Resolving 1 futures (chunks) ...
[16:59:34.898] resolve() on list ...
[16:59:34.898]  recursive: 0
[16:59:34.898]  length: 1
[16:59:34.898] 
[16:59:34.898] resolved() for ‘SequentialFuture’ ...
[16:59:34.898] - state: ‘finished’
[16:59:34.898] - run: TRUE
[16:59:34.898] - result: ‘FutureResult’
[16:59:34.899] resolved() for ‘SequentialFuture’ ... done
[16:59:34.899] Future #1
[16:59:34.899] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.901] - nx: 1
[16:59:34.901] - relay: TRUE
[16:59:34.901] - stdout: TRUE
[16:59:34.901] - signal: TRUE
[16:59:34.901] - resignal: FALSE
[16:59:34.901] - force: TRUE
[16:59:34.901] - relayed: [n=1] FALSE
[16:59:34.901] - queued futures: [n=1] FALSE
[16:59:34.901]  - until=1
[16:59:34.902]  - relaying element #1
[16:59:34.902] - relayed: [n=1] TRUE
[16:59:34.902] - queued futures: [n=1] TRUE
[16:59:34.902] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.902]  length: 0 (resolved future 1)
[16:59:34.902] Relaying remaining futures
[16:59:34.902] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.903] - nx: 1
[16:59:34.903] - relay: TRUE
[16:59:34.903] - stdout: TRUE
[16:59:34.903] - signal: TRUE
[16:59:34.903] - resignal: FALSE
[16:59:34.903] - force: TRUE
[16:59:34.903] - relayed: [n=1] TRUE
[16:59:34.903] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.903] - relayed: [n=1] TRUE
[16:59:34.904] - queued futures: [n=1] TRUE
[16:59:34.904] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.904] resolve() on list ... DONE
[16:59:34.904]  - Number of value chunks collected: 1
[16:59:34.904] Resolving 1 futures (chunks) ... DONE
[16:59:34.904] Reducing values from 1 chunks ...
[16:59:34.904]  - Number of values collected after concatenation: 6
[16:59:34.904]  - Number of values expected: 6
[16:59:34.904] Reducing values from 1 chunks ... DONE
[16:59:34.905] future_lapply() ... DONE
[16:59:34.905] future_by_internal() ... DONE
[16:59:34.906] future_by_internal() ...
[16:59:34.906] future_lapply() ...
[16:59:34.907] Number of chunks: 1
[16:59:34.907] getGlobalsAndPackagesXApply() ...
[16:59:34.907]  - future.globals: TRUE
[16:59:34.907] getGlobalsAndPackages() ...
[16:59:34.908] Searching for globals...
[16:59:34.909] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:34.909] Searching for globals ... DONE
[16:59:34.909] Resolving globals: FALSE
[16:59:34.910] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:59:34.910] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:59:34.910] - globals: [1] ‘FUN’
[16:59:34.910] - packages: [1] ‘stats’
[16:59:34.910] getGlobalsAndPackages() ... DONE
[16:59:34.911]  - globals found/used: [n=1] ‘FUN’
[16:59:34.911]  - needed namespaces: [n=1] ‘stats’
[16:59:34.911] Finding globals ... DONE
[16:59:34.911]  - use_args: TRUE
[16:59:34.911]  - Getting '...' globals ...
[16:59:34.911] resolve() on list ...
[16:59:34.911]  recursive: 0
[16:59:34.911]  length: 1
[16:59:34.912]  elements: ‘...’
[16:59:34.912]  length: 0 (resolved future 1)
[16:59:34.912] resolve() on list ... DONE
[16:59:34.912]    - '...' content: [n=1] ‘singular.ok’
[16:59:34.912] List of 1
[16:59:34.912]  $ ...:List of 1
[16:59:34.912]   ..$ singular.ok: logi FALSE
[16:59:34.912]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.912]  - attr(*, "where")=List of 1
[16:59:34.912]   ..$ ...:<environment: 0x562051c86320> 
[16:59:34.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.912]  - attr(*, "resolved")= logi TRUE
[16:59:34.912]  - attr(*, "total_size")= num NA
[16:59:34.915]  - Getting '...' globals ... DONE
[16:59:34.915] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:34.915] List of 2
[16:59:34.915]  $ ...future.FUN:function (x, ...)  
[16:59:34.915]  $ ...          :List of 1
[16:59:34.915]   ..$ singular.ok: logi FALSE
[16:59:34.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.915]  - attr(*, "where")=List of 2
[16:59:34.915]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.915]   ..$ ...          :<environment: 0x562051c86320> 
[16:59:34.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.915]  - attr(*, "resolved")= logi FALSE
[16:59:34.915]  - attr(*, "total_size")= num 5384
[16:59:34.918] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:34.918] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.918] Number of futures (= number of chunks): 1
[16:59:34.919] Launching 1 futures (chunks) ...
[16:59:34.919] Chunk #1 of 1 ...
[16:59:34.919]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.919] getGlobalsAndPackages() ...
[16:59:34.919] Searching for globals...
[16:59:34.919] 
[16:59:34.920] Searching for globals ... DONE
[16:59:34.920] - globals: [0] <none>
[16:59:34.920] getGlobalsAndPackages() ... DONE
[16:59:34.920]    + additional globals found: [n=0] 
[16:59:34.920]    + additional namespaces needed: [n=0] 
[16:59:34.920]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.920]  - seeds: <none>
[16:59:34.920]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.920] getGlobalsAndPackages() ...
[16:59:34.920] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.921] Resolving globals: FALSE
[16:59:34.921] Tweak future expression to call with '...' arguments ...
[16:59:34.921] {
[16:59:34.921]     do.call(function(...) {
[16:59:34.921]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.921]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.921]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.921]             on.exit(options(oopts), add = TRUE)
[16:59:34.921]         }
[16:59:34.921]         {
[16:59:34.921]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.921]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.921]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.921]             })
[16:59:34.921]         }
[16:59:34.921]     }, args = future.call.arguments)
[16:59:34.921] }
[16:59:34.921] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.921] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.923] 
[16:59:34.923] getGlobalsAndPackages() ... DONE
[16:59:34.924] run() for ‘Future’ ...
[16:59:34.924] - state: ‘created’
[16:59:34.924] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:34.924] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.924] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.925]   - Field: ‘label’
[16:59:34.925]   - Field: ‘local’
[16:59:34.925]   - Field: ‘owner’
[16:59:34.925]   - Field: ‘envir’
[16:59:34.925]   - Field: ‘packages’
[16:59:34.925]   - Field: ‘gc’
[16:59:34.925]   - Field: ‘conditions’
[16:59:34.925]   - Field: ‘expr’
[16:59:34.925]   - Field: ‘uuid’
[16:59:34.926]   - Field: ‘seed’
[16:59:34.926]   - Field: ‘version’
[16:59:34.926]   - Field: ‘result’
[16:59:34.926]   - Field: ‘asynchronous’
[16:59:34.926]   - Field: ‘calls’
[16:59:34.926]   - Field: ‘globals’
[16:59:34.926]   - Field: ‘stdout’
[16:59:34.926]   - Field: ‘earlySignal’
[16:59:34.926]   - Field: ‘lazy’
[16:59:34.927]   - Field: ‘state’
[16:59:34.927] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.927] - Launch lazy future ...
[16:59:34.927] Packages needed by the future expression (n = 1): ‘stats’
[16:59:34.927] Packages needed by future strategies (n = 0): <none>
[16:59:34.928] {
[16:59:34.928]     {
[16:59:34.928]         {
[16:59:34.928]             ...future.startTime <- base::Sys.time()
[16:59:34.928]             {
[16:59:34.928]                 {
[16:59:34.928]                   {
[16:59:34.928]                     {
[16:59:34.928]                       base::local({
[16:59:34.928]                         has_future <- base::requireNamespace("future", 
[16:59:34.928]                           quietly = TRUE)
[16:59:34.928]                         if (has_future) {
[16:59:34.928]                           ns <- base::getNamespace("future")
[16:59:34.928]                           version <- ns[[".package"]][["version"]]
[16:59:34.928]                           if (is.null(version)) 
[16:59:34.928]                             version <- utils::packageVersion("future")
[16:59:34.928]                         }
[16:59:34.928]                         else {
[16:59:34.928]                           version <- NULL
[16:59:34.928]                         }
[16:59:34.928]                         if (!has_future || version < "1.8.0") {
[16:59:34.928]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.928]                             "", base::R.version$version.string), 
[16:59:34.928]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:34.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.928]                               "release", "version")], collapse = " "), 
[16:59:34.928]                             hostname = base::Sys.info()[["nodename"]])
[16:59:34.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.928]                             info)
[16:59:34.928]                           info <- base::paste(info, collapse = "; ")
[16:59:34.928]                           if (!has_future) {
[16:59:34.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.928]                               info)
[16:59:34.928]                           }
[16:59:34.928]                           else {
[16:59:34.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.928]                               info, version)
[16:59:34.928]                           }
[16:59:34.928]                           base::stop(msg)
[16:59:34.928]                         }
[16:59:34.928]                       })
[16:59:34.928]                     }
[16:59:34.928]                     base::local({
[16:59:34.928]                       for (pkg in "stats") {
[16:59:34.928]                         base::loadNamespace(pkg)
[16:59:34.928]                         base::library(pkg, character.only = TRUE)
[16:59:34.928]                       }
[16:59:34.928]                     })
[16:59:34.928]                   }
[16:59:34.928]                   ...future.strategy.old <- future::plan("list")
[16:59:34.928]                   options(future.plan = NULL)
[16:59:34.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.928]                 }
[16:59:34.928]                 ...future.workdir <- getwd()
[16:59:34.928]             }
[16:59:34.928]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.928]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.928]         }
[16:59:34.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.928]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.928]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.928]             base::names(...future.oldOptions))
[16:59:34.928]     }
[16:59:34.928]     if (FALSE) {
[16:59:34.928]     }
[16:59:34.928]     else {
[16:59:34.928]         if (TRUE) {
[16:59:34.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.928]                 open = "w")
[16:59:34.928]         }
[16:59:34.928]         else {
[16:59:34.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.928]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.928]         }
[16:59:34.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.928]             base::sink(type = "output", split = FALSE)
[16:59:34.928]             base::close(...future.stdout)
[16:59:34.928]         }, add = TRUE)
[16:59:34.928]     }
[16:59:34.928]     ...future.frame <- base::sys.nframe()
[16:59:34.928]     ...future.conditions <- base::list()
[16:59:34.928]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.928]     if (FALSE) {
[16:59:34.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.928]     }
[16:59:34.928]     ...future.result <- base::tryCatch({
[16:59:34.928]         base::withCallingHandlers({
[16:59:34.928]             ...future.value <- base::withVisible(base::local({
[16:59:34.928]                 do.call(function(...) {
[16:59:34.928]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.928]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.928]                     ...future.globals.maxSize)) {
[16:59:34.928]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.928]                     on.exit(options(oopts), add = TRUE)
[16:59:34.928]                   }
[16:59:34.928]                   {
[16:59:34.928]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.928]                       FUN = function(jj) {
[16:59:34.928]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.928]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.928]                       })
[16:59:34.928]                   }
[16:59:34.928]                 }, args = future.call.arguments)
[16:59:34.928]             }))
[16:59:34.928]             future::FutureResult(value = ...future.value$value, 
[16:59:34.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.928]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.928]                     ...future.globalenv.names))
[16:59:34.928]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.928]         }, condition = base::local({
[16:59:34.928]             c <- base::c
[16:59:34.928]             inherits <- base::inherits
[16:59:34.928]             invokeRestart <- base::invokeRestart
[16:59:34.928]             length <- base::length
[16:59:34.928]             list <- base::list
[16:59:34.928]             seq.int <- base::seq.int
[16:59:34.928]             signalCondition <- base::signalCondition
[16:59:34.928]             sys.calls <- base::sys.calls
[16:59:34.928]             `[[` <- base::`[[`
[16:59:34.928]             `+` <- base::`+`
[16:59:34.928]             `<<-` <- base::`<<-`
[16:59:34.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.928]                   3L)]
[16:59:34.928]             }
[16:59:34.928]             function(cond) {
[16:59:34.928]                 is_error <- inherits(cond, "error")
[16:59:34.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.928]                   NULL)
[16:59:34.928]                 if (is_error) {
[16:59:34.928]                   sessionInformation <- function() {
[16:59:34.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.928]                       search = base::search(), system = base::Sys.info())
[16:59:34.928]                   }
[16:59:34.928]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.928]                     cond$call), session = sessionInformation(), 
[16:59:34.928]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.928]                   signalCondition(cond)
[16:59:34.928]                 }
[16:59:34.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.928]                 "immediateCondition"))) {
[16:59:34.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.928]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.928]                   if (TRUE && !signal) {
[16:59:34.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.928]                     {
[16:59:34.928]                       inherits <- base::inherits
[16:59:34.928]                       invokeRestart <- base::invokeRestart
[16:59:34.928]                       is.null <- base::is.null
[16:59:34.928]                       muffled <- FALSE
[16:59:34.928]                       if (inherits(cond, "message")) {
[16:59:34.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.928]                         if (muffled) 
[16:59:34.928]                           invokeRestart("muffleMessage")
[16:59:34.928]                       }
[16:59:34.928]                       else if (inherits(cond, "warning")) {
[16:59:34.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.928]                         if (muffled) 
[16:59:34.928]                           invokeRestart("muffleWarning")
[16:59:34.928]                       }
[16:59:34.928]                       else if (inherits(cond, "condition")) {
[16:59:34.928]                         if (!is.null(pattern)) {
[16:59:34.928]                           computeRestarts <- base::computeRestarts
[16:59:34.928]                           grepl <- base::grepl
[16:59:34.928]                           restarts <- computeRestarts(cond)
[16:59:34.928]                           for (restart in restarts) {
[16:59:34.928]                             name <- restart$name
[16:59:34.928]                             if (is.null(name)) 
[16:59:34.928]                               next
[16:59:34.928]                             if (!grepl(pattern, name)) 
[16:59:34.928]                               next
[16:59:34.928]                             invokeRestart(restart)
[16:59:34.928]                             muffled <- TRUE
[16:59:34.928]                             break
[16:59:34.928]                           }
[16:59:34.928]                         }
[16:59:34.928]                       }
[16:59:34.928]                       invisible(muffled)
[16:59:34.928]                     }
[16:59:34.928]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.928]                   }
[16:59:34.928]                 }
[16:59:34.928]                 else {
[16:59:34.928]                   if (TRUE) {
[16:59:34.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.928]                     {
[16:59:34.928]                       inherits <- base::inherits
[16:59:34.928]                       invokeRestart <- base::invokeRestart
[16:59:34.928]                       is.null <- base::is.null
[16:59:34.928]                       muffled <- FALSE
[16:59:34.928]                       if (inherits(cond, "message")) {
[16:59:34.928]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.928]                         if (muffled) 
[16:59:34.928]                           invokeRestart("muffleMessage")
[16:59:34.928]                       }
[16:59:34.928]                       else if (inherits(cond, "warning")) {
[16:59:34.928]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.928]                         if (muffled) 
[16:59:34.928]                           invokeRestart("muffleWarning")
[16:59:34.928]                       }
[16:59:34.928]                       else if (inherits(cond, "condition")) {
[16:59:34.928]                         if (!is.null(pattern)) {
[16:59:34.928]                           computeRestarts <- base::computeRestarts
[16:59:34.928]                           grepl <- base::grepl
[16:59:34.928]                           restarts <- computeRestarts(cond)
[16:59:34.928]                           for (restart in restarts) {
[16:59:34.928]                             name <- restart$name
[16:59:34.928]                             if (is.null(name)) 
[16:59:34.928]                               next
[16:59:34.928]                             if (!grepl(pattern, name)) 
[16:59:34.928]                               next
[16:59:34.928]                             invokeRestart(restart)
[16:59:34.928]                             muffled <- TRUE
[16:59:34.928]                             break
[16:59:34.928]                           }
[16:59:34.928]                         }
[16:59:34.928]                       }
[16:59:34.928]                       invisible(muffled)
[16:59:34.928]                     }
[16:59:34.928]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.928]                   }
[16:59:34.928]                 }
[16:59:34.928]             }
[16:59:34.928]         }))
[16:59:34.928]     }, error = function(ex) {
[16:59:34.928]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.928]                 ...future.rng), started = ...future.startTime, 
[16:59:34.928]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.928]             version = "1.8"), class = "FutureResult")
[16:59:34.928]     }, finally = {
[16:59:34.928]         if (!identical(...future.workdir, getwd())) 
[16:59:34.928]             setwd(...future.workdir)
[16:59:34.928]         {
[16:59:34.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.928]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.928]             }
[16:59:34.928]             base::options(...future.oldOptions)
[16:59:34.928]             if (.Platform$OS.type == "windows") {
[16:59:34.928]                 old_names <- names(...future.oldEnvVars)
[16:59:34.928]                 envs <- base::Sys.getenv()
[16:59:34.928]                 names <- names(envs)
[16:59:34.928]                 common <- intersect(names, old_names)
[16:59:34.928]                 added <- setdiff(names, old_names)
[16:59:34.928]                 removed <- setdiff(old_names, names)
[16:59:34.928]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.928]                   envs[common]]
[16:59:34.928]                 NAMES <- toupper(changed)
[16:59:34.928]                 args <- list()
[16:59:34.928]                 for (kk in seq_along(NAMES)) {
[16:59:34.928]                   name <- changed[[kk]]
[16:59:34.928]                   NAME <- NAMES[[kk]]
[16:59:34.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.928]                     next
[16:59:34.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.928]                 }
[16:59:34.928]                 NAMES <- toupper(added)
[16:59:34.928]                 for (kk in seq_along(NAMES)) {
[16:59:34.928]                   name <- added[[kk]]
[16:59:34.928]                   NAME <- NAMES[[kk]]
[16:59:34.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.928]                     next
[16:59:34.928]                   args[[name]] <- ""
[16:59:34.928]                 }
[16:59:34.928]                 NAMES <- toupper(removed)
[16:59:34.928]                 for (kk in seq_along(NAMES)) {
[16:59:34.928]                   name <- removed[[kk]]
[16:59:34.928]                   NAME <- NAMES[[kk]]
[16:59:34.928]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.928]                     next
[16:59:34.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.928]                 }
[16:59:34.928]                 if (length(args) > 0) 
[16:59:34.928]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.928]             }
[16:59:34.928]             else {
[16:59:34.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.928]             }
[16:59:34.928]             {
[16:59:34.928]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.928]                   0L) {
[16:59:34.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.928]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.928]                   base::options(opts)
[16:59:34.928]                 }
[16:59:34.928]                 {
[16:59:34.928]                   {
[16:59:34.928]                     NULL
[16:59:34.928]                     RNGkind("Mersenne-Twister")
[16:59:34.928]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.928]                       inherits = FALSE)
[16:59:34.928]                   }
[16:59:34.928]                   options(future.plan = NULL)
[16:59:34.928]                   if (is.na(NA_character_)) 
[16:59:34.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.928]                     .init = FALSE)
[16:59:34.928]                 }
[16:59:34.928]             }
[16:59:34.928]         }
[16:59:34.928]     })
[16:59:34.928]     if (TRUE) {
[16:59:34.928]         base::sink(type = "output", split = FALSE)
[16:59:34.928]         if (TRUE) {
[16:59:34.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.928]         }
[16:59:34.928]         else {
[16:59:34.928]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.928]         }
[16:59:34.928]         base::close(...future.stdout)
[16:59:34.928]         ...future.stdout <- NULL
[16:59:34.928]     }
[16:59:34.928]     ...future.result$conditions <- ...future.conditions
[16:59:34.928]     ...future.result$finished <- base::Sys.time()
[16:59:34.928]     ...future.result
[16:59:34.928] }
[16:59:34.929] assign_globals() ...
[16:59:34.930] List of 5
[16:59:34.930]  $ ...future.FUN            :function (x, ...)  
[16:59:34.930]  $ future.call.arguments    :List of 1
[16:59:34.930]   ..$ singular.ok: logi FALSE
[16:59:34.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.930]  $ ...future.elements_ii    :List of 3
[16:59:34.930]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.930]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.930]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.930]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.930]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.930]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.930]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.930]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.930]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.930]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.930]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.930]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.930]  $ ...future.seeds_ii       : NULL
[16:59:34.930]  $ ...future.globals.maxSize: NULL
[16:59:34.930]  - attr(*, "where")=List of 5
[16:59:34.930]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.930]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.930]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.930]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.930]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.930]  - attr(*, "resolved")= logi FALSE
[16:59:34.930]  - attr(*, "total_size")= num 5384
[16:59:34.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.930]  - attr(*, "already-done")= logi TRUE
[16:59:34.938] - reassign environment for ‘...future.FUN’
[16:59:34.938] - copied ‘...future.FUN’ to environment
[16:59:34.939] - copied ‘future.call.arguments’ to environment
[16:59:34.939] - copied ‘...future.elements_ii’ to environment
[16:59:34.939] - copied ‘...future.seeds_ii’ to environment
[16:59:34.939] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.939] assign_globals() ... done
[16:59:34.939] plan(): Setting new future strategy stack:
[16:59:34.939] List of future strategies:
[16:59:34.939] 1. sequential:
[16:59:34.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.939]    - tweaked: FALSE
[16:59:34.939]    - call: NULL
[16:59:34.940] plan(): nbrOfWorkers() = 1
[16:59:34.943] plan(): Setting new future strategy stack:
[16:59:34.943] List of future strategies:
[16:59:34.943] 1. sequential:
[16:59:34.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.943]    - tweaked: FALSE
[16:59:34.943]    - call: plan(strategy)
[16:59:34.943] plan(): nbrOfWorkers() = 1
[16:59:34.943] SequentialFuture started (and completed)
[16:59:34.944] - Launch lazy future ... done
[16:59:34.944] run() for ‘SequentialFuture’ ... done
[16:59:34.944] Created future:
[16:59:34.944] SequentialFuture:
[16:59:34.944] Label: ‘future_by-1’
[16:59:34.944] Expression:
[16:59:34.944] {
[16:59:34.944]     do.call(function(...) {
[16:59:34.944]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.944]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.944]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.944]             on.exit(options(oopts), add = TRUE)
[16:59:34.944]         }
[16:59:34.944]         {
[16:59:34.944]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.944]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.944]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.944]             })
[16:59:34.944]         }
[16:59:34.944]     }, args = future.call.arguments)
[16:59:34.944] }
[16:59:34.944] Lazy evaluation: FALSE
[16:59:34.944] Asynchronous evaluation: FALSE
[16:59:34.944] Local evaluation: TRUE
[16:59:34.944] Environment: R_GlobalEnv
[16:59:34.944] Capture standard output: TRUE
[16:59:34.944] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:34.944] Globals: 5 objects totaling 10.06 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:34.944] Packages: 1 packages (‘stats’)
[16:59:34.944] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:34.944] Resolved: TRUE
[16:59:34.944] Value: 26.06 KiB of class ‘list’
[16:59:34.944] Early signaling: FALSE
[16:59:34.944] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:34.944] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.945] Chunk #1 of 1 ... DONE
[16:59:34.945] Launching 1 futures (chunks) ... DONE
[16:59:34.946] Resolving 1 futures (chunks) ...
[16:59:34.947] resolve() on list ...
[16:59:34.948]  recursive: 0
[16:59:34.948]  length: 1
[16:59:34.948] 
[16:59:34.948] resolved() for ‘SequentialFuture’ ...
[16:59:34.948] - state: ‘finished’
[16:59:34.948] - run: TRUE
[16:59:34.948] - result: ‘FutureResult’
[16:59:34.948] resolved() for ‘SequentialFuture’ ... done
[16:59:34.949] Future #1
[16:59:34.949] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:34.949] - nx: 1
[16:59:34.949] - relay: TRUE
[16:59:34.949] - stdout: TRUE
[16:59:34.949] - signal: TRUE
[16:59:34.949] - resignal: FALSE
[16:59:34.949] - force: TRUE
[16:59:34.949] - relayed: [n=1] FALSE
[16:59:34.950] - queued futures: [n=1] FALSE
[16:59:34.950]  - until=1
[16:59:34.950]  - relaying element #1
[16:59:34.950] - relayed: [n=1] TRUE
[16:59:34.950] - queued futures: [n=1] TRUE
[16:59:34.950] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:34.950]  length: 0 (resolved future 1)
[16:59:34.951] Relaying remaining futures
[16:59:34.951] signalConditionsASAP(NULL, pos=0) ...
[16:59:34.951] - nx: 1
[16:59:34.951] - relay: TRUE
[16:59:34.951] - stdout: TRUE
[16:59:34.951] - signal: TRUE
[16:59:34.951] - resignal: FALSE
[16:59:34.951] - force: TRUE
[16:59:34.951] - relayed: [n=1] TRUE
[16:59:34.951] - queued futures: [n=1] TRUE
 - flush all
[16:59:34.952] - relayed: [n=1] TRUE
[16:59:34.952] - queued futures: [n=1] TRUE
[16:59:34.952] signalConditionsASAP(NULL, pos=0) ... done
[16:59:34.952] resolve() on list ... DONE
[16:59:34.952]  - Number of value chunks collected: 1
[16:59:34.952] Resolving 1 futures (chunks) ... DONE
[16:59:34.952] Reducing values from 1 chunks ...
[16:59:34.952]  - Number of values collected after concatenation: 3
[16:59:34.953]  - Number of values expected: 3
[16:59:34.953] Reducing values from 1 chunks ... DONE
[16:59:34.953] future_lapply() ... DONE
[16:59:34.953] future_by_internal() ... DONE
[16:59:34.957] future_by_internal() ...
[16:59:34.957] future_lapply() ...
[16:59:34.958] Number of chunks: 1
[16:59:34.958] getGlobalsAndPackagesXApply() ...
[16:59:34.958]  - future.globals: TRUE
[16:59:34.958] getGlobalsAndPackages() ...
[16:59:34.958] Searching for globals...
[16:59:34.960] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:34.960] Searching for globals ... DONE
[16:59:34.960] Resolving globals: FALSE
[16:59:34.961] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:59:34.961] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:59:34.961] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:34.962] - packages: [1] ‘stats’
[16:59:34.962] getGlobalsAndPackages() ... DONE
[16:59:34.962]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:34.962]  - needed namespaces: [n=1] ‘stats’
[16:59:34.962] Finding globals ... DONE
[16:59:34.962]  - use_args: TRUE
[16:59:34.962]  - Getting '...' globals ...
[16:59:34.962] resolve() on list ...
[16:59:34.963]  recursive: 0
[16:59:34.963]  length: 1
[16:59:34.963]  elements: ‘...’
[16:59:34.963]  length: 0 (resolved future 1)
[16:59:34.963] resolve() on list ... DONE
[16:59:34.963]    - '...' content: [n=0] 
[16:59:34.963] List of 1
[16:59:34.963]  $ ...: list()
[16:59:34.963]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.963]  - attr(*, "where")=List of 1
[16:59:34.963]   ..$ ...:<environment: 0x5620520d7848> 
[16:59:34.963]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.963]  - attr(*, "resolved")= logi TRUE
[16:59:34.963]  - attr(*, "total_size")= num NA
[16:59:34.966]  - Getting '...' globals ... DONE
[16:59:34.966] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:59:34.966] List of 4
[16:59:34.966]  $ ...future.FUN:function (x)  
[16:59:34.966]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:34.966]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.966]  $ ...          : list()
[16:59:34.966]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.966]  - attr(*, "where")=List of 4
[16:59:34.966]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:34.966]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:59:34.966]   ..$ wool         :<environment: R_EmptyEnv> 
[16:59:34.966]   ..$ ...          :<environment: 0x5620520d7848> 
[16:59:34.966]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.966]  - attr(*, "resolved")= logi FALSE
[16:59:34.966]  - attr(*, "total_size")= num 2320
[16:59:34.972] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:34.973] getGlobalsAndPackagesXApply() ... DONE
[16:59:34.973] Number of futures (= number of chunks): 1
[16:59:34.973] Launching 1 futures (chunks) ...
[16:59:34.973] Chunk #1 of 1 ...
[16:59:34.973]  - Finding globals in 'X' for chunk #1 ...
[16:59:34.973] getGlobalsAndPackages() ...
[16:59:34.973] Searching for globals...
[16:59:34.974] 
[16:59:34.974] Searching for globals ... DONE
[16:59:34.974] - globals: [0] <none>
[16:59:34.974] getGlobalsAndPackages() ... DONE
[16:59:34.974]    + additional globals found: [n=0] 
[16:59:34.974]    + additional namespaces needed: [n=0] 
[16:59:34.974]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:34.974]  - seeds: <none>
[16:59:34.975]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.975] getGlobalsAndPackages() ...
[16:59:34.975] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.975] Resolving globals: FALSE
[16:59:34.975] Tweak future expression to call with '...' arguments ...
[16:59:34.975] {
[16:59:34.975]     do.call(function(...) {
[16:59:34.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:34.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.975]             on.exit(options(oopts), add = TRUE)
[16:59:34.975]         }
[16:59:34.975]         {
[16:59:34.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:34.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.975]                 ...future.FUN(...future.X_jj, ...)
[16:59:34.975]             })
[16:59:34.975]         }
[16:59:34.975]     }, args = future.call.arguments)
[16:59:34.975] }
[16:59:34.975] Tweak future expression to call with '...' arguments ... DONE
[16:59:34.976] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:34.976] 
[16:59:34.976] getGlobalsAndPackages() ... DONE
[16:59:34.976] run() for ‘Future’ ...
[16:59:34.976] - state: ‘created’
[16:59:34.977] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:34.977] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:34.977] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:34.977]   - Field: ‘label’
[16:59:34.977]   - Field: ‘local’
[16:59:34.977]   - Field: ‘owner’
[16:59:34.977]   - Field: ‘envir’
[16:59:34.977]   - Field: ‘packages’
[16:59:34.978]   - Field: ‘gc’
[16:59:34.978]   - Field: ‘conditions’
[16:59:34.978]   - Field: ‘expr’
[16:59:34.978]   - Field: ‘uuid’
[16:59:34.978]   - Field: ‘seed’
[16:59:34.978]   - Field: ‘version’
[16:59:34.978]   - Field: ‘result’
[16:59:34.978]   - Field: ‘asynchronous’
[16:59:34.978]   - Field: ‘calls’
[16:59:34.978]   - Field: ‘globals’
[16:59:34.978]   - Field: ‘stdout’
[16:59:34.979]   - Field: ‘earlySignal’
[16:59:34.979]   - Field: ‘lazy’
[16:59:34.979]   - Field: ‘state’
[16:59:34.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:34.979] - Launch lazy future ...
[16:59:34.979] Packages needed by the future expression (n = 1): ‘stats’
[16:59:34.979] Packages needed by future strategies (n = 0): <none>
[16:59:34.980] {
[16:59:34.980]     {
[16:59:34.980]         {
[16:59:34.980]             ...future.startTime <- base::Sys.time()
[16:59:34.980]             {
[16:59:34.980]                 {
[16:59:34.980]                   {
[16:59:34.980]                     {
[16:59:34.980]                       base::local({
[16:59:34.980]                         has_future <- base::requireNamespace("future", 
[16:59:34.980]                           quietly = TRUE)
[16:59:34.980]                         if (has_future) {
[16:59:34.980]                           ns <- base::getNamespace("future")
[16:59:34.980]                           version <- ns[[".package"]][["version"]]
[16:59:34.980]                           if (is.null(version)) 
[16:59:34.980]                             version <- utils::packageVersion("future")
[16:59:34.980]                         }
[16:59:34.980]                         else {
[16:59:34.980]                           version <- NULL
[16:59:34.980]                         }
[16:59:34.980]                         if (!has_future || version < "1.8.0") {
[16:59:34.980]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:34.980]                             "", base::R.version$version.string), 
[16:59:34.980]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:34.980]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:34.980]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:34.980]                               "release", "version")], collapse = " "), 
[16:59:34.980]                             hostname = base::Sys.info()[["nodename"]])
[16:59:34.980]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:34.980]                             info)
[16:59:34.980]                           info <- base::paste(info, collapse = "; ")
[16:59:34.980]                           if (!has_future) {
[16:59:34.980]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:34.980]                               info)
[16:59:34.980]                           }
[16:59:34.980]                           else {
[16:59:34.980]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:34.980]                               info, version)
[16:59:34.980]                           }
[16:59:34.980]                           base::stop(msg)
[16:59:34.980]                         }
[16:59:34.980]                       })
[16:59:34.980]                     }
[16:59:34.980]                     base::local({
[16:59:34.980]                       for (pkg in "stats") {
[16:59:34.980]                         base::loadNamespace(pkg)
[16:59:34.980]                         base::library(pkg, character.only = TRUE)
[16:59:34.980]                       }
[16:59:34.980]                     })
[16:59:34.980]                   }
[16:59:34.980]                   ...future.strategy.old <- future::plan("list")
[16:59:34.980]                   options(future.plan = NULL)
[16:59:34.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:34.980]                 }
[16:59:34.980]                 ...future.workdir <- getwd()
[16:59:34.980]             }
[16:59:34.980]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:34.980]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:34.980]         }
[16:59:34.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:34.980]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:34.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:34.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:34.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:34.980]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:34.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:34.980]             base::names(...future.oldOptions))
[16:59:34.980]     }
[16:59:34.980]     if (FALSE) {
[16:59:34.980]     }
[16:59:34.980]     else {
[16:59:34.980]         if (TRUE) {
[16:59:34.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:34.980]                 open = "w")
[16:59:34.980]         }
[16:59:34.980]         else {
[16:59:34.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:34.980]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:34.980]         }
[16:59:34.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:34.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:34.980]             base::sink(type = "output", split = FALSE)
[16:59:34.980]             base::close(...future.stdout)
[16:59:34.980]         }, add = TRUE)
[16:59:34.980]     }
[16:59:34.980]     ...future.frame <- base::sys.nframe()
[16:59:34.980]     ...future.conditions <- base::list()
[16:59:34.980]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:34.980]     if (FALSE) {
[16:59:34.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:34.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:34.980]     }
[16:59:34.980]     ...future.result <- base::tryCatch({
[16:59:34.980]         base::withCallingHandlers({
[16:59:34.980]             ...future.value <- base::withVisible(base::local({
[16:59:34.980]                 do.call(function(...) {
[16:59:34.980]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:34.980]                   if (!identical(...future.globals.maxSize.org, 
[16:59:34.980]                     ...future.globals.maxSize)) {
[16:59:34.980]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:34.980]                     on.exit(options(oopts), add = TRUE)
[16:59:34.980]                   }
[16:59:34.980]                   {
[16:59:34.980]                     lapply(seq_along(...future.elements_ii), 
[16:59:34.980]                       FUN = function(jj) {
[16:59:34.980]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:34.980]                         ...future.FUN(...future.X_jj, ...)
[16:59:34.980]                       })
[16:59:34.980]                   }
[16:59:34.980]                 }, args = future.call.arguments)
[16:59:34.980]             }))
[16:59:34.980]             future::FutureResult(value = ...future.value$value, 
[16:59:34.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.980]                   ...future.rng), globalenv = if (FALSE) 
[16:59:34.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:34.980]                     ...future.globalenv.names))
[16:59:34.980]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:34.980]         }, condition = base::local({
[16:59:34.980]             c <- base::c
[16:59:34.980]             inherits <- base::inherits
[16:59:34.980]             invokeRestart <- base::invokeRestart
[16:59:34.980]             length <- base::length
[16:59:34.980]             list <- base::list
[16:59:34.980]             seq.int <- base::seq.int
[16:59:34.980]             signalCondition <- base::signalCondition
[16:59:34.980]             sys.calls <- base::sys.calls
[16:59:34.980]             `[[` <- base::`[[`
[16:59:34.980]             `+` <- base::`+`
[16:59:34.980]             `<<-` <- base::`<<-`
[16:59:34.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:34.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:34.980]                   3L)]
[16:59:34.980]             }
[16:59:34.980]             function(cond) {
[16:59:34.980]                 is_error <- inherits(cond, "error")
[16:59:34.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:34.980]                   NULL)
[16:59:34.980]                 if (is_error) {
[16:59:34.980]                   sessionInformation <- function() {
[16:59:34.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:34.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:34.980]                       search = base::search(), system = base::Sys.info())
[16:59:34.980]                   }
[16:59:34.980]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:34.980]                     cond$call), session = sessionInformation(), 
[16:59:34.980]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:34.980]                   signalCondition(cond)
[16:59:34.980]                 }
[16:59:34.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:34.980]                 "immediateCondition"))) {
[16:59:34.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:34.980]                   ...future.conditions[[length(...future.conditions) + 
[16:59:34.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:34.980]                   if (TRUE && !signal) {
[16:59:34.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.980]                     {
[16:59:34.980]                       inherits <- base::inherits
[16:59:34.980]                       invokeRestart <- base::invokeRestart
[16:59:34.980]                       is.null <- base::is.null
[16:59:34.980]                       muffled <- FALSE
[16:59:34.980]                       if (inherits(cond, "message")) {
[16:59:34.980]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.980]                         if (muffled) 
[16:59:34.980]                           invokeRestart("muffleMessage")
[16:59:34.980]                       }
[16:59:34.980]                       else if (inherits(cond, "warning")) {
[16:59:34.980]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.980]                         if (muffled) 
[16:59:34.980]                           invokeRestart("muffleWarning")
[16:59:34.980]                       }
[16:59:34.980]                       else if (inherits(cond, "condition")) {
[16:59:34.980]                         if (!is.null(pattern)) {
[16:59:34.980]                           computeRestarts <- base::computeRestarts
[16:59:34.980]                           grepl <- base::grepl
[16:59:34.980]                           restarts <- computeRestarts(cond)
[16:59:34.980]                           for (restart in restarts) {
[16:59:34.980]                             name <- restart$name
[16:59:34.980]                             if (is.null(name)) 
[16:59:34.980]                               next
[16:59:34.980]                             if (!grepl(pattern, name)) 
[16:59:34.980]                               next
[16:59:34.980]                             invokeRestart(restart)
[16:59:34.980]                             muffled <- TRUE
[16:59:34.980]                             break
[16:59:34.980]                           }
[16:59:34.980]                         }
[16:59:34.980]                       }
[16:59:34.980]                       invisible(muffled)
[16:59:34.980]                     }
[16:59:34.980]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.980]                   }
[16:59:34.980]                 }
[16:59:34.980]                 else {
[16:59:34.980]                   if (TRUE) {
[16:59:34.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:34.980]                     {
[16:59:34.980]                       inherits <- base::inherits
[16:59:34.980]                       invokeRestart <- base::invokeRestart
[16:59:34.980]                       is.null <- base::is.null
[16:59:34.980]                       muffled <- FALSE
[16:59:34.980]                       if (inherits(cond, "message")) {
[16:59:34.980]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:34.980]                         if (muffled) 
[16:59:34.980]                           invokeRestart("muffleMessage")
[16:59:34.980]                       }
[16:59:34.980]                       else if (inherits(cond, "warning")) {
[16:59:34.980]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:34.980]                         if (muffled) 
[16:59:34.980]                           invokeRestart("muffleWarning")
[16:59:34.980]                       }
[16:59:34.980]                       else if (inherits(cond, "condition")) {
[16:59:34.980]                         if (!is.null(pattern)) {
[16:59:34.980]                           computeRestarts <- base::computeRestarts
[16:59:34.980]                           grepl <- base::grepl
[16:59:34.980]                           restarts <- computeRestarts(cond)
[16:59:34.980]                           for (restart in restarts) {
[16:59:34.980]                             name <- restart$name
[16:59:34.980]                             if (is.null(name)) 
[16:59:34.980]                               next
[16:59:34.980]                             if (!grepl(pattern, name)) 
[16:59:34.980]                               next
[16:59:34.980]                             invokeRestart(restart)
[16:59:34.980]                             muffled <- TRUE
[16:59:34.980]                             break
[16:59:34.980]                           }
[16:59:34.980]                         }
[16:59:34.980]                       }
[16:59:34.980]                       invisible(muffled)
[16:59:34.980]                     }
[16:59:34.980]                     muffleCondition(cond, pattern = "^muffle")
[16:59:34.980]                   }
[16:59:34.980]                 }
[16:59:34.980]             }
[16:59:34.980]         }))
[16:59:34.980]     }, error = function(ex) {
[16:59:34.980]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:34.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:34.980]                 ...future.rng), started = ...future.startTime, 
[16:59:34.980]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:34.980]             version = "1.8"), class = "FutureResult")
[16:59:34.980]     }, finally = {
[16:59:34.980]         if (!identical(...future.workdir, getwd())) 
[16:59:34.980]             setwd(...future.workdir)
[16:59:34.980]         {
[16:59:34.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:34.980]                 ...future.oldOptions$nwarnings <- NULL
[16:59:34.980]             }
[16:59:34.980]             base::options(...future.oldOptions)
[16:59:34.980]             if (.Platform$OS.type == "windows") {
[16:59:34.980]                 old_names <- names(...future.oldEnvVars)
[16:59:34.980]                 envs <- base::Sys.getenv()
[16:59:34.980]                 names <- names(envs)
[16:59:34.980]                 common <- intersect(names, old_names)
[16:59:34.980]                 added <- setdiff(names, old_names)
[16:59:34.980]                 removed <- setdiff(old_names, names)
[16:59:34.980]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:34.980]                   envs[common]]
[16:59:34.980]                 NAMES <- toupper(changed)
[16:59:34.980]                 args <- list()
[16:59:34.980]                 for (kk in seq_along(NAMES)) {
[16:59:34.980]                   name <- changed[[kk]]
[16:59:34.980]                   NAME <- NAMES[[kk]]
[16:59:34.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.980]                     next
[16:59:34.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.980]                 }
[16:59:34.980]                 NAMES <- toupper(added)
[16:59:34.980]                 for (kk in seq_along(NAMES)) {
[16:59:34.980]                   name <- added[[kk]]
[16:59:34.980]                   NAME <- NAMES[[kk]]
[16:59:34.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.980]                     next
[16:59:34.980]                   args[[name]] <- ""
[16:59:34.980]                 }
[16:59:34.980]                 NAMES <- toupper(removed)
[16:59:34.980]                 for (kk in seq_along(NAMES)) {
[16:59:34.980]                   name <- removed[[kk]]
[16:59:34.980]                   NAME <- NAMES[[kk]]
[16:59:34.980]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:34.980]                     next
[16:59:34.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:34.980]                 }
[16:59:34.980]                 if (length(args) > 0) 
[16:59:34.980]                   base::do.call(base::Sys.setenv, args = args)
[16:59:34.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:34.980]             }
[16:59:34.980]             else {
[16:59:34.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:34.980]             }
[16:59:34.980]             {
[16:59:34.980]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:34.980]                   0L) {
[16:59:34.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:34.980]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:34.980]                   base::options(opts)
[16:59:34.980]                 }
[16:59:34.980]                 {
[16:59:34.980]                   {
[16:59:34.980]                     NULL
[16:59:34.980]                     RNGkind("Mersenne-Twister")
[16:59:34.980]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:34.980]                       inherits = FALSE)
[16:59:34.980]                   }
[16:59:34.980]                   options(future.plan = NULL)
[16:59:34.980]                   if (is.na(NA_character_)) 
[16:59:34.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:34.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:34.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:34.980]                     .init = FALSE)
[16:59:34.980]                 }
[16:59:34.980]             }
[16:59:34.980]         }
[16:59:34.980]     })
[16:59:34.980]     if (TRUE) {
[16:59:34.980]         base::sink(type = "output", split = FALSE)
[16:59:34.980]         if (TRUE) {
[16:59:34.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:34.980]         }
[16:59:34.980]         else {
[16:59:34.980]             ...future.result["stdout"] <- base::list(NULL)
[16:59:34.980]         }
[16:59:34.980]         base::close(...future.stdout)
[16:59:34.980]         ...future.stdout <- NULL
[16:59:34.980]     }
[16:59:34.980]     ...future.result$conditions <- ...future.conditions
[16:59:34.980]     ...future.result$finished <- base::Sys.time()
[16:59:34.980]     ...future.result
[16:59:34.980] }
[16:59:34.982] assign_globals() ...
[16:59:34.982] List of 7
[16:59:34.982]  $ ...future.FUN            :function (x)  
[16:59:34.982]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:34.982]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.982]  $ future.call.arguments    : list()
[16:59:34.982]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:34.982]  $ ...future.elements_ii    :List of 3
[16:59:34.982]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.982]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:34.982]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.982]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:34.982]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.982]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:34.982]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.982]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:34.982]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:34.982]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:34.982]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:34.982]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:34.982]  $ ...future.seeds_ii       : NULL
[16:59:34.982]  $ ...future.globals.maxSize: NULL
[16:59:34.982]  - attr(*, "where")=List of 7
[16:59:34.982]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:34.982]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:59:34.982]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:59:34.982]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:34.982]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:34.982]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:34.982]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:34.982]  - attr(*, "resolved")= logi FALSE
[16:59:34.982]  - attr(*, "total_size")= num 2320
[16:59:34.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:34.982]  - attr(*, "already-done")= logi TRUE
[16:59:34.993] - reassign environment for ‘...future.FUN’
[16:59:34.994] - copied ‘...future.FUN’ to environment
[16:59:34.994] - copied ‘breaks’ to environment
[16:59:34.994] - copied ‘wool’ to environment
[16:59:34.994] - copied ‘future.call.arguments’ to environment
[16:59:34.994] - copied ‘...future.elements_ii’ to environment
[16:59:34.994] - copied ‘...future.seeds_ii’ to environment
[16:59:34.994] - copied ‘...future.globals.maxSize’ to environment
[16:59:34.994] assign_globals() ... done
[16:59:34.995] plan(): Setting new future strategy stack:
[16:59:34.995] List of future strategies:
[16:59:34.995] 1. sequential:
[16:59:34.995]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.995]    - tweaked: FALSE
[16:59:34.995]    - call: NULL
[16:59:34.996] plan(): nbrOfWorkers() = 1
[16:59:34.999] plan(): Setting new future strategy stack:
[16:59:34.999] List of future strategies:
[16:59:34.999] 1. sequential:
[16:59:34.999]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:34.999]    - tweaked: FALSE
[16:59:34.999]    - call: plan(strategy)
[16:59:34.999] plan(): nbrOfWorkers() = 1
[16:59:35.000] SequentialFuture started (and completed)
[16:59:35.000] - Launch lazy future ... done
[16:59:35.000] run() for ‘SequentialFuture’ ... done
[16:59:35.000] Created future:
[16:59:35.000] SequentialFuture:
[16:59:35.000] Label: ‘future_by-1’
[16:59:35.000] Expression:
[16:59:35.000] {
[16:59:35.000]     do.call(function(...) {
[16:59:35.000]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.000]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.000]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.000]             on.exit(options(oopts), add = TRUE)
[16:59:35.000]         }
[16:59:35.000]         {
[16:59:35.000]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.000]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.000]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.000]             })
[16:59:35.000]         }
[16:59:35.000]     }, args = future.call.arguments)
[16:59:35.000] }
[16:59:35.000] Lazy evaluation: FALSE
[16:59:35.000] Asynchronous evaluation: FALSE
[16:59:35.000] Local evaluation: TRUE
[16:59:35.000] Environment: 0x56205208f138
[16:59:35.000] Capture standard output: TRUE
[16:59:35.000] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.000] Globals: 7 objects totaling 7.07 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, ...)
[16:59:35.000] Packages: 1 packages (‘stats’)
[16:59:35.000] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.000] Resolved: TRUE
[16:59:35.000] Value: 25.57 KiB of class ‘list’
[16:59:35.000] Early signaling: FALSE
[16:59:35.000] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.000] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:35.002] Chunk #1 of 1 ... DONE
[16:59:35.002] Launching 1 futures (chunks) ... DONE
[16:59:35.002] Resolving 1 futures (chunks) ...
[16:59:35.002] resolve() on list ...
[16:59:35.002]  recursive: 0
[16:59:35.002]  length: 1
[16:59:35.002] 
[16:59:35.002] resolved() for ‘SequentialFuture’ ...
[16:59:35.003] - state: ‘finished’
[16:59:35.003] - run: TRUE
[16:59:35.003] - result: ‘FutureResult’
[16:59:35.003] resolved() for ‘SequentialFuture’ ... done
[16:59:35.003] Future #1
[16:59:35.003] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:35.003] - nx: 1
[16:59:35.003] - relay: TRUE
[16:59:35.003] - stdout: TRUE
[16:59:35.003] - signal: TRUE
[16:59:35.003] - resignal: FALSE
[16:59:35.004] - force: TRUE
[16:59:35.004] - relayed: [n=1] FALSE
[16:59:35.004] - queued futures: [n=1] FALSE
[16:59:35.004]  - until=1
[16:59:35.004]  - relaying element #1
[16:59:35.004] - relayed: [n=1] TRUE
[16:59:35.004] - queued futures: [n=1] TRUE
[16:59:35.004] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:35.004]  length: 0 (resolved future 1)
[16:59:35.005] Relaying remaining futures
[16:59:35.005] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.005] - nx: 1
[16:59:35.005] - relay: TRUE
[16:59:35.005] - stdout: TRUE
[16:59:35.005] - signal: TRUE
[16:59:35.005] - resignal: FALSE
[16:59:35.005] - force: TRUE
[16:59:35.005] - relayed: [n=1] TRUE
[16:59:35.005] - queued futures: [n=1] TRUE
 - flush all
[16:59:35.005] - relayed: [n=1] TRUE
[16:59:35.005] - queued futures: [n=1] TRUE
[16:59:35.006] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.006] resolve() on list ... DONE
[16:59:35.006]  - Number of value chunks collected: 1
[16:59:35.006] Resolving 1 futures (chunks) ... DONE
[16:59:35.006] Reducing values from 1 chunks ...
[16:59:35.006]  - Number of values collected after concatenation: 3
[16:59:35.006]  - Number of values expected: 3
[16:59:35.006] Reducing values from 1 chunks ... DONE
[16:59:35.006] future_lapply() ... DONE
[16:59:35.006] future_by_internal() ... DONE
[16:59:35.007] future_by_internal() ...
[16:59:35.007] future_lapply() ...
[16:59:35.008] Number of chunks: 1
[16:59:35.008] getGlobalsAndPackagesXApply() ...
[16:59:35.008]  - future.globals: TRUE
[16:59:35.008] getGlobalsAndPackages() ...
[16:59:35.008] Searching for globals...
[16:59:35.009] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:35.009] Searching for globals ... DONE
[16:59:35.009] Resolving globals: FALSE
[16:59:35.010] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:35.010] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:35.010] - globals: [1] ‘FUN’
[16:59:35.010] 
[16:59:35.010] getGlobalsAndPackages() ... DONE
[16:59:35.011]  - globals found/used: [n=1] ‘FUN’
[16:59:35.011]  - needed namespaces: [n=0] 
[16:59:35.011] Finding globals ... DONE
[16:59:35.011]  - use_args: TRUE
[16:59:35.011]  - Getting '...' globals ...
[16:59:35.011] resolve() on list ...
[16:59:35.011]  recursive: 0
[16:59:35.011]  length: 1
[16:59:35.012]  elements: ‘...’
[16:59:35.012]  length: 0 (resolved future 1)
[16:59:35.012] resolve() on list ... DONE
[16:59:35.012]    - '...' content: [n=0] 
[16:59:35.012] List of 1
[16:59:35.012]  $ ...: list()
[16:59:35.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.012]  - attr(*, "where")=List of 1
[16:59:35.012]   ..$ ...:<environment: 0x5620527871f8> 
[16:59:35.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.012]  - attr(*, "resolved")= logi TRUE
[16:59:35.012]  - attr(*, "total_size")= num NA
[16:59:35.014]  - Getting '...' globals ... DONE
[16:59:35.017] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.017] List of 2
[16:59:35.017]  $ ...future.FUN:function (object, ...)  
[16:59:35.017]  $ ...          : list()
[16:59:35.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.017]  - attr(*, "where")=List of 2
[16:59:35.017]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.017]   ..$ ...          :<environment: 0x5620527871f8> 
[16:59:35.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.017]  - attr(*, "resolved")= logi FALSE
[16:59:35.017]  - attr(*, "total_size")= num 1240
[16:59:35.020] Packages to be attached in all futures: [n=0] 
[16:59:35.020] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.021] Number of futures (= number of chunks): 1
[16:59:35.021] Launching 1 futures (chunks) ...
[16:59:35.021] Chunk #1 of 1 ...
[16:59:35.021]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.021] getGlobalsAndPackages() ...
[16:59:35.021] Searching for globals...
[16:59:35.022] 
[16:59:35.022] Searching for globals ... DONE
[16:59:35.022] - globals: [0] <none>
[16:59:35.022] getGlobalsAndPackages() ... DONE
[16:59:35.022]    + additional globals found: [n=0] 
[16:59:35.022]    + additional namespaces needed: [n=0] 
[16:59:35.022]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.022]  - seeds: <none>
[16:59:35.022]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.023] getGlobalsAndPackages() ...
[16:59:35.023] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.023] Resolving globals: FALSE
[16:59:35.023] Tweak future expression to call with '...' arguments ...
[16:59:35.023] {
[16:59:35.023]     do.call(function(...) {
[16:59:35.023]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.023]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.023]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.023]             on.exit(options(oopts), add = TRUE)
[16:59:35.023]         }
[16:59:35.023]         {
[16:59:35.023]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.023]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.023]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.023]             })
[16:59:35.023]         }
[16:59:35.023]     }, args = future.call.arguments)
[16:59:35.023] }
[16:59:35.023] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.024] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.024] 
[16:59:35.024] getGlobalsAndPackages() ... DONE
[16:59:35.024] run() for ‘Future’ ...
[16:59:35.024] - state: ‘created’
[16:59:35.024] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:35.025] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:35.025] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:35.025]   - Field: ‘label’
[16:59:35.025]   - Field: ‘local’
[16:59:35.025]   - Field: ‘owner’
[16:59:35.025]   - Field: ‘envir’
[16:59:35.025]   - Field: ‘packages’
[16:59:35.025]   - Field: ‘gc’
[16:59:35.025]   - Field: ‘conditions’
[16:59:35.026]   - Field: ‘expr’
[16:59:35.026]   - Field: ‘uuid’
[16:59:35.026]   - Field: ‘seed’
[16:59:35.026]   - Field: ‘version’
[16:59:35.026]   - Field: ‘result’
[16:59:35.026]   - Field: ‘asynchronous’
[16:59:35.026]   - Field: ‘calls’
[16:59:35.026]   - Field: ‘globals’
[16:59:35.026]   - Field: ‘stdout’
[16:59:35.026]   - Field: ‘earlySignal’
[16:59:35.026]   - Field: ‘lazy’
[16:59:35.027]   - Field: ‘state’
[16:59:35.027] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:35.027] - Launch lazy future ...
[16:59:35.027] Packages needed by the future expression (n = 0): <none>
[16:59:35.027] Packages needed by future strategies (n = 0): <none>
[16:59:35.028] {
[16:59:35.028]     {
[16:59:35.028]         {
[16:59:35.028]             ...future.startTime <- base::Sys.time()
[16:59:35.028]             {
[16:59:35.028]                 {
[16:59:35.028]                   {
[16:59:35.028]                     base::local({
[16:59:35.028]                       has_future <- base::requireNamespace("future", 
[16:59:35.028]                         quietly = TRUE)
[16:59:35.028]                       if (has_future) {
[16:59:35.028]                         ns <- base::getNamespace("future")
[16:59:35.028]                         version <- ns[[".package"]][["version"]]
[16:59:35.028]                         if (is.null(version)) 
[16:59:35.028]                           version <- utils::packageVersion("future")
[16:59:35.028]                       }
[16:59:35.028]                       else {
[16:59:35.028]                         version <- NULL
[16:59:35.028]                       }
[16:59:35.028]                       if (!has_future || version < "1.8.0") {
[16:59:35.028]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.028]                           "", base::R.version$version.string), 
[16:59:35.028]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:35.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.028]                             "release", "version")], collapse = " "), 
[16:59:35.028]                           hostname = base::Sys.info()[["nodename"]])
[16:59:35.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.028]                           info)
[16:59:35.028]                         info <- base::paste(info, collapse = "; ")
[16:59:35.028]                         if (!has_future) {
[16:59:35.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.028]                             info)
[16:59:35.028]                         }
[16:59:35.028]                         else {
[16:59:35.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.028]                             info, version)
[16:59:35.028]                         }
[16:59:35.028]                         base::stop(msg)
[16:59:35.028]                       }
[16:59:35.028]                     })
[16:59:35.028]                   }
[16:59:35.028]                   ...future.strategy.old <- future::plan("list")
[16:59:35.028]                   options(future.plan = NULL)
[16:59:35.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.028]                 }
[16:59:35.028]                 ...future.workdir <- getwd()
[16:59:35.028]             }
[16:59:35.028]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.028]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.028]         }
[16:59:35.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.028]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:35.028]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.028]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.028]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.028]             base::names(...future.oldOptions))
[16:59:35.028]     }
[16:59:35.028]     if (FALSE) {
[16:59:35.028]     }
[16:59:35.028]     else {
[16:59:35.028]         if (TRUE) {
[16:59:35.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.028]                 open = "w")
[16:59:35.028]         }
[16:59:35.028]         else {
[16:59:35.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.028]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.028]         }
[16:59:35.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.028]             base::sink(type = "output", split = FALSE)
[16:59:35.028]             base::close(...future.stdout)
[16:59:35.028]         }, add = TRUE)
[16:59:35.028]     }
[16:59:35.028]     ...future.frame <- base::sys.nframe()
[16:59:35.028]     ...future.conditions <- base::list()
[16:59:35.028]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.028]     if (FALSE) {
[16:59:35.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.028]     }
[16:59:35.028]     ...future.result <- base::tryCatch({
[16:59:35.028]         base::withCallingHandlers({
[16:59:35.028]             ...future.value <- base::withVisible(base::local({
[16:59:35.028]                 do.call(function(...) {
[16:59:35.028]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.028]                   if (!identical(...future.globals.maxSize.org, 
[16:59:35.028]                     ...future.globals.maxSize)) {
[16:59:35.028]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.028]                     on.exit(options(oopts), add = TRUE)
[16:59:35.028]                   }
[16:59:35.028]                   {
[16:59:35.028]                     lapply(seq_along(...future.elements_ii), 
[16:59:35.028]                       FUN = function(jj) {
[16:59:35.028]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.028]                         ...future.FUN(...future.X_jj, ...)
[16:59:35.028]                       })
[16:59:35.028]                   }
[16:59:35.028]                 }, args = future.call.arguments)
[16:59:35.028]             }))
[16:59:35.028]             future::FutureResult(value = ...future.value$value, 
[16:59:35.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.028]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.028]                     ...future.globalenv.names))
[16:59:35.028]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.028]         }, condition = base::local({
[16:59:35.028]             c <- base::c
[16:59:35.028]             inherits <- base::inherits
[16:59:35.028]             invokeRestart <- base::invokeRestart
[16:59:35.028]             length <- base::length
[16:59:35.028]             list <- base::list
[16:59:35.028]             seq.int <- base::seq.int
[16:59:35.028]             signalCondition <- base::signalCondition
[16:59:35.028]             sys.calls <- base::sys.calls
[16:59:35.028]             `[[` <- base::`[[`
[16:59:35.028]             `+` <- base::`+`
[16:59:35.028]             `<<-` <- base::`<<-`
[16:59:35.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.028]                   3L)]
[16:59:35.028]             }
[16:59:35.028]             function(cond) {
[16:59:35.028]                 is_error <- inherits(cond, "error")
[16:59:35.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.028]                   NULL)
[16:59:35.028]                 if (is_error) {
[16:59:35.028]                   sessionInformation <- function() {
[16:59:35.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.028]                       search = base::search(), system = base::Sys.info())
[16:59:35.028]                   }
[16:59:35.028]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.028]                     cond$call), session = sessionInformation(), 
[16:59:35.028]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.028]                   signalCondition(cond)
[16:59:35.028]                 }
[16:59:35.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.028]                 "immediateCondition"))) {
[16:59:35.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.028]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.028]                   if (TRUE && !signal) {
[16:59:35.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.028]                     {
[16:59:35.028]                       inherits <- base::inherits
[16:59:35.028]                       invokeRestart <- base::invokeRestart
[16:59:35.028]                       is.null <- base::is.null
[16:59:35.028]                       muffled <- FALSE
[16:59:35.028]                       if (inherits(cond, "message")) {
[16:59:35.028]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.028]                         if (muffled) 
[16:59:35.028]                           invokeRestart("muffleMessage")
[16:59:35.028]                       }
[16:59:35.028]                       else if (inherits(cond, "warning")) {
[16:59:35.028]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.028]                         if (muffled) 
[16:59:35.028]                           invokeRestart("muffleWarning")
[16:59:35.028]                       }
[16:59:35.028]                       else if (inherits(cond, "condition")) {
[16:59:35.028]                         if (!is.null(pattern)) {
[16:59:35.028]                           computeRestarts <- base::computeRestarts
[16:59:35.028]                           grepl <- base::grepl
[16:59:35.028]                           restarts <- computeRestarts(cond)
[16:59:35.028]                           for (restart in restarts) {
[16:59:35.028]                             name <- restart$name
[16:59:35.028]                             if (is.null(name)) 
[16:59:35.028]                               next
[16:59:35.028]                             if (!grepl(pattern, name)) 
[16:59:35.028]                               next
[16:59:35.028]                             invokeRestart(restart)
[16:59:35.028]                             muffled <- TRUE
[16:59:35.028]                             break
[16:59:35.028]                           }
[16:59:35.028]                         }
[16:59:35.028]                       }
[16:59:35.028]                       invisible(muffled)
[16:59:35.028]                     }
[16:59:35.028]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.028]                   }
[16:59:35.028]                 }
[16:59:35.028]                 else {
[16:59:35.028]                   if (TRUE) {
[16:59:35.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.028]                     {
[16:59:35.028]                       inherits <- base::inherits
[16:59:35.028]                       invokeRestart <- base::invokeRestart
[16:59:35.028]                       is.null <- base::is.null
[16:59:35.028]                       muffled <- FALSE
[16:59:35.028]                       if (inherits(cond, "message")) {
[16:59:35.028]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.028]                         if (muffled) 
[16:59:35.028]                           invokeRestart("muffleMessage")
[16:59:35.028]                       }
[16:59:35.028]                       else if (inherits(cond, "warning")) {
[16:59:35.028]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.028]                         if (muffled) 
[16:59:35.028]                           invokeRestart("muffleWarning")
[16:59:35.028]                       }
[16:59:35.028]                       else if (inherits(cond, "condition")) {
[16:59:35.028]                         if (!is.null(pattern)) {
[16:59:35.028]                           computeRestarts <- base::computeRestarts
[16:59:35.028]                           grepl <- base::grepl
[16:59:35.028]                           restarts <- computeRestarts(cond)
[16:59:35.028]                           for (restart in restarts) {
[16:59:35.028]                             name <- restart$name
[16:59:35.028]                             if (is.null(name)) 
[16:59:35.028]                               next
[16:59:35.028]                             if (!grepl(pattern, name)) 
[16:59:35.028]                               next
[16:59:35.028]                             invokeRestart(restart)
[16:59:35.028]                             muffled <- TRUE
[16:59:35.028]                             break
[16:59:35.028]                           }
[16:59:35.028]                         }
[16:59:35.028]                       }
[16:59:35.028]                       invisible(muffled)
[16:59:35.028]                     }
[16:59:35.028]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.028]                   }
[16:59:35.028]                 }
[16:59:35.028]             }
[16:59:35.028]         }))
[16:59:35.028]     }, error = function(ex) {
[16:59:35.028]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.028]                 ...future.rng), started = ...future.startTime, 
[16:59:35.028]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.028]             version = "1.8"), class = "FutureResult")
[16:59:35.028]     }, finally = {
[16:59:35.028]         if (!identical(...future.workdir, getwd())) 
[16:59:35.028]             setwd(...future.workdir)
[16:59:35.028]         {
[16:59:35.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.028]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.028]             }
[16:59:35.028]             base::options(...future.oldOptions)
[16:59:35.028]             if (.Platform$OS.type == "windows") {
[16:59:35.028]                 old_names <- names(...future.oldEnvVars)
[16:59:35.028]                 envs <- base::Sys.getenv()
[16:59:35.028]                 names <- names(envs)
[16:59:35.028]                 common <- intersect(names, old_names)
[16:59:35.028]                 added <- setdiff(names, old_names)
[16:59:35.028]                 removed <- setdiff(old_names, names)
[16:59:35.028]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.028]                   envs[common]]
[16:59:35.028]                 NAMES <- toupper(changed)
[16:59:35.028]                 args <- list()
[16:59:35.028]                 for (kk in seq_along(NAMES)) {
[16:59:35.028]                   name <- changed[[kk]]
[16:59:35.028]                   NAME <- NAMES[[kk]]
[16:59:35.028]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.028]                     next
[16:59:35.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.028]                 }
[16:59:35.028]                 NAMES <- toupper(added)
[16:59:35.028]                 for (kk in seq_along(NAMES)) {
[16:59:35.028]                   name <- added[[kk]]
[16:59:35.028]                   NAME <- NAMES[[kk]]
[16:59:35.028]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.028]                     next
[16:59:35.028]                   args[[name]] <- ""
[16:59:35.028]                 }
[16:59:35.028]                 NAMES <- toupper(removed)
[16:59:35.028]                 for (kk in seq_along(NAMES)) {
[16:59:35.028]                   name <- removed[[kk]]
[16:59:35.028]                   NAME <- NAMES[[kk]]
[16:59:35.028]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.028]                     next
[16:59:35.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.028]                 }
[16:59:35.028]                 if (length(args) > 0) 
[16:59:35.028]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.028]             }
[16:59:35.028]             else {
[16:59:35.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.028]             }
[16:59:35.028]             {
[16:59:35.028]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.028]                   0L) {
[16:59:35.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.028]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.028]                   base::options(opts)
[16:59:35.028]                 }
[16:59:35.028]                 {
[16:59:35.028]                   {
[16:59:35.028]                     NULL
[16:59:35.028]                     RNGkind("Mersenne-Twister")
[16:59:35.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:35.028]                       inherits = FALSE)
[16:59:35.028]                   }
[16:59:35.028]                   options(future.plan = NULL)
[16:59:35.028]                   if (is.na(NA_character_)) 
[16:59:35.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.028]                     .init = FALSE)
[16:59:35.028]                 }
[16:59:35.028]             }
[16:59:35.028]         }
[16:59:35.028]     })
[16:59:35.028]     if (TRUE) {
[16:59:35.028]         base::sink(type = "output", split = FALSE)
[16:59:35.028]         if (TRUE) {
[16:59:35.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.028]         }
[16:59:35.028]         else {
[16:59:35.028]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.028]         }
[16:59:35.028]         base::close(...future.stdout)
[16:59:35.028]         ...future.stdout <- NULL
[16:59:35.028]     }
[16:59:35.028]     ...future.result$conditions <- ...future.conditions
[16:59:35.028]     ...future.result$finished <- base::Sys.time()
[16:59:35.028]     ...future.result
[16:59:35.028] }
[16:59:35.029] assign_globals() ...
[16:59:35.029] List of 5
[16:59:35.029]  $ ...future.FUN            :function (object, ...)  
[16:59:35.029]  $ future.call.arguments    : list()
[16:59:35.029]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.029]  $ ...future.elements_ii    :List of 3
[16:59:35.029]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.029]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.029]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.029]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.029]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.029]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.029]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.029]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:35.029]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.029]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.029]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.029]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:35.029]  $ ...future.seeds_ii       : NULL
[16:59:35.029]  $ ...future.globals.maxSize: NULL
[16:59:35.029]  - attr(*, "where")=List of 5
[16:59:35.029]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.029]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.029]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.029]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.029]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.029]  - attr(*, "resolved")= logi FALSE
[16:59:35.029]  - attr(*, "total_size")= num 1240
[16:59:35.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.029]  - attr(*, "already-done")= logi TRUE
[16:59:35.038] - copied ‘...future.FUN’ to environment
[16:59:35.038] - copied ‘future.call.arguments’ to environment
[16:59:35.038] - copied ‘...future.elements_ii’ to environment
[16:59:35.038] - copied ‘...future.seeds_ii’ to environment
[16:59:35.038] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.038] assign_globals() ... done
[16:59:35.040] plan(): Setting new future strategy stack:
[16:59:35.041] List of future strategies:
[16:59:35.041] 1. sequential:
[16:59:35.041]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.041]    - tweaked: FALSE
[16:59:35.041]    - call: NULL
[16:59:35.041] plan(): nbrOfWorkers() = 1
[16:59:35.044] plan(): Setting new future strategy stack:
[16:59:35.044] List of future strategies:
[16:59:35.044] 1. sequential:
[16:59:35.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.044]    - tweaked: FALSE
[16:59:35.044]    - call: plan(strategy)
[16:59:35.044] plan(): nbrOfWorkers() = 1
[16:59:35.045] SequentialFuture started (and completed)
[16:59:35.045] - Launch lazy future ... done
[16:59:35.045] run() for ‘SequentialFuture’ ... done
[16:59:35.045] Created future:
[16:59:35.045] SequentialFuture:
[16:59:35.045] Label: ‘future_by-1’
[16:59:35.045] Expression:
[16:59:35.045] {
[16:59:35.045]     do.call(function(...) {
[16:59:35.045]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.045]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.045]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.045]             on.exit(options(oopts), add = TRUE)
[16:59:35.045]         }
[16:59:35.045]         {
[16:59:35.045]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.045]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.045]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.045]             })
[16:59:35.045]         }
[16:59:35.045]     }, args = future.call.arguments)
[16:59:35.045] }
[16:59:35.045] Lazy evaluation: FALSE
[16:59:35.045] Asynchronous evaluation: FALSE
[16:59:35.045] Local evaluation: TRUE
[16:59:35.045] Environment: 0x562052720960
[16:59:35.045] Capture standard output: TRUE
[16:59:35.045] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.045] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.045] Packages: <none>
[16:59:35.045] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.045] Resolved: TRUE
[16:59:35.045] Value: 5.37 KiB of class ‘list’
[16:59:35.045] Early signaling: FALSE
[16:59:35.045] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.045] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:35.047] Chunk #1 of 1 ... DONE
[16:59:35.047] Launching 1 futures (chunks) ... DONE
[16:59:35.047] Resolving 1 futures (chunks) ...
[16:59:35.047] resolve() on list ...
[16:59:35.047]  recursive: 0
[16:59:35.047]  length: 1
[16:59:35.047] 
[16:59:35.047] resolved() for ‘SequentialFuture’ ...
[16:59:35.047] - state: ‘finished’
[16:59:35.047] - run: TRUE
[16:59:35.048] - result: ‘FutureResult’
[16:59:35.048] resolved() for ‘SequentialFuture’ ... done
[16:59:35.048] Future #1
[16:59:35.048] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:35.048] - nx: 1
[16:59:35.048] - relay: TRUE
[16:59:35.048] - stdout: TRUE
[16:59:35.048] - signal: TRUE
[16:59:35.048] - resignal: FALSE
[16:59:35.048] - force: TRUE
[16:59:35.049] - relayed: [n=1] FALSE
[16:59:35.049] - queued futures: [n=1] FALSE
[16:59:35.049]  - until=1
[16:59:35.049]  - relaying element #1
[16:59:35.049] - relayed: [n=1] TRUE
[16:59:35.049] - queued futures: [n=1] TRUE
[16:59:35.049] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:35.049]  length: 0 (resolved future 1)
[16:59:35.049] Relaying remaining futures
[16:59:35.049] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.050] - nx: 1
[16:59:35.050] - relay: TRUE
[16:59:35.050] - stdout: TRUE
[16:59:35.050] - signal: TRUE
[16:59:35.050] - resignal: FALSE
[16:59:35.050] - force: TRUE
[16:59:35.050] - relayed: [n=1] TRUE
[16:59:35.050] - queued futures: [n=1] TRUE
 - flush all
[16:59:35.050] - relayed: [n=1] TRUE
[16:59:35.050] - queued futures: [n=1] TRUE
[16:59:35.050] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.051] resolve() on list ... DONE
[16:59:35.051]  - Number of value chunks collected: 1
[16:59:35.051] Resolving 1 futures (chunks) ... DONE
[16:59:35.051] Reducing values from 1 chunks ...
[16:59:35.051]  - Number of values collected after concatenation: 3
[16:59:35.051]  - Number of values expected: 3
[16:59:35.051] Reducing values from 1 chunks ... DONE
[16:59:35.051] future_lapply() ... DONE
[16:59:35.051] future_by_internal() ... DONE
[16:59:35.052] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:59:35.053] future_lapply() ...
[16:59:35.053] Number of chunks: 1
[16:59:35.053] getGlobalsAndPackagesXApply() ...
[16:59:35.053]  - future.globals: TRUE
[16:59:35.053] getGlobalsAndPackages() ...
[16:59:35.054] Searching for globals...
[16:59:35.055] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:35.055] Searching for globals ... DONE
[16:59:35.055] Resolving globals: FALSE
[16:59:35.055] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:35.055] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:35.056] - globals: [1] ‘FUN’
[16:59:35.056] 
[16:59:35.056] getGlobalsAndPackages() ... DONE
[16:59:35.056]  - globals found/used: [n=1] ‘FUN’
[16:59:35.056]  - needed namespaces: [n=0] 
[16:59:35.056] Finding globals ... DONE
[16:59:35.056]  - use_args: TRUE
[16:59:35.056]  - Getting '...' globals ...
[16:59:35.057] resolve() on list ...
[16:59:35.057]  recursive: 0
[16:59:35.057]  length: 1
[16:59:35.057]  elements: ‘...’
[16:59:35.057]  length: 0 (resolved future 1)
[16:59:35.057] resolve() on list ... DONE
[16:59:35.057]    - '...' content: [n=0] 
[16:59:35.057] List of 1
[16:59:35.057]  $ ...: list()
[16:59:35.057]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.057]  - attr(*, "where")=List of 1
[16:59:35.057]   ..$ ...:<environment: 0x5620521ae998> 
[16:59:35.057]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.057]  - attr(*, "resolved")= logi TRUE
[16:59:35.057]  - attr(*, "total_size")= num NA
[16:59:35.060]  - Getting '...' globals ... DONE
[16:59:35.060] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.060] List of 2
[16:59:35.060]  $ ...future.FUN:function (object, ...)  
[16:59:35.060]  $ ...          : list()
[16:59:35.060]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.060]  - attr(*, "where")=List of 2
[16:59:35.060]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.060]   ..$ ...          :<environment: 0x5620521ae998> 
[16:59:35.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.060]  - attr(*, "resolved")= logi FALSE
[16:59:35.060]  - attr(*, "total_size")= num 1240
[16:59:35.065] Packages to be attached in all futures: [n=0] 
[16:59:35.065] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.065] Number of futures (= number of chunks): 1
[16:59:35.065] Launching 1 futures (chunks) ...
[16:59:35.065] Chunk #1 of 1 ...
[16:59:35.066]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.066] getGlobalsAndPackages() ...
[16:59:35.066] Searching for globals...
[16:59:35.066] 
[16:59:35.066] Searching for globals ... DONE
[16:59:35.067] - globals: [0] <none>
[16:59:35.067] getGlobalsAndPackages() ... DONE
[16:59:35.067]    + additional globals found: [n=0] 
[16:59:35.067]    + additional namespaces needed: [n=0] 
[16:59:35.067]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.067]  - seeds: <none>
[16:59:35.067]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.067] getGlobalsAndPackages() ...
[16:59:35.067] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.068] Resolving globals: FALSE
[16:59:35.068] Tweak future expression to call with '...' arguments ...
[16:59:35.068] {
[16:59:35.068]     do.call(function(...) {
[16:59:35.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.068]             on.exit(options(oopts), add = TRUE)
[16:59:35.068]         }
[16:59:35.068]         {
[16:59:35.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.068]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.068]             })
[16:59:35.068]         }
[16:59:35.068]     }, args = future.call.arguments)
[16:59:35.068] }
[16:59:35.068] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.069] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.069] 
[16:59:35.069] getGlobalsAndPackages() ... DONE
[16:59:35.069] run() for ‘Future’ ...
[16:59:35.069] - state: ‘created’
[16:59:35.069] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:59:35.070] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:35.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:59:35.070]   - Field: ‘label’
[16:59:35.070]   - Field: ‘local’
[16:59:35.070]   - Field: ‘owner’
[16:59:35.070]   - Field: ‘envir’
[16:59:35.070]   - Field: ‘packages’
[16:59:35.070]   - Field: ‘gc’
[16:59:35.070]   - Field: ‘conditions’
[16:59:35.070]   - Field: ‘expr’
[16:59:35.071]   - Field: ‘uuid’
[16:59:35.071]   - Field: ‘seed’
[16:59:35.071]   - Field: ‘version’
[16:59:35.071]   - Field: ‘result’
[16:59:35.071]   - Field: ‘asynchronous’
[16:59:35.071]   - Field: ‘calls’
[16:59:35.071]   - Field: ‘globals’
[16:59:35.071]   - Field: ‘stdout’
[16:59:35.071]   - Field: ‘earlySignal’
[16:59:35.071]   - Field: ‘lazy’
[16:59:35.071]   - Field: ‘state’
[16:59:35.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:59:35.072] - Launch lazy future ...
[16:59:35.072] Packages needed by the future expression (n = 0): <none>
[16:59:35.072] Packages needed by future strategies (n = 0): <none>
[16:59:35.072] {
[16:59:35.072]     {
[16:59:35.072]         {
[16:59:35.072]             ...future.startTime <- base::Sys.time()
[16:59:35.072]             {
[16:59:35.072]                 {
[16:59:35.072]                   {
[16:59:35.072]                     base::local({
[16:59:35.072]                       has_future <- base::requireNamespace("future", 
[16:59:35.072]                         quietly = TRUE)
[16:59:35.072]                       if (has_future) {
[16:59:35.072]                         ns <- base::getNamespace("future")
[16:59:35.072]                         version <- ns[[".package"]][["version"]]
[16:59:35.072]                         if (is.null(version)) 
[16:59:35.072]                           version <- utils::packageVersion("future")
[16:59:35.072]                       }
[16:59:35.072]                       else {
[16:59:35.072]                         version <- NULL
[16:59:35.072]                       }
[16:59:35.072]                       if (!has_future || version < "1.8.0") {
[16:59:35.072]                         info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.072]                           "", base::R.version$version.string), 
[16:59:35.072]                           platform = base::sprintf("%s (%s-bit)", 
[16:59:35.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.072]                             "release", "version")], collapse = " "), 
[16:59:35.072]                           hostname = base::Sys.info()[["nodename"]])
[16:59:35.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.072]                           info)
[16:59:35.072]                         info <- base::paste(info, collapse = "; ")
[16:59:35.072]                         if (!has_future) {
[16:59:35.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.072]                             info)
[16:59:35.072]                         }
[16:59:35.072]                         else {
[16:59:35.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.072]                             info, version)
[16:59:35.072]                         }
[16:59:35.072]                         base::stop(msg)
[16:59:35.072]                       }
[16:59:35.072]                     })
[16:59:35.072]                   }
[16:59:35.072]                   ...future.strategy.old <- future::plan("list")
[16:59:35.072]                   options(future.plan = NULL)
[16:59:35.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.072]                 }
[16:59:35.072]                 ...future.workdir <- getwd()
[16:59:35.072]             }
[16:59:35.072]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.072]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.072]         }
[16:59:35.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:35.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.072]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.072]             base::names(...future.oldOptions))
[16:59:35.072]     }
[16:59:35.072]     if (FALSE) {
[16:59:35.072]     }
[16:59:35.072]     else {
[16:59:35.072]         if (TRUE) {
[16:59:35.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.072]                 open = "w")
[16:59:35.072]         }
[16:59:35.072]         else {
[16:59:35.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.072]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.072]         }
[16:59:35.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.072]             base::sink(type = "output", split = FALSE)
[16:59:35.072]             base::close(...future.stdout)
[16:59:35.072]         }, add = TRUE)
[16:59:35.072]     }
[16:59:35.072]     ...future.frame <- base::sys.nframe()
[16:59:35.072]     ...future.conditions <- base::list()
[16:59:35.072]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.072]     if (FALSE) {
[16:59:35.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.072]     }
[16:59:35.072]     ...future.result <- base::tryCatch({
[16:59:35.072]         base::withCallingHandlers({
[16:59:35.072]             ...future.value <- base::withVisible(base::local({
[16:59:35.072]                 do.call(function(...) {
[16:59:35.072]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.072]                   if (!identical(...future.globals.maxSize.org, 
[16:59:35.072]                     ...future.globals.maxSize)) {
[16:59:35.072]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.072]                     on.exit(options(oopts), add = TRUE)
[16:59:35.072]                   }
[16:59:35.072]                   {
[16:59:35.072]                     lapply(seq_along(...future.elements_ii), 
[16:59:35.072]                       FUN = function(jj) {
[16:59:35.072]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.072]                         ...future.FUN(...future.X_jj, ...)
[16:59:35.072]                       })
[16:59:35.072]                   }
[16:59:35.072]                 }, args = future.call.arguments)
[16:59:35.072]             }))
[16:59:35.072]             future::FutureResult(value = ...future.value$value, 
[16:59:35.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.072]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.072]                     ...future.globalenv.names))
[16:59:35.072]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.072]         }, condition = base::local({
[16:59:35.072]             c <- base::c
[16:59:35.072]             inherits <- base::inherits
[16:59:35.072]             invokeRestart <- base::invokeRestart
[16:59:35.072]             length <- base::length
[16:59:35.072]             list <- base::list
[16:59:35.072]             seq.int <- base::seq.int
[16:59:35.072]             signalCondition <- base::signalCondition
[16:59:35.072]             sys.calls <- base::sys.calls
[16:59:35.072]             `[[` <- base::`[[`
[16:59:35.072]             `+` <- base::`+`
[16:59:35.072]             `<<-` <- base::`<<-`
[16:59:35.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.072]                   3L)]
[16:59:35.072]             }
[16:59:35.072]             function(cond) {
[16:59:35.072]                 is_error <- inherits(cond, "error")
[16:59:35.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.072]                   NULL)
[16:59:35.072]                 if (is_error) {
[16:59:35.072]                   sessionInformation <- function() {
[16:59:35.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.072]                       search = base::search(), system = base::Sys.info())
[16:59:35.072]                   }
[16:59:35.072]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.072]                     cond$call), session = sessionInformation(), 
[16:59:35.072]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.072]                   signalCondition(cond)
[16:59:35.072]                 }
[16:59:35.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.072]                 "immediateCondition"))) {
[16:59:35.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.072]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.072]                   if (TRUE && !signal) {
[16:59:35.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.072]                     {
[16:59:35.072]                       inherits <- base::inherits
[16:59:35.072]                       invokeRestart <- base::invokeRestart
[16:59:35.072]                       is.null <- base::is.null
[16:59:35.072]                       muffled <- FALSE
[16:59:35.072]                       if (inherits(cond, "message")) {
[16:59:35.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.072]                         if (muffled) 
[16:59:35.072]                           invokeRestart("muffleMessage")
[16:59:35.072]                       }
[16:59:35.072]                       else if (inherits(cond, "warning")) {
[16:59:35.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.072]                         if (muffled) 
[16:59:35.072]                           invokeRestart("muffleWarning")
[16:59:35.072]                       }
[16:59:35.072]                       else if (inherits(cond, "condition")) {
[16:59:35.072]                         if (!is.null(pattern)) {
[16:59:35.072]                           computeRestarts <- base::computeRestarts
[16:59:35.072]                           grepl <- base::grepl
[16:59:35.072]                           restarts <- computeRestarts(cond)
[16:59:35.072]                           for (restart in restarts) {
[16:59:35.072]                             name <- restart$name
[16:59:35.072]                             if (is.null(name)) 
[16:59:35.072]                               next
[16:59:35.072]                             if (!grepl(pattern, name)) 
[16:59:35.072]                               next
[16:59:35.072]                             invokeRestart(restart)
[16:59:35.072]                             muffled <- TRUE
[16:59:35.072]                             break
[16:59:35.072]                           }
[16:59:35.072]                         }
[16:59:35.072]                       }
[16:59:35.072]                       invisible(muffled)
[16:59:35.072]                     }
[16:59:35.072]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.072]                   }
[16:59:35.072]                 }
[16:59:35.072]                 else {
[16:59:35.072]                   if (TRUE) {
[16:59:35.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.072]                     {
[16:59:35.072]                       inherits <- base::inherits
[16:59:35.072]                       invokeRestart <- base::invokeRestart
[16:59:35.072]                       is.null <- base::is.null
[16:59:35.072]                       muffled <- FALSE
[16:59:35.072]                       if (inherits(cond, "message")) {
[16:59:35.072]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.072]                         if (muffled) 
[16:59:35.072]                           invokeRestart("muffleMessage")
[16:59:35.072]                       }
[16:59:35.072]                       else if (inherits(cond, "warning")) {
[16:59:35.072]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.072]                         if (muffled) 
[16:59:35.072]                           invokeRestart("muffleWarning")
[16:59:35.072]                       }
[16:59:35.072]                       else if (inherits(cond, "condition")) {
[16:59:35.072]                         if (!is.null(pattern)) {
[16:59:35.072]                           computeRestarts <- base::computeRestarts
[16:59:35.072]                           grepl <- base::grepl
[16:59:35.072]                           restarts <- computeRestarts(cond)
[16:59:35.072]                           for (restart in restarts) {
[16:59:35.072]                             name <- restart$name
[16:59:35.072]                             if (is.null(name)) 
[16:59:35.072]                               next
[16:59:35.072]                             if (!grepl(pattern, name)) 
[16:59:35.072]                               next
[16:59:35.072]                             invokeRestart(restart)
[16:59:35.072]                             muffled <- TRUE
[16:59:35.072]                             break
[16:59:35.072]                           }
[16:59:35.072]                         }
[16:59:35.072]                       }
[16:59:35.072]                       invisible(muffled)
[16:59:35.072]                     }
[16:59:35.072]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.072]                   }
[16:59:35.072]                 }
[16:59:35.072]             }
[16:59:35.072]         }))
[16:59:35.072]     }, error = function(ex) {
[16:59:35.072]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.072]                 ...future.rng), started = ...future.startTime, 
[16:59:35.072]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.072]             version = "1.8"), class = "FutureResult")
[16:59:35.072]     }, finally = {
[16:59:35.072]         if (!identical(...future.workdir, getwd())) 
[16:59:35.072]             setwd(...future.workdir)
[16:59:35.072]         {
[16:59:35.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.072]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.072]             }
[16:59:35.072]             base::options(...future.oldOptions)
[16:59:35.072]             if (.Platform$OS.type == "windows") {
[16:59:35.072]                 old_names <- names(...future.oldEnvVars)
[16:59:35.072]                 envs <- base::Sys.getenv()
[16:59:35.072]                 names <- names(envs)
[16:59:35.072]                 common <- intersect(names, old_names)
[16:59:35.072]                 added <- setdiff(names, old_names)
[16:59:35.072]                 removed <- setdiff(old_names, names)
[16:59:35.072]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.072]                   envs[common]]
[16:59:35.072]                 NAMES <- toupper(changed)
[16:59:35.072]                 args <- list()
[16:59:35.072]                 for (kk in seq_along(NAMES)) {
[16:59:35.072]                   name <- changed[[kk]]
[16:59:35.072]                   NAME <- NAMES[[kk]]
[16:59:35.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.072]                     next
[16:59:35.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.072]                 }
[16:59:35.072]                 NAMES <- toupper(added)
[16:59:35.072]                 for (kk in seq_along(NAMES)) {
[16:59:35.072]                   name <- added[[kk]]
[16:59:35.072]                   NAME <- NAMES[[kk]]
[16:59:35.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.072]                     next
[16:59:35.072]                   args[[name]] <- ""
[16:59:35.072]                 }
[16:59:35.072]                 NAMES <- toupper(removed)
[16:59:35.072]                 for (kk in seq_along(NAMES)) {
[16:59:35.072]                   name <- removed[[kk]]
[16:59:35.072]                   NAME <- NAMES[[kk]]
[16:59:35.072]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.072]                     next
[16:59:35.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.072]                 }
[16:59:35.072]                 if (length(args) > 0) 
[16:59:35.072]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.072]             }
[16:59:35.072]             else {
[16:59:35.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.072]             }
[16:59:35.072]             {
[16:59:35.072]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.072]                   0L) {
[16:59:35.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.072]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.072]                   base::options(opts)
[16:59:35.072]                 }
[16:59:35.072]                 {
[16:59:35.072]                   {
[16:59:35.072]                     NULL
[16:59:35.072]                     RNGkind("Mersenne-Twister")
[16:59:35.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:59:35.072]                       inherits = FALSE)
[16:59:35.072]                   }
[16:59:35.072]                   options(future.plan = NULL)
[16:59:35.072]                   if (is.na(NA_character_)) 
[16:59:35.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.072]                     .init = FALSE)
[16:59:35.072]                 }
[16:59:35.072]             }
[16:59:35.072]         }
[16:59:35.072]     })
[16:59:35.072]     if (TRUE) {
[16:59:35.072]         base::sink(type = "output", split = FALSE)
[16:59:35.072]         if (TRUE) {
[16:59:35.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.072]         }
[16:59:35.072]         else {
[16:59:35.072]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.072]         }
[16:59:35.072]         base::close(...future.stdout)
[16:59:35.072]         ...future.stdout <- NULL
[16:59:35.072]     }
[16:59:35.072]     ...future.result$conditions <- ...future.conditions
[16:59:35.072]     ...future.result$finished <- base::Sys.time()
[16:59:35.072]     ...future.result
[16:59:35.072] }
[16:59:35.074] assign_globals() ...
[16:59:35.074] List of 5
[16:59:35.074]  $ ...future.FUN            :function (object, ...)  
[16:59:35.074]  $ future.call.arguments    : list()
[16:59:35.074]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.074]  $ ...future.elements_ii    :List of 3
[16:59:35.074]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.074]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.074]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.074]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.074]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.074]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.074]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.074]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:35.074]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.074]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.074]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.074]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:35.074]  $ ...future.seeds_ii       : NULL
[16:59:35.074]  $ ...future.globals.maxSize: NULL
[16:59:35.074]  - attr(*, "where")=List of 5
[16:59:35.074]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.074]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.074]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.074]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.074]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.074]  - attr(*, "resolved")= logi FALSE
[16:59:35.074]  - attr(*, "total_size")= num 1240
[16:59:35.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.074]  - attr(*, "already-done")= logi TRUE
[16:59:35.083] - copied ‘...future.FUN’ to environment
[16:59:35.083] - copied ‘future.call.arguments’ to environment
[16:59:35.083] - copied ‘...future.elements_ii’ to environment
[16:59:35.083] - copied ‘...future.seeds_ii’ to environment
[16:59:35.083] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.083] assign_globals() ... done
[16:59:35.083] plan(): Setting new future strategy stack:
[16:59:35.083] List of future strategies:
[16:59:35.083] 1. sequential:
[16:59:35.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.083]    - tweaked: FALSE
[16:59:35.083]    - call: NULL
[16:59:35.084] plan(): nbrOfWorkers() = 1
[16:59:35.089] plan(): Setting new future strategy stack:
[16:59:35.089] List of future strategies:
[16:59:35.089] 1. sequential:
[16:59:35.089]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.089]    - tweaked: FALSE
[16:59:35.089]    - call: plan(strategy)
[16:59:35.089] plan(): nbrOfWorkers() = 1
[16:59:35.089] SequentialFuture started (and completed)
[16:59:35.090] - Launch lazy future ... done
[16:59:35.090] run() for ‘SequentialFuture’ ... done
[16:59:35.090] Created future:
[16:59:35.090] SequentialFuture:
[16:59:35.090] Label: ‘future_by-1’
[16:59:35.090] Expression:
[16:59:35.090] {
[16:59:35.090]     do.call(function(...) {
[16:59:35.090]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.090]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.090]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.090]             on.exit(options(oopts), add = TRUE)
[16:59:35.090]         }
[16:59:35.090]         {
[16:59:35.090]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.090]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.090]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.090]             })
[16:59:35.090]         }
[16:59:35.090]     }, args = future.call.arguments)
[16:59:35.090] }
[16:59:35.090] Lazy evaluation: FALSE
[16:59:35.090] Asynchronous evaluation: FALSE
[16:59:35.090] Local evaluation: TRUE
[16:59:35.090] Environment: 0x5620520e99e0
[16:59:35.090] Capture standard output: TRUE
[16:59:35.090] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.090] Globals: 5 objects totaling 6.02 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 4.80 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.090] Packages: <none>
[16:59:35.090] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.090] Resolved: TRUE
[16:59:35.090] Value: 5.37 KiB of class ‘list’
[16:59:35.090] Early signaling: FALSE
[16:59:35.090] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.090] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:59:35.092] Chunk #1 of 1 ... DONE
[16:59:35.092] Launching 1 futures (chunks) ... DONE
[16:59:35.092] Resolving 1 futures (chunks) ...
[16:59:35.092] resolve() on list ...
[16:59:35.092]  recursive: 0
[16:59:35.092]  length: 1
[16:59:35.092] 
[16:59:35.092] resolved() for ‘SequentialFuture’ ...
[16:59:35.092] - state: ‘finished’
[16:59:35.093] - run: TRUE
[16:59:35.093] - result: ‘FutureResult’
[16:59:35.093] resolved() for ‘SequentialFuture’ ... done
[16:59:35.093] Future #1
[16:59:35.093] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:59:35.093] - nx: 1
[16:59:35.093] - relay: TRUE
[16:59:35.093] - stdout: TRUE
[16:59:35.093] - signal: TRUE
[16:59:35.093] - resignal: FALSE
[16:59:35.094] - force: TRUE
[16:59:35.094] - relayed: [n=1] FALSE
[16:59:35.094] - queued futures: [n=1] FALSE
[16:59:35.094]  - until=1
[16:59:35.094]  - relaying element #1
[16:59:35.094] - relayed: [n=1] TRUE
[16:59:35.094] - queued futures: [n=1] TRUE
[16:59:35.094] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:59:35.094]  length: 0 (resolved future 1)
[16:59:35.094] Relaying remaining futures
[16:59:35.095] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.095] - nx: 1
[16:59:35.095] - relay: TRUE
[16:59:35.095] - stdout: TRUE
[16:59:35.095] - signal: TRUE
[16:59:35.095] - resignal: FALSE
[16:59:35.095] - force: TRUE
[16:59:35.095] - relayed: [n=1] TRUE
[16:59:35.095] - queued futures: [n=1] TRUE
 - flush all
[16:59:35.095] - relayed: [n=1] TRUE
[16:59:35.095] - queued futures: [n=1] TRUE
[16:59:35.096] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.096] resolve() on list ... DONE
[16:59:35.096]  - Number of value chunks collected: 1
[16:59:35.096] Resolving 1 futures (chunks) ... DONE
[16:59:35.096] Reducing values from 1 chunks ...
[16:59:35.096]  - Number of values collected after concatenation: 3
[16:59:35.096]  - Number of values expected: 3
[16:59:35.096] Reducing values from 1 chunks ... DONE
[16:59:35.096] future_lapply() ... DONE
[16:59:35.096] future_by_internal() ... DONE
[16:59:35.097] future_by_internal() ...
- plan('multicore') ...
[16:59:35.098] plan(): Setting new future strategy stack:
[16:59:35.098] List of future strategies:
[16:59:35.098] 1. multicore:
[16:59:35.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.098]    - tweaked: FALSE
[16:59:35.098]    - call: plan(strategy)
[16:59:35.102] plan(): nbrOfWorkers() = 2
[16:59:35.102] future_by_internal() ...
[16:59:35.102] future_lapply() ...
[16:59:35.107] Number of chunks: 2
[16:59:35.107] getGlobalsAndPackagesXApply() ...
[16:59:35.107]  - future.globals: TRUE
[16:59:35.107] getGlobalsAndPackages() ...
[16:59:35.107] Searching for globals...
[16:59:35.108] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:35.108] Searching for globals ... DONE
[16:59:35.108] Resolving globals: FALSE
[16:59:35.109] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:35.109] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:35.109] - globals: [1] ‘FUN’
[16:59:35.109] 
[16:59:35.109] getGlobalsAndPackages() ... DONE
[16:59:35.110]  - globals found/used: [n=1] ‘FUN’
[16:59:35.110]  - needed namespaces: [n=0] 
[16:59:35.110] Finding globals ... DONE
[16:59:35.110]  - use_args: TRUE
[16:59:35.110]  - Getting '...' globals ...
[16:59:35.110] resolve() on list ...
[16:59:35.110]  recursive: 0
[16:59:35.110]  length: 1
[16:59:35.111]  elements: ‘...’
[16:59:35.111]  length: 0 (resolved future 1)
[16:59:35.111] resolve() on list ... DONE
[16:59:35.111]    - '...' content: [n=0] 
[16:59:35.111] List of 1
[16:59:35.111]  $ ...: list()
[16:59:35.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.111]  - attr(*, "where")=List of 1
[16:59:35.111]   ..$ ...:<environment: 0x5620524e6d20> 
[16:59:35.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.111]  - attr(*, "resolved")= logi TRUE
[16:59:35.111]  - attr(*, "total_size")= num NA
[16:59:35.115]  - Getting '...' globals ... DONE
[16:59:35.116] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.116] List of 2
[16:59:35.116]  $ ...future.FUN:function (object, ...)  
[16:59:35.116]  $ ...          : list()
[16:59:35.116]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.116]  - attr(*, "where")=List of 2
[16:59:35.116]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.116]   ..$ ...          :<environment: 0x5620524e6d20> 
[16:59:35.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.116]  - attr(*, "resolved")= logi FALSE
[16:59:35.116]  - attr(*, "total_size")= num 1240
[16:59:35.119] Packages to be attached in all futures: [n=0] 
[16:59:35.119] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.119] Number of futures (= number of chunks): 2
[16:59:35.120] Launching 2 futures (chunks) ...
[16:59:35.120] Chunk #1 of 2 ...
[16:59:35.120]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.120] getGlobalsAndPackages() ...
[16:59:35.120] Searching for globals...
[16:59:35.120] 
[16:59:35.121] Searching for globals ... DONE
[16:59:35.121] - globals: [0] <none>
[16:59:35.121] getGlobalsAndPackages() ... DONE
[16:59:35.121]    + additional globals found: [n=0] 
[16:59:35.121]    + additional namespaces needed: [n=0] 
[16:59:35.121]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.121]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.121]  - seeds: <none>
[16:59:35.121]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.121] getGlobalsAndPackages() ...
[16:59:35.121] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.122] Resolving globals: FALSE
[16:59:35.122] Tweak future expression to call with '...' arguments ...
[16:59:35.122] {
[16:59:35.122]     do.call(function(...) {
[16:59:35.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.122]             on.exit(options(oopts), add = TRUE)
[16:59:35.122]         }
[16:59:35.122]         {
[16:59:35.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.122]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.122]             })
[16:59:35.122]         }
[16:59:35.122]     }, args = future.call.arguments)
[16:59:35.122] }
[16:59:35.122] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.122] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.123] 
[16:59:35.123] getGlobalsAndPackages() ... DONE
[16:59:35.123] run() for ‘Future’ ...
[16:59:35.123] - state: ‘created’
[16:59:35.123] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.127] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.127]   - Field: ‘label’
[16:59:35.127]   - Field: ‘local’
[16:59:35.127]   - Field: ‘owner’
[16:59:35.127]   - Field: ‘envir’
[16:59:35.128]   - Field: ‘workers’
[16:59:35.128]   - Field: ‘packages’
[16:59:35.128]   - Field: ‘gc’
[16:59:35.128]   - Field: ‘job’
[16:59:35.128]   - Field: ‘conditions’
[16:59:35.128]   - Field: ‘expr’
[16:59:35.128]   - Field: ‘uuid’
[16:59:35.128]   - Field: ‘seed’
[16:59:35.128]   - Field: ‘version’
[16:59:35.128]   - Field: ‘result’
[16:59:35.129]   - Field: ‘asynchronous’
[16:59:35.129]   - Field: ‘calls’
[16:59:35.129]   - Field: ‘globals’
[16:59:35.129]   - Field: ‘stdout’
[16:59:35.129]   - Field: ‘earlySignal’
[16:59:35.129]   - Field: ‘lazy’
[16:59:35.129]   - Field: ‘state’
[16:59:35.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.129] - Launch lazy future ...
[16:59:35.130] Packages needed by the future expression (n = 0): <none>
[16:59:35.130] Packages needed by future strategies (n = 0): <none>
[16:59:35.131] {
[16:59:35.131]     {
[16:59:35.131]         {
[16:59:35.131]             ...future.startTime <- base::Sys.time()
[16:59:35.131]             {
[16:59:35.131]                 {
[16:59:35.131]                   {
[16:59:35.131]                     {
[16:59:35.131]                       base::local({
[16:59:35.131]                         has_future <- base::requireNamespace("future", 
[16:59:35.131]                           quietly = TRUE)
[16:59:35.131]                         if (has_future) {
[16:59:35.131]                           ns <- base::getNamespace("future")
[16:59:35.131]                           version <- ns[[".package"]][["version"]]
[16:59:35.131]                           if (is.null(version)) 
[16:59:35.131]                             version <- utils::packageVersion("future")
[16:59:35.131]                         }
[16:59:35.131]                         else {
[16:59:35.131]                           version <- NULL
[16:59:35.131]                         }
[16:59:35.131]                         if (!has_future || version < "1.8.0") {
[16:59:35.131]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.131]                             "", base::R.version$version.string), 
[16:59:35.131]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.131]                               "release", "version")], collapse = " "), 
[16:59:35.131]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.131]                             info)
[16:59:35.131]                           info <- base::paste(info, collapse = "; ")
[16:59:35.131]                           if (!has_future) {
[16:59:35.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.131]                               info)
[16:59:35.131]                           }
[16:59:35.131]                           else {
[16:59:35.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.131]                               info, version)
[16:59:35.131]                           }
[16:59:35.131]                           base::stop(msg)
[16:59:35.131]                         }
[16:59:35.131]                       })
[16:59:35.131]                     }
[16:59:35.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.131]                     base::options(mc.cores = 1L)
[16:59:35.131]                   }
[16:59:35.131]                   ...future.strategy.old <- future::plan("list")
[16:59:35.131]                   options(future.plan = NULL)
[16:59:35.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.131]                 }
[16:59:35.131]                 ...future.workdir <- getwd()
[16:59:35.131]             }
[16:59:35.131]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.131]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.131]         }
[16:59:35.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.131]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.131]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.131]             base::names(...future.oldOptions))
[16:59:35.131]     }
[16:59:35.131]     if (FALSE) {
[16:59:35.131]     }
[16:59:35.131]     else {
[16:59:35.131]         if (TRUE) {
[16:59:35.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.131]                 open = "w")
[16:59:35.131]         }
[16:59:35.131]         else {
[16:59:35.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.131]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.131]         }
[16:59:35.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.131]             base::sink(type = "output", split = FALSE)
[16:59:35.131]             base::close(...future.stdout)
[16:59:35.131]         }, add = TRUE)
[16:59:35.131]     }
[16:59:35.131]     ...future.frame <- base::sys.nframe()
[16:59:35.131]     ...future.conditions <- base::list()
[16:59:35.131]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.131]     if (FALSE) {
[16:59:35.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.131]     }
[16:59:35.131]     ...future.result <- base::tryCatch({
[16:59:35.131]         base::withCallingHandlers({
[16:59:35.131]             ...future.value <- base::withVisible(base::local({
[16:59:35.131]                 withCallingHandlers({
[16:59:35.131]                   {
[16:59:35.131]                     do.call(function(...) {
[16:59:35.131]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.131]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.131]                         ...future.globals.maxSize)) {
[16:59:35.131]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.131]                         on.exit(options(oopts), add = TRUE)
[16:59:35.131]                       }
[16:59:35.131]                       {
[16:59:35.131]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.131]                           FUN = function(jj) {
[16:59:35.131]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.131]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.131]                           })
[16:59:35.131]                       }
[16:59:35.131]                     }, args = future.call.arguments)
[16:59:35.131]                   }
[16:59:35.131]                 }, immediateCondition = function(cond) {
[16:59:35.131]                   save_rds <- function (object, pathname, ...) 
[16:59:35.131]                   {
[16:59:35.131]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.131]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.131]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.131]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.131]                         fi_tmp[["mtime"]])
[16:59:35.131]                     }
[16:59:35.131]                     tryCatch({
[16:59:35.131]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.131]                     }, error = function(ex) {
[16:59:35.131]                       msg <- conditionMessage(ex)
[16:59:35.131]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.131]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.131]                         fi_tmp[["mtime"]], msg)
[16:59:35.131]                       ex$message <- msg
[16:59:35.131]                       stop(ex)
[16:59:35.131]                     })
[16:59:35.131]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.131]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.131]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.131]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.131]                       fi <- file.info(pathname)
[16:59:35.131]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.131]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.131]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.131]                         fi[["size"]], fi[["mtime"]])
[16:59:35.131]                       stop(msg)
[16:59:35.131]                     }
[16:59:35.131]                     invisible(pathname)
[16:59:35.131]                   }
[16:59:35.131]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.131]                     rootPath = tempdir()) 
[16:59:35.131]                   {
[16:59:35.131]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.131]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.131]                       tmpdir = path, fileext = ".rds")
[16:59:35.131]                     save_rds(obj, file)
[16:59:35.131]                   }
[16:59:35.131]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.131]                   {
[16:59:35.131]                     inherits <- base::inherits
[16:59:35.131]                     invokeRestart <- base::invokeRestart
[16:59:35.131]                     is.null <- base::is.null
[16:59:35.131]                     muffled <- FALSE
[16:59:35.131]                     if (inherits(cond, "message")) {
[16:59:35.131]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.131]                       if (muffled) 
[16:59:35.131]                         invokeRestart("muffleMessage")
[16:59:35.131]                     }
[16:59:35.131]                     else if (inherits(cond, "warning")) {
[16:59:35.131]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.131]                       if (muffled) 
[16:59:35.131]                         invokeRestart("muffleWarning")
[16:59:35.131]                     }
[16:59:35.131]                     else if (inherits(cond, "condition")) {
[16:59:35.131]                       if (!is.null(pattern)) {
[16:59:35.131]                         computeRestarts <- base::computeRestarts
[16:59:35.131]                         grepl <- base::grepl
[16:59:35.131]                         restarts <- computeRestarts(cond)
[16:59:35.131]                         for (restart in restarts) {
[16:59:35.131]                           name <- restart$name
[16:59:35.131]                           if (is.null(name)) 
[16:59:35.131]                             next
[16:59:35.131]                           if (!grepl(pattern, name)) 
[16:59:35.131]                             next
[16:59:35.131]                           invokeRestart(restart)
[16:59:35.131]                           muffled <- TRUE
[16:59:35.131]                           break
[16:59:35.131]                         }
[16:59:35.131]                       }
[16:59:35.131]                     }
[16:59:35.131]                     invisible(muffled)
[16:59:35.131]                   }
[16:59:35.131]                   muffleCondition(cond)
[16:59:35.131]                 })
[16:59:35.131]             }))
[16:59:35.131]             future::FutureResult(value = ...future.value$value, 
[16:59:35.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.131]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.131]                     ...future.globalenv.names))
[16:59:35.131]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.131]         }, condition = base::local({
[16:59:35.131]             c <- base::c
[16:59:35.131]             inherits <- base::inherits
[16:59:35.131]             invokeRestart <- base::invokeRestart
[16:59:35.131]             length <- base::length
[16:59:35.131]             list <- base::list
[16:59:35.131]             seq.int <- base::seq.int
[16:59:35.131]             signalCondition <- base::signalCondition
[16:59:35.131]             sys.calls <- base::sys.calls
[16:59:35.131]             `[[` <- base::`[[`
[16:59:35.131]             `+` <- base::`+`
[16:59:35.131]             `<<-` <- base::`<<-`
[16:59:35.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.131]                   3L)]
[16:59:35.131]             }
[16:59:35.131]             function(cond) {
[16:59:35.131]                 is_error <- inherits(cond, "error")
[16:59:35.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.131]                   NULL)
[16:59:35.131]                 if (is_error) {
[16:59:35.131]                   sessionInformation <- function() {
[16:59:35.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.131]                       search = base::search(), system = base::Sys.info())
[16:59:35.131]                   }
[16:59:35.131]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.131]                     cond$call), session = sessionInformation(), 
[16:59:35.131]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.131]                   signalCondition(cond)
[16:59:35.131]                 }
[16:59:35.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.131]                 "immediateCondition"))) {
[16:59:35.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.131]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.131]                   if (TRUE && !signal) {
[16:59:35.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.131]                     {
[16:59:35.131]                       inherits <- base::inherits
[16:59:35.131]                       invokeRestart <- base::invokeRestart
[16:59:35.131]                       is.null <- base::is.null
[16:59:35.131]                       muffled <- FALSE
[16:59:35.131]                       if (inherits(cond, "message")) {
[16:59:35.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.131]                         if (muffled) 
[16:59:35.131]                           invokeRestart("muffleMessage")
[16:59:35.131]                       }
[16:59:35.131]                       else if (inherits(cond, "warning")) {
[16:59:35.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.131]                         if (muffled) 
[16:59:35.131]                           invokeRestart("muffleWarning")
[16:59:35.131]                       }
[16:59:35.131]                       else if (inherits(cond, "condition")) {
[16:59:35.131]                         if (!is.null(pattern)) {
[16:59:35.131]                           computeRestarts <- base::computeRestarts
[16:59:35.131]                           grepl <- base::grepl
[16:59:35.131]                           restarts <- computeRestarts(cond)
[16:59:35.131]                           for (restart in restarts) {
[16:59:35.131]                             name <- restart$name
[16:59:35.131]                             if (is.null(name)) 
[16:59:35.131]                               next
[16:59:35.131]                             if (!grepl(pattern, name)) 
[16:59:35.131]                               next
[16:59:35.131]                             invokeRestart(restart)
[16:59:35.131]                             muffled <- TRUE
[16:59:35.131]                             break
[16:59:35.131]                           }
[16:59:35.131]                         }
[16:59:35.131]                       }
[16:59:35.131]                       invisible(muffled)
[16:59:35.131]                     }
[16:59:35.131]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.131]                   }
[16:59:35.131]                 }
[16:59:35.131]                 else {
[16:59:35.131]                   if (TRUE) {
[16:59:35.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.131]                     {
[16:59:35.131]                       inherits <- base::inherits
[16:59:35.131]                       invokeRestart <- base::invokeRestart
[16:59:35.131]                       is.null <- base::is.null
[16:59:35.131]                       muffled <- FALSE
[16:59:35.131]                       if (inherits(cond, "message")) {
[16:59:35.131]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.131]                         if (muffled) 
[16:59:35.131]                           invokeRestart("muffleMessage")
[16:59:35.131]                       }
[16:59:35.131]                       else if (inherits(cond, "warning")) {
[16:59:35.131]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.131]                         if (muffled) 
[16:59:35.131]                           invokeRestart("muffleWarning")
[16:59:35.131]                       }
[16:59:35.131]                       else if (inherits(cond, "condition")) {
[16:59:35.131]                         if (!is.null(pattern)) {
[16:59:35.131]                           computeRestarts <- base::computeRestarts
[16:59:35.131]                           grepl <- base::grepl
[16:59:35.131]                           restarts <- computeRestarts(cond)
[16:59:35.131]                           for (restart in restarts) {
[16:59:35.131]                             name <- restart$name
[16:59:35.131]                             if (is.null(name)) 
[16:59:35.131]                               next
[16:59:35.131]                             if (!grepl(pattern, name)) 
[16:59:35.131]                               next
[16:59:35.131]                             invokeRestart(restart)
[16:59:35.131]                             muffled <- TRUE
[16:59:35.131]                             break
[16:59:35.131]                           }
[16:59:35.131]                         }
[16:59:35.131]                       }
[16:59:35.131]                       invisible(muffled)
[16:59:35.131]                     }
[16:59:35.131]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.131]                   }
[16:59:35.131]                 }
[16:59:35.131]             }
[16:59:35.131]         }))
[16:59:35.131]     }, error = function(ex) {
[16:59:35.131]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.131]                 ...future.rng), started = ...future.startTime, 
[16:59:35.131]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.131]             version = "1.8"), class = "FutureResult")
[16:59:35.131]     }, finally = {
[16:59:35.131]         if (!identical(...future.workdir, getwd())) 
[16:59:35.131]             setwd(...future.workdir)
[16:59:35.131]         {
[16:59:35.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.131]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.131]             }
[16:59:35.131]             base::options(...future.oldOptions)
[16:59:35.131]             if (.Platform$OS.type == "windows") {
[16:59:35.131]                 old_names <- names(...future.oldEnvVars)
[16:59:35.131]                 envs <- base::Sys.getenv()
[16:59:35.131]                 names <- names(envs)
[16:59:35.131]                 common <- intersect(names, old_names)
[16:59:35.131]                 added <- setdiff(names, old_names)
[16:59:35.131]                 removed <- setdiff(old_names, names)
[16:59:35.131]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.131]                   envs[common]]
[16:59:35.131]                 NAMES <- toupper(changed)
[16:59:35.131]                 args <- list()
[16:59:35.131]                 for (kk in seq_along(NAMES)) {
[16:59:35.131]                   name <- changed[[kk]]
[16:59:35.131]                   NAME <- NAMES[[kk]]
[16:59:35.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.131]                     next
[16:59:35.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.131]                 }
[16:59:35.131]                 NAMES <- toupper(added)
[16:59:35.131]                 for (kk in seq_along(NAMES)) {
[16:59:35.131]                   name <- added[[kk]]
[16:59:35.131]                   NAME <- NAMES[[kk]]
[16:59:35.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.131]                     next
[16:59:35.131]                   args[[name]] <- ""
[16:59:35.131]                 }
[16:59:35.131]                 NAMES <- toupper(removed)
[16:59:35.131]                 for (kk in seq_along(NAMES)) {
[16:59:35.131]                   name <- removed[[kk]]
[16:59:35.131]                   NAME <- NAMES[[kk]]
[16:59:35.131]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.131]                     next
[16:59:35.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.131]                 }
[16:59:35.131]                 if (length(args) > 0) 
[16:59:35.131]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.131]             }
[16:59:35.131]             else {
[16:59:35.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.131]             }
[16:59:35.131]             {
[16:59:35.131]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.131]                   0L) {
[16:59:35.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.131]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.131]                   base::options(opts)
[16:59:35.131]                 }
[16:59:35.131]                 {
[16:59:35.131]                   {
[16:59:35.131]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.131]                     NULL
[16:59:35.131]                   }
[16:59:35.131]                   options(future.plan = NULL)
[16:59:35.131]                   if (is.na(NA_character_)) 
[16:59:35.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.131]                     .init = FALSE)
[16:59:35.131]                 }
[16:59:35.131]             }
[16:59:35.131]         }
[16:59:35.131]     })
[16:59:35.131]     if (TRUE) {
[16:59:35.131]         base::sink(type = "output", split = FALSE)
[16:59:35.131]         if (TRUE) {
[16:59:35.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.131]         }
[16:59:35.131]         else {
[16:59:35.131]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.131]         }
[16:59:35.131]         base::close(...future.stdout)
[16:59:35.131]         ...future.stdout <- NULL
[16:59:35.131]     }
[16:59:35.131]     ...future.result$conditions <- ...future.conditions
[16:59:35.131]     ...future.result$finished <- base::Sys.time()
[16:59:35.131]     ...future.result
[16:59:35.131] }
[16:59:35.133] assign_globals() ...
[16:59:35.133] List of 5
[16:59:35.133]  $ ...future.FUN            :function (object, ...)  
[16:59:35.133]  $ future.call.arguments    : list()
[16:59:35.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.133]  $ ...future.elements_ii    :List of 1
[16:59:35.133]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:35.133]   .. ..$ breaks: num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.133]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.133]  $ ...future.seeds_ii       : NULL
[16:59:35.133]  $ ...future.globals.maxSize: NULL
[16:59:35.133]  - attr(*, "where")=List of 5
[16:59:35.133]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.133]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.133]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.133]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.133]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.133]  - attr(*, "resolved")= logi FALSE
[16:59:35.133]  - attr(*, "total_size")= num 1240
[16:59:35.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.133]  - attr(*, "already-done")= logi TRUE
[16:59:35.139] - copied ‘...future.FUN’ to environment
[16:59:35.139] - copied ‘future.call.arguments’ to environment
[16:59:35.139] - copied ‘...future.elements_ii’ to environment
[16:59:35.139] - copied ‘...future.seeds_ii’ to environment
[16:59:35.139] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.139] assign_globals() ... done
[16:59:35.140] requestCore(): workers = 2
[16:59:35.143] MulticoreFuture started
[16:59:35.143] - Launch lazy future ... done
[16:59:35.143] plan(): Setting new future strategy stack:
[16:59:35.143] run() for ‘MulticoreFuture’ ... done
[16:59:35.144] Created future:
[16:59:35.144] List of future strategies:
[16:59:35.144] 1. sequential:
[16:59:35.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.144]    - tweaked: FALSE
[16:59:35.144]    - call: NULL
[16:59:35.150] plan(): nbrOfWorkers() = 1
[16:59:35.154] plan(): Setting new future strategy stack:
[16:59:35.155] List of future strategies:
[16:59:35.155] 1. multicore:
[16:59:35.155]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.155]    - tweaked: FALSE
[16:59:35.155]    - call: plan(strategy)
[16:59:35.161] plan(): nbrOfWorkers() = 2
[16:59:35.149] MulticoreFuture:
[16:59:35.149] Label: ‘future_by-1’
[16:59:35.149] Expression:
[16:59:35.149] {
[16:59:35.149]     do.call(function(...) {
[16:59:35.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.149]             on.exit(options(oopts), add = TRUE)
[16:59:35.149]         }
[16:59:35.149]         {
[16:59:35.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.149]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.149]             })
[16:59:35.149]         }
[16:59:35.149]     }, args = future.call.arguments)
[16:59:35.149] }
[16:59:35.149] Lazy evaluation: FALSE
[16:59:35.149] Asynchronous evaluation: TRUE
[16:59:35.149] Local evaluation: TRUE
[16:59:35.149] Environment: R_GlobalEnv
[16:59:35.149] Capture standard output: TRUE
[16:59:35.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.149] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.149] Packages: <none>
[16:59:35.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.149] Resolved: TRUE
[16:59:35.149] Value: <not collected>
[16:59:35.149] Conditions captured: <none>
[16:59:35.149] Early signaling: FALSE
[16:59:35.149] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.149] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.162] Chunk #1 of 2 ... DONE
[16:59:35.163] Chunk #2 of 2 ...
[16:59:35.163]  - Finding globals in 'X' for chunk #2 ...
[16:59:35.163] getGlobalsAndPackages() ...
[16:59:35.163] Searching for globals...
[16:59:35.165] 
[16:59:35.165] Searching for globals ... DONE
[16:59:35.165] - globals: [0] <none>
[16:59:35.165] getGlobalsAndPackages() ... DONE
[16:59:35.165]    + additional globals found: [n=0] 
[16:59:35.165]    + additional namespaces needed: [n=0] 
[16:59:35.166]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:35.166]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.166]  - seeds: <none>
[16:59:35.166]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.166] getGlobalsAndPackages() ...
[16:59:35.167] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.167] Resolving globals: FALSE
[16:59:35.167] Tweak future expression to call with '...' arguments ...
[16:59:35.167] {
[16:59:35.167]     do.call(function(...) {
[16:59:35.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.167]             on.exit(options(oopts), add = TRUE)
[16:59:35.167]         }
[16:59:35.167]         {
[16:59:35.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.167]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.167]             })
[16:59:35.167]         }
[16:59:35.167]     }, args = future.call.arguments)
[16:59:35.167] }
[16:59:35.168] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.169] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.169] 
[16:59:35.169] getGlobalsAndPackages() ... DONE
[16:59:35.169] run() for ‘Future’ ...
[16:59:35.169] - state: ‘created’
[16:59:35.170] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.174] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.175] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.175]   - Field: ‘label’
[16:59:35.175]   - Field: ‘local’
[16:59:35.175]   - Field: ‘owner’
[16:59:35.175]   - Field: ‘envir’
[16:59:35.176]   - Field: ‘workers’
[16:59:35.176]   - Field: ‘packages’
[16:59:35.176]   - Field: ‘gc’
[16:59:35.176]   - Field: ‘job’
[16:59:35.176]   - Field: ‘conditions’
[16:59:35.176]   - Field: ‘expr’
[16:59:35.176]   - Field: ‘uuid’
[16:59:35.176]   - Field: ‘seed’
[16:59:35.177]   - Field: ‘version’
[16:59:35.177]   - Field: ‘result’
[16:59:35.177]   - Field: ‘asynchronous’
[16:59:35.177]   - Field: ‘calls’
[16:59:35.177]   - Field: ‘globals’
[16:59:35.177]   - Field: ‘stdout’
[16:59:35.177]   - Field: ‘earlySignal’
[16:59:35.177]   - Field: ‘lazy’
[16:59:35.177]   - Field: ‘state’
[16:59:35.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.178] - Launch lazy future ...
[16:59:35.178] Packages needed by the future expression (n = 0): <none>
[16:59:35.178] Packages needed by future strategies (n = 0): <none>
[16:59:35.179] {
[16:59:35.179]     {
[16:59:35.179]         {
[16:59:35.179]             ...future.startTime <- base::Sys.time()
[16:59:35.179]             {
[16:59:35.179]                 {
[16:59:35.179]                   {
[16:59:35.179]                     {
[16:59:35.179]                       base::local({
[16:59:35.179]                         has_future <- base::requireNamespace("future", 
[16:59:35.179]                           quietly = TRUE)
[16:59:35.179]                         if (has_future) {
[16:59:35.179]                           ns <- base::getNamespace("future")
[16:59:35.179]                           version <- ns[[".package"]][["version"]]
[16:59:35.179]                           if (is.null(version)) 
[16:59:35.179]                             version <- utils::packageVersion("future")
[16:59:35.179]                         }
[16:59:35.179]                         else {
[16:59:35.179]                           version <- NULL
[16:59:35.179]                         }
[16:59:35.179]                         if (!has_future || version < "1.8.0") {
[16:59:35.179]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.179]                             "", base::R.version$version.string), 
[16:59:35.179]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.179]                               "release", "version")], collapse = " "), 
[16:59:35.179]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.179]                             info)
[16:59:35.179]                           info <- base::paste(info, collapse = "; ")
[16:59:35.179]                           if (!has_future) {
[16:59:35.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.179]                               info)
[16:59:35.179]                           }
[16:59:35.179]                           else {
[16:59:35.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.179]                               info, version)
[16:59:35.179]                           }
[16:59:35.179]                           base::stop(msg)
[16:59:35.179]                         }
[16:59:35.179]                       })
[16:59:35.179]                     }
[16:59:35.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.179]                     base::options(mc.cores = 1L)
[16:59:35.179]                   }
[16:59:35.179]                   ...future.strategy.old <- future::plan("list")
[16:59:35.179]                   options(future.plan = NULL)
[16:59:35.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.179]                 }
[16:59:35.179]                 ...future.workdir <- getwd()
[16:59:35.179]             }
[16:59:35.179]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.179]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.179]         }
[16:59:35.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.179]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.179]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.179]             base::names(...future.oldOptions))
[16:59:35.179]     }
[16:59:35.179]     if (FALSE) {
[16:59:35.179]     }
[16:59:35.179]     else {
[16:59:35.179]         if (TRUE) {
[16:59:35.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.179]                 open = "w")
[16:59:35.179]         }
[16:59:35.179]         else {
[16:59:35.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.179]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.179]         }
[16:59:35.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.179]             base::sink(type = "output", split = FALSE)
[16:59:35.179]             base::close(...future.stdout)
[16:59:35.179]         }, add = TRUE)
[16:59:35.179]     }
[16:59:35.179]     ...future.frame <- base::sys.nframe()
[16:59:35.179]     ...future.conditions <- base::list()
[16:59:35.179]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.179]     if (FALSE) {
[16:59:35.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.179]     }
[16:59:35.179]     ...future.result <- base::tryCatch({
[16:59:35.179]         base::withCallingHandlers({
[16:59:35.179]             ...future.value <- base::withVisible(base::local({
[16:59:35.179]                 withCallingHandlers({
[16:59:35.179]                   {
[16:59:35.179]                     do.call(function(...) {
[16:59:35.179]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.179]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.179]                         ...future.globals.maxSize)) {
[16:59:35.179]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.179]                         on.exit(options(oopts), add = TRUE)
[16:59:35.179]                       }
[16:59:35.179]                       {
[16:59:35.179]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.179]                           FUN = function(jj) {
[16:59:35.179]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.179]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.179]                           })
[16:59:35.179]                       }
[16:59:35.179]                     }, args = future.call.arguments)
[16:59:35.179]                   }
[16:59:35.179]                 }, immediateCondition = function(cond) {
[16:59:35.179]                   save_rds <- function (object, pathname, ...) 
[16:59:35.179]                   {
[16:59:35.179]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.179]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.179]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.179]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.179]                         fi_tmp[["mtime"]])
[16:59:35.179]                     }
[16:59:35.179]                     tryCatch({
[16:59:35.179]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.179]                     }, error = function(ex) {
[16:59:35.179]                       msg <- conditionMessage(ex)
[16:59:35.179]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.179]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.179]                         fi_tmp[["mtime"]], msg)
[16:59:35.179]                       ex$message <- msg
[16:59:35.179]                       stop(ex)
[16:59:35.179]                     })
[16:59:35.179]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.179]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.179]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.179]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.179]                       fi <- file.info(pathname)
[16:59:35.179]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.179]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.179]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.179]                         fi[["size"]], fi[["mtime"]])
[16:59:35.179]                       stop(msg)
[16:59:35.179]                     }
[16:59:35.179]                     invisible(pathname)
[16:59:35.179]                   }
[16:59:35.179]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.179]                     rootPath = tempdir()) 
[16:59:35.179]                   {
[16:59:35.179]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.179]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.179]                       tmpdir = path, fileext = ".rds")
[16:59:35.179]                     save_rds(obj, file)
[16:59:35.179]                   }
[16:59:35.179]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.179]                   {
[16:59:35.179]                     inherits <- base::inherits
[16:59:35.179]                     invokeRestart <- base::invokeRestart
[16:59:35.179]                     is.null <- base::is.null
[16:59:35.179]                     muffled <- FALSE
[16:59:35.179]                     if (inherits(cond, "message")) {
[16:59:35.179]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.179]                       if (muffled) 
[16:59:35.179]                         invokeRestart("muffleMessage")
[16:59:35.179]                     }
[16:59:35.179]                     else if (inherits(cond, "warning")) {
[16:59:35.179]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.179]                       if (muffled) 
[16:59:35.179]                         invokeRestart("muffleWarning")
[16:59:35.179]                     }
[16:59:35.179]                     else if (inherits(cond, "condition")) {
[16:59:35.179]                       if (!is.null(pattern)) {
[16:59:35.179]                         computeRestarts <- base::computeRestarts
[16:59:35.179]                         grepl <- base::grepl
[16:59:35.179]                         restarts <- computeRestarts(cond)
[16:59:35.179]                         for (restart in restarts) {
[16:59:35.179]                           name <- restart$name
[16:59:35.179]                           if (is.null(name)) 
[16:59:35.179]                             next
[16:59:35.179]                           if (!grepl(pattern, name)) 
[16:59:35.179]                             next
[16:59:35.179]                           invokeRestart(restart)
[16:59:35.179]                           muffled <- TRUE
[16:59:35.179]                           break
[16:59:35.179]                         }
[16:59:35.179]                       }
[16:59:35.179]                     }
[16:59:35.179]                     invisible(muffled)
[16:59:35.179]                   }
[16:59:35.179]                   muffleCondition(cond)
[16:59:35.179]                 })
[16:59:35.179]             }))
[16:59:35.179]             future::FutureResult(value = ...future.value$value, 
[16:59:35.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.179]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.179]                     ...future.globalenv.names))
[16:59:35.179]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.179]         }, condition = base::local({
[16:59:35.179]             c <- base::c
[16:59:35.179]             inherits <- base::inherits
[16:59:35.179]             invokeRestart <- base::invokeRestart
[16:59:35.179]             length <- base::length
[16:59:35.179]             list <- base::list
[16:59:35.179]             seq.int <- base::seq.int
[16:59:35.179]             signalCondition <- base::signalCondition
[16:59:35.179]             sys.calls <- base::sys.calls
[16:59:35.179]             `[[` <- base::`[[`
[16:59:35.179]             `+` <- base::`+`
[16:59:35.179]             `<<-` <- base::`<<-`
[16:59:35.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.179]                   3L)]
[16:59:35.179]             }
[16:59:35.179]             function(cond) {
[16:59:35.179]                 is_error <- inherits(cond, "error")
[16:59:35.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.179]                   NULL)
[16:59:35.179]                 if (is_error) {
[16:59:35.179]                   sessionInformation <- function() {
[16:59:35.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.179]                       search = base::search(), system = base::Sys.info())
[16:59:35.179]                   }
[16:59:35.179]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.179]                     cond$call), session = sessionInformation(), 
[16:59:35.179]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.179]                   signalCondition(cond)
[16:59:35.179]                 }
[16:59:35.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.179]                 "immediateCondition"))) {
[16:59:35.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.179]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.179]                   if (TRUE && !signal) {
[16:59:35.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.179]                     {
[16:59:35.179]                       inherits <- base::inherits
[16:59:35.179]                       invokeRestart <- base::invokeRestart
[16:59:35.179]                       is.null <- base::is.null
[16:59:35.179]                       muffled <- FALSE
[16:59:35.179]                       if (inherits(cond, "message")) {
[16:59:35.179]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.179]                         if (muffled) 
[16:59:35.179]                           invokeRestart("muffleMessage")
[16:59:35.179]                       }
[16:59:35.179]                       else if (inherits(cond, "warning")) {
[16:59:35.179]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.179]                         if (muffled) 
[16:59:35.179]                           invokeRestart("muffleWarning")
[16:59:35.179]                       }
[16:59:35.179]                       else if (inherits(cond, "condition")) {
[16:59:35.179]                         if (!is.null(pattern)) {
[16:59:35.179]                           computeRestarts <- base::computeRestarts
[16:59:35.179]                           grepl <- base::grepl
[16:59:35.179]                           restarts <- computeRestarts(cond)
[16:59:35.179]                           for (restart in restarts) {
[16:59:35.179]                             name <- restart$name
[16:59:35.179]                             if (is.null(name)) 
[16:59:35.179]                               next
[16:59:35.179]                             if (!grepl(pattern, name)) 
[16:59:35.179]                               next
[16:59:35.179]                             invokeRestart(restart)
[16:59:35.179]                             muffled <- TRUE
[16:59:35.179]                             break
[16:59:35.179]                           }
[16:59:35.179]                         }
[16:59:35.179]                       }
[16:59:35.179]                       invisible(muffled)
[16:59:35.179]                     }
[16:59:35.179]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.179]                   }
[16:59:35.179]                 }
[16:59:35.179]                 else {
[16:59:35.179]                   if (TRUE) {
[16:59:35.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.179]                     {
[16:59:35.179]                       inherits <- base::inherits
[16:59:35.179]                       invokeRestart <- base::invokeRestart
[16:59:35.179]                       is.null <- base::is.null
[16:59:35.179]                       muffled <- FALSE
[16:59:35.179]                       if (inherits(cond, "message")) {
[16:59:35.179]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.179]                         if (muffled) 
[16:59:35.179]                           invokeRestart("muffleMessage")
[16:59:35.179]                       }
[16:59:35.179]                       else if (inherits(cond, "warning")) {
[16:59:35.179]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.179]                         if (muffled) 
[16:59:35.179]                           invokeRestart("muffleWarning")
[16:59:35.179]                       }
[16:59:35.179]                       else if (inherits(cond, "condition")) {
[16:59:35.179]                         if (!is.null(pattern)) {
[16:59:35.179]                           computeRestarts <- base::computeRestarts
[16:59:35.179]                           grepl <- base::grepl
[16:59:35.179]                           restarts <- computeRestarts(cond)
[16:59:35.179]                           for (restart in restarts) {
[16:59:35.179]                             name <- restart$name
[16:59:35.179]                             if (is.null(name)) 
[16:59:35.179]                               next
[16:59:35.179]                             if (!grepl(pattern, name)) 
[16:59:35.179]                               next
[16:59:35.179]                             invokeRestart(restart)
[16:59:35.179]                             muffled <- TRUE
[16:59:35.179]                             break
[16:59:35.179]                           }
[16:59:35.179]                         }
[16:59:35.179]                       }
[16:59:35.179]                       invisible(muffled)
[16:59:35.179]                     }
[16:59:35.179]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.179]                   }
[16:59:35.179]                 }
[16:59:35.179]             }
[16:59:35.179]         }))
[16:59:35.179]     }, error = function(ex) {
[16:59:35.179]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.179]                 ...future.rng), started = ...future.startTime, 
[16:59:35.179]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.179]             version = "1.8"), class = "FutureResult")
[16:59:35.179]     }, finally = {
[16:59:35.179]         if (!identical(...future.workdir, getwd())) 
[16:59:35.179]             setwd(...future.workdir)
[16:59:35.179]         {
[16:59:35.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.179]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.179]             }
[16:59:35.179]             base::options(...future.oldOptions)
[16:59:35.179]             if (.Platform$OS.type == "windows") {
[16:59:35.179]                 old_names <- names(...future.oldEnvVars)
[16:59:35.179]                 envs <- base::Sys.getenv()
[16:59:35.179]                 names <- names(envs)
[16:59:35.179]                 common <- intersect(names, old_names)
[16:59:35.179]                 added <- setdiff(names, old_names)
[16:59:35.179]                 removed <- setdiff(old_names, names)
[16:59:35.179]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.179]                   envs[common]]
[16:59:35.179]                 NAMES <- toupper(changed)
[16:59:35.179]                 args <- list()
[16:59:35.179]                 for (kk in seq_along(NAMES)) {
[16:59:35.179]                   name <- changed[[kk]]
[16:59:35.179]                   NAME <- NAMES[[kk]]
[16:59:35.179]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.179]                     next
[16:59:35.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.179]                 }
[16:59:35.179]                 NAMES <- toupper(added)
[16:59:35.179]                 for (kk in seq_along(NAMES)) {
[16:59:35.179]                   name <- added[[kk]]
[16:59:35.179]                   NAME <- NAMES[[kk]]
[16:59:35.179]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.179]                     next
[16:59:35.179]                   args[[name]] <- ""
[16:59:35.179]                 }
[16:59:35.179]                 NAMES <- toupper(removed)
[16:59:35.179]                 for (kk in seq_along(NAMES)) {
[16:59:35.179]                   name <- removed[[kk]]
[16:59:35.179]                   NAME <- NAMES[[kk]]
[16:59:35.179]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.179]                     next
[16:59:35.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.179]                 }
[16:59:35.179]                 if (length(args) > 0) 
[16:59:35.179]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.179]             }
[16:59:35.179]             else {
[16:59:35.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.179]             }
[16:59:35.179]             {
[16:59:35.179]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.179]                   0L) {
[16:59:35.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.179]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.179]                   base::options(opts)
[16:59:35.179]                 }
[16:59:35.179]                 {
[16:59:35.179]                   {
[16:59:35.179]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.179]                     NULL
[16:59:35.179]                   }
[16:59:35.179]                   options(future.plan = NULL)
[16:59:35.179]                   if (is.na(NA_character_)) 
[16:59:35.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.179]                     .init = FALSE)
[16:59:35.179]                 }
[16:59:35.179]             }
[16:59:35.179]         }
[16:59:35.179]     })
[16:59:35.179]     if (TRUE) {
[16:59:35.179]         base::sink(type = "output", split = FALSE)
[16:59:35.179]         if (TRUE) {
[16:59:35.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.179]         }
[16:59:35.179]         else {
[16:59:35.179]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.179]         }
[16:59:35.179]         base::close(...future.stdout)
[16:59:35.179]         ...future.stdout <- NULL
[16:59:35.179]     }
[16:59:35.179]     ...future.result$conditions <- ...future.conditions
[16:59:35.179]     ...future.result$finished <- base::Sys.time()
[16:59:35.179]     ...future.result
[16:59:35.179] }
[16:59:35.181] assign_globals() ...
[16:59:35.182] List of 5
[16:59:35.182]  $ ...future.FUN            :function (object, ...)  
[16:59:35.182]  $ future.call.arguments    : list()
[16:59:35.182]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.182]  $ ...future.elements_ii    :List of 2
[16:59:35.182]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:35.182]   .. ..$ breaks: num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.182]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.182]   ..$ :'data.frame':	18 obs. of  2 variables:
[16:59:35.182]   .. ..$ breaks: num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.182]   .. ..$ wool  : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.182]  $ ...future.seeds_ii       : NULL
[16:59:35.182]  $ ...future.globals.maxSize: NULL
[16:59:35.182]  - attr(*, "where")=List of 5
[16:59:35.182]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.182]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.182]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.182]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.182]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.182]  - attr(*, "resolved")= logi FALSE
[16:59:35.182]  - attr(*, "total_size")= num 1240
[16:59:35.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.182]  - attr(*, "already-done")= logi TRUE
[16:59:35.190] - copied ‘...future.FUN’ to environment
[16:59:35.190] - copied ‘future.call.arguments’ to environment
[16:59:35.190] - copied ‘...future.elements_ii’ to environment
[16:59:35.190] - copied ‘...future.seeds_ii’ to environment
[16:59:35.190] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.190] assign_globals() ... done
[16:59:35.190] requestCore(): workers = 2
[16:59:35.198] MulticoreFuture started
[16:59:35.199] - Launch lazy future ... done
[16:59:35.199] plan(): Setting new future strategy stack:
[16:59:35.199] run() for ‘MulticoreFuture’ ... done
[16:59:35.200] Created future:
[16:59:35.199] List of future strategies:
[16:59:35.199] 1. sequential:
[16:59:35.199]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.199]    - tweaked: FALSE
[16:59:35.199]    - call: NULL
[16:59:35.201] plan(): nbrOfWorkers() = 1
[16:59:35.207] plan(): Setting new future strategy stack:
[16:59:35.207] List of future strategies:
[16:59:35.207] 1. multicore:
[16:59:35.207]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.207]    - tweaked: FALSE
[16:59:35.207]    - call: plan(strategy)
[16:59:35.213] plan(): nbrOfWorkers() = 2
[16:59:35.200] MulticoreFuture:
[16:59:35.200] Label: ‘future_by-2’
[16:59:35.200] Expression:
[16:59:35.200] {
[16:59:35.200]     do.call(function(...) {
[16:59:35.200]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.200]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.200]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.200]             on.exit(options(oopts), add = TRUE)
[16:59:35.200]         }
[16:59:35.200]         {
[16:59:35.200]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.200]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.200]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.200]             })
[16:59:35.200]         }
[16:59:35.200]     }, args = future.call.arguments)
[16:59:35.200] }
[16:59:35.200] Lazy evaluation: FALSE
[16:59:35.200] Asynchronous evaluation: TRUE
[16:59:35.200] Local evaluation: TRUE
[16:59:35.200] Environment: R_GlobalEnv
[16:59:35.200] Capture standard output: TRUE
[16:59:35.200] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.200] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.200] Packages: <none>
[16:59:35.200] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.200] Resolved: TRUE
[16:59:35.200] Value: <not collected>
[16:59:35.200] Conditions captured: <none>
[16:59:35.200] Early signaling: FALSE
[16:59:35.200] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.200] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.214] Chunk #2 of 2 ... DONE
[16:59:35.215] Launching 2 futures (chunks) ... DONE
[16:59:35.215] Resolving 2 futures (chunks) ...
[16:59:35.215] resolve() on list ...
[16:59:35.215]  recursive: 0
[16:59:35.216]  length: 2
[16:59:35.216] 
[16:59:35.216] Future #1
[16:59:35.217] result() for MulticoreFuture ...
[16:59:35.219] result() for MulticoreFuture ...
[16:59:35.219] result() for MulticoreFuture ... done
[16:59:35.219] result() for MulticoreFuture ... done
[16:59:35.219] result() for MulticoreFuture ...
[16:59:35.219] result() for MulticoreFuture ... done
[16:59:35.219] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:35.220] - nx: 2
[16:59:35.220] - relay: TRUE
[16:59:35.220] - stdout: TRUE
[16:59:35.221] - signal: TRUE
[16:59:35.221] - resignal: FALSE
[16:59:35.221] - force: TRUE
[16:59:35.221] - relayed: [n=2] FALSE, FALSE
[16:59:35.221] - queued futures: [n=2] FALSE, FALSE
[16:59:35.221]  - until=1
[16:59:35.222]  - relaying element #1
[16:59:35.222] result() for MulticoreFuture ...
[16:59:35.222] result() for MulticoreFuture ... done
[16:59:35.222] result() for MulticoreFuture ...
[16:59:35.222] result() for MulticoreFuture ... done
[16:59:35.222] result() for MulticoreFuture ...
[16:59:35.223] result() for MulticoreFuture ... done
[16:59:35.223] result() for MulticoreFuture ...
[16:59:35.223] result() for MulticoreFuture ... done
[16:59:35.223] - relayed: [n=2] TRUE, FALSE
[16:59:35.223] - queued futures: [n=2] TRUE, FALSE
[16:59:35.223] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:35.224]  length: 1 (resolved future 1)
[16:59:35.224] Future #2
[16:59:35.224] result() for MulticoreFuture ...
[16:59:35.225] result() for MulticoreFuture ...
[16:59:35.225] result() for MulticoreFuture ... done
[16:59:35.225] result() for MulticoreFuture ... done
[16:59:35.225] result() for MulticoreFuture ...
[16:59:35.225] result() for MulticoreFuture ... done
[16:59:35.225] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:35.226] - nx: 2
[16:59:35.226] - relay: TRUE
[16:59:35.226] - stdout: TRUE
[16:59:35.226] - signal: TRUE
[16:59:35.226] - resignal: FALSE
[16:59:35.226] - force: TRUE
[16:59:35.226] - relayed: [n=2] TRUE, FALSE
[16:59:35.226] - queued futures: [n=2] TRUE, FALSE
[16:59:35.226]  - until=2
[16:59:35.227]  - relaying element #2
[16:59:35.227] result() for MulticoreFuture ...
[16:59:35.227] result() for MulticoreFuture ... done
[16:59:35.227] result() for MulticoreFuture ...
[16:59:35.227] result() for MulticoreFuture ... done
[16:59:35.227] result() for MulticoreFuture ...
[16:59:35.227] result() for MulticoreFuture ... done
[16:59:35.227] result() for MulticoreFuture ...
[16:59:35.228] result() for MulticoreFuture ... done
[16:59:35.228] - relayed: [n=2] TRUE, TRUE
[16:59:35.228] - queued futures: [n=2] TRUE, TRUE
[16:59:35.228] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:35.228]  length: 0 (resolved future 2)
[16:59:35.228] Relaying remaining futures
[16:59:35.228] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.228] - nx: 2
[16:59:35.228] - relay: TRUE
[16:59:35.229] - stdout: TRUE
[16:59:35.229] - signal: TRUE
[16:59:35.229] - resignal: FALSE
[16:59:35.229] - force: TRUE
[16:59:35.229] - relayed: [n=2] TRUE, TRUE
[16:59:35.229] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:35.229] - relayed: [n=2] TRUE, TRUE
[16:59:35.229] - queued futures: [n=2] TRUE, TRUE
[16:59:35.229] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.229] resolve() on list ... DONE
[16:59:35.230] result() for MulticoreFuture ...
[16:59:35.230] result() for MulticoreFuture ... done
[16:59:35.230] result() for MulticoreFuture ...
[16:59:35.230] result() for MulticoreFuture ... done
[16:59:35.230] result() for MulticoreFuture ...
[16:59:35.230] result() for MulticoreFuture ... done
[16:59:35.230] result() for MulticoreFuture ...
[16:59:35.230] result() for MulticoreFuture ... done
[16:59:35.230]  - Number of value chunks collected: 2
[16:59:35.231] Resolving 2 futures (chunks) ... DONE
[16:59:35.231] Reducing values from 2 chunks ...
[16:59:35.231]  - Number of values collected after concatenation: 3
[16:59:35.231]  - Number of values expected: 3
[16:59:35.231] Reducing values from 2 chunks ... DONE
[16:59:35.231] future_lapply() ... DONE
[16:59:35.231] future_by_internal() ... DONE
[16:59:35.232] future_by_internal() ...
[16:59:35.232] future_lapply() ...
[16:59:35.237] Number of chunks: 2
[16:59:35.237] getGlobalsAndPackagesXApply() ...
[16:59:35.237]  - future.globals: TRUE
[16:59:35.237] getGlobalsAndPackages() ...
[16:59:35.237] Searching for globals...
[16:59:35.238] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:35.238] Searching for globals ... DONE
[16:59:35.239] Resolving globals: FALSE
[16:59:35.239] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:35.239] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:35.239] - globals: [1] ‘FUN’
[16:59:35.240] 
[16:59:35.240] getGlobalsAndPackages() ... DONE
[16:59:35.240]  - globals found/used: [n=1] ‘FUN’
[16:59:35.240]  - needed namespaces: [n=0] 
[16:59:35.240] Finding globals ... DONE
[16:59:35.240]  - use_args: TRUE
[16:59:35.240]  - Getting '...' globals ...
[16:59:35.241] resolve() on list ...
[16:59:35.243]  recursive: 0
[16:59:35.243]  length: 1
[16:59:35.243]  elements: ‘...’
[16:59:35.243]  length: 0 (resolved future 1)
[16:59:35.243] resolve() on list ... DONE
[16:59:35.243]    - '...' content: [n=1] ‘digits’
[16:59:35.244] List of 1
[16:59:35.244]  $ ...:List of 1
[16:59:35.244]   ..$ digits: int 2
[16:59:35.244]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.244]  - attr(*, "where")=List of 1
[16:59:35.244]   ..$ ...:<environment: 0x56205285c148> 
[16:59:35.244]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.244]  - attr(*, "resolved")= logi TRUE
[16:59:35.244]  - attr(*, "total_size")= num NA
[16:59:35.248]  - Getting '...' globals ... DONE
[16:59:35.248] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.248] List of 2
[16:59:35.248]  $ ...future.FUN:function (object, ...)  
[16:59:35.248]  $ ...          :List of 1
[16:59:35.248]   ..$ digits: int 2
[16:59:35.248]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.248]  - attr(*, "where")=List of 2
[16:59:35.248]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.248]   ..$ ...          :<environment: 0x56205285c148> 
[16:59:35.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.248]  - attr(*, "resolved")= logi FALSE
[16:59:35.248]  - attr(*, "total_size")= num 1296
[16:59:35.251] Packages to be attached in all futures: [n=0] 
[16:59:35.251] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.251] Number of futures (= number of chunks): 2
[16:59:35.251] Launching 2 futures (chunks) ...
[16:59:35.251] Chunk #1 of 2 ...
[16:59:35.252]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.252] getGlobalsAndPackages() ...
[16:59:35.252] Searching for globals...
[16:59:35.252] 
[16:59:35.252] Searching for globals ... DONE
[16:59:35.252] - globals: [0] <none>
[16:59:35.252] getGlobalsAndPackages() ... DONE
[16:59:35.252]    + additional globals found: [n=0] 
[16:59:35.253]    + additional namespaces needed: [n=0] 
[16:59:35.253]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.253]  - seeds: <none>
[16:59:35.253]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.253] getGlobalsAndPackages() ...
[16:59:35.253] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.253] Resolving globals: FALSE
[16:59:35.253] Tweak future expression to call with '...' arguments ...
[16:59:35.254] {
[16:59:35.254]     do.call(function(...) {
[16:59:35.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.254]             on.exit(options(oopts), add = TRUE)
[16:59:35.254]         }
[16:59:35.254]         {
[16:59:35.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.254]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.254]             })
[16:59:35.254]         }
[16:59:35.254]     }, args = future.call.arguments)
[16:59:35.254] }
[16:59:35.254] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.254] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.254] 
[16:59:35.254] getGlobalsAndPackages() ... DONE
[16:59:35.255] run() for ‘Future’ ...
[16:59:35.255] - state: ‘created’
[16:59:35.255] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.259] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.259] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.259]   - Field: ‘label’
[16:59:35.259]   - Field: ‘local’
[16:59:35.259]   - Field: ‘owner’
[16:59:35.259]   - Field: ‘envir’
[16:59:35.259]   - Field: ‘workers’
[16:59:35.260]   - Field: ‘packages’
[16:59:35.260]   - Field: ‘gc’
[16:59:35.260]   - Field: ‘job’
[16:59:35.260]   - Field: ‘conditions’
[16:59:35.260]   - Field: ‘expr’
[16:59:35.260]   - Field: ‘uuid’
[16:59:35.260]   - Field: ‘seed’
[16:59:35.260]   - Field: ‘version’
[16:59:35.260]   - Field: ‘result’
[16:59:35.260]   - Field: ‘asynchronous’
[16:59:35.260]   - Field: ‘calls’
[16:59:35.261]   - Field: ‘globals’
[16:59:35.261]   - Field: ‘stdout’
[16:59:35.261]   - Field: ‘earlySignal’
[16:59:35.261]   - Field: ‘lazy’
[16:59:35.261]   - Field: ‘state’
[16:59:35.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.261] - Launch lazy future ...
[16:59:35.261] Packages needed by the future expression (n = 0): <none>
[16:59:35.262] Packages needed by future strategies (n = 0): <none>
[16:59:35.262] {
[16:59:35.262]     {
[16:59:35.262]         {
[16:59:35.262]             ...future.startTime <- base::Sys.time()
[16:59:35.262]             {
[16:59:35.262]                 {
[16:59:35.262]                   {
[16:59:35.262]                     {
[16:59:35.262]                       base::local({
[16:59:35.262]                         has_future <- base::requireNamespace("future", 
[16:59:35.262]                           quietly = TRUE)
[16:59:35.262]                         if (has_future) {
[16:59:35.262]                           ns <- base::getNamespace("future")
[16:59:35.262]                           version <- ns[[".package"]][["version"]]
[16:59:35.262]                           if (is.null(version)) 
[16:59:35.262]                             version <- utils::packageVersion("future")
[16:59:35.262]                         }
[16:59:35.262]                         else {
[16:59:35.262]                           version <- NULL
[16:59:35.262]                         }
[16:59:35.262]                         if (!has_future || version < "1.8.0") {
[16:59:35.262]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.262]                             "", base::R.version$version.string), 
[16:59:35.262]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.262]                               "release", "version")], collapse = " "), 
[16:59:35.262]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.262]                             info)
[16:59:35.262]                           info <- base::paste(info, collapse = "; ")
[16:59:35.262]                           if (!has_future) {
[16:59:35.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.262]                               info)
[16:59:35.262]                           }
[16:59:35.262]                           else {
[16:59:35.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.262]                               info, version)
[16:59:35.262]                           }
[16:59:35.262]                           base::stop(msg)
[16:59:35.262]                         }
[16:59:35.262]                       })
[16:59:35.262]                     }
[16:59:35.262]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.262]                     base::options(mc.cores = 1L)
[16:59:35.262]                   }
[16:59:35.262]                   ...future.strategy.old <- future::plan("list")
[16:59:35.262]                   options(future.plan = NULL)
[16:59:35.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.262]                 }
[16:59:35.262]                 ...future.workdir <- getwd()
[16:59:35.262]             }
[16:59:35.262]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.262]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.262]         }
[16:59:35.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.262]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.262]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.262]             base::names(...future.oldOptions))
[16:59:35.262]     }
[16:59:35.262]     if (FALSE) {
[16:59:35.262]     }
[16:59:35.262]     else {
[16:59:35.262]         if (TRUE) {
[16:59:35.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.262]                 open = "w")
[16:59:35.262]         }
[16:59:35.262]         else {
[16:59:35.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.262]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.262]         }
[16:59:35.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.262]             base::sink(type = "output", split = FALSE)
[16:59:35.262]             base::close(...future.stdout)
[16:59:35.262]         }, add = TRUE)
[16:59:35.262]     }
[16:59:35.262]     ...future.frame <- base::sys.nframe()
[16:59:35.262]     ...future.conditions <- base::list()
[16:59:35.262]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.262]     if (FALSE) {
[16:59:35.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.262]     }
[16:59:35.262]     ...future.result <- base::tryCatch({
[16:59:35.262]         base::withCallingHandlers({
[16:59:35.262]             ...future.value <- base::withVisible(base::local({
[16:59:35.262]                 withCallingHandlers({
[16:59:35.262]                   {
[16:59:35.262]                     do.call(function(...) {
[16:59:35.262]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.262]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.262]                         ...future.globals.maxSize)) {
[16:59:35.262]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.262]                         on.exit(options(oopts), add = TRUE)
[16:59:35.262]                       }
[16:59:35.262]                       {
[16:59:35.262]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.262]                           FUN = function(jj) {
[16:59:35.262]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.262]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.262]                           })
[16:59:35.262]                       }
[16:59:35.262]                     }, args = future.call.arguments)
[16:59:35.262]                   }
[16:59:35.262]                 }, immediateCondition = function(cond) {
[16:59:35.262]                   save_rds <- function (object, pathname, ...) 
[16:59:35.262]                   {
[16:59:35.262]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.262]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.262]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.262]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.262]                         fi_tmp[["mtime"]])
[16:59:35.262]                     }
[16:59:35.262]                     tryCatch({
[16:59:35.262]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.262]                     }, error = function(ex) {
[16:59:35.262]                       msg <- conditionMessage(ex)
[16:59:35.262]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.262]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.262]                         fi_tmp[["mtime"]], msg)
[16:59:35.262]                       ex$message <- msg
[16:59:35.262]                       stop(ex)
[16:59:35.262]                     })
[16:59:35.262]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.262]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.262]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.262]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.262]                       fi <- file.info(pathname)
[16:59:35.262]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.262]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.262]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.262]                         fi[["size"]], fi[["mtime"]])
[16:59:35.262]                       stop(msg)
[16:59:35.262]                     }
[16:59:35.262]                     invisible(pathname)
[16:59:35.262]                   }
[16:59:35.262]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.262]                     rootPath = tempdir()) 
[16:59:35.262]                   {
[16:59:35.262]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.262]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.262]                       tmpdir = path, fileext = ".rds")
[16:59:35.262]                     save_rds(obj, file)
[16:59:35.262]                   }
[16:59:35.262]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.262]                   {
[16:59:35.262]                     inherits <- base::inherits
[16:59:35.262]                     invokeRestart <- base::invokeRestart
[16:59:35.262]                     is.null <- base::is.null
[16:59:35.262]                     muffled <- FALSE
[16:59:35.262]                     if (inherits(cond, "message")) {
[16:59:35.262]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.262]                       if (muffled) 
[16:59:35.262]                         invokeRestart("muffleMessage")
[16:59:35.262]                     }
[16:59:35.262]                     else if (inherits(cond, "warning")) {
[16:59:35.262]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.262]                       if (muffled) 
[16:59:35.262]                         invokeRestart("muffleWarning")
[16:59:35.262]                     }
[16:59:35.262]                     else if (inherits(cond, "condition")) {
[16:59:35.262]                       if (!is.null(pattern)) {
[16:59:35.262]                         computeRestarts <- base::computeRestarts
[16:59:35.262]                         grepl <- base::grepl
[16:59:35.262]                         restarts <- computeRestarts(cond)
[16:59:35.262]                         for (restart in restarts) {
[16:59:35.262]                           name <- restart$name
[16:59:35.262]                           if (is.null(name)) 
[16:59:35.262]                             next
[16:59:35.262]                           if (!grepl(pattern, name)) 
[16:59:35.262]                             next
[16:59:35.262]                           invokeRestart(restart)
[16:59:35.262]                           muffled <- TRUE
[16:59:35.262]                           break
[16:59:35.262]                         }
[16:59:35.262]                       }
[16:59:35.262]                     }
[16:59:35.262]                     invisible(muffled)
[16:59:35.262]                   }
[16:59:35.262]                   muffleCondition(cond)
[16:59:35.262]                 })
[16:59:35.262]             }))
[16:59:35.262]             future::FutureResult(value = ...future.value$value, 
[16:59:35.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.262]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.262]                     ...future.globalenv.names))
[16:59:35.262]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.262]         }, condition = base::local({
[16:59:35.262]             c <- base::c
[16:59:35.262]             inherits <- base::inherits
[16:59:35.262]             invokeRestart <- base::invokeRestart
[16:59:35.262]             length <- base::length
[16:59:35.262]             list <- base::list
[16:59:35.262]             seq.int <- base::seq.int
[16:59:35.262]             signalCondition <- base::signalCondition
[16:59:35.262]             sys.calls <- base::sys.calls
[16:59:35.262]             `[[` <- base::`[[`
[16:59:35.262]             `+` <- base::`+`
[16:59:35.262]             `<<-` <- base::`<<-`
[16:59:35.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.262]                   3L)]
[16:59:35.262]             }
[16:59:35.262]             function(cond) {
[16:59:35.262]                 is_error <- inherits(cond, "error")
[16:59:35.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.262]                   NULL)
[16:59:35.262]                 if (is_error) {
[16:59:35.262]                   sessionInformation <- function() {
[16:59:35.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.262]                       search = base::search(), system = base::Sys.info())
[16:59:35.262]                   }
[16:59:35.262]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.262]                     cond$call), session = sessionInformation(), 
[16:59:35.262]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.262]                   signalCondition(cond)
[16:59:35.262]                 }
[16:59:35.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.262]                 "immediateCondition"))) {
[16:59:35.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.262]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.262]                   if (TRUE && !signal) {
[16:59:35.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.262]                     {
[16:59:35.262]                       inherits <- base::inherits
[16:59:35.262]                       invokeRestart <- base::invokeRestart
[16:59:35.262]                       is.null <- base::is.null
[16:59:35.262]                       muffled <- FALSE
[16:59:35.262]                       if (inherits(cond, "message")) {
[16:59:35.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.262]                         if (muffled) 
[16:59:35.262]                           invokeRestart("muffleMessage")
[16:59:35.262]                       }
[16:59:35.262]                       else if (inherits(cond, "warning")) {
[16:59:35.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.262]                         if (muffled) 
[16:59:35.262]                           invokeRestart("muffleWarning")
[16:59:35.262]                       }
[16:59:35.262]                       else if (inherits(cond, "condition")) {
[16:59:35.262]                         if (!is.null(pattern)) {
[16:59:35.262]                           computeRestarts <- base::computeRestarts
[16:59:35.262]                           grepl <- base::grepl
[16:59:35.262]                           restarts <- computeRestarts(cond)
[16:59:35.262]                           for (restart in restarts) {
[16:59:35.262]                             name <- restart$name
[16:59:35.262]                             if (is.null(name)) 
[16:59:35.262]                               next
[16:59:35.262]                             if (!grepl(pattern, name)) 
[16:59:35.262]                               next
[16:59:35.262]                             invokeRestart(restart)
[16:59:35.262]                             muffled <- TRUE
[16:59:35.262]                             break
[16:59:35.262]                           }
[16:59:35.262]                         }
[16:59:35.262]                       }
[16:59:35.262]                       invisible(muffled)
[16:59:35.262]                     }
[16:59:35.262]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.262]                   }
[16:59:35.262]                 }
[16:59:35.262]                 else {
[16:59:35.262]                   if (TRUE) {
[16:59:35.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.262]                     {
[16:59:35.262]                       inherits <- base::inherits
[16:59:35.262]                       invokeRestart <- base::invokeRestart
[16:59:35.262]                       is.null <- base::is.null
[16:59:35.262]                       muffled <- FALSE
[16:59:35.262]                       if (inherits(cond, "message")) {
[16:59:35.262]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.262]                         if (muffled) 
[16:59:35.262]                           invokeRestart("muffleMessage")
[16:59:35.262]                       }
[16:59:35.262]                       else if (inherits(cond, "warning")) {
[16:59:35.262]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.262]                         if (muffled) 
[16:59:35.262]                           invokeRestart("muffleWarning")
[16:59:35.262]                       }
[16:59:35.262]                       else if (inherits(cond, "condition")) {
[16:59:35.262]                         if (!is.null(pattern)) {
[16:59:35.262]                           computeRestarts <- base::computeRestarts
[16:59:35.262]                           grepl <- base::grepl
[16:59:35.262]                           restarts <- computeRestarts(cond)
[16:59:35.262]                           for (restart in restarts) {
[16:59:35.262]                             name <- restart$name
[16:59:35.262]                             if (is.null(name)) 
[16:59:35.262]                               next
[16:59:35.262]                             if (!grepl(pattern, name)) 
[16:59:35.262]                               next
[16:59:35.262]                             invokeRestart(restart)
[16:59:35.262]                             muffled <- TRUE
[16:59:35.262]                             break
[16:59:35.262]                           }
[16:59:35.262]                         }
[16:59:35.262]                       }
[16:59:35.262]                       invisible(muffled)
[16:59:35.262]                     }
[16:59:35.262]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.262]                   }
[16:59:35.262]                 }
[16:59:35.262]             }
[16:59:35.262]         }))
[16:59:35.262]     }, error = function(ex) {
[16:59:35.262]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.262]                 ...future.rng), started = ...future.startTime, 
[16:59:35.262]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.262]             version = "1.8"), class = "FutureResult")
[16:59:35.262]     }, finally = {
[16:59:35.262]         if (!identical(...future.workdir, getwd())) 
[16:59:35.262]             setwd(...future.workdir)
[16:59:35.262]         {
[16:59:35.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.262]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.262]             }
[16:59:35.262]             base::options(...future.oldOptions)
[16:59:35.262]             if (.Platform$OS.type == "windows") {
[16:59:35.262]                 old_names <- names(...future.oldEnvVars)
[16:59:35.262]                 envs <- base::Sys.getenv()
[16:59:35.262]                 names <- names(envs)
[16:59:35.262]                 common <- intersect(names, old_names)
[16:59:35.262]                 added <- setdiff(names, old_names)
[16:59:35.262]                 removed <- setdiff(old_names, names)
[16:59:35.262]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.262]                   envs[common]]
[16:59:35.262]                 NAMES <- toupper(changed)
[16:59:35.262]                 args <- list()
[16:59:35.262]                 for (kk in seq_along(NAMES)) {
[16:59:35.262]                   name <- changed[[kk]]
[16:59:35.262]                   NAME <- NAMES[[kk]]
[16:59:35.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.262]                     next
[16:59:35.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.262]                 }
[16:59:35.262]                 NAMES <- toupper(added)
[16:59:35.262]                 for (kk in seq_along(NAMES)) {
[16:59:35.262]                   name <- added[[kk]]
[16:59:35.262]                   NAME <- NAMES[[kk]]
[16:59:35.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.262]                     next
[16:59:35.262]                   args[[name]] <- ""
[16:59:35.262]                 }
[16:59:35.262]                 NAMES <- toupper(removed)
[16:59:35.262]                 for (kk in seq_along(NAMES)) {
[16:59:35.262]                   name <- removed[[kk]]
[16:59:35.262]                   NAME <- NAMES[[kk]]
[16:59:35.262]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.262]                     next
[16:59:35.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.262]                 }
[16:59:35.262]                 if (length(args) > 0) 
[16:59:35.262]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.262]             }
[16:59:35.262]             else {
[16:59:35.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.262]             }
[16:59:35.262]             {
[16:59:35.262]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.262]                   0L) {
[16:59:35.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.262]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.262]                   base::options(opts)
[16:59:35.262]                 }
[16:59:35.262]                 {
[16:59:35.262]                   {
[16:59:35.262]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.262]                     NULL
[16:59:35.262]                   }
[16:59:35.262]                   options(future.plan = NULL)
[16:59:35.262]                   if (is.na(NA_character_)) 
[16:59:35.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.262]                     .init = FALSE)
[16:59:35.262]                 }
[16:59:35.262]             }
[16:59:35.262]         }
[16:59:35.262]     })
[16:59:35.262]     if (TRUE) {
[16:59:35.262]         base::sink(type = "output", split = FALSE)
[16:59:35.262]         if (TRUE) {
[16:59:35.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.262]         }
[16:59:35.262]         else {
[16:59:35.262]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.262]         }
[16:59:35.262]         base::close(...future.stdout)
[16:59:35.262]         ...future.stdout <- NULL
[16:59:35.262]     }
[16:59:35.262]     ...future.result$conditions <- ...future.conditions
[16:59:35.262]     ...future.result$finished <- base::Sys.time()
[16:59:35.262]     ...future.result
[16:59:35.262] }
[16:59:35.265] assign_globals() ...
[16:59:35.265] List of 5
[16:59:35.265]  $ ...future.FUN            :function (object, ...)  
[16:59:35.265]  $ future.call.arguments    :List of 1
[16:59:35.265]   ..$ digits: int 2
[16:59:35.265]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.265]  $ ...future.elements_ii    :List of 3
[16:59:35.265]   ..$ : num [1:9] 26 30 54 25 70 52 51 26 67
[16:59:35.265]   ..$ : num [1:9] 27 14 29 19 29 31 41 20 44
[16:59:35.265]   ..$ : num [1:9] 18 21 29 17 12 18 35 30 36
[16:59:35.265]  $ ...future.seeds_ii       : NULL
[16:59:35.265]  $ ...future.globals.maxSize: NULL
[16:59:35.265]  - attr(*, "where")=List of 5
[16:59:35.265]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.265]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.265]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.265]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.265]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.265]  - attr(*, "resolved")= logi FALSE
[16:59:35.265]  - attr(*, "total_size")= num 1296
[16:59:35.265]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.265]  - attr(*, "already-done")= logi TRUE
[16:59:35.274] - copied ‘...future.FUN’ to environment
[16:59:35.274] - copied ‘future.call.arguments’ to environment
[16:59:35.274] - copied ‘...future.elements_ii’ to environment
[16:59:35.274] - copied ‘...future.seeds_ii’ to environment
[16:59:35.274] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.274] assign_globals() ... done
[16:59:35.274] requestCore(): workers = 2
[16:59:35.277] MulticoreFuture started
[16:59:35.277] - Launch lazy future ... done
[16:59:35.277] run() for ‘MulticoreFuture’ ... done
[16:59:35.278] plan(): Setting new future strategy stack:
[16:59:35.278] Created future:
[16:59:35.278] List of future strategies:
[16:59:35.278] 1. sequential:
[16:59:35.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.278]    - tweaked: FALSE
[16:59:35.278]    - call: NULL
[16:59:35.279] plan(): nbrOfWorkers() = 1
[16:59:35.283] plan(): Setting new future strategy stack:
[16:59:35.283] List of future strategies:
[16:59:35.283] 1. multicore:
[16:59:35.283]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.283]    - tweaked: FALSE
[16:59:35.283]    - call: plan(strategy)
[16:59:35.288] plan(): nbrOfWorkers() = 2
[16:59:35.278] MulticoreFuture:
[16:59:35.278] Label: ‘future_by-1’
[16:59:35.278] Expression:
[16:59:35.278] {
[16:59:35.278]     do.call(function(...) {
[16:59:35.278]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.278]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.278]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.278]             on.exit(options(oopts), add = TRUE)
[16:59:35.278]         }
[16:59:35.278]         {
[16:59:35.278]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.278]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.278]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.278]             })
[16:59:35.278]         }
[16:59:35.278]     }, args = future.call.arguments)
[16:59:35.278] }
[16:59:35.278] Lazy evaluation: FALSE
[16:59:35.278] Asynchronous evaluation: TRUE
[16:59:35.278] Local evaluation: TRUE
[16:59:35.278] Environment: R_GlobalEnv
[16:59:35.278] Capture standard output: TRUE
[16:59:35.278] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.278] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.278] Packages: <none>
[16:59:35.278] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.278] Resolved: TRUE
[16:59:35.278] Value: <not collected>
[16:59:35.278] Conditions captured: <none>
[16:59:35.278] Early signaling: FALSE
[16:59:35.278] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.278] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.290] Chunk #1 of 2 ... DONE
[16:59:35.290] Chunk #2 of 2 ...
[16:59:35.290]  - Finding globals in 'X' for chunk #2 ...
[16:59:35.290] getGlobalsAndPackages() ...
[16:59:35.290] Searching for globals...
[16:59:35.291] 
[16:59:35.291] Searching for globals ... DONE
[16:59:35.291] - globals: [0] <none>
[16:59:35.291] getGlobalsAndPackages() ... DONE
[16:59:35.291]    + additional globals found: [n=0] 
[16:59:35.292]    + additional namespaces needed: [n=0] 
[16:59:35.292]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:35.292]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.292]  - seeds: <none>
[16:59:35.292]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.292] getGlobalsAndPackages() ...
[16:59:35.292] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.293] Resolving globals: FALSE
[16:59:35.293] Tweak future expression to call with '...' arguments ...
[16:59:35.293] {
[16:59:35.293]     do.call(function(...) {
[16:59:35.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.293]             on.exit(options(oopts), add = TRUE)
[16:59:35.293]         }
[16:59:35.293]         {
[16:59:35.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.293]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.293]             })
[16:59:35.293]         }
[16:59:35.293]     }, args = future.call.arguments)
[16:59:35.293] }
[16:59:35.293] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.294] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.294] 
[16:59:35.294] getGlobalsAndPackages() ... DONE
[16:59:35.295] run() for ‘Future’ ...
[16:59:35.295] - state: ‘created’
[16:59:35.295] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.300] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.301]   - Field: ‘label’
[16:59:35.301]   - Field: ‘local’
[16:59:35.301]   - Field: ‘owner’
[16:59:35.301]   - Field: ‘envir’
[16:59:35.301]   - Field: ‘workers’
[16:59:35.301]   - Field: ‘packages’
[16:59:35.302]   - Field: ‘gc’
[16:59:35.302]   - Field: ‘job’
[16:59:35.302]   - Field: ‘conditions’
[16:59:35.302]   - Field: ‘expr’
[16:59:35.302]   - Field: ‘uuid’
[16:59:35.302]   - Field: ‘seed’
[16:59:35.303]   - Field: ‘version’
[16:59:35.303]   - Field: ‘result’
[16:59:35.303]   - Field: ‘asynchronous’
[16:59:35.303]   - Field: ‘calls’
[16:59:35.303]   - Field: ‘globals’
[16:59:35.303]   - Field: ‘stdout’
[16:59:35.303]   - Field: ‘earlySignal’
[16:59:35.304]   - Field: ‘lazy’
[16:59:35.304]   - Field: ‘state’
[16:59:35.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.304] - Launch lazy future ...
[16:59:35.305] Packages needed by the future expression (n = 0): <none>
[16:59:35.305] Packages needed by future strategies (n = 0): <none>
[16:59:35.305] {
[16:59:35.305]     {
[16:59:35.305]         {
[16:59:35.305]             ...future.startTime <- base::Sys.time()
[16:59:35.305]             {
[16:59:35.305]                 {
[16:59:35.305]                   {
[16:59:35.305]                     {
[16:59:35.305]                       base::local({
[16:59:35.305]                         has_future <- base::requireNamespace("future", 
[16:59:35.305]                           quietly = TRUE)
[16:59:35.305]                         if (has_future) {
[16:59:35.305]                           ns <- base::getNamespace("future")
[16:59:35.305]                           version <- ns[[".package"]][["version"]]
[16:59:35.305]                           if (is.null(version)) 
[16:59:35.305]                             version <- utils::packageVersion("future")
[16:59:35.305]                         }
[16:59:35.305]                         else {
[16:59:35.305]                           version <- NULL
[16:59:35.305]                         }
[16:59:35.305]                         if (!has_future || version < "1.8.0") {
[16:59:35.305]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.305]                             "", base::R.version$version.string), 
[16:59:35.305]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.305]                               "release", "version")], collapse = " "), 
[16:59:35.305]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.305]                             info)
[16:59:35.305]                           info <- base::paste(info, collapse = "; ")
[16:59:35.305]                           if (!has_future) {
[16:59:35.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.305]                               info)
[16:59:35.305]                           }
[16:59:35.305]                           else {
[16:59:35.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.305]                               info, version)
[16:59:35.305]                           }
[16:59:35.305]                           base::stop(msg)
[16:59:35.305]                         }
[16:59:35.305]                       })
[16:59:35.305]                     }
[16:59:35.305]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.305]                     base::options(mc.cores = 1L)
[16:59:35.305]                   }
[16:59:35.305]                   ...future.strategy.old <- future::plan("list")
[16:59:35.305]                   options(future.plan = NULL)
[16:59:35.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.305]                 }
[16:59:35.305]                 ...future.workdir <- getwd()
[16:59:35.305]             }
[16:59:35.305]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.305]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.305]         }
[16:59:35.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.305]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.305]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.305]             base::names(...future.oldOptions))
[16:59:35.305]     }
[16:59:35.305]     if (FALSE) {
[16:59:35.305]     }
[16:59:35.305]     else {
[16:59:35.305]         if (TRUE) {
[16:59:35.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.305]                 open = "w")
[16:59:35.305]         }
[16:59:35.305]         else {
[16:59:35.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.305]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.305]         }
[16:59:35.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.305]             base::sink(type = "output", split = FALSE)
[16:59:35.305]             base::close(...future.stdout)
[16:59:35.305]         }, add = TRUE)
[16:59:35.305]     }
[16:59:35.305]     ...future.frame <- base::sys.nframe()
[16:59:35.305]     ...future.conditions <- base::list()
[16:59:35.305]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.305]     if (FALSE) {
[16:59:35.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.305]     }
[16:59:35.305]     ...future.result <- base::tryCatch({
[16:59:35.305]         base::withCallingHandlers({
[16:59:35.305]             ...future.value <- base::withVisible(base::local({
[16:59:35.305]                 withCallingHandlers({
[16:59:35.305]                   {
[16:59:35.305]                     do.call(function(...) {
[16:59:35.305]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.305]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.305]                         ...future.globals.maxSize)) {
[16:59:35.305]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.305]                         on.exit(options(oopts), add = TRUE)
[16:59:35.305]                       }
[16:59:35.305]                       {
[16:59:35.305]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.305]                           FUN = function(jj) {
[16:59:35.305]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.305]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.305]                           })
[16:59:35.305]                       }
[16:59:35.305]                     }, args = future.call.arguments)
[16:59:35.305]                   }
[16:59:35.305]                 }, immediateCondition = function(cond) {
[16:59:35.305]                   save_rds <- function (object, pathname, ...) 
[16:59:35.305]                   {
[16:59:35.305]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.305]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.305]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.305]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.305]                         fi_tmp[["mtime"]])
[16:59:35.305]                     }
[16:59:35.305]                     tryCatch({
[16:59:35.305]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.305]                     }, error = function(ex) {
[16:59:35.305]                       msg <- conditionMessage(ex)
[16:59:35.305]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.305]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.305]                         fi_tmp[["mtime"]], msg)
[16:59:35.305]                       ex$message <- msg
[16:59:35.305]                       stop(ex)
[16:59:35.305]                     })
[16:59:35.305]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.305]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.305]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.305]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.305]                       fi <- file.info(pathname)
[16:59:35.305]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.305]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.305]                         fi[["size"]], fi[["mtime"]])
[16:59:35.305]                       stop(msg)
[16:59:35.305]                     }
[16:59:35.305]                     invisible(pathname)
[16:59:35.305]                   }
[16:59:35.305]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.305]                     rootPath = tempdir()) 
[16:59:35.305]                   {
[16:59:35.305]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.305]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.305]                       tmpdir = path, fileext = ".rds")
[16:59:35.305]                     save_rds(obj, file)
[16:59:35.305]                   }
[16:59:35.305]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.305]                   {
[16:59:35.305]                     inherits <- base::inherits
[16:59:35.305]                     invokeRestart <- base::invokeRestart
[16:59:35.305]                     is.null <- base::is.null
[16:59:35.305]                     muffled <- FALSE
[16:59:35.305]                     if (inherits(cond, "message")) {
[16:59:35.305]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.305]                       if (muffled) 
[16:59:35.305]                         invokeRestart("muffleMessage")
[16:59:35.305]                     }
[16:59:35.305]                     else if (inherits(cond, "warning")) {
[16:59:35.305]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.305]                       if (muffled) 
[16:59:35.305]                         invokeRestart("muffleWarning")
[16:59:35.305]                     }
[16:59:35.305]                     else if (inherits(cond, "condition")) {
[16:59:35.305]                       if (!is.null(pattern)) {
[16:59:35.305]                         computeRestarts <- base::computeRestarts
[16:59:35.305]                         grepl <- base::grepl
[16:59:35.305]                         restarts <- computeRestarts(cond)
[16:59:35.305]                         for (restart in restarts) {
[16:59:35.305]                           name <- restart$name
[16:59:35.305]                           if (is.null(name)) 
[16:59:35.305]                             next
[16:59:35.305]                           if (!grepl(pattern, name)) 
[16:59:35.305]                             next
[16:59:35.305]                           invokeRestart(restart)
[16:59:35.305]                           muffled <- TRUE
[16:59:35.305]                           break
[16:59:35.305]                         }
[16:59:35.305]                       }
[16:59:35.305]                     }
[16:59:35.305]                     invisible(muffled)
[16:59:35.305]                   }
[16:59:35.305]                   muffleCondition(cond)
[16:59:35.305]                 })
[16:59:35.305]             }))
[16:59:35.305]             future::FutureResult(value = ...future.value$value, 
[16:59:35.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.305]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.305]                     ...future.globalenv.names))
[16:59:35.305]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.305]         }, condition = base::local({
[16:59:35.305]             c <- base::c
[16:59:35.305]             inherits <- base::inherits
[16:59:35.305]             invokeRestart <- base::invokeRestart
[16:59:35.305]             length <- base::length
[16:59:35.305]             list <- base::list
[16:59:35.305]             seq.int <- base::seq.int
[16:59:35.305]             signalCondition <- base::signalCondition
[16:59:35.305]             sys.calls <- base::sys.calls
[16:59:35.305]             `[[` <- base::`[[`
[16:59:35.305]             `+` <- base::`+`
[16:59:35.305]             `<<-` <- base::`<<-`
[16:59:35.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.305]                   3L)]
[16:59:35.305]             }
[16:59:35.305]             function(cond) {
[16:59:35.305]                 is_error <- inherits(cond, "error")
[16:59:35.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.305]                   NULL)
[16:59:35.305]                 if (is_error) {
[16:59:35.305]                   sessionInformation <- function() {
[16:59:35.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.305]                       search = base::search(), system = base::Sys.info())
[16:59:35.305]                   }
[16:59:35.305]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.305]                     cond$call), session = sessionInformation(), 
[16:59:35.305]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.305]                   signalCondition(cond)
[16:59:35.305]                 }
[16:59:35.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.305]                 "immediateCondition"))) {
[16:59:35.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.305]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.305]                   if (TRUE && !signal) {
[16:59:35.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.305]                     {
[16:59:35.305]                       inherits <- base::inherits
[16:59:35.305]                       invokeRestart <- base::invokeRestart
[16:59:35.305]                       is.null <- base::is.null
[16:59:35.305]                       muffled <- FALSE
[16:59:35.305]                       if (inherits(cond, "message")) {
[16:59:35.305]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.305]                         if (muffled) 
[16:59:35.305]                           invokeRestart("muffleMessage")
[16:59:35.305]                       }
[16:59:35.305]                       else if (inherits(cond, "warning")) {
[16:59:35.305]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.305]                         if (muffled) 
[16:59:35.305]                           invokeRestart("muffleWarning")
[16:59:35.305]                       }
[16:59:35.305]                       else if (inherits(cond, "condition")) {
[16:59:35.305]                         if (!is.null(pattern)) {
[16:59:35.305]                           computeRestarts <- base::computeRestarts
[16:59:35.305]                           grepl <- base::grepl
[16:59:35.305]                           restarts <- computeRestarts(cond)
[16:59:35.305]                           for (restart in restarts) {
[16:59:35.305]                             name <- restart$name
[16:59:35.305]                             if (is.null(name)) 
[16:59:35.305]                               next
[16:59:35.305]                             if (!grepl(pattern, name)) 
[16:59:35.305]                               next
[16:59:35.305]                             invokeRestart(restart)
[16:59:35.305]                             muffled <- TRUE
[16:59:35.305]                             break
[16:59:35.305]                           }
[16:59:35.305]                         }
[16:59:35.305]                       }
[16:59:35.305]                       invisible(muffled)
[16:59:35.305]                     }
[16:59:35.305]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.305]                   }
[16:59:35.305]                 }
[16:59:35.305]                 else {
[16:59:35.305]                   if (TRUE) {
[16:59:35.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.305]                     {
[16:59:35.305]                       inherits <- base::inherits
[16:59:35.305]                       invokeRestart <- base::invokeRestart
[16:59:35.305]                       is.null <- base::is.null
[16:59:35.305]                       muffled <- FALSE
[16:59:35.305]                       if (inherits(cond, "message")) {
[16:59:35.305]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.305]                         if (muffled) 
[16:59:35.305]                           invokeRestart("muffleMessage")
[16:59:35.305]                       }
[16:59:35.305]                       else if (inherits(cond, "warning")) {
[16:59:35.305]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.305]                         if (muffled) 
[16:59:35.305]                           invokeRestart("muffleWarning")
[16:59:35.305]                       }
[16:59:35.305]                       else if (inherits(cond, "condition")) {
[16:59:35.305]                         if (!is.null(pattern)) {
[16:59:35.305]                           computeRestarts <- base::computeRestarts
[16:59:35.305]                           grepl <- base::grepl
[16:59:35.305]                           restarts <- computeRestarts(cond)
[16:59:35.305]                           for (restart in restarts) {
[16:59:35.305]                             name <- restart$name
[16:59:35.305]                             if (is.null(name)) 
[16:59:35.305]                               next
[16:59:35.305]                             if (!grepl(pattern, name)) 
[16:59:35.305]                               next
[16:59:35.305]                             invokeRestart(restart)
[16:59:35.305]                             muffled <- TRUE
[16:59:35.305]                             break
[16:59:35.305]                           }
[16:59:35.305]                         }
[16:59:35.305]                       }
[16:59:35.305]                       invisible(muffled)
[16:59:35.305]                     }
[16:59:35.305]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.305]                   }
[16:59:35.305]                 }
[16:59:35.305]             }
[16:59:35.305]         }))
[16:59:35.305]     }, error = function(ex) {
[16:59:35.305]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.305]                 ...future.rng), started = ...future.startTime, 
[16:59:35.305]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.305]             version = "1.8"), class = "FutureResult")
[16:59:35.305]     }, finally = {
[16:59:35.305]         if (!identical(...future.workdir, getwd())) 
[16:59:35.305]             setwd(...future.workdir)
[16:59:35.305]         {
[16:59:35.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.305]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.305]             }
[16:59:35.305]             base::options(...future.oldOptions)
[16:59:35.305]             if (.Platform$OS.type == "windows") {
[16:59:35.305]                 old_names <- names(...future.oldEnvVars)
[16:59:35.305]                 envs <- base::Sys.getenv()
[16:59:35.305]                 names <- names(envs)
[16:59:35.305]                 common <- intersect(names, old_names)
[16:59:35.305]                 added <- setdiff(names, old_names)
[16:59:35.305]                 removed <- setdiff(old_names, names)
[16:59:35.305]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.305]                   envs[common]]
[16:59:35.305]                 NAMES <- toupper(changed)
[16:59:35.305]                 args <- list()
[16:59:35.305]                 for (kk in seq_along(NAMES)) {
[16:59:35.305]                   name <- changed[[kk]]
[16:59:35.305]                   NAME <- NAMES[[kk]]
[16:59:35.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.305]                     next
[16:59:35.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.305]                 }
[16:59:35.305]                 NAMES <- toupper(added)
[16:59:35.305]                 for (kk in seq_along(NAMES)) {
[16:59:35.305]                   name <- added[[kk]]
[16:59:35.305]                   NAME <- NAMES[[kk]]
[16:59:35.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.305]                     next
[16:59:35.305]                   args[[name]] <- ""
[16:59:35.305]                 }
[16:59:35.305]                 NAMES <- toupper(removed)
[16:59:35.305]                 for (kk in seq_along(NAMES)) {
[16:59:35.305]                   name <- removed[[kk]]
[16:59:35.305]                   NAME <- NAMES[[kk]]
[16:59:35.305]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.305]                     next
[16:59:35.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.305]                 }
[16:59:35.305]                 if (length(args) > 0) 
[16:59:35.305]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.305]             }
[16:59:35.305]             else {
[16:59:35.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.305]             }
[16:59:35.305]             {
[16:59:35.305]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.305]                   0L) {
[16:59:35.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.305]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.305]                   base::options(opts)
[16:59:35.305]                 }
[16:59:35.305]                 {
[16:59:35.305]                   {
[16:59:35.305]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.305]                     NULL
[16:59:35.305]                   }
[16:59:35.305]                   options(future.plan = NULL)
[16:59:35.305]                   if (is.na(NA_character_)) 
[16:59:35.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.305]                     .init = FALSE)
[16:59:35.305]                 }
[16:59:35.305]             }
[16:59:35.305]         }
[16:59:35.305]     })
[16:59:35.305]     if (TRUE) {
[16:59:35.305]         base::sink(type = "output", split = FALSE)
[16:59:35.305]         if (TRUE) {
[16:59:35.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.305]         }
[16:59:35.305]         else {
[16:59:35.305]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.305]         }
[16:59:35.305]         base::close(...future.stdout)
[16:59:35.305]         ...future.stdout <- NULL
[16:59:35.305]     }
[16:59:35.305]     ...future.result$conditions <- ...future.conditions
[16:59:35.305]     ...future.result$finished <- base::Sys.time()
[16:59:35.305]     ...future.result
[16:59:35.305] }
[16:59:35.309] assign_globals() ...
[16:59:35.309] List of 5
[16:59:35.309]  $ ...future.FUN            :function (object, ...)  
[16:59:35.309]  $ future.call.arguments    :List of 1
[16:59:35.309]   ..$ digits: int 2
[16:59:35.309]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.309]  $ ...future.elements_ii    :List of 3
[16:59:35.309]   ..$ : num [1:9] 42 26 19 16 39 28 21 39 29
[16:59:35.309]   ..$ : num [1:9] 36 21 24 18 10 43 28 15 26
[16:59:35.309]   ..$ : num [1:9] 20 21 24 17 13 15 15 16 28
[16:59:35.309]  $ ...future.seeds_ii       : NULL
[16:59:35.309]  $ ...future.globals.maxSize: NULL
[16:59:35.309]  - attr(*, "where")=List of 5
[16:59:35.309]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.309]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.309]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.309]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.309]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.309]  - attr(*, "resolved")= logi FALSE
[16:59:35.309]  - attr(*, "total_size")= num 1296
[16:59:35.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.309]  - attr(*, "already-done")= logi TRUE
[16:59:35.321] - copied ‘...future.FUN’ to environment
[16:59:35.322] - copied ‘future.call.arguments’ to environment
[16:59:35.322] - copied ‘...future.elements_ii’ to environment
[16:59:35.322] - copied ‘...future.seeds_ii’ to environment
[16:59:35.322] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.322] assign_globals() ... done
[16:59:35.322] requestCore(): workers = 2
[16:59:35.325] MulticoreFuture started
[16:59:35.326] - Launch lazy future ... done
[16:59:35.326] plan(): Setting new future strategy stack:
[16:59:35.326] run() for ‘MulticoreFuture’ ... done
[16:59:35.327] Created future:
[16:59:35.326] List of future strategies:
[16:59:35.326] 1. sequential:
[16:59:35.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.326]    - tweaked: FALSE
[16:59:35.326]    - call: NULL
[16:59:35.328] plan(): nbrOfWorkers() = 1
[16:59:35.331] plan(): Setting new future strategy stack:
[16:59:35.331] List of future strategies:
[16:59:35.331] 1. multicore:
[16:59:35.331]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.331]    - tweaked: FALSE
[16:59:35.331]    - call: plan(strategy)
[16:59:35.337] plan(): nbrOfWorkers() = 2
[16:59:35.327] MulticoreFuture:
[16:59:35.327] Label: ‘future_by-2’
[16:59:35.327] Expression:
[16:59:35.327] {
[16:59:35.327]     do.call(function(...) {
[16:59:35.327]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.327]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.327]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.327]             on.exit(options(oopts), add = TRUE)
[16:59:35.327]         }
[16:59:35.327]         {
[16:59:35.327]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.327]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.327]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.327]             })
[16:59:35.327]         }
[16:59:35.327]     }, args = future.call.arguments)
[16:59:35.327] }
[16:59:35.327] Lazy evaluation: FALSE
[16:59:35.327] Asynchronous evaluation: TRUE
[16:59:35.327] Local evaluation: TRUE
[16:59:35.327] Environment: R_GlobalEnv
[16:59:35.327] Capture standard output: TRUE
[16:59:35.327] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.327] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.327] Packages: <none>
[16:59:35.327] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.327] Resolved: TRUE
[16:59:35.327] Value: <not collected>
[16:59:35.327] Conditions captured: <none>
[16:59:35.327] Early signaling: FALSE
[16:59:35.327] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.327] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.338] Chunk #2 of 2 ... DONE
[16:59:35.338] Launching 2 futures (chunks) ... DONE
[16:59:35.339] Resolving 2 futures (chunks) ...
[16:59:35.339] resolve() on list ...
[16:59:35.339]  recursive: 0
[16:59:35.339]  length: 2
[16:59:35.339] 
[16:59:35.340] Future #1
[16:59:35.340] result() for MulticoreFuture ...
[16:59:35.341] result() for MulticoreFuture ...
[16:59:35.341] result() for MulticoreFuture ... done
[16:59:35.341] result() for MulticoreFuture ... done
[16:59:35.341] result() for MulticoreFuture ...
[16:59:35.341] result() for MulticoreFuture ... done
[16:59:35.342] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:35.342] - nx: 2
[16:59:35.342] - relay: TRUE
[16:59:35.342] - stdout: TRUE
[16:59:35.342] - signal: TRUE
[16:59:35.342] - resignal: FALSE
[16:59:35.342] - force: TRUE
[16:59:35.343] - relayed: [n=2] FALSE, FALSE
[16:59:35.343] - queued futures: [n=2] FALSE, FALSE
[16:59:35.343]  - until=1
[16:59:35.343]  - relaying element #1
[16:59:35.343] result() for MulticoreFuture ...
[16:59:35.343] result() for MulticoreFuture ... done
[16:59:35.344] result() for MulticoreFuture ...
[16:59:35.344] result() for MulticoreFuture ... done
[16:59:35.344] result() for MulticoreFuture ...
[16:59:35.344] result() for MulticoreFuture ... done
[16:59:35.344] result() for MulticoreFuture ...
[16:59:35.344] result() for MulticoreFuture ... done
[16:59:35.344] - relayed: [n=2] TRUE, FALSE
[16:59:35.345] - queued futures: [n=2] TRUE, FALSE
[16:59:35.345] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:35.345]  length: 1 (resolved future 1)
[16:59:35.345] Future #2
[16:59:35.345] result() for MulticoreFuture ...
[16:59:35.346] result() for MulticoreFuture ...
[16:59:35.346] result() for MulticoreFuture ... done
[16:59:35.346] result() for MulticoreFuture ... done
[16:59:35.347] result() for MulticoreFuture ...
[16:59:35.347] result() for MulticoreFuture ... done
[16:59:35.347] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:35.347] - nx: 2
[16:59:35.347] - relay: TRUE
[16:59:35.347] - stdout: TRUE
[16:59:35.347] - signal: TRUE
[16:59:35.347] - resignal: FALSE
[16:59:35.348] - force: TRUE
[16:59:35.348] - relayed: [n=2] TRUE, FALSE
[16:59:35.348] - queued futures: [n=2] TRUE, FALSE
[16:59:35.348]  - until=2
[16:59:35.348]  - relaying element #2
[16:59:35.348] result() for MulticoreFuture ...
[16:59:35.348] result() for MulticoreFuture ... done
[16:59:35.348] result() for MulticoreFuture ...
[16:59:35.349] result() for MulticoreFuture ... done
[16:59:35.349] result() for MulticoreFuture ...
[16:59:35.349] result() for MulticoreFuture ... done
[16:59:35.349] result() for MulticoreFuture ...
[16:59:35.349] result() for MulticoreFuture ... done
[16:59:35.349] - relayed: [n=2] TRUE, TRUE
[16:59:35.349] - queued futures: [n=2] TRUE, TRUE
[16:59:35.349] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:35.350]  length: 0 (resolved future 2)
[16:59:35.350] Relaying remaining futures
[16:59:35.350] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.350] - nx: 2
[16:59:35.350] - relay: TRUE
[16:59:35.350] - stdout: TRUE
[16:59:35.350] - signal: TRUE
[16:59:35.350] - resignal: FALSE
[16:59:35.350] - force: TRUE
[16:59:35.350] - relayed: [n=2] TRUE, TRUE
[16:59:35.351] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:35.351] - relayed: [n=2] TRUE, TRUE
[16:59:35.351] - queued futures: [n=2] TRUE, TRUE
[16:59:35.351] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.351] resolve() on list ... DONE
[16:59:35.351] result() for MulticoreFuture ...
[16:59:35.351] result() for MulticoreFuture ... done
[16:59:35.351] result() for MulticoreFuture ...
[16:59:35.351] result() for MulticoreFuture ... done
[16:59:35.352] result() for MulticoreFuture ...
[16:59:35.352] result() for MulticoreFuture ... done
[16:59:35.352] result() for MulticoreFuture ...
[16:59:35.352] result() for MulticoreFuture ... done
[16:59:35.352]  - Number of value chunks collected: 2
[16:59:35.352] Resolving 2 futures (chunks) ... DONE
[16:59:35.352] Reducing values from 2 chunks ...
[16:59:35.352]  - Number of values collected after concatenation: 6
[16:59:35.353]  - Number of values expected: 6
[16:59:35.353] Reducing values from 2 chunks ... DONE
[16:59:35.353] future_lapply() ... DONE
[16:59:35.353] future_by_internal() ... DONE
[16:59:35.354] future_by_internal() ...
[16:59:35.355] future_lapply() ...
[16:59:35.362] Number of chunks: 2
[16:59:35.363] getGlobalsAndPackagesXApply() ...
[16:59:35.363]  - future.globals: TRUE
[16:59:35.363] getGlobalsAndPackages() ...
[16:59:35.363] Searching for globals...
[16:59:35.366] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:35.366] Searching for globals ... DONE
[16:59:35.366] Resolving globals: FALSE
[16:59:35.366] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:59:35.367] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:59:35.367] - globals: [1] ‘FUN’
[16:59:35.367] - packages: [1] ‘stats’
[16:59:35.367] getGlobalsAndPackages() ... DONE
[16:59:35.367]  - globals found/used: [n=1] ‘FUN’
[16:59:35.368]  - needed namespaces: [n=1] ‘stats’
[16:59:35.368] Finding globals ... DONE
[16:59:35.368]  - use_args: TRUE
[16:59:35.368]  - Getting '...' globals ...
[16:59:35.368] resolve() on list ...
[16:59:35.368]  recursive: 0
[16:59:35.368]  length: 1
[16:59:35.368]  elements: ‘...’
[16:59:35.369]  length: 0 (resolved future 1)
[16:59:35.369] resolve() on list ... DONE
[16:59:35.369]    - '...' content: [n=1] ‘singular.ok’
[16:59:35.369] List of 1
[16:59:35.369]  $ ...:List of 1
[16:59:35.369]   ..$ singular.ok: logi FALSE
[16:59:35.369]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.369]  - attr(*, "where")=List of 1
[16:59:35.369]   ..$ ...:<environment: 0x562052a86198> 
[16:59:35.369]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.369]  - attr(*, "resolved")= logi TRUE
[16:59:35.369]  - attr(*, "total_size")= num NA
[16:59:35.372]  - Getting '...' globals ... DONE
[16:59:35.372] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.372] List of 2
[16:59:35.372]  $ ...future.FUN:function (x, ...)  
[16:59:35.372]  $ ...          :List of 1
[16:59:35.372]   ..$ singular.ok: logi FALSE
[16:59:35.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.372]  - attr(*, "where")=List of 2
[16:59:35.372]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.372]   ..$ ...          :<environment: 0x562052a86198> 
[16:59:35.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.372]  - attr(*, "resolved")= logi FALSE
[16:59:35.372]  - attr(*, "total_size")= num 5384
[16:59:35.375] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:35.375] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.376] Number of futures (= number of chunks): 2
[16:59:35.376] Launching 2 futures (chunks) ...
[16:59:35.376] Chunk #1 of 2 ...
[16:59:35.376]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.376] getGlobalsAndPackages() ...
[16:59:35.376] Searching for globals...
[16:59:35.377] 
[16:59:35.377] Searching for globals ... DONE
[16:59:35.377] - globals: [0] <none>
[16:59:35.377] getGlobalsAndPackages() ... DONE
[16:59:35.377]    + additional globals found: [n=0] 
[16:59:35.377]    + additional namespaces needed: [n=0] 
[16:59:35.377]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.377]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.377]  - seeds: <none>
[16:59:35.377]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.378] getGlobalsAndPackages() ...
[16:59:35.378] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.378] Resolving globals: FALSE
[16:59:35.378] Tweak future expression to call with '...' arguments ...
[16:59:35.378] {
[16:59:35.378]     do.call(function(...) {
[16:59:35.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.378]             on.exit(options(oopts), add = TRUE)
[16:59:35.378]         }
[16:59:35.378]         {
[16:59:35.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.378]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.378]             })
[16:59:35.378]         }
[16:59:35.378]     }, args = future.call.arguments)
[16:59:35.378] }
[16:59:35.378] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.379] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.379] 
[16:59:35.379] getGlobalsAndPackages() ... DONE
[16:59:35.379] run() for ‘Future’ ...
[16:59:35.379] - state: ‘created’
[16:59:35.379] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.383] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.384]   - Field: ‘label’
[16:59:35.384]   - Field: ‘local’
[16:59:35.384]   - Field: ‘owner’
[16:59:35.384]   - Field: ‘envir’
[16:59:35.384]   - Field: ‘workers’
[16:59:35.386]   - Field: ‘packages’
[16:59:35.386]   - Field: ‘gc’
[16:59:35.386]   - Field: ‘job’
[16:59:35.387]   - Field: ‘conditions’
[16:59:35.387]   - Field: ‘expr’
[16:59:35.387]   - Field: ‘uuid’
[16:59:35.387]   - Field: ‘seed’
[16:59:35.387]   - Field: ‘version’
[16:59:35.387]   - Field: ‘result’
[16:59:35.387]   - Field: ‘asynchronous’
[16:59:35.387]   - Field: ‘calls’
[16:59:35.387]   - Field: ‘globals’
[16:59:35.388]   - Field: ‘stdout’
[16:59:35.388]   - Field: ‘earlySignal’
[16:59:35.388]   - Field: ‘lazy’
[16:59:35.388]   - Field: ‘state’
[16:59:35.388] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.388] - Launch lazy future ...
[16:59:35.389] Packages needed by the future expression (n = 1): ‘stats’
[16:59:35.389] Packages needed by future strategies (n = 0): <none>
[16:59:35.389] {
[16:59:35.389]     {
[16:59:35.389]         {
[16:59:35.389]             ...future.startTime <- base::Sys.time()
[16:59:35.389]             {
[16:59:35.389]                 {
[16:59:35.389]                   {
[16:59:35.389]                     {
[16:59:35.389]                       {
[16:59:35.389]                         base::local({
[16:59:35.389]                           has_future <- base::requireNamespace("future", 
[16:59:35.389]                             quietly = TRUE)
[16:59:35.389]                           if (has_future) {
[16:59:35.389]                             ns <- base::getNamespace("future")
[16:59:35.389]                             version <- ns[[".package"]][["version"]]
[16:59:35.389]                             if (is.null(version)) 
[16:59:35.389]                               version <- utils::packageVersion("future")
[16:59:35.389]                           }
[16:59:35.389]                           else {
[16:59:35.389]                             version <- NULL
[16:59:35.389]                           }
[16:59:35.389]                           if (!has_future || version < "1.8.0") {
[16:59:35.389]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.389]                               "", base::R.version$version.string), 
[16:59:35.389]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:35.389]                                 base::R.version$platform, 8 * 
[16:59:35.389]                                   base::.Machine$sizeof.pointer), 
[16:59:35.389]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.389]                                 "release", "version")], collapse = " "), 
[16:59:35.389]                               hostname = base::Sys.info()[["nodename"]])
[16:59:35.389]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.389]                               info)
[16:59:35.389]                             info <- base::paste(info, collapse = "; ")
[16:59:35.389]                             if (!has_future) {
[16:59:35.389]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.389]                                 info)
[16:59:35.389]                             }
[16:59:35.389]                             else {
[16:59:35.389]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.389]                                 info, version)
[16:59:35.389]                             }
[16:59:35.389]                             base::stop(msg)
[16:59:35.389]                           }
[16:59:35.389]                         })
[16:59:35.389]                       }
[16:59:35.389]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.389]                       base::options(mc.cores = 1L)
[16:59:35.389]                     }
[16:59:35.389]                     base::local({
[16:59:35.389]                       for (pkg in "stats") {
[16:59:35.389]                         base::loadNamespace(pkg)
[16:59:35.389]                         base::library(pkg, character.only = TRUE)
[16:59:35.389]                       }
[16:59:35.389]                     })
[16:59:35.389]                   }
[16:59:35.389]                   ...future.strategy.old <- future::plan("list")
[16:59:35.389]                   options(future.plan = NULL)
[16:59:35.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.389]                 }
[16:59:35.389]                 ...future.workdir <- getwd()
[16:59:35.389]             }
[16:59:35.389]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.389]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.389]         }
[16:59:35.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.389]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.389]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.389]             base::names(...future.oldOptions))
[16:59:35.389]     }
[16:59:35.389]     if (FALSE) {
[16:59:35.389]     }
[16:59:35.389]     else {
[16:59:35.389]         if (TRUE) {
[16:59:35.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.389]                 open = "w")
[16:59:35.389]         }
[16:59:35.389]         else {
[16:59:35.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.389]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.389]         }
[16:59:35.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.389]             base::sink(type = "output", split = FALSE)
[16:59:35.389]             base::close(...future.stdout)
[16:59:35.389]         }, add = TRUE)
[16:59:35.389]     }
[16:59:35.389]     ...future.frame <- base::sys.nframe()
[16:59:35.389]     ...future.conditions <- base::list()
[16:59:35.389]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.389]     if (FALSE) {
[16:59:35.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.389]     }
[16:59:35.389]     ...future.result <- base::tryCatch({
[16:59:35.389]         base::withCallingHandlers({
[16:59:35.389]             ...future.value <- base::withVisible(base::local({
[16:59:35.389]                 withCallingHandlers({
[16:59:35.389]                   {
[16:59:35.389]                     do.call(function(...) {
[16:59:35.389]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.389]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.389]                         ...future.globals.maxSize)) {
[16:59:35.389]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.389]                         on.exit(options(oopts), add = TRUE)
[16:59:35.389]                       }
[16:59:35.389]                       {
[16:59:35.389]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.389]                           FUN = function(jj) {
[16:59:35.389]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.389]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.389]                           })
[16:59:35.389]                       }
[16:59:35.389]                     }, args = future.call.arguments)
[16:59:35.389]                   }
[16:59:35.389]                 }, immediateCondition = function(cond) {
[16:59:35.389]                   save_rds <- function (object, pathname, ...) 
[16:59:35.389]                   {
[16:59:35.389]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.389]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.389]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.389]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.389]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.389]                         fi_tmp[["mtime"]])
[16:59:35.389]                     }
[16:59:35.389]                     tryCatch({
[16:59:35.389]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.389]                     }, error = function(ex) {
[16:59:35.389]                       msg <- conditionMessage(ex)
[16:59:35.389]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.389]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.389]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.389]                         fi_tmp[["mtime"]], msg)
[16:59:35.389]                       ex$message <- msg
[16:59:35.389]                       stop(ex)
[16:59:35.389]                     })
[16:59:35.389]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.389]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.389]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.389]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.389]                       fi <- file.info(pathname)
[16:59:35.389]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.389]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.389]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.389]                         fi[["size"]], fi[["mtime"]])
[16:59:35.389]                       stop(msg)
[16:59:35.389]                     }
[16:59:35.389]                     invisible(pathname)
[16:59:35.389]                   }
[16:59:35.389]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.389]                     rootPath = tempdir()) 
[16:59:35.389]                   {
[16:59:35.389]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.389]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.389]                       tmpdir = path, fileext = ".rds")
[16:59:35.389]                     save_rds(obj, file)
[16:59:35.389]                   }
[16:59:35.389]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.389]                   {
[16:59:35.389]                     inherits <- base::inherits
[16:59:35.389]                     invokeRestart <- base::invokeRestart
[16:59:35.389]                     is.null <- base::is.null
[16:59:35.389]                     muffled <- FALSE
[16:59:35.389]                     if (inherits(cond, "message")) {
[16:59:35.389]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.389]                       if (muffled) 
[16:59:35.389]                         invokeRestart("muffleMessage")
[16:59:35.389]                     }
[16:59:35.389]                     else if (inherits(cond, "warning")) {
[16:59:35.389]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.389]                       if (muffled) 
[16:59:35.389]                         invokeRestart("muffleWarning")
[16:59:35.389]                     }
[16:59:35.389]                     else if (inherits(cond, "condition")) {
[16:59:35.389]                       if (!is.null(pattern)) {
[16:59:35.389]                         computeRestarts <- base::computeRestarts
[16:59:35.389]                         grepl <- base::grepl
[16:59:35.389]                         restarts <- computeRestarts(cond)
[16:59:35.389]                         for (restart in restarts) {
[16:59:35.389]                           name <- restart$name
[16:59:35.389]                           if (is.null(name)) 
[16:59:35.389]                             next
[16:59:35.389]                           if (!grepl(pattern, name)) 
[16:59:35.389]                             next
[16:59:35.389]                           invokeRestart(restart)
[16:59:35.389]                           muffled <- TRUE
[16:59:35.389]                           break
[16:59:35.389]                         }
[16:59:35.389]                       }
[16:59:35.389]                     }
[16:59:35.389]                     invisible(muffled)
[16:59:35.389]                   }
[16:59:35.389]                   muffleCondition(cond)
[16:59:35.389]                 })
[16:59:35.389]             }))
[16:59:35.389]             future::FutureResult(value = ...future.value$value, 
[16:59:35.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.389]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.389]                     ...future.globalenv.names))
[16:59:35.389]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.389]         }, condition = base::local({
[16:59:35.389]             c <- base::c
[16:59:35.389]             inherits <- base::inherits
[16:59:35.389]             invokeRestart <- base::invokeRestart
[16:59:35.389]             length <- base::length
[16:59:35.389]             list <- base::list
[16:59:35.389]             seq.int <- base::seq.int
[16:59:35.389]             signalCondition <- base::signalCondition
[16:59:35.389]             sys.calls <- base::sys.calls
[16:59:35.389]             `[[` <- base::`[[`
[16:59:35.389]             `+` <- base::`+`
[16:59:35.389]             `<<-` <- base::`<<-`
[16:59:35.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.389]                   3L)]
[16:59:35.389]             }
[16:59:35.389]             function(cond) {
[16:59:35.389]                 is_error <- inherits(cond, "error")
[16:59:35.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.389]                   NULL)
[16:59:35.389]                 if (is_error) {
[16:59:35.389]                   sessionInformation <- function() {
[16:59:35.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.389]                       search = base::search(), system = base::Sys.info())
[16:59:35.389]                   }
[16:59:35.389]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.389]                     cond$call), session = sessionInformation(), 
[16:59:35.389]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.389]                   signalCondition(cond)
[16:59:35.389]                 }
[16:59:35.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.389]                 "immediateCondition"))) {
[16:59:35.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.389]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.389]                   if (TRUE && !signal) {
[16:59:35.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.389]                     {
[16:59:35.389]                       inherits <- base::inherits
[16:59:35.389]                       invokeRestart <- base::invokeRestart
[16:59:35.389]                       is.null <- base::is.null
[16:59:35.389]                       muffled <- FALSE
[16:59:35.389]                       if (inherits(cond, "message")) {
[16:59:35.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.389]                         if (muffled) 
[16:59:35.389]                           invokeRestart("muffleMessage")
[16:59:35.389]                       }
[16:59:35.389]                       else if (inherits(cond, "warning")) {
[16:59:35.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.389]                         if (muffled) 
[16:59:35.389]                           invokeRestart("muffleWarning")
[16:59:35.389]                       }
[16:59:35.389]                       else if (inherits(cond, "condition")) {
[16:59:35.389]                         if (!is.null(pattern)) {
[16:59:35.389]                           computeRestarts <- base::computeRestarts
[16:59:35.389]                           grepl <- base::grepl
[16:59:35.389]                           restarts <- computeRestarts(cond)
[16:59:35.389]                           for (restart in restarts) {
[16:59:35.389]                             name <- restart$name
[16:59:35.389]                             if (is.null(name)) 
[16:59:35.389]                               next
[16:59:35.389]                             if (!grepl(pattern, name)) 
[16:59:35.389]                               next
[16:59:35.389]                             invokeRestart(restart)
[16:59:35.389]                             muffled <- TRUE
[16:59:35.389]                             break
[16:59:35.389]                           }
[16:59:35.389]                         }
[16:59:35.389]                       }
[16:59:35.389]                       invisible(muffled)
[16:59:35.389]                     }
[16:59:35.389]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.389]                   }
[16:59:35.389]                 }
[16:59:35.389]                 else {
[16:59:35.389]                   if (TRUE) {
[16:59:35.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.389]                     {
[16:59:35.389]                       inherits <- base::inherits
[16:59:35.389]                       invokeRestart <- base::invokeRestart
[16:59:35.389]                       is.null <- base::is.null
[16:59:35.389]                       muffled <- FALSE
[16:59:35.389]                       if (inherits(cond, "message")) {
[16:59:35.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.389]                         if (muffled) 
[16:59:35.389]                           invokeRestart("muffleMessage")
[16:59:35.389]                       }
[16:59:35.389]                       else if (inherits(cond, "warning")) {
[16:59:35.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.389]                         if (muffled) 
[16:59:35.389]                           invokeRestart("muffleWarning")
[16:59:35.389]                       }
[16:59:35.389]                       else if (inherits(cond, "condition")) {
[16:59:35.389]                         if (!is.null(pattern)) {
[16:59:35.389]                           computeRestarts <- base::computeRestarts
[16:59:35.389]                           grepl <- base::grepl
[16:59:35.389]                           restarts <- computeRestarts(cond)
[16:59:35.389]                           for (restart in restarts) {
[16:59:35.389]                             name <- restart$name
[16:59:35.389]                             if (is.null(name)) 
[16:59:35.389]                               next
[16:59:35.389]                             if (!grepl(pattern, name)) 
[16:59:35.389]                               next
[16:59:35.389]                             invokeRestart(restart)
[16:59:35.389]                             muffled <- TRUE
[16:59:35.389]                             break
[16:59:35.389]                           }
[16:59:35.389]                         }
[16:59:35.389]                       }
[16:59:35.389]                       invisible(muffled)
[16:59:35.389]                     }
[16:59:35.389]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.389]                   }
[16:59:35.389]                 }
[16:59:35.389]             }
[16:59:35.389]         }))
[16:59:35.389]     }, error = function(ex) {
[16:59:35.389]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.389]                 ...future.rng), started = ...future.startTime, 
[16:59:35.389]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.389]             version = "1.8"), class = "FutureResult")
[16:59:35.389]     }, finally = {
[16:59:35.389]         if (!identical(...future.workdir, getwd())) 
[16:59:35.389]             setwd(...future.workdir)
[16:59:35.389]         {
[16:59:35.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.389]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.389]             }
[16:59:35.389]             base::options(...future.oldOptions)
[16:59:35.389]             if (.Platform$OS.type == "windows") {
[16:59:35.389]                 old_names <- names(...future.oldEnvVars)
[16:59:35.389]                 envs <- base::Sys.getenv()
[16:59:35.389]                 names <- names(envs)
[16:59:35.389]                 common <- intersect(names, old_names)
[16:59:35.389]                 added <- setdiff(names, old_names)
[16:59:35.389]                 removed <- setdiff(old_names, names)
[16:59:35.389]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.389]                   envs[common]]
[16:59:35.389]                 NAMES <- toupper(changed)
[16:59:35.389]                 args <- list()
[16:59:35.389]                 for (kk in seq_along(NAMES)) {
[16:59:35.389]                   name <- changed[[kk]]
[16:59:35.389]                   NAME <- NAMES[[kk]]
[16:59:35.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.389]                     next
[16:59:35.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.389]                 }
[16:59:35.389]                 NAMES <- toupper(added)
[16:59:35.389]                 for (kk in seq_along(NAMES)) {
[16:59:35.389]                   name <- added[[kk]]
[16:59:35.389]                   NAME <- NAMES[[kk]]
[16:59:35.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.389]                     next
[16:59:35.389]                   args[[name]] <- ""
[16:59:35.389]                 }
[16:59:35.389]                 NAMES <- toupper(removed)
[16:59:35.389]                 for (kk in seq_along(NAMES)) {
[16:59:35.389]                   name <- removed[[kk]]
[16:59:35.389]                   NAME <- NAMES[[kk]]
[16:59:35.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.389]                     next
[16:59:35.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.389]                 }
[16:59:35.389]                 if (length(args) > 0) 
[16:59:35.389]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.389]             }
[16:59:35.389]             else {
[16:59:35.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.389]             }
[16:59:35.389]             {
[16:59:35.389]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.389]                   0L) {
[16:59:35.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.389]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.389]                   base::options(opts)
[16:59:35.389]                 }
[16:59:35.389]                 {
[16:59:35.389]                   {
[16:59:35.389]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.389]                     NULL
[16:59:35.389]                   }
[16:59:35.389]                   options(future.plan = NULL)
[16:59:35.389]                   if (is.na(NA_character_)) 
[16:59:35.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.389]                     .init = FALSE)
[16:59:35.389]                 }
[16:59:35.389]             }
[16:59:35.389]         }
[16:59:35.389]     })
[16:59:35.389]     if (TRUE) {
[16:59:35.389]         base::sink(type = "output", split = FALSE)
[16:59:35.389]         if (TRUE) {
[16:59:35.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.389]         }
[16:59:35.389]         else {
[16:59:35.389]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.389]         }
[16:59:35.389]         base::close(...future.stdout)
[16:59:35.389]         ...future.stdout <- NULL
[16:59:35.389]     }
[16:59:35.389]     ...future.result$conditions <- ...future.conditions
[16:59:35.389]     ...future.result$finished <- base::Sys.time()
[16:59:35.389]     ...future.result
[16:59:35.389] }
[16:59:35.392] assign_globals() ...
[16:59:35.392] List of 5
[16:59:35.392]  $ ...future.FUN            :function (x, ...)  
[16:59:35.392]  $ future.call.arguments    :List of 1
[16:59:35.392]   ..$ singular.ok: logi FALSE
[16:59:35.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.392]  $ ...future.elements_ii    :List of 1
[16:59:35.392]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.392]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.392]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.392]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.392]  $ ...future.seeds_ii       : NULL
[16:59:35.392]  $ ...future.globals.maxSize: NULL
[16:59:35.392]  - attr(*, "where")=List of 5
[16:59:35.392]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.392]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.392]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.392]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.392]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.392]  - attr(*, "resolved")= logi FALSE
[16:59:35.392]  - attr(*, "total_size")= num 5384
[16:59:35.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.392]  - attr(*, "already-done")= logi TRUE
[16:59:35.399] - reassign environment for ‘...future.FUN’
[16:59:35.399] - copied ‘...future.FUN’ to environment
[16:59:35.399] - copied ‘future.call.arguments’ to environment
[16:59:35.399] - copied ‘...future.elements_ii’ to environment
[16:59:35.399] - copied ‘...future.seeds_ii’ to environment
[16:59:35.399] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.399] assign_globals() ... done
[16:59:35.399] requestCore(): workers = 2
[16:59:35.402] MulticoreFuture started
[16:59:35.402] - Launch lazy future ... done
[16:59:35.402] run() for ‘MulticoreFuture’ ... done
[16:59:35.403] Created future:
[16:59:35.403] plan(): Setting new future strategy stack:
[16:59:35.403] List of future strategies:
[16:59:35.403] 1. sequential:
[16:59:35.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.403]    - tweaked: FALSE
[16:59:35.403]    - call: NULL
[16:59:35.404] plan(): nbrOfWorkers() = 1
[16:59:35.409] plan(): Setting new future strategy stack:
[16:59:35.409] List of future strategies:
[16:59:35.409] 1. multicore:
[16:59:35.409]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.409]    - tweaked: FALSE
[16:59:35.409]    - call: plan(strategy)
[16:59:35.414] plan(): nbrOfWorkers() = 2
[16:59:35.403] MulticoreFuture:
[16:59:35.403] Label: ‘future_by-1’
[16:59:35.403] Expression:
[16:59:35.403] {
[16:59:35.403]     do.call(function(...) {
[16:59:35.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.403]             on.exit(options(oopts), add = TRUE)
[16:59:35.403]         }
[16:59:35.403]         {
[16:59:35.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.403]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.403]             })
[16:59:35.403]         }
[16:59:35.403]     }, args = future.call.arguments)
[16:59:35.403] }
[16:59:35.403] Lazy evaluation: FALSE
[16:59:35.403] Asynchronous evaluation: TRUE
[16:59:35.403] Local evaluation: TRUE
[16:59:35.403] Environment: R_GlobalEnv
[16:59:35.403] Capture standard output: TRUE
[16:59:35.403] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.403] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.403] Packages: 1 packages (‘stats’)
[16:59:35.403] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.403] Resolved: TRUE
[16:59:35.403] Value: <not collected>
[16:59:35.403] Conditions captured: <none>
[16:59:35.403] Early signaling: FALSE
[16:59:35.403] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.403] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.416] Chunk #1 of 2 ... DONE
[16:59:35.416] Chunk #2 of 2 ...
[16:59:35.416]  - Finding globals in 'X' for chunk #2 ...
[16:59:35.416] getGlobalsAndPackages() ...
[16:59:35.417] Searching for globals...
[16:59:35.417] 
[16:59:35.418] Searching for globals ... DONE
[16:59:35.418] - globals: [0] <none>
[16:59:35.418] getGlobalsAndPackages() ... DONE
[16:59:35.418]    + additional globals found: [n=0] 
[16:59:35.418]    + additional namespaces needed: [n=0] 
[16:59:35.418]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:35.418]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.418]  - seeds: <none>
[16:59:35.418]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.419] getGlobalsAndPackages() ...
[16:59:35.419] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.419] Resolving globals: FALSE
[16:59:35.419] Tweak future expression to call with '...' arguments ...
[16:59:35.419] {
[16:59:35.419]     do.call(function(...) {
[16:59:35.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.419]             on.exit(options(oopts), add = TRUE)
[16:59:35.419]         }
[16:59:35.419]         {
[16:59:35.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.419]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.419]             })
[16:59:35.419]         }
[16:59:35.419]     }, args = future.call.arguments)
[16:59:35.419] }
[16:59:35.420] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.420] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.420] 
[16:59:35.421] getGlobalsAndPackages() ... DONE
[16:59:35.421] run() for ‘Future’ ...
[16:59:35.421] - state: ‘created’
[16:59:35.422] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.426] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.427]   - Field: ‘label’
[16:59:35.427]   - Field: ‘local’
[16:59:35.427]   - Field: ‘owner’
[16:59:35.427]   - Field: ‘envir’
[16:59:35.427]   - Field: ‘workers’
[16:59:35.427]   - Field: ‘packages’
[16:59:35.427]   - Field: ‘gc’
[16:59:35.431]   - Field: ‘job’
[16:59:35.431]   - Field: ‘conditions’
[16:59:35.431]   - Field: ‘expr’
[16:59:35.432]   - Field: ‘uuid’
[16:59:35.432]   - Field: ‘seed’
[16:59:35.432]   - Field: ‘version’
[16:59:35.433]   - Field: ‘result’
[16:59:35.433]   - Field: ‘asynchronous’
[16:59:35.433]   - Field: ‘calls’
[16:59:35.433]   - Field: ‘globals’
[16:59:35.434]   - Field: ‘stdout’
[16:59:35.434]   - Field: ‘earlySignal’
[16:59:35.434]   - Field: ‘lazy’
[16:59:35.434]   - Field: ‘state’
[16:59:35.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.435] - Launch lazy future ...
[16:59:35.436] Packages needed by the future expression (n = 1): ‘stats’
[16:59:35.436] Packages needed by future strategies (n = 0): <none>
[16:59:35.437] {
[16:59:35.437]     {
[16:59:35.437]         {
[16:59:35.437]             ...future.startTime <- base::Sys.time()
[16:59:35.437]             {
[16:59:35.437]                 {
[16:59:35.437]                   {
[16:59:35.437]                     {
[16:59:35.437]                       {
[16:59:35.437]                         base::local({
[16:59:35.437]                           has_future <- base::requireNamespace("future", 
[16:59:35.437]                             quietly = TRUE)
[16:59:35.437]                           if (has_future) {
[16:59:35.437]                             ns <- base::getNamespace("future")
[16:59:35.437]                             version <- ns[[".package"]][["version"]]
[16:59:35.437]                             if (is.null(version)) 
[16:59:35.437]                               version <- utils::packageVersion("future")
[16:59:35.437]                           }
[16:59:35.437]                           else {
[16:59:35.437]                             version <- NULL
[16:59:35.437]                           }
[16:59:35.437]                           if (!has_future || version < "1.8.0") {
[16:59:35.437]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.437]                               "", base::R.version$version.string), 
[16:59:35.437]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:35.437]                                 base::R.version$platform, 8 * 
[16:59:35.437]                                   base::.Machine$sizeof.pointer), 
[16:59:35.437]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.437]                                 "release", "version")], collapse = " "), 
[16:59:35.437]                               hostname = base::Sys.info()[["nodename"]])
[16:59:35.437]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.437]                               info)
[16:59:35.437]                             info <- base::paste(info, collapse = "; ")
[16:59:35.437]                             if (!has_future) {
[16:59:35.437]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.437]                                 info)
[16:59:35.437]                             }
[16:59:35.437]                             else {
[16:59:35.437]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.437]                                 info, version)
[16:59:35.437]                             }
[16:59:35.437]                             base::stop(msg)
[16:59:35.437]                           }
[16:59:35.437]                         })
[16:59:35.437]                       }
[16:59:35.437]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.437]                       base::options(mc.cores = 1L)
[16:59:35.437]                     }
[16:59:35.437]                     base::local({
[16:59:35.437]                       for (pkg in "stats") {
[16:59:35.437]                         base::loadNamespace(pkg)
[16:59:35.437]                         base::library(pkg, character.only = TRUE)
[16:59:35.437]                       }
[16:59:35.437]                     })
[16:59:35.437]                   }
[16:59:35.437]                   ...future.strategy.old <- future::plan("list")
[16:59:35.437]                   options(future.plan = NULL)
[16:59:35.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.437]                 }
[16:59:35.437]                 ...future.workdir <- getwd()
[16:59:35.437]             }
[16:59:35.437]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.437]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.437]         }
[16:59:35.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.437]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.437]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.437]             base::names(...future.oldOptions))
[16:59:35.437]     }
[16:59:35.437]     if (FALSE) {
[16:59:35.437]     }
[16:59:35.437]     else {
[16:59:35.437]         if (TRUE) {
[16:59:35.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.437]                 open = "w")
[16:59:35.437]         }
[16:59:35.437]         else {
[16:59:35.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.437]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.437]         }
[16:59:35.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.437]             base::sink(type = "output", split = FALSE)
[16:59:35.437]             base::close(...future.stdout)
[16:59:35.437]         }, add = TRUE)
[16:59:35.437]     }
[16:59:35.437]     ...future.frame <- base::sys.nframe()
[16:59:35.437]     ...future.conditions <- base::list()
[16:59:35.437]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.437]     if (FALSE) {
[16:59:35.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.437]     }
[16:59:35.437]     ...future.result <- base::tryCatch({
[16:59:35.437]         base::withCallingHandlers({
[16:59:35.437]             ...future.value <- base::withVisible(base::local({
[16:59:35.437]                 withCallingHandlers({
[16:59:35.437]                   {
[16:59:35.437]                     do.call(function(...) {
[16:59:35.437]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.437]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.437]                         ...future.globals.maxSize)) {
[16:59:35.437]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.437]                         on.exit(options(oopts), add = TRUE)
[16:59:35.437]                       }
[16:59:35.437]                       {
[16:59:35.437]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.437]                           FUN = function(jj) {
[16:59:35.437]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.437]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.437]                           })
[16:59:35.437]                       }
[16:59:35.437]                     }, args = future.call.arguments)
[16:59:35.437]                   }
[16:59:35.437]                 }, immediateCondition = function(cond) {
[16:59:35.437]                   save_rds <- function (object, pathname, ...) 
[16:59:35.437]                   {
[16:59:35.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.437]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.437]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.437]                         fi_tmp[["mtime"]])
[16:59:35.437]                     }
[16:59:35.437]                     tryCatch({
[16:59:35.437]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.437]                     }, error = function(ex) {
[16:59:35.437]                       msg <- conditionMessage(ex)
[16:59:35.437]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.437]                         fi_tmp[["mtime"]], msg)
[16:59:35.437]                       ex$message <- msg
[16:59:35.437]                       stop(ex)
[16:59:35.437]                     })
[16:59:35.437]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.437]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.437]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.437]                       fi <- file.info(pathname)
[16:59:35.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.437]                         fi[["size"]], fi[["mtime"]])
[16:59:35.437]                       stop(msg)
[16:59:35.437]                     }
[16:59:35.437]                     invisible(pathname)
[16:59:35.437]                   }
[16:59:35.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.437]                     rootPath = tempdir()) 
[16:59:35.437]                   {
[16:59:35.437]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.437]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.437]                       tmpdir = path, fileext = ".rds")
[16:59:35.437]                     save_rds(obj, file)
[16:59:35.437]                   }
[16:59:35.437]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.437]                   {
[16:59:35.437]                     inherits <- base::inherits
[16:59:35.437]                     invokeRestart <- base::invokeRestart
[16:59:35.437]                     is.null <- base::is.null
[16:59:35.437]                     muffled <- FALSE
[16:59:35.437]                     if (inherits(cond, "message")) {
[16:59:35.437]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.437]                       if (muffled) 
[16:59:35.437]                         invokeRestart("muffleMessage")
[16:59:35.437]                     }
[16:59:35.437]                     else if (inherits(cond, "warning")) {
[16:59:35.437]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.437]                       if (muffled) 
[16:59:35.437]                         invokeRestart("muffleWarning")
[16:59:35.437]                     }
[16:59:35.437]                     else if (inherits(cond, "condition")) {
[16:59:35.437]                       if (!is.null(pattern)) {
[16:59:35.437]                         computeRestarts <- base::computeRestarts
[16:59:35.437]                         grepl <- base::grepl
[16:59:35.437]                         restarts <- computeRestarts(cond)
[16:59:35.437]                         for (restart in restarts) {
[16:59:35.437]                           name <- restart$name
[16:59:35.437]                           if (is.null(name)) 
[16:59:35.437]                             next
[16:59:35.437]                           if (!grepl(pattern, name)) 
[16:59:35.437]                             next
[16:59:35.437]                           invokeRestart(restart)
[16:59:35.437]                           muffled <- TRUE
[16:59:35.437]                           break
[16:59:35.437]                         }
[16:59:35.437]                       }
[16:59:35.437]                     }
[16:59:35.437]                     invisible(muffled)
[16:59:35.437]                   }
[16:59:35.437]                   muffleCondition(cond)
[16:59:35.437]                 })
[16:59:35.437]             }))
[16:59:35.437]             future::FutureResult(value = ...future.value$value, 
[16:59:35.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.437]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.437]                     ...future.globalenv.names))
[16:59:35.437]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.437]         }, condition = base::local({
[16:59:35.437]             c <- base::c
[16:59:35.437]             inherits <- base::inherits
[16:59:35.437]             invokeRestart <- base::invokeRestart
[16:59:35.437]             length <- base::length
[16:59:35.437]             list <- base::list
[16:59:35.437]             seq.int <- base::seq.int
[16:59:35.437]             signalCondition <- base::signalCondition
[16:59:35.437]             sys.calls <- base::sys.calls
[16:59:35.437]             `[[` <- base::`[[`
[16:59:35.437]             `+` <- base::`+`
[16:59:35.437]             `<<-` <- base::`<<-`
[16:59:35.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.437]                   3L)]
[16:59:35.437]             }
[16:59:35.437]             function(cond) {
[16:59:35.437]                 is_error <- inherits(cond, "error")
[16:59:35.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.437]                   NULL)
[16:59:35.437]                 if (is_error) {
[16:59:35.437]                   sessionInformation <- function() {
[16:59:35.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.437]                       search = base::search(), system = base::Sys.info())
[16:59:35.437]                   }
[16:59:35.437]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.437]                     cond$call), session = sessionInformation(), 
[16:59:35.437]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.437]                   signalCondition(cond)
[16:59:35.437]                 }
[16:59:35.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.437]                 "immediateCondition"))) {
[16:59:35.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.437]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.437]                   if (TRUE && !signal) {
[16:59:35.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.437]                     {
[16:59:35.437]                       inherits <- base::inherits
[16:59:35.437]                       invokeRestart <- base::invokeRestart
[16:59:35.437]                       is.null <- base::is.null
[16:59:35.437]                       muffled <- FALSE
[16:59:35.437]                       if (inherits(cond, "message")) {
[16:59:35.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.437]                         if (muffled) 
[16:59:35.437]                           invokeRestart("muffleMessage")
[16:59:35.437]                       }
[16:59:35.437]                       else if (inherits(cond, "warning")) {
[16:59:35.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.437]                         if (muffled) 
[16:59:35.437]                           invokeRestart("muffleWarning")
[16:59:35.437]                       }
[16:59:35.437]                       else if (inherits(cond, "condition")) {
[16:59:35.437]                         if (!is.null(pattern)) {
[16:59:35.437]                           computeRestarts <- base::computeRestarts
[16:59:35.437]                           grepl <- base::grepl
[16:59:35.437]                           restarts <- computeRestarts(cond)
[16:59:35.437]                           for (restart in restarts) {
[16:59:35.437]                             name <- restart$name
[16:59:35.437]                             if (is.null(name)) 
[16:59:35.437]                               next
[16:59:35.437]                             if (!grepl(pattern, name)) 
[16:59:35.437]                               next
[16:59:35.437]                             invokeRestart(restart)
[16:59:35.437]                             muffled <- TRUE
[16:59:35.437]                             break
[16:59:35.437]                           }
[16:59:35.437]                         }
[16:59:35.437]                       }
[16:59:35.437]                       invisible(muffled)
[16:59:35.437]                     }
[16:59:35.437]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.437]                   }
[16:59:35.437]                 }
[16:59:35.437]                 else {
[16:59:35.437]                   if (TRUE) {
[16:59:35.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.437]                     {
[16:59:35.437]                       inherits <- base::inherits
[16:59:35.437]                       invokeRestart <- base::invokeRestart
[16:59:35.437]                       is.null <- base::is.null
[16:59:35.437]                       muffled <- FALSE
[16:59:35.437]                       if (inherits(cond, "message")) {
[16:59:35.437]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.437]                         if (muffled) 
[16:59:35.437]                           invokeRestart("muffleMessage")
[16:59:35.437]                       }
[16:59:35.437]                       else if (inherits(cond, "warning")) {
[16:59:35.437]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.437]                         if (muffled) 
[16:59:35.437]                           invokeRestart("muffleWarning")
[16:59:35.437]                       }
[16:59:35.437]                       else if (inherits(cond, "condition")) {
[16:59:35.437]                         if (!is.null(pattern)) {
[16:59:35.437]                           computeRestarts <- base::computeRestarts
[16:59:35.437]                           grepl <- base::grepl
[16:59:35.437]                           restarts <- computeRestarts(cond)
[16:59:35.437]                           for (restart in restarts) {
[16:59:35.437]                             name <- restart$name
[16:59:35.437]                             if (is.null(name)) 
[16:59:35.437]                               next
[16:59:35.437]                             if (!grepl(pattern, name)) 
[16:59:35.437]                               next
[16:59:35.437]                             invokeRestart(restart)
[16:59:35.437]                             muffled <- TRUE
[16:59:35.437]                             break
[16:59:35.437]                           }
[16:59:35.437]                         }
[16:59:35.437]                       }
[16:59:35.437]                       invisible(muffled)
[16:59:35.437]                     }
[16:59:35.437]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.437]                   }
[16:59:35.437]                 }
[16:59:35.437]             }
[16:59:35.437]         }))
[16:59:35.437]     }, error = function(ex) {
[16:59:35.437]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.437]                 ...future.rng), started = ...future.startTime, 
[16:59:35.437]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.437]             version = "1.8"), class = "FutureResult")
[16:59:35.437]     }, finally = {
[16:59:35.437]         if (!identical(...future.workdir, getwd())) 
[16:59:35.437]             setwd(...future.workdir)
[16:59:35.437]         {
[16:59:35.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.437]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.437]             }
[16:59:35.437]             base::options(...future.oldOptions)
[16:59:35.437]             if (.Platform$OS.type == "windows") {
[16:59:35.437]                 old_names <- names(...future.oldEnvVars)
[16:59:35.437]                 envs <- base::Sys.getenv()
[16:59:35.437]                 names <- names(envs)
[16:59:35.437]                 common <- intersect(names, old_names)
[16:59:35.437]                 added <- setdiff(names, old_names)
[16:59:35.437]                 removed <- setdiff(old_names, names)
[16:59:35.437]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.437]                   envs[common]]
[16:59:35.437]                 NAMES <- toupper(changed)
[16:59:35.437]                 args <- list()
[16:59:35.437]                 for (kk in seq_along(NAMES)) {
[16:59:35.437]                   name <- changed[[kk]]
[16:59:35.437]                   NAME <- NAMES[[kk]]
[16:59:35.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.437]                     next
[16:59:35.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.437]                 }
[16:59:35.437]                 NAMES <- toupper(added)
[16:59:35.437]                 for (kk in seq_along(NAMES)) {
[16:59:35.437]                   name <- added[[kk]]
[16:59:35.437]                   NAME <- NAMES[[kk]]
[16:59:35.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.437]                     next
[16:59:35.437]                   args[[name]] <- ""
[16:59:35.437]                 }
[16:59:35.437]                 NAMES <- toupper(removed)
[16:59:35.437]                 for (kk in seq_along(NAMES)) {
[16:59:35.437]                   name <- removed[[kk]]
[16:59:35.437]                   NAME <- NAMES[[kk]]
[16:59:35.437]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.437]                     next
[16:59:35.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.437]                 }
[16:59:35.437]                 if (length(args) > 0) 
[16:59:35.437]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.437]             }
[16:59:35.437]             else {
[16:59:35.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.437]             }
[16:59:35.437]             {
[16:59:35.437]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.437]                   0L) {
[16:59:35.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.437]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.437]                   base::options(opts)
[16:59:35.437]                 }
[16:59:35.437]                 {
[16:59:35.437]                   {
[16:59:35.437]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.437]                     NULL
[16:59:35.437]                   }
[16:59:35.437]                   options(future.plan = NULL)
[16:59:35.437]                   if (is.na(NA_character_)) 
[16:59:35.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.437]                     .init = FALSE)
[16:59:35.437]                 }
[16:59:35.437]             }
[16:59:35.437]         }
[16:59:35.437]     })
[16:59:35.437]     if (TRUE) {
[16:59:35.437]         base::sink(type = "output", split = FALSE)
[16:59:35.437]         if (TRUE) {
[16:59:35.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.437]         }
[16:59:35.437]         else {
[16:59:35.437]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.437]         }
[16:59:35.437]         base::close(...future.stdout)
[16:59:35.437]         ...future.stdout <- NULL
[16:59:35.437]     }
[16:59:35.437]     ...future.result$conditions <- ...future.conditions
[16:59:35.437]     ...future.result$finished <- base::Sys.time()
[16:59:35.437]     ...future.result
[16:59:35.437] }
[16:59:35.440] assign_globals() ...
[16:59:35.440] List of 5
[16:59:35.440]  $ ...future.FUN            :function (x, ...)  
[16:59:35.440]  $ future.call.arguments    :List of 1
[16:59:35.440]   ..$ singular.ok: logi FALSE
[16:59:35.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.440]  $ ...future.elements_ii    :List of 2
[16:59:35.440]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.440]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.440]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.440]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:35.440]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.440]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.440]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.440]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:35.440]  $ ...future.seeds_ii       : NULL
[16:59:35.440]  $ ...future.globals.maxSize: NULL
[16:59:35.440]  - attr(*, "where")=List of 5
[16:59:35.440]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.440]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.440]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.440]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.440]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.440]  - attr(*, "resolved")= logi FALSE
[16:59:35.440]  - attr(*, "total_size")= num 5384
[16:59:35.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.440]  - attr(*, "already-done")= logi TRUE
[16:59:35.451] - reassign environment for ‘...future.FUN’
[16:59:35.451] - copied ‘...future.FUN’ to environment
[16:59:35.451] - copied ‘future.call.arguments’ to environment
[16:59:35.451] - copied ‘...future.elements_ii’ to environment
[16:59:35.452] - copied ‘...future.seeds_ii’ to environment
[16:59:35.452] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.452] assign_globals() ... done
[16:59:35.452] requestCore(): workers = 2
[16:59:35.454] MulticoreFuture started
[16:59:35.454] - Launch lazy future ... done
[16:59:35.455] run() for ‘MulticoreFuture’ ... done
[16:59:35.455] Created future:
[16:59:35.456] plan(): Setting new future strategy stack:
[16:59:35.456] List of future strategies:
[16:59:35.456] 1. sequential:
[16:59:35.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.456]    - tweaked: FALSE
[16:59:35.456]    - call: NULL
[16:59:35.457] plan(): nbrOfWorkers() = 1
[16:59:35.462] plan(): Setting new future strategy stack:
[16:59:35.462] List of future strategies:
[16:59:35.462] 1. multicore:
[16:59:35.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.462]    - tweaked: FALSE
[16:59:35.462]    - call: plan(strategy)
[16:59:35.467] plan(): nbrOfWorkers() = 2
[16:59:35.455] MulticoreFuture:
[16:59:35.455] Label: ‘future_by-2’
[16:59:35.455] Expression:
[16:59:35.455] {
[16:59:35.455]     do.call(function(...) {
[16:59:35.455]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.455]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.455]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.455]             on.exit(options(oopts), add = TRUE)
[16:59:35.455]         }
[16:59:35.455]         {
[16:59:35.455]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.455]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.455]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.455]             })
[16:59:35.455]         }
[16:59:35.455]     }, args = future.call.arguments)
[16:59:35.455] }
[16:59:35.455] Lazy evaluation: FALSE
[16:59:35.455] Asynchronous evaluation: TRUE
[16:59:35.455] Local evaluation: TRUE
[16:59:35.455] Environment: R_GlobalEnv
[16:59:35.455] Capture standard output: TRUE
[16:59:35.455] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.455] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.455] Packages: 1 packages (‘stats’)
[16:59:35.455] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.455] Resolved: FALSE
[16:59:35.455] Value: <not collected>
[16:59:35.455] Conditions captured: <none>
[16:59:35.455] Early signaling: FALSE
[16:59:35.455] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.455] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.468] Chunk #2 of 2 ... DONE
[16:59:35.469] Launching 2 futures (chunks) ... DONE
[16:59:35.469] Resolving 2 futures (chunks) ...
[16:59:35.469] resolve() on list ...
[16:59:35.469]  recursive: 0
[16:59:35.469]  length: 2
[16:59:35.469] 
[16:59:35.470] Future #1
[16:59:35.470] result() for MulticoreFuture ...
[16:59:35.472] result() for MulticoreFuture ...
[16:59:35.472] result() for MulticoreFuture ... done
[16:59:35.472] result() for MulticoreFuture ... done
[16:59:35.472] result() for MulticoreFuture ...
[16:59:35.472] result() for MulticoreFuture ... done
[16:59:35.472] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:35.473] - nx: 2
[16:59:35.473] - relay: TRUE
[16:59:35.473] - stdout: TRUE
[16:59:35.473] - signal: TRUE
[16:59:35.473] - resignal: FALSE
[16:59:35.473] - force: TRUE
[16:59:35.474] - relayed: [n=2] FALSE, FALSE
[16:59:35.474] - queued futures: [n=2] FALSE, FALSE
[16:59:35.474]  - until=1
[16:59:35.474]  - relaying element #1
[16:59:35.474] result() for MulticoreFuture ...
[16:59:35.474] result() for MulticoreFuture ... done
[16:59:35.475] result() for MulticoreFuture ...
[16:59:35.475] result() for MulticoreFuture ... done
[16:59:35.475] result() for MulticoreFuture ...
[16:59:35.475] result() for MulticoreFuture ... done
[16:59:35.475] result() for MulticoreFuture ...
[16:59:35.476] result() for MulticoreFuture ... done
[16:59:35.476] - relayed: [n=2] TRUE, FALSE
[16:59:35.476] - queued futures: [n=2] TRUE, FALSE
[16:59:35.476] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:35.480]  length: 1 (resolved future 1)
[16:59:35.480] Future #2
[16:59:35.481] result() for MulticoreFuture ...
[16:59:35.483] result() for MulticoreFuture ...
[16:59:35.484] result() for MulticoreFuture ... done
[16:59:35.484] result() for MulticoreFuture ... done
[16:59:35.484] result() for MulticoreFuture ...
[16:59:35.485] result() for MulticoreFuture ... done
[16:59:35.485] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:35.485] - nx: 2
[16:59:35.485] - relay: TRUE
[16:59:35.486] - stdout: TRUE
[16:59:35.486] - signal: TRUE
[16:59:35.486] - resignal: FALSE
[16:59:35.486] - force: TRUE
[16:59:35.487] - relayed: [n=2] TRUE, FALSE
[16:59:35.487] - queued futures: [n=2] TRUE, FALSE
[16:59:35.487]  - until=2
[16:59:35.487]  - relaying element #2
[16:59:35.487] result() for MulticoreFuture ...
[16:59:35.487] result() for MulticoreFuture ... done
[16:59:35.488] result() for MulticoreFuture ...
[16:59:35.488] result() for MulticoreFuture ... done
[16:59:35.488] result() for MulticoreFuture ...
[16:59:35.488] result() for MulticoreFuture ... done
[16:59:35.488] result() for MulticoreFuture ...
[16:59:35.488] result() for MulticoreFuture ... done
[16:59:35.489] - relayed: [n=2] TRUE, TRUE
[16:59:35.489] - queued futures: [n=2] TRUE, TRUE
[16:59:35.489] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:35.489]  length: 0 (resolved future 2)
[16:59:35.489] Relaying remaining futures
[16:59:35.489] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.489] - nx: 2
[16:59:35.489] - relay: TRUE
[16:59:35.490] - stdout: TRUE
[16:59:35.490] - signal: TRUE
[16:59:35.490] - resignal: FALSE
[16:59:35.490] - force: TRUE
[16:59:35.490] - relayed: [n=2] TRUE, TRUE
[16:59:35.490] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:35.490] - relayed: [n=2] TRUE, TRUE
[16:59:35.490] - queued futures: [n=2] TRUE, TRUE
[16:59:35.490] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.491] resolve() on list ... DONE
[16:59:35.491] result() for MulticoreFuture ...
[16:59:35.491] result() for MulticoreFuture ... done
[16:59:35.491] result() for MulticoreFuture ...
[16:59:35.491] result() for MulticoreFuture ... done
[16:59:35.491] result() for MulticoreFuture ...
[16:59:35.491] result() for MulticoreFuture ... done
[16:59:35.491] result() for MulticoreFuture ...
[16:59:35.492] result() for MulticoreFuture ... done
[16:59:35.492]  - Number of value chunks collected: 2
[16:59:35.492] Resolving 2 futures (chunks) ... DONE
[16:59:35.492] Reducing values from 2 chunks ...
[16:59:35.492]  - Number of values collected after concatenation: 3
[16:59:35.492]  - Number of values expected: 3
[16:59:35.492] Reducing values from 2 chunks ... DONE
[16:59:35.492] future_lapply() ... DONE
[16:59:35.492] future_by_internal() ... DONE
[16:59:35.497] future_by_internal() ...
[16:59:35.498] future_lapply() ...
[16:59:35.503] Number of chunks: 2
[16:59:35.503] getGlobalsAndPackagesXApply() ...
[16:59:35.503]  - future.globals: TRUE
[16:59:35.503] getGlobalsAndPackages() ...
[16:59:35.503] Searching for globals...
[16:59:35.510] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:35.510] Searching for globals ... DONE
[16:59:35.510] Resolving globals: FALSE
[16:59:35.511] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:59:35.511] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:59:35.511] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:35.512] - packages: [1] ‘stats’
[16:59:35.512] getGlobalsAndPackages() ... DONE
[16:59:35.512]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:35.512]  - needed namespaces: [n=1] ‘stats’
[16:59:35.512] Finding globals ... DONE
[16:59:35.512]  - use_args: TRUE
[16:59:35.512]  - Getting '...' globals ...
[16:59:35.513] resolve() on list ...
[16:59:35.513]  recursive: 0
[16:59:35.513]  length: 1
[16:59:35.513]  elements: ‘...’
[16:59:35.513]  length: 0 (resolved future 1)
[16:59:35.513] resolve() on list ... DONE
[16:59:35.513]    - '...' content: [n=0] 
[16:59:35.513] List of 1
[16:59:35.513]  $ ...: list()
[16:59:35.513]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.513]  - attr(*, "where")=List of 1
[16:59:35.513]   ..$ ...:<environment: 0x562052804850> 
[16:59:35.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.513]  - attr(*, "resolved")= logi TRUE
[16:59:35.513]  - attr(*, "total_size")= num NA
[16:59:35.517]  - Getting '...' globals ... DONE
[16:59:35.517] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:59:35.517] List of 4
[16:59:35.517]  $ ...future.FUN:function (x)  
[16:59:35.517]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:35.517]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.517]  $ ...          : list()
[16:59:35.517]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.517]  - attr(*, "where")=List of 4
[16:59:35.517]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.517]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:59:35.517]   ..$ wool         :<environment: R_EmptyEnv> 
[16:59:35.517]   ..$ ...          :<environment: 0x562052804850> 
[16:59:35.517]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.517]  - attr(*, "resolved")= logi FALSE
[16:59:35.517]  - attr(*, "total_size")= num 2320
[16:59:35.521] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:35.521] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.521] Number of futures (= number of chunks): 2
[16:59:35.521] Launching 2 futures (chunks) ...
[16:59:35.522] Chunk #1 of 2 ...
[16:59:35.522]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.522] getGlobalsAndPackages() ...
[16:59:35.522] Searching for globals...
[16:59:35.522] 
[16:59:35.522] Searching for globals ... DONE
[16:59:35.522] - globals: [0] <none>
[16:59:35.523] getGlobalsAndPackages() ... DONE
[16:59:35.523]    + additional globals found: [n=0] 
[16:59:35.523]    + additional namespaces needed: [n=0] 
[16:59:35.523]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.523]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.523]  - seeds: <none>
[16:59:35.523]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.523] getGlobalsAndPackages() ...
[16:59:35.523] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.523] Resolving globals: FALSE
[16:59:35.524] Tweak future expression to call with '...' arguments ...
[16:59:35.524] {
[16:59:35.524]     do.call(function(...) {
[16:59:35.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.524]             on.exit(options(oopts), add = TRUE)
[16:59:35.524]         }
[16:59:35.524]         {
[16:59:35.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.524]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.524]             })
[16:59:35.524]         }
[16:59:35.524]     }, args = future.call.arguments)
[16:59:35.524] }
[16:59:35.524] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.524] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.524] 
[16:59:35.525] getGlobalsAndPackages() ... DONE
[16:59:35.525] run() for ‘Future’ ...
[16:59:35.525] - state: ‘created’
[16:59:35.525] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.529] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.529] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.529]   - Field: ‘label’
[16:59:35.530]   - Field: ‘local’
[16:59:35.530]   - Field: ‘owner’
[16:59:35.530]   - Field: ‘envir’
[16:59:35.530]   - Field: ‘workers’
[16:59:35.530]   - Field: ‘packages’
[16:59:35.530]   - Field: ‘gc’
[16:59:35.530]   - Field: ‘job’
[16:59:35.530]   - Field: ‘conditions’
[16:59:35.530]   - Field: ‘expr’
[16:59:35.530]   - Field: ‘uuid’
[16:59:35.531]   - Field: ‘seed’
[16:59:35.531]   - Field: ‘version’
[16:59:35.531]   - Field: ‘result’
[16:59:35.531]   - Field: ‘asynchronous’
[16:59:35.531]   - Field: ‘calls’
[16:59:35.531]   - Field: ‘globals’
[16:59:35.531]   - Field: ‘stdout’
[16:59:35.531]   - Field: ‘earlySignal’
[16:59:35.531]   - Field: ‘lazy’
[16:59:35.531]   - Field: ‘state’
[16:59:35.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.532] - Launch lazy future ...
[16:59:35.532] Packages needed by the future expression (n = 1): ‘stats’
[16:59:35.532] Packages needed by future strategies (n = 0): <none>
[16:59:35.533] {
[16:59:35.533]     {
[16:59:35.533]         {
[16:59:35.533]             ...future.startTime <- base::Sys.time()
[16:59:35.533]             {
[16:59:35.533]                 {
[16:59:35.533]                   {
[16:59:35.533]                     {
[16:59:35.533]                       {
[16:59:35.533]                         base::local({
[16:59:35.533]                           has_future <- base::requireNamespace("future", 
[16:59:35.533]                             quietly = TRUE)
[16:59:35.533]                           if (has_future) {
[16:59:35.533]                             ns <- base::getNamespace("future")
[16:59:35.533]                             version <- ns[[".package"]][["version"]]
[16:59:35.533]                             if (is.null(version)) 
[16:59:35.533]                               version <- utils::packageVersion("future")
[16:59:35.533]                           }
[16:59:35.533]                           else {
[16:59:35.533]                             version <- NULL
[16:59:35.533]                           }
[16:59:35.533]                           if (!has_future || version < "1.8.0") {
[16:59:35.533]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.533]                               "", base::R.version$version.string), 
[16:59:35.533]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:35.533]                                 base::R.version$platform, 8 * 
[16:59:35.533]                                   base::.Machine$sizeof.pointer), 
[16:59:35.533]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.533]                                 "release", "version")], collapse = " "), 
[16:59:35.533]                               hostname = base::Sys.info()[["nodename"]])
[16:59:35.533]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.533]                               info)
[16:59:35.533]                             info <- base::paste(info, collapse = "; ")
[16:59:35.533]                             if (!has_future) {
[16:59:35.533]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.533]                                 info)
[16:59:35.533]                             }
[16:59:35.533]                             else {
[16:59:35.533]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.533]                                 info, version)
[16:59:35.533]                             }
[16:59:35.533]                             base::stop(msg)
[16:59:35.533]                           }
[16:59:35.533]                         })
[16:59:35.533]                       }
[16:59:35.533]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.533]                       base::options(mc.cores = 1L)
[16:59:35.533]                     }
[16:59:35.533]                     base::local({
[16:59:35.533]                       for (pkg in "stats") {
[16:59:35.533]                         base::loadNamespace(pkg)
[16:59:35.533]                         base::library(pkg, character.only = TRUE)
[16:59:35.533]                       }
[16:59:35.533]                     })
[16:59:35.533]                   }
[16:59:35.533]                   ...future.strategy.old <- future::plan("list")
[16:59:35.533]                   options(future.plan = NULL)
[16:59:35.533]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.533]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.533]                 }
[16:59:35.533]                 ...future.workdir <- getwd()
[16:59:35.533]             }
[16:59:35.533]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.533]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.533]         }
[16:59:35.533]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.533]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.533]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.533]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.533]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.533]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.533]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.533]             base::names(...future.oldOptions))
[16:59:35.533]     }
[16:59:35.533]     if (FALSE) {
[16:59:35.533]     }
[16:59:35.533]     else {
[16:59:35.533]         if (TRUE) {
[16:59:35.533]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.533]                 open = "w")
[16:59:35.533]         }
[16:59:35.533]         else {
[16:59:35.533]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.533]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.533]         }
[16:59:35.533]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.533]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.533]             base::sink(type = "output", split = FALSE)
[16:59:35.533]             base::close(...future.stdout)
[16:59:35.533]         }, add = TRUE)
[16:59:35.533]     }
[16:59:35.533]     ...future.frame <- base::sys.nframe()
[16:59:35.533]     ...future.conditions <- base::list()
[16:59:35.533]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.533]     if (FALSE) {
[16:59:35.533]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.533]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.533]     }
[16:59:35.533]     ...future.result <- base::tryCatch({
[16:59:35.533]         base::withCallingHandlers({
[16:59:35.533]             ...future.value <- base::withVisible(base::local({
[16:59:35.533]                 withCallingHandlers({
[16:59:35.533]                   {
[16:59:35.533]                     do.call(function(...) {
[16:59:35.533]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.533]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.533]                         ...future.globals.maxSize)) {
[16:59:35.533]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.533]                         on.exit(options(oopts), add = TRUE)
[16:59:35.533]                       }
[16:59:35.533]                       {
[16:59:35.533]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.533]                           FUN = function(jj) {
[16:59:35.533]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.533]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.533]                           })
[16:59:35.533]                       }
[16:59:35.533]                     }, args = future.call.arguments)
[16:59:35.533]                   }
[16:59:35.533]                 }, immediateCondition = function(cond) {
[16:59:35.533]                   save_rds <- function (object, pathname, ...) 
[16:59:35.533]                   {
[16:59:35.533]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.533]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.533]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.533]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.533]                         fi_tmp[["mtime"]])
[16:59:35.533]                     }
[16:59:35.533]                     tryCatch({
[16:59:35.533]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.533]                     }, error = function(ex) {
[16:59:35.533]                       msg <- conditionMessage(ex)
[16:59:35.533]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.533]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.533]                         fi_tmp[["mtime"]], msg)
[16:59:35.533]                       ex$message <- msg
[16:59:35.533]                       stop(ex)
[16:59:35.533]                     })
[16:59:35.533]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.533]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.533]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.533]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.533]                       fi <- file.info(pathname)
[16:59:35.533]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.533]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.533]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.533]                         fi[["size"]], fi[["mtime"]])
[16:59:35.533]                       stop(msg)
[16:59:35.533]                     }
[16:59:35.533]                     invisible(pathname)
[16:59:35.533]                   }
[16:59:35.533]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.533]                     rootPath = tempdir()) 
[16:59:35.533]                   {
[16:59:35.533]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.533]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.533]                       tmpdir = path, fileext = ".rds")
[16:59:35.533]                     save_rds(obj, file)
[16:59:35.533]                   }
[16:59:35.533]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.533]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.533]                   {
[16:59:35.533]                     inherits <- base::inherits
[16:59:35.533]                     invokeRestart <- base::invokeRestart
[16:59:35.533]                     is.null <- base::is.null
[16:59:35.533]                     muffled <- FALSE
[16:59:35.533]                     if (inherits(cond, "message")) {
[16:59:35.533]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.533]                       if (muffled) 
[16:59:35.533]                         invokeRestart("muffleMessage")
[16:59:35.533]                     }
[16:59:35.533]                     else if (inherits(cond, "warning")) {
[16:59:35.533]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.533]                       if (muffled) 
[16:59:35.533]                         invokeRestart("muffleWarning")
[16:59:35.533]                     }
[16:59:35.533]                     else if (inherits(cond, "condition")) {
[16:59:35.533]                       if (!is.null(pattern)) {
[16:59:35.533]                         computeRestarts <- base::computeRestarts
[16:59:35.533]                         grepl <- base::grepl
[16:59:35.533]                         restarts <- computeRestarts(cond)
[16:59:35.533]                         for (restart in restarts) {
[16:59:35.533]                           name <- restart$name
[16:59:35.533]                           if (is.null(name)) 
[16:59:35.533]                             next
[16:59:35.533]                           if (!grepl(pattern, name)) 
[16:59:35.533]                             next
[16:59:35.533]                           invokeRestart(restart)
[16:59:35.533]                           muffled <- TRUE
[16:59:35.533]                           break
[16:59:35.533]                         }
[16:59:35.533]                       }
[16:59:35.533]                     }
[16:59:35.533]                     invisible(muffled)
[16:59:35.533]                   }
[16:59:35.533]                   muffleCondition(cond)
[16:59:35.533]                 })
[16:59:35.533]             }))
[16:59:35.533]             future::FutureResult(value = ...future.value$value, 
[16:59:35.533]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.533]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.533]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.533]                     ...future.globalenv.names))
[16:59:35.533]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.533]         }, condition = base::local({
[16:59:35.533]             c <- base::c
[16:59:35.533]             inherits <- base::inherits
[16:59:35.533]             invokeRestart <- base::invokeRestart
[16:59:35.533]             length <- base::length
[16:59:35.533]             list <- base::list
[16:59:35.533]             seq.int <- base::seq.int
[16:59:35.533]             signalCondition <- base::signalCondition
[16:59:35.533]             sys.calls <- base::sys.calls
[16:59:35.533]             `[[` <- base::`[[`
[16:59:35.533]             `+` <- base::`+`
[16:59:35.533]             `<<-` <- base::`<<-`
[16:59:35.533]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.533]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.533]                   3L)]
[16:59:35.533]             }
[16:59:35.533]             function(cond) {
[16:59:35.533]                 is_error <- inherits(cond, "error")
[16:59:35.533]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.533]                   NULL)
[16:59:35.533]                 if (is_error) {
[16:59:35.533]                   sessionInformation <- function() {
[16:59:35.533]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.533]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.533]                       search = base::search(), system = base::Sys.info())
[16:59:35.533]                   }
[16:59:35.533]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.533]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.533]                     cond$call), session = sessionInformation(), 
[16:59:35.533]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.533]                   signalCondition(cond)
[16:59:35.533]                 }
[16:59:35.533]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.533]                 "immediateCondition"))) {
[16:59:35.533]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.533]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.533]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.533]                   if (TRUE && !signal) {
[16:59:35.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.533]                     {
[16:59:35.533]                       inherits <- base::inherits
[16:59:35.533]                       invokeRestart <- base::invokeRestart
[16:59:35.533]                       is.null <- base::is.null
[16:59:35.533]                       muffled <- FALSE
[16:59:35.533]                       if (inherits(cond, "message")) {
[16:59:35.533]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.533]                         if (muffled) 
[16:59:35.533]                           invokeRestart("muffleMessage")
[16:59:35.533]                       }
[16:59:35.533]                       else if (inherits(cond, "warning")) {
[16:59:35.533]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.533]                         if (muffled) 
[16:59:35.533]                           invokeRestart("muffleWarning")
[16:59:35.533]                       }
[16:59:35.533]                       else if (inherits(cond, "condition")) {
[16:59:35.533]                         if (!is.null(pattern)) {
[16:59:35.533]                           computeRestarts <- base::computeRestarts
[16:59:35.533]                           grepl <- base::grepl
[16:59:35.533]                           restarts <- computeRestarts(cond)
[16:59:35.533]                           for (restart in restarts) {
[16:59:35.533]                             name <- restart$name
[16:59:35.533]                             if (is.null(name)) 
[16:59:35.533]                               next
[16:59:35.533]                             if (!grepl(pattern, name)) 
[16:59:35.533]                               next
[16:59:35.533]                             invokeRestart(restart)
[16:59:35.533]                             muffled <- TRUE
[16:59:35.533]                             break
[16:59:35.533]                           }
[16:59:35.533]                         }
[16:59:35.533]                       }
[16:59:35.533]                       invisible(muffled)
[16:59:35.533]                     }
[16:59:35.533]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.533]                   }
[16:59:35.533]                 }
[16:59:35.533]                 else {
[16:59:35.533]                   if (TRUE) {
[16:59:35.533]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.533]                     {
[16:59:35.533]                       inherits <- base::inherits
[16:59:35.533]                       invokeRestart <- base::invokeRestart
[16:59:35.533]                       is.null <- base::is.null
[16:59:35.533]                       muffled <- FALSE
[16:59:35.533]                       if (inherits(cond, "message")) {
[16:59:35.533]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.533]                         if (muffled) 
[16:59:35.533]                           invokeRestart("muffleMessage")
[16:59:35.533]                       }
[16:59:35.533]                       else if (inherits(cond, "warning")) {
[16:59:35.533]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.533]                         if (muffled) 
[16:59:35.533]                           invokeRestart("muffleWarning")
[16:59:35.533]                       }
[16:59:35.533]                       else if (inherits(cond, "condition")) {
[16:59:35.533]                         if (!is.null(pattern)) {
[16:59:35.533]                           computeRestarts <- base::computeRestarts
[16:59:35.533]                           grepl <- base::grepl
[16:59:35.533]                           restarts <- computeRestarts(cond)
[16:59:35.533]                           for (restart in restarts) {
[16:59:35.533]                             name <- restart$name
[16:59:35.533]                             if (is.null(name)) 
[16:59:35.533]                               next
[16:59:35.533]                             if (!grepl(pattern, name)) 
[16:59:35.533]                               next
[16:59:35.533]                             invokeRestart(restart)
[16:59:35.533]                             muffled <- TRUE
[16:59:35.533]                             break
[16:59:35.533]                           }
[16:59:35.533]                         }
[16:59:35.533]                       }
[16:59:35.533]                       invisible(muffled)
[16:59:35.533]                     }
[16:59:35.533]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.533]                   }
[16:59:35.533]                 }
[16:59:35.533]             }
[16:59:35.533]         }))
[16:59:35.533]     }, error = function(ex) {
[16:59:35.533]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.533]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.533]                 ...future.rng), started = ...future.startTime, 
[16:59:35.533]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.533]             version = "1.8"), class = "FutureResult")
[16:59:35.533]     }, finally = {
[16:59:35.533]         if (!identical(...future.workdir, getwd())) 
[16:59:35.533]             setwd(...future.workdir)
[16:59:35.533]         {
[16:59:35.533]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.533]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.533]             }
[16:59:35.533]             base::options(...future.oldOptions)
[16:59:35.533]             if (.Platform$OS.type == "windows") {
[16:59:35.533]                 old_names <- names(...future.oldEnvVars)
[16:59:35.533]                 envs <- base::Sys.getenv()
[16:59:35.533]                 names <- names(envs)
[16:59:35.533]                 common <- intersect(names, old_names)
[16:59:35.533]                 added <- setdiff(names, old_names)
[16:59:35.533]                 removed <- setdiff(old_names, names)
[16:59:35.533]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.533]                   envs[common]]
[16:59:35.533]                 NAMES <- toupper(changed)
[16:59:35.533]                 args <- list()
[16:59:35.533]                 for (kk in seq_along(NAMES)) {
[16:59:35.533]                   name <- changed[[kk]]
[16:59:35.533]                   NAME <- NAMES[[kk]]
[16:59:35.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.533]                     next
[16:59:35.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.533]                 }
[16:59:35.533]                 NAMES <- toupper(added)
[16:59:35.533]                 for (kk in seq_along(NAMES)) {
[16:59:35.533]                   name <- added[[kk]]
[16:59:35.533]                   NAME <- NAMES[[kk]]
[16:59:35.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.533]                     next
[16:59:35.533]                   args[[name]] <- ""
[16:59:35.533]                 }
[16:59:35.533]                 NAMES <- toupper(removed)
[16:59:35.533]                 for (kk in seq_along(NAMES)) {
[16:59:35.533]                   name <- removed[[kk]]
[16:59:35.533]                   NAME <- NAMES[[kk]]
[16:59:35.533]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.533]                     next
[16:59:35.533]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.533]                 }
[16:59:35.533]                 if (length(args) > 0) 
[16:59:35.533]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.533]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.533]             }
[16:59:35.533]             else {
[16:59:35.533]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.533]             }
[16:59:35.533]             {
[16:59:35.533]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.533]                   0L) {
[16:59:35.533]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.533]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.533]                   base::options(opts)
[16:59:35.533]                 }
[16:59:35.533]                 {
[16:59:35.533]                   {
[16:59:35.533]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.533]                     NULL
[16:59:35.533]                   }
[16:59:35.533]                   options(future.plan = NULL)
[16:59:35.533]                   if (is.na(NA_character_)) 
[16:59:35.533]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.533]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.533]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.533]                     .init = FALSE)
[16:59:35.533]                 }
[16:59:35.533]             }
[16:59:35.533]         }
[16:59:35.533]     })
[16:59:35.533]     if (TRUE) {
[16:59:35.533]         base::sink(type = "output", split = FALSE)
[16:59:35.533]         if (TRUE) {
[16:59:35.533]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.533]         }
[16:59:35.533]         else {
[16:59:35.533]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.533]         }
[16:59:35.533]         base::close(...future.stdout)
[16:59:35.533]         ...future.stdout <- NULL
[16:59:35.533]     }
[16:59:35.533]     ...future.result$conditions <- ...future.conditions
[16:59:35.533]     ...future.result$finished <- base::Sys.time()
[16:59:35.533]     ...future.result
[16:59:35.533] }
[16:59:35.535] assign_globals() ...
[16:59:35.535] List of 7
[16:59:35.535]  $ ...future.FUN            :function (x)  
[16:59:35.535]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:35.535]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.535]  $ future.call.arguments    : list()
[16:59:35.535]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.535]  $ ...future.elements_ii    :List of 1
[16:59:35.535]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.535]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.535]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.535]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.535]  $ ...future.seeds_ii       : NULL
[16:59:35.535]  $ ...future.globals.maxSize: NULL
[16:59:35.535]  - attr(*, "where")=List of 7
[16:59:35.535]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.535]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:59:35.535]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:59:35.535]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.535]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.535]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.535]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.535]  - attr(*, "resolved")= logi FALSE
[16:59:35.535]  - attr(*, "total_size")= num 2320
[16:59:35.535]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.535]  - attr(*, "already-done")= logi TRUE
[16:59:35.546] - reassign environment for ‘...future.FUN’
[16:59:35.546] - copied ‘...future.FUN’ to environment
[16:59:35.546] - copied ‘breaks’ to environment
[16:59:35.546] - copied ‘wool’ to environment
[16:59:35.546] - copied ‘future.call.arguments’ to environment
[16:59:35.546] - copied ‘...future.elements_ii’ to environment
[16:59:35.546] - copied ‘...future.seeds_ii’ to environment
[16:59:35.546] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.547] assign_globals() ... done
[16:59:35.547] requestCore(): workers = 2
[16:59:35.549] MulticoreFuture started
[16:59:35.549] - Launch lazy future ... done
[16:59:35.550] run() for ‘MulticoreFuture’ ... done
[16:59:35.550] Created future:
[16:59:35.550] plan(): Setting new future strategy stack:
[16:59:35.551] List of future strategies:
[16:59:35.551] 1. sequential:
[16:59:35.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.551]    - tweaked: FALSE
[16:59:35.551]    - call: NULL
[16:59:35.552] plan(): nbrOfWorkers() = 1
[16:59:35.555] plan(): Setting new future strategy stack:
[16:59:35.556] List of future strategies:
[16:59:35.556] 1. multicore:
[16:59:35.556]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.556]    - tweaked: FALSE
[16:59:35.556]    - call: plan(strategy)
[16:59:35.561] plan(): nbrOfWorkers() = 2
[16:59:35.550] MulticoreFuture:
[16:59:35.550] Label: ‘future_by-1’
[16:59:35.550] Expression:
[16:59:35.550] {
[16:59:35.550]     do.call(function(...) {
[16:59:35.550]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.550]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.550]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.550]             on.exit(options(oopts), add = TRUE)
[16:59:35.550]         }
[16:59:35.550]         {
[16:59:35.550]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.550]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.550]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.550]             })
[16:59:35.550]         }
[16:59:35.550]     }, args = future.call.arguments)
[16:59:35.550] }
[16:59:35.550] Lazy evaluation: FALSE
[16:59:35.550] Asynchronous evaluation: TRUE
[16:59:35.550] Local evaluation: TRUE
[16:59:35.550] Environment: 0x5620527bcaf0
[16:59:35.550] Capture standard output: TRUE
[16:59:35.550] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.550] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:59:35.550] Packages: 1 packages (‘stats’)
[16:59:35.550] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.550] Resolved: TRUE
[16:59:35.550] Value: <not collected>
[16:59:35.550] Conditions captured: <none>
[16:59:35.550] Early signaling: FALSE
[16:59:35.550] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.550] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.563] Chunk #1 of 2 ... DONE
[16:59:35.563] Chunk #2 of 2 ...
[16:59:35.563]  - Finding globals in 'X' for chunk #2 ...
[16:59:35.564] getGlobalsAndPackages() ...
[16:59:35.564] Searching for globals...
[16:59:35.564] 
[16:59:35.565] Searching for globals ... DONE
[16:59:35.565] - globals: [0] <none>
[16:59:35.565] getGlobalsAndPackages() ... DONE
[16:59:35.565]    + additional globals found: [n=0] 
[16:59:35.565]    + additional namespaces needed: [n=0] 
[16:59:35.565]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:35.565]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.566]  - seeds: <none>
[16:59:35.566]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.566] getGlobalsAndPackages() ...
[16:59:35.566] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.566] Resolving globals: FALSE
[16:59:35.566] Tweak future expression to call with '...' arguments ...
[16:59:35.566] {
[16:59:35.566]     do.call(function(...) {
[16:59:35.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.566]             on.exit(options(oopts), add = TRUE)
[16:59:35.566]         }
[16:59:35.566]         {
[16:59:35.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.566]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.566]             })
[16:59:35.566]         }
[16:59:35.566]     }, args = future.call.arguments)
[16:59:35.566] }
[16:59:35.567] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.568] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.568] 
[16:59:35.568] getGlobalsAndPackages() ... DONE
[16:59:35.569] run() for ‘Future’ ...
[16:59:35.569] - state: ‘created’
[16:59:35.569] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.574] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.574]   - Field: ‘label’
[16:59:35.574]   - Field: ‘local’
[16:59:35.574]   - Field: ‘owner’
[16:59:35.574]   - Field: ‘envir’
[16:59:35.575]   - Field: ‘workers’
[16:59:35.575]   - Field: ‘packages’
[16:59:35.575]   - Field: ‘gc’
[16:59:35.575]   - Field: ‘job’
[16:59:35.575]   - Field: ‘conditions’
[16:59:35.575]   - Field: ‘expr’
[16:59:35.576]   - Field: ‘uuid’
[16:59:35.576]   - Field: ‘seed’
[16:59:35.576]   - Field: ‘version’
[16:59:35.576]   - Field: ‘result’
[16:59:35.576]   - Field: ‘asynchronous’
[16:59:35.576]   - Field: ‘calls’
[16:59:35.576]   - Field: ‘globals’
[16:59:35.577]   - Field: ‘stdout’
[16:59:35.577]   - Field: ‘earlySignal’
[16:59:35.577]   - Field: ‘lazy’
[16:59:35.577]   - Field: ‘state’
[16:59:35.577] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.577] - Launch lazy future ...
[16:59:35.578] Packages needed by the future expression (n = 1): ‘stats’
[16:59:35.578] Packages needed by future strategies (n = 0): <none>
[16:59:35.579] {
[16:59:35.579]     {
[16:59:35.579]         {
[16:59:35.579]             ...future.startTime <- base::Sys.time()
[16:59:35.579]             {
[16:59:35.579]                 {
[16:59:35.579]                   {
[16:59:35.579]                     {
[16:59:35.579]                       {
[16:59:35.579]                         base::local({
[16:59:35.579]                           has_future <- base::requireNamespace("future", 
[16:59:35.579]                             quietly = TRUE)
[16:59:35.579]                           if (has_future) {
[16:59:35.579]                             ns <- base::getNamespace("future")
[16:59:35.579]                             version <- ns[[".package"]][["version"]]
[16:59:35.579]                             if (is.null(version)) 
[16:59:35.579]                               version <- utils::packageVersion("future")
[16:59:35.579]                           }
[16:59:35.579]                           else {
[16:59:35.579]                             version <- NULL
[16:59:35.579]                           }
[16:59:35.579]                           if (!has_future || version < "1.8.0") {
[16:59:35.579]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.579]                               "", base::R.version$version.string), 
[16:59:35.579]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:35.579]                                 base::R.version$platform, 8 * 
[16:59:35.579]                                   base::.Machine$sizeof.pointer), 
[16:59:35.579]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.579]                                 "release", "version")], collapse = " "), 
[16:59:35.579]                               hostname = base::Sys.info()[["nodename"]])
[16:59:35.579]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.579]                               info)
[16:59:35.579]                             info <- base::paste(info, collapse = "; ")
[16:59:35.579]                             if (!has_future) {
[16:59:35.579]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.579]                                 info)
[16:59:35.579]                             }
[16:59:35.579]                             else {
[16:59:35.579]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.579]                                 info, version)
[16:59:35.579]                             }
[16:59:35.579]                             base::stop(msg)
[16:59:35.579]                           }
[16:59:35.579]                         })
[16:59:35.579]                       }
[16:59:35.579]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.579]                       base::options(mc.cores = 1L)
[16:59:35.579]                     }
[16:59:35.579]                     base::local({
[16:59:35.579]                       for (pkg in "stats") {
[16:59:35.579]                         base::loadNamespace(pkg)
[16:59:35.579]                         base::library(pkg, character.only = TRUE)
[16:59:35.579]                       }
[16:59:35.579]                     })
[16:59:35.579]                   }
[16:59:35.579]                   ...future.strategy.old <- future::plan("list")
[16:59:35.579]                   options(future.plan = NULL)
[16:59:35.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.579]                 }
[16:59:35.579]                 ...future.workdir <- getwd()
[16:59:35.579]             }
[16:59:35.579]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.579]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.579]         }
[16:59:35.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.579]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.579]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.579]             base::names(...future.oldOptions))
[16:59:35.579]     }
[16:59:35.579]     if (FALSE) {
[16:59:35.579]     }
[16:59:35.579]     else {
[16:59:35.579]         if (TRUE) {
[16:59:35.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.579]                 open = "w")
[16:59:35.579]         }
[16:59:35.579]         else {
[16:59:35.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.579]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.579]         }
[16:59:35.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.579]             base::sink(type = "output", split = FALSE)
[16:59:35.579]             base::close(...future.stdout)
[16:59:35.579]         }, add = TRUE)
[16:59:35.579]     }
[16:59:35.579]     ...future.frame <- base::sys.nframe()
[16:59:35.579]     ...future.conditions <- base::list()
[16:59:35.579]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.579]     if (FALSE) {
[16:59:35.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.579]     }
[16:59:35.579]     ...future.result <- base::tryCatch({
[16:59:35.579]         base::withCallingHandlers({
[16:59:35.579]             ...future.value <- base::withVisible(base::local({
[16:59:35.579]                 withCallingHandlers({
[16:59:35.579]                   {
[16:59:35.579]                     do.call(function(...) {
[16:59:35.579]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.579]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.579]                         ...future.globals.maxSize)) {
[16:59:35.579]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.579]                         on.exit(options(oopts), add = TRUE)
[16:59:35.579]                       }
[16:59:35.579]                       {
[16:59:35.579]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.579]                           FUN = function(jj) {
[16:59:35.579]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.579]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.579]                           })
[16:59:35.579]                       }
[16:59:35.579]                     }, args = future.call.arguments)
[16:59:35.579]                   }
[16:59:35.579]                 }, immediateCondition = function(cond) {
[16:59:35.579]                   save_rds <- function (object, pathname, ...) 
[16:59:35.579]                   {
[16:59:35.579]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.579]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.579]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.579]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.579]                         fi_tmp[["mtime"]])
[16:59:35.579]                     }
[16:59:35.579]                     tryCatch({
[16:59:35.579]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.579]                     }, error = function(ex) {
[16:59:35.579]                       msg <- conditionMessage(ex)
[16:59:35.579]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.579]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.579]                         fi_tmp[["mtime"]], msg)
[16:59:35.579]                       ex$message <- msg
[16:59:35.579]                       stop(ex)
[16:59:35.579]                     })
[16:59:35.579]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.579]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.579]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.579]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.579]                       fi <- file.info(pathname)
[16:59:35.579]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.579]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.579]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.579]                         fi[["size"]], fi[["mtime"]])
[16:59:35.579]                       stop(msg)
[16:59:35.579]                     }
[16:59:35.579]                     invisible(pathname)
[16:59:35.579]                   }
[16:59:35.579]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.579]                     rootPath = tempdir()) 
[16:59:35.579]                   {
[16:59:35.579]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.579]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.579]                       tmpdir = path, fileext = ".rds")
[16:59:35.579]                     save_rds(obj, file)
[16:59:35.579]                   }
[16:59:35.579]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.579]                   {
[16:59:35.579]                     inherits <- base::inherits
[16:59:35.579]                     invokeRestart <- base::invokeRestart
[16:59:35.579]                     is.null <- base::is.null
[16:59:35.579]                     muffled <- FALSE
[16:59:35.579]                     if (inherits(cond, "message")) {
[16:59:35.579]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.579]                       if (muffled) 
[16:59:35.579]                         invokeRestart("muffleMessage")
[16:59:35.579]                     }
[16:59:35.579]                     else if (inherits(cond, "warning")) {
[16:59:35.579]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.579]                       if (muffled) 
[16:59:35.579]                         invokeRestart("muffleWarning")
[16:59:35.579]                     }
[16:59:35.579]                     else if (inherits(cond, "condition")) {
[16:59:35.579]                       if (!is.null(pattern)) {
[16:59:35.579]                         computeRestarts <- base::computeRestarts
[16:59:35.579]                         grepl <- base::grepl
[16:59:35.579]                         restarts <- computeRestarts(cond)
[16:59:35.579]                         for (restart in restarts) {
[16:59:35.579]                           name <- restart$name
[16:59:35.579]                           if (is.null(name)) 
[16:59:35.579]                             next
[16:59:35.579]                           if (!grepl(pattern, name)) 
[16:59:35.579]                             next
[16:59:35.579]                           invokeRestart(restart)
[16:59:35.579]                           muffled <- TRUE
[16:59:35.579]                           break
[16:59:35.579]                         }
[16:59:35.579]                       }
[16:59:35.579]                     }
[16:59:35.579]                     invisible(muffled)
[16:59:35.579]                   }
[16:59:35.579]                   muffleCondition(cond)
[16:59:35.579]                 })
[16:59:35.579]             }))
[16:59:35.579]             future::FutureResult(value = ...future.value$value, 
[16:59:35.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.579]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.579]                     ...future.globalenv.names))
[16:59:35.579]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.579]         }, condition = base::local({
[16:59:35.579]             c <- base::c
[16:59:35.579]             inherits <- base::inherits
[16:59:35.579]             invokeRestart <- base::invokeRestart
[16:59:35.579]             length <- base::length
[16:59:35.579]             list <- base::list
[16:59:35.579]             seq.int <- base::seq.int
[16:59:35.579]             signalCondition <- base::signalCondition
[16:59:35.579]             sys.calls <- base::sys.calls
[16:59:35.579]             `[[` <- base::`[[`
[16:59:35.579]             `+` <- base::`+`
[16:59:35.579]             `<<-` <- base::`<<-`
[16:59:35.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.579]                   3L)]
[16:59:35.579]             }
[16:59:35.579]             function(cond) {
[16:59:35.579]                 is_error <- inherits(cond, "error")
[16:59:35.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.579]                   NULL)
[16:59:35.579]                 if (is_error) {
[16:59:35.579]                   sessionInformation <- function() {
[16:59:35.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.579]                       search = base::search(), system = base::Sys.info())
[16:59:35.579]                   }
[16:59:35.579]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.579]                     cond$call), session = sessionInformation(), 
[16:59:35.579]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.579]                   signalCondition(cond)
[16:59:35.579]                 }
[16:59:35.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.579]                 "immediateCondition"))) {
[16:59:35.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.579]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.579]                   if (TRUE && !signal) {
[16:59:35.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.579]                     {
[16:59:35.579]                       inherits <- base::inherits
[16:59:35.579]                       invokeRestart <- base::invokeRestart
[16:59:35.579]                       is.null <- base::is.null
[16:59:35.579]                       muffled <- FALSE
[16:59:35.579]                       if (inherits(cond, "message")) {
[16:59:35.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.579]                         if (muffled) 
[16:59:35.579]                           invokeRestart("muffleMessage")
[16:59:35.579]                       }
[16:59:35.579]                       else if (inherits(cond, "warning")) {
[16:59:35.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.579]                         if (muffled) 
[16:59:35.579]                           invokeRestart("muffleWarning")
[16:59:35.579]                       }
[16:59:35.579]                       else if (inherits(cond, "condition")) {
[16:59:35.579]                         if (!is.null(pattern)) {
[16:59:35.579]                           computeRestarts <- base::computeRestarts
[16:59:35.579]                           grepl <- base::grepl
[16:59:35.579]                           restarts <- computeRestarts(cond)
[16:59:35.579]                           for (restart in restarts) {
[16:59:35.579]                             name <- restart$name
[16:59:35.579]                             if (is.null(name)) 
[16:59:35.579]                               next
[16:59:35.579]                             if (!grepl(pattern, name)) 
[16:59:35.579]                               next
[16:59:35.579]                             invokeRestart(restart)
[16:59:35.579]                             muffled <- TRUE
[16:59:35.579]                             break
[16:59:35.579]                           }
[16:59:35.579]                         }
[16:59:35.579]                       }
[16:59:35.579]                       invisible(muffled)
[16:59:35.579]                     }
[16:59:35.579]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.579]                   }
[16:59:35.579]                 }
[16:59:35.579]                 else {
[16:59:35.579]                   if (TRUE) {
[16:59:35.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.579]                     {
[16:59:35.579]                       inherits <- base::inherits
[16:59:35.579]                       invokeRestart <- base::invokeRestart
[16:59:35.579]                       is.null <- base::is.null
[16:59:35.579]                       muffled <- FALSE
[16:59:35.579]                       if (inherits(cond, "message")) {
[16:59:35.579]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.579]                         if (muffled) 
[16:59:35.579]                           invokeRestart("muffleMessage")
[16:59:35.579]                       }
[16:59:35.579]                       else if (inherits(cond, "warning")) {
[16:59:35.579]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.579]                         if (muffled) 
[16:59:35.579]                           invokeRestart("muffleWarning")
[16:59:35.579]                       }
[16:59:35.579]                       else if (inherits(cond, "condition")) {
[16:59:35.579]                         if (!is.null(pattern)) {
[16:59:35.579]                           computeRestarts <- base::computeRestarts
[16:59:35.579]                           grepl <- base::grepl
[16:59:35.579]                           restarts <- computeRestarts(cond)
[16:59:35.579]                           for (restart in restarts) {
[16:59:35.579]                             name <- restart$name
[16:59:35.579]                             if (is.null(name)) 
[16:59:35.579]                               next
[16:59:35.579]                             if (!grepl(pattern, name)) 
[16:59:35.579]                               next
[16:59:35.579]                             invokeRestart(restart)
[16:59:35.579]                             muffled <- TRUE
[16:59:35.579]                             break
[16:59:35.579]                           }
[16:59:35.579]                         }
[16:59:35.579]                       }
[16:59:35.579]                       invisible(muffled)
[16:59:35.579]                     }
[16:59:35.579]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.579]                   }
[16:59:35.579]                 }
[16:59:35.579]             }
[16:59:35.579]         }))
[16:59:35.579]     }, error = function(ex) {
[16:59:35.579]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.579]                 ...future.rng), started = ...future.startTime, 
[16:59:35.579]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.579]             version = "1.8"), class = "FutureResult")
[16:59:35.579]     }, finally = {
[16:59:35.579]         if (!identical(...future.workdir, getwd())) 
[16:59:35.579]             setwd(...future.workdir)
[16:59:35.579]         {
[16:59:35.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.579]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.579]             }
[16:59:35.579]             base::options(...future.oldOptions)
[16:59:35.579]             if (.Platform$OS.type == "windows") {
[16:59:35.579]                 old_names <- names(...future.oldEnvVars)
[16:59:35.579]                 envs <- base::Sys.getenv()
[16:59:35.579]                 names <- names(envs)
[16:59:35.579]                 common <- intersect(names, old_names)
[16:59:35.579]                 added <- setdiff(names, old_names)
[16:59:35.579]                 removed <- setdiff(old_names, names)
[16:59:35.579]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.579]                   envs[common]]
[16:59:35.579]                 NAMES <- toupper(changed)
[16:59:35.579]                 args <- list()
[16:59:35.579]                 for (kk in seq_along(NAMES)) {
[16:59:35.579]                   name <- changed[[kk]]
[16:59:35.579]                   NAME <- NAMES[[kk]]
[16:59:35.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.579]                     next
[16:59:35.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.579]                 }
[16:59:35.579]                 NAMES <- toupper(added)
[16:59:35.579]                 for (kk in seq_along(NAMES)) {
[16:59:35.579]                   name <- added[[kk]]
[16:59:35.579]                   NAME <- NAMES[[kk]]
[16:59:35.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.579]                     next
[16:59:35.579]                   args[[name]] <- ""
[16:59:35.579]                 }
[16:59:35.579]                 NAMES <- toupper(removed)
[16:59:35.579]                 for (kk in seq_along(NAMES)) {
[16:59:35.579]                   name <- removed[[kk]]
[16:59:35.579]                   NAME <- NAMES[[kk]]
[16:59:35.579]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.579]                     next
[16:59:35.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.579]                 }
[16:59:35.579]                 if (length(args) > 0) 
[16:59:35.579]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.579]             }
[16:59:35.579]             else {
[16:59:35.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.579]             }
[16:59:35.579]             {
[16:59:35.579]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.579]                   0L) {
[16:59:35.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.579]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.579]                   base::options(opts)
[16:59:35.579]                 }
[16:59:35.579]                 {
[16:59:35.579]                   {
[16:59:35.579]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.579]                     NULL
[16:59:35.579]                   }
[16:59:35.579]                   options(future.plan = NULL)
[16:59:35.579]                   if (is.na(NA_character_)) 
[16:59:35.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.579]                     .init = FALSE)
[16:59:35.579]                 }
[16:59:35.579]             }
[16:59:35.579]         }
[16:59:35.579]     })
[16:59:35.579]     if (TRUE) {
[16:59:35.579]         base::sink(type = "output", split = FALSE)
[16:59:35.579]         if (TRUE) {
[16:59:35.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.579]         }
[16:59:35.579]         else {
[16:59:35.579]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.579]         }
[16:59:35.579]         base::close(...future.stdout)
[16:59:35.579]         ...future.stdout <- NULL
[16:59:35.579]     }
[16:59:35.579]     ...future.result$conditions <- ...future.conditions
[16:59:35.579]     ...future.result$finished <- base::Sys.time()
[16:59:35.579]     ...future.result
[16:59:35.579] }
[16:59:35.582] assign_globals() ...
[16:59:35.582] List of 7
[16:59:35.582]  $ ...future.FUN            :function (x)  
[16:59:35.582]  $ breaks                   : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:35.582]  $ wool                     : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.582]  $ future.call.arguments    : list()
[16:59:35.582]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.582]  $ ...future.elements_ii    :List of 2
[16:59:35.582]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.582]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.582]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.582]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:35.582]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.582]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.582]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.582]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:35.582]  $ ...future.seeds_ii       : NULL
[16:59:35.582]  $ ...future.globals.maxSize: NULL
[16:59:35.582]  - attr(*, "where")=List of 7
[16:59:35.582]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.582]   ..$ breaks                   :<environment: R_EmptyEnv> 
[16:59:35.582]   ..$ wool                     :<environment: R_EmptyEnv> 
[16:59:35.582]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.582]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.582]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.582]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.582]  - attr(*, "resolved")= logi FALSE
[16:59:35.582]  - attr(*, "total_size")= num 2320
[16:59:35.582]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.582]  - attr(*, "already-done")= logi TRUE
[16:59:35.600] - reassign environment for ‘...future.FUN’
[16:59:35.600] - copied ‘...future.FUN’ to environment
[16:59:35.601] - copied ‘breaks’ to environment
[16:59:35.601] - copied ‘wool’ to environment
[16:59:35.601] - copied ‘future.call.arguments’ to environment
[16:59:35.601] - copied ‘...future.elements_ii’ to environment
[16:59:35.601] - copied ‘...future.seeds_ii’ to environment
[16:59:35.601] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.601] assign_globals() ... done
[16:59:35.601] requestCore(): workers = 2
[16:59:35.604] MulticoreFuture started
[16:59:35.604] - Launch lazy future ... done
[16:59:35.604] run() for ‘MulticoreFuture’ ... done
[16:59:35.605] Created future:
[16:59:35.605] plan(): Setting new future strategy stack:
[16:59:35.605] List of future strategies:
[16:59:35.605] 1. sequential:
[16:59:35.605]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.605]    - tweaked: FALSE
[16:59:35.605]    - call: NULL
[16:59:35.606] plan(): nbrOfWorkers() = 1
[16:59:35.611] plan(): Setting new future strategy stack:
[16:59:35.612] List of future strategies:
[16:59:35.612] 1. multicore:
[16:59:35.612]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.612]    - tweaked: FALSE
[16:59:35.612]    - call: plan(strategy)
[16:59:35.617] plan(): nbrOfWorkers() = 2
[16:59:35.605] MulticoreFuture:
[16:59:35.605] Label: ‘future_by-2’
[16:59:35.605] Expression:
[16:59:35.605] {
[16:59:35.605]     do.call(function(...) {
[16:59:35.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.605]             on.exit(options(oopts), add = TRUE)
[16:59:35.605]         }
[16:59:35.605]         {
[16:59:35.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.605]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.605]             })
[16:59:35.605]         }
[16:59:35.605]     }, args = future.call.arguments)
[16:59:35.605] }
[16:59:35.605] Lazy evaluation: FALSE
[16:59:35.605] Asynchronous evaluation: TRUE
[16:59:35.605] Local evaluation: TRUE
[16:59:35.605] Environment: 0x5620527bcaf0
[16:59:35.605] Capture standard output: TRUE
[16:59:35.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.605] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:59:35.605] Packages: 1 packages (‘stats’)
[16:59:35.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.605] Resolved: FALSE
[16:59:35.605] Value: <not collected>
[16:59:35.605] Conditions captured: <none>
[16:59:35.605] Early signaling: FALSE
[16:59:35.605] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.605] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.618] Chunk #2 of 2 ... DONE
[16:59:35.618] Launching 2 futures (chunks) ... DONE
[16:59:35.619] Resolving 2 futures (chunks) ...
[16:59:35.619] resolve() on list ...
[16:59:35.619]  recursive: 0
[16:59:35.619]  length: 2
[16:59:35.619] 
[16:59:35.620] Future #1
[16:59:35.620] result() for MulticoreFuture ...
[16:59:35.621] result() for MulticoreFuture ...
[16:59:35.622] result() for MulticoreFuture ... done
[16:59:35.622] result() for MulticoreFuture ... done
[16:59:35.622] result() for MulticoreFuture ...
[16:59:35.622] result() for MulticoreFuture ... done
[16:59:35.622] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:35.622] - nx: 2
[16:59:35.622] - relay: TRUE
[16:59:35.623] - stdout: TRUE
[16:59:35.623] - signal: TRUE
[16:59:35.623] - resignal: FALSE
[16:59:35.623] - force: TRUE
[16:59:35.623] - relayed: [n=2] FALSE, FALSE
[16:59:35.623] - queued futures: [n=2] FALSE, FALSE
[16:59:35.623]  - until=1
[16:59:35.624]  - relaying element #1
[16:59:35.624] result() for MulticoreFuture ...
[16:59:35.624] result() for MulticoreFuture ... done
[16:59:35.624] result() for MulticoreFuture ...
[16:59:35.624] result() for MulticoreFuture ... done
[16:59:35.625] result() for MulticoreFuture ...
[16:59:35.625] result() for MulticoreFuture ... done
[16:59:35.625] result() for MulticoreFuture ...
[16:59:35.625] result() for MulticoreFuture ... done
[16:59:35.625] - relayed: [n=2] TRUE, FALSE
[16:59:35.626] - queued futures: [n=2] TRUE, FALSE
[16:59:35.626] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:35.626]  length: 1 (resolved future 1)
[16:59:35.627] Future #2
[16:59:35.627] result() for MulticoreFuture ...
[16:59:35.629] result() for MulticoreFuture ...
[16:59:35.629] result() for MulticoreFuture ... done
[16:59:35.629] result() for MulticoreFuture ... done
[16:59:35.629] result() for MulticoreFuture ...
[16:59:35.629] result() for MulticoreFuture ... done
[16:59:35.629] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:35.629] - nx: 2
[16:59:35.630] - relay: TRUE
[16:59:35.630] - stdout: TRUE
[16:59:35.630] - signal: TRUE
[16:59:35.630] - resignal: FALSE
[16:59:35.630] - force: TRUE
[16:59:35.630] - relayed: [n=2] TRUE, FALSE
[16:59:35.630] - queued futures: [n=2] TRUE, FALSE
[16:59:35.631]  - until=2
[16:59:35.631]  - relaying element #2
[16:59:35.631] result() for MulticoreFuture ...
[16:59:35.631] result() for MulticoreFuture ... done
[16:59:35.631] result() for MulticoreFuture ...
[16:59:35.631] result() for MulticoreFuture ... done
[16:59:35.634] result() for MulticoreFuture ...
[16:59:35.634] result() for MulticoreFuture ... done
[16:59:35.634] result() for MulticoreFuture ...
[16:59:35.634] result() for MulticoreFuture ... done
[16:59:35.634] - relayed: [n=2] TRUE, TRUE
[16:59:35.635] - queued futures: [n=2] TRUE, TRUE
[16:59:35.635] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:35.635]  length: 0 (resolved future 2)
[16:59:35.635] Relaying remaining futures
[16:59:35.635] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.636] - nx: 2
[16:59:35.636] - relay: TRUE
[16:59:35.636] - stdout: TRUE
[16:59:35.636] - signal: TRUE
[16:59:35.636] - resignal: FALSE
[16:59:35.636] - force: TRUE
[16:59:35.636] - relayed: [n=2] TRUE, TRUE
[16:59:35.637] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:35.637] - relayed: [n=2] TRUE, TRUE
[16:59:35.637] - queued futures: [n=2] TRUE, TRUE
[16:59:35.637] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.637] resolve() on list ... DONE
[16:59:35.637] result() for MulticoreFuture ...
[16:59:35.638] result() for MulticoreFuture ... done
[16:59:35.638] result() for MulticoreFuture ...
[16:59:35.638] result() for MulticoreFuture ... done
[16:59:35.638] result() for MulticoreFuture ...
[16:59:35.638] result() for MulticoreFuture ... done
[16:59:35.638] result() for MulticoreFuture ...
[16:59:35.639] result() for MulticoreFuture ... done
[16:59:35.639]  - Number of value chunks collected: 2
[16:59:35.639] Resolving 2 futures (chunks) ... DONE
[16:59:35.639] Reducing values from 2 chunks ...
[16:59:35.639]  - Number of values collected after concatenation: 3
[16:59:35.640]  - Number of values expected: 3
[16:59:35.640] Reducing values from 2 chunks ... DONE
[16:59:35.640] future_lapply() ... DONE
[16:59:35.640] future_by_internal() ... DONE
[16:59:35.641] future_by_internal() ...
[16:59:35.641] future_lapply() ...
[16:59:35.646] Number of chunks: 2
[16:59:35.646] getGlobalsAndPackagesXApply() ...
[16:59:35.646]  - future.globals: TRUE
[16:59:35.647] getGlobalsAndPackages() ...
[16:59:35.647] Searching for globals...
[16:59:35.648] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:35.648] Searching for globals ... DONE
[16:59:35.648] Resolving globals: FALSE
[16:59:35.649] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:35.649] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:35.649] - globals: [1] ‘FUN’
[16:59:35.649] 
[16:59:35.650] getGlobalsAndPackages() ... DONE
[16:59:35.650]  - globals found/used: [n=1] ‘FUN’
[16:59:35.650]  - needed namespaces: [n=0] 
[16:59:35.650] Finding globals ... DONE
[16:59:35.650]  - use_args: TRUE
[16:59:35.650]  - Getting '...' globals ...
[16:59:35.650] resolve() on list ...
[16:59:35.651]  recursive: 0
[16:59:35.651]  length: 1
[16:59:35.651]  elements: ‘...’
[16:59:35.651]  length: 0 (resolved future 1)
[16:59:35.651] resolve() on list ... DONE
[16:59:35.651]    - '...' content: [n=0] 
[16:59:35.651] List of 1
[16:59:35.651]  $ ...: list()
[16:59:35.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.651]  - attr(*, "where")=List of 1
[16:59:35.651]   ..$ ...:<environment: 0x5620531015f0> 
[16:59:35.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.651]  - attr(*, "resolved")= logi TRUE
[16:59:35.651]  - attr(*, "total_size")= num NA
[16:59:35.654]  - Getting '...' globals ... DONE
[16:59:35.654] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.654] List of 2
[16:59:35.654]  $ ...future.FUN:function (object, ...)  
[16:59:35.654]  $ ...          : list()
[16:59:35.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.654]  - attr(*, "where")=List of 2
[16:59:35.654]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.654]   ..$ ...          :<environment: 0x5620531015f0> 
[16:59:35.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.654]  - attr(*, "resolved")= logi FALSE
[16:59:35.654]  - attr(*, "total_size")= num 1240
[16:59:35.657] Packages to be attached in all futures: [n=0] 
[16:59:35.657] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.657] Number of futures (= number of chunks): 2
[16:59:35.657] Launching 2 futures (chunks) ...
[16:59:35.658] Chunk #1 of 2 ...
[16:59:35.658]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.658] getGlobalsAndPackages() ...
[16:59:35.658] Searching for globals...
[16:59:35.658] 
[16:59:35.658] Searching for globals ... DONE
[16:59:35.658] - globals: [0] <none>
[16:59:35.659] getGlobalsAndPackages() ... DONE
[16:59:35.659]    + additional globals found: [n=0] 
[16:59:35.659]    + additional namespaces needed: [n=0] 
[16:59:35.659]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.659]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.661]  - seeds: <none>
[16:59:35.661]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.662] getGlobalsAndPackages() ...
[16:59:35.662] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.662] Resolving globals: FALSE
[16:59:35.662] Tweak future expression to call with '...' arguments ...
[16:59:35.662] {
[16:59:35.662]     do.call(function(...) {
[16:59:35.662]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.662]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.662]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.662]             on.exit(options(oopts), add = TRUE)
[16:59:35.662]         }
[16:59:35.662]         {
[16:59:35.662]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.662]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.662]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.662]             })
[16:59:35.662]         }
[16:59:35.662]     }, args = future.call.arguments)
[16:59:35.662] }
[16:59:35.662] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.663] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.663] 
[16:59:35.663] getGlobalsAndPackages() ... DONE
[16:59:35.664] run() for ‘Future’ ...
[16:59:35.664] - state: ‘created’
[16:59:35.664] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.668] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.668]   - Field: ‘label’
[16:59:35.668]   - Field: ‘local’
[16:59:35.669]   - Field: ‘owner’
[16:59:35.669]   - Field: ‘envir’
[16:59:35.669]   - Field: ‘workers’
[16:59:35.669]   - Field: ‘packages’
[16:59:35.669]   - Field: ‘gc’
[16:59:35.669]   - Field: ‘job’
[16:59:35.669]   - Field: ‘conditions’
[16:59:35.669]   - Field: ‘expr’
[16:59:35.670]   - Field: ‘uuid’
[16:59:35.670]   - Field: ‘seed’
[16:59:35.670]   - Field: ‘version’
[16:59:35.670]   - Field: ‘result’
[16:59:35.670]   - Field: ‘asynchronous’
[16:59:35.670]   - Field: ‘calls’
[16:59:35.670]   - Field: ‘globals’
[16:59:35.670]   - Field: ‘stdout’
[16:59:35.670]   - Field: ‘earlySignal’
[16:59:35.671]   - Field: ‘lazy’
[16:59:35.671]   - Field: ‘state’
[16:59:35.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.671] - Launch lazy future ...
[16:59:35.671] Packages needed by the future expression (n = 0): <none>
[16:59:35.671] Packages needed by future strategies (n = 0): <none>
[16:59:35.672] {
[16:59:35.672]     {
[16:59:35.672]         {
[16:59:35.672]             ...future.startTime <- base::Sys.time()
[16:59:35.672]             {
[16:59:35.672]                 {
[16:59:35.672]                   {
[16:59:35.672]                     {
[16:59:35.672]                       base::local({
[16:59:35.672]                         has_future <- base::requireNamespace("future", 
[16:59:35.672]                           quietly = TRUE)
[16:59:35.672]                         if (has_future) {
[16:59:35.672]                           ns <- base::getNamespace("future")
[16:59:35.672]                           version <- ns[[".package"]][["version"]]
[16:59:35.672]                           if (is.null(version)) 
[16:59:35.672]                             version <- utils::packageVersion("future")
[16:59:35.672]                         }
[16:59:35.672]                         else {
[16:59:35.672]                           version <- NULL
[16:59:35.672]                         }
[16:59:35.672]                         if (!has_future || version < "1.8.0") {
[16:59:35.672]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.672]                             "", base::R.version$version.string), 
[16:59:35.672]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.672]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.672]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.672]                               "release", "version")], collapse = " "), 
[16:59:35.672]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.672]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.672]                             info)
[16:59:35.672]                           info <- base::paste(info, collapse = "; ")
[16:59:35.672]                           if (!has_future) {
[16:59:35.672]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.672]                               info)
[16:59:35.672]                           }
[16:59:35.672]                           else {
[16:59:35.672]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.672]                               info, version)
[16:59:35.672]                           }
[16:59:35.672]                           base::stop(msg)
[16:59:35.672]                         }
[16:59:35.672]                       })
[16:59:35.672]                     }
[16:59:35.672]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.672]                     base::options(mc.cores = 1L)
[16:59:35.672]                   }
[16:59:35.672]                   ...future.strategy.old <- future::plan("list")
[16:59:35.672]                   options(future.plan = NULL)
[16:59:35.672]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.672]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.672]                 }
[16:59:35.672]                 ...future.workdir <- getwd()
[16:59:35.672]             }
[16:59:35.672]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.672]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.672]         }
[16:59:35.672]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.672]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.672]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.672]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.672]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.672]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.672]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.672]             base::names(...future.oldOptions))
[16:59:35.672]     }
[16:59:35.672]     if (FALSE) {
[16:59:35.672]     }
[16:59:35.672]     else {
[16:59:35.672]         if (TRUE) {
[16:59:35.672]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.672]                 open = "w")
[16:59:35.672]         }
[16:59:35.672]         else {
[16:59:35.672]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.672]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.672]         }
[16:59:35.672]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.672]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.672]             base::sink(type = "output", split = FALSE)
[16:59:35.672]             base::close(...future.stdout)
[16:59:35.672]         }, add = TRUE)
[16:59:35.672]     }
[16:59:35.672]     ...future.frame <- base::sys.nframe()
[16:59:35.672]     ...future.conditions <- base::list()
[16:59:35.672]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.672]     if (FALSE) {
[16:59:35.672]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.672]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.672]     }
[16:59:35.672]     ...future.result <- base::tryCatch({
[16:59:35.672]         base::withCallingHandlers({
[16:59:35.672]             ...future.value <- base::withVisible(base::local({
[16:59:35.672]                 withCallingHandlers({
[16:59:35.672]                   {
[16:59:35.672]                     do.call(function(...) {
[16:59:35.672]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.672]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.672]                         ...future.globals.maxSize)) {
[16:59:35.672]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.672]                         on.exit(options(oopts), add = TRUE)
[16:59:35.672]                       }
[16:59:35.672]                       {
[16:59:35.672]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.672]                           FUN = function(jj) {
[16:59:35.672]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.672]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.672]                           })
[16:59:35.672]                       }
[16:59:35.672]                     }, args = future.call.arguments)
[16:59:35.672]                   }
[16:59:35.672]                 }, immediateCondition = function(cond) {
[16:59:35.672]                   save_rds <- function (object, pathname, ...) 
[16:59:35.672]                   {
[16:59:35.672]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.672]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.672]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.672]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.672]                         fi_tmp[["mtime"]])
[16:59:35.672]                     }
[16:59:35.672]                     tryCatch({
[16:59:35.672]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.672]                     }, error = function(ex) {
[16:59:35.672]                       msg <- conditionMessage(ex)
[16:59:35.672]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.672]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.672]                         fi_tmp[["mtime"]], msg)
[16:59:35.672]                       ex$message <- msg
[16:59:35.672]                       stop(ex)
[16:59:35.672]                     })
[16:59:35.672]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.672]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.672]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.672]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.672]                       fi <- file.info(pathname)
[16:59:35.672]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.672]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.672]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.672]                         fi[["size"]], fi[["mtime"]])
[16:59:35.672]                       stop(msg)
[16:59:35.672]                     }
[16:59:35.672]                     invisible(pathname)
[16:59:35.672]                   }
[16:59:35.672]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.672]                     rootPath = tempdir()) 
[16:59:35.672]                   {
[16:59:35.672]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.672]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.672]                       tmpdir = path, fileext = ".rds")
[16:59:35.672]                     save_rds(obj, file)
[16:59:35.672]                   }
[16:59:35.672]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.672]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.672]                   {
[16:59:35.672]                     inherits <- base::inherits
[16:59:35.672]                     invokeRestart <- base::invokeRestart
[16:59:35.672]                     is.null <- base::is.null
[16:59:35.672]                     muffled <- FALSE
[16:59:35.672]                     if (inherits(cond, "message")) {
[16:59:35.672]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.672]                       if (muffled) 
[16:59:35.672]                         invokeRestart("muffleMessage")
[16:59:35.672]                     }
[16:59:35.672]                     else if (inherits(cond, "warning")) {
[16:59:35.672]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.672]                       if (muffled) 
[16:59:35.672]                         invokeRestart("muffleWarning")
[16:59:35.672]                     }
[16:59:35.672]                     else if (inherits(cond, "condition")) {
[16:59:35.672]                       if (!is.null(pattern)) {
[16:59:35.672]                         computeRestarts <- base::computeRestarts
[16:59:35.672]                         grepl <- base::grepl
[16:59:35.672]                         restarts <- computeRestarts(cond)
[16:59:35.672]                         for (restart in restarts) {
[16:59:35.672]                           name <- restart$name
[16:59:35.672]                           if (is.null(name)) 
[16:59:35.672]                             next
[16:59:35.672]                           if (!grepl(pattern, name)) 
[16:59:35.672]                             next
[16:59:35.672]                           invokeRestart(restart)
[16:59:35.672]                           muffled <- TRUE
[16:59:35.672]                           break
[16:59:35.672]                         }
[16:59:35.672]                       }
[16:59:35.672]                     }
[16:59:35.672]                     invisible(muffled)
[16:59:35.672]                   }
[16:59:35.672]                   muffleCondition(cond)
[16:59:35.672]                 })
[16:59:35.672]             }))
[16:59:35.672]             future::FutureResult(value = ...future.value$value, 
[16:59:35.672]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.672]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.672]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.672]                     ...future.globalenv.names))
[16:59:35.672]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.672]         }, condition = base::local({
[16:59:35.672]             c <- base::c
[16:59:35.672]             inherits <- base::inherits
[16:59:35.672]             invokeRestart <- base::invokeRestart
[16:59:35.672]             length <- base::length
[16:59:35.672]             list <- base::list
[16:59:35.672]             seq.int <- base::seq.int
[16:59:35.672]             signalCondition <- base::signalCondition
[16:59:35.672]             sys.calls <- base::sys.calls
[16:59:35.672]             `[[` <- base::`[[`
[16:59:35.672]             `+` <- base::`+`
[16:59:35.672]             `<<-` <- base::`<<-`
[16:59:35.672]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.672]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.672]                   3L)]
[16:59:35.672]             }
[16:59:35.672]             function(cond) {
[16:59:35.672]                 is_error <- inherits(cond, "error")
[16:59:35.672]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.672]                   NULL)
[16:59:35.672]                 if (is_error) {
[16:59:35.672]                   sessionInformation <- function() {
[16:59:35.672]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.672]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.672]                       search = base::search(), system = base::Sys.info())
[16:59:35.672]                   }
[16:59:35.672]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.672]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.672]                     cond$call), session = sessionInformation(), 
[16:59:35.672]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.672]                   signalCondition(cond)
[16:59:35.672]                 }
[16:59:35.672]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.672]                 "immediateCondition"))) {
[16:59:35.672]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.672]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.672]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.672]                   if (TRUE && !signal) {
[16:59:35.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.672]                     {
[16:59:35.672]                       inherits <- base::inherits
[16:59:35.672]                       invokeRestart <- base::invokeRestart
[16:59:35.672]                       is.null <- base::is.null
[16:59:35.672]                       muffled <- FALSE
[16:59:35.672]                       if (inherits(cond, "message")) {
[16:59:35.672]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.672]                         if (muffled) 
[16:59:35.672]                           invokeRestart("muffleMessage")
[16:59:35.672]                       }
[16:59:35.672]                       else if (inherits(cond, "warning")) {
[16:59:35.672]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.672]                         if (muffled) 
[16:59:35.672]                           invokeRestart("muffleWarning")
[16:59:35.672]                       }
[16:59:35.672]                       else if (inherits(cond, "condition")) {
[16:59:35.672]                         if (!is.null(pattern)) {
[16:59:35.672]                           computeRestarts <- base::computeRestarts
[16:59:35.672]                           grepl <- base::grepl
[16:59:35.672]                           restarts <- computeRestarts(cond)
[16:59:35.672]                           for (restart in restarts) {
[16:59:35.672]                             name <- restart$name
[16:59:35.672]                             if (is.null(name)) 
[16:59:35.672]                               next
[16:59:35.672]                             if (!grepl(pattern, name)) 
[16:59:35.672]                               next
[16:59:35.672]                             invokeRestart(restart)
[16:59:35.672]                             muffled <- TRUE
[16:59:35.672]                             break
[16:59:35.672]                           }
[16:59:35.672]                         }
[16:59:35.672]                       }
[16:59:35.672]                       invisible(muffled)
[16:59:35.672]                     }
[16:59:35.672]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.672]                   }
[16:59:35.672]                 }
[16:59:35.672]                 else {
[16:59:35.672]                   if (TRUE) {
[16:59:35.672]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.672]                     {
[16:59:35.672]                       inherits <- base::inherits
[16:59:35.672]                       invokeRestart <- base::invokeRestart
[16:59:35.672]                       is.null <- base::is.null
[16:59:35.672]                       muffled <- FALSE
[16:59:35.672]                       if (inherits(cond, "message")) {
[16:59:35.672]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.672]                         if (muffled) 
[16:59:35.672]                           invokeRestart("muffleMessage")
[16:59:35.672]                       }
[16:59:35.672]                       else if (inherits(cond, "warning")) {
[16:59:35.672]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.672]                         if (muffled) 
[16:59:35.672]                           invokeRestart("muffleWarning")
[16:59:35.672]                       }
[16:59:35.672]                       else if (inherits(cond, "condition")) {
[16:59:35.672]                         if (!is.null(pattern)) {
[16:59:35.672]                           computeRestarts <- base::computeRestarts
[16:59:35.672]                           grepl <- base::grepl
[16:59:35.672]                           restarts <- computeRestarts(cond)
[16:59:35.672]                           for (restart in restarts) {
[16:59:35.672]                             name <- restart$name
[16:59:35.672]                             if (is.null(name)) 
[16:59:35.672]                               next
[16:59:35.672]                             if (!grepl(pattern, name)) 
[16:59:35.672]                               next
[16:59:35.672]                             invokeRestart(restart)
[16:59:35.672]                             muffled <- TRUE
[16:59:35.672]                             break
[16:59:35.672]                           }
[16:59:35.672]                         }
[16:59:35.672]                       }
[16:59:35.672]                       invisible(muffled)
[16:59:35.672]                     }
[16:59:35.672]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.672]                   }
[16:59:35.672]                 }
[16:59:35.672]             }
[16:59:35.672]         }))
[16:59:35.672]     }, error = function(ex) {
[16:59:35.672]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.672]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.672]                 ...future.rng), started = ...future.startTime, 
[16:59:35.672]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.672]             version = "1.8"), class = "FutureResult")
[16:59:35.672]     }, finally = {
[16:59:35.672]         if (!identical(...future.workdir, getwd())) 
[16:59:35.672]             setwd(...future.workdir)
[16:59:35.672]         {
[16:59:35.672]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.672]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.672]             }
[16:59:35.672]             base::options(...future.oldOptions)
[16:59:35.672]             if (.Platform$OS.type == "windows") {
[16:59:35.672]                 old_names <- names(...future.oldEnvVars)
[16:59:35.672]                 envs <- base::Sys.getenv()
[16:59:35.672]                 names <- names(envs)
[16:59:35.672]                 common <- intersect(names, old_names)
[16:59:35.672]                 added <- setdiff(names, old_names)
[16:59:35.672]                 removed <- setdiff(old_names, names)
[16:59:35.672]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.672]                   envs[common]]
[16:59:35.672]                 NAMES <- toupper(changed)
[16:59:35.672]                 args <- list()
[16:59:35.672]                 for (kk in seq_along(NAMES)) {
[16:59:35.672]                   name <- changed[[kk]]
[16:59:35.672]                   NAME <- NAMES[[kk]]
[16:59:35.672]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.672]                     next
[16:59:35.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.672]                 }
[16:59:35.672]                 NAMES <- toupper(added)
[16:59:35.672]                 for (kk in seq_along(NAMES)) {
[16:59:35.672]                   name <- added[[kk]]
[16:59:35.672]                   NAME <- NAMES[[kk]]
[16:59:35.672]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.672]                     next
[16:59:35.672]                   args[[name]] <- ""
[16:59:35.672]                 }
[16:59:35.672]                 NAMES <- toupper(removed)
[16:59:35.672]                 for (kk in seq_along(NAMES)) {
[16:59:35.672]                   name <- removed[[kk]]
[16:59:35.672]                   NAME <- NAMES[[kk]]
[16:59:35.672]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.672]                     next
[16:59:35.672]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.672]                 }
[16:59:35.672]                 if (length(args) > 0) 
[16:59:35.672]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.672]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.672]             }
[16:59:35.672]             else {
[16:59:35.672]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.672]             }
[16:59:35.672]             {
[16:59:35.672]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.672]                   0L) {
[16:59:35.672]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.672]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.672]                   base::options(opts)
[16:59:35.672]                 }
[16:59:35.672]                 {
[16:59:35.672]                   {
[16:59:35.672]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.672]                     NULL
[16:59:35.672]                   }
[16:59:35.672]                   options(future.plan = NULL)
[16:59:35.672]                   if (is.na(NA_character_)) 
[16:59:35.672]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.672]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.672]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.672]                     .init = FALSE)
[16:59:35.672]                 }
[16:59:35.672]             }
[16:59:35.672]         }
[16:59:35.672]     })
[16:59:35.672]     if (TRUE) {
[16:59:35.672]         base::sink(type = "output", split = FALSE)
[16:59:35.672]         if (TRUE) {
[16:59:35.672]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.672]         }
[16:59:35.672]         else {
[16:59:35.672]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.672]         }
[16:59:35.672]         base::close(...future.stdout)
[16:59:35.672]         ...future.stdout <- NULL
[16:59:35.672]     }
[16:59:35.672]     ...future.result$conditions <- ...future.conditions
[16:59:35.672]     ...future.result$finished <- base::Sys.time()
[16:59:35.672]     ...future.result
[16:59:35.672] }
[16:59:35.674] assign_globals() ...
[16:59:35.674] List of 5
[16:59:35.674]  $ ...future.FUN            :function (object, ...)  
[16:59:35.674]  $ future.call.arguments    : list()
[16:59:35.674]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.674]  $ ...future.elements_ii    :List of 1
[16:59:35.674]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.674]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.674]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.674]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.674]  $ ...future.seeds_ii       : NULL
[16:59:35.674]  $ ...future.globals.maxSize: NULL
[16:59:35.674]  - attr(*, "where")=List of 5
[16:59:35.674]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.674]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.674]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.674]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.674]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.674]  - attr(*, "resolved")= logi FALSE
[16:59:35.674]  - attr(*, "total_size")= num 1240
[16:59:35.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.674]  - attr(*, "already-done")= logi TRUE
[16:59:35.681] - copied ‘...future.FUN’ to environment
[16:59:35.681] - copied ‘future.call.arguments’ to environment
[16:59:35.681] - copied ‘...future.elements_ii’ to environment
[16:59:35.681] - copied ‘...future.seeds_ii’ to environment
[16:59:35.681] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.681] assign_globals() ... done
[16:59:35.681] requestCore(): workers = 2
[16:59:35.684] MulticoreFuture started
[16:59:35.684] - Launch lazy future ... done
[16:59:35.684] run() for ‘MulticoreFuture’ ... done
[16:59:35.684] Created future:
[16:59:35.685] plan(): Setting new future strategy stack:
[16:59:35.685] List of future strategies:
[16:59:35.685] 1. sequential:
[16:59:35.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.685]    - tweaked: FALSE
[16:59:35.685]    - call: NULL
[16:59:35.686] plan(): nbrOfWorkers() = 1
[16:59:35.690] plan(): Setting new future strategy stack:
[16:59:35.690] List of future strategies:
[16:59:35.690] 1. multicore:
[16:59:35.690]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.690]    - tweaked: FALSE
[16:59:35.690]    - call: plan(strategy)
[16:59:35.696] plan(): nbrOfWorkers() = 2
[16:59:35.685] MulticoreFuture:
[16:59:35.685] Label: ‘future_by-1’
[16:59:35.685] Expression:
[16:59:35.685] {
[16:59:35.685]     do.call(function(...) {
[16:59:35.685]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.685]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.685]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.685]             on.exit(options(oopts), add = TRUE)
[16:59:35.685]         }
[16:59:35.685]         {
[16:59:35.685]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.685]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.685]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.685]             })
[16:59:35.685]         }
[16:59:35.685]     }, args = future.call.arguments)
[16:59:35.685] }
[16:59:35.685] Lazy evaluation: FALSE
[16:59:35.685] Asynchronous evaluation: TRUE
[16:59:35.685] Local evaluation: TRUE
[16:59:35.685] Environment: 0x56205310b638
[16:59:35.685] Capture standard output: TRUE
[16:59:35.685] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.685] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.685] Packages: <none>
[16:59:35.685] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.685] Resolved: TRUE
[16:59:35.685] Value: <not collected>
[16:59:35.685] Conditions captured: <none>
[16:59:35.685] Early signaling: FALSE
[16:59:35.685] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.685] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.697] Chunk #1 of 2 ... DONE
[16:59:35.697] Chunk #2 of 2 ...
[16:59:35.697]  - Finding globals in 'X' for chunk #2 ...
[16:59:35.697] getGlobalsAndPackages() ...
[16:59:35.697] Searching for globals...
[16:59:35.698] 
[16:59:35.698] Searching for globals ... DONE
[16:59:35.698] - globals: [0] <none>
[16:59:35.699] getGlobalsAndPackages() ... DONE
[16:59:35.699]    + additional globals found: [n=0] 
[16:59:35.699]    + additional namespaces needed: [n=0] 
[16:59:35.699]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:35.699]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.699]  - seeds: <none>
[16:59:35.699]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.700] getGlobalsAndPackages() ...
[16:59:35.700] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.700] Resolving globals: FALSE
[16:59:35.700] Tweak future expression to call with '...' arguments ...
[16:59:35.700] {
[16:59:35.700]     do.call(function(...) {
[16:59:35.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.700]             on.exit(options(oopts), add = TRUE)
[16:59:35.700]         }
[16:59:35.700]         {
[16:59:35.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.700]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.700]             })
[16:59:35.700]         }
[16:59:35.700]     }, args = future.call.arguments)
[16:59:35.700] }
[16:59:35.701] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.705] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.705] 
[16:59:35.706] getGlobalsAndPackages() ... DONE
[16:59:35.707] run() for ‘Future’ ...
[16:59:35.707] - state: ‘created’
[16:59:35.708] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.714]   - Field: ‘label’
[16:59:35.715]   - Field: ‘local’
[16:59:35.715]   - Field: ‘owner’
[16:59:35.715]   - Field: ‘envir’
[16:59:35.715]   - Field: ‘workers’
[16:59:35.716]   - Field: ‘packages’
[16:59:35.716]   - Field: ‘gc’
[16:59:35.716]   - Field: ‘job’
[16:59:35.716]   - Field: ‘conditions’
[16:59:35.717]   - Field: ‘expr’
[16:59:35.717]   - Field: ‘uuid’
[16:59:35.717]   - Field: ‘seed’
[16:59:35.717]   - Field: ‘version’
[16:59:35.718]   - Field: ‘result’
[16:59:35.718]   - Field: ‘asynchronous’
[16:59:35.718]   - Field: ‘calls’
[16:59:35.718]   - Field: ‘globals’
[16:59:35.718]   - Field: ‘stdout’
[16:59:35.718]   - Field: ‘earlySignal’
[16:59:35.719]   - Field: ‘lazy’
[16:59:35.719]   - Field: ‘state’
[16:59:35.719] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.719] - Launch lazy future ...
[16:59:35.719] Packages needed by the future expression (n = 0): <none>
[16:59:35.720] Packages needed by future strategies (n = 0): <none>
[16:59:35.721] {
[16:59:35.721]     {
[16:59:35.721]         {
[16:59:35.721]             ...future.startTime <- base::Sys.time()
[16:59:35.721]             {
[16:59:35.721]                 {
[16:59:35.721]                   {
[16:59:35.721]                     {
[16:59:35.721]                       base::local({
[16:59:35.721]                         has_future <- base::requireNamespace("future", 
[16:59:35.721]                           quietly = TRUE)
[16:59:35.721]                         if (has_future) {
[16:59:35.721]                           ns <- base::getNamespace("future")
[16:59:35.721]                           version <- ns[[".package"]][["version"]]
[16:59:35.721]                           if (is.null(version)) 
[16:59:35.721]                             version <- utils::packageVersion("future")
[16:59:35.721]                         }
[16:59:35.721]                         else {
[16:59:35.721]                           version <- NULL
[16:59:35.721]                         }
[16:59:35.721]                         if (!has_future || version < "1.8.0") {
[16:59:35.721]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.721]                             "", base::R.version$version.string), 
[16:59:35.721]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.721]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.721]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.721]                               "release", "version")], collapse = " "), 
[16:59:35.721]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.721]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.721]                             info)
[16:59:35.721]                           info <- base::paste(info, collapse = "; ")
[16:59:35.721]                           if (!has_future) {
[16:59:35.721]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.721]                               info)
[16:59:35.721]                           }
[16:59:35.721]                           else {
[16:59:35.721]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.721]                               info, version)
[16:59:35.721]                           }
[16:59:35.721]                           base::stop(msg)
[16:59:35.721]                         }
[16:59:35.721]                       })
[16:59:35.721]                     }
[16:59:35.721]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.721]                     base::options(mc.cores = 1L)
[16:59:35.721]                   }
[16:59:35.721]                   ...future.strategy.old <- future::plan("list")
[16:59:35.721]                   options(future.plan = NULL)
[16:59:35.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.721]                 }
[16:59:35.721]                 ...future.workdir <- getwd()
[16:59:35.721]             }
[16:59:35.721]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.721]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.721]         }
[16:59:35.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.721]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.721]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.721]             base::names(...future.oldOptions))
[16:59:35.721]     }
[16:59:35.721]     if (FALSE) {
[16:59:35.721]     }
[16:59:35.721]     else {
[16:59:35.721]         if (TRUE) {
[16:59:35.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.721]                 open = "w")
[16:59:35.721]         }
[16:59:35.721]         else {
[16:59:35.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.721]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.721]         }
[16:59:35.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.721]             base::sink(type = "output", split = FALSE)
[16:59:35.721]             base::close(...future.stdout)
[16:59:35.721]         }, add = TRUE)
[16:59:35.721]     }
[16:59:35.721]     ...future.frame <- base::sys.nframe()
[16:59:35.721]     ...future.conditions <- base::list()
[16:59:35.721]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.721]     if (FALSE) {
[16:59:35.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.721]     }
[16:59:35.721]     ...future.result <- base::tryCatch({
[16:59:35.721]         base::withCallingHandlers({
[16:59:35.721]             ...future.value <- base::withVisible(base::local({
[16:59:35.721]                 withCallingHandlers({
[16:59:35.721]                   {
[16:59:35.721]                     do.call(function(...) {
[16:59:35.721]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.721]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.721]                         ...future.globals.maxSize)) {
[16:59:35.721]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.721]                         on.exit(options(oopts), add = TRUE)
[16:59:35.721]                       }
[16:59:35.721]                       {
[16:59:35.721]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.721]                           FUN = function(jj) {
[16:59:35.721]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.721]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.721]                           })
[16:59:35.721]                       }
[16:59:35.721]                     }, args = future.call.arguments)
[16:59:35.721]                   }
[16:59:35.721]                 }, immediateCondition = function(cond) {
[16:59:35.721]                   save_rds <- function (object, pathname, ...) 
[16:59:35.721]                   {
[16:59:35.721]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.721]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.721]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.721]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.721]                         fi_tmp[["mtime"]])
[16:59:35.721]                     }
[16:59:35.721]                     tryCatch({
[16:59:35.721]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.721]                     }, error = function(ex) {
[16:59:35.721]                       msg <- conditionMessage(ex)
[16:59:35.721]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.721]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.721]                         fi_tmp[["mtime"]], msg)
[16:59:35.721]                       ex$message <- msg
[16:59:35.721]                       stop(ex)
[16:59:35.721]                     })
[16:59:35.721]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.721]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.721]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.721]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.721]                       fi <- file.info(pathname)
[16:59:35.721]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.721]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.721]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.721]                         fi[["size"]], fi[["mtime"]])
[16:59:35.721]                       stop(msg)
[16:59:35.721]                     }
[16:59:35.721]                     invisible(pathname)
[16:59:35.721]                   }
[16:59:35.721]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.721]                     rootPath = tempdir()) 
[16:59:35.721]                   {
[16:59:35.721]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.721]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.721]                       tmpdir = path, fileext = ".rds")
[16:59:35.721]                     save_rds(obj, file)
[16:59:35.721]                   }
[16:59:35.721]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.721]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.721]                   {
[16:59:35.721]                     inherits <- base::inherits
[16:59:35.721]                     invokeRestart <- base::invokeRestart
[16:59:35.721]                     is.null <- base::is.null
[16:59:35.721]                     muffled <- FALSE
[16:59:35.721]                     if (inherits(cond, "message")) {
[16:59:35.721]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.721]                       if (muffled) 
[16:59:35.721]                         invokeRestart("muffleMessage")
[16:59:35.721]                     }
[16:59:35.721]                     else if (inherits(cond, "warning")) {
[16:59:35.721]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.721]                       if (muffled) 
[16:59:35.721]                         invokeRestart("muffleWarning")
[16:59:35.721]                     }
[16:59:35.721]                     else if (inherits(cond, "condition")) {
[16:59:35.721]                       if (!is.null(pattern)) {
[16:59:35.721]                         computeRestarts <- base::computeRestarts
[16:59:35.721]                         grepl <- base::grepl
[16:59:35.721]                         restarts <- computeRestarts(cond)
[16:59:35.721]                         for (restart in restarts) {
[16:59:35.721]                           name <- restart$name
[16:59:35.721]                           if (is.null(name)) 
[16:59:35.721]                             next
[16:59:35.721]                           if (!grepl(pattern, name)) 
[16:59:35.721]                             next
[16:59:35.721]                           invokeRestart(restart)
[16:59:35.721]                           muffled <- TRUE
[16:59:35.721]                           break
[16:59:35.721]                         }
[16:59:35.721]                       }
[16:59:35.721]                     }
[16:59:35.721]                     invisible(muffled)
[16:59:35.721]                   }
[16:59:35.721]                   muffleCondition(cond)
[16:59:35.721]                 })
[16:59:35.721]             }))
[16:59:35.721]             future::FutureResult(value = ...future.value$value, 
[16:59:35.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.721]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.721]                     ...future.globalenv.names))
[16:59:35.721]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.721]         }, condition = base::local({
[16:59:35.721]             c <- base::c
[16:59:35.721]             inherits <- base::inherits
[16:59:35.721]             invokeRestart <- base::invokeRestart
[16:59:35.721]             length <- base::length
[16:59:35.721]             list <- base::list
[16:59:35.721]             seq.int <- base::seq.int
[16:59:35.721]             signalCondition <- base::signalCondition
[16:59:35.721]             sys.calls <- base::sys.calls
[16:59:35.721]             `[[` <- base::`[[`
[16:59:35.721]             `+` <- base::`+`
[16:59:35.721]             `<<-` <- base::`<<-`
[16:59:35.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.721]                   3L)]
[16:59:35.721]             }
[16:59:35.721]             function(cond) {
[16:59:35.721]                 is_error <- inherits(cond, "error")
[16:59:35.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.721]                   NULL)
[16:59:35.721]                 if (is_error) {
[16:59:35.721]                   sessionInformation <- function() {
[16:59:35.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.721]                       search = base::search(), system = base::Sys.info())
[16:59:35.721]                   }
[16:59:35.721]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.721]                     cond$call), session = sessionInformation(), 
[16:59:35.721]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.721]                   signalCondition(cond)
[16:59:35.721]                 }
[16:59:35.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.721]                 "immediateCondition"))) {
[16:59:35.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.721]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.721]                   if (TRUE && !signal) {
[16:59:35.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.721]                     {
[16:59:35.721]                       inherits <- base::inherits
[16:59:35.721]                       invokeRestart <- base::invokeRestart
[16:59:35.721]                       is.null <- base::is.null
[16:59:35.721]                       muffled <- FALSE
[16:59:35.721]                       if (inherits(cond, "message")) {
[16:59:35.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.721]                         if (muffled) 
[16:59:35.721]                           invokeRestart("muffleMessage")
[16:59:35.721]                       }
[16:59:35.721]                       else if (inherits(cond, "warning")) {
[16:59:35.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.721]                         if (muffled) 
[16:59:35.721]                           invokeRestart("muffleWarning")
[16:59:35.721]                       }
[16:59:35.721]                       else if (inherits(cond, "condition")) {
[16:59:35.721]                         if (!is.null(pattern)) {
[16:59:35.721]                           computeRestarts <- base::computeRestarts
[16:59:35.721]                           grepl <- base::grepl
[16:59:35.721]                           restarts <- computeRestarts(cond)
[16:59:35.721]                           for (restart in restarts) {
[16:59:35.721]                             name <- restart$name
[16:59:35.721]                             if (is.null(name)) 
[16:59:35.721]                               next
[16:59:35.721]                             if (!grepl(pattern, name)) 
[16:59:35.721]                               next
[16:59:35.721]                             invokeRestart(restart)
[16:59:35.721]                             muffled <- TRUE
[16:59:35.721]                             break
[16:59:35.721]                           }
[16:59:35.721]                         }
[16:59:35.721]                       }
[16:59:35.721]                       invisible(muffled)
[16:59:35.721]                     }
[16:59:35.721]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.721]                   }
[16:59:35.721]                 }
[16:59:35.721]                 else {
[16:59:35.721]                   if (TRUE) {
[16:59:35.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.721]                     {
[16:59:35.721]                       inherits <- base::inherits
[16:59:35.721]                       invokeRestart <- base::invokeRestart
[16:59:35.721]                       is.null <- base::is.null
[16:59:35.721]                       muffled <- FALSE
[16:59:35.721]                       if (inherits(cond, "message")) {
[16:59:35.721]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.721]                         if (muffled) 
[16:59:35.721]                           invokeRestart("muffleMessage")
[16:59:35.721]                       }
[16:59:35.721]                       else if (inherits(cond, "warning")) {
[16:59:35.721]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.721]                         if (muffled) 
[16:59:35.721]                           invokeRestart("muffleWarning")
[16:59:35.721]                       }
[16:59:35.721]                       else if (inherits(cond, "condition")) {
[16:59:35.721]                         if (!is.null(pattern)) {
[16:59:35.721]                           computeRestarts <- base::computeRestarts
[16:59:35.721]                           grepl <- base::grepl
[16:59:35.721]                           restarts <- computeRestarts(cond)
[16:59:35.721]                           for (restart in restarts) {
[16:59:35.721]                             name <- restart$name
[16:59:35.721]                             if (is.null(name)) 
[16:59:35.721]                               next
[16:59:35.721]                             if (!grepl(pattern, name)) 
[16:59:35.721]                               next
[16:59:35.721]                             invokeRestart(restart)
[16:59:35.721]                             muffled <- TRUE
[16:59:35.721]                             break
[16:59:35.721]                           }
[16:59:35.721]                         }
[16:59:35.721]                       }
[16:59:35.721]                       invisible(muffled)
[16:59:35.721]                     }
[16:59:35.721]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.721]                   }
[16:59:35.721]                 }
[16:59:35.721]             }
[16:59:35.721]         }))
[16:59:35.721]     }, error = function(ex) {
[16:59:35.721]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.721]                 ...future.rng), started = ...future.startTime, 
[16:59:35.721]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.721]             version = "1.8"), class = "FutureResult")
[16:59:35.721]     }, finally = {
[16:59:35.721]         if (!identical(...future.workdir, getwd())) 
[16:59:35.721]             setwd(...future.workdir)
[16:59:35.721]         {
[16:59:35.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.721]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.721]             }
[16:59:35.721]             base::options(...future.oldOptions)
[16:59:35.721]             if (.Platform$OS.type == "windows") {
[16:59:35.721]                 old_names <- names(...future.oldEnvVars)
[16:59:35.721]                 envs <- base::Sys.getenv()
[16:59:35.721]                 names <- names(envs)
[16:59:35.721]                 common <- intersect(names, old_names)
[16:59:35.721]                 added <- setdiff(names, old_names)
[16:59:35.721]                 removed <- setdiff(old_names, names)
[16:59:35.721]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.721]                   envs[common]]
[16:59:35.721]                 NAMES <- toupper(changed)
[16:59:35.721]                 args <- list()
[16:59:35.721]                 for (kk in seq_along(NAMES)) {
[16:59:35.721]                   name <- changed[[kk]]
[16:59:35.721]                   NAME <- NAMES[[kk]]
[16:59:35.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.721]                     next
[16:59:35.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.721]                 }
[16:59:35.721]                 NAMES <- toupper(added)
[16:59:35.721]                 for (kk in seq_along(NAMES)) {
[16:59:35.721]                   name <- added[[kk]]
[16:59:35.721]                   NAME <- NAMES[[kk]]
[16:59:35.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.721]                     next
[16:59:35.721]                   args[[name]] <- ""
[16:59:35.721]                 }
[16:59:35.721]                 NAMES <- toupper(removed)
[16:59:35.721]                 for (kk in seq_along(NAMES)) {
[16:59:35.721]                   name <- removed[[kk]]
[16:59:35.721]                   NAME <- NAMES[[kk]]
[16:59:35.721]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.721]                     next
[16:59:35.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.721]                 }
[16:59:35.721]                 if (length(args) > 0) 
[16:59:35.721]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.721]             }
[16:59:35.721]             else {
[16:59:35.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.721]             }
[16:59:35.721]             {
[16:59:35.721]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.721]                   0L) {
[16:59:35.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.721]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.721]                   base::options(opts)
[16:59:35.721]                 }
[16:59:35.721]                 {
[16:59:35.721]                   {
[16:59:35.721]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.721]                     NULL
[16:59:35.721]                   }
[16:59:35.721]                   options(future.plan = NULL)
[16:59:35.721]                   if (is.na(NA_character_)) 
[16:59:35.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.721]                     .init = FALSE)
[16:59:35.721]                 }
[16:59:35.721]             }
[16:59:35.721]         }
[16:59:35.721]     })
[16:59:35.721]     if (TRUE) {
[16:59:35.721]         base::sink(type = "output", split = FALSE)
[16:59:35.721]         if (TRUE) {
[16:59:35.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.721]         }
[16:59:35.721]         else {
[16:59:35.721]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.721]         }
[16:59:35.721]         base::close(...future.stdout)
[16:59:35.721]         ...future.stdout <- NULL
[16:59:35.721]     }
[16:59:35.721]     ...future.result$conditions <- ...future.conditions
[16:59:35.721]     ...future.result$finished <- base::Sys.time()
[16:59:35.721]     ...future.result
[16:59:35.721] }
[16:59:35.723] assign_globals() ...
[16:59:35.724] List of 5
[16:59:35.724]  $ ...future.FUN            :function (object, ...)  
[16:59:35.724]  $ future.call.arguments    : list()
[16:59:35.724]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.724]  $ ...future.elements_ii    :List of 2
[16:59:35.724]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.724]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.724]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.724]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:35.724]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.724]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.724]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.724]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:35.724]  $ ...future.seeds_ii       : NULL
[16:59:35.724]  $ ...future.globals.maxSize: NULL
[16:59:35.724]  - attr(*, "where")=List of 5
[16:59:35.724]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.724]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.724]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.724]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.724]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.724]  - attr(*, "resolved")= logi FALSE
[16:59:35.724]  - attr(*, "total_size")= num 1240
[16:59:35.724]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.724]  - attr(*, "already-done")= logi TRUE
[16:59:35.733] - copied ‘...future.FUN’ to environment
[16:59:35.733] - copied ‘future.call.arguments’ to environment
[16:59:35.733] - copied ‘...future.elements_ii’ to environment
[16:59:35.733] - copied ‘...future.seeds_ii’ to environment
[16:59:35.733] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.734] assign_globals() ... done
[16:59:35.734] requestCore(): workers = 2
[16:59:35.736] MulticoreFuture started
[16:59:35.736] - Launch lazy future ... done
[16:59:35.736] run() for ‘MulticoreFuture’ ... done
[16:59:35.737] Created future:
[16:59:35.737] plan(): Setting new future strategy stack:
[16:59:35.737] List of future strategies:
[16:59:35.737] 1. sequential:
[16:59:35.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.737]    - tweaked: FALSE
[16:59:35.737]    - call: NULL
[16:59:35.738] plan(): nbrOfWorkers() = 1
[16:59:35.742] plan(): Setting new future strategy stack:
[16:59:35.742] List of future strategies:
[16:59:35.742] 1. multicore:
[16:59:35.742]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.742]    - tweaked: FALSE
[16:59:35.742]    - call: plan(strategy)
[16:59:35.737] MulticoreFuture:
[16:59:35.737] Label: ‘future_by-2’
[16:59:35.737] Expression:
[16:59:35.737] {
[16:59:35.737]     do.call(function(...) {
[16:59:35.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.737]             on.exit(options(oopts), add = TRUE)
[16:59:35.737]         }
[16:59:35.737]         {
[16:59:35.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.737]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.737]             })
[16:59:35.737]         }
[16:59:35.737]     }, args = future.call.arguments)
[16:59:35.737] }
[16:59:35.737] Lazy evaluation: FALSE
[16:59:35.737] Asynchronous evaluation: TRUE
[16:59:35.737] Local evaluation: TRUE
[16:59:35.737] Environment: 0x56205310b638
[16:59:35.737] Capture standard output: TRUE
[16:59:35.737] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.737] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.737] Packages: <none>
[16:59:35.737] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.737] Resolved: FALSE
[16:59:35.737] Value: <not collected>
[16:59:35.737] Conditions captured: <none>
[16:59:35.737] Early signaling: FALSE
[16:59:35.737] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.737] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.750] Chunk #2 of 2 ... DONE
[16:59:35.750] Launching 2 futures (chunks) ... DONE
[16:59:35.751] Resolving 2 futures (chunks) ...
[16:59:35.751] resolve() on list ...
[16:59:35.751]  recursive: 0
[16:59:35.751]  length: 2
[16:59:35.751] 
[16:59:35.751] Future #1
[16:59:35.752] result() for MulticoreFuture ...
[16:59:35.752] plan(): nbrOfWorkers() = 2
[16:59:35.753] result() for MulticoreFuture ...
[16:59:35.753] result() for MulticoreFuture ... done
[16:59:35.753] result() for MulticoreFuture ... done
[16:59:35.753] result() for MulticoreFuture ...
[16:59:35.753] result() for MulticoreFuture ... done
[16:59:35.753] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:35.753] - nx: 2
[16:59:35.753] - relay: TRUE
[16:59:35.754] - stdout: TRUE
[16:59:35.756] - signal: TRUE
[16:59:35.756] - resignal: FALSE
[16:59:35.757] - force: TRUE
[16:59:35.757] - relayed: [n=2] FALSE, FALSE
[16:59:35.757] - queued futures: [n=2] FALSE, FALSE
[16:59:35.758]  - until=1
[16:59:35.758]  - relaying element #1
[16:59:35.758] result() for MulticoreFuture ...
[16:59:35.759] result() for MulticoreFuture ... done
[16:59:35.759] result() for MulticoreFuture ...
[16:59:35.759] result() for MulticoreFuture ... done
[16:59:35.760] result() for MulticoreFuture ...
[16:59:35.760] result() for MulticoreFuture ... done
[16:59:35.760] result() for MulticoreFuture ...
[16:59:35.761] result() for MulticoreFuture ... done
[16:59:35.761] - relayed: [n=2] TRUE, FALSE
[16:59:35.761] - queued futures: [n=2] TRUE, FALSE
[16:59:35.761] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:35.761]  length: 1 (resolved future 1)
[16:59:35.762] Future #2
[16:59:35.762] result() for MulticoreFuture ...
[16:59:35.763] result() for MulticoreFuture ...
[16:59:35.763] result() for MulticoreFuture ... done
[16:59:35.764] result() for MulticoreFuture ... done
[16:59:35.764] result() for MulticoreFuture ...
[16:59:35.764] result() for MulticoreFuture ... done
[16:59:35.764] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:35.765] - nx: 2
[16:59:35.765] - relay: TRUE
[16:59:35.765] - stdout: TRUE
[16:59:35.765] - signal: TRUE
[16:59:35.765] - resignal: FALSE
[16:59:35.765] - force: TRUE
[16:59:35.766] - relayed: [n=2] TRUE, FALSE
[16:59:35.766] - queued futures: [n=2] TRUE, FALSE
[16:59:35.766]  - until=2
[16:59:35.766]  - relaying element #2
[16:59:35.766] result() for MulticoreFuture ...
[16:59:35.766] result() for MulticoreFuture ... done
[16:59:35.766] result() for MulticoreFuture ...
[16:59:35.767] result() for MulticoreFuture ... done
[16:59:35.767] result() for MulticoreFuture ...
[16:59:35.767] result() for MulticoreFuture ... done
[16:59:35.767] result() for MulticoreFuture ...
[16:59:35.767] result() for MulticoreFuture ... done
[16:59:35.767] - relayed: [n=2] TRUE, TRUE
[16:59:35.767] - queued futures: [n=2] TRUE, TRUE
[16:59:35.767] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:35.768]  length: 0 (resolved future 2)
[16:59:35.768] Relaying remaining futures
[16:59:35.768] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.768] - nx: 2
[16:59:35.768] - relay: TRUE
[16:59:35.768] - stdout: TRUE
[16:59:35.768] - signal: TRUE
[16:59:35.768] - resignal: FALSE
[16:59:35.768] - force: TRUE
[16:59:35.769] - relayed: [n=2] TRUE, TRUE
[16:59:35.769] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:35.769] - relayed: [n=2] TRUE, TRUE
[16:59:35.769] - queued futures: [n=2] TRUE, TRUE
[16:59:35.769] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.769] resolve() on list ... DONE
[16:59:35.769] result() for MulticoreFuture ...
[16:59:35.769] result() for MulticoreFuture ... done
[16:59:35.770] result() for MulticoreFuture ...
[16:59:35.770] result() for MulticoreFuture ... done
[16:59:35.770] result() for MulticoreFuture ...
[16:59:35.770] result() for MulticoreFuture ... done
[16:59:35.770] result() for MulticoreFuture ...
[16:59:35.770] result() for MulticoreFuture ... done
[16:59:35.770]  - Number of value chunks collected: 2
[16:59:35.770] Resolving 2 futures (chunks) ... DONE
[16:59:35.770] Reducing values from 2 chunks ...
[16:59:35.771]  - Number of values collected after concatenation: 3
[16:59:35.771]  - Number of values expected: 3
[16:59:35.771] Reducing values from 2 chunks ... DONE
[16:59:35.771] future_lapply() ... DONE
[16:59:35.771] future_by_internal() ... DONE
[16:59:35.772] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:59:35.773] future_lapply() ...
[16:59:35.777] Number of chunks: 2
[16:59:35.778] getGlobalsAndPackagesXApply() ...
[16:59:35.778]  - future.globals: TRUE
[16:59:35.778] getGlobalsAndPackages() ...
[16:59:35.778] Searching for globals...
[16:59:35.779] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:35.779] Searching for globals ... DONE
[16:59:35.779] Resolving globals: FALSE
[16:59:35.780] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:35.780] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:35.780] - globals: [1] ‘FUN’
[16:59:35.780] 
[16:59:35.780] getGlobalsAndPackages() ... DONE
[16:59:35.781]  - globals found/used: [n=1] ‘FUN’
[16:59:35.781]  - needed namespaces: [n=0] 
[16:59:35.781] Finding globals ... DONE
[16:59:35.781]  - use_args: TRUE
[16:59:35.781]  - Getting '...' globals ...
[16:59:35.781] resolve() on list ...
[16:59:35.781]  recursive: 0
[16:59:35.781]  length: 1
[16:59:35.782]  elements: ‘...’
[16:59:35.782]  length: 0 (resolved future 1)
[16:59:35.782] resolve() on list ... DONE
[16:59:35.782]    - '...' content: [n=0] 
[16:59:35.782] List of 1
[16:59:35.782]  $ ...: list()
[16:59:35.782]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.782]  - attr(*, "where")=List of 1
[16:59:35.782]   ..$ ...:<environment: 0x562050f14f50> 
[16:59:35.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.782]  - attr(*, "resolved")= logi TRUE
[16:59:35.782]  - attr(*, "total_size")= num NA
[16:59:35.787]  - Getting '...' globals ... DONE
[16:59:35.787] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:35.787] List of 2
[16:59:35.787]  $ ...future.FUN:function (object, ...)  
[16:59:35.787]  $ ...          : list()
[16:59:35.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.787]  - attr(*, "where")=List of 2
[16:59:35.787]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:35.787]   ..$ ...          :<environment: 0x562050f14f50> 
[16:59:35.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.787]  - attr(*, "resolved")= logi FALSE
[16:59:35.787]  - attr(*, "total_size")= num 1240
[16:59:35.791] Packages to be attached in all futures: [n=0] 
[16:59:35.791] getGlobalsAndPackagesXApply() ... DONE
[16:59:35.791] Number of futures (= number of chunks): 2
[16:59:35.791] Launching 2 futures (chunks) ...
[16:59:35.791] Chunk #1 of 2 ...
[16:59:35.791]  - Finding globals in 'X' for chunk #1 ...
[16:59:35.791] getGlobalsAndPackages() ...
[16:59:35.792] Searching for globals...
[16:59:35.792] 
[16:59:35.792] Searching for globals ... DONE
[16:59:35.792] - globals: [0] <none>
[16:59:35.792] getGlobalsAndPackages() ... DONE
[16:59:35.792]    + additional globals found: [n=0] 
[16:59:35.793]    + additional namespaces needed: [n=0] 
[16:59:35.793]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:35.793]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.793]  - seeds: <none>
[16:59:35.793]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.793] getGlobalsAndPackages() ...
[16:59:35.793] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.793] Resolving globals: FALSE
[16:59:35.793] Tweak future expression to call with '...' arguments ...
[16:59:35.793] {
[16:59:35.793]     do.call(function(...) {
[16:59:35.793]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.793]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.793]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.793]             on.exit(options(oopts), add = TRUE)
[16:59:35.793]         }
[16:59:35.793]         {
[16:59:35.793]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.793]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.793]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.793]             })
[16:59:35.793]         }
[16:59:35.793]     }, args = future.call.arguments)
[16:59:35.793] }
[16:59:35.794] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.794] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.794] 
[16:59:35.794] getGlobalsAndPackages() ... DONE
[16:59:35.795] run() for ‘Future’ ...
[16:59:35.795] - state: ‘created’
[16:59:35.795] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.799] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.799]   - Field: ‘label’
[16:59:35.799]   - Field: ‘local’
[16:59:35.799]   - Field: ‘owner’
[16:59:35.800]   - Field: ‘envir’
[16:59:35.800]   - Field: ‘workers’
[16:59:35.800]   - Field: ‘packages’
[16:59:35.800]   - Field: ‘gc’
[16:59:35.800]   - Field: ‘job’
[16:59:35.800]   - Field: ‘conditions’
[16:59:35.800]   - Field: ‘expr’
[16:59:35.800]   - Field: ‘uuid’
[16:59:35.800]   - Field: ‘seed’
[16:59:35.800]   - Field: ‘version’
[16:59:35.801]   - Field: ‘result’
[16:59:35.801]   - Field: ‘asynchronous’
[16:59:35.801]   - Field: ‘calls’
[16:59:35.801]   - Field: ‘globals’
[16:59:35.801]   - Field: ‘stdout’
[16:59:35.801]   - Field: ‘earlySignal’
[16:59:35.801]   - Field: ‘lazy’
[16:59:35.801]   - Field: ‘state’
[16:59:35.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.801] - Launch lazy future ...
[16:59:35.802] Packages needed by the future expression (n = 0): <none>
[16:59:35.802] Packages needed by future strategies (n = 0): <none>
[16:59:35.802] {
[16:59:35.802]     {
[16:59:35.802]         {
[16:59:35.802]             ...future.startTime <- base::Sys.time()
[16:59:35.802]             {
[16:59:35.802]                 {
[16:59:35.802]                   {
[16:59:35.802]                     {
[16:59:35.802]                       base::local({
[16:59:35.802]                         has_future <- base::requireNamespace("future", 
[16:59:35.802]                           quietly = TRUE)
[16:59:35.802]                         if (has_future) {
[16:59:35.802]                           ns <- base::getNamespace("future")
[16:59:35.802]                           version <- ns[[".package"]][["version"]]
[16:59:35.802]                           if (is.null(version)) 
[16:59:35.802]                             version <- utils::packageVersion("future")
[16:59:35.802]                         }
[16:59:35.802]                         else {
[16:59:35.802]                           version <- NULL
[16:59:35.802]                         }
[16:59:35.802]                         if (!has_future || version < "1.8.0") {
[16:59:35.802]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.802]                             "", base::R.version$version.string), 
[16:59:35.802]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.802]                               "release", "version")], collapse = " "), 
[16:59:35.802]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.802]                             info)
[16:59:35.802]                           info <- base::paste(info, collapse = "; ")
[16:59:35.802]                           if (!has_future) {
[16:59:35.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.802]                               info)
[16:59:35.802]                           }
[16:59:35.802]                           else {
[16:59:35.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.802]                               info, version)
[16:59:35.802]                           }
[16:59:35.802]                           base::stop(msg)
[16:59:35.802]                         }
[16:59:35.802]                       })
[16:59:35.802]                     }
[16:59:35.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.802]                     base::options(mc.cores = 1L)
[16:59:35.802]                   }
[16:59:35.802]                   ...future.strategy.old <- future::plan("list")
[16:59:35.802]                   options(future.plan = NULL)
[16:59:35.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.802]                 }
[16:59:35.802]                 ...future.workdir <- getwd()
[16:59:35.802]             }
[16:59:35.802]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.802]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.802]         }
[16:59:35.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.802]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.802]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.802]             base::names(...future.oldOptions))
[16:59:35.802]     }
[16:59:35.802]     if (FALSE) {
[16:59:35.802]     }
[16:59:35.802]     else {
[16:59:35.802]         if (TRUE) {
[16:59:35.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.802]                 open = "w")
[16:59:35.802]         }
[16:59:35.802]         else {
[16:59:35.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.802]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.802]         }
[16:59:35.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.802]             base::sink(type = "output", split = FALSE)
[16:59:35.802]             base::close(...future.stdout)
[16:59:35.802]         }, add = TRUE)
[16:59:35.802]     }
[16:59:35.802]     ...future.frame <- base::sys.nframe()
[16:59:35.802]     ...future.conditions <- base::list()
[16:59:35.802]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.802]     if (FALSE) {
[16:59:35.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.802]     }
[16:59:35.802]     ...future.result <- base::tryCatch({
[16:59:35.802]         base::withCallingHandlers({
[16:59:35.802]             ...future.value <- base::withVisible(base::local({
[16:59:35.802]                 withCallingHandlers({
[16:59:35.802]                   {
[16:59:35.802]                     do.call(function(...) {
[16:59:35.802]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.802]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.802]                         ...future.globals.maxSize)) {
[16:59:35.802]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.802]                         on.exit(options(oopts), add = TRUE)
[16:59:35.802]                       }
[16:59:35.802]                       {
[16:59:35.802]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.802]                           FUN = function(jj) {
[16:59:35.802]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.802]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.802]                           })
[16:59:35.802]                       }
[16:59:35.802]                     }, args = future.call.arguments)
[16:59:35.802]                   }
[16:59:35.802]                 }, immediateCondition = function(cond) {
[16:59:35.802]                   save_rds <- function (object, pathname, ...) 
[16:59:35.802]                   {
[16:59:35.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.802]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.802]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.802]                         fi_tmp[["mtime"]])
[16:59:35.802]                     }
[16:59:35.802]                     tryCatch({
[16:59:35.802]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.802]                     }, error = function(ex) {
[16:59:35.802]                       msg <- conditionMessage(ex)
[16:59:35.802]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.802]                         fi_tmp[["mtime"]], msg)
[16:59:35.802]                       ex$message <- msg
[16:59:35.802]                       stop(ex)
[16:59:35.802]                     })
[16:59:35.802]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.802]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.802]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.802]                       fi <- file.info(pathname)
[16:59:35.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.802]                         fi[["size"]], fi[["mtime"]])
[16:59:35.802]                       stop(msg)
[16:59:35.802]                     }
[16:59:35.802]                     invisible(pathname)
[16:59:35.802]                   }
[16:59:35.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.802]                     rootPath = tempdir()) 
[16:59:35.802]                   {
[16:59:35.802]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.802]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.802]                       tmpdir = path, fileext = ".rds")
[16:59:35.802]                     save_rds(obj, file)
[16:59:35.802]                   }
[16:59:35.802]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.802]                   {
[16:59:35.802]                     inherits <- base::inherits
[16:59:35.802]                     invokeRestart <- base::invokeRestart
[16:59:35.802]                     is.null <- base::is.null
[16:59:35.802]                     muffled <- FALSE
[16:59:35.802]                     if (inherits(cond, "message")) {
[16:59:35.802]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.802]                       if (muffled) 
[16:59:35.802]                         invokeRestart("muffleMessage")
[16:59:35.802]                     }
[16:59:35.802]                     else if (inherits(cond, "warning")) {
[16:59:35.802]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.802]                       if (muffled) 
[16:59:35.802]                         invokeRestart("muffleWarning")
[16:59:35.802]                     }
[16:59:35.802]                     else if (inherits(cond, "condition")) {
[16:59:35.802]                       if (!is.null(pattern)) {
[16:59:35.802]                         computeRestarts <- base::computeRestarts
[16:59:35.802]                         grepl <- base::grepl
[16:59:35.802]                         restarts <- computeRestarts(cond)
[16:59:35.802]                         for (restart in restarts) {
[16:59:35.802]                           name <- restart$name
[16:59:35.802]                           if (is.null(name)) 
[16:59:35.802]                             next
[16:59:35.802]                           if (!grepl(pattern, name)) 
[16:59:35.802]                             next
[16:59:35.802]                           invokeRestart(restart)
[16:59:35.802]                           muffled <- TRUE
[16:59:35.802]                           break
[16:59:35.802]                         }
[16:59:35.802]                       }
[16:59:35.802]                     }
[16:59:35.802]                     invisible(muffled)
[16:59:35.802]                   }
[16:59:35.802]                   muffleCondition(cond)
[16:59:35.802]                 })
[16:59:35.802]             }))
[16:59:35.802]             future::FutureResult(value = ...future.value$value, 
[16:59:35.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.802]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.802]                     ...future.globalenv.names))
[16:59:35.802]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.802]         }, condition = base::local({
[16:59:35.802]             c <- base::c
[16:59:35.802]             inherits <- base::inherits
[16:59:35.802]             invokeRestart <- base::invokeRestart
[16:59:35.802]             length <- base::length
[16:59:35.802]             list <- base::list
[16:59:35.802]             seq.int <- base::seq.int
[16:59:35.802]             signalCondition <- base::signalCondition
[16:59:35.802]             sys.calls <- base::sys.calls
[16:59:35.802]             `[[` <- base::`[[`
[16:59:35.802]             `+` <- base::`+`
[16:59:35.802]             `<<-` <- base::`<<-`
[16:59:35.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.802]                   3L)]
[16:59:35.802]             }
[16:59:35.802]             function(cond) {
[16:59:35.802]                 is_error <- inherits(cond, "error")
[16:59:35.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.802]                   NULL)
[16:59:35.802]                 if (is_error) {
[16:59:35.802]                   sessionInformation <- function() {
[16:59:35.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.802]                       search = base::search(), system = base::Sys.info())
[16:59:35.802]                   }
[16:59:35.802]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.802]                     cond$call), session = sessionInformation(), 
[16:59:35.802]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.802]                   signalCondition(cond)
[16:59:35.802]                 }
[16:59:35.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.802]                 "immediateCondition"))) {
[16:59:35.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.802]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.802]                   if (TRUE && !signal) {
[16:59:35.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.802]                     {
[16:59:35.802]                       inherits <- base::inherits
[16:59:35.802]                       invokeRestart <- base::invokeRestart
[16:59:35.802]                       is.null <- base::is.null
[16:59:35.802]                       muffled <- FALSE
[16:59:35.802]                       if (inherits(cond, "message")) {
[16:59:35.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.802]                         if (muffled) 
[16:59:35.802]                           invokeRestart("muffleMessage")
[16:59:35.802]                       }
[16:59:35.802]                       else if (inherits(cond, "warning")) {
[16:59:35.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.802]                         if (muffled) 
[16:59:35.802]                           invokeRestart("muffleWarning")
[16:59:35.802]                       }
[16:59:35.802]                       else if (inherits(cond, "condition")) {
[16:59:35.802]                         if (!is.null(pattern)) {
[16:59:35.802]                           computeRestarts <- base::computeRestarts
[16:59:35.802]                           grepl <- base::grepl
[16:59:35.802]                           restarts <- computeRestarts(cond)
[16:59:35.802]                           for (restart in restarts) {
[16:59:35.802]                             name <- restart$name
[16:59:35.802]                             if (is.null(name)) 
[16:59:35.802]                               next
[16:59:35.802]                             if (!grepl(pattern, name)) 
[16:59:35.802]                               next
[16:59:35.802]                             invokeRestart(restart)
[16:59:35.802]                             muffled <- TRUE
[16:59:35.802]                             break
[16:59:35.802]                           }
[16:59:35.802]                         }
[16:59:35.802]                       }
[16:59:35.802]                       invisible(muffled)
[16:59:35.802]                     }
[16:59:35.802]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.802]                   }
[16:59:35.802]                 }
[16:59:35.802]                 else {
[16:59:35.802]                   if (TRUE) {
[16:59:35.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.802]                     {
[16:59:35.802]                       inherits <- base::inherits
[16:59:35.802]                       invokeRestart <- base::invokeRestart
[16:59:35.802]                       is.null <- base::is.null
[16:59:35.802]                       muffled <- FALSE
[16:59:35.802]                       if (inherits(cond, "message")) {
[16:59:35.802]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.802]                         if (muffled) 
[16:59:35.802]                           invokeRestart("muffleMessage")
[16:59:35.802]                       }
[16:59:35.802]                       else if (inherits(cond, "warning")) {
[16:59:35.802]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.802]                         if (muffled) 
[16:59:35.802]                           invokeRestart("muffleWarning")
[16:59:35.802]                       }
[16:59:35.802]                       else if (inherits(cond, "condition")) {
[16:59:35.802]                         if (!is.null(pattern)) {
[16:59:35.802]                           computeRestarts <- base::computeRestarts
[16:59:35.802]                           grepl <- base::grepl
[16:59:35.802]                           restarts <- computeRestarts(cond)
[16:59:35.802]                           for (restart in restarts) {
[16:59:35.802]                             name <- restart$name
[16:59:35.802]                             if (is.null(name)) 
[16:59:35.802]                               next
[16:59:35.802]                             if (!grepl(pattern, name)) 
[16:59:35.802]                               next
[16:59:35.802]                             invokeRestart(restart)
[16:59:35.802]                             muffled <- TRUE
[16:59:35.802]                             break
[16:59:35.802]                           }
[16:59:35.802]                         }
[16:59:35.802]                       }
[16:59:35.802]                       invisible(muffled)
[16:59:35.802]                     }
[16:59:35.802]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.802]                   }
[16:59:35.802]                 }
[16:59:35.802]             }
[16:59:35.802]         }))
[16:59:35.802]     }, error = function(ex) {
[16:59:35.802]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.802]                 ...future.rng), started = ...future.startTime, 
[16:59:35.802]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.802]             version = "1.8"), class = "FutureResult")
[16:59:35.802]     }, finally = {
[16:59:35.802]         if (!identical(...future.workdir, getwd())) 
[16:59:35.802]             setwd(...future.workdir)
[16:59:35.802]         {
[16:59:35.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.802]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.802]             }
[16:59:35.802]             base::options(...future.oldOptions)
[16:59:35.802]             if (.Platform$OS.type == "windows") {
[16:59:35.802]                 old_names <- names(...future.oldEnvVars)
[16:59:35.802]                 envs <- base::Sys.getenv()
[16:59:35.802]                 names <- names(envs)
[16:59:35.802]                 common <- intersect(names, old_names)
[16:59:35.802]                 added <- setdiff(names, old_names)
[16:59:35.802]                 removed <- setdiff(old_names, names)
[16:59:35.802]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.802]                   envs[common]]
[16:59:35.802]                 NAMES <- toupper(changed)
[16:59:35.802]                 args <- list()
[16:59:35.802]                 for (kk in seq_along(NAMES)) {
[16:59:35.802]                   name <- changed[[kk]]
[16:59:35.802]                   NAME <- NAMES[[kk]]
[16:59:35.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.802]                     next
[16:59:35.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.802]                 }
[16:59:35.802]                 NAMES <- toupper(added)
[16:59:35.802]                 for (kk in seq_along(NAMES)) {
[16:59:35.802]                   name <- added[[kk]]
[16:59:35.802]                   NAME <- NAMES[[kk]]
[16:59:35.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.802]                     next
[16:59:35.802]                   args[[name]] <- ""
[16:59:35.802]                 }
[16:59:35.802]                 NAMES <- toupper(removed)
[16:59:35.802]                 for (kk in seq_along(NAMES)) {
[16:59:35.802]                   name <- removed[[kk]]
[16:59:35.802]                   NAME <- NAMES[[kk]]
[16:59:35.802]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.802]                     next
[16:59:35.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.802]                 }
[16:59:35.802]                 if (length(args) > 0) 
[16:59:35.802]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.802]             }
[16:59:35.802]             else {
[16:59:35.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.802]             }
[16:59:35.802]             {
[16:59:35.802]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.802]                   0L) {
[16:59:35.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.802]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.802]                   base::options(opts)
[16:59:35.802]                 }
[16:59:35.802]                 {
[16:59:35.802]                   {
[16:59:35.802]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.802]                     NULL
[16:59:35.802]                   }
[16:59:35.802]                   options(future.plan = NULL)
[16:59:35.802]                   if (is.na(NA_character_)) 
[16:59:35.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.802]                     .init = FALSE)
[16:59:35.802]                 }
[16:59:35.802]             }
[16:59:35.802]         }
[16:59:35.802]     })
[16:59:35.802]     if (TRUE) {
[16:59:35.802]         base::sink(type = "output", split = FALSE)
[16:59:35.802]         if (TRUE) {
[16:59:35.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.802]         }
[16:59:35.802]         else {
[16:59:35.802]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.802]         }
[16:59:35.802]         base::close(...future.stdout)
[16:59:35.802]         ...future.stdout <- NULL
[16:59:35.802]     }
[16:59:35.802]     ...future.result$conditions <- ...future.conditions
[16:59:35.802]     ...future.result$finished <- base::Sys.time()
[16:59:35.802]     ...future.result
[16:59:35.802] }
[16:59:35.805] assign_globals() ...
[16:59:35.805] List of 5
[16:59:35.805]  $ ...future.FUN            :function (object, ...)  
[16:59:35.805]  $ future.call.arguments    : list()
[16:59:35.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.805]  $ ...future.elements_ii    :List of 1
[16:59:35.805]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.805]   .. ..$ breaks : num [1:18] 26 30 54 25 70 52 51 26 67 27 ...
[16:59:35.805]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.805]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:35.805]  $ ...future.seeds_ii       : NULL
[16:59:35.805]  $ ...future.globals.maxSize: NULL
[16:59:35.805]  - attr(*, "where")=List of 5
[16:59:35.805]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.805]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.805]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.805]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.805]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.805]  - attr(*, "resolved")= logi FALSE
[16:59:35.805]  - attr(*, "total_size")= num 1240
[16:59:35.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.805]  - attr(*, "already-done")= logi TRUE
[16:59:35.813] - copied ‘...future.FUN’ to environment
[16:59:35.813] - copied ‘future.call.arguments’ to environment
[16:59:35.813] - copied ‘...future.elements_ii’ to environment
[16:59:35.814] - copied ‘...future.seeds_ii’ to environment
[16:59:35.814] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.814] assign_globals() ... done
[16:59:35.814] requestCore(): workers = 2
[16:59:35.817] MulticoreFuture started
[16:59:35.817] - Launch lazy future ... done
[16:59:35.818] plan(): Setting new future strategy stack:
[16:59:35.818] run() for ‘MulticoreFuture’ ... done
[16:59:35.819] Created future:
[16:59:35.818] List of future strategies:
[16:59:35.818] 1. sequential:
[16:59:35.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.818]    - tweaked: FALSE
[16:59:35.818]    - call: NULL
[16:59:35.820] plan(): nbrOfWorkers() = 1
[16:59:35.825] plan(): Setting new future strategy stack:
[16:59:35.825] List of future strategies:
[16:59:35.825] 1. multicore:
[16:59:35.825]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.825]    - tweaked: FALSE
[16:59:35.825]    - call: plan(strategy)
[16:59:35.831] plan(): nbrOfWorkers() = 2
[16:59:35.819] MulticoreFuture:
[16:59:35.819] Label: ‘future_by-1’
[16:59:35.819] Expression:
[16:59:35.819] {
[16:59:35.819]     do.call(function(...) {
[16:59:35.819]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.819]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.819]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.819]             on.exit(options(oopts), add = TRUE)
[16:59:35.819]         }
[16:59:35.819]         {
[16:59:35.819]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.819]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.819]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.819]             })
[16:59:35.819]         }
[16:59:35.819]     }, args = future.call.arguments)
[16:59:35.819] }
[16:59:35.819] Lazy evaluation: FALSE
[16:59:35.819] Asynchronous evaluation: TRUE
[16:59:35.819] Local evaluation: TRUE
[16:59:35.819] Environment: 0x5620508ec760
[16:59:35.819] Capture standard output: TRUE
[16:59:35.819] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.819] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.819] Packages: <none>
[16:59:35.819] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.819] Resolved: TRUE
[16:59:35.819] Value: <not collected>
[16:59:35.819] Conditions captured: <none>
[16:59:35.819] Early signaling: FALSE
[16:59:35.819] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.819] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.833] Chunk #1 of 2 ... DONE
[16:59:35.833] Chunk #2 of 2 ...
[16:59:35.833]  - Finding globals in 'X' for chunk #2 ...
[16:59:35.833] getGlobalsAndPackages() ...
[16:59:35.834] Searching for globals...
[16:59:35.835] 
[16:59:35.835] Searching for globals ... DONE
[16:59:35.835] - globals: [0] <none>
[16:59:35.835] getGlobalsAndPackages() ... DONE
[16:59:35.835]    + additional globals found: [n=0] 
[16:59:35.836]    + additional namespaces needed: [n=0] 
[16:59:35.836]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:35.836]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:35.836]  - seeds: <none>
[16:59:35.836]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.836] getGlobalsAndPackages() ...
[16:59:35.837] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.837] Resolving globals: FALSE
[16:59:35.837] Tweak future expression to call with '...' arguments ...
[16:59:35.837] {
[16:59:35.837]     do.call(function(...) {
[16:59:35.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.837]             on.exit(options(oopts), add = TRUE)
[16:59:35.837]         }
[16:59:35.837]         {
[16:59:35.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.837]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.837]             })
[16:59:35.837]         }
[16:59:35.837]     }, args = future.call.arguments)
[16:59:35.837] }
[16:59:35.838] Tweak future expression to call with '...' arguments ... DONE
[16:59:35.839] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:35.839] 
[16:59:35.839] getGlobalsAndPackages() ... DONE
[16:59:35.839] run() for ‘Future’ ...
[16:59:35.840] - state: ‘created’
[16:59:35.840] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:59:35.845] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.845] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:59:35.845]   - Field: ‘label’
[16:59:35.845]   - Field: ‘local’
[16:59:35.845]   - Field: ‘owner’
[16:59:35.845]   - Field: ‘envir’
[16:59:35.845]   - Field: ‘workers’
[16:59:35.846]   - Field: ‘packages’
[16:59:35.846]   - Field: ‘gc’
[16:59:35.846]   - Field: ‘job’
[16:59:35.846]   - Field: ‘conditions’
[16:59:35.846]   - Field: ‘expr’
[16:59:35.846]   - Field: ‘uuid’
[16:59:35.846]   - Field: ‘seed’
[16:59:35.847]   - Field: ‘version’
[16:59:35.847]   - Field: ‘result’
[16:59:35.847]   - Field: ‘asynchronous’
[16:59:35.847]   - Field: ‘calls’
[16:59:35.847]   - Field: ‘globals’
[16:59:35.847]   - Field: ‘stdout’
[16:59:35.847]   - Field: ‘earlySignal’
[16:59:35.847]   - Field: ‘lazy’
[16:59:35.848]   - Field: ‘state’
[16:59:35.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:59:35.848] - Launch lazy future ...
[16:59:35.848] Packages needed by the future expression (n = 0): <none>
[16:59:35.848] Packages needed by future strategies (n = 0): <none>
[16:59:35.849] {
[16:59:35.849]     {
[16:59:35.849]         {
[16:59:35.849]             ...future.startTime <- base::Sys.time()
[16:59:35.849]             {
[16:59:35.849]                 {
[16:59:35.849]                   {
[16:59:35.849]                     {
[16:59:35.849]                       base::local({
[16:59:35.849]                         has_future <- base::requireNamespace("future", 
[16:59:35.849]                           quietly = TRUE)
[16:59:35.849]                         if (has_future) {
[16:59:35.849]                           ns <- base::getNamespace("future")
[16:59:35.849]                           version <- ns[[".package"]][["version"]]
[16:59:35.849]                           if (is.null(version)) 
[16:59:35.849]                             version <- utils::packageVersion("future")
[16:59:35.849]                         }
[16:59:35.849]                         else {
[16:59:35.849]                           version <- NULL
[16:59:35.849]                         }
[16:59:35.849]                         if (!has_future || version < "1.8.0") {
[16:59:35.849]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:35.849]                             "", base::R.version$version.string), 
[16:59:35.849]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:35.849]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:35.849]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:35.849]                               "release", "version")], collapse = " "), 
[16:59:35.849]                             hostname = base::Sys.info()[["nodename"]])
[16:59:35.849]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:35.849]                             info)
[16:59:35.849]                           info <- base::paste(info, collapse = "; ")
[16:59:35.849]                           if (!has_future) {
[16:59:35.849]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:35.849]                               info)
[16:59:35.849]                           }
[16:59:35.849]                           else {
[16:59:35.849]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:35.849]                               info, version)
[16:59:35.849]                           }
[16:59:35.849]                           base::stop(msg)
[16:59:35.849]                         }
[16:59:35.849]                       })
[16:59:35.849]                     }
[16:59:35.849]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:35.849]                     base::options(mc.cores = 1L)
[16:59:35.849]                   }
[16:59:35.849]                   ...future.strategy.old <- future::plan("list")
[16:59:35.849]                   options(future.plan = NULL)
[16:59:35.849]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.849]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:35.849]                 }
[16:59:35.849]                 ...future.workdir <- getwd()
[16:59:35.849]             }
[16:59:35.849]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:35.849]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:35.849]         }
[16:59:35.849]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:35.849]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:35.849]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:35.849]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:35.849]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:35.849]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:35.849]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:35.849]             base::names(...future.oldOptions))
[16:59:35.849]     }
[16:59:35.849]     if (FALSE) {
[16:59:35.849]     }
[16:59:35.849]     else {
[16:59:35.849]         if (TRUE) {
[16:59:35.849]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:35.849]                 open = "w")
[16:59:35.849]         }
[16:59:35.849]         else {
[16:59:35.849]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:35.849]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:35.849]         }
[16:59:35.849]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:35.849]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:35.849]             base::sink(type = "output", split = FALSE)
[16:59:35.849]             base::close(...future.stdout)
[16:59:35.849]         }, add = TRUE)
[16:59:35.849]     }
[16:59:35.849]     ...future.frame <- base::sys.nframe()
[16:59:35.849]     ...future.conditions <- base::list()
[16:59:35.849]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:35.849]     if (FALSE) {
[16:59:35.849]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:35.849]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:35.849]     }
[16:59:35.849]     ...future.result <- base::tryCatch({
[16:59:35.849]         base::withCallingHandlers({
[16:59:35.849]             ...future.value <- base::withVisible(base::local({
[16:59:35.849]                 withCallingHandlers({
[16:59:35.849]                   {
[16:59:35.849]                     do.call(function(...) {
[16:59:35.849]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.849]                       if (!identical(...future.globals.maxSize.org, 
[16:59:35.849]                         ...future.globals.maxSize)) {
[16:59:35.849]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.849]                         on.exit(options(oopts), add = TRUE)
[16:59:35.849]                       }
[16:59:35.849]                       {
[16:59:35.849]                         lapply(seq_along(...future.elements_ii), 
[16:59:35.849]                           FUN = function(jj) {
[16:59:35.849]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.849]                             ...future.FUN(...future.X_jj, ...)
[16:59:35.849]                           })
[16:59:35.849]                       }
[16:59:35.849]                     }, args = future.call.arguments)
[16:59:35.849]                   }
[16:59:35.849]                 }, immediateCondition = function(cond) {
[16:59:35.849]                   save_rds <- function (object, pathname, ...) 
[16:59:35.849]                   {
[16:59:35.849]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:59:35.849]                     if (file_test("-f", pathname_tmp)) {
[16:59:35.849]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.849]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:59:35.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.849]                         fi_tmp[["mtime"]])
[16:59:35.849]                     }
[16:59:35.849]                     tryCatch({
[16:59:35.849]                       saveRDS(object, file = pathname_tmp, ...)
[16:59:35.849]                     }, error = function(ex) {
[16:59:35.849]                       msg <- conditionMessage(ex)
[16:59:35.849]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.849]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:59:35.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.849]                         fi_tmp[["mtime"]], msg)
[16:59:35.849]                       ex$message <- msg
[16:59:35.849]                       stop(ex)
[16:59:35.849]                     })
[16:59:35.849]                     stopifnot(file_test("-f", pathname_tmp))
[16:59:35.849]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:59:35.849]                     if (!res || file_test("-f", pathname_tmp)) {
[16:59:35.849]                       fi_tmp <- file.info(pathname_tmp)
[16:59:35.849]                       fi <- file.info(pathname)
[16:59:35.849]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:59:35.849]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:59:35.849]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:59:35.849]                         fi[["size"]], fi[["mtime"]])
[16:59:35.849]                       stop(msg)
[16:59:35.849]                     }
[16:59:35.849]                     invisible(pathname)
[16:59:35.849]                   }
[16:59:35.849]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:59:35.849]                     rootPath = tempdir()) 
[16:59:35.849]                   {
[16:59:35.849]                     obj <- list(time = Sys.time(), condition = cond)
[16:59:35.849]                     file <- tempfile(pattern = class(cond)[1], 
[16:59:35.849]                       tmpdir = path, fileext = ".rds")
[16:59:35.849]                     save_rds(obj, file)
[16:59:35.849]                   }
[16:59:35.849]                   saveImmediateCondition(cond, path = "/tmp/Rtmpzh7kfO/.future/immediateConditions")
[16:59:35.849]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.849]                   {
[16:59:35.849]                     inherits <- base::inherits
[16:59:35.849]                     invokeRestart <- base::invokeRestart
[16:59:35.849]                     is.null <- base::is.null
[16:59:35.849]                     muffled <- FALSE
[16:59:35.849]                     if (inherits(cond, "message")) {
[16:59:35.849]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:35.849]                       if (muffled) 
[16:59:35.849]                         invokeRestart("muffleMessage")
[16:59:35.849]                     }
[16:59:35.849]                     else if (inherits(cond, "warning")) {
[16:59:35.849]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:35.849]                       if (muffled) 
[16:59:35.849]                         invokeRestart("muffleWarning")
[16:59:35.849]                     }
[16:59:35.849]                     else if (inherits(cond, "condition")) {
[16:59:35.849]                       if (!is.null(pattern)) {
[16:59:35.849]                         computeRestarts <- base::computeRestarts
[16:59:35.849]                         grepl <- base::grepl
[16:59:35.849]                         restarts <- computeRestarts(cond)
[16:59:35.849]                         for (restart in restarts) {
[16:59:35.849]                           name <- restart$name
[16:59:35.849]                           if (is.null(name)) 
[16:59:35.849]                             next
[16:59:35.849]                           if (!grepl(pattern, name)) 
[16:59:35.849]                             next
[16:59:35.849]                           invokeRestart(restart)
[16:59:35.849]                           muffled <- TRUE
[16:59:35.849]                           break
[16:59:35.849]                         }
[16:59:35.849]                       }
[16:59:35.849]                     }
[16:59:35.849]                     invisible(muffled)
[16:59:35.849]                   }
[16:59:35.849]                   muffleCondition(cond)
[16:59:35.849]                 })
[16:59:35.849]             }))
[16:59:35.849]             future::FutureResult(value = ...future.value$value, 
[16:59:35.849]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.849]                   ...future.rng), globalenv = if (FALSE) 
[16:59:35.849]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:35.849]                     ...future.globalenv.names))
[16:59:35.849]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:35.849]         }, condition = base::local({
[16:59:35.849]             c <- base::c
[16:59:35.849]             inherits <- base::inherits
[16:59:35.849]             invokeRestart <- base::invokeRestart
[16:59:35.849]             length <- base::length
[16:59:35.849]             list <- base::list
[16:59:35.849]             seq.int <- base::seq.int
[16:59:35.849]             signalCondition <- base::signalCondition
[16:59:35.849]             sys.calls <- base::sys.calls
[16:59:35.849]             `[[` <- base::`[[`
[16:59:35.849]             `+` <- base::`+`
[16:59:35.849]             `<<-` <- base::`<<-`
[16:59:35.849]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:35.849]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:35.849]                   3L)]
[16:59:35.849]             }
[16:59:35.849]             function(cond) {
[16:59:35.849]                 is_error <- inherits(cond, "error")
[16:59:35.849]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:35.849]                   NULL)
[16:59:35.849]                 if (is_error) {
[16:59:35.849]                   sessionInformation <- function() {
[16:59:35.849]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:35.849]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:35.849]                       search = base::search(), system = base::Sys.info())
[16:59:35.849]                   }
[16:59:35.849]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.849]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:35.849]                     cond$call), session = sessionInformation(), 
[16:59:35.849]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:35.849]                   signalCondition(cond)
[16:59:35.849]                 }
[16:59:35.849]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:35.849]                 "immediateCondition"))) {
[16:59:35.849]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:35.849]                   ...future.conditions[[length(...future.conditions) + 
[16:59:35.849]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:35.849]                   if (TRUE && !signal) {
[16:59:35.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.849]                     {
[16:59:35.849]                       inherits <- base::inherits
[16:59:35.849]                       invokeRestart <- base::invokeRestart
[16:59:35.849]                       is.null <- base::is.null
[16:59:35.849]                       muffled <- FALSE
[16:59:35.849]                       if (inherits(cond, "message")) {
[16:59:35.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.849]                         if (muffled) 
[16:59:35.849]                           invokeRestart("muffleMessage")
[16:59:35.849]                       }
[16:59:35.849]                       else if (inherits(cond, "warning")) {
[16:59:35.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.849]                         if (muffled) 
[16:59:35.849]                           invokeRestart("muffleWarning")
[16:59:35.849]                       }
[16:59:35.849]                       else if (inherits(cond, "condition")) {
[16:59:35.849]                         if (!is.null(pattern)) {
[16:59:35.849]                           computeRestarts <- base::computeRestarts
[16:59:35.849]                           grepl <- base::grepl
[16:59:35.849]                           restarts <- computeRestarts(cond)
[16:59:35.849]                           for (restart in restarts) {
[16:59:35.849]                             name <- restart$name
[16:59:35.849]                             if (is.null(name)) 
[16:59:35.849]                               next
[16:59:35.849]                             if (!grepl(pattern, name)) 
[16:59:35.849]                               next
[16:59:35.849]                             invokeRestart(restart)
[16:59:35.849]                             muffled <- TRUE
[16:59:35.849]                             break
[16:59:35.849]                           }
[16:59:35.849]                         }
[16:59:35.849]                       }
[16:59:35.849]                       invisible(muffled)
[16:59:35.849]                     }
[16:59:35.849]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.849]                   }
[16:59:35.849]                 }
[16:59:35.849]                 else {
[16:59:35.849]                   if (TRUE) {
[16:59:35.849]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:35.849]                     {
[16:59:35.849]                       inherits <- base::inherits
[16:59:35.849]                       invokeRestart <- base::invokeRestart
[16:59:35.849]                       is.null <- base::is.null
[16:59:35.849]                       muffled <- FALSE
[16:59:35.849]                       if (inherits(cond, "message")) {
[16:59:35.849]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:35.849]                         if (muffled) 
[16:59:35.849]                           invokeRestart("muffleMessage")
[16:59:35.849]                       }
[16:59:35.849]                       else if (inherits(cond, "warning")) {
[16:59:35.849]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:35.849]                         if (muffled) 
[16:59:35.849]                           invokeRestart("muffleWarning")
[16:59:35.849]                       }
[16:59:35.849]                       else if (inherits(cond, "condition")) {
[16:59:35.849]                         if (!is.null(pattern)) {
[16:59:35.849]                           computeRestarts <- base::computeRestarts
[16:59:35.849]                           grepl <- base::grepl
[16:59:35.849]                           restarts <- computeRestarts(cond)
[16:59:35.849]                           for (restart in restarts) {
[16:59:35.849]                             name <- restart$name
[16:59:35.849]                             if (is.null(name)) 
[16:59:35.849]                               next
[16:59:35.849]                             if (!grepl(pattern, name)) 
[16:59:35.849]                               next
[16:59:35.849]                             invokeRestart(restart)
[16:59:35.849]                             muffled <- TRUE
[16:59:35.849]                             break
[16:59:35.849]                           }
[16:59:35.849]                         }
[16:59:35.849]                       }
[16:59:35.849]                       invisible(muffled)
[16:59:35.849]                     }
[16:59:35.849]                     muffleCondition(cond, pattern = "^muffle")
[16:59:35.849]                   }
[16:59:35.849]                 }
[16:59:35.849]             }
[16:59:35.849]         }))
[16:59:35.849]     }, error = function(ex) {
[16:59:35.849]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:35.849]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:35.849]                 ...future.rng), started = ...future.startTime, 
[16:59:35.849]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:35.849]             version = "1.8"), class = "FutureResult")
[16:59:35.849]     }, finally = {
[16:59:35.849]         if (!identical(...future.workdir, getwd())) 
[16:59:35.849]             setwd(...future.workdir)
[16:59:35.849]         {
[16:59:35.849]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:35.849]                 ...future.oldOptions$nwarnings <- NULL
[16:59:35.849]             }
[16:59:35.849]             base::options(...future.oldOptions)
[16:59:35.849]             if (.Platform$OS.type == "windows") {
[16:59:35.849]                 old_names <- names(...future.oldEnvVars)
[16:59:35.849]                 envs <- base::Sys.getenv()
[16:59:35.849]                 names <- names(envs)
[16:59:35.849]                 common <- intersect(names, old_names)
[16:59:35.849]                 added <- setdiff(names, old_names)
[16:59:35.849]                 removed <- setdiff(old_names, names)
[16:59:35.849]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:35.849]                   envs[common]]
[16:59:35.849]                 NAMES <- toupper(changed)
[16:59:35.849]                 args <- list()
[16:59:35.849]                 for (kk in seq_along(NAMES)) {
[16:59:35.849]                   name <- changed[[kk]]
[16:59:35.849]                   NAME <- NAMES[[kk]]
[16:59:35.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.849]                     next
[16:59:35.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.849]                 }
[16:59:35.849]                 NAMES <- toupper(added)
[16:59:35.849]                 for (kk in seq_along(NAMES)) {
[16:59:35.849]                   name <- added[[kk]]
[16:59:35.849]                   NAME <- NAMES[[kk]]
[16:59:35.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.849]                     next
[16:59:35.849]                   args[[name]] <- ""
[16:59:35.849]                 }
[16:59:35.849]                 NAMES <- toupper(removed)
[16:59:35.849]                 for (kk in seq_along(NAMES)) {
[16:59:35.849]                   name <- removed[[kk]]
[16:59:35.849]                   NAME <- NAMES[[kk]]
[16:59:35.849]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:35.849]                     next
[16:59:35.849]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:35.849]                 }
[16:59:35.849]                 if (length(args) > 0) 
[16:59:35.849]                   base::do.call(base::Sys.setenv, args = args)
[16:59:35.849]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:35.849]             }
[16:59:35.849]             else {
[16:59:35.849]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:35.849]             }
[16:59:35.849]             {
[16:59:35.849]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:35.849]                   0L) {
[16:59:35.849]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:35.849]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:35.849]                   base::options(opts)
[16:59:35.849]                 }
[16:59:35.849]                 {
[16:59:35.849]                   {
[16:59:35.849]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:35.849]                     NULL
[16:59:35.849]                   }
[16:59:35.849]                   options(future.plan = NULL)
[16:59:35.849]                   if (is.na(NA_character_)) 
[16:59:35.849]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:35.849]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:35.849]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:35.849]                     .init = FALSE)
[16:59:35.849]                 }
[16:59:35.849]             }
[16:59:35.849]         }
[16:59:35.849]     })
[16:59:35.849]     if (TRUE) {
[16:59:35.849]         base::sink(type = "output", split = FALSE)
[16:59:35.849]         if (TRUE) {
[16:59:35.849]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:35.849]         }
[16:59:35.849]         else {
[16:59:35.849]             ...future.result["stdout"] <- base::list(NULL)
[16:59:35.849]         }
[16:59:35.849]         base::close(...future.stdout)
[16:59:35.849]         ...future.stdout <- NULL
[16:59:35.849]     }
[16:59:35.849]     ...future.result$conditions <- ...future.conditions
[16:59:35.849]     ...future.result$finished <- base::Sys.time()
[16:59:35.849]     ...future.result
[16:59:35.849] }
[16:59:35.852] assign_globals() ...
[16:59:35.852] List of 5
[16:59:35.852]  $ ...future.FUN            :function (object, ...)  
[16:59:35.852]  $ future.call.arguments    : list()
[16:59:35.852]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:35.852]  $ ...future.elements_ii    :List of 2
[16:59:35.852]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.852]   .. ..$ breaks : num [1:18] 18 21 29 17 12 18 35 30 36 42 ...
[16:59:35.852]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.852]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 2 2 2 2 2 2 2 2 2 2 ...
[16:59:35.852]   ..$ :'data.frame':	18 obs. of  3 variables:
[16:59:35.852]   .. ..$ breaks : num [1:18] 36 21 24 18 10 43 28 15 26 20 ...
[16:59:35.852]   .. ..$ wool   : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 2 ...
[16:59:35.852]   .. ..$ tension: Factor w/ 3 levels "L","M","H": 3 3 3 3 3 3 3 3 3 3 ...
[16:59:35.852]  $ ...future.seeds_ii       : NULL
[16:59:35.852]  $ ...future.globals.maxSize: NULL
[16:59:35.852]  - attr(*, "where")=List of 5
[16:59:35.852]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:59:35.852]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:59:35.852]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:59:35.852]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:59:35.852]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:59:35.852]  - attr(*, "resolved")= logi FALSE
[16:59:35.852]  - attr(*, "total_size")= num 1240
[16:59:35.852]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:35.852]  - attr(*, "already-done")= logi TRUE
[16:59:35.864] - copied ‘...future.FUN’ to environment
[16:59:35.864] - copied ‘future.call.arguments’ to environment
[16:59:35.865] - copied ‘...future.elements_ii’ to environment
[16:59:35.865] - copied ‘...future.seeds_ii’ to environment
[16:59:35.865] - copied ‘...future.globals.maxSize’ to environment
[16:59:35.865] assign_globals() ... done
[16:59:35.865] requestCore(): workers = 2
[16:59:35.868] MulticoreFuture started
[16:59:35.868] - Launch lazy future ... done
[16:59:35.869] plan(): Setting new future strategy stack:
[16:59:35.869] run() for ‘MulticoreFuture’ ... done
[16:59:35.870] Created future:
[16:59:35.869] List of future strategies:
[16:59:35.869] 1. sequential:
[16:59:35.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:35.869]    - tweaked: FALSE
[16:59:35.869]    - call: NULL
[16:59:35.871] plan(): nbrOfWorkers() = 1
[16:59:35.877] plan(): Setting new future strategy stack:
[16:59:35.878] List of future strategies:
[16:59:35.878] 1. multicore:
[16:59:35.878]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:59:35.878]    - tweaked: FALSE
[16:59:35.878]    - call: plan(strategy)
[16:59:35.883] plan(): nbrOfWorkers() = 2
[16:59:35.870] MulticoreFuture:
[16:59:35.870] Label: ‘future_by-2’
[16:59:35.870] Expression:
[16:59:35.870] {
[16:59:35.870]     do.call(function(...) {
[16:59:35.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:35.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:35.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:35.870]             on.exit(options(oopts), add = TRUE)
[16:59:35.870]         }
[16:59:35.870]         {
[16:59:35.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:35.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:35.870]                 ...future.FUN(...future.X_jj, ...)
[16:59:35.870]             })
[16:59:35.870]         }
[16:59:35.870]     }, args = future.call.arguments)
[16:59:35.870] }
[16:59:35.870] Lazy evaluation: FALSE
[16:59:35.870] Asynchronous evaluation: TRUE
[16:59:35.870] Local evaluation: TRUE
[16:59:35.870] Environment: 0x5620508ec760
[16:59:35.870] Capture standard output: TRUE
[16:59:35.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:35.870] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:35.870] Packages: <none>
[16:59:35.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:35.870] Resolved: TRUE
[16:59:35.870] Value: <not collected>
[16:59:35.870] Conditions captured: <none>
[16:59:35.870] Early signaling: FALSE
[16:59:35.870] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:35.870] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:35.884] Chunk #2 of 2 ... DONE
[16:59:35.884] Launching 2 futures (chunks) ... DONE
[16:59:35.885] Resolving 2 futures (chunks) ...
[16:59:35.885] resolve() on list ...
[16:59:35.885]  recursive: 0
[16:59:35.885]  length: 2
[16:59:35.885] 
[16:59:35.886] Future #1
[16:59:35.886] result() for MulticoreFuture ...
[16:59:35.887] result() for MulticoreFuture ...
[16:59:35.887] result() for MulticoreFuture ... done
[16:59:35.887] result() for MulticoreFuture ... done
[16:59:35.887] result() for MulticoreFuture ...
[16:59:35.887] result() for MulticoreFuture ... done
[16:59:35.888] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:59:35.888] - nx: 2
[16:59:35.888] - relay: TRUE
[16:59:35.888] - stdout: TRUE
[16:59:35.888] - signal: TRUE
[16:59:35.888] - resignal: FALSE
[16:59:35.888] - force: TRUE
[16:59:35.889] - relayed: [n=2] FALSE, FALSE
[16:59:35.889] - queued futures: [n=2] FALSE, FALSE
[16:59:35.889]  - until=1
[16:59:35.889]  - relaying element #1
[16:59:35.889] result() for MulticoreFuture ...
[16:59:35.889] result() for MulticoreFuture ... done
[16:59:35.890] result() for MulticoreFuture ...
[16:59:35.890] result() for MulticoreFuture ... done
[16:59:35.890] result() for MulticoreFuture ...
[16:59:35.890] result() for MulticoreFuture ... done
[16:59:35.890] result() for MulticoreFuture ...
[16:59:35.890] result() for MulticoreFuture ... done
[16:59:35.891] - relayed: [n=2] TRUE, FALSE
[16:59:35.891] - queued futures: [n=2] TRUE, FALSE
[16:59:35.891] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:59:35.891]  length: 1 (resolved future 1)
[16:59:35.891] Future #2
[16:59:35.892] result() for MulticoreFuture ...
[16:59:35.892] result() for MulticoreFuture ...
[16:59:35.892] result() for MulticoreFuture ... done
[16:59:35.893] result() for MulticoreFuture ... done
[16:59:35.893] result() for MulticoreFuture ...
[16:59:35.893] result() for MulticoreFuture ... done
[16:59:35.893] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:59:35.893] - nx: 2
[16:59:35.893] - relay: TRUE
[16:59:35.893] - stdout: TRUE
[16:59:35.893] - signal: TRUE
[16:59:35.893] - resignal: FALSE
[16:59:35.894] - force: TRUE
[16:59:35.894] - relayed: [n=2] TRUE, FALSE
[16:59:35.894] - queued futures: [n=2] TRUE, FALSE
[16:59:35.894]  - until=2
[16:59:35.894]  - relaying element #2
[16:59:35.894] result() for MulticoreFuture ...
[16:59:35.894] result() for MulticoreFuture ... done
[16:59:35.894] result() for MulticoreFuture ...
[16:59:35.894] result() for MulticoreFuture ... done
[16:59:35.895] result() for MulticoreFuture ...
[16:59:35.895] result() for MulticoreFuture ... done
[16:59:35.895] result() for MulticoreFuture ...
[16:59:35.895] result() for MulticoreFuture ... done
[16:59:35.895] - relayed: [n=2] TRUE, TRUE
[16:59:35.895] - queued futures: [n=2] TRUE, TRUE
[16:59:35.895] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[16:59:35.895]  length: 0 (resolved future 2)
[16:59:35.896] Relaying remaining futures
[16:59:35.896] signalConditionsASAP(NULL, pos=0) ...
[16:59:35.896] - nx: 2
[16:59:35.896] - relay: TRUE
[16:59:35.896] - stdout: TRUE
[16:59:35.896] - signal: TRUE
[16:59:35.896] - resignal: FALSE
[16:59:35.896] - force: TRUE
[16:59:35.896] - relayed: [n=2] TRUE, TRUE
[16:59:35.896] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:35.897] - relayed: [n=2] TRUE, TRUE
[16:59:35.897] - queued futures: [n=2] TRUE, TRUE
[16:59:35.897] signalConditionsASAP(NULL, pos=0) ... done
[16:59:35.897] resolve() on list ... DONE
[16:59:35.897] result() for MulticoreFuture ...
[16:59:35.897] result() for MulticoreFuture ... done
[16:59:35.897] result() for MulticoreFuture ...
[16:59:35.897] result() for MulticoreFuture ... done
[16:59:35.897] result() for MulticoreFuture ...
[16:59:35.898] result() for MulticoreFuture ... done
[16:59:35.898] result() for MulticoreFuture ...
[16:59:35.898] result() for MulticoreFuture ... done
[16:59:35.898]  - Number of value chunks collected: 2
[16:59:35.898] Resolving 2 futures (chunks) ... DONE
[16:59:35.898] Reducing values from 2 chunks ...
[16:59:35.898]  - Number of values collected after concatenation: 3
[16:59:35.898]  - Number of values expected: 3
[16:59:35.898] Reducing values from 2 chunks ... DONE
[16:59:35.898] future_lapply() ... DONE
[16:59:35.899] future_by_internal() ... DONE
[16:59:35.900] future_by_internal() ...
- plan('multisession') ...
[16:59:35.900] plan(): Setting new future strategy stack:
[16:59:35.900] List of future strategies:
[16:59:35.900] 1. multisession:
[16:59:35.900]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:35.900]    - tweaked: FALSE
[16:59:35.900]    - call: plan(strategy)
[16:59:35.901] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:59:35.901] multisession:
[16:59:35.901] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:59:35.901] - tweaked: FALSE
[16:59:35.901] - call: plan(strategy)
[16:59:35.912] getGlobalsAndPackages() ...
[16:59:35.912] Not searching for globals
[16:59:35.912] - globals: [0] <none>
[16:59:35.912] getGlobalsAndPackages() ... DONE
[16:59:35.913] [local output] makeClusterPSOCK() ...
[16:59:35.965] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:59:35.966] [local output] Base port: 11873
[16:59:35.966] [local output] Getting setup options for 2 cluster nodes ...
[16:59:35.966] [local output]  - Node 1 of 2 ...
[16:59:35.966] [local output] localMachine=TRUE => revtunnel=FALSE

[16:59:35.967] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpzh7kfO/worker.rank=1.parallelly.parent=28739.704324d67ca2.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmpzh7kfO/worker.rank=1.parallelly.parent=28739.704324d67ca2.pid")'’
[16:59:36.157] - Possible to infer worker's PID: TRUE
[16:59:36.158] [local output] Rscript port: 11873

[16:59:36.158] [local output]  - Node 2 of 2 ...
[16:59:36.159] [local output] localMachine=TRUE => revtunnel=FALSE

[16:59:36.159] [local output] Rscript port: 11873

[16:59:36.160] [local output] Getting setup options for 2 cluster nodes ... done
[16:59:36.160] [local output]  - Parallel setup requested for some PSOCK nodes
[16:59:36.160] [local output] Setting up PSOCK nodes in parallel
[16:59:36.160] List of 36
[16:59:36.160]  $ worker          : chr "localhost"
[16:59:36.160]   ..- attr(*, "localhost")= logi TRUE
[16:59:36.160]  $ master          : chr "localhost"
[16:59:36.160]  $ port            : int 11873
[16:59:36.160]  $ connectTimeout  : num 120
[16:59:36.160]  $ timeout         : num 2592000
[16:59:36.160]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:59:36.160]  $ homogeneous     : logi TRUE
[16:59:36.160]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:59:36.160]  $ rscript_envs    : NULL
[16:59:36.160]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:59:36.160]  $ rscript_startup : NULL
[16:59:36.160]  $ rscript_sh      : chr "sh"
[16:59:36.160]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:59:36.160]  $ methods         : logi TRUE
[16:59:36.160]  $ socketOptions   : chr "no-delay"
[16:59:36.160]  $ useXDR          : logi FALSE
[16:59:36.160]  $ outfile         : chr "/dev/null"
[16:59:36.160]  $ renice          : int NA
[16:59:36.160]  $ rshcmd          : NULL
[16:59:36.160]  $ user            : chr(0) 
[16:59:36.160]  $ revtunnel       : logi FALSE
[16:59:36.160]  $ rshlogfile      : NULL
[16:59:36.160]  $ rshopts         : chr(0) 
[16:59:36.160]  $ rank            : int 1
[16:59:36.160]  $ manual          : logi FALSE
[16:59:36.160]  $ dryrun          : logi FALSE
[16:59:36.160]  $ quiet           : logi FALSE
[16:59:36.160]  $ setup_strategy  : chr "parallel"
[16:59:36.160]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:59:36.160]  $ pidfile         : chr "/tmp/Rtmpzh7kfO/worker.rank=1.parallelly.parent=28739.704324d67ca2.pid"
[16:59:36.160]  $ rshcmd_label    : NULL
[16:59:36.160]  $ rsh_call        : NULL
[16:59:36.160]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:59:36.160]  $ localMachine    : logi TRUE
[16:59:36.160]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:59:36.160]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:59:36.160]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:59:36.160]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:59:36.160]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:59:36.160]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:59:36.160]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:59:36.160]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:59:36.160]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:59:36.160]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:59:36.160]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:59:36.160]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:59:36.160]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:59:36.160]  $ arguments       :List of 28
[16:59:36.160]   ..$ worker          : chr "localhost"
[16:59:36.160]   ..$ master          : NULL
[16:59:36.160]   ..$ port            : int 11873
[16:59:36.160]   ..$ connectTimeout  : num 120
[16:59:36.160]   ..$ timeout         : num 2592000
[16:59:36.160]   ..$ rscript         : NULL
[16:59:36.160]   ..$ homogeneous     : NULL
[16:59:36.160]   ..$ rscript_args    : NULL
[16:59:36.160]   ..$ rscript_envs    : NULL
[16:59:36.160]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:59:36.160]   ..$ rscript_startup : NULL
[16:59:36.160]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:59:36.160]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:59:36.160]   ..$ methods         : logi TRUE
[16:59:36.160]   ..$ socketOptions   : chr "no-delay"
[16:59:36.160]   ..$ useXDR          : logi FALSE
[16:59:36.160]   ..$ outfile         : chr "/dev/null"
[16:59:36.160]   ..$ renice          : int NA
[16:59:36.160]   ..$ rshcmd          : NULL
[16:59:36.160]   ..$ user            : NULL
[16:59:36.160]   ..$ revtunnel       : logi NA
[16:59:36.160]   ..$ rshlogfile      : NULL
[16:59:36.160]   ..$ rshopts         : NULL
[16:59:36.160]   ..$ rank            : int 1
[16:59:36.160]   ..$ manual          : logi FALSE
[16:59:36.160]   ..$ dryrun          : logi FALSE
[16:59:36.160]   ..$ quiet           : logi FALSE
[16:59:36.160]   ..$ setup_strategy  : chr "parallel"
[16:59:36.160]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:59:36.178] [local output] System call to launch all workers:
[16:59:36.178] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmpzh7kfO/worker.rank=1.parallelly.parent=28739.704324d67ca2.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11873 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:59:36.178] [local output] Starting PSOCK main server
[16:59:36.184] [local output] Workers launched
[16:59:36.184] [local output] Waiting for workers to connect back
[16:59:36.184]  - [local output] 0 workers out of 2 ready
[16:59:36.430]  - [local output] 0 workers out of 2 ready
[16:59:36.431]  - [local output] 1 workers out of 2 ready
[16:59:36.449]  - [local output] 1 workers out of 2 ready
[16:59:36.449]  - [local output] 2 workers out of 2 ready
[16:59:36.449] [local output] Launching of workers completed
[16:59:36.449] [local output] Collecting session information from workers
[16:59:36.450] [local output]  - Worker #1 of 2
[16:59:36.451] [local output]  - Worker #2 of 2
[16:59:36.451] [local output] makeClusterPSOCK() ... done
[16:59:36.463] Packages needed by the future expression (n = 0): <none>
[16:59:36.463] Packages needed by future strategies (n = 0): <none>
[16:59:36.463] {
[16:59:36.463]     {
[16:59:36.463]         {
[16:59:36.463]             ...future.startTime <- base::Sys.time()
[16:59:36.463]             {
[16:59:36.463]                 {
[16:59:36.463]                   {
[16:59:36.463]                     {
[16:59:36.463]                       base::local({
[16:59:36.463]                         has_future <- base::requireNamespace("future", 
[16:59:36.463]                           quietly = TRUE)
[16:59:36.463]                         if (has_future) {
[16:59:36.463]                           ns <- base::getNamespace("future")
[16:59:36.463]                           version <- ns[[".package"]][["version"]]
[16:59:36.463]                           if (is.null(version)) 
[16:59:36.463]                             version <- utils::packageVersion("future")
[16:59:36.463]                         }
[16:59:36.463]                         else {
[16:59:36.463]                           version <- NULL
[16:59:36.463]                         }
[16:59:36.463]                         if (!has_future || version < "1.8.0") {
[16:59:36.463]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:36.463]                             "", base::R.version$version.string), 
[16:59:36.463]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:36.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:36.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:36.463]                               "release", "version")], collapse = " "), 
[16:59:36.463]                             hostname = base::Sys.info()[["nodename"]])
[16:59:36.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:36.463]                             info)
[16:59:36.463]                           info <- base::paste(info, collapse = "; ")
[16:59:36.463]                           if (!has_future) {
[16:59:36.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:36.463]                               info)
[16:59:36.463]                           }
[16:59:36.463]                           else {
[16:59:36.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:36.463]                               info, version)
[16:59:36.463]                           }
[16:59:36.463]                           base::stop(msg)
[16:59:36.463]                         }
[16:59:36.463]                       })
[16:59:36.463]                     }
[16:59:36.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:36.463]                     base::options(mc.cores = 1L)
[16:59:36.463]                   }
[16:59:36.463]                   ...future.strategy.old <- future::plan("list")
[16:59:36.463]                   options(future.plan = NULL)
[16:59:36.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:36.463]                 }
[16:59:36.463]                 ...future.workdir <- getwd()
[16:59:36.463]             }
[16:59:36.463]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:36.463]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:36.463]         }
[16:59:36.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:36.463]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:59:36.463]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:36.463]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:36.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:36.463]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:36.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:36.463]             base::names(...future.oldOptions))
[16:59:36.463]     }
[16:59:36.463]     if (FALSE) {
[16:59:36.463]     }
[16:59:36.463]     else {
[16:59:36.463]         if (TRUE) {
[16:59:36.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:36.463]                 open = "w")
[16:59:36.463]         }
[16:59:36.463]         else {
[16:59:36.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:36.463]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:36.463]         }
[16:59:36.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:36.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:36.463]             base::sink(type = "output", split = FALSE)
[16:59:36.463]             base::close(...future.stdout)
[16:59:36.463]         }, add = TRUE)
[16:59:36.463]     }
[16:59:36.463]     ...future.frame <- base::sys.nframe()
[16:59:36.463]     ...future.conditions <- base::list()
[16:59:36.463]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:36.463]     if (FALSE) {
[16:59:36.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:36.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:36.463]     }
[16:59:36.463]     ...future.result <- base::tryCatch({
[16:59:36.463]         base::withCallingHandlers({
[16:59:36.463]             ...future.value <- base::withVisible(base::local({
[16:59:36.463]                 ...future.makeSendCondition <- base::local({
[16:59:36.463]                   sendCondition <- NULL
[16:59:36.463]                   function(frame = 1L) {
[16:59:36.463]                     if (is.function(sendCondition)) 
[16:59:36.463]                       return(sendCondition)
[16:59:36.463]                     ns <- getNamespace("parallel")
[16:59:36.463]                     if (exists("sendData", mode = "function", 
[16:59:36.463]                       envir = ns)) {
[16:59:36.463]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:36.463]                         envir = ns)
[16:59:36.463]                       envir <- sys.frame(frame)
[16:59:36.463]                       master <- NULL
[16:59:36.463]                       while (!identical(envir, .GlobalEnv) && 
[16:59:36.463]                         !identical(envir, emptyenv())) {
[16:59:36.463]                         if (exists("master", mode = "list", envir = envir, 
[16:59:36.463]                           inherits = FALSE)) {
[16:59:36.463]                           master <- get("master", mode = "list", 
[16:59:36.463]                             envir = envir, inherits = FALSE)
[16:59:36.463]                           if (inherits(master, c("SOCKnode", 
[16:59:36.463]                             "SOCK0node"))) {
[16:59:36.463]                             sendCondition <<- function(cond) {
[16:59:36.463]                               data <- list(type = "VALUE", value = cond, 
[16:59:36.463]                                 success = TRUE)
[16:59:36.463]                               parallel_sendData(master, data)
[16:59:36.463]                             }
[16:59:36.463]                             return(sendCondition)
[16:59:36.463]                           }
[16:59:36.463]                         }
[16:59:36.463]                         frame <- frame + 1L
[16:59:36.463]                         envir <- sys.frame(frame)
[16:59:36.463]                       }
[16:59:36.463]                     }
[16:59:36.463]                     sendCondition <<- function(cond) NULL
[16:59:36.463]                   }
[16:59:36.463]                 })
[16:59:36.463]                 withCallingHandlers({
[16:59:36.463]                   NA
[16:59:36.463]                 }, immediateCondition = function(cond) {
[16:59:36.463]                   sendCondition <- ...future.makeSendCondition()
[16:59:36.463]                   sendCondition(cond)
[16:59:36.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.463]                   {
[16:59:36.463]                     inherits <- base::inherits
[16:59:36.463]                     invokeRestart <- base::invokeRestart
[16:59:36.463]                     is.null <- base::is.null
[16:59:36.463]                     muffled <- FALSE
[16:59:36.463]                     if (inherits(cond, "message")) {
[16:59:36.463]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:36.463]                       if (muffled) 
[16:59:36.463]                         invokeRestart("muffleMessage")
[16:59:36.463]                     }
[16:59:36.463]                     else if (inherits(cond, "warning")) {
[16:59:36.463]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:36.463]                       if (muffled) 
[16:59:36.463]                         invokeRestart("muffleWarning")
[16:59:36.463]                     }
[16:59:36.463]                     else if (inherits(cond, "condition")) {
[16:59:36.463]                       if (!is.null(pattern)) {
[16:59:36.463]                         computeRestarts <- base::computeRestarts
[16:59:36.463]                         grepl <- base::grepl
[16:59:36.463]                         restarts <- computeRestarts(cond)
[16:59:36.463]                         for (restart in restarts) {
[16:59:36.463]                           name <- restart$name
[16:59:36.463]                           if (is.null(name)) 
[16:59:36.463]                             next
[16:59:36.463]                           if (!grepl(pattern, name)) 
[16:59:36.463]                             next
[16:59:36.463]                           invokeRestart(restart)
[16:59:36.463]                           muffled <- TRUE
[16:59:36.463]                           break
[16:59:36.463]                         }
[16:59:36.463]                       }
[16:59:36.463]                     }
[16:59:36.463]                     invisible(muffled)
[16:59:36.463]                   }
[16:59:36.463]                   muffleCondition(cond)
[16:59:36.463]                 })
[16:59:36.463]             }))
[16:59:36.463]             future::FutureResult(value = ...future.value$value, 
[16:59:36.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.463]                   ...future.rng), globalenv = if (FALSE) 
[16:59:36.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:36.463]                     ...future.globalenv.names))
[16:59:36.463]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:36.463]         }, condition = base::local({
[16:59:36.463]             c <- base::c
[16:59:36.463]             inherits <- base::inherits
[16:59:36.463]             invokeRestart <- base::invokeRestart
[16:59:36.463]             length <- base::length
[16:59:36.463]             list <- base::list
[16:59:36.463]             seq.int <- base::seq.int
[16:59:36.463]             signalCondition <- base::signalCondition
[16:59:36.463]             sys.calls <- base::sys.calls
[16:59:36.463]             `[[` <- base::`[[`
[16:59:36.463]             `+` <- base::`+`
[16:59:36.463]             `<<-` <- base::`<<-`
[16:59:36.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:36.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:36.463]                   3L)]
[16:59:36.463]             }
[16:59:36.463]             function(cond) {
[16:59:36.463]                 is_error <- inherits(cond, "error")
[16:59:36.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:36.463]                   NULL)
[16:59:36.463]                 if (is_error) {
[16:59:36.463]                   sessionInformation <- function() {
[16:59:36.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:36.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:36.463]                       search = base::search(), system = base::Sys.info())
[16:59:36.463]                   }
[16:59:36.463]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:36.463]                     cond$call), session = sessionInformation(), 
[16:59:36.463]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:36.463]                   signalCondition(cond)
[16:59:36.463]                 }
[16:59:36.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:36.463]                 "immediateCondition"))) {
[16:59:36.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:36.463]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:36.463]                   if (TRUE && !signal) {
[16:59:36.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.463]                     {
[16:59:36.463]                       inherits <- base::inherits
[16:59:36.463]                       invokeRestart <- base::invokeRestart
[16:59:36.463]                       is.null <- base::is.null
[16:59:36.463]                       muffled <- FALSE
[16:59:36.463]                       if (inherits(cond, "message")) {
[16:59:36.463]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.463]                         if (muffled) 
[16:59:36.463]                           invokeRestart("muffleMessage")
[16:59:36.463]                       }
[16:59:36.463]                       else if (inherits(cond, "warning")) {
[16:59:36.463]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.463]                         if (muffled) 
[16:59:36.463]                           invokeRestart("muffleWarning")
[16:59:36.463]                       }
[16:59:36.463]                       else if (inherits(cond, "condition")) {
[16:59:36.463]                         if (!is.null(pattern)) {
[16:59:36.463]                           computeRestarts <- base::computeRestarts
[16:59:36.463]                           grepl <- base::grepl
[16:59:36.463]                           restarts <- computeRestarts(cond)
[16:59:36.463]                           for (restart in restarts) {
[16:59:36.463]                             name <- restart$name
[16:59:36.463]                             if (is.null(name)) 
[16:59:36.463]                               next
[16:59:36.463]                             if (!grepl(pattern, name)) 
[16:59:36.463]                               next
[16:59:36.463]                             invokeRestart(restart)
[16:59:36.463]                             muffled <- TRUE
[16:59:36.463]                             break
[16:59:36.463]                           }
[16:59:36.463]                         }
[16:59:36.463]                       }
[16:59:36.463]                       invisible(muffled)
[16:59:36.463]                     }
[16:59:36.463]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.463]                   }
[16:59:36.463]                 }
[16:59:36.463]                 else {
[16:59:36.463]                   if (TRUE) {
[16:59:36.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.463]                     {
[16:59:36.463]                       inherits <- base::inherits
[16:59:36.463]                       invokeRestart <- base::invokeRestart
[16:59:36.463]                       is.null <- base::is.null
[16:59:36.463]                       muffled <- FALSE
[16:59:36.463]                       if (inherits(cond, "message")) {
[16:59:36.463]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.463]                         if (muffled) 
[16:59:36.463]                           invokeRestart("muffleMessage")
[16:59:36.463]                       }
[16:59:36.463]                       else if (inherits(cond, "warning")) {
[16:59:36.463]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.463]                         if (muffled) 
[16:59:36.463]                           invokeRestart("muffleWarning")
[16:59:36.463]                       }
[16:59:36.463]                       else if (inherits(cond, "condition")) {
[16:59:36.463]                         if (!is.null(pattern)) {
[16:59:36.463]                           computeRestarts <- base::computeRestarts
[16:59:36.463]                           grepl <- base::grepl
[16:59:36.463]                           restarts <- computeRestarts(cond)
[16:59:36.463]                           for (restart in restarts) {
[16:59:36.463]                             name <- restart$name
[16:59:36.463]                             if (is.null(name)) 
[16:59:36.463]                               next
[16:59:36.463]                             if (!grepl(pattern, name)) 
[16:59:36.463]                               next
[16:59:36.463]                             invokeRestart(restart)
[16:59:36.463]                             muffled <- TRUE
[16:59:36.463]                             break
[16:59:36.463]                           }
[16:59:36.463]                         }
[16:59:36.463]                       }
[16:59:36.463]                       invisible(muffled)
[16:59:36.463]                     }
[16:59:36.463]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.463]                   }
[16:59:36.463]                 }
[16:59:36.463]             }
[16:59:36.463]         }))
[16:59:36.463]     }, error = function(ex) {
[16:59:36.463]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:36.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.463]                 ...future.rng), started = ...future.startTime, 
[16:59:36.463]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:36.463]             version = "1.8"), class = "FutureResult")
[16:59:36.463]     }, finally = {
[16:59:36.463]         if (!identical(...future.workdir, getwd())) 
[16:59:36.463]             setwd(...future.workdir)
[16:59:36.463]         {
[16:59:36.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:36.463]                 ...future.oldOptions$nwarnings <- NULL
[16:59:36.463]             }
[16:59:36.463]             base::options(...future.oldOptions)
[16:59:36.463]             if (.Platform$OS.type == "windows") {
[16:59:36.463]                 old_names <- names(...future.oldEnvVars)
[16:59:36.463]                 envs <- base::Sys.getenv()
[16:59:36.463]                 names <- names(envs)
[16:59:36.463]                 common <- intersect(names, old_names)
[16:59:36.463]                 added <- setdiff(names, old_names)
[16:59:36.463]                 removed <- setdiff(old_names, names)
[16:59:36.463]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:36.463]                   envs[common]]
[16:59:36.463]                 NAMES <- toupper(changed)
[16:59:36.463]                 args <- list()
[16:59:36.463]                 for (kk in seq_along(NAMES)) {
[16:59:36.463]                   name <- changed[[kk]]
[16:59:36.463]                   NAME <- NAMES[[kk]]
[16:59:36.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.463]                     next
[16:59:36.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.463]                 }
[16:59:36.463]                 NAMES <- toupper(added)
[16:59:36.463]                 for (kk in seq_along(NAMES)) {
[16:59:36.463]                   name <- added[[kk]]
[16:59:36.463]                   NAME <- NAMES[[kk]]
[16:59:36.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.463]                     next
[16:59:36.463]                   args[[name]] <- ""
[16:59:36.463]                 }
[16:59:36.463]                 NAMES <- toupper(removed)
[16:59:36.463]                 for (kk in seq_along(NAMES)) {
[16:59:36.463]                   name <- removed[[kk]]
[16:59:36.463]                   NAME <- NAMES[[kk]]
[16:59:36.463]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.463]                     next
[16:59:36.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.463]                 }
[16:59:36.463]                 if (length(args) > 0) 
[16:59:36.463]                   base::do.call(base::Sys.setenv, args = args)
[16:59:36.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:36.463]             }
[16:59:36.463]             else {
[16:59:36.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:36.463]             }
[16:59:36.463]             {
[16:59:36.463]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:36.463]                   0L) {
[16:59:36.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:36.463]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:36.463]                   base::options(opts)
[16:59:36.463]                 }
[16:59:36.463]                 {
[16:59:36.463]                   {
[16:59:36.463]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:36.463]                     NULL
[16:59:36.463]                   }
[16:59:36.463]                   options(future.plan = NULL)
[16:59:36.463]                   if (is.na(NA_character_)) 
[16:59:36.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:36.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:36.463]                     .init = FALSE)
[16:59:36.463]                 }
[16:59:36.463]             }
[16:59:36.463]         }
[16:59:36.463]     })
[16:59:36.463]     if (TRUE) {
[16:59:36.463]         base::sink(type = "output", split = FALSE)
[16:59:36.463]         if (TRUE) {
[16:59:36.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:36.463]         }
[16:59:36.463]         else {
[16:59:36.463]             ...future.result["stdout"] <- base::list(NULL)
[16:59:36.463]         }
[16:59:36.463]         base::close(...future.stdout)
[16:59:36.463]         ...future.stdout <- NULL
[16:59:36.463]     }
[16:59:36.463]     ...future.result$conditions <- ...future.conditions
[16:59:36.463]     ...future.result$finished <- base::Sys.time()
[16:59:36.463]     ...future.result
[16:59:36.463] }
[16:59:36.518] MultisessionFuture started
[16:59:36.518] result() for ClusterFuture ...
[16:59:36.519] receiveMessageFromWorker() for ClusterFuture ...
[16:59:36.519] - Validating connection of MultisessionFuture
[16:59:36.552] - received message: FutureResult
[16:59:36.552] - Received FutureResult
[16:59:36.552] - Erased future from FutureRegistry
[16:59:36.553] result() for ClusterFuture ...
[16:59:36.553] - result already collected: FutureResult
[16:59:36.553] result() for ClusterFuture ... done
[16:59:36.553] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:36.553] result() for ClusterFuture ... done
[16:59:36.553] result() for ClusterFuture ...
[16:59:36.553] - result already collected: FutureResult
[16:59:36.553] result() for ClusterFuture ... done
[16:59:36.554] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:59:36.557] plan(): nbrOfWorkers() = 2
[16:59:36.558] future_by_internal() ...
[16:59:36.558] future_lapply() ...
[16:59:36.562] Number of chunks: 2
[16:59:36.563] getGlobalsAndPackagesXApply() ...
[16:59:36.563]  - future.globals: TRUE
[16:59:36.563] getGlobalsAndPackages() ...
[16:59:36.563] Searching for globals...
[16:59:36.564] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:36.565] Searching for globals ... DONE
[16:59:36.565] Resolving globals: FALSE
[16:59:36.565] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:36.565] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:36.566] - globals: [1] ‘FUN’
[16:59:36.566] 
[16:59:36.566] getGlobalsAndPackages() ... DONE
[16:59:36.566]  - globals found/used: [n=1] ‘FUN’
[16:59:36.566]  - needed namespaces: [n=0] 
[16:59:36.566] Finding globals ... DONE
[16:59:36.566]  - use_args: TRUE
[16:59:36.566]  - Getting '...' globals ...
[16:59:36.567] resolve() on list ...
[16:59:36.567]  recursive: 0
[16:59:36.567]  length: 1
[16:59:36.567]  elements: ‘...’
[16:59:36.567]  length: 0 (resolved future 1)
[16:59:36.568] resolve() on list ... DONE
[16:59:36.568]    - '...' content: [n=0] 
[16:59:36.568] List of 1
[16:59:36.568]  $ ...: list()
[16:59:36.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:36.568]  - attr(*, "where")=List of 1
[16:59:36.568]   ..$ ...:<environment: 0x562053e1fec0> 
[16:59:36.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:36.568]  - attr(*, "resolved")= logi TRUE
[16:59:36.568]  - attr(*, "total_size")= num NA
[16:59:36.571]  - Getting '...' globals ... DONE
[16:59:36.571] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:36.571] List of 2
[16:59:36.571]  $ ...future.FUN:function (object, ...)  
[16:59:36.571]  $ ...          : list()
[16:59:36.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:36.571]  - attr(*, "where")=List of 2
[16:59:36.571]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:36.571]   ..$ ...          :<environment: 0x562053e1fec0> 
[16:59:36.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:36.571]  - attr(*, "resolved")= logi FALSE
[16:59:36.571]  - attr(*, "total_size")= num 1240
[16:59:36.575] Packages to be attached in all futures: [n=0] 
[16:59:36.575] getGlobalsAndPackagesXApply() ... DONE
[16:59:36.575] Number of futures (= number of chunks): 2
[16:59:36.575] Launching 2 futures (chunks) ...
[16:59:36.575] Chunk #1 of 2 ...
[16:59:36.575]  - Finding globals in 'X' for chunk #1 ...
[16:59:36.576] getGlobalsAndPackages() ...
[16:59:36.576] Searching for globals...
[16:59:36.576] 
[16:59:36.576] Searching for globals ... DONE
[16:59:36.576] - globals: [0] <none>
[16:59:36.576] getGlobalsAndPackages() ... DONE
[16:59:36.576]    + additional globals found: [n=0] 
[16:59:36.577]    + additional namespaces needed: [n=0] 
[16:59:36.577]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:36.577]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:36.577]  - seeds: <none>
[16:59:36.577]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.577] getGlobalsAndPackages() ...
[16:59:36.577] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.577] Resolving globals: FALSE
[16:59:36.578] Tweak future expression to call with '...' arguments ...
[16:59:36.578] {
[16:59:36.578]     do.call(function(...) {
[16:59:36.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.578]             on.exit(options(oopts), add = TRUE)
[16:59:36.578]         }
[16:59:36.578]         {
[16:59:36.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.578]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.578]             })
[16:59:36.578]         }
[16:59:36.578]     }, args = future.call.arguments)
[16:59:36.578] }
[16:59:36.578] Tweak future expression to call with '...' arguments ... DONE
[16:59:36.578] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.579] 
[16:59:36.579] getGlobalsAndPackages() ... DONE
[16:59:36.579] run() for ‘Future’ ...
[16:59:36.579] - state: ‘created’
[16:59:36.579] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:36.594] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:36.595]   - Field: ‘node’
[16:59:36.595]   - Field: ‘label’
[16:59:36.595]   - Field: ‘local’
[16:59:36.595]   - Field: ‘owner’
[16:59:36.595]   - Field: ‘envir’
[16:59:36.595]   - Field: ‘workers’
[16:59:36.595]   - Field: ‘packages’
[16:59:36.595]   - Field: ‘gc’
[16:59:36.595]   - Field: ‘conditions’
[16:59:36.596]   - Field: ‘persistent’
[16:59:36.596]   - Field: ‘expr’
[16:59:36.596]   - Field: ‘uuid’
[16:59:36.596]   - Field: ‘seed’
[16:59:36.596]   - Field: ‘version’
[16:59:36.596]   - Field: ‘result’
[16:59:36.596]   - Field: ‘asynchronous’
[16:59:36.596]   - Field: ‘calls’
[16:59:36.596]   - Field: ‘globals’
[16:59:36.597]   - Field: ‘stdout’
[16:59:36.597]   - Field: ‘earlySignal’
[16:59:36.597]   - Field: ‘lazy’
[16:59:36.597]   - Field: ‘state’
[16:59:36.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:36.597] - Launch lazy future ...
[16:59:36.597] Packages needed by the future expression (n = 0): <none>
[16:59:36.598] Packages needed by future strategies (n = 0): <none>
[16:59:36.598] {
[16:59:36.598]     {
[16:59:36.598]         {
[16:59:36.598]             ...future.startTime <- base::Sys.time()
[16:59:36.598]             {
[16:59:36.598]                 {
[16:59:36.598]                   {
[16:59:36.598]                     {
[16:59:36.598]                       base::local({
[16:59:36.598]                         has_future <- base::requireNamespace("future", 
[16:59:36.598]                           quietly = TRUE)
[16:59:36.598]                         if (has_future) {
[16:59:36.598]                           ns <- base::getNamespace("future")
[16:59:36.598]                           version <- ns[[".package"]][["version"]]
[16:59:36.598]                           if (is.null(version)) 
[16:59:36.598]                             version <- utils::packageVersion("future")
[16:59:36.598]                         }
[16:59:36.598]                         else {
[16:59:36.598]                           version <- NULL
[16:59:36.598]                         }
[16:59:36.598]                         if (!has_future || version < "1.8.0") {
[16:59:36.598]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:36.598]                             "", base::R.version$version.string), 
[16:59:36.598]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:36.598]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:36.598]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:36.598]                               "release", "version")], collapse = " "), 
[16:59:36.598]                             hostname = base::Sys.info()[["nodename"]])
[16:59:36.598]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:36.598]                             info)
[16:59:36.598]                           info <- base::paste(info, collapse = "; ")
[16:59:36.598]                           if (!has_future) {
[16:59:36.598]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:36.598]                               info)
[16:59:36.598]                           }
[16:59:36.598]                           else {
[16:59:36.598]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:36.598]                               info, version)
[16:59:36.598]                           }
[16:59:36.598]                           base::stop(msg)
[16:59:36.598]                         }
[16:59:36.598]                       })
[16:59:36.598]                     }
[16:59:36.598]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:36.598]                     base::options(mc.cores = 1L)
[16:59:36.598]                   }
[16:59:36.598]                   ...future.strategy.old <- future::plan("list")
[16:59:36.598]                   options(future.plan = NULL)
[16:59:36.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:36.598]                 }
[16:59:36.598]                 ...future.workdir <- getwd()
[16:59:36.598]             }
[16:59:36.598]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:36.598]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:36.598]         }
[16:59:36.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:36.598]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:36.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:36.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:36.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:36.598]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:36.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:36.598]             base::names(...future.oldOptions))
[16:59:36.598]     }
[16:59:36.598]     if (FALSE) {
[16:59:36.598]     }
[16:59:36.598]     else {
[16:59:36.598]         if (TRUE) {
[16:59:36.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:36.598]                 open = "w")
[16:59:36.598]         }
[16:59:36.598]         else {
[16:59:36.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:36.598]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:36.598]         }
[16:59:36.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:36.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:36.598]             base::sink(type = "output", split = FALSE)
[16:59:36.598]             base::close(...future.stdout)
[16:59:36.598]         }, add = TRUE)
[16:59:36.598]     }
[16:59:36.598]     ...future.frame <- base::sys.nframe()
[16:59:36.598]     ...future.conditions <- base::list()
[16:59:36.598]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:36.598]     if (FALSE) {
[16:59:36.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:36.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:36.598]     }
[16:59:36.598]     ...future.result <- base::tryCatch({
[16:59:36.598]         base::withCallingHandlers({
[16:59:36.598]             ...future.value <- base::withVisible(base::local({
[16:59:36.598]                 ...future.makeSendCondition <- base::local({
[16:59:36.598]                   sendCondition <- NULL
[16:59:36.598]                   function(frame = 1L) {
[16:59:36.598]                     if (is.function(sendCondition)) 
[16:59:36.598]                       return(sendCondition)
[16:59:36.598]                     ns <- getNamespace("parallel")
[16:59:36.598]                     if (exists("sendData", mode = "function", 
[16:59:36.598]                       envir = ns)) {
[16:59:36.598]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:36.598]                         envir = ns)
[16:59:36.598]                       envir <- sys.frame(frame)
[16:59:36.598]                       master <- NULL
[16:59:36.598]                       while (!identical(envir, .GlobalEnv) && 
[16:59:36.598]                         !identical(envir, emptyenv())) {
[16:59:36.598]                         if (exists("master", mode = "list", envir = envir, 
[16:59:36.598]                           inherits = FALSE)) {
[16:59:36.598]                           master <- get("master", mode = "list", 
[16:59:36.598]                             envir = envir, inherits = FALSE)
[16:59:36.598]                           if (inherits(master, c("SOCKnode", 
[16:59:36.598]                             "SOCK0node"))) {
[16:59:36.598]                             sendCondition <<- function(cond) {
[16:59:36.598]                               data <- list(type = "VALUE", value = cond, 
[16:59:36.598]                                 success = TRUE)
[16:59:36.598]                               parallel_sendData(master, data)
[16:59:36.598]                             }
[16:59:36.598]                             return(sendCondition)
[16:59:36.598]                           }
[16:59:36.598]                         }
[16:59:36.598]                         frame <- frame + 1L
[16:59:36.598]                         envir <- sys.frame(frame)
[16:59:36.598]                       }
[16:59:36.598]                     }
[16:59:36.598]                     sendCondition <<- function(cond) NULL
[16:59:36.598]                   }
[16:59:36.598]                 })
[16:59:36.598]                 withCallingHandlers({
[16:59:36.598]                   {
[16:59:36.598]                     do.call(function(...) {
[16:59:36.598]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.598]                       if (!identical(...future.globals.maxSize.org, 
[16:59:36.598]                         ...future.globals.maxSize)) {
[16:59:36.598]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.598]                         on.exit(options(oopts), add = TRUE)
[16:59:36.598]                       }
[16:59:36.598]                       {
[16:59:36.598]                         lapply(seq_along(...future.elements_ii), 
[16:59:36.598]                           FUN = function(jj) {
[16:59:36.598]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.598]                             ...future.FUN(...future.X_jj, ...)
[16:59:36.598]                           })
[16:59:36.598]                       }
[16:59:36.598]                     }, args = future.call.arguments)
[16:59:36.598]                   }
[16:59:36.598]                 }, immediateCondition = function(cond) {
[16:59:36.598]                   sendCondition <- ...future.makeSendCondition()
[16:59:36.598]                   sendCondition(cond)
[16:59:36.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.598]                   {
[16:59:36.598]                     inherits <- base::inherits
[16:59:36.598]                     invokeRestart <- base::invokeRestart
[16:59:36.598]                     is.null <- base::is.null
[16:59:36.598]                     muffled <- FALSE
[16:59:36.598]                     if (inherits(cond, "message")) {
[16:59:36.598]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:36.598]                       if (muffled) 
[16:59:36.598]                         invokeRestart("muffleMessage")
[16:59:36.598]                     }
[16:59:36.598]                     else if (inherits(cond, "warning")) {
[16:59:36.598]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:36.598]                       if (muffled) 
[16:59:36.598]                         invokeRestart("muffleWarning")
[16:59:36.598]                     }
[16:59:36.598]                     else if (inherits(cond, "condition")) {
[16:59:36.598]                       if (!is.null(pattern)) {
[16:59:36.598]                         computeRestarts <- base::computeRestarts
[16:59:36.598]                         grepl <- base::grepl
[16:59:36.598]                         restarts <- computeRestarts(cond)
[16:59:36.598]                         for (restart in restarts) {
[16:59:36.598]                           name <- restart$name
[16:59:36.598]                           if (is.null(name)) 
[16:59:36.598]                             next
[16:59:36.598]                           if (!grepl(pattern, name)) 
[16:59:36.598]                             next
[16:59:36.598]                           invokeRestart(restart)
[16:59:36.598]                           muffled <- TRUE
[16:59:36.598]                           break
[16:59:36.598]                         }
[16:59:36.598]                       }
[16:59:36.598]                     }
[16:59:36.598]                     invisible(muffled)
[16:59:36.598]                   }
[16:59:36.598]                   muffleCondition(cond)
[16:59:36.598]                 })
[16:59:36.598]             }))
[16:59:36.598]             future::FutureResult(value = ...future.value$value, 
[16:59:36.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.598]                   ...future.rng), globalenv = if (FALSE) 
[16:59:36.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:36.598]                     ...future.globalenv.names))
[16:59:36.598]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:36.598]         }, condition = base::local({
[16:59:36.598]             c <- base::c
[16:59:36.598]             inherits <- base::inherits
[16:59:36.598]             invokeRestart <- base::invokeRestart
[16:59:36.598]             length <- base::length
[16:59:36.598]             list <- base::list
[16:59:36.598]             seq.int <- base::seq.int
[16:59:36.598]             signalCondition <- base::signalCondition
[16:59:36.598]             sys.calls <- base::sys.calls
[16:59:36.598]             `[[` <- base::`[[`
[16:59:36.598]             `+` <- base::`+`
[16:59:36.598]             `<<-` <- base::`<<-`
[16:59:36.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:36.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:36.598]                   3L)]
[16:59:36.598]             }
[16:59:36.598]             function(cond) {
[16:59:36.598]                 is_error <- inherits(cond, "error")
[16:59:36.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:36.598]                   NULL)
[16:59:36.598]                 if (is_error) {
[16:59:36.598]                   sessionInformation <- function() {
[16:59:36.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:36.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:36.598]                       search = base::search(), system = base::Sys.info())
[16:59:36.598]                   }
[16:59:36.598]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:36.598]                     cond$call), session = sessionInformation(), 
[16:59:36.598]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:36.598]                   signalCondition(cond)
[16:59:36.598]                 }
[16:59:36.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:36.598]                 "immediateCondition"))) {
[16:59:36.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:36.598]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:36.598]                   if (TRUE && !signal) {
[16:59:36.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.598]                     {
[16:59:36.598]                       inherits <- base::inherits
[16:59:36.598]                       invokeRestart <- base::invokeRestart
[16:59:36.598]                       is.null <- base::is.null
[16:59:36.598]                       muffled <- FALSE
[16:59:36.598]                       if (inherits(cond, "message")) {
[16:59:36.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.598]                         if (muffled) 
[16:59:36.598]                           invokeRestart("muffleMessage")
[16:59:36.598]                       }
[16:59:36.598]                       else if (inherits(cond, "warning")) {
[16:59:36.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.598]                         if (muffled) 
[16:59:36.598]                           invokeRestart("muffleWarning")
[16:59:36.598]                       }
[16:59:36.598]                       else if (inherits(cond, "condition")) {
[16:59:36.598]                         if (!is.null(pattern)) {
[16:59:36.598]                           computeRestarts <- base::computeRestarts
[16:59:36.598]                           grepl <- base::grepl
[16:59:36.598]                           restarts <- computeRestarts(cond)
[16:59:36.598]                           for (restart in restarts) {
[16:59:36.598]                             name <- restart$name
[16:59:36.598]                             if (is.null(name)) 
[16:59:36.598]                               next
[16:59:36.598]                             if (!grepl(pattern, name)) 
[16:59:36.598]                               next
[16:59:36.598]                             invokeRestart(restart)
[16:59:36.598]                             muffled <- TRUE
[16:59:36.598]                             break
[16:59:36.598]                           }
[16:59:36.598]                         }
[16:59:36.598]                       }
[16:59:36.598]                       invisible(muffled)
[16:59:36.598]                     }
[16:59:36.598]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.598]                   }
[16:59:36.598]                 }
[16:59:36.598]                 else {
[16:59:36.598]                   if (TRUE) {
[16:59:36.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.598]                     {
[16:59:36.598]                       inherits <- base::inherits
[16:59:36.598]                       invokeRestart <- base::invokeRestart
[16:59:36.598]                       is.null <- base::is.null
[16:59:36.598]                       muffled <- FALSE
[16:59:36.598]                       if (inherits(cond, "message")) {
[16:59:36.598]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.598]                         if (muffled) 
[16:59:36.598]                           invokeRestart("muffleMessage")
[16:59:36.598]                       }
[16:59:36.598]                       else if (inherits(cond, "warning")) {
[16:59:36.598]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.598]                         if (muffled) 
[16:59:36.598]                           invokeRestart("muffleWarning")
[16:59:36.598]                       }
[16:59:36.598]                       else if (inherits(cond, "condition")) {
[16:59:36.598]                         if (!is.null(pattern)) {
[16:59:36.598]                           computeRestarts <- base::computeRestarts
[16:59:36.598]                           grepl <- base::grepl
[16:59:36.598]                           restarts <- computeRestarts(cond)
[16:59:36.598]                           for (restart in restarts) {
[16:59:36.598]                             name <- restart$name
[16:59:36.598]                             if (is.null(name)) 
[16:59:36.598]                               next
[16:59:36.598]                             if (!grepl(pattern, name)) 
[16:59:36.598]                               next
[16:59:36.598]                             invokeRestart(restart)
[16:59:36.598]                             muffled <- TRUE
[16:59:36.598]                             break
[16:59:36.598]                           }
[16:59:36.598]                         }
[16:59:36.598]                       }
[16:59:36.598]                       invisible(muffled)
[16:59:36.598]                     }
[16:59:36.598]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.598]                   }
[16:59:36.598]                 }
[16:59:36.598]             }
[16:59:36.598]         }))
[16:59:36.598]     }, error = function(ex) {
[16:59:36.598]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:36.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.598]                 ...future.rng), started = ...future.startTime, 
[16:59:36.598]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:36.598]             version = "1.8"), class = "FutureResult")
[16:59:36.598]     }, finally = {
[16:59:36.598]         if (!identical(...future.workdir, getwd())) 
[16:59:36.598]             setwd(...future.workdir)
[16:59:36.598]         {
[16:59:36.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:36.598]                 ...future.oldOptions$nwarnings <- NULL
[16:59:36.598]             }
[16:59:36.598]             base::options(...future.oldOptions)
[16:59:36.598]             if (.Platform$OS.type == "windows") {
[16:59:36.598]                 old_names <- names(...future.oldEnvVars)
[16:59:36.598]                 envs <- base::Sys.getenv()
[16:59:36.598]                 names <- names(envs)
[16:59:36.598]                 common <- intersect(names, old_names)
[16:59:36.598]                 added <- setdiff(names, old_names)
[16:59:36.598]                 removed <- setdiff(old_names, names)
[16:59:36.598]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:36.598]                   envs[common]]
[16:59:36.598]                 NAMES <- toupper(changed)
[16:59:36.598]                 args <- list()
[16:59:36.598]                 for (kk in seq_along(NAMES)) {
[16:59:36.598]                   name <- changed[[kk]]
[16:59:36.598]                   NAME <- NAMES[[kk]]
[16:59:36.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.598]                     next
[16:59:36.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.598]                 }
[16:59:36.598]                 NAMES <- toupper(added)
[16:59:36.598]                 for (kk in seq_along(NAMES)) {
[16:59:36.598]                   name <- added[[kk]]
[16:59:36.598]                   NAME <- NAMES[[kk]]
[16:59:36.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.598]                     next
[16:59:36.598]                   args[[name]] <- ""
[16:59:36.598]                 }
[16:59:36.598]                 NAMES <- toupper(removed)
[16:59:36.598]                 for (kk in seq_along(NAMES)) {
[16:59:36.598]                   name <- removed[[kk]]
[16:59:36.598]                   NAME <- NAMES[[kk]]
[16:59:36.598]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.598]                     next
[16:59:36.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.598]                 }
[16:59:36.598]                 if (length(args) > 0) 
[16:59:36.598]                   base::do.call(base::Sys.setenv, args = args)
[16:59:36.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:36.598]             }
[16:59:36.598]             else {
[16:59:36.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:36.598]             }
[16:59:36.598]             {
[16:59:36.598]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:36.598]                   0L) {
[16:59:36.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:36.598]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:36.598]                   base::options(opts)
[16:59:36.598]                 }
[16:59:36.598]                 {
[16:59:36.598]                   {
[16:59:36.598]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:36.598]                     NULL
[16:59:36.598]                   }
[16:59:36.598]                   options(future.plan = NULL)
[16:59:36.598]                   if (is.na(NA_character_)) 
[16:59:36.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:36.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:36.598]                     .init = FALSE)
[16:59:36.598]                 }
[16:59:36.598]             }
[16:59:36.598]         }
[16:59:36.598]     })
[16:59:36.598]     if (TRUE) {
[16:59:36.598]         base::sink(type = "output", split = FALSE)
[16:59:36.598]         if (TRUE) {
[16:59:36.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:36.598]         }
[16:59:36.598]         else {
[16:59:36.598]             ...future.result["stdout"] <- base::list(NULL)
[16:59:36.598]         }
[16:59:36.598]         base::close(...future.stdout)
[16:59:36.598]         ...future.stdout <- NULL
[16:59:36.598]     }
[16:59:36.598]     ...future.result$conditions <- ...future.conditions
[16:59:36.598]     ...future.result$finished <- base::Sys.time()
[16:59:36.598]     ...future.result
[16:59:36.598] }
[16:59:36.601] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:59:36.601] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:59:36.602] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:59:36.602] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:36.603] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.603] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ...
[16:59:36.603] Exporting ‘...future.elements_ii’ (880 bytes) to cluster node #1 ... DONE
[16:59:36.604] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:36.604] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.604] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:36.605] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.605] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:59:36.605] MultisessionFuture started
[16:59:36.605] - Launch lazy future ... done
[16:59:36.606] run() for ‘MultisessionFuture’ ... done
[16:59:36.606] Created future:
[16:59:36.606] MultisessionFuture:
[16:59:36.606] Label: ‘future_by-1’
[16:59:36.606] Expression:
[16:59:36.606] {
[16:59:36.606]     do.call(function(...) {
[16:59:36.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.606]             on.exit(options(oopts), add = TRUE)
[16:59:36.606]         }
[16:59:36.606]         {
[16:59:36.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.606]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.606]             })
[16:59:36.606]         }
[16:59:36.606]     }, args = future.call.arguments)
[16:59:36.606] }
[16:59:36.606] Lazy evaluation: FALSE
[16:59:36.606] Asynchronous evaluation: TRUE
[16:59:36.606] Local evaluation: TRUE
[16:59:36.606] Environment: R_GlobalEnv
[16:59:36.606] Capture standard output: TRUE
[16:59:36.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:36.606] Globals: 5 objects totaling 2.07 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 880 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:36.606] Packages: <none>
[16:59:36.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:36.606] Resolved: FALSE
[16:59:36.606] Value: <not collected>
[16:59:36.606] Conditions captured: <none>
[16:59:36.606] Early signaling: FALSE
[16:59:36.606] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:36.606] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.618] Chunk #1 of 2 ... DONE
[16:59:36.618] Chunk #2 of 2 ...
[16:59:36.618]  - Finding globals in 'X' for chunk #2 ...
[16:59:36.619] getGlobalsAndPackages() ...
[16:59:36.619] Searching for globals...
[16:59:36.619] 
[16:59:36.619] Searching for globals ... DONE
[16:59:36.619] - globals: [0] <none>
[16:59:36.620] getGlobalsAndPackages() ... DONE
[16:59:36.620]    + additional globals found: [n=0] 
[16:59:36.620]    + additional namespaces needed: [n=0] 
[16:59:36.620]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:36.620]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:36.620]  - seeds: <none>
[16:59:36.620]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.620] getGlobalsAndPackages() ...
[16:59:36.621] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.621] Resolving globals: FALSE
[16:59:36.621] Tweak future expression to call with '...' arguments ...
[16:59:36.621] {
[16:59:36.621]     do.call(function(...) {
[16:59:36.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.621]             on.exit(options(oopts), add = TRUE)
[16:59:36.621]         }
[16:59:36.621]         {
[16:59:36.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.621]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.621]             })
[16:59:36.621]         }
[16:59:36.621]     }, args = future.call.arguments)
[16:59:36.621] }
[16:59:36.621] Tweak future expression to call with '...' arguments ... DONE
[16:59:36.622] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.622] 
[16:59:36.622] getGlobalsAndPackages() ... DONE
[16:59:36.622] run() for ‘Future’ ...
[16:59:36.622] - state: ‘created’
[16:59:36.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:36.640] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:36.640]   - Field: ‘node’
[16:59:36.640]   - Field: ‘label’
[16:59:36.640]   - Field: ‘local’
[16:59:36.640]   - Field: ‘owner’
[16:59:36.641]   - Field: ‘envir’
[16:59:36.641]   - Field: ‘workers’
[16:59:36.641]   - Field: ‘packages’
[16:59:36.641]   - Field: ‘gc’
[16:59:36.641]   - Field: ‘conditions’
[16:59:36.641]   - Field: ‘persistent’
[16:59:36.641]   - Field: ‘expr’
[16:59:36.641]   - Field: ‘uuid’
[16:59:36.641]   - Field: ‘seed’
[16:59:36.642]   - Field: ‘version’
[16:59:36.642]   - Field: ‘result’
[16:59:36.642]   - Field: ‘asynchronous’
[16:59:36.642]   - Field: ‘calls’
[16:59:36.642]   - Field: ‘globals’
[16:59:36.642]   - Field: ‘stdout’
[16:59:36.642]   - Field: ‘earlySignal’
[16:59:36.642]   - Field: ‘lazy’
[16:59:36.642]   - Field: ‘state’
[16:59:36.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:36.643] - Launch lazy future ...
[16:59:36.643] Packages needed by the future expression (n = 0): <none>
[16:59:36.643] Packages needed by future strategies (n = 0): <none>
[16:59:36.644] {
[16:59:36.644]     {
[16:59:36.644]         {
[16:59:36.644]             ...future.startTime <- base::Sys.time()
[16:59:36.644]             {
[16:59:36.644]                 {
[16:59:36.644]                   {
[16:59:36.644]                     {
[16:59:36.644]                       base::local({
[16:59:36.644]                         has_future <- base::requireNamespace("future", 
[16:59:36.644]                           quietly = TRUE)
[16:59:36.644]                         if (has_future) {
[16:59:36.644]                           ns <- base::getNamespace("future")
[16:59:36.644]                           version <- ns[[".package"]][["version"]]
[16:59:36.644]                           if (is.null(version)) 
[16:59:36.644]                             version <- utils::packageVersion("future")
[16:59:36.644]                         }
[16:59:36.644]                         else {
[16:59:36.644]                           version <- NULL
[16:59:36.644]                         }
[16:59:36.644]                         if (!has_future || version < "1.8.0") {
[16:59:36.644]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:36.644]                             "", base::R.version$version.string), 
[16:59:36.644]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:36.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:36.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:36.644]                               "release", "version")], collapse = " "), 
[16:59:36.644]                             hostname = base::Sys.info()[["nodename"]])
[16:59:36.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:36.644]                             info)
[16:59:36.644]                           info <- base::paste(info, collapse = "; ")
[16:59:36.644]                           if (!has_future) {
[16:59:36.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:36.644]                               info)
[16:59:36.644]                           }
[16:59:36.644]                           else {
[16:59:36.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:36.644]                               info, version)
[16:59:36.644]                           }
[16:59:36.644]                           base::stop(msg)
[16:59:36.644]                         }
[16:59:36.644]                       })
[16:59:36.644]                     }
[16:59:36.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:36.644]                     base::options(mc.cores = 1L)
[16:59:36.644]                   }
[16:59:36.644]                   ...future.strategy.old <- future::plan("list")
[16:59:36.644]                   options(future.plan = NULL)
[16:59:36.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:36.644]                 }
[16:59:36.644]                 ...future.workdir <- getwd()
[16:59:36.644]             }
[16:59:36.644]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:36.644]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:36.644]         }
[16:59:36.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:36.644]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:36.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:36.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:36.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:36.644]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:36.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:36.644]             base::names(...future.oldOptions))
[16:59:36.644]     }
[16:59:36.644]     if (FALSE) {
[16:59:36.644]     }
[16:59:36.644]     else {
[16:59:36.644]         if (TRUE) {
[16:59:36.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:36.644]                 open = "w")
[16:59:36.644]         }
[16:59:36.644]         else {
[16:59:36.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:36.644]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:36.644]         }
[16:59:36.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:36.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:36.644]             base::sink(type = "output", split = FALSE)
[16:59:36.644]             base::close(...future.stdout)
[16:59:36.644]         }, add = TRUE)
[16:59:36.644]     }
[16:59:36.644]     ...future.frame <- base::sys.nframe()
[16:59:36.644]     ...future.conditions <- base::list()
[16:59:36.644]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:36.644]     if (FALSE) {
[16:59:36.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:36.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:36.644]     }
[16:59:36.644]     ...future.result <- base::tryCatch({
[16:59:36.644]         base::withCallingHandlers({
[16:59:36.644]             ...future.value <- base::withVisible(base::local({
[16:59:36.644]                 ...future.makeSendCondition <- base::local({
[16:59:36.644]                   sendCondition <- NULL
[16:59:36.644]                   function(frame = 1L) {
[16:59:36.644]                     if (is.function(sendCondition)) 
[16:59:36.644]                       return(sendCondition)
[16:59:36.644]                     ns <- getNamespace("parallel")
[16:59:36.644]                     if (exists("sendData", mode = "function", 
[16:59:36.644]                       envir = ns)) {
[16:59:36.644]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:36.644]                         envir = ns)
[16:59:36.644]                       envir <- sys.frame(frame)
[16:59:36.644]                       master <- NULL
[16:59:36.644]                       while (!identical(envir, .GlobalEnv) && 
[16:59:36.644]                         !identical(envir, emptyenv())) {
[16:59:36.644]                         if (exists("master", mode = "list", envir = envir, 
[16:59:36.644]                           inherits = FALSE)) {
[16:59:36.644]                           master <- get("master", mode = "list", 
[16:59:36.644]                             envir = envir, inherits = FALSE)
[16:59:36.644]                           if (inherits(master, c("SOCKnode", 
[16:59:36.644]                             "SOCK0node"))) {
[16:59:36.644]                             sendCondition <<- function(cond) {
[16:59:36.644]                               data <- list(type = "VALUE", value = cond, 
[16:59:36.644]                                 success = TRUE)
[16:59:36.644]                               parallel_sendData(master, data)
[16:59:36.644]                             }
[16:59:36.644]                             return(sendCondition)
[16:59:36.644]                           }
[16:59:36.644]                         }
[16:59:36.644]                         frame <- frame + 1L
[16:59:36.644]                         envir <- sys.frame(frame)
[16:59:36.644]                       }
[16:59:36.644]                     }
[16:59:36.644]                     sendCondition <<- function(cond) NULL
[16:59:36.644]                   }
[16:59:36.644]                 })
[16:59:36.644]                 withCallingHandlers({
[16:59:36.644]                   {
[16:59:36.644]                     do.call(function(...) {
[16:59:36.644]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.644]                       if (!identical(...future.globals.maxSize.org, 
[16:59:36.644]                         ...future.globals.maxSize)) {
[16:59:36.644]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.644]                         on.exit(options(oopts), add = TRUE)
[16:59:36.644]                       }
[16:59:36.644]                       {
[16:59:36.644]                         lapply(seq_along(...future.elements_ii), 
[16:59:36.644]                           FUN = function(jj) {
[16:59:36.644]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.644]                             ...future.FUN(...future.X_jj, ...)
[16:59:36.644]                           })
[16:59:36.644]                       }
[16:59:36.644]                     }, args = future.call.arguments)
[16:59:36.644]                   }
[16:59:36.644]                 }, immediateCondition = function(cond) {
[16:59:36.644]                   sendCondition <- ...future.makeSendCondition()
[16:59:36.644]                   sendCondition(cond)
[16:59:36.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.644]                   {
[16:59:36.644]                     inherits <- base::inherits
[16:59:36.644]                     invokeRestart <- base::invokeRestart
[16:59:36.644]                     is.null <- base::is.null
[16:59:36.644]                     muffled <- FALSE
[16:59:36.644]                     if (inherits(cond, "message")) {
[16:59:36.644]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:36.644]                       if (muffled) 
[16:59:36.644]                         invokeRestart("muffleMessage")
[16:59:36.644]                     }
[16:59:36.644]                     else if (inherits(cond, "warning")) {
[16:59:36.644]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:36.644]                       if (muffled) 
[16:59:36.644]                         invokeRestart("muffleWarning")
[16:59:36.644]                     }
[16:59:36.644]                     else if (inherits(cond, "condition")) {
[16:59:36.644]                       if (!is.null(pattern)) {
[16:59:36.644]                         computeRestarts <- base::computeRestarts
[16:59:36.644]                         grepl <- base::grepl
[16:59:36.644]                         restarts <- computeRestarts(cond)
[16:59:36.644]                         for (restart in restarts) {
[16:59:36.644]                           name <- restart$name
[16:59:36.644]                           if (is.null(name)) 
[16:59:36.644]                             next
[16:59:36.644]                           if (!grepl(pattern, name)) 
[16:59:36.644]                             next
[16:59:36.644]                           invokeRestart(restart)
[16:59:36.644]                           muffled <- TRUE
[16:59:36.644]                           break
[16:59:36.644]                         }
[16:59:36.644]                       }
[16:59:36.644]                     }
[16:59:36.644]                     invisible(muffled)
[16:59:36.644]                   }
[16:59:36.644]                   muffleCondition(cond)
[16:59:36.644]                 })
[16:59:36.644]             }))
[16:59:36.644]             future::FutureResult(value = ...future.value$value, 
[16:59:36.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.644]                   ...future.rng), globalenv = if (FALSE) 
[16:59:36.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:36.644]                     ...future.globalenv.names))
[16:59:36.644]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:36.644]         }, condition = base::local({
[16:59:36.644]             c <- base::c
[16:59:36.644]             inherits <- base::inherits
[16:59:36.644]             invokeRestart <- base::invokeRestart
[16:59:36.644]             length <- base::length
[16:59:36.644]             list <- base::list
[16:59:36.644]             seq.int <- base::seq.int
[16:59:36.644]             signalCondition <- base::signalCondition
[16:59:36.644]             sys.calls <- base::sys.calls
[16:59:36.644]             `[[` <- base::`[[`
[16:59:36.644]             `+` <- base::`+`
[16:59:36.644]             `<<-` <- base::`<<-`
[16:59:36.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:36.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:36.644]                   3L)]
[16:59:36.644]             }
[16:59:36.644]             function(cond) {
[16:59:36.644]                 is_error <- inherits(cond, "error")
[16:59:36.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:36.644]                   NULL)
[16:59:36.644]                 if (is_error) {
[16:59:36.644]                   sessionInformation <- function() {
[16:59:36.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:36.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:36.644]                       search = base::search(), system = base::Sys.info())
[16:59:36.644]                   }
[16:59:36.644]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:36.644]                     cond$call), session = sessionInformation(), 
[16:59:36.644]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:36.644]                   signalCondition(cond)
[16:59:36.644]                 }
[16:59:36.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:36.644]                 "immediateCondition"))) {
[16:59:36.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:36.644]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:36.644]                   if (TRUE && !signal) {
[16:59:36.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.644]                     {
[16:59:36.644]                       inherits <- base::inherits
[16:59:36.644]                       invokeRestart <- base::invokeRestart
[16:59:36.644]                       is.null <- base::is.null
[16:59:36.644]                       muffled <- FALSE
[16:59:36.644]                       if (inherits(cond, "message")) {
[16:59:36.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.644]                         if (muffled) 
[16:59:36.644]                           invokeRestart("muffleMessage")
[16:59:36.644]                       }
[16:59:36.644]                       else if (inherits(cond, "warning")) {
[16:59:36.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.644]                         if (muffled) 
[16:59:36.644]                           invokeRestart("muffleWarning")
[16:59:36.644]                       }
[16:59:36.644]                       else if (inherits(cond, "condition")) {
[16:59:36.644]                         if (!is.null(pattern)) {
[16:59:36.644]                           computeRestarts <- base::computeRestarts
[16:59:36.644]                           grepl <- base::grepl
[16:59:36.644]                           restarts <- computeRestarts(cond)
[16:59:36.644]                           for (restart in restarts) {
[16:59:36.644]                             name <- restart$name
[16:59:36.644]                             if (is.null(name)) 
[16:59:36.644]                               next
[16:59:36.644]                             if (!grepl(pattern, name)) 
[16:59:36.644]                               next
[16:59:36.644]                             invokeRestart(restart)
[16:59:36.644]                             muffled <- TRUE
[16:59:36.644]                             break
[16:59:36.644]                           }
[16:59:36.644]                         }
[16:59:36.644]                       }
[16:59:36.644]                       invisible(muffled)
[16:59:36.644]                     }
[16:59:36.644]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.644]                   }
[16:59:36.644]                 }
[16:59:36.644]                 else {
[16:59:36.644]                   if (TRUE) {
[16:59:36.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.644]                     {
[16:59:36.644]                       inherits <- base::inherits
[16:59:36.644]                       invokeRestart <- base::invokeRestart
[16:59:36.644]                       is.null <- base::is.null
[16:59:36.644]                       muffled <- FALSE
[16:59:36.644]                       if (inherits(cond, "message")) {
[16:59:36.644]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.644]                         if (muffled) 
[16:59:36.644]                           invokeRestart("muffleMessage")
[16:59:36.644]                       }
[16:59:36.644]                       else if (inherits(cond, "warning")) {
[16:59:36.644]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.644]                         if (muffled) 
[16:59:36.644]                           invokeRestart("muffleWarning")
[16:59:36.644]                       }
[16:59:36.644]                       else if (inherits(cond, "condition")) {
[16:59:36.644]                         if (!is.null(pattern)) {
[16:59:36.644]                           computeRestarts <- base::computeRestarts
[16:59:36.644]                           grepl <- base::grepl
[16:59:36.644]                           restarts <- computeRestarts(cond)
[16:59:36.644]                           for (restart in restarts) {
[16:59:36.644]                             name <- restart$name
[16:59:36.644]                             if (is.null(name)) 
[16:59:36.644]                               next
[16:59:36.644]                             if (!grepl(pattern, name)) 
[16:59:36.644]                               next
[16:59:36.644]                             invokeRestart(restart)
[16:59:36.644]                             muffled <- TRUE
[16:59:36.644]                             break
[16:59:36.644]                           }
[16:59:36.644]                         }
[16:59:36.644]                       }
[16:59:36.644]                       invisible(muffled)
[16:59:36.644]                     }
[16:59:36.644]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.644]                   }
[16:59:36.644]                 }
[16:59:36.644]             }
[16:59:36.644]         }))
[16:59:36.644]     }, error = function(ex) {
[16:59:36.644]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:36.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.644]                 ...future.rng), started = ...future.startTime, 
[16:59:36.644]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:36.644]             version = "1.8"), class = "FutureResult")
[16:59:36.644]     }, finally = {
[16:59:36.644]         if (!identical(...future.workdir, getwd())) 
[16:59:36.644]             setwd(...future.workdir)
[16:59:36.644]         {
[16:59:36.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:36.644]                 ...future.oldOptions$nwarnings <- NULL
[16:59:36.644]             }
[16:59:36.644]             base::options(...future.oldOptions)
[16:59:36.644]             if (.Platform$OS.type == "windows") {
[16:59:36.644]                 old_names <- names(...future.oldEnvVars)
[16:59:36.644]                 envs <- base::Sys.getenv()
[16:59:36.644]                 names <- names(envs)
[16:59:36.644]                 common <- intersect(names, old_names)
[16:59:36.644]                 added <- setdiff(names, old_names)
[16:59:36.644]                 removed <- setdiff(old_names, names)
[16:59:36.644]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:36.644]                   envs[common]]
[16:59:36.644]                 NAMES <- toupper(changed)
[16:59:36.644]                 args <- list()
[16:59:36.644]                 for (kk in seq_along(NAMES)) {
[16:59:36.644]                   name <- changed[[kk]]
[16:59:36.644]                   NAME <- NAMES[[kk]]
[16:59:36.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.644]                     next
[16:59:36.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.644]                 }
[16:59:36.644]                 NAMES <- toupper(added)
[16:59:36.644]                 for (kk in seq_along(NAMES)) {
[16:59:36.644]                   name <- added[[kk]]
[16:59:36.644]                   NAME <- NAMES[[kk]]
[16:59:36.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.644]                     next
[16:59:36.644]                   args[[name]] <- ""
[16:59:36.644]                 }
[16:59:36.644]                 NAMES <- toupper(removed)
[16:59:36.644]                 for (kk in seq_along(NAMES)) {
[16:59:36.644]                   name <- removed[[kk]]
[16:59:36.644]                   NAME <- NAMES[[kk]]
[16:59:36.644]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.644]                     next
[16:59:36.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.644]                 }
[16:59:36.644]                 if (length(args) > 0) 
[16:59:36.644]                   base::do.call(base::Sys.setenv, args = args)
[16:59:36.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:36.644]             }
[16:59:36.644]             else {
[16:59:36.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:36.644]             }
[16:59:36.644]             {
[16:59:36.644]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:36.644]                   0L) {
[16:59:36.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:36.644]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:36.644]                   base::options(opts)
[16:59:36.644]                 }
[16:59:36.644]                 {
[16:59:36.644]                   {
[16:59:36.644]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:36.644]                     NULL
[16:59:36.644]                   }
[16:59:36.644]                   options(future.plan = NULL)
[16:59:36.644]                   if (is.na(NA_character_)) 
[16:59:36.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:36.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:36.644]                     .init = FALSE)
[16:59:36.644]                 }
[16:59:36.644]             }
[16:59:36.644]         }
[16:59:36.644]     })
[16:59:36.644]     if (TRUE) {
[16:59:36.644]         base::sink(type = "output", split = FALSE)
[16:59:36.644]         if (TRUE) {
[16:59:36.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:36.644]         }
[16:59:36.644]         else {
[16:59:36.644]             ...future.result["stdout"] <- base::list(NULL)
[16:59:36.644]         }
[16:59:36.644]         base::close(...future.stdout)
[16:59:36.644]         ...future.stdout <- NULL
[16:59:36.644]     }
[16:59:36.644]     ...future.result$conditions <- ...future.conditions
[16:59:36.644]     ...future.result$finished <- base::Sys.time()
[16:59:36.644]     ...future.result
[16:59:36.644] }
[16:59:36.696] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:59:36.696] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:59:36.696] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:59:36.697] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:36.697] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:36.697] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ...
[16:59:36.698] Exporting ‘...future.elements_ii’ (1.72 KiB) to cluster node #2 ... DONE
[16:59:36.698] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:36.698] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:36.698] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:36.699] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:36.699] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:59:36.700] MultisessionFuture started
[16:59:36.700] - Launch lazy future ... done
[16:59:36.700] run() for ‘MultisessionFuture’ ... done
[16:59:36.700] Created future:
[16:59:36.700] MultisessionFuture:
[16:59:36.700] Label: ‘future_by-2’
[16:59:36.700] Expression:
[16:59:36.700] {
[16:59:36.700]     do.call(function(...) {
[16:59:36.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.700]             on.exit(options(oopts), add = TRUE)
[16:59:36.700]         }
[16:59:36.700]         {
[16:59:36.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.700]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.700]             })
[16:59:36.700]         }
[16:59:36.700]     }, args = future.call.arguments)
[16:59:36.700] }
[16:59:36.700] Lazy evaluation: FALSE
[16:59:36.700] Asynchronous evaluation: TRUE
[16:59:36.700] Local evaluation: TRUE
[16:59:36.700] Environment: R_GlobalEnv
[16:59:36.700] Capture standard output: TRUE
[16:59:36.700] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:36.700] Globals: 5 objects totaling 2.93 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.72 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:36.700] Packages: <none>
[16:59:36.700] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:36.700] Resolved: FALSE
[16:59:36.700] Value: <not collected>
[16:59:36.700] Conditions captured: <none>
[16:59:36.700] Early signaling: FALSE
[16:59:36.700] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:36.700] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.712] Chunk #2 of 2 ... DONE
[16:59:36.712] Launching 2 futures (chunks) ... DONE
[16:59:36.712] Resolving 2 futures (chunks) ...
[16:59:36.712] resolve() on list ...
[16:59:36.713]  recursive: 0
[16:59:36.713]  length: 2
[16:59:36.713] 
[16:59:36.713] receiveMessageFromWorker() for ClusterFuture ...
[16:59:36.713] - Validating connection of MultisessionFuture
[16:59:36.714] - received message: FutureResult
[16:59:36.714] - Received FutureResult
[16:59:36.714] - Erased future from FutureRegistry
[16:59:36.714] result() for ClusterFuture ...
[16:59:36.714] - result already collected: FutureResult
[16:59:36.714] result() for ClusterFuture ... done
[16:59:36.714] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:36.715] Future #1
[16:59:36.715] result() for ClusterFuture ...
[16:59:36.715] - result already collected: FutureResult
[16:59:36.715] result() for ClusterFuture ... done
[16:59:36.715] result() for ClusterFuture ...
[16:59:36.715] - result already collected: FutureResult
[16:59:36.715] result() for ClusterFuture ... done
[16:59:36.715] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:36.715] - nx: 2
[16:59:36.716] - relay: TRUE
[16:59:36.716] - stdout: TRUE
[16:59:36.716] - signal: TRUE
[16:59:36.716] - resignal: FALSE
[16:59:36.716] - force: TRUE
[16:59:36.716] - relayed: [n=2] FALSE, FALSE
[16:59:36.716] - queued futures: [n=2] FALSE, FALSE
[16:59:36.716]  - until=1
[16:59:36.716]  - relaying element #1
[16:59:36.717] result() for ClusterFuture ...
[16:59:36.717] - result already collected: FutureResult
[16:59:36.717] result() for ClusterFuture ... done
[16:59:36.717] result() for ClusterFuture ...
[16:59:36.717] - result already collected: FutureResult
[16:59:36.717] result() for ClusterFuture ... done
[16:59:36.717] result() for ClusterFuture ...
[16:59:36.717] - result already collected: FutureResult
[16:59:36.717] result() for ClusterFuture ... done
[16:59:36.718] result() for ClusterFuture ...
[16:59:36.718] - result already collected: FutureResult
[16:59:36.718] result() for ClusterFuture ... done
[16:59:36.718] - relayed: [n=2] TRUE, FALSE
[16:59:36.718] - queued futures: [n=2] TRUE, FALSE
[16:59:36.718] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:36.718]  length: 1 (resolved future 1)
[16:59:36.784] receiveMessageFromWorker() for ClusterFuture ...
[16:59:36.784] - Validating connection of MultisessionFuture
[16:59:36.784] - received message: FutureResult
[16:59:36.784] - Received FutureResult
[16:59:36.785] - Erased future from FutureRegistry
[16:59:36.785] result() for ClusterFuture ...
[16:59:36.785] - result already collected: FutureResult
[16:59:36.785] result() for ClusterFuture ... done
[16:59:36.785] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:36.785] Future #2
[16:59:36.785] result() for ClusterFuture ...
[16:59:36.785] - result already collected: FutureResult
[16:59:36.785] result() for ClusterFuture ... done
[16:59:36.786] result() for ClusterFuture ...
[16:59:36.786] - result already collected: FutureResult
[16:59:36.786] result() for ClusterFuture ... done
[16:59:36.786] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:36.786] - nx: 2
[16:59:36.788] - relay: TRUE
[16:59:36.789] - stdout: TRUE
[16:59:36.789] - signal: TRUE
[16:59:36.789] - resignal: FALSE
[16:59:36.789] - force: TRUE
[16:59:36.789] - relayed: [n=2] TRUE, FALSE
[16:59:36.789] - queued futures: [n=2] TRUE, FALSE
[16:59:36.789]  - until=2
[16:59:36.789]  - relaying element #2
[16:59:36.789] result() for ClusterFuture ...
[16:59:36.789] - result already collected: FutureResult
[16:59:36.789] result() for ClusterFuture ... done
[16:59:36.789] result() for ClusterFuture ...
[16:59:36.790] - result already collected: FutureResult
[16:59:36.790] result() for ClusterFuture ... done
[16:59:36.790] result() for ClusterFuture ...
[16:59:36.790] - result already collected: FutureResult
[16:59:36.790] result() for ClusterFuture ... done
[16:59:36.790] result() for ClusterFuture ...
[16:59:36.790] - result already collected: FutureResult
[16:59:36.790] result() for ClusterFuture ... done
[16:59:36.790] - relayed: [n=2] TRUE, TRUE
[16:59:36.790] - queued futures: [n=2] TRUE, TRUE
[16:59:36.790] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:36.791]  length: 0 (resolved future 2)
[16:59:36.791] Relaying remaining futures
[16:59:36.791] signalConditionsASAP(NULL, pos=0) ...
[16:59:36.791] - nx: 2
[16:59:36.791] - relay: TRUE
[16:59:36.791] - stdout: TRUE
[16:59:36.791] - signal: TRUE
[16:59:36.791] - resignal: FALSE
[16:59:36.791] - force: TRUE
[16:59:36.791] - relayed: [n=2] TRUE, TRUE
[16:59:36.791] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:36.791] - relayed: [n=2] TRUE, TRUE
[16:59:36.792] - queued futures: [n=2] TRUE, TRUE
[16:59:36.792] signalConditionsASAP(NULL, pos=0) ... done
[16:59:36.792] resolve() on list ... DONE
[16:59:36.792] result() for ClusterFuture ...
[16:59:36.792] - result already collected: FutureResult
[16:59:36.792] result() for ClusterFuture ... done
[16:59:36.792] result() for ClusterFuture ...
[16:59:36.792] - result already collected: FutureResult
[16:59:36.792] result() for ClusterFuture ... done
[16:59:36.792] result() for ClusterFuture ...
[16:59:36.792] - result already collected: FutureResult
[16:59:36.792] result() for ClusterFuture ... done
[16:59:36.793] result() for ClusterFuture ...
[16:59:36.793] - result already collected: FutureResult
[16:59:36.793] result() for ClusterFuture ... done
[16:59:36.793]  - Number of value chunks collected: 2
[16:59:36.793] Resolving 2 futures (chunks) ... DONE
[16:59:36.793] Reducing values from 2 chunks ...
[16:59:36.793]  - Number of values collected after concatenation: 3
[16:59:36.793]  - Number of values expected: 3
[16:59:36.793] Reducing values from 2 chunks ... DONE
[16:59:36.793] future_lapply() ... DONE
[16:59:36.793] future_by_internal() ... DONE
[16:59:36.794] future_by_internal() ...
[16:59:36.794] future_lapply() ...
[16:59:36.798] Number of chunks: 2
[16:59:36.798] getGlobalsAndPackagesXApply() ...
[16:59:36.798]  - future.globals: TRUE
[16:59:36.798] getGlobalsAndPackages() ...
[16:59:36.799] Searching for globals...
[16:59:36.800] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:36.800] Searching for globals ... DONE
[16:59:36.800] Resolving globals: FALSE
[16:59:36.800] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:36.801] The total size of the 1 globals exported for future expression (‘FUN(digits = 2L)’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:36.801] - globals: [1] ‘FUN’
[16:59:36.801] 
[16:59:36.801] getGlobalsAndPackages() ... DONE
[16:59:36.801]  - globals found/used: [n=1] ‘FUN’
[16:59:36.801]  - needed namespaces: [n=0] 
[16:59:36.801] Finding globals ... DONE
[16:59:36.801]  - use_args: TRUE
[16:59:36.801]  - Getting '...' globals ...
[16:59:36.802] resolve() on list ...
[16:59:36.802]  recursive: 0
[16:59:36.802]  length: 1
[16:59:36.802]  elements: ‘...’
[16:59:36.802]  length: 0 (resolved future 1)
[16:59:36.802] resolve() on list ... DONE
[16:59:36.802]    - '...' content: [n=1] ‘digits’
[16:59:36.802] List of 1
[16:59:36.802]  $ ...:List of 1
[16:59:36.802]   ..$ digits: int 2
[16:59:36.802]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:36.802]  - attr(*, "where")=List of 1
[16:59:36.802]   ..$ ...:<environment: 0x562052d509d8> 
[16:59:36.802]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:36.802]  - attr(*, "resolved")= logi TRUE
[16:59:36.802]  - attr(*, "total_size")= num NA
[16:59:36.805]  - Getting '...' globals ... DONE
[16:59:36.806] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:36.806] List of 2
[16:59:36.806]  $ ...future.FUN:function (object, ...)  
[16:59:36.806]  $ ...          :List of 1
[16:59:36.806]   ..$ digits: int 2
[16:59:36.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:36.806]  - attr(*, "where")=List of 2
[16:59:36.806]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:36.806]   ..$ ...          :<environment: 0x562052d509d8> 
[16:59:36.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:36.806]  - attr(*, "resolved")= logi FALSE
[16:59:36.806]  - attr(*, "total_size")= num 1296
[16:59:36.809] Packages to be attached in all futures: [n=0] 
[16:59:36.809] getGlobalsAndPackagesXApply() ... DONE
[16:59:36.809] Number of futures (= number of chunks): 2
[16:59:36.809] Launching 2 futures (chunks) ...
[16:59:36.809] Chunk #1 of 2 ...
[16:59:36.809]  - Finding globals in 'X' for chunk #1 ...
[16:59:36.809] getGlobalsAndPackages() ...
[16:59:36.810] Searching for globals...
[16:59:36.810] 
[16:59:36.810] Searching for globals ... DONE
[16:59:36.810] - globals: [0] <none>
[16:59:36.810] getGlobalsAndPackages() ... DONE
[16:59:36.810]    + additional globals found: [n=0] 
[16:59:36.810]    + additional namespaces needed: [n=0] 
[16:59:36.810]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:36.810]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:36.811]  - seeds: <none>
[16:59:36.811]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.811] getGlobalsAndPackages() ...
[16:59:36.811] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.811] Resolving globals: FALSE
[16:59:36.811] Tweak future expression to call with '...' arguments ...
[16:59:36.811] {
[16:59:36.811]     do.call(function(...) {
[16:59:36.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.811]             on.exit(options(oopts), add = TRUE)
[16:59:36.811]         }
[16:59:36.811]         {
[16:59:36.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.811]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.811]             })
[16:59:36.811]         }
[16:59:36.811]     }, args = future.call.arguments)
[16:59:36.811] }
[16:59:36.811] Tweak future expression to call with '...' arguments ... DONE
[16:59:36.812] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.812] 
[16:59:36.812] getGlobalsAndPackages() ... DONE
[16:59:36.812] run() for ‘Future’ ...
[16:59:36.812] - state: ‘created’
[16:59:36.813] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:36.826] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:36.827]   - Field: ‘node’
[16:59:36.827]   - Field: ‘label’
[16:59:36.827]   - Field: ‘local’
[16:59:36.827]   - Field: ‘owner’
[16:59:36.827]   - Field: ‘envir’
[16:59:36.827]   - Field: ‘workers’
[16:59:36.827]   - Field: ‘packages’
[16:59:36.827]   - Field: ‘gc’
[16:59:36.828]   - Field: ‘conditions’
[16:59:36.828]   - Field: ‘persistent’
[16:59:36.828]   - Field: ‘expr’
[16:59:36.828]   - Field: ‘uuid’
[16:59:36.828]   - Field: ‘seed’
[16:59:36.828]   - Field: ‘version’
[16:59:36.828]   - Field: ‘result’
[16:59:36.828]   - Field: ‘asynchronous’
[16:59:36.828]   - Field: ‘calls’
[16:59:36.828]   - Field: ‘globals’
[16:59:36.828]   - Field: ‘stdout’
[16:59:36.829]   - Field: ‘earlySignal’
[16:59:36.829]   - Field: ‘lazy’
[16:59:36.829]   - Field: ‘state’
[16:59:36.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:36.829] - Launch lazy future ...
[16:59:36.829] Packages needed by the future expression (n = 0): <none>
[16:59:36.829] Packages needed by future strategies (n = 0): <none>
[16:59:36.830] {
[16:59:36.830]     {
[16:59:36.830]         {
[16:59:36.830]             ...future.startTime <- base::Sys.time()
[16:59:36.830]             {
[16:59:36.830]                 {
[16:59:36.830]                   {
[16:59:36.830]                     {
[16:59:36.830]                       base::local({
[16:59:36.830]                         has_future <- base::requireNamespace("future", 
[16:59:36.830]                           quietly = TRUE)
[16:59:36.830]                         if (has_future) {
[16:59:36.830]                           ns <- base::getNamespace("future")
[16:59:36.830]                           version <- ns[[".package"]][["version"]]
[16:59:36.830]                           if (is.null(version)) 
[16:59:36.830]                             version <- utils::packageVersion("future")
[16:59:36.830]                         }
[16:59:36.830]                         else {
[16:59:36.830]                           version <- NULL
[16:59:36.830]                         }
[16:59:36.830]                         if (!has_future || version < "1.8.0") {
[16:59:36.830]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:36.830]                             "", base::R.version$version.string), 
[16:59:36.830]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:36.830]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:36.830]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:36.830]                               "release", "version")], collapse = " "), 
[16:59:36.830]                             hostname = base::Sys.info()[["nodename"]])
[16:59:36.830]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:36.830]                             info)
[16:59:36.830]                           info <- base::paste(info, collapse = "; ")
[16:59:36.830]                           if (!has_future) {
[16:59:36.830]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:36.830]                               info)
[16:59:36.830]                           }
[16:59:36.830]                           else {
[16:59:36.830]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:36.830]                               info, version)
[16:59:36.830]                           }
[16:59:36.830]                           base::stop(msg)
[16:59:36.830]                         }
[16:59:36.830]                       })
[16:59:36.830]                     }
[16:59:36.830]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:36.830]                     base::options(mc.cores = 1L)
[16:59:36.830]                   }
[16:59:36.830]                   ...future.strategy.old <- future::plan("list")
[16:59:36.830]                   options(future.plan = NULL)
[16:59:36.830]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.830]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:36.830]                 }
[16:59:36.830]                 ...future.workdir <- getwd()
[16:59:36.830]             }
[16:59:36.830]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:36.830]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:36.830]         }
[16:59:36.830]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:36.830]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:36.830]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:36.830]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:36.830]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:36.830]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:36.830]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:36.830]             base::names(...future.oldOptions))
[16:59:36.830]     }
[16:59:36.830]     if (FALSE) {
[16:59:36.830]     }
[16:59:36.830]     else {
[16:59:36.830]         if (TRUE) {
[16:59:36.830]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:36.830]                 open = "w")
[16:59:36.830]         }
[16:59:36.830]         else {
[16:59:36.830]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:36.830]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:36.830]         }
[16:59:36.830]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:36.830]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:36.830]             base::sink(type = "output", split = FALSE)
[16:59:36.830]             base::close(...future.stdout)
[16:59:36.830]         }, add = TRUE)
[16:59:36.830]     }
[16:59:36.830]     ...future.frame <- base::sys.nframe()
[16:59:36.830]     ...future.conditions <- base::list()
[16:59:36.830]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:36.830]     if (FALSE) {
[16:59:36.830]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:36.830]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:36.830]     }
[16:59:36.830]     ...future.result <- base::tryCatch({
[16:59:36.830]         base::withCallingHandlers({
[16:59:36.830]             ...future.value <- base::withVisible(base::local({
[16:59:36.830]                 ...future.makeSendCondition <- base::local({
[16:59:36.830]                   sendCondition <- NULL
[16:59:36.830]                   function(frame = 1L) {
[16:59:36.830]                     if (is.function(sendCondition)) 
[16:59:36.830]                       return(sendCondition)
[16:59:36.830]                     ns <- getNamespace("parallel")
[16:59:36.830]                     if (exists("sendData", mode = "function", 
[16:59:36.830]                       envir = ns)) {
[16:59:36.830]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:36.830]                         envir = ns)
[16:59:36.830]                       envir <- sys.frame(frame)
[16:59:36.830]                       master <- NULL
[16:59:36.830]                       while (!identical(envir, .GlobalEnv) && 
[16:59:36.830]                         !identical(envir, emptyenv())) {
[16:59:36.830]                         if (exists("master", mode = "list", envir = envir, 
[16:59:36.830]                           inherits = FALSE)) {
[16:59:36.830]                           master <- get("master", mode = "list", 
[16:59:36.830]                             envir = envir, inherits = FALSE)
[16:59:36.830]                           if (inherits(master, c("SOCKnode", 
[16:59:36.830]                             "SOCK0node"))) {
[16:59:36.830]                             sendCondition <<- function(cond) {
[16:59:36.830]                               data <- list(type = "VALUE", value = cond, 
[16:59:36.830]                                 success = TRUE)
[16:59:36.830]                               parallel_sendData(master, data)
[16:59:36.830]                             }
[16:59:36.830]                             return(sendCondition)
[16:59:36.830]                           }
[16:59:36.830]                         }
[16:59:36.830]                         frame <- frame + 1L
[16:59:36.830]                         envir <- sys.frame(frame)
[16:59:36.830]                       }
[16:59:36.830]                     }
[16:59:36.830]                     sendCondition <<- function(cond) NULL
[16:59:36.830]                   }
[16:59:36.830]                 })
[16:59:36.830]                 withCallingHandlers({
[16:59:36.830]                   {
[16:59:36.830]                     do.call(function(...) {
[16:59:36.830]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.830]                       if (!identical(...future.globals.maxSize.org, 
[16:59:36.830]                         ...future.globals.maxSize)) {
[16:59:36.830]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.830]                         on.exit(options(oopts), add = TRUE)
[16:59:36.830]                       }
[16:59:36.830]                       {
[16:59:36.830]                         lapply(seq_along(...future.elements_ii), 
[16:59:36.830]                           FUN = function(jj) {
[16:59:36.830]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.830]                             ...future.FUN(...future.X_jj, ...)
[16:59:36.830]                           })
[16:59:36.830]                       }
[16:59:36.830]                     }, args = future.call.arguments)
[16:59:36.830]                   }
[16:59:36.830]                 }, immediateCondition = function(cond) {
[16:59:36.830]                   sendCondition <- ...future.makeSendCondition()
[16:59:36.830]                   sendCondition(cond)
[16:59:36.830]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.830]                   {
[16:59:36.830]                     inherits <- base::inherits
[16:59:36.830]                     invokeRestart <- base::invokeRestart
[16:59:36.830]                     is.null <- base::is.null
[16:59:36.830]                     muffled <- FALSE
[16:59:36.830]                     if (inherits(cond, "message")) {
[16:59:36.830]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:36.830]                       if (muffled) 
[16:59:36.830]                         invokeRestart("muffleMessage")
[16:59:36.830]                     }
[16:59:36.830]                     else if (inherits(cond, "warning")) {
[16:59:36.830]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:36.830]                       if (muffled) 
[16:59:36.830]                         invokeRestart("muffleWarning")
[16:59:36.830]                     }
[16:59:36.830]                     else if (inherits(cond, "condition")) {
[16:59:36.830]                       if (!is.null(pattern)) {
[16:59:36.830]                         computeRestarts <- base::computeRestarts
[16:59:36.830]                         grepl <- base::grepl
[16:59:36.830]                         restarts <- computeRestarts(cond)
[16:59:36.830]                         for (restart in restarts) {
[16:59:36.830]                           name <- restart$name
[16:59:36.830]                           if (is.null(name)) 
[16:59:36.830]                             next
[16:59:36.830]                           if (!grepl(pattern, name)) 
[16:59:36.830]                             next
[16:59:36.830]                           invokeRestart(restart)
[16:59:36.830]                           muffled <- TRUE
[16:59:36.830]                           break
[16:59:36.830]                         }
[16:59:36.830]                       }
[16:59:36.830]                     }
[16:59:36.830]                     invisible(muffled)
[16:59:36.830]                   }
[16:59:36.830]                   muffleCondition(cond)
[16:59:36.830]                 })
[16:59:36.830]             }))
[16:59:36.830]             future::FutureResult(value = ...future.value$value, 
[16:59:36.830]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.830]                   ...future.rng), globalenv = if (FALSE) 
[16:59:36.830]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:36.830]                     ...future.globalenv.names))
[16:59:36.830]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:36.830]         }, condition = base::local({
[16:59:36.830]             c <- base::c
[16:59:36.830]             inherits <- base::inherits
[16:59:36.830]             invokeRestart <- base::invokeRestart
[16:59:36.830]             length <- base::length
[16:59:36.830]             list <- base::list
[16:59:36.830]             seq.int <- base::seq.int
[16:59:36.830]             signalCondition <- base::signalCondition
[16:59:36.830]             sys.calls <- base::sys.calls
[16:59:36.830]             `[[` <- base::`[[`
[16:59:36.830]             `+` <- base::`+`
[16:59:36.830]             `<<-` <- base::`<<-`
[16:59:36.830]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:36.830]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:36.830]                   3L)]
[16:59:36.830]             }
[16:59:36.830]             function(cond) {
[16:59:36.830]                 is_error <- inherits(cond, "error")
[16:59:36.830]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:36.830]                   NULL)
[16:59:36.830]                 if (is_error) {
[16:59:36.830]                   sessionInformation <- function() {
[16:59:36.830]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:36.830]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:36.830]                       search = base::search(), system = base::Sys.info())
[16:59:36.830]                   }
[16:59:36.830]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.830]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:36.830]                     cond$call), session = sessionInformation(), 
[16:59:36.830]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:36.830]                   signalCondition(cond)
[16:59:36.830]                 }
[16:59:36.830]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:36.830]                 "immediateCondition"))) {
[16:59:36.830]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:36.830]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.830]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:36.830]                   if (TRUE && !signal) {
[16:59:36.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.830]                     {
[16:59:36.830]                       inherits <- base::inherits
[16:59:36.830]                       invokeRestart <- base::invokeRestart
[16:59:36.830]                       is.null <- base::is.null
[16:59:36.830]                       muffled <- FALSE
[16:59:36.830]                       if (inherits(cond, "message")) {
[16:59:36.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.830]                         if (muffled) 
[16:59:36.830]                           invokeRestart("muffleMessage")
[16:59:36.830]                       }
[16:59:36.830]                       else if (inherits(cond, "warning")) {
[16:59:36.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.830]                         if (muffled) 
[16:59:36.830]                           invokeRestart("muffleWarning")
[16:59:36.830]                       }
[16:59:36.830]                       else if (inherits(cond, "condition")) {
[16:59:36.830]                         if (!is.null(pattern)) {
[16:59:36.830]                           computeRestarts <- base::computeRestarts
[16:59:36.830]                           grepl <- base::grepl
[16:59:36.830]                           restarts <- computeRestarts(cond)
[16:59:36.830]                           for (restart in restarts) {
[16:59:36.830]                             name <- restart$name
[16:59:36.830]                             if (is.null(name)) 
[16:59:36.830]                               next
[16:59:36.830]                             if (!grepl(pattern, name)) 
[16:59:36.830]                               next
[16:59:36.830]                             invokeRestart(restart)
[16:59:36.830]                             muffled <- TRUE
[16:59:36.830]                             break
[16:59:36.830]                           }
[16:59:36.830]                         }
[16:59:36.830]                       }
[16:59:36.830]                       invisible(muffled)
[16:59:36.830]                     }
[16:59:36.830]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.830]                   }
[16:59:36.830]                 }
[16:59:36.830]                 else {
[16:59:36.830]                   if (TRUE) {
[16:59:36.830]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.830]                     {
[16:59:36.830]                       inherits <- base::inherits
[16:59:36.830]                       invokeRestart <- base::invokeRestart
[16:59:36.830]                       is.null <- base::is.null
[16:59:36.830]                       muffled <- FALSE
[16:59:36.830]                       if (inherits(cond, "message")) {
[16:59:36.830]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.830]                         if (muffled) 
[16:59:36.830]                           invokeRestart("muffleMessage")
[16:59:36.830]                       }
[16:59:36.830]                       else if (inherits(cond, "warning")) {
[16:59:36.830]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.830]                         if (muffled) 
[16:59:36.830]                           invokeRestart("muffleWarning")
[16:59:36.830]                       }
[16:59:36.830]                       else if (inherits(cond, "condition")) {
[16:59:36.830]                         if (!is.null(pattern)) {
[16:59:36.830]                           computeRestarts <- base::computeRestarts
[16:59:36.830]                           grepl <- base::grepl
[16:59:36.830]                           restarts <- computeRestarts(cond)
[16:59:36.830]                           for (restart in restarts) {
[16:59:36.830]                             name <- restart$name
[16:59:36.830]                             if (is.null(name)) 
[16:59:36.830]                               next
[16:59:36.830]                             if (!grepl(pattern, name)) 
[16:59:36.830]                               next
[16:59:36.830]                             invokeRestart(restart)
[16:59:36.830]                             muffled <- TRUE
[16:59:36.830]                             break
[16:59:36.830]                           }
[16:59:36.830]                         }
[16:59:36.830]                       }
[16:59:36.830]                       invisible(muffled)
[16:59:36.830]                     }
[16:59:36.830]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.830]                   }
[16:59:36.830]                 }
[16:59:36.830]             }
[16:59:36.830]         }))
[16:59:36.830]     }, error = function(ex) {
[16:59:36.830]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:36.830]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.830]                 ...future.rng), started = ...future.startTime, 
[16:59:36.830]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:36.830]             version = "1.8"), class = "FutureResult")
[16:59:36.830]     }, finally = {
[16:59:36.830]         if (!identical(...future.workdir, getwd())) 
[16:59:36.830]             setwd(...future.workdir)
[16:59:36.830]         {
[16:59:36.830]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:36.830]                 ...future.oldOptions$nwarnings <- NULL
[16:59:36.830]             }
[16:59:36.830]             base::options(...future.oldOptions)
[16:59:36.830]             if (.Platform$OS.type == "windows") {
[16:59:36.830]                 old_names <- names(...future.oldEnvVars)
[16:59:36.830]                 envs <- base::Sys.getenv()
[16:59:36.830]                 names <- names(envs)
[16:59:36.830]                 common <- intersect(names, old_names)
[16:59:36.830]                 added <- setdiff(names, old_names)
[16:59:36.830]                 removed <- setdiff(old_names, names)
[16:59:36.830]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:36.830]                   envs[common]]
[16:59:36.830]                 NAMES <- toupper(changed)
[16:59:36.830]                 args <- list()
[16:59:36.830]                 for (kk in seq_along(NAMES)) {
[16:59:36.830]                   name <- changed[[kk]]
[16:59:36.830]                   NAME <- NAMES[[kk]]
[16:59:36.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.830]                     next
[16:59:36.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.830]                 }
[16:59:36.830]                 NAMES <- toupper(added)
[16:59:36.830]                 for (kk in seq_along(NAMES)) {
[16:59:36.830]                   name <- added[[kk]]
[16:59:36.830]                   NAME <- NAMES[[kk]]
[16:59:36.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.830]                     next
[16:59:36.830]                   args[[name]] <- ""
[16:59:36.830]                 }
[16:59:36.830]                 NAMES <- toupper(removed)
[16:59:36.830]                 for (kk in seq_along(NAMES)) {
[16:59:36.830]                   name <- removed[[kk]]
[16:59:36.830]                   NAME <- NAMES[[kk]]
[16:59:36.830]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.830]                     next
[16:59:36.830]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.830]                 }
[16:59:36.830]                 if (length(args) > 0) 
[16:59:36.830]                   base::do.call(base::Sys.setenv, args = args)
[16:59:36.830]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:36.830]             }
[16:59:36.830]             else {
[16:59:36.830]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:36.830]             }
[16:59:36.830]             {
[16:59:36.830]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:36.830]                   0L) {
[16:59:36.830]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:36.830]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:36.830]                   base::options(opts)
[16:59:36.830]                 }
[16:59:36.830]                 {
[16:59:36.830]                   {
[16:59:36.830]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:36.830]                     NULL
[16:59:36.830]                   }
[16:59:36.830]                   options(future.plan = NULL)
[16:59:36.830]                   if (is.na(NA_character_)) 
[16:59:36.830]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.830]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:36.830]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:36.830]                     .init = FALSE)
[16:59:36.830]                 }
[16:59:36.830]             }
[16:59:36.830]         }
[16:59:36.830]     })
[16:59:36.830]     if (TRUE) {
[16:59:36.830]         base::sink(type = "output", split = FALSE)
[16:59:36.830]         if (TRUE) {
[16:59:36.830]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:36.830]         }
[16:59:36.830]         else {
[16:59:36.830]             ...future.result["stdout"] <- base::list(NULL)
[16:59:36.830]         }
[16:59:36.830]         base::close(...future.stdout)
[16:59:36.830]         ...future.stdout <- NULL
[16:59:36.830]     }
[16:59:36.830]     ...future.result$conditions <- ...future.conditions
[16:59:36.830]     ...future.result$finished <- base::Sys.time()
[16:59:36.830]     ...future.result
[16:59:36.830] }
[16:59:36.833] Exporting 5 global objects (1.27 KiB) to cluster node #1 ...
[16:59:36.833] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:59:36.833] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:59:36.833] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:59:36.834] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:59:36.834] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ...
[16:59:36.834] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #1 ... DONE
[16:59:36.834] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:36.835] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:36.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.835] Exporting 5 global objects (1.27 KiB) to cluster node #1 ... DONE
[16:59:36.836] MultisessionFuture started
[16:59:36.836] - Launch lazy future ... done
[16:59:36.836] run() for ‘MultisessionFuture’ ... done
[16:59:36.836] Created future:
[16:59:36.837] MultisessionFuture:
[16:59:36.837] Label: ‘future_by-1’
[16:59:36.837] Expression:
[16:59:36.837] {
[16:59:36.837]     do.call(function(...) {
[16:59:36.837]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.837]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.837]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.837]             on.exit(options(oopts), add = TRUE)
[16:59:36.837]         }
[16:59:36.837]         {
[16:59:36.837]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.837]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.837]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.837]             })
[16:59:36.837]         }
[16:59:36.837]     }, args = future.call.arguments)
[16:59:36.837] }
[16:59:36.837] Lazy evaluation: FALSE
[16:59:36.837] Asynchronous evaluation: TRUE
[16:59:36.837] Local evaluation: TRUE
[16:59:36.837] Environment: R_GlobalEnv
[16:59:36.837] Capture standard output: TRUE
[16:59:36.837] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:36.837] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:36.837] Packages: <none>
[16:59:36.837] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:36.837] Resolved: FALSE
[16:59:36.837] Value: <not collected>
[16:59:36.837] Conditions captured: <none>
[16:59:36.837] Early signaling: FALSE
[16:59:36.837] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:36.837] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.848] Chunk #1 of 2 ... DONE
[16:59:36.848] Chunk #2 of 2 ...
[16:59:36.848]  - Finding globals in 'X' for chunk #2 ...
[16:59:36.848] getGlobalsAndPackages() ...
[16:59:36.849] Searching for globals...
[16:59:36.849] 
[16:59:36.849] Searching for globals ... DONE
[16:59:36.849] - globals: [0] <none>
[16:59:36.849] getGlobalsAndPackages() ... DONE
[16:59:36.849]    + additional globals found: [n=0] 
[16:59:36.849]    + additional namespaces needed: [n=0] 
[16:59:36.849]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:36.849]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:36.850]  - seeds: <none>
[16:59:36.850]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.850] getGlobalsAndPackages() ...
[16:59:36.850] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.850] Resolving globals: FALSE
[16:59:36.850] Tweak future expression to call with '...' arguments ...
[16:59:36.850] {
[16:59:36.850]     do.call(function(...) {
[16:59:36.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.850]             on.exit(options(oopts), add = TRUE)
[16:59:36.850]         }
[16:59:36.850]         {
[16:59:36.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.850]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.850]             })
[16:59:36.850]         }
[16:59:36.850]     }, args = future.call.arguments)
[16:59:36.850] }
[16:59:36.850] Tweak future expression to call with '...' arguments ... DONE
[16:59:36.851] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.851] 
[16:59:36.851] getGlobalsAndPackages() ... DONE
[16:59:36.851] run() for ‘Future’ ...
[16:59:36.851] - state: ‘created’
[16:59:36.852] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:36.866] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.866] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:36.866]   - Field: ‘node’
[16:59:36.866]   - Field: ‘label’
[16:59:36.866]   - Field: ‘local’
[16:59:36.866]   - Field: ‘owner’
[16:59:36.866]   - Field: ‘envir’
[16:59:36.866]   - Field: ‘workers’
[16:59:36.867]   - Field: ‘packages’
[16:59:36.867]   - Field: ‘gc’
[16:59:36.867]   - Field: ‘conditions’
[16:59:36.867]   - Field: ‘persistent’
[16:59:36.867]   - Field: ‘expr’
[16:59:36.867]   - Field: ‘uuid’
[16:59:36.867]   - Field: ‘seed’
[16:59:36.867]   - Field: ‘version’
[16:59:36.867]   - Field: ‘result’
[16:59:36.867]   - Field: ‘asynchronous’
[16:59:36.867]   - Field: ‘calls’
[16:59:36.868]   - Field: ‘globals’
[16:59:36.868]   - Field: ‘stdout’
[16:59:36.868]   - Field: ‘earlySignal’
[16:59:36.868]   - Field: ‘lazy’
[16:59:36.868]   - Field: ‘state’
[16:59:36.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:36.868] - Launch lazy future ...
[16:59:36.868] Packages needed by the future expression (n = 0): <none>
[16:59:36.869] Packages needed by future strategies (n = 0): <none>
[16:59:36.869] {
[16:59:36.869]     {
[16:59:36.869]         {
[16:59:36.869]             ...future.startTime <- base::Sys.time()
[16:59:36.869]             {
[16:59:36.869]                 {
[16:59:36.869]                   {
[16:59:36.869]                     {
[16:59:36.869]                       base::local({
[16:59:36.869]                         has_future <- base::requireNamespace("future", 
[16:59:36.869]                           quietly = TRUE)
[16:59:36.869]                         if (has_future) {
[16:59:36.869]                           ns <- base::getNamespace("future")
[16:59:36.869]                           version <- ns[[".package"]][["version"]]
[16:59:36.869]                           if (is.null(version)) 
[16:59:36.869]                             version <- utils::packageVersion("future")
[16:59:36.869]                         }
[16:59:36.869]                         else {
[16:59:36.869]                           version <- NULL
[16:59:36.869]                         }
[16:59:36.869]                         if (!has_future || version < "1.8.0") {
[16:59:36.869]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:36.869]                             "", base::R.version$version.string), 
[16:59:36.869]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:36.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:36.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:36.869]                               "release", "version")], collapse = " "), 
[16:59:36.869]                             hostname = base::Sys.info()[["nodename"]])
[16:59:36.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:36.869]                             info)
[16:59:36.869]                           info <- base::paste(info, collapse = "; ")
[16:59:36.869]                           if (!has_future) {
[16:59:36.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:36.869]                               info)
[16:59:36.869]                           }
[16:59:36.869]                           else {
[16:59:36.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:36.869]                               info, version)
[16:59:36.869]                           }
[16:59:36.869]                           base::stop(msg)
[16:59:36.869]                         }
[16:59:36.869]                       })
[16:59:36.869]                     }
[16:59:36.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:36.869]                     base::options(mc.cores = 1L)
[16:59:36.869]                   }
[16:59:36.869]                   ...future.strategy.old <- future::plan("list")
[16:59:36.869]                   options(future.plan = NULL)
[16:59:36.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:36.869]                 }
[16:59:36.869]                 ...future.workdir <- getwd()
[16:59:36.869]             }
[16:59:36.869]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:36.869]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:36.869]         }
[16:59:36.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:36.869]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:36.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:36.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:36.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:36.869]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:36.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:36.869]             base::names(...future.oldOptions))
[16:59:36.869]     }
[16:59:36.869]     if (FALSE) {
[16:59:36.869]     }
[16:59:36.869]     else {
[16:59:36.869]         if (TRUE) {
[16:59:36.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:36.869]                 open = "w")
[16:59:36.869]         }
[16:59:36.869]         else {
[16:59:36.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:36.869]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:36.869]         }
[16:59:36.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:36.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:36.869]             base::sink(type = "output", split = FALSE)
[16:59:36.869]             base::close(...future.stdout)
[16:59:36.869]         }, add = TRUE)
[16:59:36.869]     }
[16:59:36.869]     ...future.frame <- base::sys.nframe()
[16:59:36.869]     ...future.conditions <- base::list()
[16:59:36.869]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:36.869]     if (FALSE) {
[16:59:36.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:36.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:36.869]     }
[16:59:36.869]     ...future.result <- base::tryCatch({
[16:59:36.869]         base::withCallingHandlers({
[16:59:36.869]             ...future.value <- base::withVisible(base::local({
[16:59:36.869]                 ...future.makeSendCondition <- base::local({
[16:59:36.869]                   sendCondition <- NULL
[16:59:36.869]                   function(frame = 1L) {
[16:59:36.869]                     if (is.function(sendCondition)) 
[16:59:36.869]                       return(sendCondition)
[16:59:36.869]                     ns <- getNamespace("parallel")
[16:59:36.869]                     if (exists("sendData", mode = "function", 
[16:59:36.869]                       envir = ns)) {
[16:59:36.869]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:36.869]                         envir = ns)
[16:59:36.869]                       envir <- sys.frame(frame)
[16:59:36.869]                       master <- NULL
[16:59:36.869]                       while (!identical(envir, .GlobalEnv) && 
[16:59:36.869]                         !identical(envir, emptyenv())) {
[16:59:36.869]                         if (exists("master", mode = "list", envir = envir, 
[16:59:36.869]                           inherits = FALSE)) {
[16:59:36.869]                           master <- get("master", mode = "list", 
[16:59:36.869]                             envir = envir, inherits = FALSE)
[16:59:36.869]                           if (inherits(master, c("SOCKnode", 
[16:59:36.869]                             "SOCK0node"))) {
[16:59:36.869]                             sendCondition <<- function(cond) {
[16:59:36.869]                               data <- list(type = "VALUE", value = cond, 
[16:59:36.869]                                 success = TRUE)
[16:59:36.869]                               parallel_sendData(master, data)
[16:59:36.869]                             }
[16:59:36.869]                             return(sendCondition)
[16:59:36.869]                           }
[16:59:36.869]                         }
[16:59:36.869]                         frame <- frame + 1L
[16:59:36.869]                         envir <- sys.frame(frame)
[16:59:36.869]                       }
[16:59:36.869]                     }
[16:59:36.869]                     sendCondition <<- function(cond) NULL
[16:59:36.869]                   }
[16:59:36.869]                 })
[16:59:36.869]                 withCallingHandlers({
[16:59:36.869]                   {
[16:59:36.869]                     do.call(function(...) {
[16:59:36.869]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.869]                       if (!identical(...future.globals.maxSize.org, 
[16:59:36.869]                         ...future.globals.maxSize)) {
[16:59:36.869]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.869]                         on.exit(options(oopts), add = TRUE)
[16:59:36.869]                       }
[16:59:36.869]                       {
[16:59:36.869]                         lapply(seq_along(...future.elements_ii), 
[16:59:36.869]                           FUN = function(jj) {
[16:59:36.869]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.869]                             ...future.FUN(...future.X_jj, ...)
[16:59:36.869]                           })
[16:59:36.869]                       }
[16:59:36.869]                     }, args = future.call.arguments)
[16:59:36.869]                   }
[16:59:36.869]                 }, immediateCondition = function(cond) {
[16:59:36.869]                   sendCondition <- ...future.makeSendCondition()
[16:59:36.869]                   sendCondition(cond)
[16:59:36.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.869]                   {
[16:59:36.869]                     inherits <- base::inherits
[16:59:36.869]                     invokeRestart <- base::invokeRestart
[16:59:36.869]                     is.null <- base::is.null
[16:59:36.869]                     muffled <- FALSE
[16:59:36.869]                     if (inherits(cond, "message")) {
[16:59:36.869]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:36.869]                       if (muffled) 
[16:59:36.869]                         invokeRestart("muffleMessage")
[16:59:36.869]                     }
[16:59:36.869]                     else if (inherits(cond, "warning")) {
[16:59:36.869]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:36.869]                       if (muffled) 
[16:59:36.869]                         invokeRestart("muffleWarning")
[16:59:36.869]                     }
[16:59:36.869]                     else if (inherits(cond, "condition")) {
[16:59:36.869]                       if (!is.null(pattern)) {
[16:59:36.869]                         computeRestarts <- base::computeRestarts
[16:59:36.869]                         grepl <- base::grepl
[16:59:36.869]                         restarts <- computeRestarts(cond)
[16:59:36.869]                         for (restart in restarts) {
[16:59:36.869]                           name <- restart$name
[16:59:36.869]                           if (is.null(name)) 
[16:59:36.869]                             next
[16:59:36.869]                           if (!grepl(pattern, name)) 
[16:59:36.869]                             next
[16:59:36.869]                           invokeRestart(restart)
[16:59:36.869]                           muffled <- TRUE
[16:59:36.869]                           break
[16:59:36.869]                         }
[16:59:36.869]                       }
[16:59:36.869]                     }
[16:59:36.869]                     invisible(muffled)
[16:59:36.869]                   }
[16:59:36.869]                   muffleCondition(cond)
[16:59:36.869]                 })
[16:59:36.869]             }))
[16:59:36.869]             future::FutureResult(value = ...future.value$value, 
[16:59:36.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.869]                   ...future.rng), globalenv = if (FALSE) 
[16:59:36.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:36.869]                     ...future.globalenv.names))
[16:59:36.869]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:36.869]         }, condition = base::local({
[16:59:36.869]             c <- base::c
[16:59:36.869]             inherits <- base::inherits
[16:59:36.869]             invokeRestart <- base::invokeRestart
[16:59:36.869]             length <- base::length
[16:59:36.869]             list <- base::list
[16:59:36.869]             seq.int <- base::seq.int
[16:59:36.869]             signalCondition <- base::signalCondition
[16:59:36.869]             sys.calls <- base::sys.calls
[16:59:36.869]             `[[` <- base::`[[`
[16:59:36.869]             `+` <- base::`+`
[16:59:36.869]             `<<-` <- base::`<<-`
[16:59:36.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:36.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:36.869]                   3L)]
[16:59:36.869]             }
[16:59:36.869]             function(cond) {
[16:59:36.869]                 is_error <- inherits(cond, "error")
[16:59:36.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:36.869]                   NULL)
[16:59:36.869]                 if (is_error) {
[16:59:36.869]                   sessionInformation <- function() {
[16:59:36.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:36.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:36.869]                       search = base::search(), system = base::Sys.info())
[16:59:36.869]                   }
[16:59:36.869]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:36.869]                     cond$call), session = sessionInformation(), 
[16:59:36.869]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:36.869]                   signalCondition(cond)
[16:59:36.869]                 }
[16:59:36.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:36.869]                 "immediateCondition"))) {
[16:59:36.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:36.869]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:36.869]                   if (TRUE && !signal) {
[16:59:36.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.869]                     {
[16:59:36.869]                       inherits <- base::inherits
[16:59:36.869]                       invokeRestart <- base::invokeRestart
[16:59:36.869]                       is.null <- base::is.null
[16:59:36.869]                       muffled <- FALSE
[16:59:36.869]                       if (inherits(cond, "message")) {
[16:59:36.869]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.869]                         if (muffled) 
[16:59:36.869]                           invokeRestart("muffleMessage")
[16:59:36.869]                       }
[16:59:36.869]                       else if (inherits(cond, "warning")) {
[16:59:36.869]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.869]                         if (muffled) 
[16:59:36.869]                           invokeRestart("muffleWarning")
[16:59:36.869]                       }
[16:59:36.869]                       else if (inherits(cond, "condition")) {
[16:59:36.869]                         if (!is.null(pattern)) {
[16:59:36.869]                           computeRestarts <- base::computeRestarts
[16:59:36.869]                           grepl <- base::grepl
[16:59:36.869]                           restarts <- computeRestarts(cond)
[16:59:36.869]                           for (restart in restarts) {
[16:59:36.869]                             name <- restart$name
[16:59:36.869]                             if (is.null(name)) 
[16:59:36.869]                               next
[16:59:36.869]                             if (!grepl(pattern, name)) 
[16:59:36.869]                               next
[16:59:36.869]                             invokeRestart(restart)
[16:59:36.869]                             muffled <- TRUE
[16:59:36.869]                             break
[16:59:36.869]                           }
[16:59:36.869]                         }
[16:59:36.869]                       }
[16:59:36.869]                       invisible(muffled)
[16:59:36.869]                     }
[16:59:36.869]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.869]                   }
[16:59:36.869]                 }
[16:59:36.869]                 else {
[16:59:36.869]                   if (TRUE) {
[16:59:36.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.869]                     {
[16:59:36.869]                       inherits <- base::inherits
[16:59:36.869]                       invokeRestart <- base::invokeRestart
[16:59:36.869]                       is.null <- base::is.null
[16:59:36.869]                       muffled <- FALSE
[16:59:36.869]                       if (inherits(cond, "message")) {
[16:59:36.869]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.869]                         if (muffled) 
[16:59:36.869]                           invokeRestart("muffleMessage")
[16:59:36.869]                       }
[16:59:36.869]                       else if (inherits(cond, "warning")) {
[16:59:36.869]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.869]                         if (muffled) 
[16:59:36.869]                           invokeRestart("muffleWarning")
[16:59:36.869]                       }
[16:59:36.869]                       else if (inherits(cond, "condition")) {
[16:59:36.869]                         if (!is.null(pattern)) {
[16:59:36.869]                           computeRestarts <- base::computeRestarts
[16:59:36.869]                           grepl <- base::grepl
[16:59:36.869]                           restarts <- computeRestarts(cond)
[16:59:36.869]                           for (restart in restarts) {
[16:59:36.869]                             name <- restart$name
[16:59:36.869]                             if (is.null(name)) 
[16:59:36.869]                               next
[16:59:36.869]                             if (!grepl(pattern, name)) 
[16:59:36.869]                               next
[16:59:36.869]                             invokeRestart(restart)
[16:59:36.869]                             muffled <- TRUE
[16:59:36.869]                             break
[16:59:36.869]                           }
[16:59:36.869]                         }
[16:59:36.869]                       }
[16:59:36.869]                       invisible(muffled)
[16:59:36.869]                     }
[16:59:36.869]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.869]                   }
[16:59:36.869]                 }
[16:59:36.869]             }
[16:59:36.869]         }))
[16:59:36.869]     }, error = function(ex) {
[16:59:36.869]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:36.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.869]                 ...future.rng), started = ...future.startTime, 
[16:59:36.869]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:36.869]             version = "1.8"), class = "FutureResult")
[16:59:36.869]     }, finally = {
[16:59:36.869]         if (!identical(...future.workdir, getwd())) 
[16:59:36.869]             setwd(...future.workdir)
[16:59:36.869]         {
[16:59:36.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:36.869]                 ...future.oldOptions$nwarnings <- NULL
[16:59:36.869]             }
[16:59:36.869]             base::options(...future.oldOptions)
[16:59:36.869]             if (.Platform$OS.type == "windows") {
[16:59:36.869]                 old_names <- names(...future.oldEnvVars)
[16:59:36.869]                 envs <- base::Sys.getenv()
[16:59:36.869]                 names <- names(envs)
[16:59:36.869]                 common <- intersect(names, old_names)
[16:59:36.869]                 added <- setdiff(names, old_names)
[16:59:36.869]                 removed <- setdiff(old_names, names)
[16:59:36.869]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:36.869]                   envs[common]]
[16:59:36.869]                 NAMES <- toupper(changed)
[16:59:36.869]                 args <- list()
[16:59:36.869]                 for (kk in seq_along(NAMES)) {
[16:59:36.869]                   name <- changed[[kk]]
[16:59:36.869]                   NAME <- NAMES[[kk]]
[16:59:36.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.869]                     next
[16:59:36.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.869]                 }
[16:59:36.869]                 NAMES <- toupper(added)
[16:59:36.869]                 for (kk in seq_along(NAMES)) {
[16:59:36.869]                   name <- added[[kk]]
[16:59:36.869]                   NAME <- NAMES[[kk]]
[16:59:36.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.869]                     next
[16:59:36.869]                   args[[name]] <- ""
[16:59:36.869]                 }
[16:59:36.869]                 NAMES <- toupper(removed)
[16:59:36.869]                 for (kk in seq_along(NAMES)) {
[16:59:36.869]                   name <- removed[[kk]]
[16:59:36.869]                   NAME <- NAMES[[kk]]
[16:59:36.869]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.869]                     next
[16:59:36.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.869]                 }
[16:59:36.869]                 if (length(args) > 0) 
[16:59:36.869]                   base::do.call(base::Sys.setenv, args = args)
[16:59:36.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:36.869]             }
[16:59:36.869]             else {
[16:59:36.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:36.869]             }
[16:59:36.869]             {
[16:59:36.869]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:36.869]                   0L) {
[16:59:36.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:36.869]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:36.869]                   base::options(opts)
[16:59:36.869]                 }
[16:59:36.869]                 {
[16:59:36.869]                   {
[16:59:36.869]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:36.869]                     NULL
[16:59:36.869]                   }
[16:59:36.869]                   options(future.plan = NULL)
[16:59:36.869]                   if (is.na(NA_character_)) 
[16:59:36.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:36.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:36.869]                     .init = FALSE)
[16:59:36.869]                 }
[16:59:36.869]             }
[16:59:36.869]         }
[16:59:36.869]     })
[16:59:36.869]     if (TRUE) {
[16:59:36.869]         base::sink(type = "output", split = FALSE)
[16:59:36.869]         if (TRUE) {
[16:59:36.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:36.869]         }
[16:59:36.869]         else {
[16:59:36.869]             ...future.result["stdout"] <- base::list(NULL)
[16:59:36.869]         }
[16:59:36.869]         base::close(...future.stdout)
[16:59:36.869]         ...future.stdout <- NULL
[16:59:36.869]     }
[16:59:36.869]     ...future.result$conditions <- ...future.conditions
[16:59:36.869]     ...future.result$finished <- base::Sys.time()
[16:59:36.869]     ...future.result
[16:59:36.869] }
[16:59:36.872] Exporting 5 global objects (1.27 KiB) to cluster node #2 ...
[16:59:36.872] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:59:36.872] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:59:36.872] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:59:36.873] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:59:36.873] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ...
[16:59:36.873] Exporting ‘...future.elements_ii’ (528 bytes) to cluster node #2 ... DONE
[16:59:36.873] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:36.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:36.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:36.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:36.874] Exporting 5 global objects (1.27 KiB) to cluster node #2 ... DONE
[16:59:36.875] MultisessionFuture started
[16:59:36.875] - Launch lazy future ... done
[16:59:36.875] run() for ‘MultisessionFuture’ ... done
[16:59:36.875] Created future:
[16:59:36.875] MultisessionFuture:
[16:59:36.875] Label: ‘future_by-2’
[16:59:36.875] Expression:
[16:59:36.875] {
[16:59:36.875]     do.call(function(...) {
[16:59:36.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.875]             on.exit(options(oopts), add = TRUE)
[16:59:36.875]         }
[16:59:36.875]         {
[16:59:36.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.875]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.875]             })
[16:59:36.875]         }
[16:59:36.875]     }, args = future.call.arguments)
[16:59:36.875] }
[16:59:36.875] Lazy evaluation: FALSE
[16:59:36.875] Asynchronous evaluation: TRUE
[16:59:36.875] Local evaluation: TRUE
[16:59:36.875] Environment: R_GlobalEnv
[16:59:36.875] Capture standard output: TRUE
[16:59:36.875] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:36.875] Globals: 5 objects totaling 1.78 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 528 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:36.875] Packages: <none>
[16:59:36.875] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:36.875] Resolved: FALSE
[16:59:36.875] Value: <not collected>
[16:59:36.875] Conditions captured: <none>
[16:59:36.875] Early signaling: FALSE
[16:59:36.875] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:36.875] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.887] Chunk #2 of 2 ... DONE
[16:59:36.887] Launching 2 futures (chunks) ... DONE
[16:59:36.887] Resolving 2 futures (chunks) ...
[16:59:36.887] resolve() on list ...
[16:59:36.887]  recursive: 0
[16:59:36.887]  length: 2
[16:59:36.887] 
[16:59:36.888] receiveMessageFromWorker() for ClusterFuture ...
[16:59:36.888] - Validating connection of MultisessionFuture
[16:59:36.888] - received message: FutureResult
[16:59:36.888] - Received FutureResult
[16:59:36.888] - Erased future from FutureRegistry
[16:59:36.889] result() for ClusterFuture ...
[16:59:36.889] - result already collected: FutureResult
[16:59:36.889] result() for ClusterFuture ... done
[16:59:36.889] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:36.889] Future #1
[16:59:36.889] result() for ClusterFuture ...
[16:59:36.889] - result already collected: FutureResult
[16:59:36.889] result() for ClusterFuture ... done
[16:59:36.889] result() for ClusterFuture ...
[16:59:36.889] - result already collected: FutureResult
[16:59:36.889] result() for ClusterFuture ... done
[16:59:36.890] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:36.890] - nx: 2
[16:59:36.890] - relay: TRUE
[16:59:36.890] - stdout: TRUE
[16:59:36.890] - signal: TRUE
[16:59:36.890] - resignal: FALSE
[16:59:36.890] - force: TRUE
[16:59:36.890] - relayed: [n=2] FALSE, FALSE
[16:59:36.890] - queued futures: [n=2] FALSE, FALSE
[16:59:36.890]  - until=1
[16:59:36.890]  - relaying element #1
[16:59:36.890] result() for ClusterFuture ...
[16:59:36.891] - result already collected: FutureResult
[16:59:36.891] result() for ClusterFuture ... done
[16:59:36.891] result() for ClusterFuture ...
[16:59:36.891] - result already collected: FutureResult
[16:59:36.891] result() for ClusterFuture ... done
[16:59:36.891] result() for ClusterFuture ...
[16:59:36.891] - result already collected: FutureResult
[16:59:36.891] result() for ClusterFuture ... done
[16:59:36.891] result() for ClusterFuture ...
[16:59:36.891] - result already collected: FutureResult
[16:59:36.891] result() for ClusterFuture ... done
[16:59:36.892] - relayed: [n=2] TRUE, FALSE
[16:59:36.892] - queued futures: [n=2] TRUE, FALSE
[16:59:36.892] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:36.892]  length: 1 (resolved future 1)
[16:59:36.917] receiveMessageFromWorker() for ClusterFuture ...
[16:59:36.918] - Validating connection of MultisessionFuture
[16:59:36.918] - received message: FutureResult
[16:59:36.918] - Received FutureResult
[16:59:36.918] - Erased future from FutureRegistry
[16:59:36.918] result() for ClusterFuture ...
[16:59:36.918] - result already collected: FutureResult
[16:59:36.918] result() for ClusterFuture ... done
[16:59:36.918] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:36.919] Future #2
[16:59:36.919] result() for ClusterFuture ...
[16:59:36.919] - result already collected: FutureResult
[16:59:36.919] result() for ClusterFuture ... done
[16:59:36.919] result() for ClusterFuture ...
[16:59:36.919] - result already collected: FutureResult
[16:59:36.919] result() for ClusterFuture ... done
[16:59:36.919] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:36.919] - nx: 2
[16:59:36.919] - relay: TRUE
[16:59:36.919] - stdout: TRUE
[16:59:36.920] - signal: TRUE
[16:59:36.920] - resignal: FALSE
[16:59:36.920] - force: TRUE
[16:59:36.920] - relayed: [n=2] TRUE, FALSE
[16:59:36.920] - queued futures: [n=2] TRUE, FALSE
[16:59:36.920]  - until=2
[16:59:36.920]  - relaying element #2
[16:59:36.920] result() for ClusterFuture ...
[16:59:36.920] - result already collected: FutureResult
[16:59:36.920] result() for ClusterFuture ... done
[16:59:36.920] result() for ClusterFuture ...
[16:59:36.920] - result already collected: FutureResult
[16:59:36.921] result() for ClusterFuture ... done
[16:59:36.921] result() for ClusterFuture ...
[16:59:36.921] - result already collected: FutureResult
[16:59:36.921] result() for ClusterFuture ... done
[16:59:36.921] result() for ClusterFuture ...
[16:59:36.921] - result already collected: FutureResult
[16:59:36.921] result() for ClusterFuture ... done
[16:59:36.921] - relayed: [n=2] TRUE, TRUE
[16:59:36.921] - queued futures: [n=2] TRUE, TRUE
[16:59:36.921] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:36.921]  length: 0 (resolved future 2)
[16:59:36.922] Relaying remaining futures
[16:59:36.922] signalConditionsASAP(NULL, pos=0) ...
[16:59:36.922] - nx: 2
[16:59:36.922] - relay: TRUE
[16:59:36.922] - stdout: TRUE
[16:59:36.922] - signal: TRUE
[16:59:36.922] - resignal: FALSE
[16:59:36.922] - force: TRUE
[16:59:36.922] - relayed: [n=2] TRUE, TRUE
[16:59:36.922] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:36.922] - relayed: [n=2] TRUE, TRUE
[16:59:36.923] - queued futures: [n=2] TRUE, TRUE
[16:59:36.923] signalConditionsASAP(NULL, pos=0) ... done
[16:59:36.923] resolve() on list ... DONE
[16:59:36.923] result() for ClusterFuture ...
[16:59:36.923] - result already collected: FutureResult
[16:59:36.923] result() for ClusterFuture ... done
[16:59:36.923] result() for ClusterFuture ...
[16:59:36.923] - result already collected: FutureResult
[16:59:36.923] result() for ClusterFuture ... done
[16:59:36.923] result() for ClusterFuture ...
[16:59:36.923] - result already collected: FutureResult
[16:59:36.924] result() for ClusterFuture ... done
[16:59:36.924] result() for ClusterFuture ...
[16:59:36.924] - result already collected: FutureResult
[16:59:36.924] result() for ClusterFuture ... done
[16:59:36.924]  - Number of value chunks collected: 2
[16:59:36.924] Resolving 2 futures (chunks) ... DONE
[16:59:36.924] Reducing values from 2 chunks ...
[16:59:36.924]  - Number of values collected after concatenation: 6
[16:59:36.924]  - Number of values expected: 6
[16:59:36.924] Reducing values from 2 chunks ... DONE
[16:59:36.924] future_lapply() ... DONE
[16:59:36.924] future_by_internal() ... DONE
[16:59:36.925] future_by_internal() ...
[16:59:36.926] future_lapply() ...
[16:59:36.930] Number of chunks: 2
[16:59:36.930] getGlobalsAndPackagesXApply() ...
[16:59:36.931]  - future.globals: TRUE
[16:59:36.931] getGlobalsAndPackages() ...
[16:59:36.931] Searching for globals...
[16:59:36.932] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:36.932] Searching for globals ... DONE
[16:59:36.933] Resolving globals: FALSE
[16:59:36.933] The total size of the 1 globals is 5.20 KiB (5328 bytes)
[16:59:36.933] The total size of the 1 globals exported for future expression (‘FUN(singular.ok = FALSE)’) is 5.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (5.20 KiB of class ‘function’)
[16:59:36.934] - globals: [1] ‘FUN’
[16:59:36.934] - packages: [1] ‘stats’
[16:59:36.934] getGlobalsAndPackages() ... DONE
[16:59:36.934]  - globals found/used: [n=1] ‘FUN’
[16:59:36.934]  - needed namespaces: [n=1] ‘stats’
[16:59:36.934] Finding globals ... DONE
[16:59:36.934]  - use_args: TRUE
[16:59:36.934]  - Getting '...' globals ...
[16:59:36.935] resolve() on list ...
[16:59:36.935]  recursive: 0
[16:59:36.935]  length: 1
[16:59:36.935]  elements: ‘...’
[16:59:36.935]  length: 0 (resolved future 1)
[16:59:36.935] resolve() on list ... DONE
[16:59:36.935]    - '...' content: [n=1] ‘singular.ok’
[16:59:36.935] List of 1
[16:59:36.935]  $ ...:List of 1
[16:59:36.935]   ..$ singular.ok: logi FALSE
[16:59:36.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:36.935]  - attr(*, "where")=List of 1
[16:59:36.935]   ..$ ...:<environment: 0x562054aecdb8> 
[16:59:36.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:36.935]  - attr(*, "resolved")= logi TRUE
[16:59:36.935]  - attr(*, "total_size")= num NA
[16:59:36.938]  - Getting '...' globals ... DONE
[16:59:36.938] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:36.938] List of 2
[16:59:36.938]  $ ...future.FUN:function (x, ...)  
[16:59:36.938]  $ ...          :List of 1
[16:59:36.938]   ..$ singular.ok: logi FALSE
[16:59:36.938]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:36.938]  - attr(*, "where")=List of 2
[16:59:36.938]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:36.938]   ..$ ...          :<environment: 0x562054aecdb8> 
[16:59:36.938]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:36.938]  - attr(*, "resolved")= logi FALSE
[16:59:36.938]  - attr(*, "total_size")= num 5384
[16:59:36.941] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:36.942] getGlobalsAndPackagesXApply() ... DONE
[16:59:36.942] Number of futures (= number of chunks): 2
[16:59:36.942] Launching 2 futures (chunks) ...
[16:59:36.942] Chunk #1 of 2 ...
[16:59:36.942]  - Finding globals in 'X' for chunk #1 ...
[16:59:36.942] getGlobalsAndPackages() ...
[16:59:36.942] Searching for globals...
[16:59:36.943] 
[16:59:36.943] Searching for globals ... DONE
[16:59:36.943] - globals: [0] <none>
[16:59:36.943] getGlobalsAndPackages() ... DONE
[16:59:36.943]    + additional globals found: [n=0] 
[16:59:36.943]    + additional namespaces needed: [n=0] 
[16:59:36.943]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:36.943]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:36.943]  - seeds: <none>
[16:59:36.943]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.944] getGlobalsAndPackages() ...
[16:59:36.944] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.944] Resolving globals: FALSE
[16:59:36.944] Tweak future expression to call with '...' arguments ...
[16:59:36.944] {
[16:59:36.944]     do.call(function(...) {
[16:59:36.944]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.944]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.944]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.944]             on.exit(options(oopts), add = TRUE)
[16:59:36.944]         }
[16:59:36.944]         {
[16:59:36.944]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.944]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.944]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.944]             })
[16:59:36.944]         }
[16:59:36.944]     }, args = future.call.arguments)
[16:59:36.944] }
[16:59:36.944] Tweak future expression to call with '...' arguments ... DONE
[16:59:36.945] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.945] 
[16:59:36.945] getGlobalsAndPackages() ... DONE
[16:59:36.945] run() for ‘Future’ ...
[16:59:36.945] - state: ‘created’
[16:59:36.945] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:36.962] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:36.962]   - Field: ‘node’
[16:59:36.962]   - Field: ‘label’
[16:59:36.962]   - Field: ‘local’
[16:59:36.962]   - Field: ‘owner’
[16:59:36.962]   - Field: ‘envir’
[16:59:36.962]   - Field: ‘workers’
[16:59:36.962]   - Field: ‘packages’
[16:59:36.963]   - Field: ‘gc’
[16:59:36.963]   - Field: ‘conditions’
[16:59:36.963]   - Field: ‘persistent’
[16:59:36.963]   - Field: ‘expr’
[16:59:36.963]   - Field: ‘uuid’
[16:59:36.963]   - Field: ‘seed’
[16:59:36.963]   - Field: ‘version’
[16:59:36.963]   - Field: ‘result’
[16:59:36.963]   - Field: ‘asynchronous’
[16:59:36.963]   - Field: ‘calls’
[16:59:36.963]   - Field: ‘globals’
[16:59:36.963]   - Field: ‘stdout’
[16:59:36.964]   - Field: ‘earlySignal’
[16:59:36.964]   - Field: ‘lazy’
[16:59:36.964]   - Field: ‘state’
[16:59:36.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:36.964] - Launch lazy future ...
[16:59:36.964] Packages needed by the future expression (n = 1): ‘stats’
[16:59:36.964] Packages needed by future strategies (n = 0): <none>
[16:59:36.965] {
[16:59:36.965]     {
[16:59:36.965]         {
[16:59:36.965]             ...future.startTime <- base::Sys.time()
[16:59:36.965]             {
[16:59:36.965]                 {
[16:59:36.965]                   {
[16:59:36.965]                     {
[16:59:36.965]                       {
[16:59:36.965]                         base::local({
[16:59:36.965]                           has_future <- base::requireNamespace("future", 
[16:59:36.965]                             quietly = TRUE)
[16:59:36.965]                           if (has_future) {
[16:59:36.965]                             ns <- base::getNamespace("future")
[16:59:36.965]                             version <- ns[[".package"]][["version"]]
[16:59:36.965]                             if (is.null(version)) 
[16:59:36.965]                               version <- utils::packageVersion("future")
[16:59:36.965]                           }
[16:59:36.965]                           else {
[16:59:36.965]                             version <- NULL
[16:59:36.965]                           }
[16:59:36.965]                           if (!has_future || version < "1.8.0") {
[16:59:36.965]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:36.965]                               "", base::R.version$version.string), 
[16:59:36.965]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:36.965]                                 base::R.version$platform, 8 * 
[16:59:36.965]                                   base::.Machine$sizeof.pointer), 
[16:59:36.965]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:36.965]                                 "release", "version")], collapse = " "), 
[16:59:36.965]                               hostname = base::Sys.info()[["nodename"]])
[16:59:36.965]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:36.965]                               info)
[16:59:36.965]                             info <- base::paste(info, collapse = "; ")
[16:59:36.965]                             if (!has_future) {
[16:59:36.965]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:36.965]                                 info)
[16:59:36.965]                             }
[16:59:36.965]                             else {
[16:59:36.965]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:36.965]                                 info, version)
[16:59:36.965]                             }
[16:59:36.965]                             base::stop(msg)
[16:59:36.965]                           }
[16:59:36.965]                         })
[16:59:36.965]                       }
[16:59:36.965]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:36.965]                       base::options(mc.cores = 1L)
[16:59:36.965]                     }
[16:59:36.965]                     base::local({
[16:59:36.965]                       for (pkg in "stats") {
[16:59:36.965]                         base::loadNamespace(pkg)
[16:59:36.965]                         base::library(pkg, character.only = TRUE)
[16:59:36.965]                       }
[16:59:36.965]                     })
[16:59:36.965]                   }
[16:59:36.965]                   ...future.strategy.old <- future::plan("list")
[16:59:36.965]                   options(future.plan = NULL)
[16:59:36.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:36.965]                 }
[16:59:36.965]                 ...future.workdir <- getwd()
[16:59:36.965]             }
[16:59:36.965]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:36.965]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:36.965]         }
[16:59:36.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:36.965]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:36.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:36.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:36.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:36.965]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:36.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:36.965]             base::names(...future.oldOptions))
[16:59:36.965]     }
[16:59:36.965]     if (FALSE) {
[16:59:36.965]     }
[16:59:36.965]     else {
[16:59:36.965]         if (TRUE) {
[16:59:36.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:36.965]                 open = "w")
[16:59:36.965]         }
[16:59:36.965]         else {
[16:59:36.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:36.965]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:36.965]         }
[16:59:36.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:36.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:36.965]             base::sink(type = "output", split = FALSE)
[16:59:36.965]             base::close(...future.stdout)
[16:59:36.965]         }, add = TRUE)
[16:59:36.965]     }
[16:59:36.965]     ...future.frame <- base::sys.nframe()
[16:59:36.965]     ...future.conditions <- base::list()
[16:59:36.965]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:36.965]     if (FALSE) {
[16:59:36.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:36.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:36.965]     }
[16:59:36.965]     ...future.result <- base::tryCatch({
[16:59:36.965]         base::withCallingHandlers({
[16:59:36.965]             ...future.value <- base::withVisible(base::local({
[16:59:36.965]                 ...future.makeSendCondition <- base::local({
[16:59:36.965]                   sendCondition <- NULL
[16:59:36.965]                   function(frame = 1L) {
[16:59:36.965]                     if (is.function(sendCondition)) 
[16:59:36.965]                       return(sendCondition)
[16:59:36.965]                     ns <- getNamespace("parallel")
[16:59:36.965]                     if (exists("sendData", mode = "function", 
[16:59:36.965]                       envir = ns)) {
[16:59:36.965]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:36.965]                         envir = ns)
[16:59:36.965]                       envir <- sys.frame(frame)
[16:59:36.965]                       master <- NULL
[16:59:36.965]                       while (!identical(envir, .GlobalEnv) && 
[16:59:36.965]                         !identical(envir, emptyenv())) {
[16:59:36.965]                         if (exists("master", mode = "list", envir = envir, 
[16:59:36.965]                           inherits = FALSE)) {
[16:59:36.965]                           master <- get("master", mode = "list", 
[16:59:36.965]                             envir = envir, inherits = FALSE)
[16:59:36.965]                           if (inherits(master, c("SOCKnode", 
[16:59:36.965]                             "SOCK0node"))) {
[16:59:36.965]                             sendCondition <<- function(cond) {
[16:59:36.965]                               data <- list(type = "VALUE", value = cond, 
[16:59:36.965]                                 success = TRUE)
[16:59:36.965]                               parallel_sendData(master, data)
[16:59:36.965]                             }
[16:59:36.965]                             return(sendCondition)
[16:59:36.965]                           }
[16:59:36.965]                         }
[16:59:36.965]                         frame <- frame + 1L
[16:59:36.965]                         envir <- sys.frame(frame)
[16:59:36.965]                       }
[16:59:36.965]                     }
[16:59:36.965]                     sendCondition <<- function(cond) NULL
[16:59:36.965]                   }
[16:59:36.965]                 })
[16:59:36.965]                 withCallingHandlers({
[16:59:36.965]                   {
[16:59:36.965]                     do.call(function(...) {
[16:59:36.965]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.965]                       if (!identical(...future.globals.maxSize.org, 
[16:59:36.965]                         ...future.globals.maxSize)) {
[16:59:36.965]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.965]                         on.exit(options(oopts), add = TRUE)
[16:59:36.965]                       }
[16:59:36.965]                       {
[16:59:36.965]                         lapply(seq_along(...future.elements_ii), 
[16:59:36.965]                           FUN = function(jj) {
[16:59:36.965]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.965]                             ...future.FUN(...future.X_jj, ...)
[16:59:36.965]                           })
[16:59:36.965]                       }
[16:59:36.965]                     }, args = future.call.arguments)
[16:59:36.965]                   }
[16:59:36.965]                 }, immediateCondition = function(cond) {
[16:59:36.965]                   sendCondition <- ...future.makeSendCondition()
[16:59:36.965]                   sendCondition(cond)
[16:59:36.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.965]                   {
[16:59:36.965]                     inherits <- base::inherits
[16:59:36.965]                     invokeRestart <- base::invokeRestart
[16:59:36.965]                     is.null <- base::is.null
[16:59:36.965]                     muffled <- FALSE
[16:59:36.965]                     if (inherits(cond, "message")) {
[16:59:36.965]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:36.965]                       if (muffled) 
[16:59:36.965]                         invokeRestart("muffleMessage")
[16:59:36.965]                     }
[16:59:36.965]                     else if (inherits(cond, "warning")) {
[16:59:36.965]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:36.965]                       if (muffled) 
[16:59:36.965]                         invokeRestart("muffleWarning")
[16:59:36.965]                     }
[16:59:36.965]                     else if (inherits(cond, "condition")) {
[16:59:36.965]                       if (!is.null(pattern)) {
[16:59:36.965]                         computeRestarts <- base::computeRestarts
[16:59:36.965]                         grepl <- base::grepl
[16:59:36.965]                         restarts <- computeRestarts(cond)
[16:59:36.965]                         for (restart in restarts) {
[16:59:36.965]                           name <- restart$name
[16:59:36.965]                           if (is.null(name)) 
[16:59:36.965]                             next
[16:59:36.965]                           if (!grepl(pattern, name)) 
[16:59:36.965]                             next
[16:59:36.965]                           invokeRestart(restart)
[16:59:36.965]                           muffled <- TRUE
[16:59:36.965]                           break
[16:59:36.965]                         }
[16:59:36.965]                       }
[16:59:36.965]                     }
[16:59:36.965]                     invisible(muffled)
[16:59:36.965]                   }
[16:59:36.965]                   muffleCondition(cond)
[16:59:36.965]                 })
[16:59:36.965]             }))
[16:59:36.965]             future::FutureResult(value = ...future.value$value, 
[16:59:36.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.965]                   ...future.rng), globalenv = if (FALSE) 
[16:59:36.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:36.965]                     ...future.globalenv.names))
[16:59:36.965]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:36.965]         }, condition = base::local({
[16:59:36.965]             c <- base::c
[16:59:36.965]             inherits <- base::inherits
[16:59:36.965]             invokeRestart <- base::invokeRestart
[16:59:36.965]             length <- base::length
[16:59:36.965]             list <- base::list
[16:59:36.965]             seq.int <- base::seq.int
[16:59:36.965]             signalCondition <- base::signalCondition
[16:59:36.965]             sys.calls <- base::sys.calls
[16:59:36.965]             `[[` <- base::`[[`
[16:59:36.965]             `+` <- base::`+`
[16:59:36.965]             `<<-` <- base::`<<-`
[16:59:36.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:36.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:36.965]                   3L)]
[16:59:36.965]             }
[16:59:36.965]             function(cond) {
[16:59:36.965]                 is_error <- inherits(cond, "error")
[16:59:36.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:36.965]                   NULL)
[16:59:36.965]                 if (is_error) {
[16:59:36.965]                   sessionInformation <- function() {
[16:59:36.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:36.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:36.965]                       search = base::search(), system = base::Sys.info())
[16:59:36.965]                   }
[16:59:36.965]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:36.965]                     cond$call), session = sessionInformation(), 
[16:59:36.965]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:36.965]                   signalCondition(cond)
[16:59:36.965]                 }
[16:59:36.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:36.965]                 "immediateCondition"))) {
[16:59:36.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:36.965]                   ...future.conditions[[length(...future.conditions) + 
[16:59:36.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:36.965]                   if (TRUE && !signal) {
[16:59:36.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.965]                     {
[16:59:36.965]                       inherits <- base::inherits
[16:59:36.965]                       invokeRestart <- base::invokeRestart
[16:59:36.965]                       is.null <- base::is.null
[16:59:36.965]                       muffled <- FALSE
[16:59:36.965]                       if (inherits(cond, "message")) {
[16:59:36.965]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.965]                         if (muffled) 
[16:59:36.965]                           invokeRestart("muffleMessage")
[16:59:36.965]                       }
[16:59:36.965]                       else if (inherits(cond, "warning")) {
[16:59:36.965]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.965]                         if (muffled) 
[16:59:36.965]                           invokeRestart("muffleWarning")
[16:59:36.965]                       }
[16:59:36.965]                       else if (inherits(cond, "condition")) {
[16:59:36.965]                         if (!is.null(pattern)) {
[16:59:36.965]                           computeRestarts <- base::computeRestarts
[16:59:36.965]                           grepl <- base::grepl
[16:59:36.965]                           restarts <- computeRestarts(cond)
[16:59:36.965]                           for (restart in restarts) {
[16:59:36.965]                             name <- restart$name
[16:59:36.965]                             if (is.null(name)) 
[16:59:36.965]                               next
[16:59:36.965]                             if (!grepl(pattern, name)) 
[16:59:36.965]                               next
[16:59:36.965]                             invokeRestart(restart)
[16:59:36.965]                             muffled <- TRUE
[16:59:36.965]                             break
[16:59:36.965]                           }
[16:59:36.965]                         }
[16:59:36.965]                       }
[16:59:36.965]                       invisible(muffled)
[16:59:36.965]                     }
[16:59:36.965]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.965]                   }
[16:59:36.965]                 }
[16:59:36.965]                 else {
[16:59:36.965]                   if (TRUE) {
[16:59:36.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:36.965]                     {
[16:59:36.965]                       inherits <- base::inherits
[16:59:36.965]                       invokeRestart <- base::invokeRestart
[16:59:36.965]                       is.null <- base::is.null
[16:59:36.965]                       muffled <- FALSE
[16:59:36.965]                       if (inherits(cond, "message")) {
[16:59:36.965]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:36.965]                         if (muffled) 
[16:59:36.965]                           invokeRestart("muffleMessage")
[16:59:36.965]                       }
[16:59:36.965]                       else if (inherits(cond, "warning")) {
[16:59:36.965]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:36.965]                         if (muffled) 
[16:59:36.965]                           invokeRestart("muffleWarning")
[16:59:36.965]                       }
[16:59:36.965]                       else if (inherits(cond, "condition")) {
[16:59:36.965]                         if (!is.null(pattern)) {
[16:59:36.965]                           computeRestarts <- base::computeRestarts
[16:59:36.965]                           grepl <- base::grepl
[16:59:36.965]                           restarts <- computeRestarts(cond)
[16:59:36.965]                           for (restart in restarts) {
[16:59:36.965]                             name <- restart$name
[16:59:36.965]                             if (is.null(name)) 
[16:59:36.965]                               next
[16:59:36.965]                             if (!grepl(pattern, name)) 
[16:59:36.965]                               next
[16:59:36.965]                             invokeRestart(restart)
[16:59:36.965]                             muffled <- TRUE
[16:59:36.965]                             break
[16:59:36.965]                           }
[16:59:36.965]                         }
[16:59:36.965]                       }
[16:59:36.965]                       invisible(muffled)
[16:59:36.965]                     }
[16:59:36.965]                     muffleCondition(cond, pattern = "^muffle")
[16:59:36.965]                   }
[16:59:36.965]                 }
[16:59:36.965]             }
[16:59:36.965]         }))
[16:59:36.965]     }, error = function(ex) {
[16:59:36.965]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:36.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:36.965]                 ...future.rng), started = ...future.startTime, 
[16:59:36.965]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:36.965]             version = "1.8"), class = "FutureResult")
[16:59:36.965]     }, finally = {
[16:59:36.965]         if (!identical(...future.workdir, getwd())) 
[16:59:36.965]             setwd(...future.workdir)
[16:59:36.965]         {
[16:59:36.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:36.965]                 ...future.oldOptions$nwarnings <- NULL
[16:59:36.965]             }
[16:59:36.965]             base::options(...future.oldOptions)
[16:59:36.965]             if (.Platform$OS.type == "windows") {
[16:59:36.965]                 old_names <- names(...future.oldEnvVars)
[16:59:36.965]                 envs <- base::Sys.getenv()
[16:59:36.965]                 names <- names(envs)
[16:59:36.965]                 common <- intersect(names, old_names)
[16:59:36.965]                 added <- setdiff(names, old_names)
[16:59:36.965]                 removed <- setdiff(old_names, names)
[16:59:36.965]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:36.965]                   envs[common]]
[16:59:36.965]                 NAMES <- toupper(changed)
[16:59:36.965]                 args <- list()
[16:59:36.965]                 for (kk in seq_along(NAMES)) {
[16:59:36.965]                   name <- changed[[kk]]
[16:59:36.965]                   NAME <- NAMES[[kk]]
[16:59:36.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.965]                     next
[16:59:36.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.965]                 }
[16:59:36.965]                 NAMES <- toupper(added)
[16:59:36.965]                 for (kk in seq_along(NAMES)) {
[16:59:36.965]                   name <- added[[kk]]
[16:59:36.965]                   NAME <- NAMES[[kk]]
[16:59:36.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.965]                     next
[16:59:36.965]                   args[[name]] <- ""
[16:59:36.965]                 }
[16:59:36.965]                 NAMES <- toupper(removed)
[16:59:36.965]                 for (kk in seq_along(NAMES)) {
[16:59:36.965]                   name <- removed[[kk]]
[16:59:36.965]                   NAME <- NAMES[[kk]]
[16:59:36.965]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:36.965]                     next
[16:59:36.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:36.965]                 }
[16:59:36.965]                 if (length(args) > 0) 
[16:59:36.965]                   base::do.call(base::Sys.setenv, args = args)
[16:59:36.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:36.965]             }
[16:59:36.965]             else {
[16:59:36.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:36.965]             }
[16:59:36.965]             {
[16:59:36.965]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:36.965]                   0L) {
[16:59:36.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:36.965]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:36.965]                   base::options(opts)
[16:59:36.965]                 }
[16:59:36.965]                 {
[16:59:36.965]                   {
[16:59:36.965]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:36.965]                     NULL
[16:59:36.965]                   }
[16:59:36.965]                   options(future.plan = NULL)
[16:59:36.965]                   if (is.na(NA_character_)) 
[16:59:36.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:36.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:36.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:36.965]                     .init = FALSE)
[16:59:36.965]                 }
[16:59:36.965]             }
[16:59:36.965]         }
[16:59:36.965]     })
[16:59:36.965]     if (TRUE) {
[16:59:36.965]         base::sink(type = "output", split = FALSE)
[16:59:36.965]         if (TRUE) {
[16:59:36.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:36.965]         }
[16:59:36.965]         else {
[16:59:36.965]             ...future.result["stdout"] <- base::list(NULL)
[16:59:36.965]         }
[16:59:36.965]         base::close(...future.stdout)
[16:59:36.965]         ...future.stdout <- NULL
[16:59:36.965]     }
[16:59:36.965]     ...future.result$conditions <- ...future.conditions
[16:59:36.965]     ...future.result$finished <- base::Sys.time()
[16:59:36.965]     ...future.result
[16:59:36.965] }
[16:59:36.968] Exporting 5 global objects (5.26 KiB) to cluster node #1 ...
[16:59:36.968] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ...
[16:59:36.968] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #1 ... DONE
[16:59:36.969] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ...
[16:59:36.969] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #1 ... DONE
[16:59:36.969] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:59:36.970] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:59:36.970] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:36.970] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.970] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:36.971] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:36.971] Exporting 5 global objects (5.26 KiB) to cluster node #1 ... DONE
[16:59:36.971] MultisessionFuture started
[16:59:36.971] - Launch lazy future ... done
[16:59:36.972] run() for ‘MultisessionFuture’ ... done
[16:59:36.972] Created future:
[16:59:36.972] MultisessionFuture:
[16:59:36.972] Label: ‘future_by-1’
[16:59:36.972] Expression:
[16:59:36.972] {
[16:59:36.972]     do.call(function(...) {
[16:59:36.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.972]             on.exit(options(oopts), add = TRUE)
[16:59:36.972]         }
[16:59:36.972]         {
[16:59:36.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.972]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.972]             })
[16:59:36.972]         }
[16:59:36.972]     }, args = future.call.arguments)
[16:59:36.972] }
[16:59:36.972] Lazy evaluation: FALSE
[16:59:36.972] Asynchronous evaluation: TRUE
[16:59:36.972] Local evaluation: TRUE
[16:59:36.972] Environment: R_GlobalEnv
[16:59:36.972] Capture standard output: TRUE
[16:59:36.972] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:36.972] Globals: 5 objects totaling 6.86 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:36.972] Packages: 1 packages (‘stats’)
[16:59:36.972] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:36.972] Resolved: FALSE
[16:59:36.972] Value: <not collected>
[16:59:36.972] Conditions captured: <none>
[16:59:36.972] Early signaling: FALSE
[16:59:36.972] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:36.972] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:36.983] Chunk #1 of 2 ... DONE
[16:59:36.984] Chunk #2 of 2 ...
[16:59:36.984]  - Finding globals in 'X' for chunk #2 ...
[16:59:36.984] getGlobalsAndPackages() ...
[16:59:36.984] Searching for globals...
[16:59:36.984] 
[16:59:36.985] Searching for globals ... DONE
[16:59:36.985] - globals: [0] <none>
[16:59:36.985] getGlobalsAndPackages() ... DONE
[16:59:36.985]    + additional globals found: [n=0] 
[16:59:36.985]    + additional namespaces needed: [n=0] 
[16:59:36.985]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:36.985]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:36.985]  - seeds: <none>
[16:59:36.985]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.985] getGlobalsAndPackages() ...
[16:59:36.985] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.986] Resolving globals: FALSE
[16:59:36.986] Tweak future expression to call with '...' arguments ...
[16:59:36.986] {
[16:59:36.986]     do.call(function(...) {
[16:59:36.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:36.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:36.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:36.986]             on.exit(options(oopts), add = TRUE)
[16:59:36.986]         }
[16:59:36.986]         {
[16:59:36.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:36.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:36.986]                 ...future.FUN(...future.X_jj, ...)
[16:59:36.986]             })
[16:59:36.986]         }
[16:59:36.986]     }, args = future.call.arguments)
[16:59:36.986] }
[16:59:36.986] Tweak future expression to call with '...' arguments ... DONE
[16:59:36.986] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:36.986] 
[16:59:36.987] getGlobalsAndPackages() ... DONE
[16:59:36.987] run() for ‘Future’ ...
[16:59:36.987] - state: ‘created’
[16:59:36.987] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.002] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.003] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.003]   - Field: ‘node’
[16:59:37.003]   - Field: ‘label’
[16:59:37.003]   - Field: ‘local’
[16:59:37.003]   - Field: ‘owner’
[16:59:37.003]   - Field: ‘envir’
[16:59:37.003]   - Field: ‘workers’
[16:59:37.003]   - Field: ‘packages’
[16:59:37.003]   - Field: ‘gc’
[16:59:37.004]   - Field: ‘conditions’
[16:59:37.004]   - Field: ‘persistent’
[16:59:37.004]   - Field: ‘expr’
[16:59:37.004]   - Field: ‘uuid’
[16:59:37.004]   - Field: ‘seed’
[16:59:37.004]   - Field: ‘version’
[16:59:37.004]   - Field: ‘result’
[16:59:37.004]   - Field: ‘asynchronous’
[16:59:37.004]   - Field: ‘calls’
[16:59:37.004]   - Field: ‘globals’
[16:59:37.004]   - Field: ‘stdout’
[16:59:37.005]   - Field: ‘earlySignal’
[16:59:37.005]   - Field: ‘lazy’
[16:59:37.005]   - Field: ‘state’
[16:59:37.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.005] - Launch lazy future ...
[16:59:37.005] Packages needed by the future expression (n = 1): ‘stats’
[16:59:37.005] Packages needed by future strategies (n = 0): <none>
[16:59:37.006] {
[16:59:37.006]     {
[16:59:37.006]         {
[16:59:37.006]             ...future.startTime <- base::Sys.time()
[16:59:37.006]             {
[16:59:37.006]                 {
[16:59:37.006]                   {
[16:59:37.006]                     {
[16:59:37.006]                       {
[16:59:37.006]                         base::local({
[16:59:37.006]                           has_future <- base::requireNamespace("future", 
[16:59:37.006]                             quietly = TRUE)
[16:59:37.006]                           if (has_future) {
[16:59:37.006]                             ns <- base::getNamespace("future")
[16:59:37.006]                             version <- ns[[".package"]][["version"]]
[16:59:37.006]                             if (is.null(version)) 
[16:59:37.006]                               version <- utils::packageVersion("future")
[16:59:37.006]                           }
[16:59:37.006]                           else {
[16:59:37.006]                             version <- NULL
[16:59:37.006]                           }
[16:59:37.006]                           if (!has_future || version < "1.8.0") {
[16:59:37.006]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.006]                               "", base::R.version$version.string), 
[16:59:37.006]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:37.006]                                 base::R.version$platform, 8 * 
[16:59:37.006]                                   base::.Machine$sizeof.pointer), 
[16:59:37.006]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.006]                                 "release", "version")], collapse = " "), 
[16:59:37.006]                               hostname = base::Sys.info()[["nodename"]])
[16:59:37.006]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.006]                               info)
[16:59:37.006]                             info <- base::paste(info, collapse = "; ")
[16:59:37.006]                             if (!has_future) {
[16:59:37.006]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.006]                                 info)
[16:59:37.006]                             }
[16:59:37.006]                             else {
[16:59:37.006]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.006]                                 info, version)
[16:59:37.006]                             }
[16:59:37.006]                             base::stop(msg)
[16:59:37.006]                           }
[16:59:37.006]                         })
[16:59:37.006]                       }
[16:59:37.006]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.006]                       base::options(mc.cores = 1L)
[16:59:37.006]                     }
[16:59:37.006]                     base::local({
[16:59:37.006]                       for (pkg in "stats") {
[16:59:37.006]                         base::loadNamespace(pkg)
[16:59:37.006]                         base::library(pkg, character.only = TRUE)
[16:59:37.006]                       }
[16:59:37.006]                     })
[16:59:37.006]                   }
[16:59:37.006]                   ...future.strategy.old <- future::plan("list")
[16:59:37.006]                   options(future.plan = NULL)
[16:59:37.006]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.006]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.006]                 }
[16:59:37.006]                 ...future.workdir <- getwd()
[16:59:37.006]             }
[16:59:37.006]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.006]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.006]         }
[16:59:37.006]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.006]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.006]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.006]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.006]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.006]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.006]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.006]             base::names(...future.oldOptions))
[16:59:37.006]     }
[16:59:37.006]     if (FALSE) {
[16:59:37.006]     }
[16:59:37.006]     else {
[16:59:37.006]         if (TRUE) {
[16:59:37.006]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.006]                 open = "w")
[16:59:37.006]         }
[16:59:37.006]         else {
[16:59:37.006]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.006]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.006]         }
[16:59:37.006]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.006]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.006]             base::sink(type = "output", split = FALSE)
[16:59:37.006]             base::close(...future.stdout)
[16:59:37.006]         }, add = TRUE)
[16:59:37.006]     }
[16:59:37.006]     ...future.frame <- base::sys.nframe()
[16:59:37.006]     ...future.conditions <- base::list()
[16:59:37.006]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.006]     if (FALSE) {
[16:59:37.006]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.006]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.006]     }
[16:59:37.006]     ...future.result <- base::tryCatch({
[16:59:37.006]         base::withCallingHandlers({
[16:59:37.006]             ...future.value <- base::withVisible(base::local({
[16:59:37.006]                 ...future.makeSendCondition <- base::local({
[16:59:37.006]                   sendCondition <- NULL
[16:59:37.006]                   function(frame = 1L) {
[16:59:37.006]                     if (is.function(sendCondition)) 
[16:59:37.006]                       return(sendCondition)
[16:59:37.006]                     ns <- getNamespace("parallel")
[16:59:37.006]                     if (exists("sendData", mode = "function", 
[16:59:37.006]                       envir = ns)) {
[16:59:37.006]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.006]                         envir = ns)
[16:59:37.006]                       envir <- sys.frame(frame)
[16:59:37.006]                       master <- NULL
[16:59:37.006]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.006]                         !identical(envir, emptyenv())) {
[16:59:37.006]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.006]                           inherits = FALSE)) {
[16:59:37.006]                           master <- get("master", mode = "list", 
[16:59:37.006]                             envir = envir, inherits = FALSE)
[16:59:37.006]                           if (inherits(master, c("SOCKnode", 
[16:59:37.006]                             "SOCK0node"))) {
[16:59:37.006]                             sendCondition <<- function(cond) {
[16:59:37.006]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.006]                                 success = TRUE)
[16:59:37.006]                               parallel_sendData(master, data)
[16:59:37.006]                             }
[16:59:37.006]                             return(sendCondition)
[16:59:37.006]                           }
[16:59:37.006]                         }
[16:59:37.006]                         frame <- frame + 1L
[16:59:37.006]                         envir <- sys.frame(frame)
[16:59:37.006]                       }
[16:59:37.006]                     }
[16:59:37.006]                     sendCondition <<- function(cond) NULL
[16:59:37.006]                   }
[16:59:37.006]                 })
[16:59:37.006]                 withCallingHandlers({
[16:59:37.006]                   {
[16:59:37.006]                     do.call(function(...) {
[16:59:37.006]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.006]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.006]                         ...future.globals.maxSize)) {
[16:59:37.006]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.006]                         on.exit(options(oopts), add = TRUE)
[16:59:37.006]                       }
[16:59:37.006]                       {
[16:59:37.006]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.006]                           FUN = function(jj) {
[16:59:37.006]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.006]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.006]                           })
[16:59:37.006]                       }
[16:59:37.006]                     }, args = future.call.arguments)
[16:59:37.006]                   }
[16:59:37.006]                 }, immediateCondition = function(cond) {
[16:59:37.006]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.006]                   sendCondition(cond)
[16:59:37.006]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.006]                   {
[16:59:37.006]                     inherits <- base::inherits
[16:59:37.006]                     invokeRestart <- base::invokeRestart
[16:59:37.006]                     is.null <- base::is.null
[16:59:37.006]                     muffled <- FALSE
[16:59:37.006]                     if (inherits(cond, "message")) {
[16:59:37.006]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.006]                       if (muffled) 
[16:59:37.006]                         invokeRestart("muffleMessage")
[16:59:37.006]                     }
[16:59:37.006]                     else if (inherits(cond, "warning")) {
[16:59:37.006]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.006]                       if (muffled) 
[16:59:37.006]                         invokeRestart("muffleWarning")
[16:59:37.006]                     }
[16:59:37.006]                     else if (inherits(cond, "condition")) {
[16:59:37.006]                       if (!is.null(pattern)) {
[16:59:37.006]                         computeRestarts <- base::computeRestarts
[16:59:37.006]                         grepl <- base::grepl
[16:59:37.006]                         restarts <- computeRestarts(cond)
[16:59:37.006]                         for (restart in restarts) {
[16:59:37.006]                           name <- restart$name
[16:59:37.006]                           if (is.null(name)) 
[16:59:37.006]                             next
[16:59:37.006]                           if (!grepl(pattern, name)) 
[16:59:37.006]                             next
[16:59:37.006]                           invokeRestart(restart)
[16:59:37.006]                           muffled <- TRUE
[16:59:37.006]                           break
[16:59:37.006]                         }
[16:59:37.006]                       }
[16:59:37.006]                     }
[16:59:37.006]                     invisible(muffled)
[16:59:37.006]                   }
[16:59:37.006]                   muffleCondition(cond)
[16:59:37.006]                 })
[16:59:37.006]             }))
[16:59:37.006]             future::FutureResult(value = ...future.value$value, 
[16:59:37.006]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.006]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.006]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.006]                     ...future.globalenv.names))
[16:59:37.006]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.006]         }, condition = base::local({
[16:59:37.006]             c <- base::c
[16:59:37.006]             inherits <- base::inherits
[16:59:37.006]             invokeRestart <- base::invokeRestart
[16:59:37.006]             length <- base::length
[16:59:37.006]             list <- base::list
[16:59:37.006]             seq.int <- base::seq.int
[16:59:37.006]             signalCondition <- base::signalCondition
[16:59:37.006]             sys.calls <- base::sys.calls
[16:59:37.006]             `[[` <- base::`[[`
[16:59:37.006]             `+` <- base::`+`
[16:59:37.006]             `<<-` <- base::`<<-`
[16:59:37.006]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.006]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.006]                   3L)]
[16:59:37.006]             }
[16:59:37.006]             function(cond) {
[16:59:37.006]                 is_error <- inherits(cond, "error")
[16:59:37.006]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.006]                   NULL)
[16:59:37.006]                 if (is_error) {
[16:59:37.006]                   sessionInformation <- function() {
[16:59:37.006]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.006]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.006]                       search = base::search(), system = base::Sys.info())
[16:59:37.006]                   }
[16:59:37.006]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.006]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.006]                     cond$call), session = sessionInformation(), 
[16:59:37.006]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.006]                   signalCondition(cond)
[16:59:37.006]                 }
[16:59:37.006]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.006]                 "immediateCondition"))) {
[16:59:37.006]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.006]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.006]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.006]                   if (TRUE && !signal) {
[16:59:37.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.006]                     {
[16:59:37.006]                       inherits <- base::inherits
[16:59:37.006]                       invokeRestart <- base::invokeRestart
[16:59:37.006]                       is.null <- base::is.null
[16:59:37.006]                       muffled <- FALSE
[16:59:37.006]                       if (inherits(cond, "message")) {
[16:59:37.006]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.006]                         if (muffled) 
[16:59:37.006]                           invokeRestart("muffleMessage")
[16:59:37.006]                       }
[16:59:37.006]                       else if (inherits(cond, "warning")) {
[16:59:37.006]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.006]                         if (muffled) 
[16:59:37.006]                           invokeRestart("muffleWarning")
[16:59:37.006]                       }
[16:59:37.006]                       else if (inherits(cond, "condition")) {
[16:59:37.006]                         if (!is.null(pattern)) {
[16:59:37.006]                           computeRestarts <- base::computeRestarts
[16:59:37.006]                           grepl <- base::grepl
[16:59:37.006]                           restarts <- computeRestarts(cond)
[16:59:37.006]                           for (restart in restarts) {
[16:59:37.006]                             name <- restart$name
[16:59:37.006]                             if (is.null(name)) 
[16:59:37.006]                               next
[16:59:37.006]                             if (!grepl(pattern, name)) 
[16:59:37.006]                               next
[16:59:37.006]                             invokeRestart(restart)
[16:59:37.006]                             muffled <- TRUE
[16:59:37.006]                             break
[16:59:37.006]                           }
[16:59:37.006]                         }
[16:59:37.006]                       }
[16:59:37.006]                       invisible(muffled)
[16:59:37.006]                     }
[16:59:37.006]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.006]                   }
[16:59:37.006]                 }
[16:59:37.006]                 else {
[16:59:37.006]                   if (TRUE) {
[16:59:37.006]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.006]                     {
[16:59:37.006]                       inherits <- base::inherits
[16:59:37.006]                       invokeRestart <- base::invokeRestart
[16:59:37.006]                       is.null <- base::is.null
[16:59:37.006]                       muffled <- FALSE
[16:59:37.006]                       if (inherits(cond, "message")) {
[16:59:37.006]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.006]                         if (muffled) 
[16:59:37.006]                           invokeRestart("muffleMessage")
[16:59:37.006]                       }
[16:59:37.006]                       else if (inherits(cond, "warning")) {
[16:59:37.006]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.006]                         if (muffled) 
[16:59:37.006]                           invokeRestart("muffleWarning")
[16:59:37.006]                       }
[16:59:37.006]                       else if (inherits(cond, "condition")) {
[16:59:37.006]                         if (!is.null(pattern)) {
[16:59:37.006]                           computeRestarts <- base::computeRestarts
[16:59:37.006]                           grepl <- base::grepl
[16:59:37.006]                           restarts <- computeRestarts(cond)
[16:59:37.006]                           for (restart in restarts) {
[16:59:37.006]                             name <- restart$name
[16:59:37.006]                             if (is.null(name)) 
[16:59:37.006]                               next
[16:59:37.006]                             if (!grepl(pattern, name)) 
[16:59:37.006]                               next
[16:59:37.006]                             invokeRestart(restart)
[16:59:37.006]                             muffled <- TRUE
[16:59:37.006]                             break
[16:59:37.006]                           }
[16:59:37.006]                         }
[16:59:37.006]                       }
[16:59:37.006]                       invisible(muffled)
[16:59:37.006]                     }
[16:59:37.006]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.006]                   }
[16:59:37.006]                 }
[16:59:37.006]             }
[16:59:37.006]         }))
[16:59:37.006]     }, error = function(ex) {
[16:59:37.006]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.006]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.006]                 ...future.rng), started = ...future.startTime, 
[16:59:37.006]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.006]             version = "1.8"), class = "FutureResult")
[16:59:37.006]     }, finally = {
[16:59:37.006]         if (!identical(...future.workdir, getwd())) 
[16:59:37.006]             setwd(...future.workdir)
[16:59:37.006]         {
[16:59:37.006]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.006]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.006]             }
[16:59:37.006]             base::options(...future.oldOptions)
[16:59:37.006]             if (.Platform$OS.type == "windows") {
[16:59:37.006]                 old_names <- names(...future.oldEnvVars)
[16:59:37.006]                 envs <- base::Sys.getenv()
[16:59:37.006]                 names <- names(envs)
[16:59:37.006]                 common <- intersect(names, old_names)
[16:59:37.006]                 added <- setdiff(names, old_names)
[16:59:37.006]                 removed <- setdiff(old_names, names)
[16:59:37.006]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.006]                   envs[common]]
[16:59:37.006]                 NAMES <- toupper(changed)
[16:59:37.006]                 args <- list()
[16:59:37.006]                 for (kk in seq_along(NAMES)) {
[16:59:37.006]                   name <- changed[[kk]]
[16:59:37.006]                   NAME <- NAMES[[kk]]
[16:59:37.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.006]                     next
[16:59:37.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.006]                 }
[16:59:37.006]                 NAMES <- toupper(added)
[16:59:37.006]                 for (kk in seq_along(NAMES)) {
[16:59:37.006]                   name <- added[[kk]]
[16:59:37.006]                   NAME <- NAMES[[kk]]
[16:59:37.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.006]                     next
[16:59:37.006]                   args[[name]] <- ""
[16:59:37.006]                 }
[16:59:37.006]                 NAMES <- toupper(removed)
[16:59:37.006]                 for (kk in seq_along(NAMES)) {
[16:59:37.006]                   name <- removed[[kk]]
[16:59:37.006]                   NAME <- NAMES[[kk]]
[16:59:37.006]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.006]                     next
[16:59:37.006]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.006]                 }
[16:59:37.006]                 if (length(args) > 0) 
[16:59:37.006]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.006]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.006]             }
[16:59:37.006]             else {
[16:59:37.006]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.006]             }
[16:59:37.006]             {
[16:59:37.006]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.006]                   0L) {
[16:59:37.006]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.006]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.006]                   base::options(opts)
[16:59:37.006]                 }
[16:59:37.006]                 {
[16:59:37.006]                   {
[16:59:37.006]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.006]                     NULL
[16:59:37.006]                   }
[16:59:37.006]                   options(future.plan = NULL)
[16:59:37.006]                   if (is.na(NA_character_)) 
[16:59:37.006]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.006]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.006]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.006]                     .init = FALSE)
[16:59:37.006]                 }
[16:59:37.006]             }
[16:59:37.006]         }
[16:59:37.006]     })
[16:59:37.006]     if (TRUE) {
[16:59:37.006]         base::sink(type = "output", split = FALSE)
[16:59:37.006]         if (TRUE) {
[16:59:37.006]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.006]         }
[16:59:37.006]         else {
[16:59:37.006]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.006]         }
[16:59:37.006]         base::close(...future.stdout)
[16:59:37.006]         ...future.stdout <- NULL
[16:59:37.006]     }
[16:59:37.006]     ...future.result$conditions <- ...future.conditions
[16:59:37.006]     ...future.result$finished <- base::Sys.time()
[16:59:37.006]     ...future.result
[16:59:37.006] }
[16:59:37.009] Exporting 5 global objects (5.26 KiB) to cluster node #2 ...
[16:59:37.009] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ...
[16:59:37.009] Exporting ‘...future.FUN’ (5.20 KiB) to cluster node #2 ... DONE
[16:59:37.009] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ...
[16:59:37.010] Exporting ‘future.call.arguments’ (56 bytes) to cluster node #2 ... DONE
[16:59:37.010] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:59:37.010] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:59:37.010] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:37.011] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.011] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:37.011] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.011] Exporting 5 global objects (5.26 KiB) to cluster node #2 ... DONE
[16:59:37.012] MultisessionFuture started
[16:59:37.012] - Launch lazy future ... done
[16:59:37.012] run() for ‘MultisessionFuture’ ... done
[16:59:37.013] Created future:
[16:59:37.013] MultisessionFuture:
[16:59:37.013] Label: ‘future_by-2’
[16:59:37.013] Expression:
[16:59:37.013] {
[16:59:37.013]     do.call(function(...) {
[16:59:37.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.013]             on.exit(options(oopts), add = TRUE)
[16:59:37.013]         }
[16:59:37.013]         {
[16:59:37.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.013]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.013]             })
[16:59:37.013]         }
[16:59:37.013]     }, args = future.call.arguments)
[16:59:37.013] }
[16:59:37.013] Lazy evaluation: FALSE
[16:59:37.013] Asynchronous evaluation: TRUE
[16:59:37.013] Local evaluation: TRUE
[16:59:37.013] Environment: R_GlobalEnv
[16:59:37.013] Capture standard output: TRUE
[16:59:37.013] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.013] Globals: 5 objects totaling 8.46 KiB (function ‘...future.FUN’ of 5.20 KiB, DotDotDotList ‘future.call.arguments’ of 56 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.013] Packages: 1 packages (‘stats’)
[16:59:37.013] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.013] Resolved: FALSE
[16:59:37.013] Value: <not collected>
[16:59:37.013] Conditions captured: <none>
[16:59:37.013] Early signaling: FALSE
[16:59:37.013] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.013] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.025] Chunk #2 of 2 ... DONE
[16:59:37.025] Launching 2 futures (chunks) ... DONE
[16:59:37.025] Resolving 2 futures (chunks) ...
[16:59:37.025] resolve() on list ...
[16:59:37.025]  recursive: 0
[16:59:37.026]  length: 2
[16:59:37.026] 
[16:59:37.026] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.026] - Validating connection of MultisessionFuture
[16:59:37.027] - received message: FutureResult
[16:59:37.027] - Received FutureResult
[16:59:37.027] - Erased future from FutureRegistry
[16:59:37.027] result() for ClusterFuture ...
[16:59:37.027] - result already collected: FutureResult
[16:59:37.027] result() for ClusterFuture ... done
[16:59:37.027] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.027] Future #1
[16:59:37.027] result() for ClusterFuture ...
[16:59:37.027] - result already collected: FutureResult
[16:59:37.028] result() for ClusterFuture ... done
[16:59:37.028] result() for ClusterFuture ...
[16:59:37.028] - result already collected: FutureResult
[16:59:37.028] result() for ClusterFuture ... done
[16:59:37.028] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:37.028] - nx: 2
[16:59:37.028] - relay: TRUE
[16:59:37.028] - stdout: TRUE
[16:59:37.028] - signal: TRUE
[16:59:37.028] - resignal: FALSE
[16:59:37.028] - force: TRUE
[16:59:37.029] - relayed: [n=2] FALSE, FALSE
[16:59:37.029] - queued futures: [n=2] FALSE, FALSE
[16:59:37.029]  - until=1
[16:59:37.029]  - relaying element #1
[16:59:37.029] result() for ClusterFuture ...
[16:59:37.029] - result already collected: FutureResult
[16:59:37.029] result() for ClusterFuture ... done
[16:59:37.029] result() for ClusterFuture ...
[16:59:37.029] - result already collected: FutureResult
[16:59:37.029] result() for ClusterFuture ... done
[16:59:37.029] result() for ClusterFuture ...
[16:59:37.030] - result already collected: FutureResult
[16:59:37.030] result() for ClusterFuture ... done
[16:59:37.030] result() for ClusterFuture ...
[16:59:37.030] - result already collected: FutureResult
[16:59:37.030] result() for ClusterFuture ... done
[16:59:37.030] - relayed: [n=2] TRUE, FALSE
[16:59:37.030] - queued futures: [n=2] TRUE, FALSE
[16:59:37.030] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:37.030]  length: 1 (resolved future 1)
[16:59:37.061] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.061] - Validating connection of MultisessionFuture
[16:59:37.062] - received message: FutureResult
[16:59:37.062] - Received FutureResult
[16:59:37.062] - Erased future from FutureRegistry
[16:59:37.062] result() for ClusterFuture ...
[16:59:37.062] - result already collected: FutureResult
[16:59:37.062] result() for ClusterFuture ... done
[16:59:37.062] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.062] Future #2
[16:59:37.062] result() for ClusterFuture ...
[16:59:37.063] - result already collected: FutureResult
[16:59:37.063] result() for ClusterFuture ... done
[16:59:37.063] result() for ClusterFuture ...
[16:59:37.063] - result already collected: FutureResult
[16:59:37.063] result() for ClusterFuture ... done
[16:59:37.063] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:37.063] - nx: 2
[16:59:37.063] - relay: TRUE
[16:59:37.063] - stdout: TRUE
[16:59:37.063] - signal: TRUE
[16:59:37.063] - resignal: FALSE
[16:59:37.064] - force: TRUE
[16:59:37.064] - relayed: [n=2] TRUE, FALSE
[16:59:37.064] - queued futures: [n=2] TRUE, FALSE
[16:59:37.064]  - until=2
[16:59:37.064]  - relaying element #2
[16:59:37.064] result() for ClusterFuture ...
[16:59:37.064] - result already collected: FutureResult
[16:59:37.064] result() for ClusterFuture ... done
[16:59:37.064] result() for ClusterFuture ...
[16:59:37.064] - result already collected: FutureResult
[16:59:37.064] result() for ClusterFuture ... done
[16:59:37.065] result() for ClusterFuture ...
[16:59:37.065] - result already collected: FutureResult
[16:59:37.065] result() for ClusterFuture ... done
[16:59:37.065] result() for ClusterFuture ...
[16:59:37.065] - result already collected: FutureResult
[16:59:37.065] result() for ClusterFuture ... done
[16:59:37.065] - relayed: [n=2] TRUE, TRUE
[16:59:37.065] - queued futures: [n=2] TRUE, TRUE
[16:59:37.065] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:37.065]  length: 0 (resolved future 2)
[16:59:37.065] Relaying remaining futures
[16:59:37.065] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.066] - nx: 2
[16:59:37.066] - relay: TRUE
[16:59:37.066] - stdout: TRUE
[16:59:37.066] - signal: TRUE
[16:59:37.066] - resignal: FALSE
[16:59:37.066] - force: TRUE
[16:59:37.066] - relayed: [n=2] TRUE, TRUE
[16:59:37.066] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:37.066] - relayed: [n=2] TRUE, TRUE
[16:59:37.066] - queued futures: [n=2] TRUE, TRUE
[16:59:37.066] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.067] resolve() on list ... DONE
[16:59:37.067] result() for ClusterFuture ...
[16:59:37.067] - result already collected: FutureResult
[16:59:37.067] result() for ClusterFuture ... done
[16:59:37.067] result() for ClusterFuture ...
[16:59:37.067] - result already collected: FutureResult
[16:59:37.067] result() for ClusterFuture ... done
[16:59:37.067] result() for ClusterFuture ...
[16:59:37.067] - result already collected: FutureResult
[16:59:37.067] result() for ClusterFuture ... done
[16:59:37.067] result() for ClusterFuture ...
[16:59:37.067] - result already collected: FutureResult
[16:59:37.068] result() for ClusterFuture ... done
[16:59:37.068]  - Number of value chunks collected: 2
[16:59:37.068] Resolving 2 futures (chunks) ... DONE
[16:59:37.068] Reducing values from 2 chunks ...
[16:59:37.068]  - Number of values collected after concatenation: 3
[16:59:37.068]  - Number of values expected: 3
[16:59:37.068] Reducing values from 2 chunks ... DONE
[16:59:37.068] future_lapply() ... DONE
[16:59:37.068] future_by_internal() ... DONE
[16:59:37.072] future_by_internal() ...
[16:59:37.073] future_lapply() ...
[16:59:37.077] Number of chunks: 2
[16:59:37.077] getGlobalsAndPackagesXApply() ...
[16:59:37.077]  - future.globals: TRUE
[16:59:37.077] getGlobalsAndPackages() ...
[16:59:37.078] Searching for globals...
[16:59:37.079] - globals found: [6] ‘FUN’, ‘{’, ‘lm’, ‘~’, ‘breaks’, ‘wool’
[16:59:37.079] Searching for globals ... DONE
[16:59:37.079] Resolving globals: FALSE
[16:59:37.080] The total size of the 3 globals is 2.27 KiB (2320 bytes)
[16:59:37.080] The total size of the 3 globals exported for future expression (‘FUN()’) is 2.27 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘FUN’ (1.04 KiB of class ‘function’), ‘wool’ (776 bytes of class ‘numeric’) and ‘breaks’ (480 bytes of class ‘numeric’)
[16:59:37.081] - globals: [3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:37.081] - packages: [1] ‘stats’
[16:59:37.081] getGlobalsAndPackages() ... DONE
[16:59:37.081]  - globals found/used: [n=3] ‘FUN’, ‘breaks’, ‘wool’
[16:59:37.081]  - needed namespaces: [n=1] ‘stats’
[16:59:37.081] Finding globals ... DONE
[16:59:37.081]  - use_args: TRUE
[16:59:37.081]  - Getting '...' globals ...
[16:59:37.082] resolve() on list ...
[16:59:37.082]  recursive: 0
[16:59:37.082]  length: 1
[16:59:37.082]  elements: ‘...’
[16:59:37.082]  length: 0 (resolved future 1)
[16:59:37.082] resolve() on list ... DONE
[16:59:37.082]    - '...' content: [n=0] 
[16:59:37.082] List of 1
[16:59:37.082]  $ ...: list()
[16:59:37.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.082]  - attr(*, "where")=List of 1
[16:59:37.082]   ..$ ...:<environment: 0x562054155e30> 
[16:59:37.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.082]  - attr(*, "resolved")= logi TRUE
[16:59:37.082]  - attr(*, "total_size")= num NA
[16:59:37.085]  - Getting '...' globals ... DONE
[16:59:37.085] Globals to be used in all futures (chunks): [n=4] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’
[16:59:37.085] List of 4
[16:59:37.085]  $ ...future.FUN:function (x)  
[16:59:37.085]  $ breaks       : num [1:54] 26 30 54 25 70 52 51 26 67 18 ...
[16:59:37.085]  $ wool         : Factor w/ 2 levels "A","B": 1 1 1 1 1 1 1 1 1 1 ...
[16:59:37.085]  $ ...          : list()
[16:59:37.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.085]  - attr(*, "where")=List of 4
[16:59:37.085]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.085]   ..$ breaks       :<environment: R_EmptyEnv> 
[16:59:37.085]   ..$ wool         :<environment: R_EmptyEnv> 
[16:59:37.085]   ..$ ...          :<environment: 0x562054155e30> 
[16:59:37.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.085]  - attr(*, "resolved")= logi FALSE
[16:59:37.085]  - attr(*, "total_size")= num 2320
[16:59:37.089] Packages to be attached in all futures: [n=1] ‘stats’
[16:59:37.089] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.089] Number of futures (= number of chunks): 2
[16:59:37.089] Launching 2 futures (chunks) ...
[16:59:37.089] Chunk #1 of 2 ...
[16:59:37.089]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.090] getGlobalsAndPackages() ...
[16:59:37.090] Searching for globals...
[16:59:37.090] 
[16:59:37.090] Searching for globals ... DONE
[16:59:37.090] - globals: [0] <none>
[16:59:37.090] getGlobalsAndPackages() ... DONE
[16:59:37.090]    + additional globals found: [n=0] 
[16:59:37.090]    + additional namespaces needed: [n=0] 
[16:59:37.091]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.091]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:37.091]  - seeds: <none>
[16:59:37.091]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.091] getGlobalsAndPackages() ...
[16:59:37.091] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.091] Resolving globals: FALSE
[16:59:37.091] Tweak future expression to call with '...' arguments ...
[16:59:37.091] {
[16:59:37.091]     do.call(function(...) {
[16:59:37.091]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.091]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.091]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.091]             on.exit(options(oopts), add = TRUE)
[16:59:37.091]         }
[16:59:37.091]         {
[16:59:37.091]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.091]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.091]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.091]             })
[16:59:37.091]         }
[16:59:37.091]     }, args = future.call.arguments)
[16:59:37.091] }
[16:59:37.092] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.092] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.092] 
[16:59:37.092] getGlobalsAndPackages() ... DONE
[16:59:37.093] run() for ‘Future’ ...
[16:59:37.093] - state: ‘created’
[16:59:37.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.108]   - Field: ‘node’
[16:59:37.108]   - Field: ‘label’
[16:59:37.108]   - Field: ‘local’
[16:59:37.108]   - Field: ‘owner’
[16:59:37.108]   - Field: ‘envir’
[16:59:37.108]   - Field: ‘workers’
[16:59:37.108]   - Field: ‘packages’
[16:59:37.108]   - Field: ‘gc’
[16:59:37.109]   - Field: ‘conditions’
[16:59:37.109]   - Field: ‘persistent’
[16:59:37.109]   - Field: ‘expr’
[16:59:37.109]   - Field: ‘uuid’
[16:59:37.109]   - Field: ‘seed’
[16:59:37.109]   - Field: ‘version’
[16:59:37.109]   - Field: ‘result’
[16:59:37.109]   - Field: ‘asynchronous’
[16:59:37.109]   - Field: ‘calls’
[16:59:37.109]   - Field: ‘globals’
[16:59:37.109]   - Field: ‘stdout’
[16:59:37.110]   - Field: ‘earlySignal’
[16:59:37.110]   - Field: ‘lazy’
[16:59:37.110]   - Field: ‘state’
[16:59:37.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.110] - Launch lazy future ...
[16:59:37.110] Packages needed by the future expression (n = 1): ‘stats’
[16:59:37.110] Packages needed by future strategies (n = 0): <none>
[16:59:37.111] {
[16:59:37.111]     {
[16:59:37.111]         {
[16:59:37.111]             ...future.startTime <- base::Sys.time()
[16:59:37.111]             {
[16:59:37.111]                 {
[16:59:37.111]                   {
[16:59:37.111]                     {
[16:59:37.111]                       {
[16:59:37.111]                         base::local({
[16:59:37.111]                           has_future <- base::requireNamespace("future", 
[16:59:37.111]                             quietly = TRUE)
[16:59:37.111]                           if (has_future) {
[16:59:37.111]                             ns <- base::getNamespace("future")
[16:59:37.111]                             version <- ns[[".package"]][["version"]]
[16:59:37.111]                             if (is.null(version)) 
[16:59:37.111]                               version <- utils::packageVersion("future")
[16:59:37.111]                           }
[16:59:37.111]                           else {
[16:59:37.111]                             version <- NULL
[16:59:37.111]                           }
[16:59:37.111]                           if (!has_future || version < "1.8.0") {
[16:59:37.111]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.111]                               "", base::R.version$version.string), 
[16:59:37.111]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:37.111]                                 base::R.version$platform, 8 * 
[16:59:37.111]                                   base::.Machine$sizeof.pointer), 
[16:59:37.111]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.111]                                 "release", "version")], collapse = " "), 
[16:59:37.111]                               hostname = base::Sys.info()[["nodename"]])
[16:59:37.111]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.111]                               info)
[16:59:37.111]                             info <- base::paste(info, collapse = "; ")
[16:59:37.111]                             if (!has_future) {
[16:59:37.111]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.111]                                 info)
[16:59:37.111]                             }
[16:59:37.111]                             else {
[16:59:37.111]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.111]                                 info, version)
[16:59:37.111]                             }
[16:59:37.111]                             base::stop(msg)
[16:59:37.111]                           }
[16:59:37.111]                         })
[16:59:37.111]                       }
[16:59:37.111]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.111]                       base::options(mc.cores = 1L)
[16:59:37.111]                     }
[16:59:37.111]                     base::local({
[16:59:37.111]                       for (pkg in "stats") {
[16:59:37.111]                         base::loadNamespace(pkg)
[16:59:37.111]                         base::library(pkg, character.only = TRUE)
[16:59:37.111]                       }
[16:59:37.111]                     })
[16:59:37.111]                   }
[16:59:37.111]                   ...future.strategy.old <- future::plan("list")
[16:59:37.111]                   options(future.plan = NULL)
[16:59:37.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.111]                 }
[16:59:37.111]                 ...future.workdir <- getwd()
[16:59:37.111]             }
[16:59:37.111]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.111]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.111]         }
[16:59:37.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.111]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.111]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.111]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.111]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.111]             base::names(...future.oldOptions))
[16:59:37.111]     }
[16:59:37.111]     if (FALSE) {
[16:59:37.111]     }
[16:59:37.111]     else {
[16:59:37.111]         if (TRUE) {
[16:59:37.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.111]                 open = "w")
[16:59:37.111]         }
[16:59:37.111]         else {
[16:59:37.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.111]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.111]         }
[16:59:37.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.111]             base::sink(type = "output", split = FALSE)
[16:59:37.111]             base::close(...future.stdout)
[16:59:37.111]         }, add = TRUE)
[16:59:37.111]     }
[16:59:37.111]     ...future.frame <- base::sys.nframe()
[16:59:37.111]     ...future.conditions <- base::list()
[16:59:37.111]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.111]     if (FALSE) {
[16:59:37.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.111]     }
[16:59:37.111]     ...future.result <- base::tryCatch({
[16:59:37.111]         base::withCallingHandlers({
[16:59:37.111]             ...future.value <- base::withVisible(base::local({
[16:59:37.111]                 ...future.makeSendCondition <- base::local({
[16:59:37.111]                   sendCondition <- NULL
[16:59:37.111]                   function(frame = 1L) {
[16:59:37.111]                     if (is.function(sendCondition)) 
[16:59:37.111]                       return(sendCondition)
[16:59:37.111]                     ns <- getNamespace("parallel")
[16:59:37.111]                     if (exists("sendData", mode = "function", 
[16:59:37.111]                       envir = ns)) {
[16:59:37.111]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.111]                         envir = ns)
[16:59:37.111]                       envir <- sys.frame(frame)
[16:59:37.111]                       master <- NULL
[16:59:37.111]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.111]                         !identical(envir, emptyenv())) {
[16:59:37.111]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.111]                           inherits = FALSE)) {
[16:59:37.111]                           master <- get("master", mode = "list", 
[16:59:37.111]                             envir = envir, inherits = FALSE)
[16:59:37.111]                           if (inherits(master, c("SOCKnode", 
[16:59:37.111]                             "SOCK0node"))) {
[16:59:37.111]                             sendCondition <<- function(cond) {
[16:59:37.111]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.111]                                 success = TRUE)
[16:59:37.111]                               parallel_sendData(master, data)
[16:59:37.111]                             }
[16:59:37.111]                             return(sendCondition)
[16:59:37.111]                           }
[16:59:37.111]                         }
[16:59:37.111]                         frame <- frame + 1L
[16:59:37.111]                         envir <- sys.frame(frame)
[16:59:37.111]                       }
[16:59:37.111]                     }
[16:59:37.111]                     sendCondition <<- function(cond) NULL
[16:59:37.111]                   }
[16:59:37.111]                 })
[16:59:37.111]                 withCallingHandlers({
[16:59:37.111]                   {
[16:59:37.111]                     do.call(function(...) {
[16:59:37.111]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.111]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.111]                         ...future.globals.maxSize)) {
[16:59:37.111]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.111]                         on.exit(options(oopts), add = TRUE)
[16:59:37.111]                       }
[16:59:37.111]                       {
[16:59:37.111]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.111]                           FUN = function(jj) {
[16:59:37.111]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.111]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.111]                           })
[16:59:37.111]                       }
[16:59:37.111]                     }, args = future.call.arguments)
[16:59:37.111]                   }
[16:59:37.111]                 }, immediateCondition = function(cond) {
[16:59:37.111]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.111]                   sendCondition(cond)
[16:59:37.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.111]                   {
[16:59:37.111]                     inherits <- base::inherits
[16:59:37.111]                     invokeRestart <- base::invokeRestart
[16:59:37.111]                     is.null <- base::is.null
[16:59:37.111]                     muffled <- FALSE
[16:59:37.111]                     if (inherits(cond, "message")) {
[16:59:37.111]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.111]                       if (muffled) 
[16:59:37.111]                         invokeRestart("muffleMessage")
[16:59:37.111]                     }
[16:59:37.111]                     else if (inherits(cond, "warning")) {
[16:59:37.111]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.111]                       if (muffled) 
[16:59:37.111]                         invokeRestart("muffleWarning")
[16:59:37.111]                     }
[16:59:37.111]                     else if (inherits(cond, "condition")) {
[16:59:37.111]                       if (!is.null(pattern)) {
[16:59:37.111]                         computeRestarts <- base::computeRestarts
[16:59:37.111]                         grepl <- base::grepl
[16:59:37.111]                         restarts <- computeRestarts(cond)
[16:59:37.111]                         for (restart in restarts) {
[16:59:37.111]                           name <- restart$name
[16:59:37.111]                           if (is.null(name)) 
[16:59:37.111]                             next
[16:59:37.111]                           if (!grepl(pattern, name)) 
[16:59:37.111]                             next
[16:59:37.111]                           invokeRestart(restart)
[16:59:37.111]                           muffled <- TRUE
[16:59:37.111]                           break
[16:59:37.111]                         }
[16:59:37.111]                       }
[16:59:37.111]                     }
[16:59:37.111]                     invisible(muffled)
[16:59:37.111]                   }
[16:59:37.111]                   muffleCondition(cond)
[16:59:37.111]                 })
[16:59:37.111]             }))
[16:59:37.111]             future::FutureResult(value = ...future.value$value, 
[16:59:37.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.111]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.111]                     ...future.globalenv.names))
[16:59:37.111]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.111]         }, condition = base::local({
[16:59:37.111]             c <- base::c
[16:59:37.111]             inherits <- base::inherits
[16:59:37.111]             invokeRestart <- base::invokeRestart
[16:59:37.111]             length <- base::length
[16:59:37.111]             list <- base::list
[16:59:37.111]             seq.int <- base::seq.int
[16:59:37.111]             signalCondition <- base::signalCondition
[16:59:37.111]             sys.calls <- base::sys.calls
[16:59:37.111]             `[[` <- base::`[[`
[16:59:37.111]             `+` <- base::`+`
[16:59:37.111]             `<<-` <- base::`<<-`
[16:59:37.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.111]                   3L)]
[16:59:37.111]             }
[16:59:37.111]             function(cond) {
[16:59:37.111]                 is_error <- inherits(cond, "error")
[16:59:37.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.111]                   NULL)
[16:59:37.111]                 if (is_error) {
[16:59:37.111]                   sessionInformation <- function() {
[16:59:37.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.111]                       search = base::search(), system = base::Sys.info())
[16:59:37.111]                   }
[16:59:37.111]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.111]                     cond$call), session = sessionInformation(), 
[16:59:37.111]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.111]                   signalCondition(cond)
[16:59:37.111]                 }
[16:59:37.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.111]                 "immediateCondition"))) {
[16:59:37.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.111]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.111]                   if (TRUE && !signal) {
[16:59:37.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.111]                     {
[16:59:37.111]                       inherits <- base::inherits
[16:59:37.111]                       invokeRestart <- base::invokeRestart
[16:59:37.111]                       is.null <- base::is.null
[16:59:37.111]                       muffled <- FALSE
[16:59:37.111]                       if (inherits(cond, "message")) {
[16:59:37.111]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.111]                         if (muffled) 
[16:59:37.111]                           invokeRestart("muffleMessage")
[16:59:37.111]                       }
[16:59:37.111]                       else if (inherits(cond, "warning")) {
[16:59:37.111]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.111]                         if (muffled) 
[16:59:37.111]                           invokeRestart("muffleWarning")
[16:59:37.111]                       }
[16:59:37.111]                       else if (inherits(cond, "condition")) {
[16:59:37.111]                         if (!is.null(pattern)) {
[16:59:37.111]                           computeRestarts <- base::computeRestarts
[16:59:37.111]                           grepl <- base::grepl
[16:59:37.111]                           restarts <- computeRestarts(cond)
[16:59:37.111]                           for (restart in restarts) {
[16:59:37.111]                             name <- restart$name
[16:59:37.111]                             if (is.null(name)) 
[16:59:37.111]                               next
[16:59:37.111]                             if (!grepl(pattern, name)) 
[16:59:37.111]                               next
[16:59:37.111]                             invokeRestart(restart)
[16:59:37.111]                             muffled <- TRUE
[16:59:37.111]                             break
[16:59:37.111]                           }
[16:59:37.111]                         }
[16:59:37.111]                       }
[16:59:37.111]                       invisible(muffled)
[16:59:37.111]                     }
[16:59:37.111]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.111]                   }
[16:59:37.111]                 }
[16:59:37.111]                 else {
[16:59:37.111]                   if (TRUE) {
[16:59:37.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.111]                     {
[16:59:37.111]                       inherits <- base::inherits
[16:59:37.111]                       invokeRestart <- base::invokeRestart
[16:59:37.111]                       is.null <- base::is.null
[16:59:37.111]                       muffled <- FALSE
[16:59:37.111]                       if (inherits(cond, "message")) {
[16:59:37.111]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.111]                         if (muffled) 
[16:59:37.111]                           invokeRestart("muffleMessage")
[16:59:37.111]                       }
[16:59:37.111]                       else if (inherits(cond, "warning")) {
[16:59:37.111]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.111]                         if (muffled) 
[16:59:37.111]                           invokeRestart("muffleWarning")
[16:59:37.111]                       }
[16:59:37.111]                       else if (inherits(cond, "condition")) {
[16:59:37.111]                         if (!is.null(pattern)) {
[16:59:37.111]                           computeRestarts <- base::computeRestarts
[16:59:37.111]                           grepl <- base::grepl
[16:59:37.111]                           restarts <- computeRestarts(cond)
[16:59:37.111]                           for (restart in restarts) {
[16:59:37.111]                             name <- restart$name
[16:59:37.111]                             if (is.null(name)) 
[16:59:37.111]                               next
[16:59:37.111]                             if (!grepl(pattern, name)) 
[16:59:37.111]                               next
[16:59:37.111]                             invokeRestart(restart)
[16:59:37.111]                             muffled <- TRUE
[16:59:37.111]                             break
[16:59:37.111]                           }
[16:59:37.111]                         }
[16:59:37.111]                       }
[16:59:37.111]                       invisible(muffled)
[16:59:37.111]                     }
[16:59:37.111]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.111]                   }
[16:59:37.111]                 }
[16:59:37.111]             }
[16:59:37.111]         }))
[16:59:37.111]     }, error = function(ex) {
[16:59:37.111]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.111]                 ...future.rng), started = ...future.startTime, 
[16:59:37.111]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.111]             version = "1.8"), class = "FutureResult")
[16:59:37.111]     }, finally = {
[16:59:37.111]         if (!identical(...future.workdir, getwd())) 
[16:59:37.111]             setwd(...future.workdir)
[16:59:37.111]         {
[16:59:37.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.111]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.111]             }
[16:59:37.111]             base::options(...future.oldOptions)
[16:59:37.111]             if (.Platform$OS.type == "windows") {
[16:59:37.111]                 old_names <- names(...future.oldEnvVars)
[16:59:37.111]                 envs <- base::Sys.getenv()
[16:59:37.111]                 names <- names(envs)
[16:59:37.111]                 common <- intersect(names, old_names)
[16:59:37.111]                 added <- setdiff(names, old_names)
[16:59:37.111]                 removed <- setdiff(old_names, names)
[16:59:37.111]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.111]                   envs[common]]
[16:59:37.111]                 NAMES <- toupper(changed)
[16:59:37.111]                 args <- list()
[16:59:37.111]                 for (kk in seq_along(NAMES)) {
[16:59:37.111]                   name <- changed[[kk]]
[16:59:37.111]                   NAME <- NAMES[[kk]]
[16:59:37.111]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.111]                     next
[16:59:37.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.111]                 }
[16:59:37.111]                 NAMES <- toupper(added)
[16:59:37.111]                 for (kk in seq_along(NAMES)) {
[16:59:37.111]                   name <- added[[kk]]
[16:59:37.111]                   NAME <- NAMES[[kk]]
[16:59:37.111]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.111]                     next
[16:59:37.111]                   args[[name]] <- ""
[16:59:37.111]                 }
[16:59:37.111]                 NAMES <- toupper(removed)
[16:59:37.111]                 for (kk in seq_along(NAMES)) {
[16:59:37.111]                   name <- removed[[kk]]
[16:59:37.111]                   NAME <- NAMES[[kk]]
[16:59:37.111]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.111]                     next
[16:59:37.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.111]                 }
[16:59:37.111]                 if (length(args) > 0) 
[16:59:37.111]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.111]             }
[16:59:37.111]             else {
[16:59:37.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.111]             }
[16:59:37.111]             {
[16:59:37.111]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.111]                   0L) {
[16:59:37.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.111]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.111]                   base::options(opts)
[16:59:37.111]                 }
[16:59:37.111]                 {
[16:59:37.111]                   {
[16:59:37.111]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.111]                     NULL
[16:59:37.111]                   }
[16:59:37.111]                   options(future.plan = NULL)
[16:59:37.111]                   if (is.na(NA_character_)) 
[16:59:37.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.111]                     .init = FALSE)
[16:59:37.111]                 }
[16:59:37.111]             }
[16:59:37.111]         }
[16:59:37.111]     })
[16:59:37.111]     if (TRUE) {
[16:59:37.111]         base::sink(type = "output", split = FALSE)
[16:59:37.111]         if (TRUE) {
[16:59:37.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.111]         }
[16:59:37.111]         else {
[16:59:37.111]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.111]         }
[16:59:37.111]         base::close(...future.stdout)
[16:59:37.111]         ...future.stdout <- NULL
[16:59:37.111]     }
[16:59:37.111]     ...future.result$conditions <- ...future.conditions
[16:59:37.111]     ...future.result$finished <- base::Sys.time()
[16:59:37.111]     ...future.result
[16:59:37.111] }
[16:59:37.114] Exporting 7 global objects (2.27 KiB) to cluster node #1 ...
[16:59:37.114] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[16:59:37.114] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[16:59:37.114] Exporting ‘breaks’ (480 bytes) to cluster node #1 ...
[16:59:37.115] Exporting ‘breaks’ (480 bytes) to cluster node #1 ... DONE
[16:59:37.115] Exporting ‘wool’ (776 bytes) to cluster node #1 ...
[16:59:37.115] Exporting ‘wool’ (776 bytes) to cluster node #1 ... DONE
[16:59:37.115] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:37.116] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.116] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:59:37.116] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:59:37.116] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:37.117] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.117] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:37.117] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.117] Exporting 7 global objects (2.27 KiB) to cluster node #1 ... DONE
[16:59:37.118] MultisessionFuture started
[16:59:37.118] - Launch lazy future ... done
[16:59:37.118] run() for ‘MultisessionFuture’ ... done
[16:59:37.118] Created future:
[16:59:37.118] MultisessionFuture:
[16:59:37.118] Label: ‘future_by-1’
[16:59:37.118] Expression:
[16:59:37.118] {
[16:59:37.118]     do.call(function(...) {
[16:59:37.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.118]             on.exit(options(oopts), add = TRUE)
[16:59:37.118]         }
[16:59:37.118]         {
[16:59:37.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.118]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.118]             })
[16:59:37.118]         }
[16:59:37.118]     }, args = future.call.arguments)
[16:59:37.118] }
[16:59:37.118] Lazy evaluation: FALSE
[16:59:37.118] Asynchronous evaluation: TRUE
[16:59:37.118] Local evaluation: TRUE
[16:59:37.118] Environment: 0x56205412c578
[16:59:37.118] Capture standard output: TRUE
[16:59:37.118] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.118] Globals: 7 objects totaling 3.87 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, ...)
[16:59:37.118] Packages: 1 packages (‘stats’)
[16:59:37.118] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.118] Resolved: FALSE
[16:59:37.118] Value: <not collected>
[16:59:37.118] Conditions captured: <none>
[16:59:37.118] Early signaling: FALSE
[16:59:37.118] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.118] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.130] Chunk #1 of 2 ... DONE
[16:59:37.130] Chunk #2 of 2 ...
[16:59:37.130]  - Finding globals in 'X' for chunk #2 ...
[16:59:37.130] getGlobalsAndPackages() ...
[16:59:37.130] Searching for globals...
[16:59:37.131] 
[16:59:37.131] Searching for globals ... DONE
[16:59:37.131] - globals: [0] <none>
[16:59:37.131] getGlobalsAndPackages() ... DONE
[16:59:37.131]    + additional globals found: [n=0] 
[16:59:37.131]    + additional namespaces needed: [n=0] 
[16:59:37.131]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:37.132]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:37.132]  - seeds: <none>
[16:59:37.132]  - All globals exported: [n=7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.132] getGlobalsAndPackages() ...
[16:59:37.132] - globals passed as-is: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.132] Resolving globals: FALSE
[16:59:37.132] Tweak future expression to call with '...' arguments ...
[16:59:37.132] {
[16:59:37.132]     do.call(function(...) {
[16:59:37.132]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.132]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.132]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.132]             on.exit(options(oopts), add = TRUE)
[16:59:37.132]         }
[16:59:37.132]         {
[16:59:37.132]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.132]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.132]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.132]             })
[16:59:37.132]         }
[16:59:37.132]     }, args = future.call.arguments)
[16:59:37.132] }
[16:59:37.133] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.133] - globals: [7] ‘...future.FUN’, ‘breaks’, ‘wool’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.133] 
[16:59:37.133] getGlobalsAndPackages() ... DONE
[16:59:37.134] run() for ‘Future’ ...
[16:59:37.134] - state: ‘created’
[16:59:37.134] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.149] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.149] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.149]   - Field: ‘node’
[16:59:37.149]   - Field: ‘label’
[16:59:37.149]   - Field: ‘local’
[16:59:37.149]   - Field: ‘owner’
[16:59:37.149]   - Field: ‘envir’
[16:59:37.149]   - Field: ‘workers’
[16:59:37.150]   - Field: ‘packages’
[16:59:37.150]   - Field: ‘gc’
[16:59:37.150]   - Field: ‘conditions’
[16:59:37.150]   - Field: ‘persistent’
[16:59:37.150]   - Field: ‘expr’
[16:59:37.150]   - Field: ‘uuid’
[16:59:37.150]   - Field: ‘seed’
[16:59:37.150]   - Field: ‘version’
[16:59:37.150]   - Field: ‘result’
[16:59:37.152]   - Field: ‘asynchronous’
[16:59:37.153]   - Field: ‘calls’
[16:59:37.153]   - Field: ‘globals’
[16:59:37.153]   - Field: ‘stdout’
[16:59:37.153]   - Field: ‘earlySignal’
[16:59:37.153]   - Field: ‘lazy’
[16:59:37.153]   - Field: ‘state’
[16:59:37.153] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.153] - Launch lazy future ...
[16:59:37.154] Packages needed by the future expression (n = 1): ‘stats’
[16:59:37.154] Packages needed by future strategies (n = 0): <none>
[16:59:37.154] {
[16:59:37.154]     {
[16:59:37.154]         {
[16:59:37.154]             ...future.startTime <- base::Sys.time()
[16:59:37.154]             {
[16:59:37.154]                 {
[16:59:37.154]                   {
[16:59:37.154]                     {
[16:59:37.154]                       {
[16:59:37.154]                         base::local({
[16:59:37.154]                           has_future <- base::requireNamespace("future", 
[16:59:37.154]                             quietly = TRUE)
[16:59:37.154]                           if (has_future) {
[16:59:37.154]                             ns <- base::getNamespace("future")
[16:59:37.154]                             version <- ns[[".package"]][["version"]]
[16:59:37.154]                             if (is.null(version)) 
[16:59:37.154]                               version <- utils::packageVersion("future")
[16:59:37.154]                           }
[16:59:37.154]                           else {
[16:59:37.154]                             version <- NULL
[16:59:37.154]                           }
[16:59:37.154]                           if (!has_future || version < "1.8.0") {
[16:59:37.154]                             info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.154]                               "", base::R.version$version.string), 
[16:59:37.154]                               platform = base::sprintf("%s (%s-bit)", 
[16:59:37.154]                                 base::R.version$platform, 8 * 
[16:59:37.154]                                   base::.Machine$sizeof.pointer), 
[16:59:37.154]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.154]                                 "release", "version")], collapse = " "), 
[16:59:37.154]                               hostname = base::Sys.info()[["nodename"]])
[16:59:37.154]                             info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.154]                               info)
[16:59:37.154]                             info <- base::paste(info, collapse = "; ")
[16:59:37.154]                             if (!has_future) {
[16:59:37.154]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.154]                                 info)
[16:59:37.154]                             }
[16:59:37.154]                             else {
[16:59:37.154]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.154]                                 info, version)
[16:59:37.154]                             }
[16:59:37.154]                             base::stop(msg)
[16:59:37.154]                           }
[16:59:37.154]                         })
[16:59:37.154]                       }
[16:59:37.154]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.154]                       base::options(mc.cores = 1L)
[16:59:37.154]                     }
[16:59:37.154]                     base::local({
[16:59:37.154]                       for (pkg in "stats") {
[16:59:37.154]                         base::loadNamespace(pkg)
[16:59:37.154]                         base::library(pkg, character.only = TRUE)
[16:59:37.154]                       }
[16:59:37.154]                     })
[16:59:37.154]                   }
[16:59:37.154]                   ...future.strategy.old <- future::plan("list")
[16:59:37.154]                   options(future.plan = NULL)
[16:59:37.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.154]                 }
[16:59:37.154]                 ...future.workdir <- getwd()
[16:59:37.154]             }
[16:59:37.154]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.154]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.154]         }
[16:59:37.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.154]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.154]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.154]             base::names(...future.oldOptions))
[16:59:37.154]     }
[16:59:37.154]     if (FALSE) {
[16:59:37.154]     }
[16:59:37.154]     else {
[16:59:37.154]         if (TRUE) {
[16:59:37.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.154]                 open = "w")
[16:59:37.154]         }
[16:59:37.154]         else {
[16:59:37.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.154]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.154]         }
[16:59:37.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.154]             base::sink(type = "output", split = FALSE)
[16:59:37.154]             base::close(...future.stdout)
[16:59:37.154]         }, add = TRUE)
[16:59:37.154]     }
[16:59:37.154]     ...future.frame <- base::sys.nframe()
[16:59:37.154]     ...future.conditions <- base::list()
[16:59:37.154]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.154]     if (FALSE) {
[16:59:37.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.154]     }
[16:59:37.154]     ...future.result <- base::tryCatch({
[16:59:37.154]         base::withCallingHandlers({
[16:59:37.154]             ...future.value <- base::withVisible(base::local({
[16:59:37.154]                 ...future.makeSendCondition <- base::local({
[16:59:37.154]                   sendCondition <- NULL
[16:59:37.154]                   function(frame = 1L) {
[16:59:37.154]                     if (is.function(sendCondition)) 
[16:59:37.154]                       return(sendCondition)
[16:59:37.154]                     ns <- getNamespace("parallel")
[16:59:37.154]                     if (exists("sendData", mode = "function", 
[16:59:37.154]                       envir = ns)) {
[16:59:37.154]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.154]                         envir = ns)
[16:59:37.154]                       envir <- sys.frame(frame)
[16:59:37.154]                       master <- NULL
[16:59:37.154]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.154]                         !identical(envir, emptyenv())) {
[16:59:37.154]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.154]                           inherits = FALSE)) {
[16:59:37.154]                           master <- get("master", mode = "list", 
[16:59:37.154]                             envir = envir, inherits = FALSE)
[16:59:37.154]                           if (inherits(master, c("SOCKnode", 
[16:59:37.154]                             "SOCK0node"))) {
[16:59:37.154]                             sendCondition <<- function(cond) {
[16:59:37.154]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.154]                                 success = TRUE)
[16:59:37.154]                               parallel_sendData(master, data)
[16:59:37.154]                             }
[16:59:37.154]                             return(sendCondition)
[16:59:37.154]                           }
[16:59:37.154]                         }
[16:59:37.154]                         frame <- frame + 1L
[16:59:37.154]                         envir <- sys.frame(frame)
[16:59:37.154]                       }
[16:59:37.154]                     }
[16:59:37.154]                     sendCondition <<- function(cond) NULL
[16:59:37.154]                   }
[16:59:37.154]                 })
[16:59:37.154]                 withCallingHandlers({
[16:59:37.154]                   {
[16:59:37.154]                     do.call(function(...) {
[16:59:37.154]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.154]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.154]                         ...future.globals.maxSize)) {
[16:59:37.154]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.154]                         on.exit(options(oopts), add = TRUE)
[16:59:37.154]                       }
[16:59:37.154]                       {
[16:59:37.154]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.154]                           FUN = function(jj) {
[16:59:37.154]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.154]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.154]                           })
[16:59:37.154]                       }
[16:59:37.154]                     }, args = future.call.arguments)
[16:59:37.154]                   }
[16:59:37.154]                 }, immediateCondition = function(cond) {
[16:59:37.154]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.154]                   sendCondition(cond)
[16:59:37.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.154]                   {
[16:59:37.154]                     inherits <- base::inherits
[16:59:37.154]                     invokeRestart <- base::invokeRestart
[16:59:37.154]                     is.null <- base::is.null
[16:59:37.154]                     muffled <- FALSE
[16:59:37.154]                     if (inherits(cond, "message")) {
[16:59:37.154]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.154]                       if (muffled) 
[16:59:37.154]                         invokeRestart("muffleMessage")
[16:59:37.154]                     }
[16:59:37.154]                     else if (inherits(cond, "warning")) {
[16:59:37.154]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.154]                       if (muffled) 
[16:59:37.154]                         invokeRestart("muffleWarning")
[16:59:37.154]                     }
[16:59:37.154]                     else if (inherits(cond, "condition")) {
[16:59:37.154]                       if (!is.null(pattern)) {
[16:59:37.154]                         computeRestarts <- base::computeRestarts
[16:59:37.154]                         grepl <- base::grepl
[16:59:37.154]                         restarts <- computeRestarts(cond)
[16:59:37.154]                         for (restart in restarts) {
[16:59:37.154]                           name <- restart$name
[16:59:37.154]                           if (is.null(name)) 
[16:59:37.154]                             next
[16:59:37.154]                           if (!grepl(pattern, name)) 
[16:59:37.154]                             next
[16:59:37.154]                           invokeRestart(restart)
[16:59:37.154]                           muffled <- TRUE
[16:59:37.154]                           break
[16:59:37.154]                         }
[16:59:37.154]                       }
[16:59:37.154]                     }
[16:59:37.154]                     invisible(muffled)
[16:59:37.154]                   }
[16:59:37.154]                   muffleCondition(cond)
[16:59:37.154]                 })
[16:59:37.154]             }))
[16:59:37.154]             future::FutureResult(value = ...future.value$value, 
[16:59:37.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.154]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.154]                     ...future.globalenv.names))
[16:59:37.154]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.154]         }, condition = base::local({
[16:59:37.154]             c <- base::c
[16:59:37.154]             inherits <- base::inherits
[16:59:37.154]             invokeRestart <- base::invokeRestart
[16:59:37.154]             length <- base::length
[16:59:37.154]             list <- base::list
[16:59:37.154]             seq.int <- base::seq.int
[16:59:37.154]             signalCondition <- base::signalCondition
[16:59:37.154]             sys.calls <- base::sys.calls
[16:59:37.154]             `[[` <- base::`[[`
[16:59:37.154]             `+` <- base::`+`
[16:59:37.154]             `<<-` <- base::`<<-`
[16:59:37.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.154]                   3L)]
[16:59:37.154]             }
[16:59:37.154]             function(cond) {
[16:59:37.154]                 is_error <- inherits(cond, "error")
[16:59:37.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.154]                   NULL)
[16:59:37.154]                 if (is_error) {
[16:59:37.154]                   sessionInformation <- function() {
[16:59:37.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.154]                       search = base::search(), system = base::Sys.info())
[16:59:37.154]                   }
[16:59:37.154]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.154]                     cond$call), session = sessionInformation(), 
[16:59:37.154]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.154]                   signalCondition(cond)
[16:59:37.154]                 }
[16:59:37.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.154]                 "immediateCondition"))) {
[16:59:37.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.154]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.154]                   if (TRUE && !signal) {
[16:59:37.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.154]                     {
[16:59:37.154]                       inherits <- base::inherits
[16:59:37.154]                       invokeRestart <- base::invokeRestart
[16:59:37.154]                       is.null <- base::is.null
[16:59:37.154]                       muffled <- FALSE
[16:59:37.154]                       if (inherits(cond, "message")) {
[16:59:37.154]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.154]                         if (muffled) 
[16:59:37.154]                           invokeRestart("muffleMessage")
[16:59:37.154]                       }
[16:59:37.154]                       else if (inherits(cond, "warning")) {
[16:59:37.154]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.154]                         if (muffled) 
[16:59:37.154]                           invokeRestart("muffleWarning")
[16:59:37.154]                       }
[16:59:37.154]                       else if (inherits(cond, "condition")) {
[16:59:37.154]                         if (!is.null(pattern)) {
[16:59:37.154]                           computeRestarts <- base::computeRestarts
[16:59:37.154]                           grepl <- base::grepl
[16:59:37.154]                           restarts <- computeRestarts(cond)
[16:59:37.154]                           for (restart in restarts) {
[16:59:37.154]                             name <- restart$name
[16:59:37.154]                             if (is.null(name)) 
[16:59:37.154]                               next
[16:59:37.154]                             if (!grepl(pattern, name)) 
[16:59:37.154]                               next
[16:59:37.154]                             invokeRestart(restart)
[16:59:37.154]                             muffled <- TRUE
[16:59:37.154]                             break
[16:59:37.154]                           }
[16:59:37.154]                         }
[16:59:37.154]                       }
[16:59:37.154]                       invisible(muffled)
[16:59:37.154]                     }
[16:59:37.154]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.154]                   }
[16:59:37.154]                 }
[16:59:37.154]                 else {
[16:59:37.154]                   if (TRUE) {
[16:59:37.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.154]                     {
[16:59:37.154]                       inherits <- base::inherits
[16:59:37.154]                       invokeRestart <- base::invokeRestart
[16:59:37.154]                       is.null <- base::is.null
[16:59:37.154]                       muffled <- FALSE
[16:59:37.154]                       if (inherits(cond, "message")) {
[16:59:37.154]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.154]                         if (muffled) 
[16:59:37.154]                           invokeRestart("muffleMessage")
[16:59:37.154]                       }
[16:59:37.154]                       else if (inherits(cond, "warning")) {
[16:59:37.154]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.154]                         if (muffled) 
[16:59:37.154]                           invokeRestart("muffleWarning")
[16:59:37.154]                       }
[16:59:37.154]                       else if (inherits(cond, "condition")) {
[16:59:37.154]                         if (!is.null(pattern)) {
[16:59:37.154]                           computeRestarts <- base::computeRestarts
[16:59:37.154]                           grepl <- base::grepl
[16:59:37.154]                           restarts <- computeRestarts(cond)
[16:59:37.154]                           for (restart in restarts) {
[16:59:37.154]                             name <- restart$name
[16:59:37.154]                             if (is.null(name)) 
[16:59:37.154]                               next
[16:59:37.154]                             if (!grepl(pattern, name)) 
[16:59:37.154]                               next
[16:59:37.154]                             invokeRestart(restart)
[16:59:37.154]                             muffled <- TRUE
[16:59:37.154]                             break
[16:59:37.154]                           }
[16:59:37.154]                         }
[16:59:37.154]                       }
[16:59:37.154]                       invisible(muffled)
[16:59:37.154]                     }
[16:59:37.154]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.154]                   }
[16:59:37.154]                 }
[16:59:37.154]             }
[16:59:37.154]         }))
[16:59:37.154]     }, error = function(ex) {
[16:59:37.154]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.154]                 ...future.rng), started = ...future.startTime, 
[16:59:37.154]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.154]             version = "1.8"), class = "FutureResult")
[16:59:37.154]     }, finally = {
[16:59:37.154]         if (!identical(...future.workdir, getwd())) 
[16:59:37.154]             setwd(...future.workdir)
[16:59:37.154]         {
[16:59:37.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.154]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.154]             }
[16:59:37.154]             base::options(...future.oldOptions)
[16:59:37.154]             if (.Platform$OS.type == "windows") {
[16:59:37.154]                 old_names <- names(...future.oldEnvVars)
[16:59:37.154]                 envs <- base::Sys.getenv()
[16:59:37.154]                 names <- names(envs)
[16:59:37.154]                 common <- intersect(names, old_names)
[16:59:37.154]                 added <- setdiff(names, old_names)
[16:59:37.154]                 removed <- setdiff(old_names, names)
[16:59:37.154]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.154]                   envs[common]]
[16:59:37.154]                 NAMES <- toupper(changed)
[16:59:37.154]                 args <- list()
[16:59:37.154]                 for (kk in seq_along(NAMES)) {
[16:59:37.154]                   name <- changed[[kk]]
[16:59:37.154]                   NAME <- NAMES[[kk]]
[16:59:37.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.154]                     next
[16:59:37.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.154]                 }
[16:59:37.154]                 NAMES <- toupper(added)
[16:59:37.154]                 for (kk in seq_along(NAMES)) {
[16:59:37.154]                   name <- added[[kk]]
[16:59:37.154]                   NAME <- NAMES[[kk]]
[16:59:37.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.154]                     next
[16:59:37.154]                   args[[name]] <- ""
[16:59:37.154]                 }
[16:59:37.154]                 NAMES <- toupper(removed)
[16:59:37.154]                 for (kk in seq_along(NAMES)) {
[16:59:37.154]                   name <- removed[[kk]]
[16:59:37.154]                   NAME <- NAMES[[kk]]
[16:59:37.154]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.154]                     next
[16:59:37.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.154]                 }
[16:59:37.154]                 if (length(args) > 0) 
[16:59:37.154]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.154]             }
[16:59:37.154]             else {
[16:59:37.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.154]             }
[16:59:37.154]             {
[16:59:37.154]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.154]                   0L) {
[16:59:37.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.154]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.154]                   base::options(opts)
[16:59:37.154]                 }
[16:59:37.154]                 {
[16:59:37.154]                   {
[16:59:37.154]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.154]                     NULL
[16:59:37.154]                   }
[16:59:37.154]                   options(future.plan = NULL)
[16:59:37.154]                   if (is.na(NA_character_)) 
[16:59:37.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.154]                     .init = FALSE)
[16:59:37.154]                 }
[16:59:37.154]             }
[16:59:37.154]         }
[16:59:37.154]     })
[16:59:37.154]     if (TRUE) {
[16:59:37.154]         base::sink(type = "output", split = FALSE)
[16:59:37.154]         if (TRUE) {
[16:59:37.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.154]         }
[16:59:37.154]         else {
[16:59:37.154]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.154]         }
[16:59:37.154]         base::close(...future.stdout)
[16:59:37.154]         ...future.stdout <- NULL
[16:59:37.154]     }
[16:59:37.154]     ...future.result$conditions <- ...future.conditions
[16:59:37.154]     ...future.result$finished <- base::Sys.time()
[16:59:37.154]     ...future.result
[16:59:37.154] }
[16:59:37.157] Exporting 7 global objects (2.27 KiB) to cluster node #2 ...
[16:59:37.157] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[16:59:37.157] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[16:59:37.158] Exporting ‘breaks’ (480 bytes) to cluster node #2 ...
[16:59:37.158] Exporting ‘breaks’ (480 bytes) to cluster node #2 ... DONE
[16:59:37.158] Exporting ‘wool’ (776 bytes) to cluster node #2 ...
[16:59:37.158] Exporting ‘wool’ (776 bytes) to cluster node #2 ... DONE
[16:59:37.159] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:37.159] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.159] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:59:37.159] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:59:37.160] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:37.160] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.160] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:37.160] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.160] Exporting 7 global objects (2.27 KiB) to cluster node #2 ... DONE
[16:59:37.161] MultisessionFuture started
[16:59:37.161] - Launch lazy future ... done
[16:59:37.161] run() for ‘MultisessionFuture’ ... done
[16:59:37.161] Created future:
[16:59:37.161] MultisessionFuture:
[16:59:37.161] Label: ‘future_by-2’
[16:59:37.161] Expression:
[16:59:37.161] {
[16:59:37.161]     do.call(function(...) {
[16:59:37.161]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.161]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.161]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.161]             on.exit(options(oopts), add = TRUE)
[16:59:37.161]         }
[16:59:37.161]         {
[16:59:37.161]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.161]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.161]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.161]             })
[16:59:37.161]         }
[16:59:37.161]     }, args = future.call.arguments)
[16:59:37.161] }
[16:59:37.161] Lazy evaluation: FALSE
[16:59:37.161] Asynchronous evaluation: TRUE
[16:59:37.161] Local evaluation: TRUE
[16:59:37.161] Environment: 0x56205412c578
[16:59:37.161] Capture standard output: TRUE
[16:59:37.161] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.161] Globals: 7 objects totaling 5.47 KiB (function ‘...future.FUN’ of 1.04 KiB, numeric ‘breaks’ of 480 bytes, factor ‘wool’ of 776 bytes, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, ...)
[16:59:37.161] Packages: 1 packages (‘stats’)
[16:59:37.161] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.161] Resolved: FALSE
[16:59:37.161] Value: <not collected>
[16:59:37.161] Conditions captured: <none>
[16:59:37.161] Early signaling: FALSE
[16:59:37.161] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.161] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.173] Chunk #2 of 2 ... DONE
[16:59:37.173] Launching 2 futures (chunks) ... DONE
[16:59:37.173] Resolving 2 futures (chunks) ...
[16:59:37.173] resolve() on list ...
[16:59:37.173]  recursive: 0
[16:59:37.174]  length: 2
[16:59:37.174] 
[16:59:37.174] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.174] - Validating connection of MultisessionFuture
[16:59:37.174] - received message: FutureResult
[16:59:37.175] - Received FutureResult
[16:59:37.175] - Erased future from FutureRegistry
[16:59:37.175] result() for ClusterFuture ...
[16:59:37.175] - result already collected: FutureResult
[16:59:37.175] result() for ClusterFuture ... done
[16:59:37.175] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.175] Future #1
[16:59:37.175] result() for ClusterFuture ...
[16:59:37.175] - result already collected: FutureResult
[16:59:37.175] result() for ClusterFuture ... done
[16:59:37.176] result() for ClusterFuture ...
[16:59:37.176] - result already collected: FutureResult
[16:59:37.176] result() for ClusterFuture ... done
[16:59:37.176] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:37.176] - nx: 2
[16:59:37.176] - relay: TRUE
[16:59:37.176] - stdout: TRUE
[16:59:37.176] - signal: TRUE
[16:59:37.176] - resignal: FALSE
[16:59:37.176] - force: TRUE
[16:59:37.176] - relayed: [n=2] FALSE, FALSE
[16:59:37.177] - queued futures: [n=2] FALSE, FALSE
[16:59:37.177]  - until=1
[16:59:37.177]  - relaying element #1
[16:59:37.177] result() for ClusterFuture ...
[16:59:37.177] - result already collected: FutureResult
[16:59:37.177] result() for ClusterFuture ... done
[16:59:37.177] result() for ClusterFuture ...
[16:59:37.177] - result already collected: FutureResult
[16:59:37.177] result() for ClusterFuture ... done
[16:59:37.177] result() for ClusterFuture ...
[16:59:37.177] - result already collected: FutureResult
[16:59:37.177] result() for ClusterFuture ... done
[16:59:37.178] result() for ClusterFuture ...
[16:59:37.178] - result already collected: FutureResult
[16:59:37.178] result() for ClusterFuture ... done
[16:59:37.178] - relayed: [n=2] TRUE, FALSE
[16:59:37.178] - queued futures: [n=2] TRUE, FALSE
[16:59:37.178] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:37.178]  length: 1 (resolved future 1)
[16:59:37.207] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.207] - Validating connection of MultisessionFuture
[16:59:37.207] - received message: FutureResult
[16:59:37.207] - Received FutureResult
[16:59:37.207] - Erased future from FutureRegistry
[16:59:37.208] result() for ClusterFuture ...
[16:59:37.208] - result already collected: FutureResult
[16:59:37.208] result() for ClusterFuture ... done
[16:59:37.208] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.208] Future #2
[16:59:37.208] result() for ClusterFuture ...
[16:59:37.208] - result already collected: FutureResult
[16:59:37.208] result() for ClusterFuture ... done
[16:59:37.208] result() for ClusterFuture ...
[16:59:37.208] - result already collected: FutureResult
[16:59:37.208] result() for ClusterFuture ... done
[16:59:37.209] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:37.209] - nx: 2
[16:59:37.209] - relay: TRUE
[16:59:37.209] - stdout: TRUE
[16:59:37.209] - signal: TRUE
[16:59:37.209] - resignal: FALSE
[16:59:37.209] - force: TRUE
[16:59:37.209] - relayed: [n=2] TRUE, FALSE
[16:59:37.209] - queued futures: [n=2] TRUE, FALSE
[16:59:37.209]  - until=2
[16:59:37.209]  - relaying element #2
[16:59:37.210] result() for ClusterFuture ...
[16:59:37.210] - result already collected: FutureResult
[16:59:37.210] result() for ClusterFuture ... done
[16:59:37.210] result() for ClusterFuture ...
[16:59:37.210] - result already collected: FutureResult
[16:59:37.210] result() for ClusterFuture ... done
[16:59:37.210] result() for ClusterFuture ...
[16:59:37.210] - result already collected: FutureResult
[16:59:37.210] result() for ClusterFuture ... done
[16:59:37.210] result() for ClusterFuture ...
[16:59:37.210] - result already collected: FutureResult
[16:59:37.210] result() for ClusterFuture ... done
[16:59:37.211] - relayed: [n=2] TRUE, TRUE
[16:59:37.211] - queued futures: [n=2] TRUE, TRUE
[16:59:37.211] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:37.211]  length: 0 (resolved future 2)
[16:59:37.211] Relaying remaining futures
[16:59:37.211] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.211] - nx: 2
[16:59:37.211] - relay: TRUE
[16:59:37.211] - stdout: TRUE
[16:59:37.211] - signal: TRUE
[16:59:37.211] - resignal: FALSE
[16:59:37.212] - force: TRUE
[16:59:37.212] - relayed: [n=2] TRUE, TRUE
[16:59:37.212] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:37.212] - relayed: [n=2] TRUE, TRUE
[16:59:37.212] - queued futures: [n=2] TRUE, TRUE
[16:59:37.212] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.212] resolve() on list ... DONE
[16:59:37.212] result() for ClusterFuture ...
[16:59:37.212] - result already collected: FutureResult
[16:59:37.212] result() for ClusterFuture ... done
[16:59:37.212] result() for ClusterFuture ...
[16:59:37.213] - result already collected: FutureResult
[16:59:37.213] result() for ClusterFuture ... done
[16:59:37.213] result() for ClusterFuture ...
[16:59:37.213] - result already collected: FutureResult
[16:59:37.213] result() for ClusterFuture ... done
[16:59:37.213] result() for ClusterFuture ...
[16:59:37.213] - result already collected: FutureResult
[16:59:37.213] result() for ClusterFuture ... done
[16:59:37.213]  - Number of value chunks collected: 2
[16:59:37.213] Resolving 2 futures (chunks) ... DONE
[16:59:37.213] Reducing values from 2 chunks ...
[16:59:37.214]  - Number of values collected after concatenation: 3
[16:59:37.214]  - Number of values expected: 3
[16:59:37.214] Reducing values from 2 chunks ... DONE
[16:59:37.214] future_lapply() ... DONE
[16:59:37.214] future_by_internal() ... DONE
[16:59:37.214] future_by_internal() ...
[16:59:37.215] future_lapply() ...
[16:59:37.219] Number of chunks: 2
[16:59:37.219] getGlobalsAndPackagesXApply() ...
[16:59:37.219]  - future.globals: TRUE
[16:59:37.219] getGlobalsAndPackages() ...
[16:59:37.219] Searching for globals...
[16:59:37.221] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.221] Searching for globals ... DONE
[16:59:37.221] Resolving globals: FALSE
[16:59:37.221] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:37.221] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:37.222] - globals: [1] ‘FUN’
[16:59:37.222] 
[16:59:37.222] getGlobalsAndPackages() ... DONE
[16:59:37.222]  - globals found/used: [n=1] ‘FUN’
[16:59:37.222]  - needed namespaces: [n=0] 
[16:59:37.222] Finding globals ... DONE
[16:59:37.222]  - use_args: TRUE
[16:59:37.222]  - Getting '...' globals ...
[16:59:37.223] resolve() on list ...
[16:59:37.223]  recursive: 0
[16:59:37.223]  length: 1
[16:59:37.223]  elements: ‘...’
[16:59:37.223]  length: 0 (resolved future 1)
[16:59:37.223] resolve() on list ... DONE
[16:59:37.223]    - '...' content: [n=0] 
[16:59:37.223] List of 1
[16:59:37.223]  $ ...: list()
[16:59:37.223]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.223]  - attr(*, "where")=List of 1
[16:59:37.223]   ..$ ...:<environment: 0x562051cbb0a0> 
[16:59:37.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.223]  - attr(*, "resolved")= logi TRUE
[16:59:37.223]  - attr(*, "total_size")= num NA
[16:59:37.226]  - Getting '...' globals ... DONE
[16:59:37.226] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:37.226] List of 2
[16:59:37.226]  $ ...future.FUN:function (object, ...)  
[16:59:37.226]  $ ...          : list()
[16:59:37.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.226]  - attr(*, "where")=List of 2
[16:59:37.226]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.226]   ..$ ...          :<environment: 0x562051cbb0a0> 
[16:59:37.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.226]  - attr(*, "resolved")= logi FALSE
[16:59:37.226]  - attr(*, "total_size")= num 1240
[16:59:37.229] Packages to be attached in all futures: [n=0] 
[16:59:37.229] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.229] Number of futures (= number of chunks): 2
[16:59:37.229] Launching 2 futures (chunks) ...
[16:59:37.229] Chunk #1 of 2 ...
[16:59:37.229]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.229] getGlobalsAndPackages() ...
[16:59:37.230] Searching for globals...
[16:59:37.230] 
[16:59:37.230] Searching for globals ... DONE
[16:59:37.230] - globals: [0] <none>
[16:59:37.230] getGlobalsAndPackages() ... DONE
[16:59:37.230]    + additional globals found: [n=0] 
[16:59:37.230]    + additional namespaces needed: [n=0] 
[16:59:37.231]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.231]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:37.231]  - seeds: <none>
[16:59:37.231]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.231] getGlobalsAndPackages() ...
[16:59:37.231] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.231] Resolving globals: FALSE
[16:59:37.231] Tweak future expression to call with '...' arguments ...
[16:59:37.231] {
[16:59:37.231]     do.call(function(...) {
[16:59:37.231]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.231]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.231]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.231]             on.exit(options(oopts), add = TRUE)
[16:59:37.231]         }
[16:59:37.231]         {
[16:59:37.231]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.231]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.231]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.231]             })
[16:59:37.231]         }
[16:59:37.231]     }, args = future.call.arguments)
[16:59:37.231] }
[16:59:37.232] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.232] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.232] 
[16:59:37.232] getGlobalsAndPackages() ... DONE
[16:59:37.233] run() for ‘Future’ ...
[16:59:37.233] - state: ‘created’
[16:59:37.233] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.247] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.248]   - Field: ‘node’
[16:59:37.248]   - Field: ‘label’
[16:59:37.248]   - Field: ‘local’
[16:59:37.248]   - Field: ‘owner’
[16:59:37.248]   - Field: ‘envir’
[16:59:37.248]   - Field: ‘workers’
[16:59:37.248]   - Field: ‘packages’
[16:59:37.248]   - Field: ‘gc’
[16:59:37.248]   - Field: ‘conditions’
[16:59:37.248]   - Field: ‘persistent’
[16:59:37.248]   - Field: ‘expr’
[16:59:37.249]   - Field: ‘uuid’
[16:59:37.249]   - Field: ‘seed’
[16:59:37.249]   - Field: ‘version’
[16:59:37.249]   - Field: ‘result’
[16:59:37.249]   - Field: ‘asynchronous’
[16:59:37.249]   - Field: ‘calls’
[16:59:37.249]   - Field: ‘globals’
[16:59:37.249]   - Field: ‘stdout’
[16:59:37.249]   - Field: ‘earlySignal’
[16:59:37.249]   - Field: ‘lazy’
[16:59:37.249]   - Field: ‘state’
[16:59:37.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.250] - Launch lazy future ...
[16:59:37.250] Packages needed by the future expression (n = 0): <none>
[16:59:37.250] Packages needed by future strategies (n = 0): <none>
[16:59:37.250] {
[16:59:37.250]     {
[16:59:37.250]         {
[16:59:37.250]             ...future.startTime <- base::Sys.time()
[16:59:37.250]             {
[16:59:37.250]                 {
[16:59:37.250]                   {
[16:59:37.250]                     {
[16:59:37.250]                       base::local({
[16:59:37.250]                         has_future <- base::requireNamespace("future", 
[16:59:37.250]                           quietly = TRUE)
[16:59:37.250]                         if (has_future) {
[16:59:37.250]                           ns <- base::getNamespace("future")
[16:59:37.250]                           version <- ns[[".package"]][["version"]]
[16:59:37.250]                           if (is.null(version)) 
[16:59:37.250]                             version <- utils::packageVersion("future")
[16:59:37.250]                         }
[16:59:37.250]                         else {
[16:59:37.250]                           version <- NULL
[16:59:37.250]                         }
[16:59:37.250]                         if (!has_future || version < "1.8.0") {
[16:59:37.250]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.250]                             "", base::R.version$version.string), 
[16:59:37.250]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.250]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.250]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.250]                               "release", "version")], collapse = " "), 
[16:59:37.250]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.250]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.250]                             info)
[16:59:37.250]                           info <- base::paste(info, collapse = "; ")
[16:59:37.250]                           if (!has_future) {
[16:59:37.250]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.250]                               info)
[16:59:37.250]                           }
[16:59:37.250]                           else {
[16:59:37.250]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.250]                               info, version)
[16:59:37.250]                           }
[16:59:37.250]                           base::stop(msg)
[16:59:37.250]                         }
[16:59:37.250]                       })
[16:59:37.250]                     }
[16:59:37.250]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.250]                     base::options(mc.cores = 1L)
[16:59:37.250]                   }
[16:59:37.250]                   ...future.strategy.old <- future::plan("list")
[16:59:37.250]                   options(future.plan = NULL)
[16:59:37.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.250]                 }
[16:59:37.250]                 ...future.workdir <- getwd()
[16:59:37.250]             }
[16:59:37.250]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.250]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.250]         }
[16:59:37.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.250]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.250]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.250]             base::names(...future.oldOptions))
[16:59:37.250]     }
[16:59:37.250]     if (FALSE) {
[16:59:37.250]     }
[16:59:37.250]     else {
[16:59:37.250]         if (TRUE) {
[16:59:37.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.250]                 open = "w")
[16:59:37.250]         }
[16:59:37.250]         else {
[16:59:37.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.250]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.250]         }
[16:59:37.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.250]             base::sink(type = "output", split = FALSE)
[16:59:37.250]             base::close(...future.stdout)
[16:59:37.250]         }, add = TRUE)
[16:59:37.250]     }
[16:59:37.250]     ...future.frame <- base::sys.nframe()
[16:59:37.250]     ...future.conditions <- base::list()
[16:59:37.250]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.250]     if (FALSE) {
[16:59:37.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.250]     }
[16:59:37.250]     ...future.result <- base::tryCatch({
[16:59:37.250]         base::withCallingHandlers({
[16:59:37.250]             ...future.value <- base::withVisible(base::local({
[16:59:37.250]                 ...future.makeSendCondition <- base::local({
[16:59:37.250]                   sendCondition <- NULL
[16:59:37.250]                   function(frame = 1L) {
[16:59:37.250]                     if (is.function(sendCondition)) 
[16:59:37.250]                       return(sendCondition)
[16:59:37.250]                     ns <- getNamespace("parallel")
[16:59:37.250]                     if (exists("sendData", mode = "function", 
[16:59:37.250]                       envir = ns)) {
[16:59:37.250]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.250]                         envir = ns)
[16:59:37.250]                       envir <- sys.frame(frame)
[16:59:37.250]                       master <- NULL
[16:59:37.250]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.250]                         !identical(envir, emptyenv())) {
[16:59:37.250]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.250]                           inherits = FALSE)) {
[16:59:37.250]                           master <- get("master", mode = "list", 
[16:59:37.250]                             envir = envir, inherits = FALSE)
[16:59:37.250]                           if (inherits(master, c("SOCKnode", 
[16:59:37.250]                             "SOCK0node"))) {
[16:59:37.250]                             sendCondition <<- function(cond) {
[16:59:37.250]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.250]                                 success = TRUE)
[16:59:37.250]                               parallel_sendData(master, data)
[16:59:37.250]                             }
[16:59:37.250]                             return(sendCondition)
[16:59:37.250]                           }
[16:59:37.250]                         }
[16:59:37.250]                         frame <- frame + 1L
[16:59:37.250]                         envir <- sys.frame(frame)
[16:59:37.250]                       }
[16:59:37.250]                     }
[16:59:37.250]                     sendCondition <<- function(cond) NULL
[16:59:37.250]                   }
[16:59:37.250]                 })
[16:59:37.250]                 withCallingHandlers({
[16:59:37.250]                   {
[16:59:37.250]                     do.call(function(...) {
[16:59:37.250]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.250]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.250]                         ...future.globals.maxSize)) {
[16:59:37.250]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.250]                         on.exit(options(oopts), add = TRUE)
[16:59:37.250]                       }
[16:59:37.250]                       {
[16:59:37.250]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.250]                           FUN = function(jj) {
[16:59:37.250]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.250]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.250]                           })
[16:59:37.250]                       }
[16:59:37.250]                     }, args = future.call.arguments)
[16:59:37.250]                   }
[16:59:37.250]                 }, immediateCondition = function(cond) {
[16:59:37.250]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.250]                   sendCondition(cond)
[16:59:37.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.250]                   {
[16:59:37.250]                     inherits <- base::inherits
[16:59:37.250]                     invokeRestart <- base::invokeRestart
[16:59:37.250]                     is.null <- base::is.null
[16:59:37.250]                     muffled <- FALSE
[16:59:37.250]                     if (inherits(cond, "message")) {
[16:59:37.250]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.250]                       if (muffled) 
[16:59:37.250]                         invokeRestart("muffleMessage")
[16:59:37.250]                     }
[16:59:37.250]                     else if (inherits(cond, "warning")) {
[16:59:37.250]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.250]                       if (muffled) 
[16:59:37.250]                         invokeRestart("muffleWarning")
[16:59:37.250]                     }
[16:59:37.250]                     else if (inherits(cond, "condition")) {
[16:59:37.250]                       if (!is.null(pattern)) {
[16:59:37.250]                         computeRestarts <- base::computeRestarts
[16:59:37.250]                         grepl <- base::grepl
[16:59:37.250]                         restarts <- computeRestarts(cond)
[16:59:37.250]                         for (restart in restarts) {
[16:59:37.250]                           name <- restart$name
[16:59:37.250]                           if (is.null(name)) 
[16:59:37.250]                             next
[16:59:37.250]                           if (!grepl(pattern, name)) 
[16:59:37.250]                             next
[16:59:37.250]                           invokeRestart(restart)
[16:59:37.250]                           muffled <- TRUE
[16:59:37.250]                           break
[16:59:37.250]                         }
[16:59:37.250]                       }
[16:59:37.250]                     }
[16:59:37.250]                     invisible(muffled)
[16:59:37.250]                   }
[16:59:37.250]                   muffleCondition(cond)
[16:59:37.250]                 })
[16:59:37.250]             }))
[16:59:37.250]             future::FutureResult(value = ...future.value$value, 
[16:59:37.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.250]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.250]                     ...future.globalenv.names))
[16:59:37.250]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.250]         }, condition = base::local({
[16:59:37.250]             c <- base::c
[16:59:37.250]             inherits <- base::inherits
[16:59:37.250]             invokeRestart <- base::invokeRestart
[16:59:37.250]             length <- base::length
[16:59:37.250]             list <- base::list
[16:59:37.250]             seq.int <- base::seq.int
[16:59:37.250]             signalCondition <- base::signalCondition
[16:59:37.250]             sys.calls <- base::sys.calls
[16:59:37.250]             `[[` <- base::`[[`
[16:59:37.250]             `+` <- base::`+`
[16:59:37.250]             `<<-` <- base::`<<-`
[16:59:37.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.250]                   3L)]
[16:59:37.250]             }
[16:59:37.250]             function(cond) {
[16:59:37.250]                 is_error <- inherits(cond, "error")
[16:59:37.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.250]                   NULL)
[16:59:37.250]                 if (is_error) {
[16:59:37.250]                   sessionInformation <- function() {
[16:59:37.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.250]                       search = base::search(), system = base::Sys.info())
[16:59:37.250]                   }
[16:59:37.250]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.250]                     cond$call), session = sessionInformation(), 
[16:59:37.250]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.250]                   signalCondition(cond)
[16:59:37.250]                 }
[16:59:37.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.250]                 "immediateCondition"))) {
[16:59:37.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.250]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.250]                   if (TRUE && !signal) {
[16:59:37.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.250]                     {
[16:59:37.250]                       inherits <- base::inherits
[16:59:37.250]                       invokeRestart <- base::invokeRestart
[16:59:37.250]                       is.null <- base::is.null
[16:59:37.250]                       muffled <- FALSE
[16:59:37.250]                       if (inherits(cond, "message")) {
[16:59:37.250]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.250]                         if (muffled) 
[16:59:37.250]                           invokeRestart("muffleMessage")
[16:59:37.250]                       }
[16:59:37.250]                       else if (inherits(cond, "warning")) {
[16:59:37.250]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.250]                         if (muffled) 
[16:59:37.250]                           invokeRestart("muffleWarning")
[16:59:37.250]                       }
[16:59:37.250]                       else if (inherits(cond, "condition")) {
[16:59:37.250]                         if (!is.null(pattern)) {
[16:59:37.250]                           computeRestarts <- base::computeRestarts
[16:59:37.250]                           grepl <- base::grepl
[16:59:37.250]                           restarts <- computeRestarts(cond)
[16:59:37.250]                           for (restart in restarts) {
[16:59:37.250]                             name <- restart$name
[16:59:37.250]                             if (is.null(name)) 
[16:59:37.250]                               next
[16:59:37.250]                             if (!grepl(pattern, name)) 
[16:59:37.250]                               next
[16:59:37.250]                             invokeRestart(restart)
[16:59:37.250]                             muffled <- TRUE
[16:59:37.250]                             break
[16:59:37.250]                           }
[16:59:37.250]                         }
[16:59:37.250]                       }
[16:59:37.250]                       invisible(muffled)
[16:59:37.250]                     }
[16:59:37.250]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.250]                   }
[16:59:37.250]                 }
[16:59:37.250]                 else {
[16:59:37.250]                   if (TRUE) {
[16:59:37.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.250]                     {
[16:59:37.250]                       inherits <- base::inherits
[16:59:37.250]                       invokeRestart <- base::invokeRestart
[16:59:37.250]                       is.null <- base::is.null
[16:59:37.250]                       muffled <- FALSE
[16:59:37.250]                       if (inherits(cond, "message")) {
[16:59:37.250]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.250]                         if (muffled) 
[16:59:37.250]                           invokeRestart("muffleMessage")
[16:59:37.250]                       }
[16:59:37.250]                       else if (inherits(cond, "warning")) {
[16:59:37.250]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.250]                         if (muffled) 
[16:59:37.250]                           invokeRestart("muffleWarning")
[16:59:37.250]                       }
[16:59:37.250]                       else if (inherits(cond, "condition")) {
[16:59:37.250]                         if (!is.null(pattern)) {
[16:59:37.250]                           computeRestarts <- base::computeRestarts
[16:59:37.250]                           grepl <- base::grepl
[16:59:37.250]                           restarts <- computeRestarts(cond)
[16:59:37.250]                           for (restart in restarts) {
[16:59:37.250]                             name <- restart$name
[16:59:37.250]                             if (is.null(name)) 
[16:59:37.250]                               next
[16:59:37.250]                             if (!grepl(pattern, name)) 
[16:59:37.250]                               next
[16:59:37.250]                             invokeRestart(restart)
[16:59:37.250]                             muffled <- TRUE
[16:59:37.250]                             break
[16:59:37.250]                           }
[16:59:37.250]                         }
[16:59:37.250]                       }
[16:59:37.250]                       invisible(muffled)
[16:59:37.250]                     }
[16:59:37.250]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.250]                   }
[16:59:37.250]                 }
[16:59:37.250]             }
[16:59:37.250]         }))
[16:59:37.250]     }, error = function(ex) {
[16:59:37.250]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.250]                 ...future.rng), started = ...future.startTime, 
[16:59:37.250]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.250]             version = "1.8"), class = "FutureResult")
[16:59:37.250]     }, finally = {
[16:59:37.250]         if (!identical(...future.workdir, getwd())) 
[16:59:37.250]             setwd(...future.workdir)
[16:59:37.250]         {
[16:59:37.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.250]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.250]             }
[16:59:37.250]             base::options(...future.oldOptions)
[16:59:37.250]             if (.Platform$OS.type == "windows") {
[16:59:37.250]                 old_names <- names(...future.oldEnvVars)
[16:59:37.250]                 envs <- base::Sys.getenv()
[16:59:37.250]                 names <- names(envs)
[16:59:37.250]                 common <- intersect(names, old_names)
[16:59:37.250]                 added <- setdiff(names, old_names)
[16:59:37.250]                 removed <- setdiff(old_names, names)
[16:59:37.250]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.250]                   envs[common]]
[16:59:37.250]                 NAMES <- toupper(changed)
[16:59:37.250]                 args <- list()
[16:59:37.250]                 for (kk in seq_along(NAMES)) {
[16:59:37.250]                   name <- changed[[kk]]
[16:59:37.250]                   NAME <- NAMES[[kk]]
[16:59:37.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.250]                     next
[16:59:37.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.250]                 }
[16:59:37.250]                 NAMES <- toupper(added)
[16:59:37.250]                 for (kk in seq_along(NAMES)) {
[16:59:37.250]                   name <- added[[kk]]
[16:59:37.250]                   NAME <- NAMES[[kk]]
[16:59:37.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.250]                     next
[16:59:37.250]                   args[[name]] <- ""
[16:59:37.250]                 }
[16:59:37.250]                 NAMES <- toupper(removed)
[16:59:37.250]                 for (kk in seq_along(NAMES)) {
[16:59:37.250]                   name <- removed[[kk]]
[16:59:37.250]                   NAME <- NAMES[[kk]]
[16:59:37.250]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.250]                     next
[16:59:37.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.250]                 }
[16:59:37.250]                 if (length(args) > 0) 
[16:59:37.250]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.250]             }
[16:59:37.250]             else {
[16:59:37.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.250]             }
[16:59:37.250]             {
[16:59:37.250]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.250]                   0L) {
[16:59:37.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.250]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.250]                   base::options(opts)
[16:59:37.250]                 }
[16:59:37.250]                 {
[16:59:37.250]                   {
[16:59:37.250]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.250]                     NULL
[16:59:37.250]                   }
[16:59:37.250]                   options(future.plan = NULL)
[16:59:37.250]                   if (is.na(NA_character_)) 
[16:59:37.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.250]                     .init = FALSE)
[16:59:37.250]                 }
[16:59:37.250]             }
[16:59:37.250]         }
[16:59:37.250]     })
[16:59:37.250]     if (TRUE) {
[16:59:37.250]         base::sink(type = "output", split = FALSE)
[16:59:37.250]         if (TRUE) {
[16:59:37.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.250]         }
[16:59:37.250]         else {
[16:59:37.250]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.250]         }
[16:59:37.250]         base::close(...future.stdout)
[16:59:37.250]         ...future.stdout <- NULL
[16:59:37.250]     }
[16:59:37.250]     ...future.result$conditions <- ...future.conditions
[16:59:37.250]     ...future.result$finished <- base::Sys.time()
[16:59:37.250]     ...future.result
[16:59:37.250] }
[16:59:37.253] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:59:37.253] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:59:37.254] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:59:37.254] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:37.254] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.255] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:59:37.255] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:59:37.255] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:37.255] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.255] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:37.256] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.256] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:59:37.256] MultisessionFuture started
[16:59:37.256] - Launch lazy future ... done
[16:59:37.257] run() for ‘MultisessionFuture’ ... done
[16:59:37.257] Created future:
[16:59:37.257] MultisessionFuture:
[16:59:37.257] Label: ‘future_by-1’
[16:59:37.257] Expression:
[16:59:37.257] {
[16:59:37.257]     do.call(function(...) {
[16:59:37.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.257]             on.exit(options(oopts), add = TRUE)
[16:59:37.257]         }
[16:59:37.257]         {
[16:59:37.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.257]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.257]             })
[16:59:37.257]         }
[16:59:37.257]     }, args = future.call.arguments)
[16:59:37.257] }
[16:59:37.257] Lazy evaluation: FALSE
[16:59:37.257] Asynchronous evaluation: TRUE
[16:59:37.257] Local evaluation: TRUE
[16:59:37.257] Environment: 0x562051d135c0
[16:59:37.257] Capture standard output: TRUE
[16:59:37.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.257] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.257] Packages: <none>
[16:59:37.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.257] Resolved: FALSE
[16:59:37.257] Value: <not collected>
[16:59:37.257] Conditions captured: <none>
[16:59:37.257] Early signaling: FALSE
[16:59:37.257] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.257] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.268] Chunk #1 of 2 ... DONE
[16:59:37.269] Chunk #2 of 2 ...
[16:59:37.269]  - Finding globals in 'X' for chunk #2 ...
[16:59:37.269] getGlobalsAndPackages() ...
[16:59:37.269] Searching for globals...
[16:59:37.269] 
[16:59:37.269] Searching for globals ... DONE
[16:59:37.270] - globals: [0] <none>
[16:59:37.270] getGlobalsAndPackages() ... DONE
[16:59:37.270]    + additional globals found: [n=0] 
[16:59:37.270]    + additional namespaces needed: [n=0] 
[16:59:37.270]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:37.270]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:37.270]  - seeds: <none>
[16:59:37.270]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.270] getGlobalsAndPackages() ...
[16:59:37.270] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.270] Resolving globals: FALSE
[16:59:37.271] Tweak future expression to call with '...' arguments ...
[16:59:37.271] {
[16:59:37.271]     do.call(function(...) {
[16:59:37.271]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.271]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.271]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.271]             on.exit(options(oopts), add = TRUE)
[16:59:37.271]         }
[16:59:37.271]         {
[16:59:37.271]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.271]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.271]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.271]             })
[16:59:37.271]         }
[16:59:37.271]     }, args = future.call.arguments)
[16:59:37.271] }
[16:59:37.271] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.271] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.271] 
[16:59:37.272] getGlobalsAndPackages() ... DONE
[16:59:37.272] run() for ‘Future’ ...
[16:59:37.272] - state: ‘created’
[16:59:37.272] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.287] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.287] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.287]   - Field: ‘node’
[16:59:37.287]   - Field: ‘label’
[16:59:37.287]   - Field: ‘local’
[16:59:37.287]   - Field: ‘owner’
[16:59:37.287]   - Field: ‘envir’
[16:59:37.287]   - Field: ‘workers’
[16:59:37.288]   - Field: ‘packages’
[16:59:37.288]   - Field: ‘gc’
[16:59:37.288]   - Field: ‘conditions’
[16:59:37.288]   - Field: ‘persistent’
[16:59:37.288]   - Field: ‘expr’
[16:59:37.288]   - Field: ‘uuid’
[16:59:37.288]   - Field: ‘seed’
[16:59:37.288]   - Field: ‘version’
[16:59:37.288]   - Field: ‘result’
[16:59:37.288]   - Field: ‘asynchronous’
[16:59:37.288]   - Field: ‘calls’
[16:59:37.289]   - Field: ‘globals’
[16:59:37.289]   - Field: ‘stdout’
[16:59:37.289]   - Field: ‘earlySignal’
[16:59:37.289]   - Field: ‘lazy’
[16:59:37.289]   - Field: ‘state’
[16:59:37.289] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.289] - Launch lazy future ...
[16:59:37.290] Packages needed by the future expression (n = 0): <none>
[16:59:37.290] Packages needed by future strategies (n = 0): <none>
[16:59:37.290] {
[16:59:37.290]     {
[16:59:37.290]         {
[16:59:37.290]             ...future.startTime <- base::Sys.time()
[16:59:37.290]             {
[16:59:37.290]                 {
[16:59:37.290]                   {
[16:59:37.290]                     {
[16:59:37.290]                       base::local({
[16:59:37.290]                         has_future <- base::requireNamespace("future", 
[16:59:37.290]                           quietly = TRUE)
[16:59:37.290]                         if (has_future) {
[16:59:37.290]                           ns <- base::getNamespace("future")
[16:59:37.290]                           version <- ns[[".package"]][["version"]]
[16:59:37.290]                           if (is.null(version)) 
[16:59:37.290]                             version <- utils::packageVersion("future")
[16:59:37.290]                         }
[16:59:37.290]                         else {
[16:59:37.290]                           version <- NULL
[16:59:37.290]                         }
[16:59:37.290]                         if (!has_future || version < "1.8.0") {
[16:59:37.290]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.290]                             "", base::R.version$version.string), 
[16:59:37.290]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.290]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.290]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.290]                               "release", "version")], collapse = " "), 
[16:59:37.290]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.290]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.290]                             info)
[16:59:37.290]                           info <- base::paste(info, collapse = "; ")
[16:59:37.290]                           if (!has_future) {
[16:59:37.290]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.290]                               info)
[16:59:37.290]                           }
[16:59:37.290]                           else {
[16:59:37.290]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.290]                               info, version)
[16:59:37.290]                           }
[16:59:37.290]                           base::stop(msg)
[16:59:37.290]                         }
[16:59:37.290]                       })
[16:59:37.290]                     }
[16:59:37.290]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.290]                     base::options(mc.cores = 1L)
[16:59:37.290]                   }
[16:59:37.290]                   ...future.strategy.old <- future::plan("list")
[16:59:37.290]                   options(future.plan = NULL)
[16:59:37.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.290]                 }
[16:59:37.290]                 ...future.workdir <- getwd()
[16:59:37.290]             }
[16:59:37.290]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.290]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.290]         }
[16:59:37.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.290]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.290]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.290]             base::names(...future.oldOptions))
[16:59:37.290]     }
[16:59:37.290]     if (FALSE) {
[16:59:37.290]     }
[16:59:37.290]     else {
[16:59:37.290]         if (TRUE) {
[16:59:37.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.290]                 open = "w")
[16:59:37.290]         }
[16:59:37.290]         else {
[16:59:37.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.290]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.290]         }
[16:59:37.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.290]             base::sink(type = "output", split = FALSE)
[16:59:37.290]             base::close(...future.stdout)
[16:59:37.290]         }, add = TRUE)
[16:59:37.290]     }
[16:59:37.290]     ...future.frame <- base::sys.nframe()
[16:59:37.290]     ...future.conditions <- base::list()
[16:59:37.290]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.290]     if (FALSE) {
[16:59:37.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.290]     }
[16:59:37.290]     ...future.result <- base::tryCatch({
[16:59:37.290]         base::withCallingHandlers({
[16:59:37.290]             ...future.value <- base::withVisible(base::local({
[16:59:37.290]                 ...future.makeSendCondition <- base::local({
[16:59:37.290]                   sendCondition <- NULL
[16:59:37.290]                   function(frame = 1L) {
[16:59:37.290]                     if (is.function(sendCondition)) 
[16:59:37.290]                       return(sendCondition)
[16:59:37.290]                     ns <- getNamespace("parallel")
[16:59:37.290]                     if (exists("sendData", mode = "function", 
[16:59:37.290]                       envir = ns)) {
[16:59:37.290]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.290]                         envir = ns)
[16:59:37.290]                       envir <- sys.frame(frame)
[16:59:37.290]                       master <- NULL
[16:59:37.290]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.290]                         !identical(envir, emptyenv())) {
[16:59:37.290]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.290]                           inherits = FALSE)) {
[16:59:37.290]                           master <- get("master", mode = "list", 
[16:59:37.290]                             envir = envir, inherits = FALSE)
[16:59:37.290]                           if (inherits(master, c("SOCKnode", 
[16:59:37.290]                             "SOCK0node"))) {
[16:59:37.290]                             sendCondition <<- function(cond) {
[16:59:37.290]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.290]                                 success = TRUE)
[16:59:37.290]                               parallel_sendData(master, data)
[16:59:37.290]                             }
[16:59:37.290]                             return(sendCondition)
[16:59:37.290]                           }
[16:59:37.290]                         }
[16:59:37.290]                         frame <- frame + 1L
[16:59:37.290]                         envir <- sys.frame(frame)
[16:59:37.290]                       }
[16:59:37.290]                     }
[16:59:37.290]                     sendCondition <<- function(cond) NULL
[16:59:37.290]                   }
[16:59:37.290]                 })
[16:59:37.290]                 withCallingHandlers({
[16:59:37.290]                   {
[16:59:37.290]                     do.call(function(...) {
[16:59:37.290]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.290]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.290]                         ...future.globals.maxSize)) {
[16:59:37.290]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.290]                         on.exit(options(oopts), add = TRUE)
[16:59:37.290]                       }
[16:59:37.290]                       {
[16:59:37.290]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.290]                           FUN = function(jj) {
[16:59:37.290]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.290]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.290]                           })
[16:59:37.290]                       }
[16:59:37.290]                     }, args = future.call.arguments)
[16:59:37.290]                   }
[16:59:37.290]                 }, immediateCondition = function(cond) {
[16:59:37.290]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.290]                   sendCondition(cond)
[16:59:37.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.290]                   {
[16:59:37.290]                     inherits <- base::inherits
[16:59:37.290]                     invokeRestart <- base::invokeRestart
[16:59:37.290]                     is.null <- base::is.null
[16:59:37.290]                     muffled <- FALSE
[16:59:37.290]                     if (inherits(cond, "message")) {
[16:59:37.290]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.290]                       if (muffled) 
[16:59:37.290]                         invokeRestart("muffleMessage")
[16:59:37.290]                     }
[16:59:37.290]                     else if (inherits(cond, "warning")) {
[16:59:37.290]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.290]                       if (muffled) 
[16:59:37.290]                         invokeRestart("muffleWarning")
[16:59:37.290]                     }
[16:59:37.290]                     else if (inherits(cond, "condition")) {
[16:59:37.290]                       if (!is.null(pattern)) {
[16:59:37.290]                         computeRestarts <- base::computeRestarts
[16:59:37.290]                         grepl <- base::grepl
[16:59:37.290]                         restarts <- computeRestarts(cond)
[16:59:37.290]                         for (restart in restarts) {
[16:59:37.290]                           name <- restart$name
[16:59:37.290]                           if (is.null(name)) 
[16:59:37.290]                             next
[16:59:37.290]                           if (!grepl(pattern, name)) 
[16:59:37.290]                             next
[16:59:37.290]                           invokeRestart(restart)
[16:59:37.290]                           muffled <- TRUE
[16:59:37.290]                           break
[16:59:37.290]                         }
[16:59:37.290]                       }
[16:59:37.290]                     }
[16:59:37.290]                     invisible(muffled)
[16:59:37.290]                   }
[16:59:37.290]                   muffleCondition(cond)
[16:59:37.290]                 })
[16:59:37.290]             }))
[16:59:37.290]             future::FutureResult(value = ...future.value$value, 
[16:59:37.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.290]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.290]                     ...future.globalenv.names))
[16:59:37.290]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.290]         }, condition = base::local({
[16:59:37.290]             c <- base::c
[16:59:37.290]             inherits <- base::inherits
[16:59:37.290]             invokeRestart <- base::invokeRestart
[16:59:37.290]             length <- base::length
[16:59:37.290]             list <- base::list
[16:59:37.290]             seq.int <- base::seq.int
[16:59:37.290]             signalCondition <- base::signalCondition
[16:59:37.290]             sys.calls <- base::sys.calls
[16:59:37.290]             `[[` <- base::`[[`
[16:59:37.290]             `+` <- base::`+`
[16:59:37.290]             `<<-` <- base::`<<-`
[16:59:37.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.290]                   3L)]
[16:59:37.290]             }
[16:59:37.290]             function(cond) {
[16:59:37.290]                 is_error <- inherits(cond, "error")
[16:59:37.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.290]                   NULL)
[16:59:37.290]                 if (is_error) {
[16:59:37.290]                   sessionInformation <- function() {
[16:59:37.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.290]                       search = base::search(), system = base::Sys.info())
[16:59:37.290]                   }
[16:59:37.290]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.290]                     cond$call), session = sessionInformation(), 
[16:59:37.290]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.290]                   signalCondition(cond)
[16:59:37.290]                 }
[16:59:37.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.290]                 "immediateCondition"))) {
[16:59:37.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.290]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.290]                   if (TRUE && !signal) {
[16:59:37.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.290]                     {
[16:59:37.290]                       inherits <- base::inherits
[16:59:37.290]                       invokeRestart <- base::invokeRestart
[16:59:37.290]                       is.null <- base::is.null
[16:59:37.290]                       muffled <- FALSE
[16:59:37.290]                       if (inherits(cond, "message")) {
[16:59:37.290]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.290]                         if (muffled) 
[16:59:37.290]                           invokeRestart("muffleMessage")
[16:59:37.290]                       }
[16:59:37.290]                       else if (inherits(cond, "warning")) {
[16:59:37.290]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.290]                         if (muffled) 
[16:59:37.290]                           invokeRestart("muffleWarning")
[16:59:37.290]                       }
[16:59:37.290]                       else if (inherits(cond, "condition")) {
[16:59:37.290]                         if (!is.null(pattern)) {
[16:59:37.290]                           computeRestarts <- base::computeRestarts
[16:59:37.290]                           grepl <- base::grepl
[16:59:37.290]                           restarts <- computeRestarts(cond)
[16:59:37.290]                           for (restart in restarts) {
[16:59:37.290]                             name <- restart$name
[16:59:37.290]                             if (is.null(name)) 
[16:59:37.290]                               next
[16:59:37.290]                             if (!grepl(pattern, name)) 
[16:59:37.290]                               next
[16:59:37.290]                             invokeRestart(restart)
[16:59:37.290]                             muffled <- TRUE
[16:59:37.290]                             break
[16:59:37.290]                           }
[16:59:37.290]                         }
[16:59:37.290]                       }
[16:59:37.290]                       invisible(muffled)
[16:59:37.290]                     }
[16:59:37.290]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.290]                   }
[16:59:37.290]                 }
[16:59:37.290]                 else {
[16:59:37.290]                   if (TRUE) {
[16:59:37.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.290]                     {
[16:59:37.290]                       inherits <- base::inherits
[16:59:37.290]                       invokeRestart <- base::invokeRestart
[16:59:37.290]                       is.null <- base::is.null
[16:59:37.290]                       muffled <- FALSE
[16:59:37.290]                       if (inherits(cond, "message")) {
[16:59:37.290]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.290]                         if (muffled) 
[16:59:37.290]                           invokeRestart("muffleMessage")
[16:59:37.290]                       }
[16:59:37.290]                       else if (inherits(cond, "warning")) {
[16:59:37.290]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.290]                         if (muffled) 
[16:59:37.290]                           invokeRestart("muffleWarning")
[16:59:37.290]                       }
[16:59:37.290]                       else if (inherits(cond, "condition")) {
[16:59:37.290]                         if (!is.null(pattern)) {
[16:59:37.290]                           computeRestarts <- base::computeRestarts
[16:59:37.290]                           grepl <- base::grepl
[16:59:37.290]                           restarts <- computeRestarts(cond)
[16:59:37.290]                           for (restart in restarts) {
[16:59:37.290]                             name <- restart$name
[16:59:37.290]                             if (is.null(name)) 
[16:59:37.290]                               next
[16:59:37.290]                             if (!grepl(pattern, name)) 
[16:59:37.290]                               next
[16:59:37.290]                             invokeRestart(restart)
[16:59:37.290]                             muffled <- TRUE
[16:59:37.290]                             break
[16:59:37.290]                           }
[16:59:37.290]                         }
[16:59:37.290]                       }
[16:59:37.290]                       invisible(muffled)
[16:59:37.290]                     }
[16:59:37.290]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.290]                   }
[16:59:37.290]                 }
[16:59:37.290]             }
[16:59:37.290]         }))
[16:59:37.290]     }, error = function(ex) {
[16:59:37.290]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.290]                 ...future.rng), started = ...future.startTime, 
[16:59:37.290]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.290]             version = "1.8"), class = "FutureResult")
[16:59:37.290]     }, finally = {
[16:59:37.290]         if (!identical(...future.workdir, getwd())) 
[16:59:37.290]             setwd(...future.workdir)
[16:59:37.290]         {
[16:59:37.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.290]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.290]             }
[16:59:37.290]             base::options(...future.oldOptions)
[16:59:37.290]             if (.Platform$OS.type == "windows") {
[16:59:37.290]                 old_names <- names(...future.oldEnvVars)
[16:59:37.290]                 envs <- base::Sys.getenv()
[16:59:37.290]                 names <- names(envs)
[16:59:37.290]                 common <- intersect(names, old_names)
[16:59:37.290]                 added <- setdiff(names, old_names)
[16:59:37.290]                 removed <- setdiff(old_names, names)
[16:59:37.290]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.290]                   envs[common]]
[16:59:37.290]                 NAMES <- toupper(changed)
[16:59:37.290]                 args <- list()
[16:59:37.290]                 for (kk in seq_along(NAMES)) {
[16:59:37.290]                   name <- changed[[kk]]
[16:59:37.290]                   NAME <- NAMES[[kk]]
[16:59:37.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.290]                     next
[16:59:37.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.290]                 }
[16:59:37.290]                 NAMES <- toupper(added)
[16:59:37.290]                 for (kk in seq_along(NAMES)) {
[16:59:37.290]                   name <- added[[kk]]
[16:59:37.290]                   NAME <- NAMES[[kk]]
[16:59:37.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.290]                     next
[16:59:37.290]                   args[[name]] <- ""
[16:59:37.290]                 }
[16:59:37.290]                 NAMES <- toupper(removed)
[16:59:37.290]                 for (kk in seq_along(NAMES)) {
[16:59:37.290]                   name <- removed[[kk]]
[16:59:37.290]                   NAME <- NAMES[[kk]]
[16:59:37.290]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.290]                     next
[16:59:37.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.290]                 }
[16:59:37.290]                 if (length(args) > 0) 
[16:59:37.290]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.290]             }
[16:59:37.290]             else {
[16:59:37.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.290]             }
[16:59:37.290]             {
[16:59:37.290]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.290]                   0L) {
[16:59:37.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.290]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.290]                   base::options(opts)
[16:59:37.290]                 }
[16:59:37.290]                 {
[16:59:37.290]                   {
[16:59:37.290]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.290]                     NULL
[16:59:37.290]                   }
[16:59:37.290]                   options(future.plan = NULL)
[16:59:37.290]                   if (is.na(NA_character_)) 
[16:59:37.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.290]                     .init = FALSE)
[16:59:37.290]                 }
[16:59:37.290]             }
[16:59:37.290]         }
[16:59:37.290]     })
[16:59:37.290]     if (TRUE) {
[16:59:37.290]         base::sink(type = "output", split = FALSE)
[16:59:37.290]         if (TRUE) {
[16:59:37.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.290]         }
[16:59:37.290]         else {
[16:59:37.290]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.290]         }
[16:59:37.290]         base::close(...future.stdout)
[16:59:37.290]         ...future.stdout <- NULL
[16:59:37.290]     }
[16:59:37.290]     ...future.result$conditions <- ...future.conditions
[16:59:37.290]     ...future.result$finished <- base::Sys.time()
[16:59:37.290]     ...future.result
[16:59:37.290] }
[16:59:37.293] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:59:37.293] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:59:37.293] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:59:37.294] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:37.294] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.294] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:59:37.295] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:59:37.295] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:37.295] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.295] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:37.295] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.295] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:59:37.296] MultisessionFuture started
[16:59:37.296] - Launch lazy future ... done
[16:59:37.296] run() for ‘MultisessionFuture’ ... done
[16:59:37.296] Created future:
[16:59:37.296] MultisessionFuture:
[16:59:37.296] Label: ‘future_by-2’
[16:59:37.296] Expression:
[16:59:37.296] {
[16:59:37.296]     do.call(function(...) {
[16:59:37.296]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.296]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.296]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.296]             on.exit(options(oopts), add = TRUE)
[16:59:37.296]         }
[16:59:37.296]         {
[16:59:37.296]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.296]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.296]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.296]             })
[16:59:37.296]         }
[16:59:37.296]     }, args = future.call.arguments)
[16:59:37.296] }
[16:59:37.296] Lazy evaluation: FALSE
[16:59:37.296] Asynchronous evaluation: TRUE
[16:59:37.296] Local evaluation: TRUE
[16:59:37.296] Environment: 0x562051d135c0
[16:59:37.296] Capture standard output: TRUE
[16:59:37.296] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.296] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.296] Packages: <none>
[16:59:37.296] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.296] Resolved: FALSE
[16:59:37.296] Value: <not collected>
[16:59:37.296] Conditions captured: <none>
[16:59:37.296] Early signaling: FALSE
[16:59:37.296] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.296] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.308] Chunk #2 of 2 ... DONE
[16:59:37.308] Launching 2 futures (chunks) ... DONE
[16:59:37.308] Resolving 2 futures (chunks) ...
[16:59:37.309] resolve() on list ...
[16:59:37.309]  recursive: 0
[16:59:37.309]  length: 2
[16:59:37.309] 
[16:59:37.309] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.309] - Validating connection of MultisessionFuture
[16:59:37.310] - received message: FutureResult
[16:59:37.310] - Received FutureResult
[16:59:37.310] - Erased future from FutureRegistry
[16:59:37.310] result() for ClusterFuture ...
[16:59:37.310] - result already collected: FutureResult
[16:59:37.310] result() for ClusterFuture ... done
[16:59:37.310] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.310] Future #1
[16:59:37.310] result() for ClusterFuture ...
[16:59:37.311] - result already collected: FutureResult
[16:59:37.311] result() for ClusterFuture ... done
[16:59:37.311] result() for ClusterFuture ...
[16:59:37.311] - result already collected: FutureResult
[16:59:37.311] result() for ClusterFuture ... done
[16:59:37.311] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:37.311] - nx: 2
[16:59:37.311] - relay: TRUE
[16:59:37.311] - stdout: TRUE
[16:59:37.311] - signal: TRUE
[16:59:37.311] - resignal: FALSE
[16:59:37.312] - force: TRUE
[16:59:37.312] - relayed: [n=2] FALSE, FALSE
[16:59:37.312] - queued futures: [n=2] FALSE, FALSE
[16:59:37.312]  - until=1
[16:59:37.312]  - relaying element #1
[16:59:37.312] result() for ClusterFuture ...
[16:59:37.312] - result already collected: FutureResult
[16:59:37.312] result() for ClusterFuture ... done
[16:59:37.312] result() for ClusterFuture ...
[16:59:37.312] - result already collected: FutureResult
[16:59:37.312] result() for ClusterFuture ... done
[16:59:37.313] result() for ClusterFuture ...
[16:59:37.313] - result already collected: FutureResult
[16:59:37.313] result() for ClusterFuture ... done
[16:59:37.313] result() for ClusterFuture ...
[16:59:37.313] - result already collected: FutureResult
[16:59:37.313] result() for ClusterFuture ... done
[16:59:37.313] - relayed: [n=2] TRUE, FALSE
[16:59:37.313] - queued futures: [n=2] TRUE, FALSE
[16:59:37.313] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:37.313]  length: 1 (resolved future 1)
[16:59:37.342] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.342] - Validating connection of MultisessionFuture
[16:59:37.343] - received message: FutureResult
[16:59:37.343] - Received FutureResult
[16:59:37.343] - Erased future from FutureRegistry
[16:59:37.343] result() for ClusterFuture ...
[16:59:37.343] - result already collected: FutureResult
[16:59:37.343] result() for ClusterFuture ... done
[16:59:37.343] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.343] Future #2
[16:59:37.343] result() for ClusterFuture ...
[16:59:37.344] - result already collected: FutureResult
[16:59:37.344] result() for ClusterFuture ... done
[16:59:37.344] result() for ClusterFuture ...
[16:59:37.344] - result already collected: FutureResult
[16:59:37.344] result() for ClusterFuture ... done
[16:59:37.344] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:37.344] - nx: 2
[16:59:37.344] - relay: TRUE
[16:59:37.344] - stdout: TRUE
[16:59:37.344] - signal: TRUE
[16:59:37.344] - resignal: FALSE
[16:59:37.344] - force: TRUE
[16:59:37.345] - relayed: [n=2] TRUE, FALSE
[16:59:37.345] - queued futures: [n=2] TRUE, FALSE
[16:59:37.345]  - until=2
[16:59:37.345]  - relaying element #2
[16:59:37.345] result() for ClusterFuture ...
[16:59:37.345] - result already collected: FutureResult
[16:59:37.345] result() for ClusterFuture ... done
[16:59:37.345] result() for ClusterFuture ...
[16:59:37.345] - result already collected: FutureResult
[16:59:37.345] result() for ClusterFuture ... done
[16:59:37.345] result() for ClusterFuture ...
[16:59:37.346] - result already collected: FutureResult
[16:59:37.346] result() for ClusterFuture ... done
[16:59:37.346] result() for ClusterFuture ...
[16:59:37.346] - result already collected: FutureResult
[16:59:37.346] result() for ClusterFuture ... done
[16:59:37.346] - relayed: [n=2] TRUE, TRUE
[16:59:37.346] - queued futures: [n=2] TRUE, TRUE
[16:59:37.346] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:37.346]  length: 0 (resolved future 2)
[16:59:37.346] Relaying remaining futures
[16:59:37.346] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.347] - nx: 2
[16:59:37.347] - relay: TRUE
[16:59:37.347] - stdout: TRUE
[16:59:37.347] - signal: TRUE
[16:59:37.347] - resignal: FALSE
[16:59:37.347] - force: TRUE
[16:59:37.347] - relayed: [n=2] TRUE, TRUE
[16:59:37.347] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:37.347] - relayed: [n=2] TRUE, TRUE
[16:59:37.347] - queued futures: [n=2] TRUE, TRUE
[16:59:37.347] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.348] resolve() on list ... DONE
[16:59:37.348] result() for ClusterFuture ...
[16:59:37.348] - result already collected: FutureResult
[16:59:37.348] result() for ClusterFuture ... done
[16:59:37.348] result() for ClusterFuture ...
[16:59:37.348] - result already collected: FutureResult
[16:59:37.348] result() for ClusterFuture ... done
[16:59:37.348] result() for ClusterFuture ...
[16:59:37.348] - result already collected: FutureResult
[16:59:37.348] result() for ClusterFuture ... done
[16:59:37.348] result() for ClusterFuture ...
[16:59:37.348] - result already collected: FutureResult
[16:59:37.349] result() for ClusterFuture ... done
[16:59:37.349]  - Number of value chunks collected: 2
[16:59:37.349] Resolving 2 futures (chunks) ... DONE
[16:59:37.349] Reducing values from 2 chunks ...
[16:59:37.349]  - Number of values collected after concatenation: 3
[16:59:37.349]  - Number of values expected: 3
[16:59:37.349] Reducing values from 2 chunks ... DONE
[16:59:37.349] future_lapply() ... DONE
[16:59:37.349] future_by_internal() ... DONE
[16:59:37.350] future_by_internal() ...
Warning in future_by_match_FUN(FUN) :
  Specifying the function 'FUN' for future_by() as a character string is deprecated in future.apply (>= 1.10.0) [2022-11-04], because base::by() does not support it. Instead, specify it as a function, e.g. FUN = sqrt and FUN = `[[`. It is deprecated.
[16:59:37.351] future_lapply() ...
[16:59:37.355] Number of chunks: 2
[16:59:37.355] getGlobalsAndPackagesXApply() ...
[16:59:37.355]  - future.globals: TRUE
[16:59:37.355] getGlobalsAndPackages() ...
[16:59:37.355] Searching for globals...
[16:59:37.356] - globals found: [2] ‘FUN’, ‘UseMethod’
[16:59:37.357] Searching for globals ... DONE
[16:59:37.357] Resolving globals: FALSE
[16:59:37.357] The total size of the 1 globals is 1.21 KiB (1240 bytes)
[16:59:37.360] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.21 KiB of class ‘function’)
[16:59:37.360] - globals: [1] ‘FUN’
[16:59:37.360] 
[16:59:37.360] getGlobalsAndPackages() ... DONE
[16:59:37.360]  - globals found/used: [n=1] ‘FUN’
[16:59:37.360]  - needed namespaces: [n=0] 
[16:59:37.360] Finding globals ... DONE
[16:59:37.360]  - use_args: TRUE
[16:59:37.360]  - Getting '...' globals ...
[16:59:37.361] resolve() on list ...
[16:59:37.361]  recursive: 0
[16:59:37.361]  length: 1
[16:59:37.361]  elements: ‘...’
[16:59:37.361]  length: 0 (resolved future 1)
[16:59:37.361] resolve() on list ... DONE
[16:59:37.361]    - '...' content: [n=0] 
[16:59:37.361] List of 1
[16:59:37.361]  $ ...: list()
[16:59:37.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.361]  - attr(*, "where")=List of 1
[16:59:37.361]   ..$ ...:<environment: 0x562055283d68> 
[16:59:37.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.361]  - attr(*, "resolved")= logi TRUE
[16:59:37.361]  - attr(*, "total_size")= num NA
[16:59:37.364]  - Getting '...' globals ... DONE
[16:59:37.364] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:59:37.364] List of 2
[16:59:37.364]  $ ...future.FUN:function (object, ...)  
[16:59:37.364]  $ ...          : list()
[16:59:37.364]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:59:37.364]  - attr(*, "where")=List of 2
[16:59:37.364]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:59:37.364]   ..$ ...          :<environment: 0x562055283d68> 
[16:59:37.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:59:37.364]  - attr(*, "resolved")= logi FALSE
[16:59:37.364]  - attr(*, "total_size")= num 1240
[16:59:37.367] Packages to be attached in all futures: [n=0] 
[16:59:37.367] getGlobalsAndPackagesXApply() ... DONE
[16:59:37.367] Number of futures (= number of chunks): 2
[16:59:37.367] Launching 2 futures (chunks) ...
[16:59:37.367] Chunk #1 of 2 ...
[16:59:37.367]  - Finding globals in 'X' for chunk #1 ...
[16:59:37.367] getGlobalsAndPackages() ...
[16:59:37.367] Searching for globals...
[16:59:37.368] 
[16:59:37.368] Searching for globals ... DONE
[16:59:37.368] - globals: [0] <none>
[16:59:37.368] getGlobalsAndPackages() ... DONE
[16:59:37.368]    + additional globals found: [n=0] 
[16:59:37.368]    + additional namespaces needed: [n=0] 
[16:59:37.368]  - Finding globals in 'X' for chunk #1 ... DONE
[16:59:37.368]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:37.368]  - seeds: <none>
[16:59:37.369]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.369] getGlobalsAndPackages() ...
[16:59:37.369] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.369] Resolving globals: FALSE
[16:59:37.369] Tweak future expression to call with '...' arguments ...
[16:59:37.369] {
[16:59:37.369]     do.call(function(...) {
[16:59:37.369]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.369]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.369]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.369]             on.exit(options(oopts), add = TRUE)
[16:59:37.369]         }
[16:59:37.369]         {
[16:59:37.369]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.369]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.369]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.369]             })
[16:59:37.369]         }
[16:59:37.369]     }, args = future.call.arguments)
[16:59:37.369] }
[16:59:37.369] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.370] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.370] 
[16:59:37.370] getGlobalsAndPackages() ... DONE
[16:59:37.370] run() for ‘Future’ ...
[16:59:37.370] - state: ‘created’
[16:59:37.370] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.386] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.386]   - Field: ‘node’
[16:59:37.386]   - Field: ‘label’
[16:59:37.386]   - Field: ‘local’
[16:59:37.386]   - Field: ‘owner’
[16:59:37.386]   - Field: ‘envir’
[16:59:37.387]   - Field: ‘workers’
[16:59:37.387]   - Field: ‘packages’
[16:59:37.387]   - Field: ‘gc’
[16:59:37.387]   - Field: ‘conditions’
[16:59:37.387]   - Field: ‘persistent’
[16:59:37.387]   - Field: ‘expr’
[16:59:37.387]   - Field: ‘uuid’
[16:59:37.387]   - Field: ‘seed’
[16:59:37.387]   - Field: ‘version’
[16:59:37.387]   - Field: ‘result’
[16:59:37.387]   - Field: ‘asynchronous’
[16:59:37.388]   - Field: ‘calls’
[16:59:37.388]   - Field: ‘globals’
[16:59:37.388]   - Field: ‘stdout’
[16:59:37.388]   - Field: ‘earlySignal’
[16:59:37.388]   - Field: ‘lazy’
[16:59:37.388]   - Field: ‘state’
[16:59:37.388] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.388] - Launch lazy future ...
[16:59:37.389] Packages needed by the future expression (n = 0): <none>
[16:59:37.389] Packages needed by future strategies (n = 0): <none>
[16:59:37.389] {
[16:59:37.389]     {
[16:59:37.389]         {
[16:59:37.389]             ...future.startTime <- base::Sys.time()
[16:59:37.389]             {
[16:59:37.389]                 {
[16:59:37.389]                   {
[16:59:37.389]                     {
[16:59:37.389]                       base::local({
[16:59:37.389]                         has_future <- base::requireNamespace("future", 
[16:59:37.389]                           quietly = TRUE)
[16:59:37.389]                         if (has_future) {
[16:59:37.389]                           ns <- base::getNamespace("future")
[16:59:37.389]                           version <- ns[[".package"]][["version"]]
[16:59:37.389]                           if (is.null(version)) 
[16:59:37.389]                             version <- utils::packageVersion("future")
[16:59:37.389]                         }
[16:59:37.389]                         else {
[16:59:37.389]                           version <- NULL
[16:59:37.389]                         }
[16:59:37.389]                         if (!has_future || version < "1.8.0") {
[16:59:37.389]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.389]                             "", base::R.version$version.string), 
[16:59:37.389]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.389]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.389]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.389]                               "release", "version")], collapse = " "), 
[16:59:37.389]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.389]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.389]                             info)
[16:59:37.389]                           info <- base::paste(info, collapse = "; ")
[16:59:37.389]                           if (!has_future) {
[16:59:37.389]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.389]                               info)
[16:59:37.389]                           }
[16:59:37.389]                           else {
[16:59:37.389]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.389]                               info, version)
[16:59:37.389]                           }
[16:59:37.389]                           base::stop(msg)
[16:59:37.389]                         }
[16:59:37.389]                       })
[16:59:37.389]                     }
[16:59:37.389]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.389]                     base::options(mc.cores = 1L)
[16:59:37.389]                   }
[16:59:37.389]                   ...future.strategy.old <- future::plan("list")
[16:59:37.389]                   options(future.plan = NULL)
[16:59:37.389]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.389]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.389]                 }
[16:59:37.389]                 ...future.workdir <- getwd()
[16:59:37.389]             }
[16:59:37.389]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.389]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.389]         }
[16:59:37.389]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.389]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.389]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.389]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.389]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.389]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.389]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.389]             base::names(...future.oldOptions))
[16:59:37.389]     }
[16:59:37.389]     if (FALSE) {
[16:59:37.389]     }
[16:59:37.389]     else {
[16:59:37.389]         if (TRUE) {
[16:59:37.389]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.389]                 open = "w")
[16:59:37.389]         }
[16:59:37.389]         else {
[16:59:37.389]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.389]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.389]         }
[16:59:37.389]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.389]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.389]             base::sink(type = "output", split = FALSE)
[16:59:37.389]             base::close(...future.stdout)
[16:59:37.389]         }, add = TRUE)
[16:59:37.389]     }
[16:59:37.389]     ...future.frame <- base::sys.nframe()
[16:59:37.389]     ...future.conditions <- base::list()
[16:59:37.389]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.389]     if (FALSE) {
[16:59:37.389]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.389]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.389]     }
[16:59:37.389]     ...future.result <- base::tryCatch({
[16:59:37.389]         base::withCallingHandlers({
[16:59:37.389]             ...future.value <- base::withVisible(base::local({
[16:59:37.389]                 ...future.makeSendCondition <- base::local({
[16:59:37.389]                   sendCondition <- NULL
[16:59:37.389]                   function(frame = 1L) {
[16:59:37.389]                     if (is.function(sendCondition)) 
[16:59:37.389]                       return(sendCondition)
[16:59:37.389]                     ns <- getNamespace("parallel")
[16:59:37.389]                     if (exists("sendData", mode = "function", 
[16:59:37.389]                       envir = ns)) {
[16:59:37.389]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.389]                         envir = ns)
[16:59:37.389]                       envir <- sys.frame(frame)
[16:59:37.389]                       master <- NULL
[16:59:37.389]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.389]                         !identical(envir, emptyenv())) {
[16:59:37.389]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.389]                           inherits = FALSE)) {
[16:59:37.389]                           master <- get("master", mode = "list", 
[16:59:37.389]                             envir = envir, inherits = FALSE)
[16:59:37.389]                           if (inherits(master, c("SOCKnode", 
[16:59:37.389]                             "SOCK0node"))) {
[16:59:37.389]                             sendCondition <<- function(cond) {
[16:59:37.389]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.389]                                 success = TRUE)
[16:59:37.389]                               parallel_sendData(master, data)
[16:59:37.389]                             }
[16:59:37.389]                             return(sendCondition)
[16:59:37.389]                           }
[16:59:37.389]                         }
[16:59:37.389]                         frame <- frame + 1L
[16:59:37.389]                         envir <- sys.frame(frame)
[16:59:37.389]                       }
[16:59:37.389]                     }
[16:59:37.389]                     sendCondition <<- function(cond) NULL
[16:59:37.389]                   }
[16:59:37.389]                 })
[16:59:37.389]                 withCallingHandlers({
[16:59:37.389]                   {
[16:59:37.389]                     do.call(function(...) {
[16:59:37.389]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.389]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.389]                         ...future.globals.maxSize)) {
[16:59:37.389]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.389]                         on.exit(options(oopts), add = TRUE)
[16:59:37.389]                       }
[16:59:37.389]                       {
[16:59:37.389]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.389]                           FUN = function(jj) {
[16:59:37.389]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.389]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.389]                           })
[16:59:37.389]                       }
[16:59:37.389]                     }, args = future.call.arguments)
[16:59:37.389]                   }
[16:59:37.389]                 }, immediateCondition = function(cond) {
[16:59:37.389]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.389]                   sendCondition(cond)
[16:59:37.389]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.389]                   {
[16:59:37.389]                     inherits <- base::inherits
[16:59:37.389]                     invokeRestart <- base::invokeRestart
[16:59:37.389]                     is.null <- base::is.null
[16:59:37.389]                     muffled <- FALSE
[16:59:37.389]                     if (inherits(cond, "message")) {
[16:59:37.389]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.389]                       if (muffled) 
[16:59:37.389]                         invokeRestart("muffleMessage")
[16:59:37.389]                     }
[16:59:37.389]                     else if (inherits(cond, "warning")) {
[16:59:37.389]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.389]                       if (muffled) 
[16:59:37.389]                         invokeRestart("muffleWarning")
[16:59:37.389]                     }
[16:59:37.389]                     else if (inherits(cond, "condition")) {
[16:59:37.389]                       if (!is.null(pattern)) {
[16:59:37.389]                         computeRestarts <- base::computeRestarts
[16:59:37.389]                         grepl <- base::grepl
[16:59:37.389]                         restarts <- computeRestarts(cond)
[16:59:37.389]                         for (restart in restarts) {
[16:59:37.389]                           name <- restart$name
[16:59:37.389]                           if (is.null(name)) 
[16:59:37.389]                             next
[16:59:37.389]                           if (!grepl(pattern, name)) 
[16:59:37.389]                             next
[16:59:37.389]                           invokeRestart(restart)
[16:59:37.389]                           muffled <- TRUE
[16:59:37.389]                           break
[16:59:37.389]                         }
[16:59:37.389]                       }
[16:59:37.389]                     }
[16:59:37.389]                     invisible(muffled)
[16:59:37.389]                   }
[16:59:37.389]                   muffleCondition(cond)
[16:59:37.389]                 })
[16:59:37.389]             }))
[16:59:37.389]             future::FutureResult(value = ...future.value$value, 
[16:59:37.389]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.389]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.389]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.389]                     ...future.globalenv.names))
[16:59:37.389]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.389]         }, condition = base::local({
[16:59:37.389]             c <- base::c
[16:59:37.389]             inherits <- base::inherits
[16:59:37.389]             invokeRestart <- base::invokeRestart
[16:59:37.389]             length <- base::length
[16:59:37.389]             list <- base::list
[16:59:37.389]             seq.int <- base::seq.int
[16:59:37.389]             signalCondition <- base::signalCondition
[16:59:37.389]             sys.calls <- base::sys.calls
[16:59:37.389]             `[[` <- base::`[[`
[16:59:37.389]             `+` <- base::`+`
[16:59:37.389]             `<<-` <- base::`<<-`
[16:59:37.389]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.389]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.389]                   3L)]
[16:59:37.389]             }
[16:59:37.389]             function(cond) {
[16:59:37.389]                 is_error <- inherits(cond, "error")
[16:59:37.389]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.389]                   NULL)
[16:59:37.389]                 if (is_error) {
[16:59:37.389]                   sessionInformation <- function() {
[16:59:37.389]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.389]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.389]                       search = base::search(), system = base::Sys.info())
[16:59:37.389]                   }
[16:59:37.389]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.389]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.389]                     cond$call), session = sessionInformation(), 
[16:59:37.389]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.389]                   signalCondition(cond)
[16:59:37.389]                 }
[16:59:37.389]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.389]                 "immediateCondition"))) {
[16:59:37.389]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.389]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.389]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.389]                   if (TRUE && !signal) {
[16:59:37.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.389]                     {
[16:59:37.389]                       inherits <- base::inherits
[16:59:37.389]                       invokeRestart <- base::invokeRestart
[16:59:37.389]                       is.null <- base::is.null
[16:59:37.389]                       muffled <- FALSE
[16:59:37.389]                       if (inherits(cond, "message")) {
[16:59:37.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.389]                         if (muffled) 
[16:59:37.389]                           invokeRestart("muffleMessage")
[16:59:37.389]                       }
[16:59:37.389]                       else if (inherits(cond, "warning")) {
[16:59:37.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.389]                         if (muffled) 
[16:59:37.389]                           invokeRestart("muffleWarning")
[16:59:37.389]                       }
[16:59:37.389]                       else if (inherits(cond, "condition")) {
[16:59:37.389]                         if (!is.null(pattern)) {
[16:59:37.389]                           computeRestarts <- base::computeRestarts
[16:59:37.389]                           grepl <- base::grepl
[16:59:37.389]                           restarts <- computeRestarts(cond)
[16:59:37.389]                           for (restart in restarts) {
[16:59:37.389]                             name <- restart$name
[16:59:37.389]                             if (is.null(name)) 
[16:59:37.389]                               next
[16:59:37.389]                             if (!grepl(pattern, name)) 
[16:59:37.389]                               next
[16:59:37.389]                             invokeRestart(restart)
[16:59:37.389]                             muffled <- TRUE
[16:59:37.389]                             break
[16:59:37.389]                           }
[16:59:37.389]                         }
[16:59:37.389]                       }
[16:59:37.389]                       invisible(muffled)
[16:59:37.389]                     }
[16:59:37.389]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.389]                   }
[16:59:37.389]                 }
[16:59:37.389]                 else {
[16:59:37.389]                   if (TRUE) {
[16:59:37.389]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.389]                     {
[16:59:37.389]                       inherits <- base::inherits
[16:59:37.389]                       invokeRestart <- base::invokeRestart
[16:59:37.389]                       is.null <- base::is.null
[16:59:37.389]                       muffled <- FALSE
[16:59:37.389]                       if (inherits(cond, "message")) {
[16:59:37.389]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.389]                         if (muffled) 
[16:59:37.389]                           invokeRestart("muffleMessage")
[16:59:37.389]                       }
[16:59:37.389]                       else if (inherits(cond, "warning")) {
[16:59:37.389]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.389]                         if (muffled) 
[16:59:37.389]                           invokeRestart("muffleWarning")
[16:59:37.389]                       }
[16:59:37.389]                       else if (inherits(cond, "condition")) {
[16:59:37.389]                         if (!is.null(pattern)) {
[16:59:37.389]                           computeRestarts <- base::computeRestarts
[16:59:37.389]                           grepl <- base::grepl
[16:59:37.389]                           restarts <- computeRestarts(cond)
[16:59:37.389]                           for (restart in restarts) {
[16:59:37.389]                             name <- restart$name
[16:59:37.389]                             if (is.null(name)) 
[16:59:37.389]                               next
[16:59:37.389]                             if (!grepl(pattern, name)) 
[16:59:37.389]                               next
[16:59:37.389]                             invokeRestart(restart)
[16:59:37.389]                             muffled <- TRUE
[16:59:37.389]                             break
[16:59:37.389]                           }
[16:59:37.389]                         }
[16:59:37.389]                       }
[16:59:37.389]                       invisible(muffled)
[16:59:37.389]                     }
[16:59:37.389]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.389]                   }
[16:59:37.389]                 }
[16:59:37.389]             }
[16:59:37.389]         }))
[16:59:37.389]     }, error = function(ex) {
[16:59:37.389]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.389]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.389]                 ...future.rng), started = ...future.startTime, 
[16:59:37.389]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.389]             version = "1.8"), class = "FutureResult")
[16:59:37.389]     }, finally = {
[16:59:37.389]         if (!identical(...future.workdir, getwd())) 
[16:59:37.389]             setwd(...future.workdir)
[16:59:37.389]         {
[16:59:37.389]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.389]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.389]             }
[16:59:37.389]             base::options(...future.oldOptions)
[16:59:37.389]             if (.Platform$OS.type == "windows") {
[16:59:37.389]                 old_names <- names(...future.oldEnvVars)
[16:59:37.389]                 envs <- base::Sys.getenv()
[16:59:37.389]                 names <- names(envs)
[16:59:37.389]                 common <- intersect(names, old_names)
[16:59:37.389]                 added <- setdiff(names, old_names)
[16:59:37.389]                 removed <- setdiff(old_names, names)
[16:59:37.389]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.389]                   envs[common]]
[16:59:37.389]                 NAMES <- toupper(changed)
[16:59:37.389]                 args <- list()
[16:59:37.389]                 for (kk in seq_along(NAMES)) {
[16:59:37.389]                   name <- changed[[kk]]
[16:59:37.389]                   NAME <- NAMES[[kk]]
[16:59:37.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.389]                     next
[16:59:37.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.389]                 }
[16:59:37.389]                 NAMES <- toupper(added)
[16:59:37.389]                 for (kk in seq_along(NAMES)) {
[16:59:37.389]                   name <- added[[kk]]
[16:59:37.389]                   NAME <- NAMES[[kk]]
[16:59:37.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.389]                     next
[16:59:37.389]                   args[[name]] <- ""
[16:59:37.389]                 }
[16:59:37.389]                 NAMES <- toupper(removed)
[16:59:37.389]                 for (kk in seq_along(NAMES)) {
[16:59:37.389]                   name <- removed[[kk]]
[16:59:37.389]                   NAME <- NAMES[[kk]]
[16:59:37.389]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.389]                     next
[16:59:37.389]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.389]                 }
[16:59:37.389]                 if (length(args) > 0) 
[16:59:37.389]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.389]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.389]             }
[16:59:37.389]             else {
[16:59:37.389]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.389]             }
[16:59:37.389]             {
[16:59:37.389]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.389]                   0L) {
[16:59:37.389]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.389]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.389]                   base::options(opts)
[16:59:37.389]                 }
[16:59:37.389]                 {
[16:59:37.389]                   {
[16:59:37.389]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.389]                     NULL
[16:59:37.389]                   }
[16:59:37.389]                   options(future.plan = NULL)
[16:59:37.389]                   if (is.na(NA_character_)) 
[16:59:37.389]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.389]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.389]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.389]                     .init = FALSE)
[16:59:37.389]                 }
[16:59:37.389]             }
[16:59:37.389]         }
[16:59:37.389]     })
[16:59:37.389]     if (TRUE) {
[16:59:37.389]         base::sink(type = "output", split = FALSE)
[16:59:37.389]         if (TRUE) {
[16:59:37.389]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.389]         }
[16:59:37.389]         else {
[16:59:37.389]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.389]         }
[16:59:37.389]         base::close(...future.stdout)
[16:59:37.389]         ...future.stdout <- NULL
[16:59:37.389]     }
[16:59:37.389]     ...future.result$conditions <- ...future.conditions
[16:59:37.389]     ...future.result$finished <- base::Sys.time()
[16:59:37.389]     ...future.result
[16:59:37.389] }
[16:59:37.392] Exporting 5 global objects (1.21 KiB) to cluster node #1 ...
[16:59:37.392] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ...
[16:59:37.392] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #1 ... DONE
[16:59:37.393] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:59:37.393] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.393] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ...
[16:59:37.393] Exporting ‘...future.elements_ii’ (1.60 KiB) to cluster node #1 ... DONE
[16:59:37.394] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:59:37.394] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.394] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:59:37.394] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:59:37.394] Exporting 5 global objects (1.21 KiB) to cluster node #1 ... DONE
[16:59:37.395] MultisessionFuture started
[16:59:37.395] - Launch lazy future ... done
[16:59:37.395] run() for ‘MultisessionFuture’ ... done
[16:59:37.395] Created future:
[16:59:37.395] MultisessionFuture:
[16:59:37.395] Label: ‘future_by-1’
[16:59:37.395] Expression:
[16:59:37.395] {
[16:59:37.395]     do.call(function(...) {
[16:59:37.395]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.395]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.395]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.395]             on.exit(options(oopts), add = TRUE)
[16:59:37.395]         }
[16:59:37.395]         {
[16:59:37.395]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.395]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.395]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.395]             })
[16:59:37.395]         }
[16:59:37.395]     }, args = future.call.arguments)
[16:59:37.395] }
[16:59:37.395] Lazy evaluation: FALSE
[16:59:37.395] Asynchronous evaluation: TRUE
[16:59:37.395] Local evaluation: TRUE
[16:59:37.395] Environment: 0x5620552517e0
[16:59:37.395] Capture standard output: TRUE
[16:59:37.395] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.395] Globals: 5 objects totaling 2.81 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 1.60 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.395] Packages: <none>
[16:59:37.395] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.395] Resolved: FALSE
[16:59:37.395] Value: <not collected>
[16:59:37.395] Conditions captured: <none>
[16:59:37.395] Early signaling: FALSE
[16:59:37.395] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.395] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.407] Chunk #1 of 2 ... DONE
[16:59:37.407] Chunk #2 of 2 ...
[16:59:37.407]  - Finding globals in 'X' for chunk #2 ...
[16:59:37.408] getGlobalsAndPackages() ...
[16:59:37.408] Searching for globals...
[16:59:37.408] 
[16:59:37.408] Searching for globals ... DONE
[16:59:37.408] - globals: [0] <none>
[16:59:37.408] getGlobalsAndPackages() ... DONE
[16:59:37.409]    + additional globals found: [n=0] 
[16:59:37.409]    + additional namespaces needed: [n=0] 
[16:59:37.409]  - Finding globals in 'X' for chunk #2 ... DONE
[16:59:37.409]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:59:37.409]  - seeds: <none>
[16:59:37.409]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.409] getGlobalsAndPackages() ...
[16:59:37.409] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.409] Resolving globals: FALSE
[16:59:37.409] Tweak future expression to call with '...' arguments ...
[16:59:37.410] {
[16:59:37.410]     do.call(function(...) {
[16:59:37.410]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.410]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.410]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.410]             on.exit(options(oopts), add = TRUE)
[16:59:37.410]         }
[16:59:37.410]         {
[16:59:37.410]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.410]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.410]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.410]             })
[16:59:37.410]         }
[16:59:37.410]     }, args = future.call.arguments)
[16:59:37.410] }
[16:59:37.410] Tweak future expression to call with '...' arguments ... DONE
[16:59:37.410] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:59:37.410] 
[16:59:37.410] getGlobalsAndPackages() ... DONE
[16:59:37.411] run() for ‘Future’ ...
[16:59:37.411] - state: ‘created’
[16:59:37.411] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:59:37.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:59:37.426]   - Field: ‘node’
[16:59:37.426]   - Field: ‘label’
[16:59:37.426]   - Field: ‘local’
[16:59:37.426]   - Field: ‘owner’
[16:59:37.426]   - Field: ‘envir’
[16:59:37.426]   - Field: ‘workers’
[16:59:37.426]   - Field: ‘packages’
[16:59:37.427]   - Field: ‘gc’
[16:59:37.427]   - Field: ‘conditions’
[16:59:37.427]   - Field: ‘persistent’
[16:59:37.427]   - Field: ‘expr’
[16:59:37.427]   - Field: ‘uuid’
[16:59:37.427]   - Field: ‘seed’
[16:59:37.427]   - Field: ‘version’
[16:59:37.427]   - Field: ‘result’
[16:59:37.427]   - Field: ‘asynchronous’
[16:59:37.427]   - Field: ‘calls’
[16:59:37.428]   - Field: ‘globals’
[16:59:37.428]   - Field: ‘stdout’
[16:59:37.428]   - Field: ‘earlySignal’
[16:59:37.428]   - Field: ‘lazy’
[16:59:37.428]   - Field: ‘state’
[16:59:37.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:59:37.428] - Launch lazy future ...
[16:59:37.428] Packages needed by the future expression (n = 0): <none>
[16:59:37.429] Packages needed by future strategies (n = 0): <none>
[16:59:37.429] {
[16:59:37.429]     {
[16:59:37.429]         {
[16:59:37.429]             ...future.startTime <- base::Sys.time()
[16:59:37.429]             {
[16:59:37.429]                 {
[16:59:37.429]                   {
[16:59:37.429]                     {
[16:59:37.429]                       base::local({
[16:59:37.429]                         has_future <- base::requireNamespace("future", 
[16:59:37.429]                           quietly = TRUE)
[16:59:37.429]                         if (has_future) {
[16:59:37.429]                           ns <- base::getNamespace("future")
[16:59:37.429]                           version <- ns[[".package"]][["version"]]
[16:59:37.429]                           if (is.null(version)) 
[16:59:37.429]                             version <- utils::packageVersion("future")
[16:59:37.429]                         }
[16:59:37.429]                         else {
[16:59:37.429]                           version <- NULL
[16:59:37.429]                         }
[16:59:37.429]                         if (!has_future || version < "1.8.0") {
[16:59:37.429]                           info <- base::c(r_version = base::gsub("R version ", 
[16:59:37.429]                             "", base::R.version$version.string), 
[16:59:37.429]                             platform = base::sprintf("%s (%s-bit)", 
[16:59:37.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:59:37.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:59:37.429]                               "release", "version")], collapse = " "), 
[16:59:37.429]                             hostname = base::Sys.info()[["nodename"]])
[16:59:37.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:59:37.429]                             info)
[16:59:37.429]                           info <- base::paste(info, collapse = "; ")
[16:59:37.429]                           if (!has_future) {
[16:59:37.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:59:37.429]                               info)
[16:59:37.429]                           }
[16:59:37.429]                           else {
[16:59:37.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:59:37.429]                               info, version)
[16:59:37.429]                           }
[16:59:37.429]                           base::stop(msg)
[16:59:37.429]                         }
[16:59:37.429]                       })
[16:59:37.429]                     }
[16:59:37.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:59:37.429]                     base::options(mc.cores = 1L)
[16:59:37.429]                   }
[16:59:37.429]                   ...future.strategy.old <- future::plan("list")
[16:59:37.429]                   options(future.plan = NULL)
[16:59:37.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:59:37.429]                 }
[16:59:37.429]                 ...future.workdir <- getwd()
[16:59:37.429]             }
[16:59:37.429]             ...future.oldOptions <- base::as.list(base::.Options)
[16:59:37.429]             ...future.oldEnvVars <- base::Sys.getenv()
[16:59:37.429]         }
[16:59:37.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:59:37.429]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:59:37.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:59:37.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:59:37.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:59:37.429]             future.stdout.windows.reencode = NULL, width = 80L)
[16:59:37.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:59:37.429]             base::names(...future.oldOptions))
[16:59:37.429]     }
[16:59:37.429]     if (FALSE) {
[16:59:37.429]     }
[16:59:37.429]     else {
[16:59:37.429]         if (TRUE) {
[16:59:37.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:59:37.429]                 open = "w")
[16:59:37.429]         }
[16:59:37.429]         else {
[16:59:37.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:59:37.429]                 windows = "NUL", "/dev/null"), open = "w")
[16:59:37.429]         }
[16:59:37.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:59:37.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:59:37.429]             base::sink(type = "output", split = FALSE)
[16:59:37.429]             base::close(...future.stdout)
[16:59:37.429]         }, add = TRUE)
[16:59:37.429]     }
[16:59:37.429]     ...future.frame <- base::sys.nframe()
[16:59:37.429]     ...future.conditions <- base::list()
[16:59:37.429]     ...future.rng <- base::globalenv()$.Random.seed
[16:59:37.429]     if (FALSE) {
[16:59:37.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:59:37.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:59:37.429]     }
[16:59:37.429]     ...future.result <- base::tryCatch({
[16:59:37.429]         base::withCallingHandlers({
[16:59:37.429]             ...future.value <- base::withVisible(base::local({
[16:59:37.429]                 ...future.makeSendCondition <- base::local({
[16:59:37.429]                   sendCondition <- NULL
[16:59:37.429]                   function(frame = 1L) {
[16:59:37.429]                     if (is.function(sendCondition)) 
[16:59:37.429]                       return(sendCondition)
[16:59:37.429]                     ns <- getNamespace("parallel")
[16:59:37.429]                     if (exists("sendData", mode = "function", 
[16:59:37.429]                       envir = ns)) {
[16:59:37.429]                       parallel_sendData <- get("sendData", mode = "function", 
[16:59:37.429]                         envir = ns)
[16:59:37.429]                       envir <- sys.frame(frame)
[16:59:37.429]                       master <- NULL
[16:59:37.429]                       while (!identical(envir, .GlobalEnv) && 
[16:59:37.429]                         !identical(envir, emptyenv())) {
[16:59:37.429]                         if (exists("master", mode = "list", envir = envir, 
[16:59:37.429]                           inherits = FALSE)) {
[16:59:37.429]                           master <- get("master", mode = "list", 
[16:59:37.429]                             envir = envir, inherits = FALSE)
[16:59:37.429]                           if (inherits(master, c("SOCKnode", 
[16:59:37.429]                             "SOCK0node"))) {
[16:59:37.429]                             sendCondition <<- function(cond) {
[16:59:37.429]                               data <- list(type = "VALUE", value = cond, 
[16:59:37.429]                                 success = TRUE)
[16:59:37.429]                               parallel_sendData(master, data)
[16:59:37.429]                             }
[16:59:37.429]                             return(sendCondition)
[16:59:37.429]                           }
[16:59:37.429]                         }
[16:59:37.429]                         frame <- frame + 1L
[16:59:37.429]                         envir <- sys.frame(frame)
[16:59:37.429]                       }
[16:59:37.429]                     }
[16:59:37.429]                     sendCondition <<- function(cond) NULL
[16:59:37.429]                   }
[16:59:37.429]                 })
[16:59:37.429]                 withCallingHandlers({
[16:59:37.429]                   {
[16:59:37.429]                     do.call(function(...) {
[16:59:37.429]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.429]                       if (!identical(...future.globals.maxSize.org, 
[16:59:37.429]                         ...future.globals.maxSize)) {
[16:59:37.429]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.429]                         on.exit(options(oopts), add = TRUE)
[16:59:37.429]                       }
[16:59:37.429]                       {
[16:59:37.429]                         lapply(seq_along(...future.elements_ii), 
[16:59:37.429]                           FUN = function(jj) {
[16:59:37.429]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.429]                             ...future.FUN(...future.X_jj, ...)
[16:59:37.429]                           })
[16:59:37.429]                       }
[16:59:37.429]                     }, args = future.call.arguments)
[16:59:37.429]                   }
[16:59:37.429]                 }, immediateCondition = function(cond) {
[16:59:37.429]                   sendCondition <- ...future.makeSendCondition()
[16:59:37.429]                   sendCondition(cond)
[16:59:37.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.429]                   {
[16:59:37.429]                     inherits <- base::inherits
[16:59:37.429]                     invokeRestart <- base::invokeRestart
[16:59:37.429]                     is.null <- base::is.null
[16:59:37.429]                     muffled <- FALSE
[16:59:37.429]                     if (inherits(cond, "message")) {
[16:59:37.429]                       muffled <- grepl(pattern, "muffleMessage")
[16:59:37.429]                       if (muffled) 
[16:59:37.429]                         invokeRestart("muffleMessage")
[16:59:37.429]                     }
[16:59:37.429]                     else if (inherits(cond, "warning")) {
[16:59:37.429]                       muffled <- grepl(pattern, "muffleWarning")
[16:59:37.429]                       if (muffled) 
[16:59:37.429]                         invokeRestart("muffleWarning")
[16:59:37.429]                     }
[16:59:37.429]                     else if (inherits(cond, "condition")) {
[16:59:37.429]                       if (!is.null(pattern)) {
[16:59:37.429]                         computeRestarts <- base::computeRestarts
[16:59:37.429]                         grepl <- base::grepl
[16:59:37.429]                         restarts <- computeRestarts(cond)
[16:59:37.429]                         for (restart in restarts) {
[16:59:37.429]                           name <- restart$name
[16:59:37.429]                           if (is.null(name)) 
[16:59:37.429]                             next
[16:59:37.429]                           if (!grepl(pattern, name)) 
[16:59:37.429]                             next
[16:59:37.429]                           invokeRestart(restart)
[16:59:37.429]                           muffled <- TRUE
[16:59:37.429]                           break
[16:59:37.429]                         }
[16:59:37.429]                       }
[16:59:37.429]                     }
[16:59:37.429]                     invisible(muffled)
[16:59:37.429]                   }
[16:59:37.429]                   muffleCondition(cond)
[16:59:37.429]                 })
[16:59:37.429]             }))
[16:59:37.429]             future::FutureResult(value = ...future.value$value, 
[16:59:37.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.429]                   ...future.rng), globalenv = if (FALSE) 
[16:59:37.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:59:37.429]                     ...future.globalenv.names))
[16:59:37.429]                 else NULL, started = ...future.startTime, version = "1.8")
[16:59:37.429]         }, condition = base::local({
[16:59:37.429]             c <- base::c
[16:59:37.429]             inherits <- base::inherits
[16:59:37.429]             invokeRestart <- base::invokeRestart
[16:59:37.429]             length <- base::length
[16:59:37.429]             list <- base::list
[16:59:37.429]             seq.int <- base::seq.int
[16:59:37.429]             signalCondition <- base::signalCondition
[16:59:37.429]             sys.calls <- base::sys.calls
[16:59:37.429]             `[[` <- base::`[[`
[16:59:37.429]             `+` <- base::`+`
[16:59:37.429]             `<<-` <- base::`<<-`
[16:59:37.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:59:37.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:59:37.429]                   3L)]
[16:59:37.429]             }
[16:59:37.429]             function(cond) {
[16:59:37.429]                 is_error <- inherits(cond, "error")
[16:59:37.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:59:37.429]                   NULL)
[16:59:37.429]                 if (is_error) {
[16:59:37.429]                   sessionInformation <- function() {
[16:59:37.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:59:37.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:59:37.429]                       search = base::search(), system = base::Sys.info())
[16:59:37.429]                   }
[16:59:37.429]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:59:37.429]                     cond$call), session = sessionInformation(), 
[16:59:37.429]                     timestamp = base::Sys.time(), signaled = 0L)
[16:59:37.429]                   signalCondition(cond)
[16:59:37.429]                 }
[16:59:37.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:59:37.429]                 "immediateCondition"))) {
[16:59:37.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:59:37.429]                   ...future.conditions[[length(...future.conditions) + 
[16:59:37.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:59:37.429]                   if (TRUE && !signal) {
[16:59:37.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.429]                     {
[16:59:37.429]                       inherits <- base::inherits
[16:59:37.429]                       invokeRestart <- base::invokeRestart
[16:59:37.429]                       is.null <- base::is.null
[16:59:37.429]                       muffled <- FALSE
[16:59:37.429]                       if (inherits(cond, "message")) {
[16:59:37.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.429]                         if (muffled) 
[16:59:37.429]                           invokeRestart("muffleMessage")
[16:59:37.429]                       }
[16:59:37.429]                       else if (inherits(cond, "warning")) {
[16:59:37.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.429]                         if (muffled) 
[16:59:37.429]                           invokeRestart("muffleWarning")
[16:59:37.429]                       }
[16:59:37.429]                       else if (inherits(cond, "condition")) {
[16:59:37.429]                         if (!is.null(pattern)) {
[16:59:37.429]                           computeRestarts <- base::computeRestarts
[16:59:37.429]                           grepl <- base::grepl
[16:59:37.429]                           restarts <- computeRestarts(cond)
[16:59:37.429]                           for (restart in restarts) {
[16:59:37.429]                             name <- restart$name
[16:59:37.429]                             if (is.null(name)) 
[16:59:37.429]                               next
[16:59:37.429]                             if (!grepl(pattern, name)) 
[16:59:37.429]                               next
[16:59:37.429]                             invokeRestart(restart)
[16:59:37.429]                             muffled <- TRUE
[16:59:37.429]                             break
[16:59:37.429]                           }
[16:59:37.429]                         }
[16:59:37.429]                       }
[16:59:37.429]                       invisible(muffled)
[16:59:37.429]                     }
[16:59:37.429]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.429]                   }
[16:59:37.429]                 }
[16:59:37.429]                 else {
[16:59:37.429]                   if (TRUE) {
[16:59:37.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:59:37.429]                     {
[16:59:37.429]                       inherits <- base::inherits
[16:59:37.429]                       invokeRestart <- base::invokeRestart
[16:59:37.429]                       is.null <- base::is.null
[16:59:37.429]                       muffled <- FALSE
[16:59:37.429]                       if (inherits(cond, "message")) {
[16:59:37.429]                         muffled <- grepl(pattern, "muffleMessage")
[16:59:37.429]                         if (muffled) 
[16:59:37.429]                           invokeRestart("muffleMessage")
[16:59:37.429]                       }
[16:59:37.429]                       else if (inherits(cond, "warning")) {
[16:59:37.429]                         muffled <- grepl(pattern, "muffleWarning")
[16:59:37.429]                         if (muffled) 
[16:59:37.429]                           invokeRestart("muffleWarning")
[16:59:37.429]                       }
[16:59:37.429]                       else if (inherits(cond, "condition")) {
[16:59:37.429]                         if (!is.null(pattern)) {
[16:59:37.429]                           computeRestarts <- base::computeRestarts
[16:59:37.429]                           grepl <- base::grepl
[16:59:37.429]                           restarts <- computeRestarts(cond)
[16:59:37.429]                           for (restart in restarts) {
[16:59:37.429]                             name <- restart$name
[16:59:37.429]                             if (is.null(name)) 
[16:59:37.429]                               next
[16:59:37.429]                             if (!grepl(pattern, name)) 
[16:59:37.429]                               next
[16:59:37.429]                             invokeRestart(restart)
[16:59:37.429]                             muffled <- TRUE
[16:59:37.429]                             break
[16:59:37.429]                           }
[16:59:37.429]                         }
[16:59:37.429]                       }
[16:59:37.429]                       invisible(muffled)
[16:59:37.429]                     }
[16:59:37.429]                     muffleCondition(cond, pattern = "^muffle")
[16:59:37.429]                   }
[16:59:37.429]                 }
[16:59:37.429]             }
[16:59:37.429]         }))
[16:59:37.429]     }, error = function(ex) {
[16:59:37.429]         base::structure(base::list(value = NULL, visible = NULL, 
[16:59:37.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:59:37.429]                 ...future.rng), started = ...future.startTime, 
[16:59:37.429]             finished = Sys.time(), session_uuid = NA_character_, 
[16:59:37.429]             version = "1.8"), class = "FutureResult")
[16:59:37.429]     }, finally = {
[16:59:37.429]         if (!identical(...future.workdir, getwd())) 
[16:59:37.429]             setwd(...future.workdir)
[16:59:37.429]         {
[16:59:37.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:59:37.429]                 ...future.oldOptions$nwarnings <- NULL
[16:59:37.429]             }
[16:59:37.429]             base::options(...future.oldOptions)
[16:59:37.429]             if (.Platform$OS.type == "windows") {
[16:59:37.429]                 old_names <- names(...future.oldEnvVars)
[16:59:37.429]                 envs <- base::Sys.getenv()
[16:59:37.429]                 names <- names(envs)
[16:59:37.429]                 common <- intersect(names, old_names)
[16:59:37.429]                 added <- setdiff(names, old_names)
[16:59:37.429]                 removed <- setdiff(old_names, names)
[16:59:37.429]                 changed <- common[...future.oldEnvVars[common] != 
[16:59:37.429]                   envs[common]]
[16:59:37.429]                 NAMES <- toupper(changed)
[16:59:37.429]                 args <- list()
[16:59:37.429]                 for (kk in seq_along(NAMES)) {
[16:59:37.429]                   name <- changed[[kk]]
[16:59:37.429]                   NAME <- NAMES[[kk]]
[16:59:37.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.429]                     next
[16:59:37.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.429]                 }
[16:59:37.429]                 NAMES <- toupper(added)
[16:59:37.429]                 for (kk in seq_along(NAMES)) {
[16:59:37.429]                   name <- added[[kk]]
[16:59:37.429]                   NAME <- NAMES[[kk]]
[16:59:37.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.429]                     next
[16:59:37.429]                   args[[name]] <- ""
[16:59:37.429]                 }
[16:59:37.429]                 NAMES <- toupper(removed)
[16:59:37.429]                 for (kk in seq_along(NAMES)) {
[16:59:37.429]                   name <- removed[[kk]]
[16:59:37.429]                   NAME <- NAMES[[kk]]
[16:59:37.429]                   if (name != NAME && is.element(NAME, old_names)) 
[16:59:37.429]                     next
[16:59:37.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:59:37.429]                 }
[16:59:37.429]                 if (length(args) > 0) 
[16:59:37.429]                   base::do.call(base::Sys.setenv, args = args)
[16:59:37.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:59:37.429]             }
[16:59:37.429]             else {
[16:59:37.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:59:37.429]             }
[16:59:37.429]             {
[16:59:37.429]                 if (base::length(...future.futureOptionsAdded) > 
[16:59:37.429]                   0L) {
[16:59:37.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:59:37.429]                   base::names(opts) <- ...future.futureOptionsAdded
[16:59:37.429]                   base::options(opts)
[16:59:37.429]                 }
[16:59:37.429]                 {
[16:59:37.429]                   {
[16:59:37.429]                     base::options(mc.cores = ...future.mc.cores.old)
[16:59:37.429]                     NULL
[16:59:37.429]                   }
[16:59:37.429]                   options(future.plan = NULL)
[16:59:37.429]                   if (is.na(NA_character_)) 
[16:59:37.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:59:37.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:59:37.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:59:37.429]                     .init = FALSE)
[16:59:37.429]                 }
[16:59:37.429]             }
[16:59:37.429]         }
[16:59:37.429]     })
[16:59:37.429]     if (TRUE) {
[16:59:37.429]         base::sink(type = "output", split = FALSE)
[16:59:37.429]         if (TRUE) {
[16:59:37.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:59:37.429]         }
[16:59:37.429]         else {
[16:59:37.429]             ...future.result["stdout"] <- base::list(NULL)
[16:59:37.429]         }
[16:59:37.429]         base::close(...future.stdout)
[16:59:37.429]         ...future.stdout <- NULL
[16:59:37.429]     }
[16:59:37.429]     ...future.result$conditions <- ...future.conditions
[16:59:37.429]     ...future.result$finished <- base::Sys.time()
[16:59:37.429]     ...future.result
[16:59:37.429] }
[16:59:37.432] Exporting 5 global objects (1.21 KiB) to cluster node #2 ...
[16:59:37.432] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ...
[16:59:37.432] Exporting ‘...future.FUN’ (1.21 KiB) to cluster node #2 ... DONE
[16:59:37.433] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:59:37.433] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.433] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ...
[16:59:37.433] Exporting ‘...future.elements_ii’ (3.20 KiB) to cluster node #2 ... DONE
[16:59:37.434] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:59:37.434] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.434] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:59:37.434] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:59:37.434] Exporting 5 global objects (1.21 KiB) to cluster node #2 ... DONE
[16:59:37.435] MultisessionFuture started
[16:59:37.435] - Launch lazy future ... done
[16:59:37.435] run() for ‘MultisessionFuture’ ... done
[16:59:37.435] Created future:
[16:59:37.435] MultisessionFuture:
[16:59:37.435] Label: ‘future_by-2’
[16:59:37.435] Expression:
[16:59:37.435] {
[16:59:37.435]     do.call(function(...) {
[16:59:37.435]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:59:37.435]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:59:37.435]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:59:37.435]             on.exit(options(oopts), add = TRUE)
[16:59:37.435]         }
[16:59:37.435]         {
[16:59:37.435]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:59:37.435]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:59:37.435]                 ...future.FUN(...future.X_jj, ...)
[16:59:37.435]             })
[16:59:37.435]         }
[16:59:37.435]     }, args = future.call.arguments)
[16:59:37.435] }
[16:59:37.435] Lazy evaluation: FALSE
[16:59:37.435] Asynchronous evaluation: TRUE
[16:59:37.435] Local evaluation: TRUE
[16:59:37.435] Environment: 0x5620552517e0
[16:59:37.435] Capture standard output: TRUE
[16:59:37.435] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:59:37.435] Globals: 5 objects totaling 4.41 KiB (function ‘...future.FUN’ of 1.21 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 3.20 KiB, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:59:37.435] Packages: <none>
[16:59:37.435] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:59:37.435] Resolved: FALSE
[16:59:37.435] Value: <not collected>
[16:59:37.435] Conditions captured: <none>
[16:59:37.435] Early signaling: FALSE
[16:59:37.435] Owner process: ab46d09a-7185-e614-b611-88b09ec54149
[16:59:37.435] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:59:37.448] Chunk #2 of 2 ... DONE
[16:59:37.448] Launching 2 futures (chunks) ... DONE
[16:59:37.448] Resolving 2 futures (chunks) ...
[16:59:37.448] resolve() on list ...
[16:59:37.448]  recursive: 0
[16:59:37.448]  length: 2
[16:59:37.449] 
[16:59:37.449] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.449] - Validating connection of MultisessionFuture
[16:59:37.449] - received message: FutureResult
[16:59:37.449] - Received FutureResult
[16:59:37.450] - Erased future from FutureRegistry
[16:59:37.450] result() for ClusterFuture ...
[16:59:37.450] - result already collected: FutureResult
[16:59:37.450] result() for ClusterFuture ... done
[16:59:37.450] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.450] Future #1
[16:59:37.450] result() for ClusterFuture ...
[16:59:37.450] - result already collected: FutureResult
[16:59:37.450] result() for ClusterFuture ... done
[16:59:37.450] result() for ClusterFuture ...
[16:59:37.450] - result already collected: FutureResult
[16:59:37.451] result() for ClusterFuture ... done
[16:59:37.451] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:59:37.451] - nx: 2
[16:59:37.451] - relay: TRUE
[16:59:37.451] - stdout: TRUE
[16:59:37.451] - signal: TRUE
[16:59:37.451] - resignal: FALSE
[16:59:37.451] - force: TRUE
[16:59:37.451] - relayed: [n=2] FALSE, FALSE
[16:59:37.451] - queued futures: [n=2] FALSE, FALSE
[16:59:37.451]  - until=1
[16:59:37.452]  - relaying element #1
[16:59:37.452] result() for ClusterFuture ...
[16:59:37.452] - result already collected: FutureResult
[16:59:37.452] result() for ClusterFuture ... done
[16:59:37.452] result() for ClusterFuture ...
[16:59:37.452] - result already collected: FutureResult
[16:59:37.452] result() for ClusterFuture ... done
[16:59:37.452] result() for ClusterFuture ...
[16:59:37.452] - result already collected: FutureResult
[16:59:37.452] result() for ClusterFuture ... done
[16:59:37.452] result() for ClusterFuture ...
[16:59:37.453] - result already collected: FutureResult
[16:59:37.453] result() for ClusterFuture ... done
[16:59:37.453] - relayed: [n=2] TRUE, FALSE
[16:59:37.453] - queued futures: [n=2] TRUE, FALSE
[16:59:37.453] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:59:37.453]  length: 1 (resolved future 1)
[16:59:37.478] receiveMessageFromWorker() for ClusterFuture ...
[16:59:37.478] - Validating connection of MultisessionFuture
[16:59:37.478] - received message: FutureResult
[16:59:37.479] - Received FutureResult
[16:59:37.479] - Erased future from FutureRegistry
[16:59:37.479] result() for ClusterFuture ...
[16:59:37.479] - result already collected: FutureResult
[16:59:37.479] result() for ClusterFuture ... done
[16:59:37.479] receiveMessageFromWorker() for ClusterFuture ... done
[16:59:37.479] Future #2
[16:59:37.479] result() for ClusterFuture ...
[16:59:37.479] - result already collected: FutureResult
[16:59:37.480] result() for ClusterFuture ... done
[16:59:37.480] result() for ClusterFuture ...
[16:59:37.480] - result already collected: FutureResult
[16:59:37.480] result() for ClusterFuture ... done
[16:59:37.480] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:59:37.480] - nx: 2
[16:59:37.480] - relay: TRUE
[16:59:37.480] - stdout: TRUE
[16:59:37.480] - signal: TRUE
[16:59:37.480] - resignal: FALSE
[16:59:37.480] - force: TRUE
[16:59:37.481] - relayed: [n=2] TRUE, FALSE
[16:59:37.481] - queued futures: [n=2] TRUE, FALSE
[16:59:37.481]  - until=2
[16:59:37.481]  - relaying element #2
[16:59:37.481] result() for ClusterFuture ...
[16:59:37.481] - result already collected: FutureResult
[16:59:37.481] result() for ClusterFuture ... done
[16:59:37.481] result() for ClusterFuture ...
[16:59:37.481] - result already collected: FutureResult
[16:59:37.481] result() for ClusterFuture ... done
[16:59:37.481] result() for ClusterFuture ...
[16:59:37.482] - result already collected: FutureResult
[16:59:37.482] result() for ClusterFuture ... done
[16:59:37.482] result() for ClusterFuture ...
[16:59:37.482] - result already collected: FutureResult
[16:59:37.482] result() for ClusterFuture ... done
[16:59:37.482] - relayed: [n=2] TRUE, TRUE
[16:59:37.482] - queued futures: [n=2] TRUE, TRUE
[16:59:37.482] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[16:59:37.482]  length: 0 (resolved future 2)
[16:59:37.482] Relaying remaining futures
[16:59:37.482] signalConditionsASAP(NULL, pos=0) ...
[16:59:37.483] - nx: 2
[16:59:37.483] - relay: TRUE
[16:59:37.483] - stdout: TRUE
[16:59:37.483] - signal: TRUE
[16:59:37.483] - resignal: FALSE
[16:59:37.483] - force: TRUE
[16:59:37.483] - relayed: [n=2] TRUE, TRUE
[16:59:37.483] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:59:37.483] - relayed: [n=2] TRUE, TRUE
[16:59:37.483] - queued futures: [n=2] TRUE, TRUE
[16:59:37.483] signalConditionsASAP(NULL, pos=0) ... done
[16:59:37.483] resolve() on list ... DONE
[16:59:37.484] result() for ClusterFuture ...
[16:59:37.484] - result already collected: FutureResult
[16:59:37.484] result() for ClusterFuture ... done
[16:59:37.484] result() for ClusterFuture ...
[16:59:37.484] - result already collected: FutureResult
[16:59:37.484] result() for ClusterFuture ... done
[16:59:37.484] result() for ClusterFuture ...
[16:59:37.484] - result already collected: FutureResult
[16:59:37.484] result() for ClusterFuture ... done
[16:59:37.484] result() for ClusterFuture ...
[16:59:37.484] - result already collected: FutureResult
[16:59:37.485] result() for ClusterFuture ... done
[16:59:37.485]  - Number of value chunks collected: 2
[16:59:37.485] Resolving 2 futures (chunks) ... DONE
[16:59:37.485] Reducing values from 2 chunks ...
[16:59:37.485]  - Number of values collected after concatenation: 3
[16:59:37.485]  - Number of values expected: 3
[16:59:37.485] Reducing values from 2 chunks ... DONE
[16:59:37.485] future_lapply() ... DONE
[16:59:37.485] future_by_internal() ... DONE
[16:59:37.486] future_by_internal() ...
Testing with 2 cores ... DONE
> 
> message("*** future_by() ... DONE")
*** future_by() ... DONE
> 
> source("incl/end.R")
[16:59:37.487] plan(): Setting new future strategy stack:
[16:59:37.487] List of future strategies:
[16:59:37.487] 1. FutureStrategy:
[16:59:37.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[16:59:37.487]    - tweaked: FALSE
[16:59:37.487]    - call: future::plan(oplan)
[16:59:37.488] plan(): nbrOfWorkers() = 1
> 
