
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[17:45:17.257] plan(): Setting new future strategy stack:
[17:45:17.257] List of future strategies:
[17:45:17.257] 1. sequential:
[17:45:17.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.257]    - tweaked: FALSE
[17:45:17.257]    - call: future::plan("sequential")
[17:45:17.272] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[17:45:17.378] plan(): Setting new future strategy stack:
[17:45:17.378] List of future strategies:
[17:45:17.378] 1. sequential:
[17:45:17.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.378]    - tweaked: FALSE
[17:45:17.378]    - call: plan(strategy)
[17:45:17.389] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:45:17.396] future_lapply() ...
[17:45:17.402] Number of chunks: 1
[17:45:17.402] getGlobalsAndPackagesXApply() ...
[17:45:17.403]  - future.globals: TRUE
[17:45:17.403] getGlobalsAndPackages() ...
[17:45:17.403] Searching for globals...
[17:45:17.407] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:17.408] Searching for globals ... DONE
[17:45:17.408] Resolving globals: FALSE
[17:45:17.409] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:45:17.410] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.410] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.410] - packages: [1] ‘future.apply’
[17:45:17.410] getGlobalsAndPackages() ... DONE
[17:45:17.410]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.410]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.410] Finding globals ... DONE
[17:45:17.410]  - use_args: TRUE
[17:45:17.411]  - Getting '...' globals ...
[17:45:17.411] resolve() on list ...
[17:45:17.411]  recursive: 0
[17:45:17.412]  length: 1
[17:45:17.412]  elements: ‘...’
[17:45:17.412]  length: 0 (resolved future 1)
[17:45:17.412] resolve() on list ... DONE
[17:45:17.412]    - '...' content: [n=0] 
[17:45:17.412] List of 1
[17:45:17.412]  $ ...: list()
[17:45:17.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.412]  - attr(*, "where")=List of 1
[17:45:17.412]   ..$ ...:<environment: 0x5561f4821aa0> 
[17:45:17.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.412]  - attr(*, "resolved")= logi TRUE
[17:45:17.412]  - attr(*, "total_size")= num NA
[17:45:17.415]  - Getting '...' globals ... DONE
[17:45:17.415] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.415] List of 8
[17:45:17.415]  $ ...future.FUN:function (x, ...)  
[17:45:17.415]  $ x_FUN        :function (x)  
[17:45:17.415]  $ times        : int 1
[17:45:17.415]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.415]  $ stop_if_not  :function (...)  
[17:45:17.415]  $ dim          : NULL
[17:45:17.415]  $ valid_types  : chr "character"
[17:45:17.415]  $ ...          : list()
[17:45:17.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.415]  - attr(*, "where")=List of 8
[17:45:17.415]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.415]   ..$ ...          :<environment: 0x5561f4821aa0> 
[17:45:17.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.415]  - attr(*, "resolved")= logi FALSE
[17:45:17.415]  - attr(*, "total_size")= num 94208
[17:45:17.420] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.421] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.421] Number of futures (= number of chunks): 1
[17:45:17.421] Launching 1 futures (chunks) ...
[17:45:17.421] Chunk #1 of 1 ...
[17:45:17.421]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.421] getGlobalsAndPackages() ...
[17:45:17.422] Searching for globals...
[17:45:17.422] 
[17:45:17.422] Searching for globals ... DONE
[17:45:17.422] - globals: [0] <none>
[17:45:17.422] getGlobalsAndPackages() ... DONE
[17:45:17.422]    + additional globals found: [n=0] 
[17:45:17.422]    + additional namespaces needed: [n=0] 
[17:45:17.422]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.422]  - seeds: <none>
[17:45:17.423]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.423] getGlobalsAndPackages() ...
[17:45:17.423] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.423] Resolving globals: FALSE
[17:45:17.423] Tweak future expression to call with '...' arguments ...
[17:45:17.423] {
[17:45:17.423]     do.call(function(...) {
[17:45:17.423]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.423]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.423]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.423]             on.exit(options(oopts), add = TRUE)
[17:45:17.423]         }
[17:45:17.423]         {
[17:45:17.423]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.423]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.423]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.423]             })
[17:45:17.423]         }
[17:45:17.423]     }, args = future.call.arguments)
[17:45:17.423] }
[17:45:17.423] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.424] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.424] - packages: [1] ‘future.apply’
[17:45:17.424] getGlobalsAndPackages() ... DONE
[17:45:17.425] run() for ‘Future’ ...
[17:45:17.425] - state: ‘created’
[17:45:17.425] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.426] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.426] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.426]   - Field: ‘label’
[17:45:17.426]   - Field: ‘local’
[17:45:17.426]   - Field: ‘owner’
[17:45:17.426]   - Field: ‘envir’
[17:45:17.426]   - Field: ‘packages’
[17:45:17.426]   - Field: ‘gc’
[17:45:17.426]   - Field: ‘conditions’
[17:45:17.426]   - Field: ‘expr’
[17:45:17.427]   - Field: ‘uuid’
[17:45:17.427]   - Field: ‘seed’
[17:45:17.427]   - Field: ‘version’
[17:45:17.427]   - Field: ‘result’
[17:45:17.427]   - Field: ‘asynchronous’
[17:45:17.427]   - Field: ‘calls’
[17:45:17.427]   - Field: ‘globals’
[17:45:17.427]   - Field: ‘stdout’
[17:45:17.427]   - Field: ‘earlySignal’
[17:45:17.427]   - Field: ‘lazy’
[17:45:17.427]   - Field: ‘state’
[17:45:17.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.428] - Launch lazy future ...
[17:45:17.428] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.431] Packages needed by future strategies (n = 0): <none>
[17:45:17.432] {
[17:45:17.432]     {
[17:45:17.432]         {
[17:45:17.432]             ...future.startTime <- base::Sys.time()
[17:45:17.432]             {
[17:45:17.432]                 {
[17:45:17.432]                   {
[17:45:17.432]                     {
[17:45:17.432]                       base::local({
[17:45:17.432]                         has_future <- base::requireNamespace("future", 
[17:45:17.432]                           quietly = TRUE)
[17:45:17.432]                         if (has_future) {
[17:45:17.432]                           ns <- base::getNamespace("future")
[17:45:17.432]                           version <- ns[[".package"]][["version"]]
[17:45:17.432]                           if (is.null(version)) 
[17:45:17.432]                             version <- utils::packageVersion("future")
[17:45:17.432]                         }
[17:45:17.432]                         else {
[17:45:17.432]                           version <- NULL
[17:45:17.432]                         }
[17:45:17.432]                         if (!has_future || version < "1.8.0") {
[17:45:17.432]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.432]                             "", base::R.version$version.string), 
[17:45:17.432]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.432]                               "release", "version")], collapse = " "), 
[17:45:17.432]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.432]                             info)
[17:45:17.432]                           info <- base::paste(info, collapse = "; ")
[17:45:17.432]                           if (!has_future) {
[17:45:17.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.432]                               info)
[17:45:17.432]                           }
[17:45:17.432]                           else {
[17:45:17.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.432]                               info, version)
[17:45:17.432]                           }
[17:45:17.432]                           base::stop(msg)
[17:45:17.432]                         }
[17:45:17.432]                       })
[17:45:17.432]                     }
[17:45:17.432]                     base::local({
[17:45:17.432]                       for (pkg in "future.apply") {
[17:45:17.432]                         base::loadNamespace(pkg)
[17:45:17.432]                         base::library(pkg, character.only = TRUE)
[17:45:17.432]                       }
[17:45:17.432]                     })
[17:45:17.432]                   }
[17:45:17.432]                   ...future.strategy.old <- future::plan("list")
[17:45:17.432]                   options(future.plan = NULL)
[17:45:17.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.432]                 }
[17:45:17.432]                 ...future.workdir <- getwd()
[17:45:17.432]             }
[17:45:17.432]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.432]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.432]         }
[17:45:17.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.432]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.432]             base::names(...future.oldOptions))
[17:45:17.432]     }
[17:45:17.432]     if (FALSE) {
[17:45:17.432]     }
[17:45:17.432]     else {
[17:45:17.432]         if (TRUE) {
[17:45:17.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.432]                 open = "w")
[17:45:17.432]         }
[17:45:17.432]         else {
[17:45:17.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.432]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.432]         }
[17:45:17.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.432]             base::sink(type = "output", split = FALSE)
[17:45:17.432]             base::close(...future.stdout)
[17:45:17.432]         }, add = TRUE)
[17:45:17.432]     }
[17:45:17.432]     ...future.frame <- base::sys.nframe()
[17:45:17.432]     ...future.conditions <- base::list()
[17:45:17.432]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.432]     if (FALSE) {
[17:45:17.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.432]     }
[17:45:17.432]     ...future.result <- base::tryCatch({
[17:45:17.432]         base::withCallingHandlers({
[17:45:17.432]             ...future.value <- base::withVisible(base::local({
[17:45:17.432]                 do.call(function(...) {
[17:45:17.432]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.432]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.432]                     ...future.globals.maxSize)) {
[17:45:17.432]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.432]                     on.exit(options(oopts), add = TRUE)
[17:45:17.432]                   }
[17:45:17.432]                   {
[17:45:17.432]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.432]                       FUN = function(jj) {
[17:45:17.432]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.432]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.432]                       })
[17:45:17.432]                   }
[17:45:17.432]                 }, args = future.call.arguments)
[17:45:17.432]             }))
[17:45:17.432]             future::FutureResult(value = ...future.value$value, 
[17:45:17.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.432]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.432]                     ...future.globalenv.names))
[17:45:17.432]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.432]         }, condition = base::local({
[17:45:17.432]             c <- base::c
[17:45:17.432]             inherits <- base::inherits
[17:45:17.432]             invokeRestart <- base::invokeRestart
[17:45:17.432]             length <- base::length
[17:45:17.432]             list <- base::list
[17:45:17.432]             seq.int <- base::seq.int
[17:45:17.432]             signalCondition <- base::signalCondition
[17:45:17.432]             sys.calls <- base::sys.calls
[17:45:17.432]             `[[` <- base::`[[`
[17:45:17.432]             `+` <- base::`+`
[17:45:17.432]             `<<-` <- base::`<<-`
[17:45:17.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.432]                   3L)]
[17:45:17.432]             }
[17:45:17.432]             function(cond) {
[17:45:17.432]                 is_error <- inherits(cond, "error")
[17:45:17.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.432]                   NULL)
[17:45:17.432]                 if (is_error) {
[17:45:17.432]                   sessionInformation <- function() {
[17:45:17.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.432]                       search = base::search(), system = base::Sys.info())
[17:45:17.432]                   }
[17:45:17.432]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.432]                     cond$call), session = sessionInformation(), 
[17:45:17.432]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.432]                   signalCondition(cond)
[17:45:17.432]                 }
[17:45:17.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.432]                 "immediateCondition"))) {
[17:45:17.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.432]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.432]                   if (TRUE && !signal) {
[17:45:17.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.432]                     {
[17:45:17.432]                       inherits <- base::inherits
[17:45:17.432]                       invokeRestart <- base::invokeRestart
[17:45:17.432]                       is.null <- base::is.null
[17:45:17.432]                       muffled <- FALSE
[17:45:17.432]                       if (inherits(cond, "message")) {
[17:45:17.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.432]                         if (muffled) 
[17:45:17.432]                           invokeRestart("muffleMessage")
[17:45:17.432]                       }
[17:45:17.432]                       else if (inherits(cond, "warning")) {
[17:45:17.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.432]                         if (muffled) 
[17:45:17.432]                           invokeRestart("muffleWarning")
[17:45:17.432]                       }
[17:45:17.432]                       else if (inherits(cond, "condition")) {
[17:45:17.432]                         if (!is.null(pattern)) {
[17:45:17.432]                           computeRestarts <- base::computeRestarts
[17:45:17.432]                           grepl <- base::grepl
[17:45:17.432]                           restarts <- computeRestarts(cond)
[17:45:17.432]                           for (restart in restarts) {
[17:45:17.432]                             name <- restart$name
[17:45:17.432]                             if (is.null(name)) 
[17:45:17.432]                               next
[17:45:17.432]                             if (!grepl(pattern, name)) 
[17:45:17.432]                               next
[17:45:17.432]                             invokeRestart(restart)
[17:45:17.432]                             muffled <- TRUE
[17:45:17.432]                             break
[17:45:17.432]                           }
[17:45:17.432]                         }
[17:45:17.432]                       }
[17:45:17.432]                       invisible(muffled)
[17:45:17.432]                     }
[17:45:17.432]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.432]                   }
[17:45:17.432]                 }
[17:45:17.432]                 else {
[17:45:17.432]                   if (TRUE) {
[17:45:17.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.432]                     {
[17:45:17.432]                       inherits <- base::inherits
[17:45:17.432]                       invokeRestart <- base::invokeRestart
[17:45:17.432]                       is.null <- base::is.null
[17:45:17.432]                       muffled <- FALSE
[17:45:17.432]                       if (inherits(cond, "message")) {
[17:45:17.432]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.432]                         if (muffled) 
[17:45:17.432]                           invokeRestart("muffleMessage")
[17:45:17.432]                       }
[17:45:17.432]                       else if (inherits(cond, "warning")) {
[17:45:17.432]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.432]                         if (muffled) 
[17:45:17.432]                           invokeRestart("muffleWarning")
[17:45:17.432]                       }
[17:45:17.432]                       else if (inherits(cond, "condition")) {
[17:45:17.432]                         if (!is.null(pattern)) {
[17:45:17.432]                           computeRestarts <- base::computeRestarts
[17:45:17.432]                           grepl <- base::grepl
[17:45:17.432]                           restarts <- computeRestarts(cond)
[17:45:17.432]                           for (restart in restarts) {
[17:45:17.432]                             name <- restart$name
[17:45:17.432]                             if (is.null(name)) 
[17:45:17.432]                               next
[17:45:17.432]                             if (!grepl(pattern, name)) 
[17:45:17.432]                               next
[17:45:17.432]                             invokeRestart(restart)
[17:45:17.432]                             muffled <- TRUE
[17:45:17.432]                             break
[17:45:17.432]                           }
[17:45:17.432]                         }
[17:45:17.432]                       }
[17:45:17.432]                       invisible(muffled)
[17:45:17.432]                     }
[17:45:17.432]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.432]                   }
[17:45:17.432]                 }
[17:45:17.432]             }
[17:45:17.432]         }))
[17:45:17.432]     }, error = function(ex) {
[17:45:17.432]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.432]                 ...future.rng), started = ...future.startTime, 
[17:45:17.432]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.432]             version = "1.8"), class = "FutureResult")
[17:45:17.432]     }, finally = {
[17:45:17.432]         if (!identical(...future.workdir, getwd())) 
[17:45:17.432]             setwd(...future.workdir)
[17:45:17.432]         {
[17:45:17.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.432]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.432]             }
[17:45:17.432]             base::options(...future.oldOptions)
[17:45:17.432]             if (.Platform$OS.type == "windows") {
[17:45:17.432]                 old_names <- names(...future.oldEnvVars)
[17:45:17.432]                 envs <- base::Sys.getenv()
[17:45:17.432]                 names <- names(envs)
[17:45:17.432]                 common <- intersect(names, old_names)
[17:45:17.432]                 added <- setdiff(names, old_names)
[17:45:17.432]                 removed <- setdiff(old_names, names)
[17:45:17.432]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.432]                   envs[common]]
[17:45:17.432]                 NAMES <- toupper(changed)
[17:45:17.432]                 args <- list()
[17:45:17.432]                 for (kk in seq_along(NAMES)) {
[17:45:17.432]                   name <- changed[[kk]]
[17:45:17.432]                   NAME <- NAMES[[kk]]
[17:45:17.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.432]                     next
[17:45:17.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.432]                 }
[17:45:17.432]                 NAMES <- toupper(added)
[17:45:17.432]                 for (kk in seq_along(NAMES)) {
[17:45:17.432]                   name <- added[[kk]]
[17:45:17.432]                   NAME <- NAMES[[kk]]
[17:45:17.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.432]                     next
[17:45:17.432]                   args[[name]] <- ""
[17:45:17.432]                 }
[17:45:17.432]                 NAMES <- toupper(removed)
[17:45:17.432]                 for (kk in seq_along(NAMES)) {
[17:45:17.432]                   name <- removed[[kk]]
[17:45:17.432]                   NAME <- NAMES[[kk]]
[17:45:17.432]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.432]                     next
[17:45:17.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.432]                 }
[17:45:17.432]                 if (length(args) > 0) 
[17:45:17.432]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.432]             }
[17:45:17.432]             else {
[17:45:17.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.432]             }
[17:45:17.432]             {
[17:45:17.432]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.432]                   0L) {
[17:45:17.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.432]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.432]                   base::options(opts)
[17:45:17.432]                 }
[17:45:17.432]                 {
[17:45:17.432]                   {
[17:45:17.432]                     NULL
[17:45:17.432]                     RNGkind("Mersenne-Twister")
[17:45:17.432]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.432]                       inherits = FALSE)
[17:45:17.432]                   }
[17:45:17.432]                   options(future.plan = NULL)
[17:45:17.432]                   if (is.na(NA_character_)) 
[17:45:17.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.432]                     .init = FALSE)
[17:45:17.432]                 }
[17:45:17.432]             }
[17:45:17.432]         }
[17:45:17.432]     })
[17:45:17.432]     if (TRUE) {
[17:45:17.432]         base::sink(type = "output", split = FALSE)
[17:45:17.432]         if (TRUE) {
[17:45:17.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.432]         }
[17:45:17.432]         else {
[17:45:17.432]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.432]         }
[17:45:17.432]         base::close(...future.stdout)
[17:45:17.432]         ...future.stdout <- NULL
[17:45:17.432]     }
[17:45:17.432]     ...future.result$conditions <- ...future.conditions
[17:45:17.432]     ...future.result$finished <- base::Sys.time()
[17:45:17.432]     ...future.result
[17:45:17.432] }
[17:45:17.434] assign_globals() ...
[17:45:17.434] List of 11
[17:45:17.434]  $ ...future.FUN            :function (x, ...)  
[17:45:17.434]  $ x_FUN                    :function (x)  
[17:45:17.434]  $ times                    : int 1
[17:45:17.434]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.434]  $ stop_if_not              :function (...)  
[17:45:17.434]  $ dim                      : NULL
[17:45:17.434]  $ valid_types              : chr "character"
[17:45:17.434]  $ future.call.arguments    : list()
[17:45:17.434]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.434]  $ ...future.elements_ii    :List of 2
[17:45:17.434]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:45:17.434]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:45:17.434]  $ ...future.seeds_ii       : NULL
[17:45:17.434]  $ ...future.globals.maxSize: NULL
[17:45:17.434]  - attr(*, "where")=List of 11
[17:45:17.434]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.434]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.434]  - attr(*, "resolved")= logi FALSE
[17:45:17.434]  - attr(*, "total_size")= num 94208
[17:45:17.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.434]  - attr(*, "already-done")= logi TRUE
[17:45:17.441] - copied ‘...future.FUN’ to environment
[17:45:17.442] - copied ‘x_FUN’ to environment
[17:45:17.442] - copied ‘times’ to environment
[17:45:17.442] - copied ‘stopf’ to environment
[17:45:17.442] - copied ‘stop_if_not’ to environment
[17:45:17.442] - copied ‘dim’ to environment
[17:45:17.442] - copied ‘valid_types’ to environment
[17:45:17.442] - copied ‘future.call.arguments’ to environment
[17:45:17.442] - copied ‘...future.elements_ii’ to environment
[17:45:17.442] - copied ‘...future.seeds_ii’ to environment
[17:45:17.442] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.442] assign_globals() ... done
[17:45:17.443] plan(): Setting new future strategy stack:
[17:45:17.443] List of future strategies:
[17:45:17.443] 1. sequential:
[17:45:17.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.443]    - tweaked: FALSE
[17:45:17.443]    - call: NULL
[17:45:17.443] plan(): nbrOfWorkers() = 1
[17:45:17.445] plan(): Setting new future strategy stack:
[17:45:17.445] List of future strategies:
[17:45:17.445] 1. sequential:
[17:45:17.445]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.445]    - tweaked: FALSE
[17:45:17.445]    - call: plan(strategy)
[17:45:17.445] plan(): nbrOfWorkers() = 1
[17:45:17.445] SequentialFuture started (and completed)
[17:45:17.446] - Launch lazy future ... done
[17:45:17.446] run() for ‘SequentialFuture’ ... done
[17:45:17.446] Created future:
[17:45:17.446] SequentialFuture:
[17:45:17.446] Label: ‘future_vapply-1’
[17:45:17.446] Expression:
[17:45:17.446] {
[17:45:17.446]     do.call(function(...) {
[17:45:17.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.446]             on.exit(options(oopts), add = TRUE)
[17:45:17.446]         }
[17:45:17.446]         {
[17:45:17.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.446]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.446]             })
[17:45:17.446]         }
[17:45:17.446]     }, args = future.call.arguments)
[17:45:17.446] }
[17:45:17.446] Lazy evaluation: FALSE
[17:45:17.446] Asynchronous evaluation: FALSE
[17:45:17.446] Local evaluation: TRUE
[17:45:17.446] Environment: R_GlobalEnv
[17:45:17.446] Capture standard output: TRUE
[17:45:17.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.446] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.446] Packages: 1 packages (‘future.apply’)
[17:45:17.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.446] Resolved: TRUE
[17:45:17.446] Value: 232 bytes of class ‘list’
[17:45:17.446] Early signaling: FALSE
[17:45:17.446] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.446] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.448] Chunk #1 of 1 ... DONE
[17:45:17.448] Launching 1 futures (chunks) ... DONE
[17:45:17.448] Resolving 1 futures (chunks) ...
[17:45:17.448] resolve() on list ...
[17:45:17.448]  recursive: 0
[17:45:17.448]  length: 1
[17:45:17.448] 
[17:45:17.449] resolved() for ‘SequentialFuture’ ...
[17:45:17.449] - state: ‘finished’
[17:45:17.449] - run: TRUE
[17:45:17.449] - result: ‘FutureResult’
[17:45:17.449] resolved() for ‘SequentialFuture’ ... done
[17:45:17.449] Future #1
[17:45:17.449] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.449] - nx: 1
[17:45:17.450] - relay: TRUE
[17:45:17.450] - stdout: TRUE
[17:45:17.450] - signal: TRUE
[17:45:17.450] - resignal: FALSE
[17:45:17.450] - force: TRUE
[17:45:17.450] - relayed: [n=1] FALSE
[17:45:17.450] - queued futures: [n=1] FALSE
[17:45:17.450]  - until=1
[17:45:17.450]  - relaying element #1
[17:45:17.450] - relayed: [n=1] TRUE
[17:45:17.451] - queued futures: [n=1] TRUE
[17:45:17.451] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.451]  length: 0 (resolved future 1)
[17:45:17.451] Relaying remaining futures
[17:45:17.451] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.451] - nx: 1
[17:45:17.451] - relay: TRUE
[17:45:17.451] - stdout: TRUE
[17:45:17.451] - signal: TRUE
[17:45:17.451] - resignal: FALSE
[17:45:17.452] - force: TRUE
[17:45:17.452] - relayed: [n=1] TRUE
[17:45:17.452] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.452] - relayed: [n=1] TRUE
[17:45:17.452] - queued futures: [n=1] TRUE
[17:45:17.452] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.452] resolve() on list ... DONE
[17:45:17.452]  - Number of value chunks collected: 1
[17:45:17.452] Resolving 1 futures (chunks) ... DONE
[17:45:17.452] Reducing values from 1 chunks ...
[17:45:17.453]  - Number of values collected after concatenation: 2
[17:45:17.453]  - Number of values expected: 2
[17:45:17.453] Reducing values from 1 chunks ... DONE
[17:45:17.453] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:45:17.454] future_lapply() ...
[17:45:17.456] Number of chunks: 1
[17:45:17.456] getGlobalsAndPackagesXApply() ...
[17:45:17.456]  - future.globals: TRUE
[17:45:17.456] getGlobalsAndPackages() ...
[17:45:17.456] Searching for globals...
[17:45:17.461] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:45:17.461] Searching for globals ... DONE
[17:45:17.461] Resolving globals: FALSE
[17:45:17.462] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:45:17.463] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.463] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.463] - packages: [1] ‘future.apply’
[17:45:17.463] getGlobalsAndPackages() ... DONE
[17:45:17.463]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.463]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.463] Finding globals ... DONE
[17:45:17.463]  - use_args: TRUE
[17:45:17.464]  - Getting '...' globals ...
[17:45:17.464] resolve() on list ...
[17:45:17.464]  recursive: 0
[17:45:17.464]  length: 1
[17:45:17.464]  elements: ‘...’
[17:45:17.464]  length: 0 (resolved future 1)
[17:45:17.464] resolve() on list ... DONE
[17:45:17.464]    - '...' content: [n=0] 
[17:45:17.465] List of 1
[17:45:17.465]  $ ...: list()
[17:45:17.465]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.465]  - attr(*, "where")=List of 1
[17:45:17.465]   ..$ ...:<environment: 0x5561f5645880> 
[17:45:17.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.465]  - attr(*, "resolved")= logi TRUE
[17:45:17.465]  - attr(*, "total_size")= num NA
[17:45:17.467]  - Getting '...' globals ... DONE
[17:45:17.467] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.467] List of 8
[17:45:17.467]  $ ...future.FUN:function (x, ...)  
[17:45:17.467]  $ x_FUN        :function (x)  
[17:45:17.467]  $ times        : int 0
[17:45:17.467]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.467]  $ stop_if_not  :function (...)  
[17:45:17.467]  $ dim          : NULL
[17:45:17.467]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.467]  $ ...          : list()
[17:45:17.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.467]  - attr(*, "where")=List of 8
[17:45:17.467]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.467]   ..$ ...          :<environment: 0x5561f5645880> 
[17:45:17.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.467]  - attr(*, "resolved")= logi FALSE
[17:45:17.467]  - attr(*, "total_size")= num 95472
[17:45:17.472] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.472] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.473] Number of futures (= number of chunks): 1
[17:45:17.473] Launching 1 futures (chunks) ...
[17:45:17.473] Chunk #1 of 1 ...
[17:45:17.473]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.473] getGlobalsAndPackages() ...
[17:45:17.473] Searching for globals...
[17:45:17.473] 
[17:45:17.473] Searching for globals ... DONE
[17:45:17.474] - globals: [0] <none>
[17:45:17.474] getGlobalsAndPackages() ... DONE
[17:45:17.474]    + additional globals found: [n=0] 
[17:45:17.474]    + additional namespaces needed: [n=0] 
[17:45:17.474]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.474]  - seeds: <none>
[17:45:17.474]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.474] getGlobalsAndPackages() ...
[17:45:17.474] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.474] Resolving globals: FALSE
[17:45:17.474] Tweak future expression to call with '...' arguments ...
[17:45:17.475] {
[17:45:17.475]     do.call(function(...) {
[17:45:17.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.475]             on.exit(options(oopts), add = TRUE)
[17:45:17.475]         }
[17:45:17.475]         {
[17:45:17.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.475]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.475]             })
[17:45:17.475]         }
[17:45:17.475]     }, args = future.call.arguments)
[17:45:17.475] }
[17:45:17.475] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.475] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.475] - packages: [1] ‘future.apply’
[17:45:17.476] getGlobalsAndPackages() ... DONE
[17:45:17.476] run() for ‘Future’ ...
[17:45:17.476] - state: ‘created’
[17:45:17.476] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.476] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.476] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.477]   - Field: ‘label’
[17:45:17.477]   - Field: ‘local’
[17:45:17.477]   - Field: ‘owner’
[17:45:17.477]   - Field: ‘envir’
[17:45:17.477]   - Field: ‘packages’
[17:45:17.477]   - Field: ‘gc’
[17:45:17.477]   - Field: ‘conditions’
[17:45:17.477]   - Field: ‘expr’
[17:45:17.477]   - Field: ‘uuid’
[17:45:17.477]   - Field: ‘seed’
[17:45:17.477]   - Field: ‘version’
[17:45:17.478]   - Field: ‘result’
[17:45:17.478]   - Field: ‘asynchronous’
[17:45:17.478]   - Field: ‘calls’
[17:45:17.478]   - Field: ‘globals’
[17:45:17.478]   - Field: ‘stdout’
[17:45:17.478]   - Field: ‘earlySignal’
[17:45:17.478]   - Field: ‘lazy’
[17:45:17.478]   - Field: ‘state’
[17:45:17.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.478] - Launch lazy future ...
[17:45:17.478] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.479] Packages needed by future strategies (n = 0): <none>
[17:45:17.479] {
[17:45:17.479]     {
[17:45:17.479]         {
[17:45:17.479]             ...future.startTime <- base::Sys.time()
[17:45:17.479]             {
[17:45:17.479]                 {
[17:45:17.479]                   {
[17:45:17.479]                     {
[17:45:17.479]                       base::local({
[17:45:17.479]                         has_future <- base::requireNamespace("future", 
[17:45:17.479]                           quietly = TRUE)
[17:45:17.479]                         if (has_future) {
[17:45:17.479]                           ns <- base::getNamespace("future")
[17:45:17.479]                           version <- ns[[".package"]][["version"]]
[17:45:17.479]                           if (is.null(version)) 
[17:45:17.479]                             version <- utils::packageVersion("future")
[17:45:17.479]                         }
[17:45:17.479]                         else {
[17:45:17.479]                           version <- NULL
[17:45:17.479]                         }
[17:45:17.479]                         if (!has_future || version < "1.8.0") {
[17:45:17.479]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.479]                             "", base::R.version$version.string), 
[17:45:17.479]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.479]                               "release", "version")], collapse = " "), 
[17:45:17.479]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.479]                             info)
[17:45:17.479]                           info <- base::paste(info, collapse = "; ")
[17:45:17.479]                           if (!has_future) {
[17:45:17.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.479]                               info)
[17:45:17.479]                           }
[17:45:17.479]                           else {
[17:45:17.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.479]                               info, version)
[17:45:17.479]                           }
[17:45:17.479]                           base::stop(msg)
[17:45:17.479]                         }
[17:45:17.479]                       })
[17:45:17.479]                     }
[17:45:17.479]                     base::local({
[17:45:17.479]                       for (pkg in "future.apply") {
[17:45:17.479]                         base::loadNamespace(pkg)
[17:45:17.479]                         base::library(pkg, character.only = TRUE)
[17:45:17.479]                       }
[17:45:17.479]                     })
[17:45:17.479]                   }
[17:45:17.479]                   ...future.strategy.old <- future::plan("list")
[17:45:17.479]                   options(future.plan = NULL)
[17:45:17.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.479]                 }
[17:45:17.479]                 ...future.workdir <- getwd()
[17:45:17.479]             }
[17:45:17.479]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.479]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.479]         }
[17:45:17.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.479]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.479]             base::names(...future.oldOptions))
[17:45:17.479]     }
[17:45:17.479]     if (FALSE) {
[17:45:17.479]     }
[17:45:17.479]     else {
[17:45:17.479]         if (TRUE) {
[17:45:17.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.479]                 open = "w")
[17:45:17.479]         }
[17:45:17.479]         else {
[17:45:17.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.479]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.479]         }
[17:45:17.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.479]             base::sink(type = "output", split = FALSE)
[17:45:17.479]             base::close(...future.stdout)
[17:45:17.479]         }, add = TRUE)
[17:45:17.479]     }
[17:45:17.479]     ...future.frame <- base::sys.nframe()
[17:45:17.479]     ...future.conditions <- base::list()
[17:45:17.479]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.479]     if (FALSE) {
[17:45:17.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.479]     }
[17:45:17.479]     ...future.result <- base::tryCatch({
[17:45:17.479]         base::withCallingHandlers({
[17:45:17.479]             ...future.value <- base::withVisible(base::local({
[17:45:17.479]                 do.call(function(...) {
[17:45:17.479]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.479]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.479]                     ...future.globals.maxSize)) {
[17:45:17.479]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.479]                     on.exit(options(oopts), add = TRUE)
[17:45:17.479]                   }
[17:45:17.479]                   {
[17:45:17.479]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.479]                       FUN = function(jj) {
[17:45:17.479]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.479]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.479]                       })
[17:45:17.479]                   }
[17:45:17.479]                 }, args = future.call.arguments)
[17:45:17.479]             }))
[17:45:17.479]             future::FutureResult(value = ...future.value$value, 
[17:45:17.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.479]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.479]                     ...future.globalenv.names))
[17:45:17.479]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.479]         }, condition = base::local({
[17:45:17.479]             c <- base::c
[17:45:17.479]             inherits <- base::inherits
[17:45:17.479]             invokeRestart <- base::invokeRestart
[17:45:17.479]             length <- base::length
[17:45:17.479]             list <- base::list
[17:45:17.479]             seq.int <- base::seq.int
[17:45:17.479]             signalCondition <- base::signalCondition
[17:45:17.479]             sys.calls <- base::sys.calls
[17:45:17.479]             `[[` <- base::`[[`
[17:45:17.479]             `+` <- base::`+`
[17:45:17.479]             `<<-` <- base::`<<-`
[17:45:17.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.479]                   3L)]
[17:45:17.479]             }
[17:45:17.479]             function(cond) {
[17:45:17.479]                 is_error <- inherits(cond, "error")
[17:45:17.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.479]                   NULL)
[17:45:17.479]                 if (is_error) {
[17:45:17.479]                   sessionInformation <- function() {
[17:45:17.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.479]                       search = base::search(), system = base::Sys.info())
[17:45:17.479]                   }
[17:45:17.479]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.479]                     cond$call), session = sessionInformation(), 
[17:45:17.479]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.479]                   signalCondition(cond)
[17:45:17.479]                 }
[17:45:17.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.479]                 "immediateCondition"))) {
[17:45:17.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.479]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.479]                   if (TRUE && !signal) {
[17:45:17.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.479]                     {
[17:45:17.479]                       inherits <- base::inherits
[17:45:17.479]                       invokeRestart <- base::invokeRestart
[17:45:17.479]                       is.null <- base::is.null
[17:45:17.479]                       muffled <- FALSE
[17:45:17.479]                       if (inherits(cond, "message")) {
[17:45:17.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.479]                         if (muffled) 
[17:45:17.479]                           invokeRestart("muffleMessage")
[17:45:17.479]                       }
[17:45:17.479]                       else if (inherits(cond, "warning")) {
[17:45:17.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.479]                         if (muffled) 
[17:45:17.479]                           invokeRestart("muffleWarning")
[17:45:17.479]                       }
[17:45:17.479]                       else if (inherits(cond, "condition")) {
[17:45:17.479]                         if (!is.null(pattern)) {
[17:45:17.479]                           computeRestarts <- base::computeRestarts
[17:45:17.479]                           grepl <- base::grepl
[17:45:17.479]                           restarts <- computeRestarts(cond)
[17:45:17.479]                           for (restart in restarts) {
[17:45:17.479]                             name <- restart$name
[17:45:17.479]                             if (is.null(name)) 
[17:45:17.479]                               next
[17:45:17.479]                             if (!grepl(pattern, name)) 
[17:45:17.479]                               next
[17:45:17.479]                             invokeRestart(restart)
[17:45:17.479]                             muffled <- TRUE
[17:45:17.479]                             break
[17:45:17.479]                           }
[17:45:17.479]                         }
[17:45:17.479]                       }
[17:45:17.479]                       invisible(muffled)
[17:45:17.479]                     }
[17:45:17.479]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.479]                   }
[17:45:17.479]                 }
[17:45:17.479]                 else {
[17:45:17.479]                   if (TRUE) {
[17:45:17.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.479]                     {
[17:45:17.479]                       inherits <- base::inherits
[17:45:17.479]                       invokeRestart <- base::invokeRestart
[17:45:17.479]                       is.null <- base::is.null
[17:45:17.479]                       muffled <- FALSE
[17:45:17.479]                       if (inherits(cond, "message")) {
[17:45:17.479]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.479]                         if (muffled) 
[17:45:17.479]                           invokeRestart("muffleMessage")
[17:45:17.479]                       }
[17:45:17.479]                       else if (inherits(cond, "warning")) {
[17:45:17.479]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.479]                         if (muffled) 
[17:45:17.479]                           invokeRestart("muffleWarning")
[17:45:17.479]                       }
[17:45:17.479]                       else if (inherits(cond, "condition")) {
[17:45:17.479]                         if (!is.null(pattern)) {
[17:45:17.479]                           computeRestarts <- base::computeRestarts
[17:45:17.479]                           grepl <- base::grepl
[17:45:17.479]                           restarts <- computeRestarts(cond)
[17:45:17.479]                           for (restart in restarts) {
[17:45:17.479]                             name <- restart$name
[17:45:17.479]                             if (is.null(name)) 
[17:45:17.479]                               next
[17:45:17.479]                             if (!grepl(pattern, name)) 
[17:45:17.479]                               next
[17:45:17.479]                             invokeRestart(restart)
[17:45:17.479]                             muffled <- TRUE
[17:45:17.479]                             break
[17:45:17.479]                           }
[17:45:17.479]                         }
[17:45:17.479]                       }
[17:45:17.479]                       invisible(muffled)
[17:45:17.479]                     }
[17:45:17.479]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.479]                   }
[17:45:17.479]                 }
[17:45:17.479]             }
[17:45:17.479]         }))
[17:45:17.479]     }, error = function(ex) {
[17:45:17.479]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.479]                 ...future.rng), started = ...future.startTime, 
[17:45:17.479]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.479]             version = "1.8"), class = "FutureResult")
[17:45:17.479]     }, finally = {
[17:45:17.479]         if (!identical(...future.workdir, getwd())) 
[17:45:17.479]             setwd(...future.workdir)
[17:45:17.479]         {
[17:45:17.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.479]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.479]             }
[17:45:17.479]             base::options(...future.oldOptions)
[17:45:17.479]             if (.Platform$OS.type == "windows") {
[17:45:17.479]                 old_names <- names(...future.oldEnvVars)
[17:45:17.479]                 envs <- base::Sys.getenv()
[17:45:17.479]                 names <- names(envs)
[17:45:17.479]                 common <- intersect(names, old_names)
[17:45:17.479]                 added <- setdiff(names, old_names)
[17:45:17.479]                 removed <- setdiff(old_names, names)
[17:45:17.479]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.479]                   envs[common]]
[17:45:17.479]                 NAMES <- toupper(changed)
[17:45:17.479]                 args <- list()
[17:45:17.479]                 for (kk in seq_along(NAMES)) {
[17:45:17.479]                   name <- changed[[kk]]
[17:45:17.479]                   NAME <- NAMES[[kk]]
[17:45:17.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.479]                     next
[17:45:17.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.479]                 }
[17:45:17.479]                 NAMES <- toupper(added)
[17:45:17.479]                 for (kk in seq_along(NAMES)) {
[17:45:17.479]                   name <- added[[kk]]
[17:45:17.479]                   NAME <- NAMES[[kk]]
[17:45:17.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.479]                     next
[17:45:17.479]                   args[[name]] <- ""
[17:45:17.479]                 }
[17:45:17.479]                 NAMES <- toupper(removed)
[17:45:17.479]                 for (kk in seq_along(NAMES)) {
[17:45:17.479]                   name <- removed[[kk]]
[17:45:17.479]                   NAME <- NAMES[[kk]]
[17:45:17.479]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.479]                     next
[17:45:17.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.479]                 }
[17:45:17.479]                 if (length(args) > 0) 
[17:45:17.479]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.479]             }
[17:45:17.479]             else {
[17:45:17.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.479]             }
[17:45:17.479]             {
[17:45:17.479]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.479]                   0L) {
[17:45:17.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.479]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.479]                   base::options(opts)
[17:45:17.479]                 }
[17:45:17.479]                 {
[17:45:17.479]                   {
[17:45:17.479]                     NULL
[17:45:17.479]                     RNGkind("Mersenne-Twister")
[17:45:17.479]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.479]                       inherits = FALSE)
[17:45:17.479]                   }
[17:45:17.479]                   options(future.plan = NULL)
[17:45:17.479]                   if (is.na(NA_character_)) 
[17:45:17.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.479]                     .init = FALSE)
[17:45:17.479]                 }
[17:45:17.479]             }
[17:45:17.479]         }
[17:45:17.479]     })
[17:45:17.479]     if (TRUE) {
[17:45:17.479]         base::sink(type = "output", split = FALSE)
[17:45:17.479]         if (TRUE) {
[17:45:17.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.479]         }
[17:45:17.479]         else {
[17:45:17.479]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.479]         }
[17:45:17.479]         base::close(...future.stdout)
[17:45:17.479]         ...future.stdout <- NULL
[17:45:17.479]     }
[17:45:17.479]     ...future.result$conditions <- ...future.conditions
[17:45:17.479]     ...future.result$finished <- base::Sys.time()
[17:45:17.479]     ...future.result
[17:45:17.479] }
[17:45:17.481] assign_globals() ...
[17:45:17.481] List of 11
[17:45:17.481]  $ ...future.FUN            :function (x, ...)  
[17:45:17.481]  $ x_FUN                    :function (x)  
[17:45:17.481]  $ times                    : int 0
[17:45:17.481]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.481]  $ stop_if_not              :function (...)  
[17:45:17.481]  $ dim                      : NULL
[17:45:17.481]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.481]  $ future.call.arguments    : list()
[17:45:17.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.481]  $ ...future.elements_ii    :List of 10
[17:45:17.481]   ..$ : int 1
[17:45:17.481]   ..$ : int 2
[17:45:17.481]   ..$ : int 3
[17:45:17.481]   ..$ : int 4
[17:45:17.481]   ..$ : int 5
[17:45:17.481]   ..$ : int 6
[17:45:17.481]   ..$ : int 7
[17:45:17.481]   ..$ : int 8
[17:45:17.481]   ..$ : int 9
[17:45:17.481]   ..$ : int 10
[17:45:17.481]  $ ...future.seeds_ii       : NULL
[17:45:17.481]  $ ...future.globals.maxSize: NULL
[17:45:17.481]  - attr(*, "where")=List of 11
[17:45:17.481]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.481]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.481]  - attr(*, "resolved")= logi FALSE
[17:45:17.481]  - attr(*, "total_size")= num 95472
[17:45:17.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.481]  - attr(*, "already-done")= logi TRUE
[17:45:17.492] - copied ‘...future.FUN’ to environment
[17:45:17.492] - reassign environment for ‘x_FUN’
[17:45:17.492] - copied ‘x_FUN’ to environment
[17:45:17.492] - copied ‘times’ to environment
[17:45:17.492] - copied ‘stopf’ to environment
[17:45:17.492] - copied ‘stop_if_not’ to environment
[17:45:17.492] - copied ‘dim’ to environment
[17:45:17.493] - copied ‘valid_types’ to environment
[17:45:17.493] - copied ‘future.call.arguments’ to environment
[17:45:17.493] - copied ‘...future.elements_ii’ to environment
[17:45:17.493] - copied ‘...future.seeds_ii’ to environment
[17:45:17.493] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.493] assign_globals() ... done
[17:45:17.493] plan(): Setting new future strategy stack:
[17:45:17.493] List of future strategies:
[17:45:17.493] 1. sequential:
[17:45:17.493]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.493]    - tweaked: FALSE
[17:45:17.493]    - call: NULL
[17:45:17.494] plan(): nbrOfWorkers() = 1
[17:45:17.495] plan(): Setting new future strategy stack:
[17:45:17.495] List of future strategies:
[17:45:17.495] 1. sequential:
[17:45:17.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.495]    - tweaked: FALSE
[17:45:17.495]    - call: plan(strategy)
[17:45:17.495] plan(): nbrOfWorkers() = 1
[17:45:17.495] SequentialFuture started (and completed)
[17:45:17.496] - Launch lazy future ... done
[17:45:17.496] run() for ‘SequentialFuture’ ... done
[17:45:17.496] Created future:
[17:45:17.496] SequentialFuture:
[17:45:17.496] Label: ‘future_vapply-1’
[17:45:17.496] Expression:
[17:45:17.496] {
[17:45:17.496]     do.call(function(...) {
[17:45:17.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.496]             on.exit(options(oopts), add = TRUE)
[17:45:17.496]         }
[17:45:17.496]         {
[17:45:17.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.496]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.496]             })
[17:45:17.496]         }
[17:45:17.496]     }, args = future.call.arguments)
[17:45:17.496] }
[17:45:17.496] Lazy evaluation: FALSE
[17:45:17.496] Asynchronous evaluation: FALSE
[17:45:17.496] Local evaluation: TRUE
[17:45:17.496] Environment: R_GlobalEnv
[17:45:17.496] Capture standard output: TRUE
[17:45:17.496] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.496] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.496] Packages: 1 packages (‘future.apply’)
[17:45:17.496] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.496] Resolved: TRUE
[17:45:17.496] Value: 480 bytes of class ‘list’
[17:45:17.496] Early signaling: FALSE
[17:45:17.496] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.496] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.497] Chunk #1 of 1 ... DONE
[17:45:17.497] Launching 1 futures (chunks) ... DONE
[17:45:17.497] Resolving 1 futures (chunks) ...
[17:45:17.497] resolve() on list ...
[17:45:17.497]  recursive: 0
[17:45:17.498]  length: 1
[17:45:17.498] 
[17:45:17.498] resolved() for ‘SequentialFuture’ ...
[17:45:17.498] - state: ‘finished’
[17:45:17.498] - run: TRUE
[17:45:17.498] - result: ‘FutureResult’
[17:45:17.498] resolved() for ‘SequentialFuture’ ... done
[17:45:17.498] Future #1
[17:45:17.498] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.498] - nx: 1
[17:45:17.498] - relay: TRUE
[17:45:17.499] - stdout: TRUE
[17:45:17.499] - signal: TRUE
[17:45:17.499] - resignal: FALSE
[17:45:17.499] - force: TRUE
[17:45:17.499] - relayed: [n=1] FALSE
[17:45:17.499] - queued futures: [n=1] FALSE
[17:45:17.499]  - until=1
[17:45:17.499]  - relaying element #1
[17:45:17.499] - relayed: [n=1] TRUE
[17:45:17.499] - queued futures: [n=1] TRUE
[17:45:17.500] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.500]  length: 0 (resolved future 1)
[17:45:17.500] Relaying remaining futures
[17:45:17.500] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.500] - nx: 1
[17:45:17.500] - relay: TRUE
[17:45:17.500] - stdout: TRUE
[17:45:17.500] - signal: TRUE
[17:45:17.500] - resignal: FALSE
[17:45:17.500] - force: TRUE
[17:45:17.500] - relayed: [n=1] TRUE
[17:45:17.500] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.501] - relayed: [n=1] TRUE
[17:45:17.501] - queued futures: [n=1] TRUE
[17:45:17.501] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.501] resolve() on list ... DONE
[17:45:17.501]  - Number of value chunks collected: 1
[17:45:17.501] Resolving 1 futures (chunks) ... DONE
[17:45:17.501] Reducing values from 1 chunks ...
[17:45:17.501]  - Number of values collected after concatenation: 10
[17:45:17.501]  - Number of values expected: 10
[17:45:17.501] Reducing values from 1 chunks ... DONE
[17:45:17.501] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:45:17.502] future_lapply() ...
[17:45:17.504] Number of chunks: 1
[17:45:17.504] getGlobalsAndPackagesXApply() ...
[17:45:17.504]  - future.globals: TRUE
[17:45:17.504] getGlobalsAndPackages() ...
[17:45:17.504] Searching for globals...
[17:45:17.509] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:45:17.509] Searching for globals ... DONE
[17:45:17.510] Resolving globals: FALSE
[17:45:17.510] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:45:17.511] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.511] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.511] - packages: [1] ‘future.apply’
[17:45:17.511] getGlobalsAndPackages() ... DONE
[17:45:17.511]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.511]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.511] Finding globals ... DONE
[17:45:17.511]  - use_args: TRUE
[17:45:17.512]  - Getting '...' globals ...
[17:45:17.512] resolve() on list ...
[17:45:17.512]  recursive: 0
[17:45:17.512]  length: 1
[17:45:17.512]  elements: ‘...’
[17:45:17.512]  length: 0 (resolved future 1)
[17:45:17.512] resolve() on list ... DONE
[17:45:17.512]    - '...' content: [n=0] 
[17:45:17.513] List of 1
[17:45:17.513]  $ ...: list()
[17:45:17.513]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.513]  - attr(*, "where")=List of 1
[17:45:17.513]   ..$ ...:<environment: 0x5561f563ef88> 
[17:45:17.513]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.513]  - attr(*, "resolved")= logi TRUE
[17:45:17.513]  - attr(*, "total_size")= num NA
[17:45:17.515]  - Getting '...' globals ... DONE
[17:45:17.515] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.515] List of 8
[17:45:17.515]  $ ...future.FUN:function (x, ...)  
[17:45:17.515]  $ x_FUN        :function (x)  
[17:45:17.515]  $ times        : int 0
[17:45:17.515]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.515]  $ stop_if_not  :function (...)  
[17:45:17.515]  $ dim          : NULL
[17:45:17.515]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:17.515]  $ ...          : list()
[17:45:17.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.515]  - attr(*, "where")=List of 8
[17:45:17.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.515]   ..$ ...          :<environment: 0x5561f563ef88> 
[17:45:17.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.515]  - attr(*, "resolved")= logi FALSE
[17:45:17.515]  - attr(*, "total_size")= num 95400
[17:45:17.520] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.520] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.521] Number of futures (= number of chunks): 1
[17:45:17.521] Launching 1 futures (chunks) ...
[17:45:17.521] Chunk #1 of 1 ...
[17:45:17.521]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.521] getGlobalsAndPackages() ...
[17:45:17.521] Searching for globals...
[17:45:17.521] 
[17:45:17.521] Searching for globals ... DONE
[17:45:17.522] - globals: [0] <none>
[17:45:17.522] getGlobalsAndPackages() ... DONE
[17:45:17.522]    + additional globals found: [n=0] 
[17:45:17.522]    + additional namespaces needed: [n=0] 
[17:45:17.522]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.522]  - seeds: <none>
[17:45:17.522]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.522] getGlobalsAndPackages() ...
[17:45:17.522] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.522] Resolving globals: FALSE
[17:45:17.523] Tweak future expression to call with '...' arguments ...
[17:45:17.523] {
[17:45:17.523]     do.call(function(...) {
[17:45:17.523]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.523]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.523]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.523]             on.exit(options(oopts), add = TRUE)
[17:45:17.523]         }
[17:45:17.523]         {
[17:45:17.523]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.523]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.523]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.523]             })
[17:45:17.523]         }
[17:45:17.523]     }, args = future.call.arguments)
[17:45:17.523] }
[17:45:17.523] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.523] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.524] - packages: [1] ‘future.apply’
[17:45:17.524] getGlobalsAndPackages() ... DONE
[17:45:17.524] run() for ‘Future’ ...
[17:45:17.524] - state: ‘created’
[17:45:17.524] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.525] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.525] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.525]   - Field: ‘label’
[17:45:17.525]   - Field: ‘local’
[17:45:17.525]   - Field: ‘owner’
[17:45:17.525]   - Field: ‘envir’
[17:45:17.525]   - Field: ‘packages’
[17:45:17.526]   - Field: ‘gc’
[17:45:17.526]   - Field: ‘conditions’
[17:45:17.526]   - Field: ‘expr’
[17:45:17.526]   - Field: ‘uuid’
[17:45:17.526]   - Field: ‘seed’
[17:45:17.526]   - Field: ‘version’
[17:45:17.526]   - Field: ‘result’
[17:45:17.526]   - Field: ‘asynchronous’
[17:45:17.526]   - Field: ‘calls’
[17:45:17.527]   - Field: ‘globals’
[17:45:17.527]   - Field: ‘stdout’
[17:45:17.527]   - Field: ‘earlySignal’
[17:45:17.527]   - Field: ‘lazy’
[17:45:17.527]   - Field: ‘state’
[17:45:17.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.527] - Launch lazy future ...
[17:45:17.527] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.527] Packages needed by future strategies (n = 0): <none>
[17:45:17.528] {
[17:45:17.528]     {
[17:45:17.528]         {
[17:45:17.528]             ...future.startTime <- base::Sys.time()
[17:45:17.528]             {
[17:45:17.528]                 {
[17:45:17.528]                   {
[17:45:17.528]                     {
[17:45:17.528]                       base::local({
[17:45:17.528]                         has_future <- base::requireNamespace("future", 
[17:45:17.528]                           quietly = TRUE)
[17:45:17.528]                         if (has_future) {
[17:45:17.528]                           ns <- base::getNamespace("future")
[17:45:17.528]                           version <- ns[[".package"]][["version"]]
[17:45:17.528]                           if (is.null(version)) 
[17:45:17.528]                             version <- utils::packageVersion("future")
[17:45:17.528]                         }
[17:45:17.528]                         else {
[17:45:17.528]                           version <- NULL
[17:45:17.528]                         }
[17:45:17.528]                         if (!has_future || version < "1.8.0") {
[17:45:17.528]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.528]                             "", base::R.version$version.string), 
[17:45:17.528]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.528]                               "release", "version")], collapse = " "), 
[17:45:17.528]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.528]                             info)
[17:45:17.528]                           info <- base::paste(info, collapse = "; ")
[17:45:17.528]                           if (!has_future) {
[17:45:17.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.528]                               info)
[17:45:17.528]                           }
[17:45:17.528]                           else {
[17:45:17.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.528]                               info, version)
[17:45:17.528]                           }
[17:45:17.528]                           base::stop(msg)
[17:45:17.528]                         }
[17:45:17.528]                       })
[17:45:17.528]                     }
[17:45:17.528]                     base::local({
[17:45:17.528]                       for (pkg in "future.apply") {
[17:45:17.528]                         base::loadNamespace(pkg)
[17:45:17.528]                         base::library(pkg, character.only = TRUE)
[17:45:17.528]                       }
[17:45:17.528]                     })
[17:45:17.528]                   }
[17:45:17.528]                   ...future.strategy.old <- future::plan("list")
[17:45:17.528]                   options(future.plan = NULL)
[17:45:17.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.528]                 }
[17:45:17.528]                 ...future.workdir <- getwd()
[17:45:17.528]             }
[17:45:17.528]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.528]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.528]         }
[17:45:17.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.528]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.528]             base::names(...future.oldOptions))
[17:45:17.528]     }
[17:45:17.528]     if (FALSE) {
[17:45:17.528]     }
[17:45:17.528]     else {
[17:45:17.528]         if (TRUE) {
[17:45:17.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.528]                 open = "w")
[17:45:17.528]         }
[17:45:17.528]         else {
[17:45:17.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.528]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.528]         }
[17:45:17.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.528]             base::sink(type = "output", split = FALSE)
[17:45:17.528]             base::close(...future.stdout)
[17:45:17.528]         }, add = TRUE)
[17:45:17.528]     }
[17:45:17.528]     ...future.frame <- base::sys.nframe()
[17:45:17.528]     ...future.conditions <- base::list()
[17:45:17.528]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.528]     if (FALSE) {
[17:45:17.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.528]     }
[17:45:17.528]     ...future.result <- base::tryCatch({
[17:45:17.528]         base::withCallingHandlers({
[17:45:17.528]             ...future.value <- base::withVisible(base::local({
[17:45:17.528]                 do.call(function(...) {
[17:45:17.528]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.528]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.528]                     ...future.globals.maxSize)) {
[17:45:17.528]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.528]                     on.exit(options(oopts), add = TRUE)
[17:45:17.528]                   }
[17:45:17.528]                   {
[17:45:17.528]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.528]                       FUN = function(jj) {
[17:45:17.528]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.528]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.528]                       })
[17:45:17.528]                   }
[17:45:17.528]                 }, args = future.call.arguments)
[17:45:17.528]             }))
[17:45:17.528]             future::FutureResult(value = ...future.value$value, 
[17:45:17.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.528]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.528]                     ...future.globalenv.names))
[17:45:17.528]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.528]         }, condition = base::local({
[17:45:17.528]             c <- base::c
[17:45:17.528]             inherits <- base::inherits
[17:45:17.528]             invokeRestart <- base::invokeRestart
[17:45:17.528]             length <- base::length
[17:45:17.528]             list <- base::list
[17:45:17.528]             seq.int <- base::seq.int
[17:45:17.528]             signalCondition <- base::signalCondition
[17:45:17.528]             sys.calls <- base::sys.calls
[17:45:17.528]             `[[` <- base::`[[`
[17:45:17.528]             `+` <- base::`+`
[17:45:17.528]             `<<-` <- base::`<<-`
[17:45:17.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.528]                   3L)]
[17:45:17.528]             }
[17:45:17.528]             function(cond) {
[17:45:17.528]                 is_error <- inherits(cond, "error")
[17:45:17.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.528]                   NULL)
[17:45:17.528]                 if (is_error) {
[17:45:17.528]                   sessionInformation <- function() {
[17:45:17.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.528]                       search = base::search(), system = base::Sys.info())
[17:45:17.528]                   }
[17:45:17.528]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.528]                     cond$call), session = sessionInformation(), 
[17:45:17.528]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.528]                   signalCondition(cond)
[17:45:17.528]                 }
[17:45:17.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.528]                 "immediateCondition"))) {
[17:45:17.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.528]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.528]                   if (TRUE && !signal) {
[17:45:17.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.528]                     {
[17:45:17.528]                       inherits <- base::inherits
[17:45:17.528]                       invokeRestart <- base::invokeRestart
[17:45:17.528]                       is.null <- base::is.null
[17:45:17.528]                       muffled <- FALSE
[17:45:17.528]                       if (inherits(cond, "message")) {
[17:45:17.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.528]                         if (muffled) 
[17:45:17.528]                           invokeRestart("muffleMessage")
[17:45:17.528]                       }
[17:45:17.528]                       else if (inherits(cond, "warning")) {
[17:45:17.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.528]                         if (muffled) 
[17:45:17.528]                           invokeRestart("muffleWarning")
[17:45:17.528]                       }
[17:45:17.528]                       else if (inherits(cond, "condition")) {
[17:45:17.528]                         if (!is.null(pattern)) {
[17:45:17.528]                           computeRestarts <- base::computeRestarts
[17:45:17.528]                           grepl <- base::grepl
[17:45:17.528]                           restarts <- computeRestarts(cond)
[17:45:17.528]                           for (restart in restarts) {
[17:45:17.528]                             name <- restart$name
[17:45:17.528]                             if (is.null(name)) 
[17:45:17.528]                               next
[17:45:17.528]                             if (!grepl(pattern, name)) 
[17:45:17.528]                               next
[17:45:17.528]                             invokeRestart(restart)
[17:45:17.528]                             muffled <- TRUE
[17:45:17.528]                             break
[17:45:17.528]                           }
[17:45:17.528]                         }
[17:45:17.528]                       }
[17:45:17.528]                       invisible(muffled)
[17:45:17.528]                     }
[17:45:17.528]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.528]                   }
[17:45:17.528]                 }
[17:45:17.528]                 else {
[17:45:17.528]                   if (TRUE) {
[17:45:17.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.528]                     {
[17:45:17.528]                       inherits <- base::inherits
[17:45:17.528]                       invokeRestart <- base::invokeRestart
[17:45:17.528]                       is.null <- base::is.null
[17:45:17.528]                       muffled <- FALSE
[17:45:17.528]                       if (inherits(cond, "message")) {
[17:45:17.528]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.528]                         if (muffled) 
[17:45:17.528]                           invokeRestart("muffleMessage")
[17:45:17.528]                       }
[17:45:17.528]                       else if (inherits(cond, "warning")) {
[17:45:17.528]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.528]                         if (muffled) 
[17:45:17.528]                           invokeRestart("muffleWarning")
[17:45:17.528]                       }
[17:45:17.528]                       else if (inherits(cond, "condition")) {
[17:45:17.528]                         if (!is.null(pattern)) {
[17:45:17.528]                           computeRestarts <- base::computeRestarts
[17:45:17.528]                           grepl <- base::grepl
[17:45:17.528]                           restarts <- computeRestarts(cond)
[17:45:17.528]                           for (restart in restarts) {
[17:45:17.528]                             name <- restart$name
[17:45:17.528]                             if (is.null(name)) 
[17:45:17.528]                               next
[17:45:17.528]                             if (!grepl(pattern, name)) 
[17:45:17.528]                               next
[17:45:17.528]                             invokeRestart(restart)
[17:45:17.528]                             muffled <- TRUE
[17:45:17.528]                             break
[17:45:17.528]                           }
[17:45:17.528]                         }
[17:45:17.528]                       }
[17:45:17.528]                       invisible(muffled)
[17:45:17.528]                     }
[17:45:17.528]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.528]                   }
[17:45:17.528]                 }
[17:45:17.528]             }
[17:45:17.528]         }))
[17:45:17.528]     }, error = function(ex) {
[17:45:17.528]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.528]                 ...future.rng), started = ...future.startTime, 
[17:45:17.528]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.528]             version = "1.8"), class = "FutureResult")
[17:45:17.528]     }, finally = {
[17:45:17.528]         if (!identical(...future.workdir, getwd())) 
[17:45:17.528]             setwd(...future.workdir)
[17:45:17.528]         {
[17:45:17.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.528]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.528]             }
[17:45:17.528]             base::options(...future.oldOptions)
[17:45:17.528]             if (.Platform$OS.type == "windows") {
[17:45:17.528]                 old_names <- names(...future.oldEnvVars)
[17:45:17.528]                 envs <- base::Sys.getenv()
[17:45:17.528]                 names <- names(envs)
[17:45:17.528]                 common <- intersect(names, old_names)
[17:45:17.528]                 added <- setdiff(names, old_names)
[17:45:17.528]                 removed <- setdiff(old_names, names)
[17:45:17.528]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.528]                   envs[common]]
[17:45:17.528]                 NAMES <- toupper(changed)
[17:45:17.528]                 args <- list()
[17:45:17.528]                 for (kk in seq_along(NAMES)) {
[17:45:17.528]                   name <- changed[[kk]]
[17:45:17.528]                   NAME <- NAMES[[kk]]
[17:45:17.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.528]                     next
[17:45:17.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.528]                 }
[17:45:17.528]                 NAMES <- toupper(added)
[17:45:17.528]                 for (kk in seq_along(NAMES)) {
[17:45:17.528]                   name <- added[[kk]]
[17:45:17.528]                   NAME <- NAMES[[kk]]
[17:45:17.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.528]                     next
[17:45:17.528]                   args[[name]] <- ""
[17:45:17.528]                 }
[17:45:17.528]                 NAMES <- toupper(removed)
[17:45:17.528]                 for (kk in seq_along(NAMES)) {
[17:45:17.528]                   name <- removed[[kk]]
[17:45:17.528]                   NAME <- NAMES[[kk]]
[17:45:17.528]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.528]                     next
[17:45:17.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.528]                 }
[17:45:17.528]                 if (length(args) > 0) 
[17:45:17.528]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.528]             }
[17:45:17.528]             else {
[17:45:17.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.528]             }
[17:45:17.528]             {
[17:45:17.528]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.528]                   0L) {
[17:45:17.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.528]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.528]                   base::options(opts)
[17:45:17.528]                 }
[17:45:17.528]                 {
[17:45:17.528]                   {
[17:45:17.528]                     NULL
[17:45:17.528]                     RNGkind("Mersenne-Twister")
[17:45:17.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.528]                       inherits = FALSE)
[17:45:17.528]                   }
[17:45:17.528]                   options(future.plan = NULL)
[17:45:17.528]                   if (is.na(NA_character_)) 
[17:45:17.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.528]                     .init = FALSE)
[17:45:17.528]                 }
[17:45:17.528]             }
[17:45:17.528]         }
[17:45:17.528]     })
[17:45:17.528]     if (TRUE) {
[17:45:17.528]         base::sink(type = "output", split = FALSE)
[17:45:17.528]         if (TRUE) {
[17:45:17.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.528]         }
[17:45:17.528]         else {
[17:45:17.528]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.528]         }
[17:45:17.528]         base::close(...future.stdout)
[17:45:17.528]         ...future.stdout <- NULL
[17:45:17.528]     }
[17:45:17.528]     ...future.result$conditions <- ...future.conditions
[17:45:17.528]     ...future.result$finished <- base::Sys.time()
[17:45:17.528]     ...future.result
[17:45:17.528] }
[17:45:17.530] assign_globals() ...
[17:45:17.530] List of 11
[17:45:17.530]  $ ...future.FUN            :function (x, ...)  
[17:45:17.530]  $ x_FUN                    :function (x)  
[17:45:17.530]  $ times                    : int 0
[17:45:17.530]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.530]  $ stop_if_not              :function (...)  
[17:45:17.530]  $ dim                      : NULL
[17:45:17.530]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:17.530]  $ future.call.arguments    : list()
[17:45:17.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.530]  $ ...future.elements_ii    :List of 10
[17:45:17.530]   ..$ : int 1
[17:45:17.530]   ..$ : int 2
[17:45:17.530]   ..$ : int 3
[17:45:17.530]   ..$ : int 4
[17:45:17.530]   ..$ : int 5
[17:45:17.530]   ..$ : int 6
[17:45:17.530]   ..$ : int 7
[17:45:17.530]   ..$ : int 8
[17:45:17.530]   ..$ : int 9
[17:45:17.530]   ..$ : int 10
[17:45:17.530]  $ ...future.seeds_ii       : NULL
[17:45:17.530]  $ ...future.globals.maxSize: NULL
[17:45:17.530]  - attr(*, "where")=List of 11
[17:45:17.530]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.530]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.530]  - attr(*, "resolved")= logi FALSE
[17:45:17.530]  - attr(*, "total_size")= num 95400
[17:45:17.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.530]  - attr(*, "already-done")= logi TRUE
[17:45:17.542] - copied ‘...future.FUN’ to environment
[17:45:17.542] - reassign environment for ‘x_FUN’
[17:45:17.542] - copied ‘x_FUN’ to environment
[17:45:17.542] - copied ‘times’ to environment
[17:45:17.542] - copied ‘stopf’ to environment
[17:45:17.542] - copied ‘stop_if_not’ to environment
[17:45:17.542] - copied ‘dim’ to environment
[17:45:17.542] - copied ‘valid_types’ to environment
[17:45:17.542] - copied ‘future.call.arguments’ to environment
[17:45:17.542] - copied ‘...future.elements_ii’ to environment
[17:45:17.543] - copied ‘...future.seeds_ii’ to environment
[17:45:17.543] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.543] assign_globals() ... done
[17:45:17.543] plan(): Setting new future strategy stack:
[17:45:17.543] List of future strategies:
[17:45:17.543] 1. sequential:
[17:45:17.543]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.543]    - tweaked: FALSE
[17:45:17.543]    - call: NULL
[17:45:17.544] plan(): nbrOfWorkers() = 1
[17:45:17.545] plan(): Setting new future strategy stack:
[17:45:17.545] List of future strategies:
[17:45:17.545] 1. sequential:
[17:45:17.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.545]    - tweaked: FALSE
[17:45:17.545]    - call: plan(strategy)
[17:45:17.545] plan(): nbrOfWorkers() = 1
[17:45:17.545] SequentialFuture started (and completed)
[17:45:17.545] - Launch lazy future ... done
[17:45:17.546] run() for ‘SequentialFuture’ ... done
[17:45:17.546] Created future:
[17:45:17.546] SequentialFuture:
[17:45:17.546] Label: ‘future_vapply-1’
[17:45:17.546] Expression:
[17:45:17.546] {
[17:45:17.546]     do.call(function(...) {
[17:45:17.546]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.546]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.546]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.546]             on.exit(options(oopts), add = TRUE)
[17:45:17.546]         }
[17:45:17.546]         {
[17:45:17.546]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.546]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.546]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.546]             })
[17:45:17.546]         }
[17:45:17.546]     }, args = future.call.arguments)
[17:45:17.546] }
[17:45:17.546] Lazy evaluation: FALSE
[17:45:17.546] Asynchronous evaluation: FALSE
[17:45:17.546] Local evaluation: TRUE
[17:45:17.546] Environment: R_GlobalEnv
[17:45:17.546] Capture standard output: TRUE
[17:45:17.546] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.546] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.546] Packages: 1 packages (‘future.apply’)
[17:45:17.546] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.546] Resolved: TRUE
[17:45:17.546] Value: 480 bytes of class ‘list’
[17:45:17.546] Early signaling: FALSE
[17:45:17.546] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.546] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.547] Chunk #1 of 1 ... DONE
[17:45:17.547] Launching 1 futures (chunks) ... DONE
[17:45:17.547] Resolving 1 futures (chunks) ...
[17:45:17.547] resolve() on list ...
[17:45:17.548]  recursive: 0
[17:45:17.548]  length: 1
[17:45:17.548] 
[17:45:17.548] resolved() for ‘SequentialFuture’ ...
[17:45:17.548] - state: ‘finished’
[17:45:17.548] - run: TRUE
[17:45:17.548] - result: ‘FutureResult’
[17:45:17.548] resolved() for ‘SequentialFuture’ ... done
[17:45:17.548] Future #1
[17:45:17.548] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.549] - nx: 1
[17:45:17.549] - relay: TRUE
[17:45:17.549] - stdout: TRUE
[17:45:17.549] - signal: TRUE
[17:45:17.549] - resignal: FALSE
[17:45:17.549] - force: TRUE
[17:45:17.549] - relayed: [n=1] FALSE
[17:45:17.549] - queued futures: [n=1] FALSE
[17:45:17.549]  - until=1
[17:45:17.549]  - relaying element #1
[17:45:17.549] - relayed: [n=1] TRUE
[17:45:17.550] - queued futures: [n=1] TRUE
[17:45:17.550] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.550]  length: 0 (resolved future 1)
[17:45:17.550] Relaying remaining futures
[17:45:17.550] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.550] - nx: 1
[17:45:17.550] - relay: TRUE
[17:45:17.550] - stdout: TRUE
[17:45:17.550] - signal: TRUE
[17:45:17.550] - resignal: FALSE
[17:45:17.550] - force: TRUE
[17:45:17.551] - relayed: [n=1] TRUE
[17:45:17.551] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.551] - relayed: [n=1] TRUE
[17:45:17.551] - queued futures: [n=1] TRUE
[17:45:17.551] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.551] resolve() on list ... DONE
[17:45:17.551]  - Number of value chunks collected: 1
[17:45:17.551] Resolving 1 futures (chunks) ... DONE
[17:45:17.551] Reducing values from 1 chunks ...
[17:45:17.551]  - Number of values collected after concatenation: 10
[17:45:17.552]  - Number of values expected: 10
[17:45:17.552] Reducing values from 1 chunks ... DONE
[17:45:17.552] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:45:17.553] future_lapply() ...
[17:45:17.554] Number of chunks: 1
[17:45:17.554] getGlobalsAndPackagesXApply() ...
[17:45:17.554]  - future.globals: TRUE
[17:45:17.555] getGlobalsAndPackages() ...
[17:45:17.555] Searching for globals...
[17:45:17.559] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:17.560] Searching for globals ... DONE
[17:45:17.560] Resolving globals: FALSE
[17:45:17.561] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:45:17.561] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.561] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.561] - packages: [1] ‘future.apply’
[17:45:17.561] getGlobalsAndPackages() ... DONE
[17:45:17.561]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.562]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.562] Finding globals ... DONE
[17:45:17.562]  - use_args: TRUE
[17:45:17.562]  - Getting '...' globals ...
[17:45:17.562] resolve() on list ...
[17:45:17.562]  recursive: 0
[17:45:17.562]  length: 1
[17:45:17.562]  elements: ‘...’
[17:45:17.562]  length: 0 (resolved future 1)
[17:45:17.563] resolve() on list ... DONE
[17:45:17.563]    - '...' content: [n=0] 
[17:45:17.563] List of 1
[17:45:17.563]  $ ...: list()
[17:45:17.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.563]  - attr(*, "where")=List of 1
[17:45:17.563]   ..$ ...:<environment: 0x5561f56868b0> 
[17:45:17.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.563]  - attr(*, "resolved")= logi TRUE
[17:45:17.563]  - attr(*, "total_size")= num NA
[17:45:17.565]  - Getting '...' globals ... DONE
[17:45:17.565] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.566] List of 8
[17:45:17.566]  $ ...future.FUN:function (x, ...)  
[17:45:17.566]  $ x_FUN        :function (x)  
[17:45:17.566]  $ times        : int 1
[17:45:17.566]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.566]  $ stop_if_not  :function (...)  
[17:45:17.566]  $ dim          : NULL
[17:45:17.566]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.566]  $ ...          : list()
[17:45:17.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.566]  - attr(*, "where")=List of 8
[17:45:17.566]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.566]   ..$ ...          :<environment: 0x5561f56868b0> 
[17:45:17.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.566]  - attr(*, "resolved")= logi FALSE
[17:45:17.566]  - attr(*, "total_size")= num 94336
[17:45:17.571] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.571] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.571] Number of futures (= number of chunks): 1
[17:45:17.571] Launching 1 futures (chunks) ...
[17:45:17.571] Chunk #1 of 1 ...
[17:45:17.571]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.571] getGlobalsAndPackages() ...
[17:45:17.572] Searching for globals...
[17:45:17.572] 
[17:45:17.572] Searching for globals ... DONE
[17:45:17.572] - globals: [0] <none>
[17:45:17.572] getGlobalsAndPackages() ... DONE
[17:45:17.572]    + additional globals found: [n=0] 
[17:45:17.572]    + additional namespaces needed: [n=0] 
[17:45:17.572]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.572]  - seeds: <none>
[17:45:17.572]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.573] getGlobalsAndPackages() ...
[17:45:17.573] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.573] Resolving globals: FALSE
[17:45:17.573] Tweak future expression to call with '...' arguments ...
[17:45:17.573] {
[17:45:17.573]     do.call(function(...) {
[17:45:17.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.573]             on.exit(options(oopts), add = TRUE)
[17:45:17.573]         }
[17:45:17.573]         {
[17:45:17.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.573]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.573]             })
[17:45:17.573]         }
[17:45:17.573]     }, args = future.call.arguments)
[17:45:17.573] }
[17:45:17.573] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.574] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.574] - packages: [1] ‘future.apply’
[17:45:17.574] getGlobalsAndPackages() ... DONE
[17:45:17.574] run() for ‘Future’ ...
[17:45:17.574] - state: ‘created’
[17:45:17.574] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.575] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.575] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.575]   - Field: ‘label’
[17:45:17.575]   - Field: ‘local’
[17:45:17.575]   - Field: ‘owner’
[17:45:17.575]   - Field: ‘envir’
[17:45:17.575]   - Field: ‘packages’
[17:45:17.575]   - Field: ‘gc’
[17:45:17.576]   - Field: ‘conditions’
[17:45:17.576]   - Field: ‘expr’
[17:45:17.576]   - Field: ‘uuid’
[17:45:17.576]   - Field: ‘seed’
[17:45:17.576]   - Field: ‘version’
[17:45:17.576]   - Field: ‘result’
[17:45:17.576]   - Field: ‘asynchronous’
[17:45:17.576]   - Field: ‘calls’
[17:45:17.576]   - Field: ‘globals’
[17:45:17.576]   - Field: ‘stdout’
[17:45:17.576]   - Field: ‘earlySignal’
[17:45:17.577]   - Field: ‘lazy’
[17:45:17.577]   - Field: ‘state’
[17:45:17.577] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.577] - Launch lazy future ...
[17:45:17.577] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.577] Packages needed by future strategies (n = 0): <none>
[17:45:17.578] {
[17:45:17.578]     {
[17:45:17.578]         {
[17:45:17.578]             ...future.startTime <- base::Sys.time()
[17:45:17.578]             {
[17:45:17.578]                 {
[17:45:17.578]                   {
[17:45:17.578]                     {
[17:45:17.578]                       base::local({
[17:45:17.578]                         has_future <- base::requireNamespace("future", 
[17:45:17.578]                           quietly = TRUE)
[17:45:17.578]                         if (has_future) {
[17:45:17.578]                           ns <- base::getNamespace("future")
[17:45:17.578]                           version <- ns[[".package"]][["version"]]
[17:45:17.578]                           if (is.null(version)) 
[17:45:17.578]                             version <- utils::packageVersion("future")
[17:45:17.578]                         }
[17:45:17.578]                         else {
[17:45:17.578]                           version <- NULL
[17:45:17.578]                         }
[17:45:17.578]                         if (!has_future || version < "1.8.0") {
[17:45:17.578]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.578]                             "", base::R.version$version.string), 
[17:45:17.578]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.578]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.578]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.578]                               "release", "version")], collapse = " "), 
[17:45:17.578]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.578]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.578]                             info)
[17:45:17.578]                           info <- base::paste(info, collapse = "; ")
[17:45:17.578]                           if (!has_future) {
[17:45:17.578]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.578]                               info)
[17:45:17.578]                           }
[17:45:17.578]                           else {
[17:45:17.578]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.578]                               info, version)
[17:45:17.578]                           }
[17:45:17.578]                           base::stop(msg)
[17:45:17.578]                         }
[17:45:17.578]                       })
[17:45:17.578]                     }
[17:45:17.578]                     base::local({
[17:45:17.578]                       for (pkg in "future.apply") {
[17:45:17.578]                         base::loadNamespace(pkg)
[17:45:17.578]                         base::library(pkg, character.only = TRUE)
[17:45:17.578]                       }
[17:45:17.578]                     })
[17:45:17.578]                   }
[17:45:17.578]                   ...future.strategy.old <- future::plan("list")
[17:45:17.578]                   options(future.plan = NULL)
[17:45:17.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.578]                 }
[17:45:17.578]                 ...future.workdir <- getwd()
[17:45:17.578]             }
[17:45:17.578]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.578]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.578]         }
[17:45:17.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.578]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.578]             base::names(...future.oldOptions))
[17:45:17.578]     }
[17:45:17.578]     if (FALSE) {
[17:45:17.578]     }
[17:45:17.578]     else {
[17:45:17.578]         if (TRUE) {
[17:45:17.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.578]                 open = "w")
[17:45:17.578]         }
[17:45:17.578]         else {
[17:45:17.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.578]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.578]         }
[17:45:17.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.578]             base::sink(type = "output", split = FALSE)
[17:45:17.578]             base::close(...future.stdout)
[17:45:17.578]         }, add = TRUE)
[17:45:17.578]     }
[17:45:17.578]     ...future.frame <- base::sys.nframe()
[17:45:17.578]     ...future.conditions <- base::list()
[17:45:17.578]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.578]     if (FALSE) {
[17:45:17.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.578]     }
[17:45:17.578]     ...future.result <- base::tryCatch({
[17:45:17.578]         base::withCallingHandlers({
[17:45:17.578]             ...future.value <- base::withVisible(base::local({
[17:45:17.578]                 do.call(function(...) {
[17:45:17.578]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.578]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.578]                     ...future.globals.maxSize)) {
[17:45:17.578]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.578]                     on.exit(options(oopts), add = TRUE)
[17:45:17.578]                   }
[17:45:17.578]                   {
[17:45:17.578]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.578]                       FUN = function(jj) {
[17:45:17.578]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.578]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.578]                       })
[17:45:17.578]                   }
[17:45:17.578]                 }, args = future.call.arguments)
[17:45:17.578]             }))
[17:45:17.578]             future::FutureResult(value = ...future.value$value, 
[17:45:17.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.578]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.578]                     ...future.globalenv.names))
[17:45:17.578]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.578]         }, condition = base::local({
[17:45:17.578]             c <- base::c
[17:45:17.578]             inherits <- base::inherits
[17:45:17.578]             invokeRestart <- base::invokeRestart
[17:45:17.578]             length <- base::length
[17:45:17.578]             list <- base::list
[17:45:17.578]             seq.int <- base::seq.int
[17:45:17.578]             signalCondition <- base::signalCondition
[17:45:17.578]             sys.calls <- base::sys.calls
[17:45:17.578]             `[[` <- base::`[[`
[17:45:17.578]             `+` <- base::`+`
[17:45:17.578]             `<<-` <- base::`<<-`
[17:45:17.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.578]                   3L)]
[17:45:17.578]             }
[17:45:17.578]             function(cond) {
[17:45:17.578]                 is_error <- inherits(cond, "error")
[17:45:17.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.578]                   NULL)
[17:45:17.578]                 if (is_error) {
[17:45:17.578]                   sessionInformation <- function() {
[17:45:17.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.578]                       search = base::search(), system = base::Sys.info())
[17:45:17.578]                   }
[17:45:17.578]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.578]                     cond$call), session = sessionInformation(), 
[17:45:17.578]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.578]                   signalCondition(cond)
[17:45:17.578]                 }
[17:45:17.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.578]                 "immediateCondition"))) {
[17:45:17.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.578]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.578]                   if (TRUE && !signal) {
[17:45:17.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.578]                     {
[17:45:17.578]                       inherits <- base::inherits
[17:45:17.578]                       invokeRestart <- base::invokeRestart
[17:45:17.578]                       is.null <- base::is.null
[17:45:17.578]                       muffled <- FALSE
[17:45:17.578]                       if (inherits(cond, "message")) {
[17:45:17.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.578]                         if (muffled) 
[17:45:17.578]                           invokeRestart("muffleMessage")
[17:45:17.578]                       }
[17:45:17.578]                       else if (inherits(cond, "warning")) {
[17:45:17.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.578]                         if (muffled) 
[17:45:17.578]                           invokeRestart("muffleWarning")
[17:45:17.578]                       }
[17:45:17.578]                       else if (inherits(cond, "condition")) {
[17:45:17.578]                         if (!is.null(pattern)) {
[17:45:17.578]                           computeRestarts <- base::computeRestarts
[17:45:17.578]                           grepl <- base::grepl
[17:45:17.578]                           restarts <- computeRestarts(cond)
[17:45:17.578]                           for (restart in restarts) {
[17:45:17.578]                             name <- restart$name
[17:45:17.578]                             if (is.null(name)) 
[17:45:17.578]                               next
[17:45:17.578]                             if (!grepl(pattern, name)) 
[17:45:17.578]                               next
[17:45:17.578]                             invokeRestart(restart)
[17:45:17.578]                             muffled <- TRUE
[17:45:17.578]                             break
[17:45:17.578]                           }
[17:45:17.578]                         }
[17:45:17.578]                       }
[17:45:17.578]                       invisible(muffled)
[17:45:17.578]                     }
[17:45:17.578]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.578]                   }
[17:45:17.578]                 }
[17:45:17.578]                 else {
[17:45:17.578]                   if (TRUE) {
[17:45:17.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.578]                     {
[17:45:17.578]                       inherits <- base::inherits
[17:45:17.578]                       invokeRestart <- base::invokeRestart
[17:45:17.578]                       is.null <- base::is.null
[17:45:17.578]                       muffled <- FALSE
[17:45:17.578]                       if (inherits(cond, "message")) {
[17:45:17.578]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.578]                         if (muffled) 
[17:45:17.578]                           invokeRestart("muffleMessage")
[17:45:17.578]                       }
[17:45:17.578]                       else if (inherits(cond, "warning")) {
[17:45:17.578]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.578]                         if (muffled) 
[17:45:17.578]                           invokeRestart("muffleWarning")
[17:45:17.578]                       }
[17:45:17.578]                       else if (inherits(cond, "condition")) {
[17:45:17.578]                         if (!is.null(pattern)) {
[17:45:17.578]                           computeRestarts <- base::computeRestarts
[17:45:17.578]                           grepl <- base::grepl
[17:45:17.578]                           restarts <- computeRestarts(cond)
[17:45:17.578]                           for (restart in restarts) {
[17:45:17.578]                             name <- restart$name
[17:45:17.578]                             if (is.null(name)) 
[17:45:17.578]                               next
[17:45:17.578]                             if (!grepl(pattern, name)) 
[17:45:17.578]                               next
[17:45:17.578]                             invokeRestart(restart)
[17:45:17.578]                             muffled <- TRUE
[17:45:17.578]                             break
[17:45:17.578]                           }
[17:45:17.578]                         }
[17:45:17.578]                       }
[17:45:17.578]                       invisible(muffled)
[17:45:17.578]                     }
[17:45:17.578]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.578]                   }
[17:45:17.578]                 }
[17:45:17.578]             }
[17:45:17.578]         }))
[17:45:17.578]     }, error = function(ex) {
[17:45:17.578]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.578]                 ...future.rng), started = ...future.startTime, 
[17:45:17.578]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.578]             version = "1.8"), class = "FutureResult")
[17:45:17.578]     }, finally = {
[17:45:17.578]         if (!identical(...future.workdir, getwd())) 
[17:45:17.578]             setwd(...future.workdir)
[17:45:17.578]         {
[17:45:17.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.578]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.578]             }
[17:45:17.578]             base::options(...future.oldOptions)
[17:45:17.578]             if (.Platform$OS.type == "windows") {
[17:45:17.578]                 old_names <- names(...future.oldEnvVars)
[17:45:17.578]                 envs <- base::Sys.getenv()
[17:45:17.578]                 names <- names(envs)
[17:45:17.578]                 common <- intersect(names, old_names)
[17:45:17.578]                 added <- setdiff(names, old_names)
[17:45:17.578]                 removed <- setdiff(old_names, names)
[17:45:17.578]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.578]                   envs[common]]
[17:45:17.578]                 NAMES <- toupper(changed)
[17:45:17.578]                 args <- list()
[17:45:17.578]                 for (kk in seq_along(NAMES)) {
[17:45:17.578]                   name <- changed[[kk]]
[17:45:17.578]                   NAME <- NAMES[[kk]]
[17:45:17.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.578]                     next
[17:45:17.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.578]                 }
[17:45:17.578]                 NAMES <- toupper(added)
[17:45:17.578]                 for (kk in seq_along(NAMES)) {
[17:45:17.578]                   name <- added[[kk]]
[17:45:17.578]                   NAME <- NAMES[[kk]]
[17:45:17.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.578]                     next
[17:45:17.578]                   args[[name]] <- ""
[17:45:17.578]                 }
[17:45:17.578]                 NAMES <- toupper(removed)
[17:45:17.578]                 for (kk in seq_along(NAMES)) {
[17:45:17.578]                   name <- removed[[kk]]
[17:45:17.578]                   NAME <- NAMES[[kk]]
[17:45:17.578]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.578]                     next
[17:45:17.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.578]                 }
[17:45:17.578]                 if (length(args) > 0) 
[17:45:17.578]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.578]             }
[17:45:17.578]             else {
[17:45:17.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.578]             }
[17:45:17.578]             {
[17:45:17.578]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.578]                   0L) {
[17:45:17.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.578]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.578]                   base::options(opts)
[17:45:17.578]                 }
[17:45:17.578]                 {
[17:45:17.578]                   {
[17:45:17.578]                     NULL
[17:45:17.578]                     RNGkind("Mersenne-Twister")
[17:45:17.578]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.578]                       inherits = FALSE)
[17:45:17.578]                   }
[17:45:17.578]                   options(future.plan = NULL)
[17:45:17.578]                   if (is.na(NA_character_)) 
[17:45:17.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.578]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.578]                     .init = FALSE)
[17:45:17.578]                 }
[17:45:17.578]             }
[17:45:17.578]         }
[17:45:17.578]     })
[17:45:17.578]     if (TRUE) {
[17:45:17.578]         base::sink(type = "output", split = FALSE)
[17:45:17.578]         if (TRUE) {
[17:45:17.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.578]         }
[17:45:17.578]         else {
[17:45:17.578]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.578]         }
[17:45:17.578]         base::close(...future.stdout)
[17:45:17.578]         ...future.stdout <- NULL
[17:45:17.578]     }
[17:45:17.578]     ...future.result$conditions <- ...future.conditions
[17:45:17.578]     ...future.result$finished <- base::Sys.time()
[17:45:17.578]     ...future.result
[17:45:17.578] }
[17:45:17.579] assign_globals() ...
[17:45:17.580] List of 11
[17:45:17.580]  $ ...future.FUN            :function (x, ...)  
[17:45:17.580]  $ x_FUN                    :function (x)  
[17:45:17.580]  $ times                    : int 1
[17:45:17.580]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.580]  $ stop_if_not              :function (...)  
[17:45:17.580]  $ dim                      : NULL
[17:45:17.580]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.580]  $ future.call.arguments    : list()
[17:45:17.580]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.580]  $ ...future.elements_ii    :List of 10
[17:45:17.580]   ..$ : int 1
[17:45:17.580]   ..$ : int 2
[17:45:17.580]   ..$ : int 3
[17:45:17.580]   ..$ : int 4
[17:45:17.580]   ..$ : int 5
[17:45:17.580]   ..$ : int 6
[17:45:17.580]   ..$ : int 7
[17:45:17.580]   ..$ : int 8
[17:45:17.580]   ..$ : int 9
[17:45:17.580]   ..$ : int 10
[17:45:17.580]  $ ...future.seeds_ii       : NULL
[17:45:17.580]  $ ...future.globals.maxSize: NULL
[17:45:17.580]  - attr(*, "where")=List of 11
[17:45:17.580]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.580]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.580]  - attr(*, "resolved")= logi FALSE
[17:45:17.580]  - attr(*, "total_size")= num 94336
[17:45:17.580]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.580]  - attr(*, "already-done")= logi TRUE
[17:45:17.591] - copied ‘...future.FUN’ to environment
[17:45:17.591] - copied ‘x_FUN’ to environment
[17:45:17.591] - copied ‘times’ to environment
[17:45:17.591] - copied ‘stopf’ to environment
[17:45:17.591] - copied ‘stop_if_not’ to environment
[17:45:17.591] - copied ‘dim’ to environment
[17:45:17.591] - copied ‘valid_types’ to environment
[17:45:17.591] - copied ‘future.call.arguments’ to environment
[17:45:17.592] - copied ‘...future.elements_ii’ to environment
[17:45:17.592] - copied ‘...future.seeds_ii’ to environment
[17:45:17.592] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.592] assign_globals() ... done
[17:45:17.592] plan(): Setting new future strategy stack:
[17:45:17.592] List of future strategies:
[17:45:17.592] 1. sequential:
[17:45:17.592]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.592]    - tweaked: FALSE
[17:45:17.592]    - call: NULL
[17:45:17.593] plan(): nbrOfWorkers() = 1
[17:45:17.593] plan(): Setting new future strategy stack:
[17:45:17.594] List of future strategies:
[17:45:17.594] 1. sequential:
[17:45:17.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.594]    - tweaked: FALSE
[17:45:17.594]    - call: plan(strategy)
[17:45:17.594] plan(): nbrOfWorkers() = 1
[17:45:17.594] SequentialFuture started (and completed)
[17:45:17.594] - Launch lazy future ... done
[17:45:17.594] run() for ‘SequentialFuture’ ... done
[17:45:17.595] Created future:
[17:45:17.595] SequentialFuture:
[17:45:17.595] Label: ‘future_vapply-1’
[17:45:17.595] Expression:
[17:45:17.595] {
[17:45:17.595]     do.call(function(...) {
[17:45:17.595]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.595]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.595]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.595]             on.exit(options(oopts), add = TRUE)
[17:45:17.595]         }
[17:45:17.595]         {
[17:45:17.595]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.595]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.595]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.595]             })
[17:45:17.595]         }
[17:45:17.595]     }, args = future.call.arguments)
[17:45:17.595] }
[17:45:17.595] Lazy evaluation: FALSE
[17:45:17.595] Asynchronous evaluation: FALSE
[17:45:17.595] Local evaluation: TRUE
[17:45:17.595] Environment: R_GlobalEnv
[17:45:17.595] Capture standard output: TRUE
[17:45:17.595] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.595] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.595] Packages: 1 packages (‘future.apply’)
[17:45:17.595] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.595] Resolved: TRUE
[17:45:17.595] Value: 560 bytes of class ‘list’
[17:45:17.595] Early signaling: FALSE
[17:45:17.595] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.595] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.596] Chunk #1 of 1 ... DONE
[17:45:17.596] Launching 1 futures (chunks) ... DONE
[17:45:17.596] Resolving 1 futures (chunks) ...
[17:45:17.596] resolve() on list ...
[17:45:17.596]  recursive: 0
[17:45:17.596]  length: 1
[17:45:17.596] 
[17:45:17.596] resolved() for ‘SequentialFuture’ ...
[17:45:17.597] - state: ‘finished’
[17:45:17.597] - run: TRUE
[17:45:17.597] - result: ‘FutureResult’
[17:45:17.597] resolved() for ‘SequentialFuture’ ... done
[17:45:17.597] Future #1
[17:45:17.597] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.597] - nx: 1
[17:45:17.597] - relay: TRUE
[17:45:17.597] - stdout: TRUE
[17:45:17.597] - signal: TRUE
[17:45:17.597] - resignal: FALSE
[17:45:17.598] - force: TRUE
[17:45:17.598] - relayed: [n=1] FALSE
[17:45:17.598] - queued futures: [n=1] FALSE
[17:45:17.598]  - until=1
[17:45:17.598]  - relaying element #1
[17:45:17.598] - relayed: [n=1] TRUE
[17:45:17.598] - queued futures: [n=1] TRUE
[17:45:17.598] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.598]  length: 0 (resolved future 1)
[17:45:17.598] Relaying remaining futures
[17:45:17.598] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.599] - nx: 1
[17:45:17.599] - relay: TRUE
[17:45:17.599] - stdout: TRUE
[17:45:17.599] - signal: TRUE
[17:45:17.599] - resignal: FALSE
[17:45:17.599] - force: TRUE
[17:45:17.599] - relayed: [n=1] TRUE
[17:45:17.599] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.599] - relayed: [n=1] TRUE
[17:45:17.599] - queued futures: [n=1] TRUE
[17:45:17.599] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.600] resolve() on list ... DONE
[17:45:17.600]  - Number of value chunks collected: 1
[17:45:17.600] Resolving 1 futures (chunks) ... DONE
[17:45:17.600] Reducing values from 1 chunks ...
[17:45:17.600]  - Number of values collected after concatenation: 10
[17:45:17.600]  - Number of values expected: 10
[17:45:17.600] Reducing values from 1 chunks ... DONE
[17:45:17.600] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:45:17.601] future_lapply() ...
[17:45:17.603] Number of chunks: 1
[17:45:17.603] getGlobalsAndPackagesXApply() ...
[17:45:17.603]  - future.globals: TRUE
[17:45:17.603] getGlobalsAndPackages() ...
[17:45:17.603] Searching for globals...
[17:45:17.608] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:45:17.608] Searching for globals ... DONE
[17:45:17.608] Resolving globals: FALSE
[17:45:17.609] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:45:17.610] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.610] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.610] - packages: [1] ‘future.apply’
[17:45:17.610] getGlobalsAndPackages() ... DONE
[17:45:17.610]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.610]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.610] Finding globals ... DONE
[17:45:17.610]  - use_args: TRUE
[17:45:17.610]  - Getting '...' globals ...
[17:45:17.611] resolve() on list ...
[17:45:17.611]  recursive: 0
[17:45:17.611]  length: 1
[17:45:17.611]  elements: ‘...’
[17:45:17.611]  length: 0 (resolved future 1)
[17:45:17.611] resolve() on list ... DONE
[17:45:17.611]    - '...' content: [n=0] 
[17:45:17.611] List of 1
[17:45:17.611]  $ ...: list()
[17:45:17.611]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.611]  - attr(*, "where")=List of 1
[17:45:17.611]   ..$ ...:<environment: 0x5561f56b5538> 
[17:45:17.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.611]  - attr(*, "resolved")= logi TRUE
[17:45:17.611]  - attr(*, "total_size")= num NA
[17:45:17.614]  - Getting '...' globals ... DONE
[17:45:17.614] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.614] List of 8
[17:45:17.614]  $ ...future.FUN:function (x, ...)  
[17:45:17.614]  $ x_FUN        :function (x)  
[17:45:17.614]  $ times        : int 2
[17:45:17.614]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.614]  $ stop_if_not  :function (...)  
[17:45:17.614]  $ dim          : NULL
[17:45:17.614]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.614]  $ ...          : list()
[17:45:17.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.614]  - attr(*, "where")=List of 8
[17:45:17.614]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.614]   ..$ ...          :<environment: 0x5561f56b5538> 
[17:45:17.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.614]  - attr(*, "resolved")= logi FALSE
[17:45:17.614]  - attr(*, "total_size")= num 96456
[17:45:17.620] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.620] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.620] Number of futures (= number of chunks): 1
[17:45:17.620] Launching 1 futures (chunks) ...
[17:45:17.620] Chunk #1 of 1 ...
[17:45:17.620]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.620] getGlobalsAndPackages() ...
[17:45:17.620] Searching for globals...
[17:45:17.621] 
[17:45:17.621] Searching for globals ... DONE
[17:45:17.621] - globals: [0] <none>
[17:45:17.621] getGlobalsAndPackages() ... DONE
[17:45:17.621]    + additional globals found: [n=0] 
[17:45:17.621]    + additional namespaces needed: [n=0] 
[17:45:17.621]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.621]  - seeds: <none>
[17:45:17.621]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.621] getGlobalsAndPackages() ...
[17:45:17.622] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.622] Resolving globals: FALSE
[17:45:17.622] Tweak future expression to call with '...' arguments ...
[17:45:17.622] {
[17:45:17.622]     do.call(function(...) {
[17:45:17.622]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.622]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.622]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.622]             on.exit(options(oopts), add = TRUE)
[17:45:17.622]         }
[17:45:17.622]         {
[17:45:17.622]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.622]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.622]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.622]             })
[17:45:17.622]         }
[17:45:17.622]     }, args = future.call.arguments)
[17:45:17.622] }
[17:45:17.622] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.623] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.623] - packages: [1] ‘future.apply’
[17:45:17.623] getGlobalsAndPackages() ... DONE
[17:45:17.623] run() for ‘Future’ ...
[17:45:17.623] - state: ‘created’
[17:45:17.623] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.624] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.624] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.624]   - Field: ‘label’
[17:45:17.624]   - Field: ‘local’
[17:45:17.624]   - Field: ‘owner’
[17:45:17.624]   - Field: ‘envir’
[17:45:17.624]   - Field: ‘packages’
[17:45:17.624]   - Field: ‘gc’
[17:45:17.624]   - Field: ‘conditions’
[17:45:17.624]   - Field: ‘expr’
[17:45:17.625]   - Field: ‘uuid’
[17:45:17.625]   - Field: ‘seed’
[17:45:17.625]   - Field: ‘version’
[17:45:17.625]   - Field: ‘result’
[17:45:17.625]   - Field: ‘asynchronous’
[17:45:17.625]   - Field: ‘calls’
[17:45:17.625]   - Field: ‘globals’
[17:45:17.625]   - Field: ‘stdout’
[17:45:17.625]   - Field: ‘earlySignal’
[17:45:17.625]   - Field: ‘lazy’
[17:45:17.625]   - Field: ‘state’
[17:45:17.626] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.626] - Launch lazy future ...
[17:45:17.626] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.626] Packages needed by future strategies (n = 0): <none>
[17:45:17.628] {
[17:45:17.628]     {
[17:45:17.628]         {
[17:45:17.628]             ...future.startTime <- base::Sys.time()
[17:45:17.628]             {
[17:45:17.628]                 {
[17:45:17.628]                   {
[17:45:17.628]                     {
[17:45:17.628]                       base::local({
[17:45:17.628]                         has_future <- base::requireNamespace("future", 
[17:45:17.628]                           quietly = TRUE)
[17:45:17.628]                         if (has_future) {
[17:45:17.628]                           ns <- base::getNamespace("future")
[17:45:17.628]                           version <- ns[[".package"]][["version"]]
[17:45:17.628]                           if (is.null(version)) 
[17:45:17.628]                             version <- utils::packageVersion("future")
[17:45:17.628]                         }
[17:45:17.628]                         else {
[17:45:17.628]                           version <- NULL
[17:45:17.628]                         }
[17:45:17.628]                         if (!has_future || version < "1.8.0") {
[17:45:17.628]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.628]                             "", base::R.version$version.string), 
[17:45:17.628]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.628]                               "release", "version")], collapse = " "), 
[17:45:17.628]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.628]                             info)
[17:45:17.628]                           info <- base::paste(info, collapse = "; ")
[17:45:17.628]                           if (!has_future) {
[17:45:17.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.628]                               info)
[17:45:17.628]                           }
[17:45:17.628]                           else {
[17:45:17.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.628]                               info, version)
[17:45:17.628]                           }
[17:45:17.628]                           base::stop(msg)
[17:45:17.628]                         }
[17:45:17.628]                       })
[17:45:17.628]                     }
[17:45:17.628]                     base::local({
[17:45:17.628]                       for (pkg in "future.apply") {
[17:45:17.628]                         base::loadNamespace(pkg)
[17:45:17.628]                         base::library(pkg, character.only = TRUE)
[17:45:17.628]                       }
[17:45:17.628]                     })
[17:45:17.628]                   }
[17:45:17.628]                   ...future.strategy.old <- future::plan("list")
[17:45:17.628]                   options(future.plan = NULL)
[17:45:17.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.628]                 }
[17:45:17.628]                 ...future.workdir <- getwd()
[17:45:17.628]             }
[17:45:17.628]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.628]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.628]         }
[17:45:17.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.628]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.628]             base::names(...future.oldOptions))
[17:45:17.628]     }
[17:45:17.628]     if (FALSE) {
[17:45:17.628]     }
[17:45:17.628]     else {
[17:45:17.628]         if (TRUE) {
[17:45:17.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.628]                 open = "w")
[17:45:17.628]         }
[17:45:17.628]         else {
[17:45:17.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.628]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.628]         }
[17:45:17.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.628]             base::sink(type = "output", split = FALSE)
[17:45:17.628]             base::close(...future.stdout)
[17:45:17.628]         }, add = TRUE)
[17:45:17.628]     }
[17:45:17.628]     ...future.frame <- base::sys.nframe()
[17:45:17.628]     ...future.conditions <- base::list()
[17:45:17.628]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.628]     if (FALSE) {
[17:45:17.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.628]     }
[17:45:17.628]     ...future.result <- base::tryCatch({
[17:45:17.628]         base::withCallingHandlers({
[17:45:17.628]             ...future.value <- base::withVisible(base::local({
[17:45:17.628]                 do.call(function(...) {
[17:45:17.628]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.628]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.628]                     ...future.globals.maxSize)) {
[17:45:17.628]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.628]                     on.exit(options(oopts), add = TRUE)
[17:45:17.628]                   }
[17:45:17.628]                   {
[17:45:17.628]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.628]                       FUN = function(jj) {
[17:45:17.628]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.628]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.628]                       })
[17:45:17.628]                   }
[17:45:17.628]                 }, args = future.call.arguments)
[17:45:17.628]             }))
[17:45:17.628]             future::FutureResult(value = ...future.value$value, 
[17:45:17.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.628]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.628]                     ...future.globalenv.names))
[17:45:17.628]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.628]         }, condition = base::local({
[17:45:17.628]             c <- base::c
[17:45:17.628]             inherits <- base::inherits
[17:45:17.628]             invokeRestart <- base::invokeRestart
[17:45:17.628]             length <- base::length
[17:45:17.628]             list <- base::list
[17:45:17.628]             seq.int <- base::seq.int
[17:45:17.628]             signalCondition <- base::signalCondition
[17:45:17.628]             sys.calls <- base::sys.calls
[17:45:17.628]             `[[` <- base::`[[`
[17:45:17.628]             `+` <- base::`+`
[17:45:17.628]             `<<-` <- base::`<<-`
[17:45:17.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.628]                   3L)]
[17:45:17.628]             }
[17:45:17.628]             function(cond) {
[17:45:17.628]                 is_error <- inherits(cond, "error")
[17:45:17.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.628]                   NULL)
[17:45:17.628]                 if (is_error) {
[17:45:17.628]                   sessionInformation <- function() {
[17:45:17.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.628]                       search = base::search(), system = base::Sys.info())
[17:45:17.628]                   }
[17:45:17.628]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.628]                     cond$call), session = sessionInformation(), 
[17:45:17.628]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.628]                   signalCondition(cond)
[17:45:17.628]                 }
[17:45:17.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.628]                 "immediateCondition"))) {
[17:45:17.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.628]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.628]                   if (TRUE && !signal) {
[17:45:17.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.628]                     {
[17:45:17.628]                       inherits <- base::inherits
[17:45:17.628]                       invokeRestart <- base::invokeRestart
[17:45:17.628]                       is.null <- base::is.null
[17:45:17.628]                       muffled <- FALSE
[17:45:17.628]                       if (inherits(cond, "message")) {
[17:45:17.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.628]                         if (muffled) 
[17:45:17.628]                           invokeRestart("muffleMessage")
[17:45:17.628]                       }
[17:45:17.628]                       else if (inherits(cond, "warning")) {
[17:45:17.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.628]                         if (muffled) 
[17:45:17.628]                           invokeRestart("muffleWarning")
[17:45:17.628]                       }
[17:45:17.628]                       else if (inherits(cond, "condition")) {
[17:45:17.628]                         if (!is.null(pattern)) {
[17:45:17.628]                           computeRestarts <- base::computeRestarts
[17:45:17.628]                           grepl <- base::grepl
[17:45:17.628]                           restarts <- computeRestarts(cond)
[17:45:17.628]                           for (restart in restarts) {
[17:45:17.628]                             name <- restart$name
[17:45:17.628]                             if (is.null(name)) 
[17:45:17.628]                               next
[17:45:17.628]                             if (!grepl(pattern, name)) 
[17:45:17.628]                               next
[17:45:17.628]                             invokeRestart(restart)
[17:45:17.628]                             muffled <- TRUE
[17:45:17.628]                             break
[17:45:17.628]                           }
[17:45:17.628]                         }
[17:45:17.628]                       }
[17:45:17.628]                       invisible(muffled)
[17:45:17.628]                     }
[17:45:17.628]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.628]                   }
[17:45:17.628]                 }
[17:45:17.628]                 else {
[17:45:17.628]                   if (TRUE) {
[17:45:17.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.628]                     {
[17:45:17.628]                       inherits <- base::inherits
[17:45:17.628]                       invokeRestart <- base::invokeRestart
[17:45:17.628]                       is.null <- base::is.null
[17:45:17.628]                       muffled <- FALSE
[17:45:17.628]                       if (inherits(cond, "message")) {
[17:45:17.628]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.628]                         if (muffled) 
[17:45:17.628]                           invokeRestart("muffleMessage")
[17:45:17.628]                       }
[17:45:17.628]                       else if (inherits(cond, "warning")) {
[17:45:17.628]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.628]                         if (muffled) 
[17:45:17.628]                           invokeRestart("muffleWarning")
[17:45:17.628]                       }
[17:45:17.628]                       else if (inherits(cond, "condition")) {
[17:45:17.628]                         if (!is.null(pattern)) {
[17:45:17.628]                           computeRestarts <- base::computeRestarts
[17:45:17.628]                           grepl <- base::grepl
[17:45:17.628]                           restarts <- computeRestarts(cond)
[17:45:17.628]                           for (restart in restarts) {
[17:45:17.628]                             name <- restart$name
[17:45:17.628]                             if (is.null(name)) 
[17:45:17.628]                               next
[17:45:17.628]                             if (!grepl(pattern, name)) 
[17:45:17.628]                               next
[17:45:17.628]                             invokeRestart(restart)
[17:45:17.628]                             muffled <- TRUE
[17:45:17.628]                             break
[17:45:17.628]                           }
[17:45:17.628]                         }
[17:45:17.628]                       }
[17:45:17.628]                       invisible(muffled)
[17:45:17.628]                     }
[17:45:17.628]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.628]                   }
[17:45:17.628]                 }
[17:45:17.628]             }
[17:45:17.628]         }))
[17:45:17.628]     }, error = function(ex) {
[17:45:17.628]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.628]                 ...future.rng), started = ...future.startTime, 
[17:45:17.628]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.628]             version = "1.8"), class = "FutureResult")
[17:45:17.628]     }, finally = {
[17:45:17.628]         if (!identical(...future.workdir, getwd())) 
[17:45:17.628]             setwd(...future.workdir)
[17:45:17.628]         {
[17:45:17.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.628]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.628]             }
[17:45:17.628]             base::options(...future.oldOptions)
[17:45:17.628]             if (.Platform$OS.type == "windows") {
[17:45:17.628]                 old_names <- names(...future.oldEnvVars)
[17:45:17.628]                 envs <- base::Sys.getenv()
[17:45:17.628]                 names <- names(envs)
[17:45:17.628]                 common <- intersect(names, old_names)
[17:45:17.628]                 added <- setdiff(names, old_names)
[17:45:17.628]                 removed <- setdiff(old_names, names)
[17:45:17.628]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.628]                   envs[common]]
[17:45:17.628]                 NAMES <- toupper(changed)
[17:45:17.628]                 args <- list()
[17:45:17.628]                 for (kk in seq_along(NAMES)) {
[17:45:17.628]                   name <- changed[[kk]]
[17:45:17.628]                   NAME <- NAMES[[kk]]
[17:45:17.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.628]                     next
[17:45:17.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.628]                 }
[17:45:17.628]                 NAMES <- toupper(added)
[17:45:17.628]                 for (kk in seq_along(NAMES)) {
[17:45:17.628]                   name <- added[[kk]]
[17:45:17.628]                   NAME <- NAMES[[kk]]
[17:45:17.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.628]                     next
[17:45:17.628]                   args[[name]] <- ""
[17:45:17.628]                 }
[17:45:17.628]                 NAMES <- toupper(removed)
[17:45:17.628]                 for (kk in seq_along(NAMES)) {
[17:45:17.628]                   name <- removed[[kk]]
[17:45:17.628]                   NAME <- NAMES[[kk]]
[17:45:17.628]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.628]                     next
[17:45:17.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.628]                 }
[17:45:17.628]                 if (length(args) > 0) 
[17:45:17.628]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.628]             }
[17:45:17.628]             else {
[17:45:17.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.628]             }
[17:45:17.628]             {
[17:45:17.628]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.628]                   0L) {
[17:45:17.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.628]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.628]                   base::options(opts)
[17:45:17.628]                 }
[17:45:17.628]                 {
[17:45:17.628]                   {
[17:45:17.628]                     NULL
[17:45:17.628]                     RNGkind("Mersenne-Twister")
[17:45:17.628]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.628]                       inherits = FALSE)
[17:45:17.628]                   }
[17:45:17.628]                   options(future.plan = NULL)
[17:45:17.628]                   if (is.na(NA_character_)) 
[17:45:17.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.628]                     .init = FALSE)
[17:45:17.628]                 }
[17:45:17.628]             }
[17:45:17.628]         }
[17:45:17.628]     })
[17:45:17.628]     if (TRUE) {
[17:45:17.628]         base::sink(type = "output", split = FALSE)
[17:45:17.628]         if (TRUE) {
[17:45:17.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.628]         }
[17:45:17.628]         else {
[17:45:17.628]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.628]         }
[17:45:17.628]         base::close(...future.stdout)
[17:45:17.628]         ...future.stdout <- NULL
[17:45:17.628]     }
[17:45:17.628]     ...future.result$conditions <- ...future.conditions
[17:45:17.628]     ...future.result$finished <- base::Sys.time()
[17:45:17.628]     ...future.result
[17:45:17.628] }
[17:45:17.630] assign_globals() ...
[17:45:17.630] List of 11
[17:45:17.630]  $ ...future.FUN            :function (x, ...)  
[17:45:17.630]  $ x_FUN                    :function (x)  
[17:45:17.630]  $ times                    : int 2
[17:45:17.630]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.630]  $ stop_if_not              :function (...)  
[17:45:17.630]  $ dim                      : NULL
[17:45:17.630]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.630]  $ future.call.arguments    : list()
[17:45:17.630]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.630]  $ ...future.elements_ii    :List of 10
[17:45:17.630]   ..$ : int 1
[17:45:17.630]   ..$ : int 2
[17:45:17.630]   ..$ : int 3
[17:45:17.630]   ..$ : int 4
[17:45:17.630]   ..$ : int 5
[17:45:17.630]   ..$ : int 6
[17:45:17.630]   ..$ : int 7
[17:45:17.630]   ..$ : int 8
[17:45:17.630]   ..$ : int 9
[17:45:17.630]   ..$ : int 10
[17:45:17.630]  $ ...future.seeds_ii       : NULL
[17:45:17.630]  $ ...future.globals.maxSize: NULL
[17:45:17.630]  - attr(*, "where")=List of 11
[17:45:17.630]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.630]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.630]  - attr(*, "resolved")= logi FALSE
[17:45:17.630]  - attr(*, "total_size")= num 96456
[17:45:17.630]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.630]  - attr(*, "already-done")= logi TRUE
[17:45:17.639] - copied ‘...future.FUN’ to environment
[17:45:17.640] - reassign environment for ‘x_FUN’
[17:45:17.640] - copied ‘x_FUN’ to environment
[17:45:17.640] - copied ‘times’ to environment
[17:45:17.640] - copied ‘stopf’ to environment
[17:45:17.640] - copied ‘stop_if_not’ to environment
[17:45:17.640] - copied ‘dim’ to environment
[17:45:17.640] - copied ‘valid_types’ to environment
[17:45:17.640] - copied ‘future.call.arguments’ to environment
[17:45:17.640] - copied ‘...future.elements_ii’ to environment
[17:45:17.640] - copied ‘...future.seeds_ii’ to environment
[17:45:17.640] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.641] assign_globals() ... done
[17:45:17.641] plan(): Setting new future strategy stack:
[17:45:17.641] List of future strategies:
[17:45:17.641] 1. sequential:
[17:45:17.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.641]    - tweaked: FALSE
[17:45:17.641]    - call: NULL
[17:45:17.642] plan(): nbrOfWorkers() = 1
[17:45:17.642] plan(): Setting new future strategy stack:
[17:45:17.642] List of future strategies:
[17:45:17.642] 1. sequential:
[17:45:17.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.642]    - tweaked: FALSE
[17:45:17.642]    - call: plan(strategy)
[17:45:17.643] plan(): nbrOfWorkers() = 1
[17:45:17.643] SequentialFuture started (and completed)
[17:45:17.643] - Launch lazy future ... done
[17:45:17.643] run() for ‘SequentialFuture’ ... done
[17:45:17.643] Created future:
[17:45:17.643] SequentialFuture:
[17:45:17.643] Label: ‘future_vapply-1’
[17:45:17.643] Expression:
[17:45:17.643] {
[17:45:17.643]     do.call(function(...) {
[17:45:17.643]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.643]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.643]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.643]             on.exit(options(oopts), add = TRUE)
[17:45:17.643]         }
[17:45:17.643]         {
[17:45:17.643]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.643]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.643]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.643]             })
[17:45:17.643]         }
[17:45:17.643]     }, args = future.call.arguments)
[17:45:17.643] }
[17:45:17.643] Lazy evaluation: FALSE
[17:45:17.643] Asynchronous evaluation: FALSE
[17:45:17.643] Local evaluation: TRUE
[17:45:17.643] Environment: R_GlobalEnv
[17:45:17.643] Capture standard output: TRUE
[17:45:17.643] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.643] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.643] Packages: 1 packages (‘future.apply’)
[17:45:17.643] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.643] Resolved: TRUE
[17:45:17.643] Value: 640 bytes of class ‘list’
[17:45:17.643] Early signaling: FALSE
[17:45:17.643] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.643] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.645] Chunk #1 of 1 ... DONE
[17:45:17.645] Launching 1 futures (chunks) ... DONE
[17:45:17.645] Resolving 1 futures (chunks) ...
[17:45:17.645] resolve() on list ...
[17:45:17.645]  recursive: 0
[17:45:17.645]  length: 1
[17:45:17.645] 
[17:45:17.645] resolved() for ‘SequentialFuture’ ...
[17:45:17.645] - state: ‘finished’
[17:45:17.645] - run: TRUE
[17:45:17.646] - result: ‘FutureResult’
[17:45:17.646] resolved() for ‘SequentialFuture’ ... done
[17:45:17.646] Future #1
[17:45:17.646] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.646] - nx: 1
[17:45:17.646] - relay: TRUE
[17:45:17.646] - stdout: TRUE
[17:45:17.646] - signal: TRUE
[17:45:17.646] - resignal: FALSE
[17:45:17.646] - force: TRUE
[17:45:17.646] - relayed: [n=1] FALSE
[17:45:17.647] - queued futures: [n=1] FALSE
[17:45:17.647]  - until=1
[17:45:17.647]  - relaying element #1
[17:45:17.647] - relayed: [n=1] TRUE
[17:45:17.647] - queued futures: [n=1] TRUE
[17:45:17.647] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.647]  length: 0 (resolved future 1)
[17:45:17.647] Relaying remaining futures
[17:45:17.647] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.647] - nx: 1
[17:45:17.648] - relay: TRUE
[17:45:17.648] - stdout: TRUE
[17:45:17.648] - signal: TRUE
[17:45:17.648] - resignal: FALSE
[17:45:17.648] - force: TRUE
[17:45:17.648] - relayed: [n=1] TRUE
[17:45:17.648] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.648] - relayed: [n=1] TRUE
[17:45:17.648] - queued futures: [n=1] TRUE
[17:45:17.648] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.648] resolve() on list ... DONE
[17:45:17.649]  - Number of value chunks collected: 1
[17:45:17.649] Resolving 1 futures (chunks) ... DONE
[17:45:17.649] Reducing values from 1 chunks ...
[17:45:17.649]  - Number of values collected after concatenation: 10
[17:45:17.649]  - Number of values expected: 10
[17:45:17.649] Reducing values from 1 chunks ... DONE
[17:45:17.649] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:45:17.650] future_lapply() ...
[17:45:17.654] Number of chunks: 1
[17:45:17.654] getGlobalsAndPackagesXApply() ...
[17:45:17.654]  - future.globals: TRUE
[17:45:17.654] getGlobalsAndPackages() ...
[17:45:17.654] Searching for globals...
[17:45:17.657] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:45:17.657] Searching for globals ... DONE
[17:45:17.658] Resolving globals: FALSE
[17:45:17.658] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:45:17.659] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.659] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.659] - packages: [1] ‘future.apply’
[17:45:17.659] getGlobalsAndPackages() ... DONE
[17:45:17.659]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.659]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.659] Finding globals ... DONE
[17:45:17.660]  - use_args: TRUE
[17:45:17.660]  - Getting '...' globals ...
[17:45:17.660] resolve() on list ...
[17:45:17.660]  recursive: 0
[17:45:17.660]  length: 1
[17:45:17.660]  elements: ‘...’
[17:45:17.660]  length: 0 (resolved future 1)
[17:45:17.661] resolve() on list ... DONE
[17:45:17.661]    - '...' content: [n=0] 
[17:45:17.661] List of 1
[17:45:17.661]  $ ...: list()
[17:45:17.661]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.661]  - attr(*, "where")=List of 1
[17:45:17.661]   ..$ ...:<environment: 0x5561f5861b40> 
[17:45:17.661]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.661]  - attr(*, "resolved")= logi TRUE
[17:45:17.661]  - attr(*, "total_size")= num NA
[17:45:17.663]  - Getting '...' globals ... DONE
[17:45:17.663] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.663] List of 8
[17:45:17.663]  $ ...future.FUN:function (x, ...)  
[17:45:17.663]  $ x_FUN        :function (x)  
[17:45:17.663]  $ times        : int 4
[17:45:17.663]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.663]  $ stop_if_not  :function (...)  
[17:45:17.663]  $ dim          : int [1:2] 2 2
[17:45:17.663]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:17.663]  $ ...          : list()
[17:45:17.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.663]  - attr(*, "where")=List of 8
[17:45:17.663]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.663]   ..$ ...          :<environment: 0x5561f5861b40> 
[17:45:17.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.663]  - attr(*, "resolved")= logi FALSE
[17:45:17.663]  - attr(*, "total_size")= num 97232
[17:45:17.669] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.669] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.669] Number of futures (= number of chunks): 1
[17:45:17.669] Launching 1 futures (chunks) ...
[17:45:17.669] Chunk #1 of 1 ...
[17:45:17.669]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.669] getGlobalsAndPackages() ...
[17:45:17.670] Searching for globals...
[17:45:17.670] 
[17:45:17.670] Searching for globals ... DONE
[17:45:17.670] - globals: [0] <none>
[17:45:17.670] getGlobalsAndPackages() ... DONE
[17:45:17.670]    + additional globals found: [n=0] 
[17:45:17.670]    + additional namespaces needed: [n=0] 
[17:45:17.670]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.670]  - seeds: <none>
[17:45:17.670]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.671] getGlobalsAndPackages() ...
[17:45:17.671] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.671] Resolving globals: FALSE
[17:45:17.671] Tweak future expression to call with '...' arguments ...
[17:45:17.671] {
[17:45:17.671]     do.call(function(...) {
[17:45:17.671]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.671]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.671]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.671]             on.exit(options(oopts), add = TRUE)
[17:45:17.671]         }
[17:45:17.671]         {
[17:45:17.671]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.671]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.671]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.671]             })
[17:45:17.671]         }
[17:45:17.671]     }, args = future.call.arguments)
[17:45:17.671] }
[17:45:17.671] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.672] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.672] - packages: [1] ‘future.apply’
[17:45:17.672] getGlobalsAndPackages() ... DONE
[17:45:17.672] run() for ‘Future’ ...
[17:45:17.672] - state: ‘created’
[17:45:17.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.675]   - Field: ‘label’
[17:45:17.675]   - Field: ‘local’
[17:45:17.675]   - Field: ‘owner’
[17:45:17.675]   - Field: ‘envir’
[17:45:17.675]   - Field: ‘packages’
[17:45:17.675]   - Field: ‘gc’
[17:45:17.675]   - Field: ‘conditions’
[17:45:17.675]   - Field: ‘expr’
[17:45:17.676]   - Field: ‘uuid’
[17:45:17.676]   - Field: ‘seed’
[17:45:17.676]   - Field: ‘version’
[17:45:17.676]   - Field: ‘result’
[17:45:17.676]   - Field: ‘asynchronous’
[17:45:17.676]   - Field: ‘calls’
[17:45:17.676]   - Field: ‘globals’
[17:45:17.676]   - Field: ‘stdout’
[17:45:17.676]   - Field: ‘earlySignal’
[17:45:17.676]   - Field: ‘lazy’
[17:45:17.676]   - Field: ‘state’
[17:45:17.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.677] - Launch lazy future ...
[17:45:17.677] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.677] Packages needed by future strategies (n = 0): <none>
[17:45:17.677] {
[17:45:17.677]     {
[17:45:17.677]         {
[17:45:17.677]             ...future.startTime <- base::Sys.time()
[17:45:17.677]             {
[17:45:17.677]                 {
[17:45:17.677]                   {
[17:45:17.677]                     {
[17:45:17.677]                       base::local({
[17:45:17.677]                         has_future <- base::requireNamespace("future", 
[17:45:17.677]                           quietly = TRUE)
[17:45:17.677]                         if (has_future) {
[17:45:17.677]                           ns <- base::getNamespace("future")
[17:45:17.677]                           version <- ns[[".package"]][["version"]]
[17:45:17.677]                           if (is.null(version)) 
[17:45:17.677]                             version <- utils::packageVersion("future")
[17:45:17.677]                         }
[17:45:17.677]                         else {
[17:45:17.677]                           version <- NULL
[17:45:17.677]                         }
[17:45:17.677]                         if (!has_future || version < "1.8.0") {
[17:45:17.677]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.677]                             "", base::R.version$version.string), 
[17:45:17.677]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.677]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.677]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.677]                               "release", "version")], collapse = " "), 
[17:45:17.677]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.677]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.677]                             info)
[17:45:17.677]                           info <- base::paste(info, collapse = "; ")
[17:45:17.677]                           if (!has_future) {
[17:45:17.677]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.677]                               info)
[17:45:17.677]                           }
[17:45:17.677]                           else {
[17:45:17.677]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.677]                               info, version)
[17:45:17.677]                           }
[17:45:17.677]                           base::stop(msg)
[17:45:17.677]                         }
[17:45:17.677]                       })
[17:45:17.677]                     }
[17:45:17.677]                     base::local({
[17:45:17.677]                       for (pkg in "future.apply") {
[17:45:17.677]                         base::loadNamespace(pkg)
[17:45:17.677]                         base::library(pkg, character.only = TRUE)
[17:45:17.677]                       }
[17:45:17.677]                     })
[17:45:17.677]                   }
[17:45:17.677]                   ...future.strategy.old <- future::plan("list")
[17:45:17.677]                   options(future.plan = NULL)
[17:45:17.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.677]                 }
[17:45:17.677]                 ...future.workdir <- getwd()
[17:45:17.677]             }
[17:45:17.677]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.677]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.677]         }
[17:45:17.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.677]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.677]             base::names(...future.oldOptions))
[17:45:17.677]     }
[17:45:17.677]     if (FALSE) {
[17:45:17.677]     }
[17:45:17.677]     else {
[17:45:17.677]         if (TRUE) {
[17:45:17.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.677]                 open = "w")
[17:45:17.677]         }
[17:45:17.677]         else {
[17:45:17.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.677]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.677]         }
[17:45:17.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.677]             base::sink(type = "output", split = FALSE)
[17:45:17.677]             base::close(...future.stdout)
[17:45:17.677]         }, add = TRUE)
[17:45:17.677]     }
[17:45:17.677]     ...future.frame <- base::sys.nframe()
[17:45:17.677]     ...future.conditions <- base::list()
[17:45:17.677]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.677]     if (FALSE) {
[17:45:17.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.677]     }
[17:45:17.677]     ...future.result <- base::tryCatch({
[17:45:17.677]         base::withCallingHandlers({
[17:45:17.677]             ...future.value <- base::withVisible(base::local({
[17:45:17.677]                 do.call(function(...) {
[17:45:17.677]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.677]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.677]                     ...future.globals.maxSize)) {
[17:45:17.677]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.677]                     on.exit(options(oopts), add = TRUE)
[17:45:17.677]                   }
[17:45:17.677]                   {
[17:45:17.677]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.677]                       FUN = function(jj) {
[17:45:17.677]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.677]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.677]                       })
[17:45:17.677]                   }
[17:45:17.677]                 }, args = future.call.arguments)
[17:45:17.677]             }))
[17:45:17.677]             future::FutureResult(value = ...future.value$value, 
[17:45:17.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.677]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.677]                     ...future.globalenv.names))
[17:45:17.677]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.677]         }, condition = base::local({
[17:45:17.677]             c <- base::c
[17:45:17.677]             inherits <- base::inherits
[17:45:17.677]             invokeRestart <- base::invokeRestart
[17:45:17.677]             length <- base::length
[17:45:17.677]             list <- base::list
[17:45:17.677]             seq.int <- base::seq.int
[17:45:17.677]             signalCondition <- base::signalCondition
[17:45:17.677]             sys.calls <- base::sys.calls
[17:45:17.677]             `[[` <- base::`[[`
[17:45:17.677]             `+` <- base::`+`
[17:45:17.677]             `<<-` <- base::`<<-`
[17:45:17.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.677]                   3L)]
[17:45:17.677]             }
[17:45:17.677]             function(cond) {
[17:45:17.677]                 is_error <- inherits(cond, "error")
[17:45:17.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.677]                   NULL)
[17:45:17.677]                 if (is_error) {
[17:45:17.677]                   sessionInformation <- function() {
[17:45:17.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.677]                       search = base::search(), system = base::Sys.info())
[17:45:17.677]                   }
[17:45:17.677]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.677]                     cond$call), session = sessionInformation(), 
[17:45:17.677]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.677]                   signalCondition(cond)
[17:45:17.677]                 }
[17:45:17.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.677]                 "immediateCondition"))) {
[17:45:17.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.677]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.677]                   if (TRUE && !signal) {
[17:45:17.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.677]                     {
[17:45:17.677]                       inherits <- base::inherits
[17:45:17.677]                       invokeRestart <- base::invokeRestart
[17:45:17.677]                       is.null <- base::is.null
[17:45:17.677]                       muffled <- FALSE
[17:45:17.677]                       if (inherits(cond, "message")) {
[17:45:17.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.677]                         if (muffled) 
[17:45:17.677]                           invokeRestart("muffleMessage")
[17:45:17.677]                       }
[17:45:17.677]                       else if (inherits(cond, "warning")) {
[17:45:17.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.677]                         if (muffled) 
[17:45:17.677]                           invokeRestart("muffleWarning")
[17:45:17.677]                       }
[17:45:17.677]                       else if (inherits(cond, "condition")) {
[17:45:17.677]                         if (!is.null(pattern)) {
[17:45:17.677]                           computeRestarts <- base::computeRestarts
[17:45:17.677]                           grepl <- base::grepl
[17:45:17.677]                           restarts <- computeRestarts(cond)
[17:45:17.677]                           for (restart in restarts) {
[17:45:17.677]                             name <- restart$name
[17:45:17.677]                             if (is.null(name)) 
[17:45:17.677]                               next
[17:45:17.677]                             if (!grepl(pattern, name)) 
[17:45:17.677]                               next
[17:45:17.677]                             invokeRestart(restart)
[17:45:17.677]                             muffled <- TRUE
[17:45:17.677]                             break
[17:45:17.677]                           }
[17:45:17.677]                         }
[17:45:17.677]                       }
[17:45:17.677]                       invisible(muffled)
[17:45:17.677]                     }
[17:45:17.677]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.677]                   }
[17:45:17.677]                 }
[17:45:17.677]                 else {
[17:45:17.677]                   if (TRUE) {
[17:45:17.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.677]                     {
[17:45:17.677]                       inherits <- base::inherits
[17:45:17.677]                       invokeRestart <- base::invokeRestart
[17:45:17.677]                       is.null <- base::is.null
[17:45:17.677]                       muffled <- FALSE
[17:45:17.677]                       if (inherits(cond, "message")) {
[17:45:17.677]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.677]                         if (muffled) 
[17:45:17.677]                           invokeRestart("muffleMessage")
[17:45:17.677]                       }
[17:45:17.677]                       else if (inherits(cond, "warning")) {
[17:45:17.677]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.677]                         if (muffled) 
[17:45:17.677]                           invokeRestart("muffleWarning")
[17:45:17.677]                       }
[17:45:17.677]                       else if (inherits(cond, "condition")) {
[17:45:17.677]                         if (!is.null(pattern)) {
[17:45:17.677]                           computeRestarts <- base::computeRestarts
[17:45:17.677]                           grepl <- base::grepl
[17:45:17.677]                           restarts <- computeRestarts(cond)
[17:45:17.677]                           for (restart in restarts) {
[17:45:17.677]                             name <- restart$name
[17:45:17.677]                             if (is.null(name)) 
[17:45:17.677]                               next
[17:45:17.677]                             if (!grepl(pattern, name)) 
[17:45:17.677]                               next
[17:45:17.677]                             invokeRestart(restart)
[17:45:17.677]                             muffled <- TRUE
[17:45:17.677]                             break
[17:45:17.677]                           }
[17:45:17.677]                         }
[17:45:17.677]                       }
[17:45:17.677]                       invisible(muffled)
[17:45:17.677]                     }
[17:45:17.677]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.677]                   }
[17:45:17.677]                 }
[17:45:17.677]             }
[17:45:17.677]         }))
[17:45:17.677]     }, error = function(ex) {
[17:45:17.677]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.677]                 ...future.rng), started = ...future.startTime, 
[17:45:17.677]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.677]             version = "1.8"), class = "FutureResult")
[17:45:17.677]     }, finally = {
[17:45:17.677]         if (!identical(...future.workdir, getwd())) 
[17:45:17.677]             setwd(...future.workdir)
[17:45:17.677]         {
[17:45:17.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.677]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.677]             }
[17:45:17.677]             base::options(...future.oldOptions)
[17:45:17.677]             if (.Platform$OS.type == "windows") {
[17:45:17.677]                 old_names <- names(...future.oldEnvVars)
[17:45:17.677]                 envs <- base::Sys.getenv()
[17:45:17.677]                 names <- names(envs)
[17:45:17.677]                 common <- intersect(names, old_names)
[17:45:17.677]                 added <- setdiff(names, old_names)
[17:45:17.677]                 removed <- setdiff(old_names, names)
[17:45:17.677]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.677]                   envs[common]]
[17:45:17.677]                 NAMES <- toupper(changed)
[17:45:17.677]                 args <- list()
[17:45:17.677]                 for (kk in seq_along(NAMES)) {
[17:45:17.677]                   name <- changed[[kk]]
[17:45:17.677]                   NAME <- NAMES[[kk]]
[17:45:17.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.677]                     next
[17:45:17.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.677]                 }
[17:45:17.677]                 NAMES <- toupper(added)
[17:45:17.677]                 for (kk in seq_along(NAMES)) {
[17:45:17.677]                   name <- added[[kk]]
[17:45:17.677]                   NAME <- NAMES[[kk]]
[17:45:17.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.677]                     next
[17:45:17.677]                   args[[name]] <- ""
[17:45:17.677]                 }
[17:45:17.677]                 NAMES <- toupper(removed)
[17:45:17.677]                 for (kk in seq_along(NAMES)) {
[17:45:17.677]                   name <- removed[[kk]]
[17:45:17.677]                   NAME <- NAMES[[kk]]
[17:45:17.677]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.677]                     next
[17:45:17.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.677]                 }
[17:45:17.677]                 if (length(args) > 0) 
[17:45:17.677]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.677]             }
[17:45:17.677]             else {
[17:45:17.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.677]             }
[17:45:17.677]             {
[17:45:17.677]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.677]                   0L) {
[17:45:17.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.677]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.677]                   base::options(opts)
[17:45:17.677]                 }
[17:45:17.677]                 {
[17:45:17.677]                   {
[17:45:17.677]                     NULL
[17:45:17.677]                     RNGkind("Mersenne-Twister")
[17:45:17.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.677]                       inherits = FALSE)
[17:45:17.677]                   }
[17:45:17.677]                   options(future.plan = NULL)
[17:45:17.677]                   if (is.na(NA_character_)) 
[17:45:17.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.677]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.677]                     .init = FALSE)
[17:45:17.677]                 }
[17:45:17.677]             }
[17:45:17.677]         }
[17:45:17.677]     })
[17:45:17.677]     if (TRUE) {
[17:45:17.677]         base::sink(type = "output", split = FALSE)
[17:45:17.677]         if (TRUE) {
[17:45:17.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.677]         }
[17:45:17.677]         else {
[17:45:17.677]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.677]         }
[17:45:17.677]         base::close(...future.stdout)
[17:45:17.677]         ...future.stdout <- NULL
[17:45:17.677]     }
[17:45:17.677]     ...future.result$conditions <- ...future.conditions
[17:45:17.677]     ...future.result$finished <- base::Sys.time()
[17:45:17.677]     ...future.result
[17:45:17.677] }
[17:45:17.679] assign_globals() ...
[17:45:17.679] List of 11
[17:45:17.679]  $ ...future.FUN            :function (x, ...)  
[17:45:17.679]  $ x_FUN                    :function (x)  
[17:45:17.679]  $ times                    : int 4
[17:45:17.679]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.679]  $ stop_if_not              :function (...)  
[17:45:17.679]  $ dim                      : int [1:2] 2 2
[17:45:17.679]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:17.679]  $ future.call.arguments    : list()
[17:45:17.679]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.679]  $ ...future.elements_ii    :List of 10
[17:45:17.679]   ..$ : int 1
[17:45:17.679]   ..$ : int 2
[17:45:17.679]   ..$ : int 3
[17:45:17.679]   ..$ : int 4
[17:45:17.679]   ..$ : int 5
[17:45:17.679]   ..$ : int 6
[17:45:17.679]   ..$ : int 7
[17:45:17.679]   ..$ : int 8
[17:45:17.679]   ..$ : int 9
[17:45:17.679]   ..$ : int 10
[17:45:17.679]  $ ...future.seeds_ii       : NULL
[17:45:17.679]  $ ...future.globals.maxSize: NULL
[17:45:17.679]  - attr(*, "where")=List of 11
[17:45:17.679]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.679]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.679]  - attr(*, "resolved")= logi FALSE
[17:45:17.679]  - attr(*, "total_size")= num 97232
[17:45:17.679]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.679]  - attr(*, "already-done")= logi TRUE
[17:45:17.689] - copied ‘...future.FUN’ to environment
[17:45:17.689] - reassign environment for ‘x_FUN’
[17:45:17.689] - copied ‘x_FUN’ to environment
[17:45:17.689] - copied ‘times’ to environment
[17:45:17.689] - copied ‘stopf’ to environment
[17:45:17.690] - copied ‘stop_if_not’ to environment
[17:45:17.690] - copied ‘dim’ to environment
[17:45:17.690] - copied ‘valid_types’ to environment
[17:45:17.690] - copied ‘future.call.arguments’ to environment
[17:45:17.690] - copied ‘...future.elements_ii’ to environment
[17:45:17.690] - copied ‘...future.seeds_ii’ to environment
[17:45:17.690] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.690] assign_globals() ... done
[17:45:17.691] plan(): Setting new future strategy stack:
[17:45:17.691] List of future strategies:
[17:45:17.691] 1. sequential:
[17:45:17.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.691]    - tweaked: FALSE
[17:45:17.691]    - call: NULL
[17:45:17.691] plan(): nbrOfWorkers() = 1
[17:45:17.692] plan(): Setting new future strategy stack:
[17:45:17.692] List of future strategies:
[17:45:17.692] 1. sequential:
[17:45:17.692]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.692]    - tweaked: FALSE
[17:45:17.692]    - call: plan(strategy)
[17:45:17.693] plan(): nbrOfWorkers() = 1
[17:45:17.693] SequentialFuture started (and completed)
[17:45:17.693] - Launch lazy future ... done
[17:45:17.693] run() for ‘SequentialFuture’ ... done
[17:45:17.693] Created future:
[17:45:17.693] SequentialFuture:
[17:45:17.693] Label: ‘future_vapply-1’
[17:45:17.693] Expression:
[17:45:17.693] {
[17:45:17.693]     do.call(function(...) {
[17:45:17.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.693]             on.exit(options(oopts), add = TRUE)
[17:45:17.693]         }
[17:45:17.693]         {
[17:45:17.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.693]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.693]             })
[17:45:17.693]         }
[17:45:17.693]     }, args = future.call.arguments)
[17:45:17.693] }
[17:45:17.693] Lazy evaluation: FALSE
[17:45:17.693] Asynchronous evaluation: FALSE
[17:45:17.693] Local evaluation: TRUE
[17:45:17.693] Environment: R_GlobalEnv
[17:45:17.693] Capture standard output: TRUE
[17:45:17.693] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.693] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.693] Packages: 1 packages (‘future.apply’)
[17:45:17.693] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.693] Resolved: TRUE
[17:45:17.693] Value: 2.27 KiB of class ‘list’
[17:45:17.693] Early signaling: FALSE
[17:45:17.693] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.693] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.694] Chunk #1 of 1 ... DONE
[17:45:17.695] Launching 1 futures (chunks) ... DONE
[17:45:17.695] Resolving 1 futures (chunks) ...
[17:45:17.695] resolve() on list ...
[17:45:17.695]  recursive: 0
[17:45:17.695]  length: 1
[17:45:17.695] 
[17:45:17.695] resolved() for ‘SequentialFuture’ ...
[17:45:17.695] - state: ‘finished’
[17:45:17.695] - run: TRUE
[17:45:17.695] - result: ‘FutureResult’
[17:45:17.696] resolved() for ‘SequentialFuture’ ... done
[17:45:17.696] Future #1
[17:45:17.696] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.696] - nx: 1
[17:45:17.696] - relay: TRUE
[17:45:17.696] - stdout: TRUE
[17:45:17.696] - signal: TRUE
[17:45:17.696] - resignal: FALSE
[17:45:17.696] - force: TRUE
[17:45:17.696] - relayed: [n=1] FALSE
[17:45:17.697] - queued futures: [n=1] FALSE
[17:45:17.697]  - until=1
[17:45:17.697]  - relaying element #1
[17:45:17.697] - relayed: [n=1] TRUE
[17:45:17.697] - queued futures: [n=1] TRUE
[17:45:17.697] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.697]  length: 0 (resolved future 1)
[17:45:17.697] Relaying remaining futures
[17:45:17.697] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.699] - nx: 1
[17:45:17.700] - relay: TRUE
[17:45:17.700] - stdout: TRUE
[17:45:17.700] - signal: TRUE
[17:45:17.700] - resignal: FALSE
[17:45:17.700] - force: TRUE
[17:45:17.700] - relayed: [n=1] TRUE
[17:45:17.700] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.700] - relayed: [n=1] TRUE
[17:45:17.700] - queued futures: [n=1] TRUE
[17:45:17.700] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.701] resolve() on list ... DONE
[17:45:17.701]  - Number of value chunks collected: 1
[17:45:17.701] Resolving 1 futures (chunks) ... DONE
[17:45:17.701] Reducing values from 1 chunks ...
[17:45:17.701]  - Number of values collected after concatenation: 10
[17:45:17.701]  - Number of values expected: 10
[17:45:17.701] Reducing values from 1 chunks ... DONE
[17:45:17.701] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:45:17.702] future_lapply() ...
[17:45:17.704] Number of chunks: 1
[17:45:17.704] getGlobalsAndPackagesXApply() ...
[17:45:17.704]  - future.globals: TRUE
[17:45:17.704] getGlobalsAndPackages() ...
[17:45:17.704] Searching for globals...
[17:45:17.708] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:45:17.708] Searching for globals ... DONE
[17:45:17.708] Resolving globals: FALSE
[17:45:17.709] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:45:17.709] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.709] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.710] - packages: [1] ‘future.apply’
[17:45:17.710] getGlobalsAndPackages() ... DONE
[17:45:17.710]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.710]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.710] Finding globals ... DONE
[17:45:17.710]  - use_args: TRUE
[17:45:17.710]  - Getting '...' globals ...
[17:45:17.711] resolve() on list ...
[17:45:17.711]  recursive: 0
[17:45:17.711]  length: 1
[17:45:17.711]  elements: ‘...’
[17:45:17.711]  length: 0 (resolved future 1)
[17:45:17.711] resolve() on list ... DONE
[17:45:17.711]    - '...' content: [n=0] 
[17:45:17.711] List of 1
[17:45:17.711]  $ ...: list()
[17:45:17.711]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.711]  - attr(*, "where")=List of 1
[17:45:17.711]   ..$ ...:<environment: 0x5561f314bfd8> 
[17:45:17.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.711]  - attr(*, "resolved")= logi TRUE
[17:45:17.711]  - attr(*, "total_size")= num NA
[17:45:17.714]  - Getting '...' globals ... DONE
[17:45:17.714] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.714] List of 8
[17:45:17.714]  $ ...future.FUN:function (x, ...)  
[17:45:17.714]  $ x_FUN        :function (x)  
[17:45:17.714]  $ times        : int 4
[17:45:17.714]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.714]  $ stop_if_not  :function (...)  
[17:45:17.714]  $ dim          : int [1:2] 2 2
[17:45:17.714]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.714]  $ ...          : list()
[17:45:17.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.714]  - attr(*, "where")=List of 8
[17:45:17.714]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.714]   ..$ ...          :<environment: 0x5561f314bfd8> 
[17:45:17.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.714]  - attr(*, "resolved")= logi FALSE
[17:45:17.714]  - attr(*, "total_size")= num 97304
[17:45:17.719] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.719] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.720] Number of futures (= number of chunks): 1
[17:45:17.720] Launching 1 futures (chunks) ...
[17:45:17.720] Chunk #1 of 1 ...
[17:45:17.720]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.720] getGlobalsAndPackages() ...
[17:45:17.720] Searching for globals...
[17:45:17.722] 
[17:45:17.722] Searching for globals ... DONE
[17:45:17.722] - globals: [0] <none>
[17:45:17.723] getGlobalsAndPackages() ... DONE
[17:45:17.723]    + additional globals found: [n=0] 
[17:45:17.723]    + additional namespaces needed: [n=0] 
[17:45:17.723]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.723]  - seeds: <none>
[17:45:17.723]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.723] getGlobalsAndPackages() ...
[17:45:17.723] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.723] Resolving globals: FALSE
[17:45:17.723] Tweak future expression to call with '...' arguments ...
[17:45:17.724] {
[17:45:17.724]     do.call(function(...) {
[17:45:17.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.724]             on.exit(options(oopts), add = TRUE)
[17:45:17.724]         }
[17:45:17.724]         {
[17:45:17.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.724]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.724]             })
[17:45:17.724]         }
[17:45:17.724]     }, args = future.call.arguments)
[17:45:17.724] }
[17:45:17.724] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.724] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.724] - packages: [1] ‘future.apply’
[17:45:17.725] getGlobalsAndPackages() ... DONE
[17:45:17.725] run() for ‘Future’ ...
[17:45:17.725] - state: ‘created’
[17:45:17.725] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.725] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.726]   - Field: ‘label’
[17:45:17.726]   - Field: ‘local’
[17:45:17.726]   - Field: ‘owner’
[17:45:17.726]   - Field: ‘envir’
[17:45:17.726]   - Field: ‘packages’
[17:45:17.726]   - Field: ‘gc’
[17:45:17.726]   - Field: ‘conditions’
[17:45:17.726]   - Field: ‘expr’
[17:45:17.726]   - Field: ‘uuid’
[17:45:17.726]   - Field: ‘seed’
[17:45:17.726]   - Field: ‘version’
[17:45:17.727]   - Field: ‘result’
[17:45:17.727]   - Field: ‘asynchronous’
[17:45:17.727]   - Field: ‘calls’
[17:45:17.727]   - Field: ‘globals’
[17:45:17.727]   - Field: ‘stdout’
[17:45:17.727]   - Field: ‘earlySignal’
[17:45:17.727]   - Field: ‘lazy’
[17:45:17.727]   - Field: ‘state’
[17:45:17.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.727] - Launch lazy future ...
[17:45:17.728] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.728] Packages needed by future strategies (n = 0): <none>
[17:45:17.728] {
[17:45:17.728]     {
[17:45:17.728]         {
[17:45:17.728]             ...future.startTime <- base::Sys.time()
[17:45:17.728]             {
[17:45:17.728]                 {
[17:45:17.728]                   {
[17:45:17.728]                     {
[17:45:17.728]                       base::local({
[17:45:17.728]                         has_future <- base::requireNamespace("future", 
[17:45:17.728]                           quietly = TRUE)
[17:45:17.728]                         if (has_future) {
[17:45:17.728]                           ns <- base::getNamespace("future")
[17:45:17.728]                           version <- ns[[".package"]][["version"]]
[17:45:17.728]                           if (is.null(version)) 
[17:45:17.728]                             version <- utils::packageVersion("future")
[17:45:17.728]                         }
[17:45:17.728]                         else {
[17:45:17.728]                           version <- NULL
[17:45:17.728]                         }
[17:45:17.728]                         if (!has_future || version < "1.8.0") {
[17:45:17.728]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.728]                             "", base::R.version$version.string), 
[17:45:17.728]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.728]                               "release", "version")], collapse = " "), 
[17:45:17.728]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.728]                             info)
[17:45:17.728]                           info <- base::paste(info, collapse = "; ")
[17:45:17.728]                           if (!has_future) {
[17:45:17.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.728]                               info)
[17:45:17.728]                           }
[17:45:17.728]                           else {
[17:45:17.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.728]                               info, version)
[17:45:17.728]                           }
[17:45:17.728]                           base::stop(msg)
[17:45:17.728]                         }
[17:45:17.728]                       })
[17:45:17.728]                     }
[17:45:17.728]                     base::local({
[17:45:17.728]                       for (pkg in "future.apply") {
[17:45:17.728]                         base::loadNamespace(pkg)
[17:45:17.728]                         base::library(pkg, character.only = TRUE)
[17:45:17.728]                       }
[17:45:17.728]                     })
[17:45:17.728]                   }
[17:45:17.728]                   ...future.strategy.old <- future::plan("list")
[17:45:17.728]                   options(future.plan = NULL)
[17:45:17.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.728]                 }
[17:45:17.728]                 ...future.workdir <- getwd()
[17:45:17.728]             }
[17:45:17.728]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.728]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.728]         }
[17:45:17.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.728]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.728]             base::names(...future.oldOptions))
[17:45:17.728]     }
[17:45:17.728]     if (FALSE) {
[17:45:17.728]     }
[17:45:17.728]     else {
[17:45:17.728]         if (TRUE) {
[17:45:17.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.728]                 open = "w")
[17:45:17.728]         }
[17:45:17.728]         else {
[17:45:17.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.728]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.728]         }
[17:45:17.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.728]             base::sink(type = "output", split = FALSE)
[17:45:17.728]             base::close(...future.stdout)
[17:45:17.728]         }, add = TRUE)
[17:45:17.728]     }
[17:45:17.728]     ...future.frame <- base::sys.nframe()
[17:45:17.728]     ...future.conditions <- base::list()
[17:45:17.728]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.728]     if (FALSE) {
[17:45:17.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.728]     }
[17:45:17.728]     ...future.result <- base::tryCatch({
[17:45:17.728]         base::withCallingHandlers({
[17:45:17.728]             ...future.value <- base::withVisible(base::local({
[17:45:17.728]                 do.call(function(...) {
[17:45:17.728]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.728]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.728]                     ...future.globals.maxSize)) {
[17:45:17.728]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.728]                     on.exit(options(oopts), add = TRUE)
[17:45:17.728]                   }
[17:45:17.728]                   {
[17:45:17.728]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.728]                       FUN = function(jj) {
[17:45:17.728]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.728]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.728]                       })
[17:45:17.728]                   }
[17:45:17.728]                 }, args = future.call.arguments)
[17:45:17.728]             }))
[17:45:17.728]             future::FutureResult(value = ...future.value$value, 
[17:45:17.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.728]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.728]                     ...future.globalenv.names))
[17:45:17.728]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.728]         }, condition = base::local({
[17:45:17.728]             c <- base::c
[17:45:17.728]             inherits <- base::inherits
[17:45:17.728]             invokeRestart <- base::invokeRestart
[17:45:17.728]             length <- base::length
[17:45:17.728]             list <- base::list
[17:45:17.728]             seq.int <- base::seq.int
[17:45:17.728]             signalCondition <- base::signalCondition
[17:45:17.728]             sys.calls <- base::sys.calls
[17:45:17.728]             `[[` <- base::`[[`
[17:45:17.728]             `+` <- base::`+`
[17:45:17.728]             `<<-` <- base::`<<-`
[17:45:17.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.728]                   3L)]
[17:45:17.728]             }
[17:45:17.728]             function(cond) {
[17:45:17.728]                 is_error <- inherits(cond, "error")
[17:45:17.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.728]                   NULL)
[17:45:17.728]                 if (is_error) {
[17:45:17.728]                   sessionInformation <- function() {
[17:45:17.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.728]                       search = base::search(), system = base::Sys.info())
[17:45:17.728]                   }
[17:45:17.728]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.728]                     cond$call), session = sessionInformation(), 
[17:45:17.728]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.728]                   signalCondition(cond)
[17:45:17.728]                 }
[17:45:17.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.728]                 "immediateCondition"))) {
[17:45:17.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.728]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.728]                   if (TRUE && !signal) {
[17:45:17.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.728]                     {
[17:45:17.728]                       inherits <- base::inherits
[17:45:17.728]                       invokeRestart <- base::invokeRestart
[17:45:17.728]                       is.null <- base::is.null
[17:45:17.728]                       muffled <- FALSE
[17:45:17.728]                       if (inherits(cond, "message")) {
[17:45:17.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.728]                         if (muffled) 
[17:45:17.728]                           invokeRestart("muffleMessage")
[17:45:17.728]                       }
[17:45:17.728]                       else if (inherits(cond, "warning")) {
[17:45:17.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.728]                         if (muffled) 
[17:45:17.728]                           invokeRestart("muffleWarning")
[17:45:17.728]                       }
[17:45:17.728]                       else if (inherits(cond, "condition")) {
[17:45:17.728]                         if (!is.null(pattern)) {
[17:45:17.728]                           computeRestarts <- base::computeRestarts
[17:45:17.728]                           grepl <- base::grepl
[17:45:17.728]                           restarts <- computeRestarts(cond)
[17:45:17.728]                           for (restart in restarts) {
[17:45:17.728]                             name <- restart$name
[17:45:17.728]                             if (is.null(name)) 
[17:45:17.728]                               next
[17:45:17.728]                             if (!grepl(pattern, name)) 
[17:45:17.728]                               next
[17:45:17.728]                             invokeRestart(restart)
[17:45:17.728]                             muffled <- TRUE
[17:45:17.728]                             break
[17:45:17.728]                           }
[17:45:17.728]                         }
[17:45:17.728]                       }
[17:45:17.728]                       invisible(muffled)
[17:45:17.728]                     }
[17:45:17.728]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.728]                   }
[17:45:17.728]                 }
[17:45:17.728]                 else {
[17:45:17.728]                   if (TRUE) {
[17:45:17.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.728]                     {
[17:45:17.728]                       inherits <- base::inherits
[17:45:17.728]                       invokeRestart <- base::invokeRestart
[17:45:17.728]                       is.null <- base::is.null
[17:45:17.728]                       muffled <- FALSE
[17:45:17.728]                       if (inherits(cond, "message")) {
[17:45:17.728]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.728]                         if (muffled) 
[17:45:17.728]                           invokeRestart("muffleMessage")
[17:45:17.728]                       }
[17:45:17.728]                       else if (inherits(cond, "warning")) {
[17:45:17.728]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.728]                         if (muffled) 
[17:45:17.728]                           invokeRestart("muffleWarning")
[17:45:17.728]                       }
[17:45:17.728]                       else if (inherits(cond, "condition")) {
[17:45:17.728]                         if (!is.null(pattern)) {
[17:45:17.728]                           computeRestarts <- base::computeRestarts
[17:45:17.728]                           grepl <- base::grepl
[17:45:17.728]                           restarts <- computeRestarts(cond)
[17:45:17.728]                           for (restart in restarts) {
[17:45:17.728]                             name <- restart$name
[17:45:17.728]                             if (is.null(name)) 
[17:45:17.728]                               next
[17:45:17.728]                             if (!grepl(pattern, name)) 
[17:45:17.728]                               next
[17:45:17.728]                             invokeRestart(restart)
[17:45:17.728]                             muffled <- TRUE
[17:45:17.728]                             break
[17:45:17.728]                           }
[17:45:17.728]                         }
[17:45:17.728]                       }
[17:45:17.728]                       invisible(muffled)
[17:45:17.728]                     }
[17:45:17.728]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.728]                   }
[17:45:17.728]                 }
[17:45:17.728]             }
[17:45:17.728]         }))
[17:45:17.728]     }, error = function(ex) {
[17:45:17.728]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.728]                 ...future.rng), started = ...future.startTime, 
[17:45:17.728]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.728]             version = "1.8"), class = "FutureResult")
[17:45:17.728]     }, finally = {
[17:45:17.728]         if (!identical(...future.workdir, getwd())) 
[17:45:17.728]             setwd(...future.workdir)
[17:45:17.728]         {
[17:45:17.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.728]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.728]             }
[17:45:17.728]             base::options(...future.oldOptions)
[17:45:17.728]             if (.Platform$OS.type == "windows") {
[17:45:17.728]                 old_names <- names(...future.oldEnvVars)
[17:45:17.728]                 envs <- base::Sys.getenv()
[17:45:17.728]                 names <- names(envs)
[17:45:17.728]                 common <- intersect(names, old_names)
[17:45:17.728]                 added <- setdiff(names, old_names)
[17:45:17.728]                 removed <- setdiff(old_names, names)
[17:45:17.728]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.728]                   envs[common]]
[17:45:17.728]                 NAMES <- toupper(changed)
[17:45:17.728]                 args <- list()
[17:45:17.728]                 for (kk in seq_along(NAMES)) {
[17:45:17.728]                   name <- changed[[kk]]
[17:45:17.728]                   NAME <- NAMES[[kk]]
[17:45:17.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.728]                     next
[17:45:17.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.728]                 }
[17:45:17.728]                 NAMES <- toupper(added)
[17:45:17.728]                 for (kk in seq_along(NAMES)) {
[17:45:17.728]                   name <- added[[kk]]
[17:45:17.728]                   NAME <- NAMES[[kk]]
[17:45:17.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.728]                     next
[17:45:17.728]                   args[[name]] <- ""
[17:45:17.728]                 }
[17:45:17.728]                 NAMES <- toupper(removed)
[17:45:17.728]                 for (kk in seq_along(NAMES)) {
[17:45:17.728]                   name <- removed[[kk]]
[17:45:17.728]                   NAME <- NAMES[[kk]]
[17:45:17.728]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.728]                     next
[17:45:17.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.728]                 }
[17:45:17.728]                 if (length(args) > 0) 
[17:45:17.728]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.728]             }
[17:45:17.728]             else {
[17:45:17.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.728]             }
[17:45:17.728]             {
[17:45:17.728]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.728]                   0L) {
[17:45:17.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.728]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.728]                   base::options(opts)
[17:45:17.728]                 }
[17:45:17.728]                 {
[17:45:17.728]                   {
[17:45:17.728]                     NULL
[17:45:17.728]                     RNGkind("Mersenne-Twister")
[17:45:17.728]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.728]                       inherits = FALSE)
[17:45:17.728]                   }
[17:45:17.728]                   options(future.plan = NULL)
[17:45:17.728]                   if (is.na(NA_character_)) 
[17:45:17.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.728]                     .init = FALSE)
[17:45:17.728]                 }
[17:45:17.728]             }
[17:45:17.728]         }
[17:45:17.728]     })
[17:45:17.728]     if (TRUE) {
[17:45:17.728]         base::sink(type = "output", split = FALSE)
[17:45:17.728]         if (TRUE) {
[17:45:17.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.728]         }
[17:45:17.728]         else {
[17:45:17.728]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.728]         }
[17:45:17.728]         base::close(...future.stdout)
[17:45:17.728]         ...future.stdout <- NULL
[17:45:17.728]     }
[17:45:17.728]     ...future.result$conditions <- ...future.conditions
[17:45:17.728]     ...future.result$finished <- base::Sys.time()
[17:45:17.728]     ...future.result
[17:45:17.728] }
[17:45:17.730] assign_globals() ...
[17:45:17.730] List of 11
[17:45:17.730]  $ ...future.FUN            :function (x, ...)  
[17:45:17.730]  $ x_FUN                    :function (x)  
[17:45:17.730]  $ times                    : int 4
[17:45:17.730]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.730]  $ stop_if_not              :function (...)  
[17:45:17.730]  $ dim                      : int [1:2] 2 2
[17:45:17.730]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.730]  $ future.call.arguments    : list()
[17:45:17.730]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.730]  $ ...future.elements_ii    :List of 10
[17:45:17.730]   ..$ : int 1
[17:45:17.730]   ..$ : int 2
[17:45:17.730]   ..$ : int 3
[17:45:17.730]   ..$ : int 4
[17:45:17.730]   ..$ : int 5
[17:45:17.730]   ..$ : int 6
[17:45:17.730]   ..$ : int 7
[17:45:17.730]   ..$ : int 8
[17:45:17.730]   ..$ : int 9
[17:45:17.730]   ..$ : int 10
[17:45:17.730]  $ ...future.seeds_ii       : NULL
[17:45:17.730]  $ ...future.globals.maxSize: NULL
[17:45:17.730]  - attr(*, "where")=List of 11
[17:45:17.730]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.730]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.730]  - attr(*, "resolved")= logi FALSE
[17:45:17.730]  - attr(*, "total_size")= num 97304
[17:45:17.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.730]  - attr(*, "already-done")= logi TRUE
[17:45:17.740] - copied ‘...future.FUN’ to environment
[17:45:17.740] - reassign environment for ‘x_FUN’
[17:45:17.740] - copied ‘x_FUN’ to environment
[17:45:17.740] - copied ‘times’ to environment
[17:45:17.740] - copied ‘stopf’ to environment
[17:45:17.740] - copied ‘stop_if_not’ to environment
[17:45:17.740] - copied ‘dim’ to environment
[17:45:17.740] - copied ‘valid_types’ to environment
[17:45:17.740] - copied ‘future.call.arguments’ to environment
[17:45:17.741] - copied ‘...future.elements_ii’ to environment
[17:45:17.741] - copied ‘...future.seeds_ii’ to environment
[17:45:17.741] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.741] assign_globals() ... done
[17:45:17.741] plan(): Setting new future strategy stack:
[17:45:17.741] List of future strategies:
[17:45:17.741] 1. sequential:
[17:45:17.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.741]    - tweaked: FALSE
[17:45:17.741]    - call: NULL
[17:45:17.742] plan(): nbrOfWorkers() = 1
[17:45:17.743] plan(): Setting new future strategy stack:
[17:45:17.743] List of future strategies:
[17:45:17.743] 1. sequential:
[17:45:17.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.743]    - tweaked: FALSE
[17:45:17.743]    - call: plan(strategy)
[17:45:17.743] plan(): nbrOfWorkers() = 1
[17:45:17.743] SequentialFuture started (and completed)
[17:45:17.743] - Launch lazy future ... done
[17:45:17.744] run() for ‘SequentialFuture’ ... done
[17:45:17.744] Created future:
[17:45:17.744] SequentialFuture:
[17:45:17.744] Label: ‘future_vapply-1’
[17:45:17.744] Expression:
[17:45:17.744] {
[17:45:17.744]     do.call(function(...) {
[17:45:17.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.744]             on.exit(options(oopts), add = TRUE)
[17:45:17.744]         }
[17:45:17.744]         {
[17:45:17.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.744]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.744]             })
[17:45:17.744]         }
[17:45:17.744]     }, args = future.call.arguments)
[17:45:17.744] }
[17:45:17.744] Lazy evaluation: FALSE
[17:45:17.744] Asynchronous evaluation: FALSE
[17:45:17.744] Local evaluation: TRUE
[17:45:17.744] Environment: R_GlobalEnv
[17:45:17.744] Capture standard output: TRUE
[17:45:17.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.744] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.744] Packages: 1 packages (‘future.apply’)
[17:45:17.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.744] Resolved: TRUE
[17:45:17.744] Value: 2.27 KiB of class ‘list’
[17:45:17.744] Early signaling: FALSE
[17:45:17.744] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.744] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.747] Chunk #1 of 1 ... DONE
[17:45:17.747] Launching 1 futures (chunks) ... DONE
[17:45:17.747] Resolving 1 futures (chunks) ...
[17:45:17.747] resolve() on list ...
[17:45:17.747]  recursive: 0
[17:45:17.747]  length: 1
[17:45:17.747] 
[17:45:17.747] resolved() for ‘SequentialFuture’ ...
[17:45:17.747] - state: ‘finished’
[17:45:17.748] - run: TRUE
[17:45:17.748] - result: ‘FutureResult’
[17:45:17.748] resolved() for ‘SequentialFuture’ ... done
[17:45:17.748] Future #1
[17:45:17.748] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.748] - nx: 1
[17:45:17.748] - relay: TRUE
[17:45:17.748] - stdout: TRUE
[17:45:17.748] - signal: TRUE
[17:45:17.748] - resignal: FALSE
[17:45:17.748] - force: TRUE
[17:45:17.749] - relayed: [n=1] FALSE
[17:45:17.749] - queued futures: [n=1] FALSE
[17:45:17.749]  - until=1
[17:45:17.749]  - relaying element #1
[17:45:17.749] - relayed: [n=1] TRUE
[17:45:17.749] - queued futures: [n=1] TRUE
[17:45:17.749] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.749]  length: 0 (resolved future 1)
[17:45:17.749] Relaying remaining futures
[17:45:17.749] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.749] - nx: 1
[17:45:17.750] - relay: TRUE
[17:45:17.750] - stdout: TRUE
[17:45:17.750] - signal: TRUE
[17:45:17.750] - resignal: FALSE
[17:45:17.750] - force: TRUE
[17:45:17.750] - relayed: [n=1] TRUE
[17:45:17.750] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.750] - relayed: [n=1] TRUE
[17:45:17.750] - queued futures: [n=1] TRUE
[17:45:17.750] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.750] resolve() on list ... DONE
[17:45:17.751]  - Number of value chunks collected: 1
[17:45:17.751] Resolving 1 futures (chunks) ... DONE
[17:45:17.751] Reducing values from 1 chunks ...
[17:45:17.751]  - Number of values collected after concatenation: 10
[17:45:17.751]  - Number of values expected: 10
[17:45:17.751] Reducing values from 1 chunks ... DONE
[17:45:17.751] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:45:17.753] future_lapply() ...
[17:45:17.755] Number of chunks: 1
[17:45:17.755] getGlobalsAndPackagesXApply() ...
[17:45:17.755]  - future.globals: TRUE
[17:45:17.755] getGlobalsAndPackages() ...
[17:45:17.755] Searching for globals...
[17:45:17.759] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:45:17.759] Searching for globals ... DONE
[17:45:17.759] Resolving globals: FALSE
[17:45:17.760] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:45:17.760] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.760] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.760] - packages: [1] ‘future.apply’
[17:45:17.761] getGlobalsAndPackages() ... DONE
[17:45:17.761]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.761]  - needed namespaces: [n=1] ‘future.apply’
[17:45:17.761] Finding globals ... DONE
[17:45:17.761]  - use_args: TRUE
[17:45:17.761]  - Getting '...' globals ...
[17:45:17.761] resolve() on list ...
[17:45:17.761]  recursive: 0
[17:45:17.762]  length: 1
[17:45:17.762]  elements: ‘...’
[17:45:17.762]  length: 0 (resolved future 1)
[17:45:17.762] resolve() on list ... DONE
[17:45:17.762]    - '...' content: [n=0] 
[17:45:17.762] List of 1
[17:45:17.762]  $ ...: list()
[17:45:17.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.762]  - attr(*, "where")=List of 1
[17:45:17.762]   ..$ ...:<environment: 0x5561f3b61530> 
[17:45:17.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.762]  - attr(*, "resolved")= logi TRUE
[17:45:17.762]  - attr(*, "total_size")= num NA
[17:45:17.764]  - Getting '...' globals ... DONE
[17:45:17.765] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.765] List of 8
[17:45:17.765]  $ ...future.FUN:function (x, ...)  
[17:45:17.765]  $ x_FUN        :function (x)  
[17:45:17.765]  $ times        : int 4
[17:45:17.765]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.765]  $ stop_if_not  :function (...)  
[17:45:17.765]  $ dim          : int [1:2] 2 2
[17:45:17.765]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.765]  $ ...          : list()
[17:45:17.765]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.765]  - attr(*, "where")=List of 8
[17:45:17.765]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.765]   ..$ ...          :<environment: 0x5561f3b61530> 
[17:45:17.765]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.765]  - attr(*, "resolved")= logi FALSE
[17:45:17.765]  - attr(*, "total_size")= num 105552
[17:45:17.797] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:17.797] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.797] Number of futures (= number of chunks): 1
[17:45:17.797] Launching 1 futures (chunks) ...
[17:45:17.797] Chunk #1 of 1 ...
[17:45:17.797]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.797] getGlobalsAndPackages() ...
[17:45:17.798] Searching for globals...
[17:45:17.798] 
[17:45:17.798] Searching for globals ... DONE
[17:45:17.798] - globals: [0] <none>
[17:45:17.798] getGlobalsAndPackages() ... DONE
[17:45:17.798]    + additional globals found: [n=0] 
[17:45:17.798]    + additional namespaces needed: [n=0] 
[17:45:17.798]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.798]  - seeds: <none>
[17:45:17.798]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.799] getGlobalsAndPackages() ...
[17:45:17.799] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.799] Resolving globals: FALSE
[17:45:17.799] Tweak future expression to call with '...' arguments ...
[17:45:17.799] {
[17:45:17.799]     do.call(function(...) {
[17:45:17.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.799]             on.exit(options(oopts), add = TRUE)
[17:45:17.799]         }
[17:45:17.799]         {
[17:45:17.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.799]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.799]             })
[17:45:17.799]         }
[17:45:17.799]     }, args = future.call.arguments)
[17:45:17.799] }
[17:45:17.799] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.800] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.800] - packages: [1] ‘future.apply’
[17:45:17.800] getGlobalsAndPackages() ... DONE
[17:45:17.800] run() for ‘Future’ ...
[17:45:17.800] - state: ‘created’
[17:45:17.800] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.801] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.801] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.801]   - Field: ‘label’
[17:45:17.801]   - Field: ‘local’
[17:45:17.801]   - Field: ‘owner’
[17:45:17.801]   - Field: ‘envir’
[17:45:17.801]   - Field: ‘packages’
[17:45:17.801]   - Field: ‘gc’
[17:45:17.801]   - Field: ‘conditions’
[17:45:17.802]   - Field: ‘expr’
[17:45:17.802]   - Field: ‘uuid’
[17:45:17.802]   - Field: ‘seed’
[17:45:17.802]   - Field: ‘version’
[17:45:17.802]   - Field: ‘result’
[17:45:17.802]   - Field: ‘asynchronous’
[17:45:17.802]   - Field: ‘calls’
[17:45:17.802]   - Field: ‘globals’
[17:45:17.802]   - Field: ‘stdout’
[17:45:17.802]   - Field: ‘earlySignal’
[17:45:17.802]   - Field: ‘lazy’
[17:45:17.803]   - Field: ‘state’
[17:45:17.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.803] - Launch lazy future ...
[17:45:17.803] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:17.803] Packages needed by future strategies (n = 0): <none>
[17:45:17.804] {
[17:45:17.804]     {
[17:45:17.804]         {
[17:45:17.804]             ...future.startTime <- base::Sys.time()
[17:45:17.804]             {
[17:45:17.804]                 {
[17:45:17.804]                   {
[17:45:17.804]                     {
[17:45:17.804]                       base::local({
[17:45:17.804]                         has_future <- base::requireNamespace("future", 
[17:45:17.804]                           quietly = TRUE)
[17:45:17.804]                         if (has_future) {
[17:45:17.804]                           ns <- base::getNamespace("future")
[17:45:17.804]                           version <- ns[[".package"]][["version"]]
[17:45:17.804]                           if (is.null(version)) 
[17:45:17.804]                             version <- utils::packageVersion("future")
[17:45:17.804]                         }
[17:45:17.804]                         else {
[17:45:17.804]                           version <- NULL
[17:45:17.804]                         }
[17:45:17.804]                         if (!has_future || version < "1.8.0") {
[17:45:17.804]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.804]                             "", base::R.version$version.string), 
[17:45:17.804]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.804]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.804]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.804]                               "release", "version")], collapse = " "), 
[17:45:17.804]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.804]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.804]                             info)
[17:45:17.804]                           info <- base::paste(info, collapse = "; ")
[17:45:17.804]                           if (!has_future) {
[17:45:17.804]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.804]                               info)
[17:45:17.804]                           }
[17:45:17.804]                           else {
[17:45:17.804]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.804]                               info, version)
[17:45:17.804]                           }
[17:45:17.804]                           base::stop(msg)
[17:45:17.804]                         }
[17:45:17.804]                       })
[17:45:17.804]                     }
[17:45:17.804]                     base::local({
[17:45:17.804]                       for (pkg in "future.apply") {
[17:45:17.804]                         base::loadNamespace(pkg)
[17:45:17.804]                         base::library(pkg, character.only = TRUE)
[17:45:17.804]                       }
[17:45:17.804]                     })
[17:45:17.804]                   }
[17:45:17.804]                   ...future.strategy.old <- future::plan("list")
[17:45:17.804]                   options(future.plan = NULL)
[17:45:17.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.804]                 }
[17:45:17.804]                 ...future.workdir <- getwd()
[17:45:17.804]             }
[17:45:17.804]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.804]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.804]         }
[17:45:17.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.804]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.804]             base::names(...future.oldOptions))
[17:45:17.804]     }
[17:45:17.804]     if (FALSE) {
[17:45:17.804]     }
[17:45:17.804]     else {
[17:45:17.804]         if (TRUE) {
[17:45:17.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.804]                 open = "w")
[17:45:17.804]         }
[17:45:17.804]         else {
[17:45:17.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.804]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.804]         }
[17:45:17.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.804]             base::sink(type = "output", split = FALSE)
[17:45:17.804]             base::close(...future.stdout)
[17:45:17.804]         }, add = TRUE)
[17:45:17.804]     }
[17:45:17.804]     ...future.frame <- base::sys.nframe()
[17:45:17.804]     ...future.conditions <- base::list()
[17:45:17.804]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.804]     if (FALSE) {
[17:45:17.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.804]     }
[17:45:17.804]     ...future.result <- base::tryCatch({
[17:45:17.804]         base::withCallingHandlers({
[17:45:17.804]             ...future.value <- base::withVisible(base::local({
[17:45:17.804]                 do.call(function(...) {
[17:45:17.804]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.804]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.804]                     ...future.globals.maxSize)) {
[17:45:17.804]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.804]                     on.exit(options(oopts), add = TRUE)
[17:45:17.804]                   }
[17:45:17.804]                   {
[17:45:17.804]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.804]                       FUN = function(jj) {
[17:45:17.804]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.804]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.804]                       })
[17:45:17.804]                   }
[17:45:17.804]                 }, args = future.call.arguments)
[17:45:17.804]             }))
[17:45:17.804]             future::FutureResult(value = ...future.value$value, 
[17:45:17.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.804]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.804]                     ...future.globalenv.names))
[17:45:17.804]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.804]         }, condition = base::local({
[17:45:17.804]             c <- base::c
[17:45:17.804]             inherits <- base::inherits
[17:45:17.804]             invokeRestart <- base::invokeRestart
[17:45:17.804]             length <- base::length
[17:45:17.804]             list <- base::list
[17:45:17.804]             seq.int <- base::seq.int
[17:45:17.804]             signalCondition <- base::signalCondition
[17:45:17.804]             sys.calls <- base::sys.calls
[17:45:17.804]             `[[` <- base::`[[`
[17:45:17.804]             `+` <- base::`+`
[17:45:17.804]             `<<-` <- base::`<<-`
[17:45:17.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.804]                   3L)]
[17:45:17.804]             }
[17:45:17.804]             function(cond) {
[17:45:17.804]                 is_error <- inherits(cond, "error")
[17:45:17.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.804]                   NULL)
[17:45:17.804]                 if (is_error) {
[17:45:17.804]                   sessionInformation <- function() {
[17:45:17.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.804]                       search = base::search(), system = base::Sys.info())
[17:45:17.804]                   }
[17:45:17.804]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.804]                     cond$call), session = sessionInformation(), 
[17:45:17.804]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.804]                   signalCondition(cond)
[17:45:17.804]                 }
[17:45:17.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.804]                 "immediateCondition"))) {
[17:45:17.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.804]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.804]                   if (TRUE && !signal) {
[17:45:17.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.804]                     {
[17:45:17.804]                       inherits <- base::inherits
[17:45:17.804]                       invokeRestart <- base::invokeRestart
[17:45:17.804]                       is.null <- base::is.null
[17:45:17.804]                       muffled <- FALSE
[17:45:17.804]                       if (inherits(cond, "message")) {
[17:45:17.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.804]                         if (muffled) 
[17:45:17.804]                           invokeRestart("muffleMessage")
[17:45:17.804]                       }
[17:45:17.804]                       else if (inherits(cond, "warning")) {
[17:45:17.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.804]                         if (muffled) 
[17:45:17.804]                           invokeRestart("muffleWarning")
[17:45:17.804]                       }
[17:45:17.804]                       else if (inherits(cond, "condition")) {
[17:45:17.804]                         if (!is.null(pattern)) {
[17:45:17.804]                           computeRestarts <- base::computeRestarts
[17:45:17.804]                           grepl <- base::grepl
[17:45:17.804]                           restarts <- computeRestarts(cond)
[17:45:17.804]                           for (restart in restarts) {
[17:45:17.804]                             name <- restart$name
[17:45:17.804]                             if (is.null(name)) 
[17:45:17.804]                               next
[17:45:17.804]                             if (!grepl(pattern, name)) 
[17:45:17.804]                               next
[17:45:17.804]                             invokeRestart(restart)
[17:45:17.804]                             muffled <- TRUE
[17:45:17.804]                             break
[17:45:17.804]                           }
[17:45:17.804]                         }
[17:45:17.804]                       }
[17:45:17.804]                       invisible(muffled)
[17:45:17.804]                     }
[17:45:17.804]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.804]                   }
[17:45:17.804]                 }
[17:45:17.804]                 else {
[17:45:17.804]                   if (TRUE) {
[17:45:17.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.804]                     {
[17:45:17.804]                       inherits <- base::inherits
[17:45:17.804]                       invokeRestart <- base::invokeRestart
[17:45:17.804]                       is.null <- base::is.null
[17:45:17.804]                       muffled <- FALSE
[17:45:17.804]                       if (inherits(cond, "message")) {
[17:45:17.804]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.804]                         if (muffled) 
[17:45:17.804]                           invokeRestart("muffleMessage")
[17:45:17.804]                       }
[17:45:17.804]                       else if (inherits(cond, "warning")) {
[17:45:17.804]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.804]                         if (muffled) 
[17:45:17.804]                           invokeRestart("muffleWarning")
[17:45:17.804]                       }
[17:45:17.804]                       else if (inherits(cond, "condition")) {
[17:45:17.804]                         if (!is.null(pattern)) {
[17:45:17.804]                           computeRestarts <- base::computeRestarts
[17:45:17.804]                           grepl <- base::grepl
[17:45:17.804]                           restarts <- computeRestarts(cond)
[17:45:17.804]                           for (restart in restarts) {
[17:45:17.804]                             name <- restart$name
[17:45:17.804]                             if (is.null(name)) 
[17:45:17.804]                               next
[17:45:17.804]                             if (!grepl(pattern, name)) 
[17:45:17.804]                               next
[17:45:17.804]                             invokeRestart(restart)
[17:45:17.804]                             muffled <- TRUE
[17:45:17.804]                             break
[17:45:17.804]                           }
[17:45:17.804]                         }
[17:45:17.804]                       }
[17:45:17.804]                       invisible(muffled)
[17:45:17.804]                     }
[17:45:17.804]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.804]                   }
[17:45:17.804]                 }
[17:45:17.804]             }
[17:45:17.804]         }))
[17:45:17.804]     }, error = function(ex) {
[17:45:17.804]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.804]                 ...future.rng), started = ...future.startTime, 
[17:45:17.804]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.804]             version = "1.8"), class = "FutureResult")
[17:45:17.804]     }, finally = {
[17:45:17.804]         if (!identical(...future.workdir, getwd())) 
[17:45:17.804]             setwd(...future.workdir)
[17:45:17.804]         {
[17:45:17.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.804]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.804]             }
[17:45:17.804]             base::options(...future.oldOptions)
[17:45:17.804]             if (.Platform$OS.type == "windows") {
[17:45:17.804]                 old_names <- names(...future.oldEnvVars)
[17:45:17.804]                 envs <- base::Sys.getenv()
[17:45:17.804]                 names <- names(envs)
[17:45:17.804]                 common <- intersect(names, old_names)
[17:45:17.804]                 added <- setdiff(names, old_names)
[17:45:17.804]                 removed <- setdiff(old_names, names)
[17:45:17.804]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.804]                   envs[common]]
[17:45:17.804]                 NAMES <- toupper(changed)
[17:45:17.804]                 args <- list()
[17:45:17.804]                 for (kk in seq_along(NAMES)) {
[17:45:17.804]                   name <- changed[[kk]]
[17:45:17.804]                   NAME <- NAMES[[kk]]
[17:45:17.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.804]                     next
[17:45:17.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.804]                 }
[17:45:17.804]                 NAMES <- toupper(added)
[17:45:17.804]                 for (kk in seq_along(NAMES)) {
[17:45:17.804]                   name <- added[[kk]]
[17:45:17.804]                   NAME <- NAMES[[kk]]
[17:45:17.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.804]                     next
[17:45:17.804]                   args[[name]] <- ""
[17:45:17.804]                 }
[17:45:17.804]                 NAMES <- toupper(removed)
[17:45:17.804]                 for (kk in seq_along(NAMES)) {
[17:45:17.804]                   name <- removed[[kk]]
[17:45:17.804]                   NAME <- NAMES[[kk]]
[17:45:17.804]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.804]                     next
[17:45:17.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.804]                 }
[17:45:17.804]                 if (length(args) > 0) 
[17:45:17.804]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.804]             }
[17:45:17.804]             else {
[17:45:17.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.804]             }
[17:45:17.804]             {
[17:45:17.804]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.804]                   0L) {
[17:45:17.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.804]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.804]                   base::options(opts)
[17:45:17.804]                 }
[17:45:17.804]                 {
[17:45:17.804]                   {
[17:45:17.804]                     NULL
[17:45:17.804]                     RNGkind("Mersenne-Twister")
[17:45:17.804]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.804]                       inherits = FALSE)
[17:45:17.804]                   }
[17:45:17.804]                   options(future.plan = NULL)
[17:45:17.804]                   if (is.na(NA_character_)) 
[17:45:17.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.804]                     .init = FALSE)
[17:45:17.804]                 }
[17:45:17.804]             }
[17:45:17.804]         }
[17:45:17.804]     })
[17:45:17.804]     if (TRUE) {
[17:45:17.804]         base::sink(type = "output", split = FALSE)
[17:45:17.804]         if (TRUE) {
[17:45:17.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.804]         }
[17:45:17.804]         else {
[17:45:17.804]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.804]         }
[17:45:17.804]         base::close(...future.stdout)
[17:45:17.804]         ...future.stdout <- NULL
[17:45:17.804]     }
[17:45:17.804]     ...future.result$conditions <- ...future.conditions
[17:45:17.804]     ...future.result$finished <- base::Sys.time()
[17:45:17.804]     ...future.result
[17:45:17.804] }
[17:45:17.805] assign_globals() ...
[17:45:17.805] List of 11
[17:45:17.805]  $ ...future.FUN            :function (x, ...)  
[17:45:17.805]  $ x_FUN                    :function (x)  
[17:45:17.805]  $ times                    : int 4
[17:45:17.805]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.805]  $ stop_if_not              :function (...)  
[17:45:17.805]  $ dim                      : int [1:2] 2 2
[17:45:17.805]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.805]  $ future.call.arguments    : list()
[17:45:17.805]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.805]  $ ...future.elements_ii    :List of 10
[17:45:17.805]   ..$ : int 1
[17:45:17.805]   ..$ : int 2
[17:45:17.805]   ..$ : int 3
[17:45:17.805]   ..$ : int 4
[17:45:17.805]   ..$ : int 5
[17:45:17.805]   ..$ : int 6
[17:45:17.805]   ..$ : int 7
[17:45:17.805]   ..$ : int 8
[17:45:17.805]   ..$ : int 9
[17:45:17.805]   ..$ : int 10
[17:45:17.805]  $ ...future.seeds_ii       : NULL
[17:45:17.805]  $ ...future.globals.maxSize: NULL
[17:45:17.805]  - attr(*, "where")=List of 11
[17:45:17.805]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.805]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.805]  - attr(*, "resolved")= logi FALSE
[17:45:17.805]  - attr(*, "total_size")= num 105552
[17:45:17.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.805]  - attr(*, "already-done")= logi TRUE
[17:45:17.815] - copied ‘...future.FUN’ to environment
[17:45:17.815] - reassign environment for ‘x_FUN’
[17:45:17.815] - copied ‘x_FUN’ to environment
[17:45:17.815] - copied ‘times’ to environment
[17:45:17.816] - copied ‘stopf’ to environment
[17:45:17.816] - copied ‘stop_if_not’ to environment
[17:45:17.816] - copied ‘dim’ to environment
[17:45:17.816] - copied ‘valid_types’ to environment
[17:45:17.816] - copied ‘future.call.arguments’ to environment
[17:45:17.816] - copied ‘...future.elements_ii’ to environment
[17:45:17.816] - copied ‘...future.seeds_ii’ to environment
[17:45:17.816] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.816] assign_globals() ... done
[17:45:17.817] plan(): Setting new future strategy stack:
[17:45:17.817] List of future strategies:
[17:45:17.817] 1. sequential:
[17:45:17.817]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.817]    - tweaked: FALSE
[17:45:17.817]    - call: NULL
[17:45:17.817] plan(): nbrOfWorkers() = 1
[17:45:17.819] plan(): Setting new future strategy stack:
[17:45:17.820] List of future strategies:
[17:45:17.820] 1. sequential:
[17:45:17.820]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.820]    - tweaked: FALSE
[17:45:17.820]    - call: plan(strategy)
[17:45:17.820] plan(): nbrOfWorkers() = 1
[17:45:17.820] SequentialFuture started (and completed)
[17:45:17.820] - Launch lazy future ... done
[17:45:17.820] run() for ‘SequentialFuture’ ... done
[17:45:17.821] Created future:
[17:45:17.821] SequentialFuture:
[17:45:17.821] Label: ‘future_vapply-1’
[17:45:17.821] Expression:
[17:45:17.821] {
[17:45:17.821]     do.call(function(...) {
[17:45:17.821]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.821]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.821]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.821]             on.exit(options(oopts), add = TRUE)
[17:45:17.821]         }
[17:45:17.821]         {
[17:45:17.821]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.821]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.821]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.821]             })
[17:45:17.821]         }
[17:45:17.821]     }, args = future.call.arguments)
[17:45:17.821] }
[17:45:17.821] Lazy evaluation: FALSE
[17:45:17.821] Asynchronous evaluation: FALSE
[17:45:17.821] Local evaluation: TRUE
[17:45:17.821] Environment: R_GlobalEnv
[17:45:17.821] Capture standard output: TRUE
[17:45:17.821] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.821] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.821] Packages: 1 packages (‘future.apply’)
[17:45:17.821] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.821] Resolved: TRUE
[17:45:17.821] Value: 7.42 KiB of class ‘list’
[17:45:17.821] Early signaling: FALSE
[17:45:17.821] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.821] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.822] Chunk #1 of 1 ... DONE
[17:45:17.822] Launching 1 futures (chunks) ... DONE
[17:45:17.822] Resolving 1 futures (chunks) ...
[17:45:17.822] resolve() on list ...
[17:45:17.822]  recursive: 0
[17:45:17.822]  length: 1
[17:45:17.822] 
[17:45:17.823] resolved() for ‘SequentialFuture’ ...
[17:45:17.823] - state: ‘finished’
[17:45:17.823] - run: TRUE
[17:45:17.823] - result: ‘FutureResult’
[17:45:17.823] resolved() for ‘SequentialFuture’ ... done
[17:45:17.823] Future #1
[17:45:17.823] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.823] - nx: 1
[17:45:17.823] - relay: TRUE
[17:45:17.823] - stdout: TRUE
[17:45:17.824] - signal: TRUE
[17:45:17.824] - resignal: FALSE
[17:45:17.824] - force: TRUE
[17:45:17.824] - relayed: [n=1] FALSE
[17:45:17.824] - queued futures: [n=1] FALSE
[17:45:17.824]  - until=1
[17:45:17.824]  - relaying element #1
[17:45:17.824] - relayed: [n=1] TRUE
[17:45:17.824] - queued futures: [n=1] TRUE
[17:45:17.824] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.824]  length: 0 (resolved future 1)
[17:45:17.825] Relaying remaining futures
[17:45:17.825] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.825] - nx: 1
[17:45:17.825] - relay: TRUE
[17:45:17.825] - stdout: TRUE
[17:45:17.825] - signal: TRUE
[17:45:17.825] - resignal: FALSE
[17:45:17.825] - force: TRUE
[17:45:17.825] - relayed: [n=1] TRUE
[17:45:17.825] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.825] - relayed: [n=1] TRUE
[17:45:17.826] - queued futures: [n=1] TRUE
[17:45:17.826] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.826] resolve() on list ... DONE
[17:45:17.826]  - Number of value chunks collected: 1
[17:45:17.826] Resolving 1 futures (chunks) ... DONE
[17:45:17.826] Reducing values from 1 chunks ...
[17:45:17.826]  - Number of values collected after concatenation: 10
[17:45:17.826]  - Number of values expected: 10
[17:45:17.826] Reducing values from 1 chunks ... DONE
[17:45:17.826] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:45:17.830] future_lapply() ...
[17:45:17.832] Number of chunks: 1
[17:45:17.832] getGlobalsAndPackagesXApply() ...
[17:45:17.832]  - future.globals: TRUE
[17:45:17.832] getGlobalsAndPackages() ...
[17:45:17.832] Searching for globals...
[17:45:17.835] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:45:17.836] Searching for globals ... DONE
[17:45:17.836] Resolving globals: FALSE
[17:45:17.836] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:45:17.837] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:17.837] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.837] - packages: [2] ‘stats’, ‘future.apply’
[17:45:17.837] getGlobalsAndPackages() ... DONE
[17:45:17.837]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.837]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:45:17.838] Finding globals ... DONE
[17:45:17.838]  - use_args: TRUE
[17:45:17.838]  - Getting '...' globals ...
[17:45:17.838] resolve() on list ...
[17:45:17.838]  recursive: 0
[17:45:17.838]  length: 1
[17:45:17.838]  elements: ‘...’
[17:45:17.838]  length: 0 (resolved future 1)
[17:45:17.838] resolve() on list ... DONE
[17:45:17.839]    - '...' content: [n=0] 
[17:45:17.839] List of 1
[17:45:17.839]  $ ...: list()
[17:45:17.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.839]  - attr(*, "where")=List of 1
[17:45:17.839]   ..$ ...:<environment: 0x5561f4b92aa8> 
[17:45:17.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.839]  - attr(*, "resolved")= logi TRUE
[17:45:17.839]  - attr(*, "total_size")= num NA
[17:45:17.841]  - Getting '...' globals ... DONE
[17:45:17.841] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.841] List of 8
[17:45:17.841]  $ ...future.FUN:function (x, ...)  
[17:45:17.841]  $ x_FUN        :function (x, ...)  
[17:45:17.841]  $ times        : int 5
[17:45:17.841]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.841]  $ stop_if_not  :function (...)  
[17:45:17.841]  $ dim          : NULL
[17:45:17.841]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.841]  $ ...          : list()
[17:45:17.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.841]  - attr(*, "where")=List of 8
[17:45:17.841]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.841]   ..$ ...          :<environment: 0x5561f4b92aa8> 
[17:45:17.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.841]  - attr(*, "resolved")= logi FALSE
[17:45:17.841]  - attr(*, "total_size")= num 95528
[17:45:17.848] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:45:17.848] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.848] Number of futures (= number of chunks): 1
[17:45:17.849] Launching 1 futures (chunks) ...
[17:45:17.849] Chunk #1 of 1 ...
[17:45:17.849]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.849] getGlobalsAndPackages() ...
[17:45:17.849] Searching for globals...
[17:45:17.849] 
[17:45:17.849] Searching for globals ... DONE
[17:45:17.849] - globals: [0] <none>
[17:45:17.849] getGlobalsAndPackages() ... DONE
[17:45:17.850]    + additional globals found: [n=0] 
[17:45:17.850]    + additional namespaces needed: [n=0] 
[17:45:17.850]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.850]  - seeds: <none>
[17:45:17.850]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.850] getGlobalsAndPackages() ...
[17:45:17.850] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.850] Resolving globals: FALSE
[17:45:17.850] Tweak future expression to call with '...' arguments ...
[17:45:17.850] {
[17:45:17.850]     do.call(function(...) {
[17:45:17.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.850]             on.exit(options(oopts), add = TRUE)
[17:45:17.850]         }
[17:45:17.850]         {
[17:45:17.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.850]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.850]             })
[17:45:17.850]         }
[17:45:17.850]     }, args = future.call.arguments)
[17:45:17.850] }
[17:45:17.851] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.851] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.851] - packages: [2] ‘stats’, ‘future.apply’
[17:45:17.851] getGlobalsAndPackages() ... DONE
[17:45:17.852] run() for ‘Future’ ...
[17:45:17.852] - state: ‘created’
[17:45:17.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.852]   - Field: ‘label’
[17:45:17.852]   - Field: ‘local’
[17:45:17.853]   - Field: ‘owner’
[17:45:17.853]   - Field: ‘envir’
[17:45:17.853]   - Field: ‘packages’
[17:45:17.853]   - Field: ‘gc’
[17:45:17.853]   - Field: ‘conditions’
[17:45:17.853]   - Field: ‘expr’
[17:45:17.853]   - Field: ‘uuid’
[17:45:17.853]   - Field: ‘seed’
[17:45:17.853]   - Field: ‘version’
[17:45:17.853]   - Field: ‘result’
[17:45:17.853]   - Field: ‘asynchronous’
[17:45:17.854]   - Field: ‘calls’
[17:45:17.854]   - Field: ‘globals’
[17:45:17.854]   - Field: ‘stdout’
[17:45:17.854]   - Field: ‘earlySignal’
[17:45:17.854]   - Field: ‘lazy’
[17:45:17.854]   - Field: ‘state’
[17:45:17.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.854] - Launch lazy future ...
[17:45:17.854] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:17.854] Packages needed by future strategies (n = 0): <none>
[17:45:17.855] {
[17:45:17.855]     {
[17:45:17.855]         {
[17:45:17.855]             ...future.startTime <- base::Sys.time()
[17:45:17.855]             {
[17:45:17.855]                 {
[17:45:17.855]                   {
[17:45:17.855]                     {
[17:45:17.855]                       base::local({
[17:45:17.855]                         has_future <- base::requireNamespace("future", 
[17:45:17.855]                           quietly = TRUE)
[17:45:17.855]                         if (has_future) {
[17:45:17.855]                           ns <- base::getNamespace("future")
[17:45:17.855]                           version <- ns[[".package"]][["version"]]
[17:45:17.855]                           if (is.null(version)) 
[17:45:17.855]                             version <- utils::packageVersion("future")
[17:45:17.855]                         }
[17:45:17.855]                         else {
[17:45:17.855]                           version <- NULL
[17:45:17.855]                         }
[17:45:17.855]                         if (!has_future || version < "1.8.0") {
[17:45:17.855]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.855]                             "", base::R.version$version.string), 
[17:45:17.855]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.855]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.855]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.855]                               "release", "version")], collapse = " "), 
[17:45:17.855]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.855]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.855]                             info)
[17:45:17.855]                           info <- base::paste(info, collapse = "; ")
[17:45:17.855]                           if (!has_future) {
[17:45:17.855]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.855]                               info)
[17:45:17.855]                           }
[17:45:17.855]                           else {
[17:45:17.855]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.855]                               info, version)
[17:45:17.855]                           }
[17:45:17.855]                           base::stop(msg)
[17:45:17.855]                         }
[17:45:17.855]                       })
[17:45:17.855]                     }
[17:45:17.855]                     base::local({
[17:45:17.855]                       for (pkg in c("stats", "future.apply")) {
[17:45:17.855]                         base::loadNamespace(pkg)
[17:45:17.855]                         base::library(pkg, character.only = TRUE)
[17:45:17.855]                       }
[17:45:17.855]                     })
[17:45:17.855]                   }
[17:45:17.855]                   ...future.strategy.old <- future::plan("list")
[17:45:17.855]                   options(future.plan = NULL)
[17:45:17.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.855]                 }
[17:45:17.855]                 ...future.workdir <- getwd()
[17:45:17.855]             }
[17:45:17.855]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.855]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.855]         }
[17:45:17.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.855]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.855]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.855]             base::names(...future.oldOptions))
[17:45:17.855]     }
[17:45:17.855]     if (FALSE) {
[17:45:17.855]     }
[17:45:17.855]     else {
[17:45:17.855]         if (TRUE) {
[17:45:17.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.855]                 open = "w")
[17:45:17.855]         }
[17:45:17.855]         else {
[17:45:17.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.855]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.855]         }
[17:45:17.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.855]             base::sink(type = "output", split = FALSE)
[17:45:17.855]             base::close(...future.stdout)
[17:45:17.855]         }, add = TRUE)
[17:45:17.855]     }
[17:45:17.855]     ...future.frame <- base::sys.nframe()
[17:45:17.855]     ...future.conditions <- base::list()
[17:45:17.855]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.855]     if (FALSE) {
[17:45:17.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.855]     }
[17:45:17.855]     ...future.result <- base::tryCatch({
[17:45:17.855]         base::withCallingHandlers({
[17:45:17.855]             ...future.value <- base::withVisible(base::local({
[17:45:17.855]                 do.call(function(...) {
[17:45:17.855]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.855]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.855]                     ...future.globals.maxSize)) {
[17:45:17.855]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.855]                     on.exit(options(oopts), add = TRUE)
[17:45:17.855]                   }
[17:45:17.855]                   {
[17:45:17.855]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.855]                       FUN = function(jj) {
[17:45:17.855]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.855]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.855]                       })
[17:45:17.855]                   }
[17:45:17.855]                 }, args = future.call.arguments)
[17:45:17.855]             }))
[17:45:17.855]             future::FutureResult(value = ...future.value$value, 
[17:45:17.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.855]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.855]                     ...future.globalenv.names))
[17:45:17.855]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.855]         }, condition = base::local({
[17:45:17.855]             c <- base::c
[17:45:17.855]             inherits <- base::inherits
[17:45:17.855]             invokeRestart <- base::invokeRestart
[17:45:17.855]             length <- base::length
[17:45:17.855]             list <- base::list
[17:45:17.855]             seq.int <- base::seq.int
[17:45:17.855]             signalCondition <- base::signalCondition
[17:45:17.855]             sys.calls <- base::sys.calls
[17:45:17.855]             `[[` <- base::`[[`
[17:45:17.855]             `+` <- base::`+`
[17:45:17.855]             `<<-` <- base::`<<-`
[17:45:17.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.855]                   3L)]
[17:45:17.855]             }
[17:45:17.855]             function(cond) {
[17:45:17.855]                 is_error <- inherits(cond, "error")
[17:45:17.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.855]                   NULL)
[17:45:17.855]                 if (is_error) {
[17:45:17.855]                   sessionInformation <- function() {
[17:45:17.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.855]                       search = base::search(), system = base::Sys.info())
[17:45:17.855]                   }
[17:45:17.855]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.855]                     cond$call), session = sessionInformation(), 
[17:45:17.855]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.855]                   signalCondition(cond)
[17:45:17.855]                 }
[17:45:17.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.855]                 "immediateCondition"))) {
[17:45:17.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.855]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.855]                   if (TRUE && !signal) {
[17:45:17.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.855]                     {
[17:45:17.855]                       inherits <- base::inherits
[17:45:17.855]                       invokeRestart <- base::invokeRestart
[17:45:17.855]                       is.null <- base::is.null
[17:45:17.855]                       muffled <- FALSE
[17:45:17.855]                       if (inherits(cond, "message")) {
[17:45:17.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.855]                         if (muffled) 
[17:45:17.855]                           invokeRestart("muffleMessage")
[17:45:17.855]                       }
[17:45:17.855]                       else if (inherits(cond, "warning")) {
[17:45:17.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.855]                         if (muffled) 
[17:45:17.855]                           invokeRestart("muffleWarning")
[17:45:17.855]                       }
[17:45:17.855]                       else if (inherits(cond, "condition")) {
[17:45:17.855]                         if (!is.null(pattern)) {
[17:45:17.855]                           computeRestarts <- base::computeRestarts
[17:45:17.855]                           grepl <- base::grepl
[17:45:17.855]                           restarts <- computeRestarts(cond)
[17:45:17.855]                           for (restart in restarts) {
[17:45:17.855]                             name <- restart$name
[17:45:17.855]                             if (is.null(name)) 
[17:45:17.855]                               next
[17:45:17.855]                             if (!grepl(pattern, name)) 
[17:45:17.855]                               next
[17:45:17.855]                             invokeRestart(restart)
[17:45:17.855]                             muffled <- TRUE
[17:45:17.855]                             break
[17:45:17.855]                           }
[17:45:17.855]                         }
[17:45:17.855]                       }
[17:45:17.855]                       invisible(muffled)
[17:45:17.855]                     }
[17:45:17.855]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.855]                   }
[17:45:17.855]                 }
[17:45:17.855]                 else {
[17:45:17.855]                   if (TRUE) {
[17:45:17.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.855]                     {
[17:45:17.855]                       inherits <- base::inherits
[17:45:17.855]                       invokeRestart <- base::invokeRestart
[17:45:17.855]                       is.null <- base::is.null
[17:45:17.855]                       muffled <- FALSE
[17:45:17.855]                       if (inherits(cond, "message")) {
[17:45:17.855]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.855]                         if (muffled) 
[17:45:17.855]                           invokeRestart("muffleMessage")
[17:45:17.855]                       }
[17:45:17.855]                       else if (inherits(cond, "warning")) {
[17:45:17.855]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.855]                         if (muffled) 
[17:45:17.855]                           invokeRestart("muffleWarning")
[17:45:17.855]                       }
[17:45:17.855]                       else if (inherits(cond, "condition")) {
[17:45:17.855]                         if (!is.null(pattern)) {
[17:45:17.855]                           computeRestarts <- base::computeRestarts
[17:45:17.855]                           grepl <- base::grepl
[17:45:17.855]                           restarts <- computeRestarts(cond)
[17:45:17.855]                           for (restart in restarts) {
[17:45:17.855]                             name <- restart$name
[17:45:17.855]                             if (is.null(name)) 
[17:45:17.855]                               next
[17:45:17.855]                             if (!grepl(pattern, name)) 
[17:45:17.855]                               next
[17:45:17.855]                             invokeRestart(restart)
[17:45:17.855]                             muffled <- TRUE
[17:45:17.855]                             break
[17:45:17.855]                           }
[17:45:17.855]                         }
[17:45:17.855]                       }
[17:45:17.855]                       invisible(muffled)
[17:45:17.855]                     }
[17:45:17.855]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.855]                   }
[17:45:17.855]                 }
[17:45:17.855]             }
[17:45:17.855]         }))
[17:45:17.855]     }, error = function(ex) {
[17:45:17.855]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.855]                 ...future.rng), started = ...future.startTime, 
[17:45:17.855]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.855]             version = "1.8"), class = "FutureResult")
[17:45:17.855]     }, finally = {
[17:45:17.855]         if (!identical(...future.workdir, getwd())) 
[17:45:17.855]             setwd(...future.workdir)
[17:45:17.855]         {
[17:45:17.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.855]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.855]             }
[17:45:17.855]             base::options(...future.oldOptions)
[17:45:17.855]             if (.Platform$OS.type == "windows") {
[17:45:17.855]                 old_names <- names(...future.oldEnvVars)
[17:45:17.855]                 envs <- base::Sys.getenv()
[17:45:17.855]                 names <- names(envs)
[17:45:17.855]                 common <- intersect(names, old_names)
[17:45:17.855]                 added <- setdiff(names, old_names)
[17:45:17.855]                 removed <- setdiff(old_names, names)
[17:45:17.855]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.855]                   envs[common]]
[17:45:17.855]                 NAMES <- toupper(changed)
[17:45:17.855]                 args <- list()
[17:45:17.855]                 for (kk in seq_along(NAMES)) {
[17:45:17.855]                   name <- changed[[kk]]
[17:45:17.855]                   NAME <- NAMES[[kk]]
[17:45:17.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.855]                     next
[17:45:17.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.855]                 }
[17:45:17.855]                 NAMES <- toupper(added)
[17:45:17.855]                 for (kk in seq_along(NAMES)) {
[17:45:17.855]                   name <- added[[kk]]
[17:45:17.855]                   NAME <- NAMES[[kk]]
[17:45:17.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.855]                     next
[17:45:17.855]                   args[[name]] <- ""
[17:45:17.855]                 }
[17:45:17.855]                 NAMES <- toupper(removed)
[17:45:17.855]                 for (kk in seq_along(NAMES)) {
[17:45:17.855]                   name <- removed[[kk]]
[17:45:17.855]                   NAME <- NAMES[[kk]]
[17:45:17.855]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.855]                     next
[17:45:17.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.855]                 }
[17:45:17.855]                 if (length(args) > 0) 
[17:45:17.855]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.855]             }
[17:45:17.855]             else {
[17:45:17.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.855]             }
[17:45:17.855]             {
[17:45:17.855]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.855]                   0L) {
[17:45:17.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.855]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.855]                   base::options(opts)
[17:45:17.855]                 }
[17:45:17.855]                 {
[17:45:17.855]                   {
[17:45:17.855]                     NULL
[17:45:17.855]                     RNGkind("Mersenne-Twister")
[17:45:17.855]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.855]                       inherits = FALSE)
[17:45:17.855]                   }
[17:45:17.855]                   options(future.plan = NULL)
[17:45:17.855]                   if (is.na(NA_character_)) 
[17:45:17.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.855]                     .init = FALSE)
[17:45:17.855]                 }
[17:45:17.855]             }
[17:45:17.855]         }
[17:45:17.855]     })
[17:45:17.855]     if (TRUE) {
[17:45:17.855]         base::sink(type = "output", split = FALSE)
[17:45:17.855]         if (TRUE) {
[17:45:17.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.855]         }
[17:45:17.855]         else {
[17:45:17.855]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.855]         }
[17:45:17.855]         base::close(...future.stdout)
[17:45:17.855]         ...future.stdout <- NULL
[17:45:17.855]     }
[17:45:17.855]     ...future.result$conditions <- ...future.conditions
[17:45:17.855]     ...future.result$finished <- base::Sys.time()
[17:45:17.855]     ...future.result
[17:45:17.855] }
[17:45:17.857] assign_globals() ...
[17:45:17.857] List of 11
[17:45:17.857]  $ ...future.FUN            :function (x, ...)  
[17:45:17.857]  $ x_FUN                    :function (x, ...)  
[17:45:17.857]  $ times                    : int 5
[17:45:17.857]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.857]  $ stop_if_not              :function (...)  
[17:45:17.857]  $ dim                      : NULL
[17:45:17.857]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.857]  $ future.call.arguments    : list()
[17:45:17.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.857]  $ ...future.elements_ii    :List of 3
[17:45:17.857]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:45:17.857]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:45:17.857]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:45:17.857]  $ ...future.seeds_ii       : NULL
[17:45:17.857]  $ ...future.globals.maxSize: NULL
[17:45:17.857]  - attr(*, "where")=List of 11
[17:45:17.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.857]  - attr(*, "resolved")= logi FALSE
[17:45:17.857]  - attr(*, "total_size")= num 95528
[17:45:17.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.857]  - attr(*, "already-done")= logi TRUE
[17:45:17.864] - copied ‘...future.FUN’ to environment
[17:45:17.864] - copied ‘x_FUN’ to environment
[17:45:17.865] - copied ‘times’ to environment
[17:45:17.865] - copied ‘stopf’ to environment
[17:45:17.865] - copied ‘stop_if_not’ to environment
[17:45:17.865] - copied ‘dim’ to environment
[17:45:17.865] - copied ‘valid_types’ to environment
[17:45:17.865] - copied ‘future.call.arguments’ to environment
[17:45:17.865] - copied ‘...future.elements_ii’ to environment
[17:45:17.865] - copied ‘...future.seeds_ii’ to environment
[17:45:17.865] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.865] assign_globals() ... done
[17:45:17.866] plan(): Setting new future strategy stack:
[17:45:17.866] List of future strategies:
[17:45:17.866] 1. sequential:
[17:45:17.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.866]    - tweaked: FALSE
[17:45:17.866]    - call: NULL
[17:45:17.866] plan(): nbrOfWorkers() = 1
[17:45:17.869] plan(): Setting new future strategy stack:
[17:45:17.869] List of future strategies:
[17:45:17.869] 1. sequential:
[17:45:17.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.869]    - tweaked: FALSE
[17:45:17.869]    - call: plan(strategy)
[17:45:17.870] plan(): nbrOfWorkers() = 1
[17:45:17.870] SequentialFuture started (and completed)
[17:45:17.870] - Launch lazy future ... done
[17:45:17.870] run() for ‘SequentialFuture’ ... done
[17:45:17.870] Created future:
[17:45:17.870] SequentialFuture:
[17:45:17.870] Label: ‘future_vapply-1’
[17:45:17.870] Expression:
[17:45:17.870] {
[17:45:17.870]     do.call(function(...) {
[17:45:17.870]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.870]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.870]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.870]             on.exit(options(oopts), add = TRUE)
[17:45:17.870]         }
[17:45:17.870]         {
[17:45:17.870]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.870]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.870]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.870]             })
[17:45:17.870]         }
[17:45:17.870]     }, args = future.call.arguments)
[17:45:17.870] }
[17:45:17.870] Lazy evaluation: FALSE
[17:45:17.870] Asynchronous evaluation: FALSE
[17:45:17.870] Local evaluation: TRUE
[17:45:17.870] Environment: R_GlobalEnv
[17:45:17.870] Capture standard output: TRUE
[17:45:17.870] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.870] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.870] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:17.870] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.870] Resolved: TRUE
[17:45:17.870] Value: 1.71 KiB of class ‘list’
[17:45:17.870] Early signaling: FALSE
[17:45:17.870] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.870] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.871] Chunk #1 of 1 ... DONE
[17:45:17.871] Launching 1 futures (chunks) ... DONE
[17:45:17.872] Resolving 1 futures (chunks) ...
[17:45:17.872] resolve() on list ...
[17:45:17.872]  recursive: 0
[17:45:17.872]  length: 1
[17:45:17.872] 
[17:45:17.872] resolved() for ‘SequentialFuture’ ...
[17:45:17.872] - state: ‘finished’
[17:45:17.872] - run: TRUE
[17:45:17.872] - result: ‘FutureResult’
[17:45:17.872] resolved() for ‘SequentialFuture’ ... done
[17:45:17.873] Future #1
[17:45:17.873] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.873] - nx: 1
[17:45:17.873] - relay: TRUE
[17:45:17.873] - stdout: TRUE
[17:45:17.873] - signal: TRUE
[17:45:17.873] - resignal: FALSE
[17:45:17.873] - force: TRUE
[17:45:17.873] - relayed: [n=1] FALSE
[17:45:17.873] - queued futures: [n=1] FALSE
[17:45:17.873]  - until=1
[17:45:17.873]  - relaying element #1
[17:45:17.874] - relayed: [n=1] TRUE
[17:45:17.874] - queued futures: [n=1] TRUE
[17:45:17.874] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.874]  length: 0 (resolved future 1)
[17:45:17.874] Relaying remaining futures
[17:45:17.874] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.874] - nx: 1
[17:45:17.874] - relay: TRUE
[17:45:17.874] - stdout: TRUE
[17:45:17.874] - signal: TRUE
[17:45:17.875] - resignal: FALSE
[17:45:17.875] - force: TRUE
[17:45:17.875] - relayed: [n=1] TRUE
[17:45:17.875] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.875] - relayed: [n=1] TRUE
[17:45:17.875] - queued futures: [n=1] TRUE
[17:45:17.875] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.875] resolve() on list ... DONE
[17:45:17.875]  - Number of value chunks collected: 1
[17:45:17.875] Resolving 1 futures (chunks) ... DONE
[17:45:17.876] Reducing values from 1 chunks ...
[17:45:17.876]  - Number of values collected after concatenation: 3
[17:45:17.876]  - Number of values expected: 3
[17:45:17.876] Reducing values from 1 chunks ... DONE
[17:45:17.876] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:45:17.878] future_lapply() ...
[17:45:17.881] Number of chunks: 1
[17:45:17.881] getGlobalsAndPackagesXApply() ...
[17:45:17.881]  - future.globals: TRUE
[17:45:17.881] getGlobalsAndPackages() ...
[17:45:17.882] Searching for globals...
[17:45:17.886] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:45:17.886] Searching for globals ... DONE
[17:45:17.886] Resolving globals: FALSE
[17:45:17.887] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:45:17.887] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:45:17.887] - globals: [1] ‘FUN’
[17:45:17.887] - packages: [1] ‘stats’
[17:45:17.888] getGlobalsAndPackages() ... DONE
[17:45:17.888]  - globals found/used: [n=1] ‘FUN’
[17:45:17.888]  - needed namespaces: [n=1] ‘stats’
[17:45:17.888] Finding globals ... DONE
[17:45:17.888]  - use_args: TRUE
[17:45:17.888]  - Getting '...' globals ...
[17:45:17.888] resolve() on list ...
[17:45:17.888]  recursive: 0
[17:45:17.889]  length: 1
[17:45:17.889]  elements: ‘...’
[17:45:17.889]  length: 0 (resolved future 1)
[17:45:17.889] resolve() on list ... DONE
[17:45:17.889]    - '...' content: [n=0] 
[17:45:17.889] List of 1
[17:45:17.889]  $ ...: list()
[17:45:17.889]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.889]  - attr(*, "where")=List of 1
[17:45:17.889]   ..$ ...:<environment: 0x5561f37c9f38> 
[17:45:17.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.889]  - attr(*, "resolved")= logi TRUE
[17:45:17.889]  - attr(*, "total_size")= num NA
[17:45:17.893]  - Getting '...' globals ... DONE
[17:45:17.893] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:17.893] List of 2
[17:45:17.893]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:45:17.893]  $ ...          : list()
[17:45:17.893]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.893]  - attr(*, "where")=List of 2
[17:45:17.893]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.893]   ..$ ...          :<environment: 0x5561f37c9f38> 
[17:45:17.893]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.893]  - attr(*, "resolved")= logi FALSE
[17:45:17.893]  - attr(*, "total_size")= num 46960
[17:45:17.896] Packages to be attached in all futures: [n=1] ‘stats’
[17:45:17.896] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.896] Number of futures (= number of chunks): 1
[17:45:17.896] Launching 1 futures (chunks) ...
[17:45:17.896] Chunk #1 of 1 ...
[17:45:17.896]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.896] getGlobalsAndPackages() ...
[17:45:17.896] Searching for globals...
[17:45:17.897] 
[17:45:17.897] Searching for globals ... DONE
[17:45:17.897] - globals: [0] <none>
[17:45:17.897] getGlobalsAndPackages() ... DONE
[17:45:17.897]    + additional globals found: [n=0] 
[17:45:17.897]    + additional namespaces needed: [n=0] 
[17:45:17.897]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.897]  - seeds: <none>
[17:45:17.897]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.897] getGlobalsAndPackages() ...
[17:45:17.898] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.898] Resolving globals: FALSE
[17:45:17.898] Tweak future expression to call with '...' arguments ...
[17:45:17.898] {
[17:45:17.898]     do.call(function(...) {
[17:45:17.898]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.898]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.898]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.898]             on.exit(options(oopts), add = TRUE)
[17:45:17.898]         }
[17:45:17.898]         {
[17:45:17.898]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.898]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.898]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.898]             })
[17:45:17.898]         }
[17:45:17.898]     }, args = future.call.arguments)
[17:45:17.898] }
[17:45:17.898] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.898] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.899] - packages: [1] ‘stats’
[17:45:17.899] getGlobalsAndPackages() ... DONE
[17:45:17.899] run() for ‘Future’ ...
[17:45:17.899] - state: ‘created’
[17:45:17.899] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.899] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.900]   - Field: ‘label’
[17:45:17.900]   - Field: ‘local’
[17:45:17.900]   - Field: ‘owner’
[17:45:17.900]   - Field: ‘envir’
[17:45:17.900]   - Field: ‘packages’
[17:45:17.900]   - Field: ‘gc’
[17:45:17.900]   - Field: ‘conditions’
[17:45:17.900]   - Field: ‘expr’
[17:45:17.900]   - Field: ‘uuid’
[17:45:17.901]   - Field: ‘seed’
[17:45:17.901]   - Field: ‘version’
[17:45:17.901]   - Field: ‘result’
[17:45:17.901]   - Field: ‘asynchronous’
[17:45:17.901]   - Field: ‘calls’
[17:45:17.901]   - Field: ‘globals’
[17:45:17.901]   - Field: ‘stdout’
[17:45:17.901]   - Field: ‘earlySignal’
[17:45:17.901]   - Field: ‘lazy’
[17:45:17.901]   - Field: ‘state’
[17:45:17.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.901] - Launch lazy future ...
[17:45:17.902] Packages needed by the future expression (n = 1): ‘stats’
[17:45:17.902] Packages needed by future strategies (n = 0): <none>
[17:45:17.902] {
[17:45:17.902]     {
[17:45:17.902]         {
[17:45:17.902]             ...future.startTime <- base::Sys.time()
[17:45:17.902]             {
[17:45:17.902]                 {
[17:45:17.902]                   {
[17:45:17.902]                     {
[17:45:17.902]                       base::local({
[17:45:17.902]                         has_future <- base::requireNamespace("future", 
[17:45:17.902]                           quietly = TRUE)
[17:45:17.902]                         if (has_future) {
[17:45:17.902]                           ns <- base::getNamespace("future")
[17:45:17.902]                           version <- ns[[".package"]][["version"]]
[17:45:17.902]                           if (is.null(version)) 
[17:45:17.902]                             version <- utils::packageVersion("future")
[17:45:17.902]                         }
[17:45:17.902]                         else {
[17:45:17.902]                           version <- NULL
[17:45:17.902]                         }
[17:45:17.902]                         if (!has_future || version < "1.8.0") {
[17:45:17.902]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.902]                             "", base::R.version$version.string), 
[17:45:17.902]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.902]                               "release", "version")], collapse = " "), 
[17:45:17.902]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.902]                             info)
[17:45:17.902]                           info <- base::paste(info, collapse = "; ")
[17:45:17.902]                           if (!has_future) {
[17:45:17.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.902]                               info)
[17:45:17.902]                           }
[17:45:17.902]                           else {
[17:45:17.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.902]                               info, version)
[17:45:17.902]                           }
[17:45:17.902]                           base::stop(msg)
[17:45:17.902]                         }
[17:45:17.902]                       })
[17:45:17.902]                     }
[17:45:17.902]                     base::local({
[17:45:17.902]                       for (pkg in "stats") {
[17:45:17.902]                         base::loadNamespace(pkg)
[17:45:17.902]                         base::library(pkg, character.only = TRUE)
[17:45:17.902]                       }
[17:45:17.902]                     })
[17:45:17.902]                   }
[17:45:17.902]                   ...future.strategy.old <- future::plan("list")
[17:45:17.902]                   options(future.plan = NULL)
[17:45:17.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.902]                 }
[17:45:17.902]                 ...future.workdir <- getwd()
[17:45:17.902]             }
[17:45:17.902]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.902]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.902]         }
[17:45:17.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.902]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.902]             base::names(...future.oldOptions))
[17:45:17.902]     }
[17:45:17.902]     if (FALSE) {
[17:45:17.902]     }
[17:45:17.902]     else {
[17:45:17.902]         if (TRUE) {
[17:45:17.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.902]                 open = "w")
[17:45:17.902]         }
[17:45:17.902]         else {
[17:45:17.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.902]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.902]         }
[17:45:17.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.902]             base::sink(type = "output", split = FALSE)
[17:45:17.902]             base::close(...future.stdout)
[17:45:17.902]         }, add = TRUE)
[17:45:17.902]     }
[17:45:17.902]     ...future.frame <- base::sys.nframe()
[17:45:17.902]     ...future.conditions <- base::list()
[17:45:17.902]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.902]     if (FALSE) {
[17:45:17.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.902]     }
[17:45:17.902]     ...future.result <- base::tryCatch({
[17:45:17.902]         base::withCallingHandlers({
[17:45:17.902]             ...future.value <- base::withVisible(base::local({
[17:45:17.902]                 do.call(function(...) {
[17:45:17.902]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.902]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.902]                     ...future.globals.maxSize)) {
[17:45:17.902]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.902]                     on.exit(options(oopts), add = TRUE)
[17:45:17.902]                   }
[17:45:17.902]                   {
[17:45:17.902]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.902]                       FUN = function(jj) {
[17:45:17.902]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.902]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.902]                       })
[17:45:17.902]                   }
[17:45:17.902]                 }, args = future.call.arguments)
[17:45:17.902]             }))
[17:45:17.902]             future::FutureResult(value = ...future.value$value, 
[17:45:17.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.902]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.902]                     ...future.globalenv.names))
[17:45:17.902]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.902]         }, condition = base::local({
[17:45:17.902]             c <- base::c
[17:45:17.902]             inherits <- base::inherits
[17:45:17.902]             invokeRestart <- base::invokeRestart
[17:45:17.902]             length <- base::length
[17:45:17.902]             list <- base::list
[17:45:17.902]             seq.int <- base::seq.int
[17:45:17.902]             signalCondition <- base::signalCondition
[17:45:17.902]             sys.calls <- base::sys.calls
[17:45:17.902]             `[[` <- base::`[[`
[17:45:17.902]             `+` <- base::`+`
[17:45:17.902]             `<<-` <- base::`<<-`
[17:45:17.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.902]                   3L)]
[17:45:17.902]             }
[17:45:17.902]             function(cond) {
[17:45:17.902]                 is_error <- inherits(cond, "error")
[17:45:17.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.902]                   NULL)
[17:45:17.902]                 if (is_error) {
[17:45:17.902]                   sessionInformation <- function() {
[17:45:17.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.902]                       search = base::search(), system = base::Sys.info())
[17:45:17.902]                   }
[17:45:17.902]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.902]                     cond$call), session = sessionInformation(), 
[17:45:17.902]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.902]                   signalCondition(cond)
[17:45:17.902]                 }
[17:45:17.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.902]                 "immediateCondition"))) {
[17:45:17.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.902]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.902]                   if (TRUE && !signal) {
[17:45:17.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.902]                     {
[17:45:17.902]                       inherits <- base::inherits
[17:45:17.902]                       invokeRestart <- base::invokeRestart
[17:45:17.902]                       is.null <- base::is.null
[17:45:17.902]                       muffled <- FALSE
[17:45:17.902]                       if (inherits(cond, "message")) {
[17:45:17.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.902]                         if (muffled) 
[17:45:17.902]                           invokeRestart("muffleMessage")
[17:45:17.902]                       }
[17:45:17.902]                       else if (inherits(cond, "warning")) {
[17:45:17.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.902]                         if (muffled) 
[17:45:17.902]                           invokeRestart("muffleWarning")
[17:45:17.902]                       }
[17:45:17.902]                       else if (inherits(cond, "condition")) {
[17:45:17.902]                         if (!is.null(pattern)) {
[17:45:17.902]                           computeRestarts <- base::computeRestarts
[17:45:17.902]                           grepl <- base::grepl
[17:45:17.902]                           restarts <- computeRestarts(cond)
[17:45:17.902]                           for (restart in restarts) {
[17:45:17.902]                             name <- restart$name
[17:45:17.902]                             if (is.null(name)) 
[17:45:17.902]                               next
[17:45:17.902]                             if (!grepl(pattern, name)) 
[17:45:17.902]                               next
[17:45:17.902]                             invokeRestart(restart)
[17:45:17.902]                             muffled <- TRUE
[17:45:17.902]                             break
[17:45:17.902]                           }
[17:45:17.902]                         }
[17:45:17.902]                       }
[17:45:17.902]                       invisible(muffled)
[17:45:17.902]                     }
[17:45:17.902]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.902]                   }
[17:45:17.902]                 }
[17:45:17.902]                 else {
[17:45:17.902]                   if (TRUE) {
[17:45:17.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.902]                     {
[17:45:17.902]                       inherits <- base::inherits
[17:45:17.902]                       invokeRestart <- base::invokeRestart
[17:45:17.902]                       is.null <- base::is.null
[17:45:17.902]                       muffled <- FALSE
[17:45:17.902]                       if (inherits(cond, "message")) {
[17:45:17.902]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.902]                         if (muffled) 
[17:45:17.902]                           invokeRestart("muffleMessage")
[17:45:17.902]                       }
[17:45:17.902]                       else if (inherits(cond, "warning")) {
[17:45:17.902]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.902]                         if (muffled) 
[17:45:17.902]                           invokeRestart("muffleWarning")
[17:45:17.902]                       }
[17:45:17.902]                       else if (inherits(cond, "condition")) {
[17:45:17.902]                         if (!is.null(pattern)) {
[17:45:17.902]                           computeRestarts <- base::computeRestarts
[17:45:17.902]                           grepl <- base::grepl
[17:45:17.902]                           restarts <- computeRestarts(cond)
[17:45:17.902]                           for (restart in restarts) {
[17:45:17.902]                             name <- restart$name
[17:45:17.902]                             if (is.null(name)) 
[17:45:17.902]                               next
[17:45:17.902]                             if (!grepl(pattern, name)) 
[17:45:17.902]                               next
[17:45:17.902]                             invokeRestart(restart)
[17:45:17.902]                             muffled <- TRUE
[17:45:17.902]                             break
[17:45:17.902]                           }
[17:45:17.902]                         }
[17:45:17.902]                       }
[17:45:17.902]                       invisible(muffled)
[17:45:17.902]                     }
[17:45:17.902]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.902]                   }
[17:45:17.902]                 }
[17:45:17.902]             }
[17:45:17.902]         }))
[17:45:17.902]     }, error = function(ex) {
[17:45:17.902]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.902]                 ...future.rng), started = ...future.startTime, 
[17:45:17.902]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.902]             version = "1.8"), class = "FutureResult")
[17:45:17.902]     }, finally = {
[17:45:17.902]         if (!identical(...future.workdir, getwd())) 
[17:45:17.902]             setwd(...future.workdir)
[17:45:17.902]         {
[17:45:17.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.902]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.902]             }
[17:45:17.902]             base::options(...future.oldOptions)
[17:45:17.902]             if (.Platform$OS.type == "windows") {
[17:45:17.902]                 old_names <- names(...future.oldEnvVars)
[17:45:17.902]                 envs <- base::Sys.getenv()
[17:45:17.902]                 names <- names(envs)
[17:45:17.902]                 common <- intersect(names, old_names)
[17:45:17.902]                 added <- setdiff(names, old_names)
[17:45:17.902]                 removed <- setdiff(old_names, names)
[17:45:17.902]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.902]                   envs[common]]
[17:45:17.902]                 NAMES <- toupper(changed)
[17:45:17.902]                 args <- list()
[17:45:17.902]                 for (kk in seq_along(NAMES)) {
[17:45:17.902]                   name <- changed[[kk]]
[17:45:17.902]                   NAME <- NAMES[[kk]]
[17:45:17.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.902]                     next
[17:45:17.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.902]                 }
[17:45:17.902]                 NAMES <- toupper(added)
[17:45:17.902]                 for (kk in seq_along(NAMES)) {
[17:45:17.902]                   name <- added[[kk]]
[17:45:17.902]                   NAME <- NAMES[[kk]]
[17:45:17.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.902]                     next
[17:45:17.902]                   args[[name]] <- ""
[17:45:17.902]                 }
[17:45:17.902]                 NAMES <- toupper(removed)
[17:45:17.902]                 for (kk in seq_along(NAMES)) {
[17:45:17.902]                   name <- removed[[kk]]
[17:45:17.902]                   NAME <- NAMES[[kk]]
[17:45:17.902]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.902]                     next
[17:45:17.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.902]                 }
[17:45:17.902]                 if (length(args) > 0) 
[17:45:17.902]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.902]             }
[17:45:17.902]             else {
[17:45:17.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.902]             }
[17:45:17.902]             {
[17:45:17.902]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.902]                   0L) {
[17:45:17.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.902]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.902]                   base::options(opts)
[17:45:17.902]                 }
[17:45:17.902]                 {
[17:45:17.902]                   {
[17:45:17.902]                     NULL
[17:45:17.902]                     RNGkind("Mersenne-Twister")
[17:45:17.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.902]                       inherits = FALSE)
[17:45:17.902]                   }
[17:45:17.902]                   options(future.plan = NULL)
[17:45:17.902]                   if (is.na(NA_character_)) 
[17:45:17.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.902]                     .init = FALSE)
[17:45:17.902]                 }
[17:45:17.902]             }
[17:45:17.902]         }
[17:45:17.902]     })
[17:45:17.902]     if (TRUE) {
[17:45:17.902]         base::sink(type = "output", split = FALSE)
[17:45:17.902]         if (TRUE) {
[17:45:17.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.902]         }
[17:45:17.902]         else {
[17:45:17.902]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.902]         }
[17:45:17.902]         base::close(...future.stdout)
[17:45:17.902]         ...future.stdout <- NULL
[17:45:17.902]     }
[17:45:17.902]     ...future.result$conditions <- ...future.conditions
[17:45:17.902]     ...future.result$finished <- base::Sys.time()
[17:45:17.902]     ...future.result
[17:45:17.902] }
[17:45:17.904] assign_globals() ...
[17:45:17.904] List of 5
[17:45:17.904]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:45:17.904]  $ future.call.arguments    : list()
[17:45:17.904]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.904]  $ ...future.elements_ii    :List of 7
[17:45:17.904]   ..$ : int [1:3] 1 2 3
[17:45:17.904]   ..$ : int [1:4] 1 2 3 4
[17:45:17.904]   ..$ : int [1:5] 1 2 3 4 5
[17:45:17.904]   ..$ : int [1:6] 1 2 3 4 5 6
[17:45:17.904]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:45:17.904]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:45:17.904]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:45:17.904]  $ ...future.seeds_ii       : NULL
[17:45:17.904]  $ ...future.globals.maxSize: NULL
[17:45:17.904]  - attr(*, "where")=List of 5
[17:45:17.904]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.904]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.904]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.904]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.904]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.904]  - attr(*, "resolved")= logi FALSE
[17:45:17.904]  - attr(*, "total_size")= num 46960
[17:45:17.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.904]  - attr(*, "already-done")= logi TRUE
[17:45:17.910] - copied ‘...future.FUN’ to environment
[17:45:17.910] - copied ‘future.call.arguments’ to environment
[17:45:17.910] - copied ‘...future.elements_ii’ to environment
[17:45:17.910] - copied ‘...future.seeds_ii’ to environment
[17:45:17.911] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.911] assign_globals() ... done
[17:45:17.911] plan(): Setting new future strategy stack:
[17:45:17.911] List of future strategies:
[17:45:17.911] 1. sequential:
[17:45:17.911]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.911]    - tweaked: FALSE
[17:45:17.911]    - call: NULL
[17:45:17.912] plan(): nbrOfWorkers() = 1
[17:45:17.912] plan(): Setting new future strategy stack:
[17:45:17.912] List of future strategies:
[17:45:17.912] 1. sequential:
[17:45:17.912]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.912]    - tweaked: FALSE
[17:45:17.912]    - call: plan(strategy)
[17:45:17.913] plan(): nbrOfWorkers() = 1
[17:45:17.913] SequentialFuture started (and completed)
[17:45:17.913] - Launch lazy future ... done
[17:45:17.913] run() for ‘SequentialFuture’ ... done
[17:45:17.913] Created future:
[17:45:17.914] SequentialFuture:
[17:45:17.914] Label: ‘future_sapply-1’
[17:45:17.914] Expression:
[17:45:17.914] {
[17:45:17.914]     do.call(function(...) {
[17:45:17.914]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.914]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.914]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.914]             on.exit(options(oopts), add = TRUE)
[17:45:17.914]         }
[17:45:17.914]         {
[17:45:17.914]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.914]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.914]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.914]             })
[17:45:17.914]         }
[17:45:17.914]     }, args = future.call.arguments)
[17:45:17.914] }
[17:45:17.914] Lazy evaluation: FALSE
[17:45:17.914] Asynchronous evaluation: FALSE
[17:45:17.914] Local evaluation: TRUE
[17:45:17.914] Environment: R_GlobalEnv
[17:45:17.914] Capture standard output: TRUE
[17:45:17.914] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.914] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:17.914] Packages: 1 packages (‘stats’)
[17:45:17.914] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.914] Resolved: TRUE
[17:45:17.914] Value: 672 bytes of class ‘list’
[17:45:17.914] Early signaling: FALSE
[17:45:17.914] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.914] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.916] Chunk #1 of 1 ... DONE
[17:45:17.916] Launching 1 futures (chunks) ... DONE
[17:45:17.916] Resolving 1 futures (chunks) ...
[17:45:17.916] resolve() on list ...
[17:45:17.916]  recursive: 0
[17:45:17.916]  length: 1
[17:45:17.917] 
[17:45:17.917] resolved() for ‘SequentialFuture’ ...
[17:45:17.917] - state: ‘finished’
[17:45:17.917] - run: TRUE
[17:45:17.917] - result: ‘FutureResult’
[17:45:17.917] resolved() for ‘SequentialFuture’ ... done
[17:45:17.917] Future #1
[17:45:17.917] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.917] - nx: 1
[17:45:17.918] - relay: TRUE
[17:45:17.918] - stdout: TRUE
[17:45:17.918] - signal: TRUE
[17:45:17.918] - resignal: FALSE
[17:45:17.918] - force: TRUE
[17:45:17.918] - relayed: [n=1] FALSE
[17:45:17.918] - queued futures: [n=1] FALSE
[17:45:17.918]  - until=1
[17:45:17.918]  - relaying element #1
[17:45:17.918] - relayed: [n=1] TRUE
[17:45:17.918] - queued futures: [n=1] TRUE
[17:45:17.919] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.919]  length: 0 (resolved future 1)
[17:45:17.919] Relaying remaining futures
[17:45:17.919] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.919] - nx: 1
[17:45:17.919] - relay: TRUE
[17:45:17.919] - stdout: TRUE
[17:45:17.919] - signal: TRUE
[17:45:17.919] - resignal: FALSE
[17:45:17.919] - force: TRUE
[17:45:17.920] - relayed: [n=1] TRUE
[17:45:17.920] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.920] - relayed: [n=1] TRUE
[17:45:17.920] - queued futures: [n=1] TRUE
[17:45:17.920] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.920] resolve() on list ... DONE
[17:45:17.920]  - Number of value chunks collected: 1
[17:45:17.920] Resolving 1 futures (chunks) ... DONE
[17:45:17.920] Reducing values from 1 chunks ...
[17:45:17.920]  - Number of values collected after concatenation: 7
[17:45:17.920]  - Number of values expected: 7
[17:45:17.921] Reducing values from 1 chunks ... DONE
[17:45:17.921] future_lapply() ... DONE
[17:45:17.921] future_lapply() ...
[17:45:17.923] Number of chunks: 1
[17:45:17.923] getGlobalsAndPackagesXApply() ...
[17:45:17.923]  - future.globals: TRUE
[17:45:17.923] getGlobalsAndPackages() ...
[17:45:17.923] Searching for globals...
[17:45:17.930] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:45:17.930] Searching for globals ... DONE
[17:45:17.930] Resolving globals: FALSE
[17:45:17.931] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:45:17.931] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:45:17.932] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.932] - packages: [2] ‘stats’, ‘future.apply’
[17:45:17.932] getGlobalsAndPackages() ... DONE
[17:45:17.932]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:17.932]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:45:17.932] Finding globals ... DONE
[17:45:17.932]  - use_args: TRUE
[17:45:17.932]  - Getting '...' globals ...
[17:45:17.933] resolve() on list ...
[17:45:17.933]  recursive: 0
[17:45:17.933]  length: 1
[17:45:17.933]  elements: ‘...’
[17:45:17.933]  length: 0 (resolved future 1)
[17:45:17.933] resolve() on list ... DONE
[17:45:17.933]    - '...' content: [n=0] 
[17:45:17.933] List of 1
[17:45:17.933]  $ ...: list()
[17:45:17.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.933]  - attr(*, "where")=List of 1
[17:45:17.933]   ..$ ...:<environment: 0x5561f2fc6338> 
[17:45:17.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.933]  - attr(*, "resolved")= logi TRUE
[17:45:17.933]  - attr(*, "total_size")= num NA
[17:45:17.936]  - Getting '...' globals ... DONE
[17:45:17.937] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:17.937] List of 8
[17:45:17.937]  $ ...future.FUN:function (x, ...)  
[17:45:17.937]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:45:17.937]  $ times        : int 5
[17:45:17.937]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.937]  $ stop_if_not  :function (...)  
[17:45:17.937]  $ dim          : NULL
[17:45:17.937]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:17.937]  $ ...          : list()
[17:45:17.937]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.937]  - attr(*, "where")=List of 8
[17:45:17.937]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:17.937]   ..$ ...          :<environment: 0x5561f2fc6338> 
[17:45:17.937]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.937]  - attr(*, "resolved")= logi FALSE
[17:45:17.937]  - attr(*, "total_size")= num 141240
[17:45:17.942] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:45:17.942] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.943] Number of futures (= number of chunks): 1
[17:45:17.943] Launching 1 futures (chunks) ...
[17:45:17.943] Chunk #1 of 1 ...
[17:45:17.943]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.943] getGlobalsAndPackages() ...
[17:45:17.943] Searching for globals...
[17:45:17.943] 
[17:45:17.943] Searching for globals ... DONE
[17:45:17.944] - globals: [0] <none>
[17:45:17.944] getGlobalsAndPackages() ... DONE
[17:45:17.944]    + additional globals found: [n=0] 
[17:45:17.944]    + additional namespaces needed: [n=0] 
[17:45:17.944]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.944]  - seeds: <none>
[17:45:17.944]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.944] getGlobalsAndPackages() ...
[17:45:17.944] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.944] Resolving globals: FALSE
[17:45:17.944] Tweak future expression to call with '...' arguments ...
[17:45:17.945] {
[17:45:17.945]     do.call(function(...) {
[17:45:17.945]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.945]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.945]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.945]             on.exit(options(oopts), add = TRUE)
[17:45:17.945]         }
[17:45:17.945]         {
[17:45:17.945]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.945]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.945]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.945]             })
[17:45:17.945]         }
[17:45:17.945]     }, args = future.call.arguments)
[17:45:17.945] }
[17:45:17.945] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.945] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.945] - packages: [2] ‘stats’, ‘future.apply’
[17:45:17.946] getGlobalsAndPackages() ... DONE
[17:45:17.946] run() for ‘Future’ ...
[17:45:17.946] - state: ‘created’
[17:45:17.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.947]   - Field: ‘label’
[17:45:17.947]   - Field: ‘local’
[17:45:17.947]   - Field: ‘owner’
[17:45:17.947]   - Field: ‘envir’
[17:45:17.947]   - Field: ‘packages’
[17:45:17.947]   - Field: ‘gc’
[17:45:17.947]   - Field: ‘conditions’
[17:45:17.947]   - Field: ‘expr’
[17:45:17.947]   - Field: ‘uuid’
[17:45:17.947]   - Field: ‘seed’
[17:45:17.947]   - Field: ‘version’
[17:45:17.948]   - Field: ‘result’
[17:45:17.948]   - Field: ‘asynchronous’
[17:45:17.948]   - Field: ‘calls’
[17:45:17.948]   - Field: ‘globals’
[17:45:17.948]   - Field: ‘stdout’
[17:45:17.948]   - Field: ‘earlySignal’
[17:45:17.948]   - Field: ‘lazy’
[17:45:17.948]   - Field: ‘state’
[17:45:17.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.948] - Launch lazy future ...
[17:45:17.948] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:17.949] Packages needed by future strategies (n = 0): <none>
[17:45:17.949] {
[17:45:17.949]     {
[17:45:17.949]         {
[17:45:17.949]             ...future.startTime <- base::Sys.time()
[17:45:17.949]             {
[17:45:17.949]                 {
[17:45:17.949]                   {
[17:45:17.949]                     {
[17:45:17.949]                       base::local({
[17:45:17.949]                         has_future <- base::requireNamespace("future", 
[17:45:17.949]                           quietly = TRUE)
[17:45:17.949]                         if (has_future) {
[17:45:17.949]                           ns <- base::getNamespace("future")
[17:45:17.949]                           version <- ns[[".package"]][["version"]]
[17:45:17.949]                           if (is.null(version)) 
[17:45:17.949]                             version <- utils::packageVersion("future")
[17:45:17.949]                         }
[17:45:17.949]                         else {
[17:45:17.949]                           version <- NULL
[17:45:17.949]                         }
[17:45:17.949]                         if (!has_future || version < "1.8.0") {
[17:45:17.949]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.949]                             "", base::R.version$version.string), 
[17:45:17.949]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:17.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.949]                               "release", "version")], collapse = " "), 
[17:45:17.949]                             hostname = base::Sys.info()[["nodename"]])
[17:45:17.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.949]                             info)
[17:45:17.949]                           info <- base::paste(info, collapse = "; ")
[17:45:17.949]                           if (!has_future) {
[17:45:17.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.949]                               info)
[17:45:17.949]                           }
[17:45:17.949]                           else {
[17:45:17.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.949]                               info, version)
[17:45:17.949]                           }
[17:45:17.949]                           base::stop(msg)
[17:45:17.949]                         }
[17:45:17.949]                       })
[17:45:17.949]                     }
[17:45:17.949]                     base::local({
[17:45:17.949]                       for (pkg in c("stats", "future.apply")) {
[17:45:17.949]                         base::loadNamespace(pkg)
[17:45:17.949]                         base::library(pkg, character.only = TRUE)
[17:45:17.949]                       }
[17:45:17.949]                     })
[17:45:17.949]                   }
[17:45:17.949]                   ...future.strategy.old <- future::plan("list")
[17:45:17.949]                   options(future.plan = NULL)
[17:45:17.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.949]                 }
[17:45:17.949]                 ...future.workdir <- getwd()
[17:45:17.949]             }
[17:45:17.949]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.949]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.949]         }
[17:45:17.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.949]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.949]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.949]             base::names(...future.oldOptions))
[17:45:17.949]     }
[17:45:17.949]     if (FALSE) {
[17:45:17.949]     }
[17:45:17.949]     else {
[17:45:17.949]         if (TRUE) {
[17:45:17.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.949]                 open = "w")
[17:45:17.949]         }
[17:45:17.949]         else {
[17:45:17.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.949]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.949]         }
[17:45:17.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.949]             base::sink(type = "output", split = FALSE)
[17:45:17.949]             base::close(...future.stdout)
[17:45:17.949]         }, add = TRUE)
[17:45:17.949]     }
[17:45:17.949]     ...future.frame <- base::sys.nframe()
[17:45:17.949]     ...future.conditions <- base::list()
[17:45:17.949]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.949]     if (FALSE) {
[17:45:17.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.949]     }
[17:45:17.949]     ...future.result <- base::tryCatch({
[17:45:17.949]         base::withCallingHandlers({
[17:45:17.949]             ...future.value <- base::withVisible(base::local({
[17:45:17.949]                 do.call(function(...) {
[17:45:17.949]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.949]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.949]                     ...future.globals.maxSize)) {
[17:45:17.949]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.949]                     on.exit(options(oopts), add = TRUE)
[17:45:17.949]                   }
[17:45:17.949]                   {
[17:45:17.949]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.949]                       FUN = function(jj) {
[17:45:17.949]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.949]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.949]                       })
[17:45:17.949]                   }
[17:45:17.949]                 }, args = future.call.arguments)
[17:45:17.949]             }))
[17:45:17.949]             future::FutureResult(value = ...future.value$value, 
[17:45:17.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.949]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.949]                     ...future.globalenv.names))
[17:45:17.949]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.949]         }, condition = base::local({
[17:45:17.949]             c <- base::c
[17:45:17.949]             inherits <- base::inherits
[17:45:17.949]             invokeRestart <- base::invokeRestart
[17:45:17.949]             length <- base::length
[17:45:17.949]             list <- base::list
[17:45:17.949]             seq.int <- base::seq.int
[17:45:17.949]             signalCondition <- base::signalCondition
[17:45:17.949]             sys.calls <- base::sys.calls
[17:45:17.949]             `[[` <- base::`[[`
[17:45:17.949]             `+` <- base::`+`
[17:45:17.949]             `<<-` <- base::`<<-`
[17:45:17.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.949]                   3L)]
[17:45:17.949]             }
[17:45:17.949]             function(cond) {
[17:45:17.949]                 is_error <- inherits(cond, "error")
[17:45:17.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.949]                   NULL)
[17:45:17.949]                 if (is_error) {
[17:45:17.949]                   sessionInformation <- function() {
[17:45:17.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.949]                       search = base::search(), system = base::Sys.info())
[17:45:17.949]                   }
[17:45:17.949]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.949]                     cond$call), session = sessionInformation(), 
[17:45:17.949]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.949]                   signalCondition(cond)
[17:45:17.949]                 }
[17:45:17.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.949]                 "immediateCondition"))) {
[17:45:17.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.949]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.949]                   if (TRUE && !signal) {
[17:45:17.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.949]                     {
[17:45:17.949]                       inherits <- base::inherits
[17:45:17.949]                       invokeRestart <- base::invokeRestart
[17:45:17.949]                       is.null <- base::is.null
[17:45:17.949]                       muffled <- FALSE
[17:45:17.949]                       if (inherits(cond, "message")) {
[17:45:17.949]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.949]                         if (muffled) 
[17:45:17.949]                           invokeRestart("muffleMessage")
[17:45:17.949]                       }
[17:45:17.949]                       else if (inherits(cond, "warning")) {
[17:45:17.949]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.949]                         if (muffled) 
[17:45:17.949]                           invokeRestart("muffleWarning")
[17:45:17.949]                       }
[17:45:17.949]                       else if (inherits(cond, "condition")) {
[17:45:17.949]                         if (!is.null(pattern)) {
[17:45:17.949]                           computeRestarts <- base::computeRestarts
[17:45:17.949]                           grepl <- base::grepl
[17:45:17.949]                           restarts <- computeRestarts(cond)
[17:45:17.949]                           for (restart in restarts) {
[17:45:17.949]                             name <- restart$name
[17:45:17.949]                             if (is.null(name)) 
[17:45:17.949]                               next
[17:45:17.949]                             if (!grepl(pattern, name)) 
[17:45:17.949]                               next
[17:45:17.949]                             invokeRestart(restart)
[17:45:17.949]                             muffled <- TRUE
[17:45:17.949]                             break
[17:45:17.949]                           }
[17:45:17.949]                         }
[17:45:17.949]                       }
[17:45:17.949]                       invisible(muffled)
[17:45:17.949]                     }
[17:45:17.949]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.949]                   }
[17:45:17.949]                 }
[17:45:17.949]                 else {
[17:45:17.949]                   if (TRUE) {
[17:45:17.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.949]                     {
[17:45:17.949]                       inherits <- base::inherits
[17:45:17.949]                       invokeRestart <- base::invokeRestart
[17:45:17.949]                       is.null <- base::is.null
[17:45:17.949]                       muffled <- FALSE
[17:45:17.949]                       if (inherits(cond, "message")) {
[17:45:17.949]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.949]                         if (muffled) 
[17:45:17.949]                           invokeRestart("muffleMessage")
[17:45:17.949]                       }
[17:45:17.949]                       else if (inherits(cond, "warning")) {
[17:45:17.949]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.949]                         if (muffled) 
[17:45:17.949]                           invokeRestart("muffleWarning")
[17:45:17.949]                       }
[17:45:17.949]                       else if (inherits(cond, "condition")) {
[17:45:17.949]                         if (!is.null(pattern)) {
[17:45:17.949]                           computeRestarts <- base::computeRestarts
[17:45:17.949]                           grepl <- base::grepl
[17:45:17.949]                           restarts <- computeRestarts(cond)
[17:45:17.949]                           for (restart in restarts) {
[17:45:17.949]                             name <- restart$name
[17:45:17.949]                             if (is.null(name)) 
[17:45:17.949]                               next
[17:45:17.949]                             if (!grepl(pattern, name)) 
[17:45:17.949]                               next
[17:45:17.949]                             invokeRestart(restart)
[17:45:17.949]                             muffled <- TRUE
[17:45:17.949]                             break
[17:45:17.949]                           }
[17:45:17.949]                         }
[17:45:17.949]                       }
[17:45:17.949]                       invisible(muffled)
[17:45:17.949]                     }
[17:45:17.949]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.949]                   }
[17:45:17.949]                 }
[17:45:17.949]             }
[17:45:17.949]         }))
[17:45:17.949]     }, error = function(ex) {
[17:45:17.949]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.949]                 ...future.rng), started = ...future.startTime, 
[17:45:17.949]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.949]             version = "1.8"), class = "FutureResult")
[17:45:17.949]     }, finally = {
[17:45:17.949]         if (!identical(...future.workdir, getwd())) 
[17:45:17.949]             setwd(...future.workdir)
[17:45:17.949]         {
[17:45:17.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.949]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.949]             }
[17:45:17.949]             base::options(...future.oldOptions)
[17:45:17.949]             if (.Platform$OS.type == "windows") {
[17:45:17.949]                 old_names <- names(...future.oldEnvVars)
[17:45:17.949]                 envs <- base::Sys.getenv()
[17:45:17.949]                 names <- names(envs)
[17:45:17.949]                 common <- intersect(names, old_names)
[17:45:17.949]                 added <- setdiff(names, old_names)
[17:45:17.949]                 removed <- setdiff(old_names, names)
[17:45:17.949]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.949]                   envs[common]]
[17:45:17.949]                 NAMES <- toupper(changed)
[17:45:17.949]                 args <- list()
[17:45:17.949]                 for (kk in seq_along(NAMES)) {
[17:45:17.949]                   name <- changed[[kk]]
[17:45:17.949]                   NAME <- NAMES[[kk]]
[17:45:17.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.949]                     next
[17:45:17.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.949]                 }
[17:45:17.949]                 NAMES <- toupper(added)
[17:45:17.949]                 for (kk in seq_along(NAMES)) {
[17:45:17.949]                   name <- added[[kk]]
[17:45:17.949]                   NAME <- NAMES[[kk]]
[17:45:17.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.949]                     next
[17:45:17.949]                   args[[name]] <- ""
[17:45:17.949]                 }
[17:45:17.949]                 NAMES <- toupper(removed)
[17:45:17.949]                 for (kk in seq_along(NAMES)) {
[17:45:17.949]                   name <- removed[[kk]]
[17:45:17.949]                   NAME <- NAMES[[kk]]
[17:45:17.949]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.949]                     next
[17:45:17.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.949]                 }
[17:45:17.949]                 if (length(args) > 0) 
[17:45:17.949]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.949]             }
[17:45:17.949]             else {
[17:45:17.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.949]             }
[17:45:17.949]             {
[17:45:17.949]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.949]                   0L) {
[17:45:17.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.949]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.949]                   base::options(opts)
[17:45:17.949]                 }
[17:45:17.949]                 {
[17:45:17.949]                   {
[17:45:17.949]                     NULL
[17:45:17.949]                     RNGkind("Mersenne-Twister")
[17:45:17.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.949]                       inherits = FALSE)
[17:45:17.949]                   }
[17:45:17.949]                   options(future.plan = NULL)
[17:45:17.949]                   if (is.na(NA_character_)) 
[17:45:17.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.949]                     .init = FALSE)
[17:45:17.949]                 }
[17:45:17.949]             }
[17:45:17.949]         }
[17:45:17.949]     })
[17:45:17.949]     if (TRUE) {
[17:45:17.949]         base::sink(type = "output", split = FALSE)
[17:45:17.949]         if (TRUE) {
[17:45:17.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.949]         }
[17:45:17.949]         else {
[17:45:17.949]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.949]         }
[17:45:17.949]         base::close(...future.stdout)
[17:45:17.949]         ...future.stdout <- NULL
[17:45:17.949]     }
[17:45:17.949]     ...future.result$conditions <- ...future.conditions
[17:45:17.949]     ...future.result$finished <- base::Sys.time()
[17:45:17.949]     ...future.result
[17:45:17.949] }
[17:45:17.951] assign_globals() ...
[17:45:17.951] List of 11
[17:45:17.951]  $ ...future.FUN            :function (x, ...)  
[17:45:17.951]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:45:17.951]  $ times                    : int 5
[17:45:17.951]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:17.951]  $ stop_if_not              :function (...)  
[17:45:17.951]  $ dim                      : NULL
[17:45:17.951]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:17.951]  $ future.call.arguments    : list()
[17:45:17.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.951]  $ ...future.elements_ii    :List of 7
[17:45:17.951]   ..$ : int [1:3] 1 2 3
[17:45:17.951]   ..$ : int [1:4] 1 2 3 4
[17:45:17.951]   ..$ : int [1:5] 1 2 3 4 5
[17:45:17.951]   ..$ : int [1:6] 1 2 3 4 5 6
[17:45:17.951]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:45:17.951]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:45:17.951]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:45:17.951]  $ ...future.seeds_ii       : NULL
[17:45:17.951]  $ ...future.globals.maxSize: NULL
[17:45:17.951]  - attr(*, "where")=List of 11
[17:45:17.951]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.951]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.951]  - attr(*, "resolved")= logi FALSE
[17:45:17.951]  - attr(*, "total_size")= num 141240
[17:45:17.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.951]  - attr(*, "already-done")= logi TRUE
[17:45:17.961] - copied ‘...future.FUN’ to environment
[17:45:17.961] - copied ‘x_FUN’ to environment
[17:45:17.961] - copied ‘times’ to environment
[17:45:17.961] - copied ‘stopf’ to environment
[17:45:17.961] - copied ‘stop_if_not’ to environment
[17:45:17.961] - copied ‘dim’ to environment
[17:45:17.961] - copied ‘valid_types’ to environment
[17:45:17.961] - copied ‘future.call.arguments’ to environment
[17:45:17.962] - copied ‘...future.elements_ii’ to environment
[17:45:17.962] - copied ‘...future.seeds_ii’ to environment
[17:45:17.962] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.962] assign_globals() ... done
[17:45:17.962] plan(): Setting new future strategy stack:
[17:45:17.962] List of future strategies:
[17:45:17.962] 1. sequential:
[17:45:17.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.962]    - tweaked: FALSE
[17:45:17.962]    - call: NULL
[17:45:17.963] plan(): nbrOfWorkers() = 1
[17:45:17.964] plan(): Setting new future strategy stack:
[17:45:17.964] List of future strategies:
[17:45:17.964] 1. sequential:
[17:45:17.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.964]    - tweaked: FALSE
[17:45:17.964]    - call: plan(strategy)
[17:45:17.964] plan(): nbrOfWorkers() = 1
[17:45:17.964] SequentialFuture started (and completed)
[17:45:17.965] - Launch lazy future ... done
[17:45:17.965] run() for ‘SequentialFuture’ ... done
[17:45:17.965] Created future:
[17:45:17.965] SequentialFuture:
[17:45:17.965] Label: ‘future_vapply-1’
[17:45:17.965] Expression:
[17:45:17.965] {
[17:45:17.965]     do.call(function(...) {
[17:45:17.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.965]             on.exit(options(oopts), add = TRUE)
[17:45:17.965]         }
[17:45:17.965]         {
[17:45:17.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.965]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.965]             })
[17:45:17.965]         }
[17:45:17.965]     }, args = future.call.arguments)
[17:45:17.965] }
[17:45:17.965] Lazy evaluation: FALSE
[17:45:17.965] Asynchronous evaluation: FALSE
[17:45:17.965] Local evaluation: TRUE
[17:45:17.965] Environment: R_GlobalEnv
[17:45:17.965] Capture standard output: TRUE
[17:45:17.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:17.965] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:17.965] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:17.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:17.965] Resolved: TRUE
[17:45:17.965] Value: 672 bytes of class ‘list’
[17:45:17.965] Early signaling: FALSE
[17:45:17.965] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:17.965] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.966] Chunk #1 of 1 ... DONE
[17:45:17.966] Launching 1 futures (chunks) ... DONE
[17:45:17.966] Resolving 1 futures (chunks) ...
[17:45:17.966] resolve() on list ...
[17:45:17.966]  recursive: 0
[17:45:17.966]  length: 1
[17:45:17.966] 
[17:45:17.967] resolved() for ‘SequentialFuture’ ...
[17:45:17.967] - state: ‘finished’
[17:45:17.967] - run: TRUE
[17:45:17.967] - result: ‘FutureResult’
[17:45:17.967] resolved() for ‘SequentialFuture’ ... done
[17:45:17.967] Future #1
[17:45:17.967] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:17.967] - nx: 1
[17:45:17.967] - relay: TRUE
[17:45:17.967] - stdout: TRUE
[17:45:17.968] - signal: TRUE
[17:45:17.968] - resignal: FALSE
[17:45:17.968] - force: TRUE
[17:45:17.968] - relayed: [n=1] FALSE
[17:45:17.968] - queued futures: [n=1] FALSE
[17:45:17.968]  - until=1
[17:45:17.968]  - relaying element #1
[17:45:17.968] - relayed: [n=1] TRUE
[17:45:17.968] - queued futures: [n=1] TRUE
[17:45:17.968] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:17.968]  length: 0 (resolved future 1)
[17:45:17.969] Relaying remaining futures
[17:45:17.969] signalConditionsASAP(NULL, pos=0) ...
[17:45:17.969] - nx: 1
[17:45:17.969] - relay: TRUE
[17:45:17.969] - stdout: TRUE
[17:45:17.969] - signal: TRUE
[17:45:17.969] - resignal: FALSE
[17:45:17.969] - force: TRUE
[17:45:17.969] - relayed: [n=1] TRUE
[17:45:17.969] - queued futures: [n=1] TRUE
 - flush all
[17:45:17.969] - relayed: [n=1] TRUE
[17:45:17.969] - queued futures: [n=1] TRUE
[17:45:17.970] signalConditionsASAP(NULL, pos=0) ... done
[17:45:17.970] resolve() on list ... DONE
[17:45:17.970]  - Number of value chunks collected: 1
[17:45:17.970] Resolving 1 futures (chunks) ... DONE
[17:45:17.970] Reducing values from 1 chunks ...
[17:45:17.970]  - Number of values collected after concatenation: 7
[17:45:17.970]  - Number of values expected: 7
[17:45:17.970] Reducing values from 1 chunks ... DONE
[17:45:17.970] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:45:17.972] future_lapply() ...
[17:45:17.973] Number of chunks: 1
[17:45:17.973] getGlobalsAndPackagesXApply() ...
[17:45:17.973]  - future.globals: TRUE
[17:45:17.973] getGlobalsAndPackages() ...
[17:45:17.973] Searching for globals...
[17:45:17.974] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:45:17.974] Searching for globals ... DONE
[17:45:17.974] Resolving globals: FALSE
[17:45:17.975] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:45:17.975] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:45:17.975] - globals: [1] ‘FUN’
[17:45:17.975] 
[17:45:17.975] getGlobalsAndPackages() ... DONE
[17:45:17.975]  - globals found/used: [n=1] ‘FUN’
[17:45:17.975]  - needed namespaces: [n=0] 
[17:45:17.976] Finding globals ... DONE
[17:45:17.976]  - use_args: TRUE
[17:45:17.976]  - Getting '...' globals ...
[17:45:17.976] resolve() on list ...
[17:45:17.976]  recursive: 0
[17:45:17.976]  length: 1
[17:45:17.976]  elements: ‘...’
[17:45:17.976]  length: 0 (resolved future 1)
[17:45:17.976] resolve() on list ... DONE
[17:45:17.977]    - '...' content: [n=1] ‘y’
[17:45:17.977] List of 1
[17:45:17.977]  $ ...:List of 1
[17:45:17.977]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:17.977]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.977]  - attr(*, "where")=List of 1
[17:45:17.977]   ..$ ...:<environment: 0x5561f50bb7a0> 
[17:45:17.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.977]  - attr(*, "resolved")= logi TRUE
[17:45:17.977]  - attr(*, "total_size")= num NA
[17:45:17.979]  - Getting '...' globals ... DONE
[17:45:17.980] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:17.980] List of 2
[17:45:17.980]  $ ...future.FUN:function (x, y)  
[17:45:17.980]  $ ...          :List of 1
[17:45:17.980]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:17.980]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.980]  - attr(*, "where")=List of 2
[17:45:17.980]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:17.980]   ..$ ...          :<environment: 0x5561f50bb7a0> 
[17:45:17.980]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.980]  - attr(*, "resolved")= logi FALSE
[17:45:17.980]  - attr(*, "total_size")= num 4264
[17:45:17.984] Packages to be attached in all futures: [n=0] 
[17:45:17.984] getGlobalsAndPackagesXApply() ... DONE
[17:45:17.984] Number of futures (= number of chunks): 1
[17:45:17.985] Launching 1 futures (chunks) ...
[17:45:17.985] Chunk #1 of 1 ...
[17:45:17.985]  - Finding globals in 'X' for chunk #1 ...
[17:45:17.985] getGlobalsAndPackages() ...
[17:45:17.985] Searching for globals...
[17:45:17.985] 
[17:45:17.985] Searching for globals ... DONE
[17:45:17.985] - globals: [0] <none>
[17:45:17.985] getGlobalsAndPackages() ... DONE
[17:45:17.986]    + additional globals found: [n=0] 
[17:45:17.986]    + additional namespaces needed: [n=0] 
[17:45:17.986]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:17.986]  - seeds: <none>
[17:45:17.986]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.986] getGlobalsAndPackages() ...
[17:45:17.986] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.986] Resolving globals: FALSE
[17:45:17.986] Tweak future expression to call with '...' arguments ...
[17:45:17.986] {
[17:45:17.986]     do.call(function(...) {
[17:45:17.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:17.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.986]             on.exit(options(oopts), add = TRUE)
[17:45:17.986]         }
[17:45:17.986]         {
[17:45:17.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:17.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.986]                 ...future.FUN(...future.X_jj, ...)
[17:45:17.986]             })
[17:45:17.986]         }
[17:45:17.986]     }, args = future.call.arguments)
[17:45:17.986] }
[17:45:17.987] Tweak future expression to call with '...' arguments ... DONE
[17:45:17.987] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:17.987] 
[17:45:17.987] getGlobalsAndPackages() ... DONE
[17:45:17.988] run() for ‘Future’ ...
[17:45:17.988] - state: ‘created’
[17:45:17.988] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:17.988] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:17.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:17.988]   - Field: ‘label’
[17:45:17.988]   - Field: ‘local’
[17:45:17.988]   - Field: ‘owner’
[17:45:17.989]   - Field: ‘envir’
[17:45:17.989]   - Field: ‘packages’
[17:45:17.989]   - Field: ‘gc’
[17:45:17.989]   - Field: ‘conditions’
[17:45:17.989]   - Field: ‘expr’
[17:45:17.989]   - Field: ‘uuid’
[17:45:17.989]   - Field: ‘seed’
[17:45:17.989]   - Field: ‘version’
[17:45:17.989]   - Field: ‘result’
[17:45:17.989]   - Field: ‘asynchronous’
[17:45:17.989]   - Field: ‘calls’
[17:45:17.989]   - Field: ‘globals’
[17:45:17.990]   - Field: ‘stdout’
[17:45:17.990]   - Field: ‘earlySignal’
[17:45:17.990]   - Field: ‘lazy’
[17:45:17.990]   - Field: ‘state’
[17:45:17.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:17.990] - Launch lazy future ...
[17:45:17.990] Packages needed by the future expression (n = 0): <none>
[17:45:17.990] Packages needed by future strategies (n = 0): <none>
[17:45:17.991] {
[17:45:17.991]     {
[17:45:17.991]         {
[17:45:17.991]             ...future.startTime <- base::Sys.time()
[17:45:17.991]             {
[17:45:17.991]                 {
[17:45:17.991]                   {
[17:45:17.991]                     base::local({
[17:45:17.991]                       has_future <- base::requireNamespace("future", 
[17:45:17.991]                         quietly = TRUE)
[17:45:17.991]                       if (has_future) {
[17:45:17.991]                         ns <- base::getNamespace("future")
[17:45:17.991]                         version <- ns[[".package"]][["version"]]
[17:45:17.991]                         if (is.null(version)) 
[17:45:17.991]                           version <- utils::packageVersion("future")
[17:45:17.991]                       }
[17:45:17.991]                       else {
[17:45:17.991]                         version <- NULL
[17:45:17.991]                       }
[17:45:17.991]                       if (!has_future || version < "1.8.0") {
[17:45:17.991]                         info <- base::c(r_version = base::gsub("R version ", 
[17:45:17.991]                           "", base::R.version$version.string), 
[17:45:17.991]                           platform = base::sprintf("%s (%s-bit)", 
[17:45:17.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:17.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:17.991]                             "release", "version")], collapse = " "), 
[17:45:17.991]                           hostname = base::Sys.info()[["nodename"]])
[17:45:17.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[17:45:17.991]                           info)
[17:45:17.991]                         info <- base::paste(info, collapse = "; ")
[17:45:17.991]                         if (!has_future) {
[17:45:17.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:17.991]                             info)
[17:45:17.991]                         }
[17:45:17.991]                         else {
[17:45:17.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:17.991]                             info, version)
[17:45:17.991]                         }
[17:45:17.991]                         base::stop(msg)
[17:45:17.991]                       }
[17:45:17.991]                     })
[17:45:17.991]                   }
[17:45:17.991]                   ...future.strategy.old <- future::plan("list")
[17:45:17.991]                   options(future.plan = NULL)
[17:45:17.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:17.991]                 }
[17:45:17.991]                 ...future.workdir <- getwd()
[17:45:17.991]             }
[17:45:17.991]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:17.991]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:17.991]         }
[17:45:17.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:17.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:17.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:17.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:17.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:17.991]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:17.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:17.991]             base::names(...future.oldOptions))
[17:45:17.991]     }
[17:45:17.991]     if (FALSE) {
[17:45:17.991]     }
[17:45:17.991]     else {
[17:45:17.991]         if (TRUE) {
[17:45:17.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:17.991]                 open = "w")
[17:45:17.991]         }
[17:45:17.991]         else {
[17:45:17.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:17.991]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:17.991]         }
[17:45:17.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:17.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:17.991]             base::sink(type = "output", split = FALSE)
[17:45:17.991]             base::close(...future.stdout)
[17:45:17.991]         }, add = TRUE)
[17:45:17.991]     }
[17:45:17.991]     ...future.frame <- base::sys.nframe()
[17:45:17.991]     ...future.conditions <- base::list()
[17:45:17.991]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:17.991]     if (FALSE) {
[17:45:17.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:17.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:17.991]     }
[17:45:17.991]     ...future.result <- base::tryCatch({
[17:45:17.991]         base::withCallingHandlers({
[17:45:17.991]             ...future.value <- base::withVisible(base::local({
[17:45:17.991]                 do.call(function(...) {
[17:45:17.991]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:17.991]                   if (!identical(...future.globals.maxSize.org, 
[17:45:17.991]                     ...future.globals.maxSize)) {
[17:45:17.991]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:17.991]                     on.exit(options(oopts), add = TRUE)
[17:45:17.991]                   }
[17:45:17.991]                   {
[17:45:17.991]                     lapply(seq_along(...future.elements_ii), 
[17:45:17.991]                       FUN = function(jj) {
[17:45:17.991]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:17.991]                         ...future.FUN(...future.X_jj, ...)
[17:45:17.991]                       })
[17:45:17.991]                   }
[17:45:17.991]                 }, args = future.call.arguments)
[17:45:17.991]             }))
[17:45:17.991]             future::FutureResult(value = ...future.value$value, 
[17:45:17.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.991]                   ...future.rng), globalenv = if (FALSE) 
[17:45:17.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:17.991]                     ...future.globalenv.names))
[17:45:17.991]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:17.991]         }, condition = base::local({
[17:45:17.991]             c <- base::c
[17:45:17.991]             inherits <- base::inherits
[17:45:17.991]             invokeRestart <- base::invokeRestart
[17:45:17.991]             length <- base::length
[17:45:17.991]             list <- base::list
[17:45:17.991]             seq.int <- base::seq.int
[17:45:17.991]             signalCondition <- base::signalCondition
[17:45:17.991]             sys.calls <- base::sys.calls
[17:45:17.991]             `[[` <- base::`[[`
[17:45:17.991]             `+` <- base::`+`
[17:45:17.991]             `<<-` <- base::`<<-`
[17:45:17.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:17.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:17.991]                   3L)]
[17:45:17.991]             }
[17:45:17.991]             function(cond) {
[17:45:17.991]                 is_error <- inherits(cond, "error")
[17:45:17.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:17.991]                   NULL)
[17:45:17.991]                 if (is_error) {
[17:45:17.991]                   sessionInformation <- function() {
[17:45:17.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:17.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:17.991]                       search = base::search(), system = base::Sys.info())
[17:45:17.991]                   }
[17:45:17.991]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:17.991]                     cond$call), session = sessionInformation(), 
[17:45:17.991]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:17.991]                   signalCondition(cond)
[17:45:17.991]                 }
[17:45:17.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:17.991]                 "immediateCondition"))) {
[17:45:17.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:17.991]                   ...future.conditions[[length(...future.conditions) + 
[17:45:17.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:17.991]                   if (TRUE && !signal) {
[17:45:17.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.991]                     {
[17:45:17.991]                       inherits <- base::inherits
[17:45:17.991]                       invokeRestart <- base::invokeRestart
[17:45:17.991]                       is.null <- base::is.null
[17:45:17.991]                       muffled <- FALSE
[17:45:17.991]                       if (inherits(cond, "message")) {
[17:45:17.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.991]                         if (muffled) 
[17:45:17.991]                           invokeRestart("muffleMessage")
[17:45:17.991]                       }
[17:45:17.991]                       else if (inherits(cond, "warning")) {
[17:45:17.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.991]                         if (muffled) 
[17:45:17.991]                           invokeRestart("muffleWarning")
[17:45:17.991]                       }
[17:45:17.991]                       else if (inherits(cond, "condition")) {
[17:45:17.991]                         if (!is.null(pattern)) {
[17:45:17.991]                           computeRestarts <- base::computeRestarts
[17:45:17.991]                           grepl <- base::grepl
[17:45:17.991]                           restarts <- computeRestarts(cond)
[17:45:17.991]                           for (restart in restarts) {
[17:45:17.991]                             name <- restart$name
[17:45:17.991]                             if (is.null(name)) 
[17:45:17.991]                               next
[17:45:17.991]                             if (!grepl(pattern, name)) 
[17:45:17.991]                               next
[17:45:17.991]                             invokeRestart(restart)
[17:45:17.991]                             muffled <- TRUE
[17:45:17.991]                             break
[17:45:17.991]                           }
[17:45:17.991]                         }
[17:45:17.991]                       }
[17:45:17.991]                       invisible(muffled)
[17:45:17.991]                     }
[17:45:17.991]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.991]                   }
[17:45:17.991]                 }
[17:45:17.991]                 else {
[17:45:17.991]                   if (TRUE) {
[17:45:17.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:17.991]                     {
[17:45:17.991]                       inherits <- base::inherits
[17:45:17.991]                       invokeRestart <- base::invokeRestart
[17:45:17.991]                       is.null <- base::is.null
[17:45:17.991]                       muffled <- FALSE
[17:45:17.991]                       if (inherits(cond, "message")) {
[17:45:17.991]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:17.991]                         if (muffled) 
[17:45:17.991]                           invokeRestart("muffleMessage")
[17:45:17.991]                       }
[17:45:17.991]                       else if (inherits(cond, "warning")) {
[17:45:17.991]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:17.991]                         if (muffled) 
[17:45:17.991]                           invokeRestart("muffleWarning")
[17:45:17.991]                       }
[17:45:17.991]                       else if (inherits(cond, "condition")) {
[17:45:17.991]                         if (!is.null(pattern)) {
[17:45:17.991]                           computeRestarts <- base::computeRestarts
[17:45:17.991]                           grepl <- base::grepl
[17:45:17.991]                           restarts <- computeRestarts(cond)
[17:45:17.991]                           for (restart in restarts) {
[17:45:17.991]                             name <- restart$name
[17:45:17.991]                             if (is.null(name)) 
[17:45:17.991]                               next
[17:45:17.991]                             if (!grepl(pattern, name)) 
[17:45:17.991]                               next
[17:45:17.991]                             invokeRestart(restart)
[17:45:17.991]                             muffled <- TRUE
[17:45:17.991]                             break
[17:45:17.991]                           }
[17:45:17.991]                         }
[17:45:17.991]                       }
[17:45:17.991]                       invisible(muffled)
[17:45:17.991]                     }
[17:45:17.991]                     muffleCondition(cond, pattern = "^muffle")
[17:45:17.991]                   }
[17:45:17.991]                 }
[17:45:17.991]             }
[17:45:17.991]         }))
[17:45:17.991]     }, error = function(ex) {
[17:45:17.991]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:17.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:17.991]                 ...future.rng), started = ...future.startTime, 
[17:45:17.991]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:17.991]             version = "1.8"), class = "FutureResult")
[17:45:17.991]     }, finally = {
[17:45:17.991]         if (!identical(...future.workdir, getwd())) 
[17:45:17.991]             setwd(...future.workdir)
[17:45:17.991]         {
[17:45:17.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:17.991]                 ...future.oldOptions$nwarnings <- NULL
[17:45:17.991]             }
[17:45:17.991]             base::options(...future.oldOptions)
[17:45:17.991]             if (.Platform$OS.type == "windows") {
[17:45:17.991]                 old_names <- names(...future.oldEnvVars)
[17:45:17.991]                 envs <- base::Sys.getenv()
[17:45:17.991]                 names <- names(envs)
[17:45:17.991]                 common <- intersect(names, old_names)
[17:45:17.991]                 added <- setdiff(names, old_names)
[17:45:17.991]                 removed <- setdiff(old_names, names)
[17:45:17.991]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:17.991]                   envs[common]]
[17:45:17.991]                 NAMES <- toupper(changed)
[17:45:17.991]                 args <- list()
[17:45:17.991]                 for (kk in seq_along(NAMES)) {
[17:45:17.991]                   name <- changed[[kk]]
[17:45:17.991]                   NAME <- NAMES[[kk]]
[17:45:17.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.991]                     next
[17:45:17.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.991]                 }
[17:45:17.991]                 NAMES <- toupper(added)
[17:45:17.991]                 for (kk in seq_along(NAMES)) {
[17:45:17.991]                   name <- added[[kk]]
[17:45:17.991]                   NAME <- NAMES[[kk]]
[17:45:17.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.991]                     next
[17:45:17.991]                   args[[name]] <- ""
[17:45:17.991]                 }
[17:45:17.991]                 NAMES <- toupper(removed)
[17:45:17.991]                 for (kk in seq_along(NAMES)) {
[17:45:17.991]                   name <- removed[[kk]]
[17:45:17.991]                   NAME <- NAMES[[kk]]
[17:45:17.991]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:17.991]                     next
[17:45:17.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:17.991]                 }
[17:45:17.991]                 if (length(args) > 0) 
[17:45:17.991]                   base::do.call(base::Sys.setenv, args = args)
[17:45:17.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:17.991]             }
[17:45:17.991]             else {
[17:45:17.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:17.991]             }
[17:45:17.991]             {
[17:45:17.991]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:17.991]                   0L) {
[17:45:17.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:17.991]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:17.991]                   base::options(opts)
[17:45:17.991]                 }
[17:45:17.991]                 {
[17:45:17.991]                   {
[17:45:17.991]                     NULL
[17:45:17.991]                     RNGkind("Mersenne-Twister")
[17:45:17.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:17.991]                       inherits = FALSE)
[17:45:17.991]                   }
[17:45:17.991]                   options(future.plan = NULL)
[17:45:17.991]                   if (is.na(NA_character_)) 
[17:45:17.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:17.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:17.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:17.991]                     .init = FALSE)
[17:45:17.991]                 }
[17:45:17.991]             }
[17:45:17.991]         }
[17:45:17.991]     })
[17:45:17.991]     if (TRUE) {
[17:45:17.991]         base::sink(type = "output", split = FALSE)
[17:45:17.991]         if (TRUE) {
[17:45:17.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:17.991]         }
[17:45:17.991]         else {
[17:45:17.991]             ...future.result["stdout"] <- base::list(NULL)
[17:45:17.991]         }
[17:45:17.991]         base::close(...future.stdout)
[17:45:17.991]         ...future.stdout <- NULL
[17:45:17.991]     }
[17:45:17.991]     ...future.result$conditions <- ...future.conditions
[17:45:17.991]     ...future.result$finished <- base::Sys.time()
[17:45:17.991]     ...future.result
[17:45:17.991] }
[17:45:17.992] assign_globals() ...
[17:45:17.992] List of 5
[17:45:17.992]  $ ...future.FUN            :function (x, y)  
[17:45:17.992]  $ future.call.arguments    :List of 1
[17:45:17.992]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:17.992]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:17.992]  $ ...future.elements_ii    :List of 4
[17:45:17.992]   ..$ A: num 50
[17:45:17.992]   ..$ B: num 60
[17:45:17.992]   ..$ C: num 70
[17:45:17.992]   ..$ D: num 80
[17:45:17.992]  $ ...future.seeds_ii       : NULL
[17:45:17.992]  $ ...future.globals.maxSize: NULL
[17:45:17.992]  - attr(*, "where")=List of 5
[17:45:17.992]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:17.992]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:17.992]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:17.992]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:17.992]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:17.992]  - attr(*, "resolved")= logi FALSE
[17:45:17.992]  - attr(*, "total_size")= num 4264
[17:45:17.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:17.992]  - attr(*, "already-done")= logi TRUE
[17:45:17.998] - reassign environment for ‘...future.FUN’
[17:45:17.998] - copied ‘...future.FUN’ to environment
[17:45:17.998] - copied ‘future.call.arguments’ to environment
[17:45:17.998] - copied ‘...future.elements_ii’ to environment
[17:45:17.998] - copied ‘...future.seeds_ii’ to environment
[17:45:17.999] - copied ‘...future.globals.maxSize’ to environment
[17:45:17.999] assign_globals() ... done
[17:45:17.999] plan(): Setting new future strategy stack:
[17:45:17.999] List of future strategies:
[17:45:17.999] 1. sequential:
[17:45:17.999]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:17.999]    - tweaked: FALSE
[17:45:17.999]    - call: NULL
[17:45:17.999] plan(): nbrOfWorkers() = 1
[17:45:18.000] plan(): Setting new future strategy stack:
[17:45:18.000] List of future strategies:
[17:45:18.000] 1. sequential:
[17:45:18.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.000]    - tweaked: FALSE
[17:45:18.000]    - call: plan(strategy)
[17:45:18.001] plan(): nbrOfWorkers() = 1
[17:45:18.001] SequentialFuture started (and completed)
[17:45:18.001] - Launch lazy future ... done
[17:45:18.001] run() for ‘SequentialFuture’ ... done
[17:45:18.001] Created future:
[17:45:18.001] SequentialFuture:
[17:45:18.001] Label: ‘future_sapply-1’
[17:45:18.001] Expression:
[17:45:18.001] {
[17:45:18.001]     do.call(function(...) {
[17:45:18.001]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.001]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.001]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.001]             on.exit(options(oopts), add = TRUE)
[17:45:18.001]         }
[17:45:18.001]         {
[17:45:18.001]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.001]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.001]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.001]             })
[17:45:18.001]         }
[17:45:18.001]     }, args = future.call.arguments)
[17:45:18.001] }
[17:45:18.001] Lazy evaluation: FALSE
[17:45:18.001] Asynchronous evaluation: FALSE
[17:45:18.001] Local evaluation: TRUE
[17:45:18.001] Environment: R_GlobalEnv
[17:45:18.001] Capture standard output: TRUE
[17:45:18.001] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.001] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:18.001] Packages: <none>
[17:45:18.001] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.001] Resolved: TRUE
[17:45:18.001] Value: 1.34 KiB of class ‘list’
[17:45:18.001] Early signaling: FALSE
[17:45:18.001] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.001] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.002] Chunk #1 of 1 ... DONE
[17:45:18.002] Launching 1 futures (chunks) ... DONE
[17:45:18.002] Resolving 1 futures (chunks) ...
[17:45:18.003] resolve() on list ...
[17:45:18.003]  recursive: 0
[17:45:18.003]  length: 1
[17:45:18.003] 
[17:45:18.003] resolved() for ‘SequentialFuture’ ...
[17:45:18.003] - state: ‘finished’
[17:45:18.003] - run: TRUE
[17:45:18.003] - result: ‘FutureResult’
[17:45:18.003] resolved() for ‘SequentialFuture’ ... done
[17:45:18.003] Future #1
[17:45:18.003] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:18.004] - nx: 1
[17:45:18.004] - relay: TRUE
[17:45:18.004] - stdout: TRUE
[17:45:18.004] - signal: TRUE
[17:45:18.004] - resignal: FALSE
[17:45:18.004] - force: TRUE
[17:45:18.004] - relayed: [n=1] FALSE
[17:45:18.004] - queued futures: [n=1] FALSE
[17:45:18.004]  - until=1
[17:45:18.004]  - relaying element #1
[17:45:18.004] - relayed: [n=1] TRUE
[17:45:18.005] - queued futures: [n=1] TRUE
[17:45:18.005] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:18.005]  length: 0 (resolved future 1)
[17:45:18.005] Relaying remaining futures
[17:45:18.005] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.005] - nx: 1
[17:45:18.005] - relay: TRUE
[17:45:18.005] - stdout: TRUE
[17:45:18.005] - signal: TRUE
[17:45:18.005] - resignal: FALSE
[17:45:18.005] - force: TRUE
[17:45:18.005] - relayed: [n=1] TRUE
[17:45:18.006] - queued futures: [n=1] TRUE
 - flush all
[17:45:18.006] - relayed: [n=1] TRUE
[17:45:18.006] - queued futures: [n=1] TRUE
[17:45:18.006] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.006] resolve() on list ... DONE
[17:45:18.006]  - Number of value chunks collected: 1
[17:45:18.006] Resolving 1 futures (chunks) ... DONE
[17:45:18.006] Reducing values from 1 chunks ...
[17:45:18.006]  - Number of values collected after concatenation: 4
[17:45:18.006]  - Number of values expected: 4
[17:45:18.007] Reducing values from 1 chunks ... DONE
[17:45:18.007] future_lapply() ... DONE
[17:45:18.008] future_lapply() ...
[17:45:18.010] Number of chunks: 1
[17:45:18.010] getGlobalsAndPackagesXApply() ...
[17:45:18.010]  - future.globals: TRUE
[17:45:18.010] getGlobalsAndPackages() ...
[17:45:18.011] Searching for globals...
[17:45:18.014] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:45:18.014] Searching for globals ... DONE
[17:45:18.014] Resolving globals: FALSE
[17:45:18.015] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:45:18.015] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.016] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.016] - packages: [1] ‘future.apply’
[17:45:18.016] getGlobalsAndPackages() ... DONE
[17:45:18.016]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.016]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.016] Finding globals ... DONE
[17:45:18.016]  - use_args: TRUE
[17:45:18.016]  - Getting '...' globals ...
[17:45:18.017] resolve() on list ...
[17:45:18.017]  recursive: 0
[17:45:18.017]  length: 1
[17:45:18.017]  elements: ‘...’
[17:45:18.017]  length: 0 (resolved future 1)
[17:45:18.017] resolve() on list ... DONE
[17:45:18.017]    - '...' content: [n=1] ‘y’
[17:45:18.017] List of 1
[17:45:18.017]  $ ...:List of 1
[17:45:18.017]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:18.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.017]  - attr(*, "where")=List of 1
[17:45:18.017]   ..$ ...:<environment: 0x5561f56ed8b0> 
[17:45:18.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.017]  - attr(*, "resolved")= logi TRUE
[17:45:18.017]  - attr(*, "total_size")= num NA
[17:45:18.020]  - Getting '...' globals ... DONE
[17:45:18.020] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.020] List of 8
[17:45:18.020]  $ ...future.FUN:function (x, ...)  
[17:45:18.020]  $ x_FUN        :function (x, y)  
[17:45:18.020]  $ times        : int 15
[17:45:18.020]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.020]  $ stop_if_not  :function (...)  
[17:45:18.020]  $ dim          : int [1:2] 3 5
[17:45:18.020]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:18.020]  $ ...          :List of 1
[17:45:18.020]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:18.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.020]  - attr(*, "where")=List of 8
[17:45:18.020]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.020]   ..$ ...          :<environment: 0x5561f56ed8b0> 
[17:45:18.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.020]  - attr(*, "resolved")= logi FALSE
[17:45:18.020]  - attr(*, "total_size")= num 98600
[17:45:18.026] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.026] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.026] Number of futures (= number of chunks): 1
[17:45:18.026] Launching 1 futures (chunks) ...
[17:45:18.026] Chunk #1 of 1 ...
[17:45:18.027]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.027] getGlobalsAndPackages() ...
[17:45:18.027] Searching for globals...
[17:45:18.027] 
[17:45:18.027] Searching for globals ... DONE
[17:45:18.027] - globals: [0] <none>
[17:45:18.027] getGlobalsAndPackages() ... DONE
[17:45:18.027]    + additional globals found: [n=0] 
[17:45:18.027]    + additional namespaces needed: [n=0] 
[17:45:18.028]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.028]  - seeds: <none>
[17:45:18.028]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.028] getGlobalsAndPackages() ...
[17:45:18.028] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.028] Resolving globals: FALSE
[17:45:18.028] Tweak future expression to call with '...' arguments ...
[17:45:18.028] {
[17:45:18.028]     do.call(function(...) {
[17:45:18.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.028]             on.exit(options(oopts), add = TRUE)
[17:45:18.028]         }
[17:45:18.028]         {
[17:45:18.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.028]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.028]             })
[17:45:18.028]         }
[17:45:18.028]     }, args = future.call.arguments)
[17:45:18.028] }
[17:45:18.030] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.031] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.031] - packages: [1] ‘future.apply’
[17:45:18.031] getGlobalsAndPackages() ... DONE
[17:45:18.031] run() for ‘Future’ ...
[17:45:18.031] - state: ‘created’
[17:45:18.031] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:18.032] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.032] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:18.032]   - Field: ‘label’
[17:45:18.032]   - Field: ‘local’
[17:45:18.032]   - Field: ‘owner’
[17:45:18.032]   - Field: ‘envir’
[17:45:18.032]   - Field: ‘packages’
[17:45:18.032]   - Field: ‘gc’
[17:45:18.032]   - Field: ‘conditions’
[17:45:18.033]   - Field: ‘expr’
[17:45:18.033]   - Field: ‘uuid’
[17:45:18.033]   - Field: ‘seed’
[17:45:18.033]   - Field: ‘version’
[17:45:18.033]   - Field: ‘result’
[17:45:18.033]   - Field: ‘asynchronous’
[17:45:18.033]   - Field: ‘calls’
[17:45:18.033]   - Field: ‘globals’
[17:45:18.033]   - Field: ‘stdout’
[17:45:18.033]   - Field: ‘earlySignal’
[17:45:18.033]   - Field: ‘lazy’
[17:45:18.034]   - Field: ‘state’
[17:45:18.034] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:18.034] - Launch lazy future ...
[17:45:18.034] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.034] Packages needed by future strategies (n = 0): <none>
[17:45:18.035] {
[17:45:18.035]     {
[17:45:18.035]         {
[17:45:18.035]             ...future.startTime <- base::Sys.time()
[17:45:18.035]             {
[17:45:18.035]                 {
[17:45:18.035]                   {
[17:45:18.035]                     {
[17:45:18.035]                       base::local({
[17:45:18.035]                         has_future <- base::requireNamespace("future", 
[17:45:18.035]                           quietly = TRUE)
[17:45:18.035]                         if (has_future) {
[17:45:18.035]                           ns <- base::getNamespace("future")
[17:45:18.035]                           version <- ns[[".package"]][["version"]]
[17:45:18.035]                           if (is.null(version)) 
[17:45:18.035]                             version <- utils::packageVersion("future")
[17:45:18.035]                         }
[17:45:18.035]                         else {
[17:45:18.035]                           version <- NULL
[17:45:18.035]                         }
[17:45:18.035]                         if (!has_future || version < "1.8.0") {
[17:45:18.035]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.035]                             "", base::R.version$version.string), 
[17:45:18.035]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:18.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:18.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.035]                               "release", "version")], collapse = " "), 
[17:45:18.035]                             hostname = base::Sys.info()[["nodename"]])
[17:45:18.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.035]                             info)
[17:45:18.035]                           info <- base::paste(info, collapse = "; ")
[17:45:18.035]                           if (!has_future) {
[17:45:18.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.035]                               info)
[17:45:18.035]                           }
[17:45:18.035]                           else {
[17:45:18.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.035]                               info, version)
[17:45:18.035]                           }
[17:45:18.035]                           base::stop(msg)
[17:45:18.035]                         }
[17:45:18.035]                       })
[17:45:18.035]                     }
[17:45:18.035]                     base::local({
[17:45:18.035]                       for (pkg in "future.apply") {
[17:45:18.035]                         base::loadNamespace(pkg)
[17:45:18.035]                         base::library(pkg, character.only = TRUE)
[17:45:18.035]                       }
[17:45:18.035]                     })
[17:45:18.035]                   }
[17:45:18.035]                   ...future.strategy.old <- future::plan("list")
[17:45:18.035]                   options(future.plan = NULL)
[17:45:18.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.035]                 }
[17:45:18.035]                 ...future.workdir <- getwd()
[17:45:18.035]             }
[17:45:18.035]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.035]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.035]         }
[17:45:18.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:18.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.035]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.035]             base::names(...future.oldOptions))
[17:45:18.035]     }
[17:45:18.035]     if (FALSE) {
[17:45:18.035]     }
[17:45:18.035]     else {
[17:45:18.035]         if (TRUE) {
[17:45:18.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.035]                 open = "w")
[17:45:18.035]         }
[17:45:18.035]         else {
[17:45:18.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.035]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.035]         }
[17:45:18.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.035]             base::sink(type = "output", split = FALSE)
[17:45:18.035]             base::close(...future.stdout)
[17:45:18.035]         }, add = TRUE)
[17:45:18.035]     }
[17:45:18.035]     ...future.frame <- base::sys.nframe()
[17:45:18.035]     ...future.conditions <- base::list()
[17:45:18.035]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.035]     if (FALSE) {
[17:45:18.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.035]     }
[17:45:18.035]     ...future.result <- base::tryCatch({
[17:45:18.035]         base::withCallingHandlers({
[17:45:18.035]             ...future.value <- base::withVisible(base::local({
[17:45:18.035]                 do.call(function(...) {
[17:45:18.035]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.035]                   if (!identical(...future.globals.maxSize.org, 
[17:45:18.035]                     ...future.globals.maxSize)) {
[17:45:18.035]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.035]                     on.exit(options(oopts), add = TRUE)
[17:45:18.035]                   }
[17:45:18.035]                   {
[17:45:18.035]                     lapply(seq_along(...future.elements_ii), 
[17:45:18.035]                       FUN = function(jj) {
[17:45:18.035]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.035]                         ...future.FUN(...future.X_jj, ...)
[17:45:18.035]                       })
[17:45:18.035]                   }
[17:45:18.035]                 }, args = future.call.arguments)
[17:45:18.035]             }))
[17:45:18.035]             future::FutureResult(value = ...future.value$value, 
[17:45:18.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.035]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.035]                     ...future.globalenv.names))
[17:45:18.035]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.035]         }, condition = base::local({
[17:45:18.035]             c <- base::c
[17:45:18.035]             inherits <- base::inherits
[17:45:18.035]             invokeRestart <- base::invokeRestart
[17:45:18.035]             length <- base::length
[17:45:18.035]             list <- base::list
[17:45:18.035]             seq.int <- base::seq.int
[17:45:18.035]             signalCondition <- base::signalCondition
[17:45:18.035]             sys.calls <- base::sys.calls
[17:45:18.035]             `[[` <- base::`[[`
[17:45:18.035]             `+` <- base::`+`
[17:45:18.035]             `<<-` <- base::`<<-`
[17:45:18.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.035]                   3L)]
[17:45:18.035]             }
[17:45:18.035]             function(cond) {
[17:45:18.035]                 is_error <- inherits(cond, "error")
[17:45:18.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.035]                   NULL)
[17:45:18.035]                 if (is_error) {
[17:45:18.035]                   sessionInformation <- function() {
[17:45:18.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.035]                       search = base::search(), system = base::Sys.info())
[17:45:18.035]                   }
[17:45:18.035]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.035]                     cond$call), session = sessionInformation(), 
[17:45:18.035]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.035]                   signalCondition(cond)
[17:45:18.035]                 }
[17:45:18.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.035]                 "immediateCondition"))) {
[17:45:18.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.035]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.035]                   if (TRUE && !signal) {
[17:45:18.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.035]                     {
[17:45:18.035]                       inherits <- base::inherits
[17:45:18.035]                       invokeRestart <- base::invokeRestart
[17:45:18.035]                       is.null <- base::is.null
[17:45:18.035]                       muffled <- FALSE
[17:45:18.035]                       if (inherits(cond, "message")) {
[17:45:18.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.035]                         if (muffled) 
[17:45:18.035]                           invokeRestart("muffleMessage")
[17:45:18.035]                       }
[17:45:18.035]                       else if (inherits(cond, "warning")) {
[17:45:18.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.035]                         if (muffled) 
[17:45:18.035]                           invokeRestart("muffleWarning")
[17:45:18.035]                       }
[17:45:18.035]                       else if (inherits(cond, "condition")) {
[17:45:18.035]                         if (!is.null(pattern)) {
[17:45:18.035]                           computeRestarts <- base::computeRestarts
[17:45:18.035]                           grepl <- base::grepl
[17:45:18.035]                           restarts <- computeRestarts(cond)
[17:45:18.035]                           for (restart in restarts) {
[17:45:18.035]                             name <- restart$name
[17:45:18.035]                             if (is.null(name)) 
[17:45:18.035]                               next
[17:45:18.035]                             if (!grepl(pattern, name)) 
[17:45:18.035]                               next
[17:45:18.035]                             invokeRestart(restart)
[17:45:18.035]                             muffled <- TRUE
[17:45:18.035]                             break
[17:45:18.035]                           }
[17:45:18.035]                         }
[17:45:18.035]                       }
[17:45:18.035]                       invisible(muffled)
[17:45:18.035]                     }
[17:45:18.035]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.035]                   }
[17:45:18.035]                 }
[17:45:18.035]                 else {
[17:45:18.035]                   if (TRUE) {
[17:45:18.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.035]                     {
[17:45:18.035]                       inherits <- base::inherits
[17:45:18.035]                       invokeRestart <- base::invokeRestart
[17:45:18.035]                       is.null <- base::is.null
[17:45:18.035]                       muffled <- FALSE
[17:45:18.035]                       if (inherits(cond, "message")) {
[17:45:18.035]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.035]                         if (muffled) 
[17:45:18.035]                           invokeRestart("muffleMessage")
[17:45:18.035]                       }
[17:45:18.035]                       else if (inherits(cond, "warning")) {
[17:45:18.035]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.035]                         if (muffled) 
[17:45:18.035]                           invokeRestart("muffleWarning")
[17:45:18.035]                       }
[17:45:18.035]                       else if (inherits(cond, "condition")) {
[17:45:18.035]                         if (!is.null(pattern)) {
[17:45:18.035]                           computeRestarts <- base::computeRestarts
[17:45:18.035]                           grepl <- base::grepl
[17:45:18.035]                           restarts <- computeRestarts(cond)
[17:45:18.035]                           for (restart in restarts) {
[17:45:18.035]                             name <- restart$name
[17:45:18.035]                             if (is.null(name)) 
[17:45:18.035]                               next
[17:45:18.035]                             if (!grepl(pattern, name)) 
[17:45:18.035]                               next
[17:45:18.035]                             invokeRestart(restart)
[17:45:18.035]                             muffled <- TRUE
[17:45:18.035]                             break
[17:45:18.035]                           }
[17:45:18.035]                         }
[17:45:18.035]                       }
[17:45:18.035]                       invisible(muffled)
[17:45:18.035]                     }
[17:45:18.035]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.035]                   }
[17:45:18.035]                 }
[17:45:18.035]             }
[17:45:18.035]         }))
[17:45:18.035]     }, error = function(ex) {
[17:45:18.035]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.035]                 ...future.rng), started = ...future.startTime, 
[17:45:18.035]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.035]             version = "1.8"), class = "FutureResult")
[17:45:18.035]     }, finally = {
[17:45:18.035]         if (!identical(...future.workdir, getwd())) 
[17:45:18.035]             setwd(...future.workdir)
[17:45:18.035]         {
[17:45:18.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.035]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.035]             }
[17:45:18.035]             base::options(...future.oldOptions)
[17:45:18.035]             if (.Platform$OS.type == "windows") {
[17:45:18.035]                 old_names <- names(...future.oldEnvVars)
[17:45:18.035]                 envs <- base::Sys.getenv()
[17:45:18.035]                 names <- names(envs)
[17:45:18.035]                 common <- intersect(names, old_names)
[17:45:18.035]                 added <- setdiff(names, old_names)
[17:45:18.035]                 removed <- setdiff(old_names, names)
[17:45:18.035]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.035]                   envs[common]]
[17:45:18.035]                 NAMES <- toupper(changed)
[17:45:18.035]                 args <- list()
[17:45:18.035]                 for (kk in seq_along(NAMES)) {
[17:45:18.035]                   name <- changed[[kk]]
[17:45:18.035]                   NAME <- NAMES[[kk]]
[17:45:18.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.035]                     next
[17:45:18.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.035]                 }
[17:45:18.035]                 NAMES <- toupper(added)
[17:45:18.035]                 for (kk in seq_along(NAMES)) {
[17:45:18.035]                   name <- added[[kk]]
[17:45:18.035]                   NAME <- NAMES[[kk]]
[17:45:18.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.035]                     next
[17:45:18.035]                   args[[name]] <- ""
[17:45:18.035]                 }
[17:45:18.035]                 NAMES <- toupper(removed)
[17:45:18.035]                 for (kk in seq_along(NAMES)) {
[17:45:18.035]                   name <- removed[[kk]]
[17:45:18.035]                   NAME <- NAMES[[kk]]
[17:45:18.035]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.035]                     next
[17:45:18.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.035]                 }
[17:45:18.035]                 if (length(args) > 0) 
[17:45:18.035]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.035]             }
[17:45:18.035]             else {
[17:45:18.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.035]             }
[17:45:18.035]             {
[17:45:18.035]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.035]                   0L) {
[17:45:18.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.035]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.035]                   base::options(opts)
[17:45:18.035]                 }
[17:45:18.035]                 {
[17:45:18.035]                   {
[17:45:18.035]                     NULL
[17:45:18.035]                     RNGkind("Mersenne-Twister")
[17:45:18.035]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:18.035]                       inherits = FALSE)
[17:45:18.035]                   }
[17:45:18.035]                   options(future.plan = NULL)
[17:45:18.035]                   if (is.na(NA_character_)) 
[17:45:18.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.035]                     .init = FALSE)
[17:45:18.035]                 }
[17:45:18.035]             }
[17:45:18.035]         }
[17:45:18.035]     })
[17:45:18.035]     if (TRUE) {
[17:45:18.035]         base::sink(type = "output", split = FALSE)
[17:45:18.035]         if (TRUE) {
[17:45:18.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.035]         }
[17:45:18.035]         else {
[17:45:18.035]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.035]         }
[17:45:18.035]         base::close(...future.stdout)
[17:45:18.035]         ...future.stdout <- NULL
[17:45:18.035]     }
[17:45:18.035]     ...future.result$conditions <- ...future.conditions
[17:45:18.035]     ...future.result$finished <- base::Sys.time()
[17:45:18.035]     ...future.result
[17:45:18.035] }
[17:45:18.036] assign_globals() ...
[17:45:18.036] List of 11
[17:45:18.036]  $ ...future.FUN            :function (x, ...)  
[17:45:18.036]  $ x_FUN                    :function (x, y)  
[17:45:18.036]  $ times                    : int 15
[17:45:18.036]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.036]  $ stop_if_not              :function (...)  
[17:45:18.036]  $ dim                      : int [1:2] 3 5
[17:45:18.036]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.036]  $ future.call.arguments    :List of 1
[17:45:18.036]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:18.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.036]  $ ...future.elements_ii    :List of 4
[17:45:18.036]   ..$ A: num 50
[17:45:18.036]   ..$ B: num 60
[17:45:18.036]   ..$ C: num 70
[17:45:18.036]   ..$ D: num 80
[17:45:18.036]  $ ...future.seeds_ii       : NULL
[17:45:18.036]  $ ...future.globals.maxSize: NULL
[17:45:18.036]  - attr(*, "where")=List of 11
[17:45:18.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.036]  - attr(*, "resolved")= logi FALSE
[17:45:18.036]  - attr(*, "total_size")= num 98600
[17:45:18.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.036]  - attr(*, "already-done")= logi TRUE
[17:45:18.045] - copied ‘...future.FUN’ to environment
[17:45:18.045] - reassign environment for ‘x_FUN’
[17:45:18.045] - copied ‘x_FUN’ to environment
[17:45:18.045] - copied ‘times’ to environment
[17:45:18.045] - copied ‘stopf’ to environment
[17:45:18.045] - copied ‘stop_if_not’ to environment
[17:45:18.045] - copied ‘dim’ to environment
[17:45:18.046] - copied ‘valid_types’ to environment
[17:45:18.046] - copied ‘future.call.arguments’ to environment
[17:45:18.046] - copied ‘...future.elements_ii’ to environment
[17:45:18.046] - copied ‘...future.seeds_ii’ to environment
[17:45:18.046] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.046] assign_globals() ... done
[17:45:18.046] plan(): Setting new future strategy stack:
[17:45:18.046] List of future strategies:
[17:45:18.046] 1. sequential:
[17:45:18.046]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.046]    - tweaked: FALSE
[17:45:18.046]    - call: NULL
[17:45:18.047] plan(): nbrOfWorkers() = 1
[17:45:18.048] plan(): Setting new future strategy stack:
[17:45:18.048] List of future strategies:
[17:45:18.048] 1. sequential:
[17:45:18.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.048]    - tweaked: FALSE
[17:45:18.048]    - call: plan(strategy)
[17:45:18.048] plan(): nbrOfWorkers() = 1
[17:45:18.048] SequentialFuture started (and completed)
[17:45:18.049] - Launch lazy future ... done
[17:45:18.049] run() for ‘SequentialFuture’ ... done
[17:45:18.049] Created future:
[17:45:18.049] SequentialFuture:
[17:45:18.049] Label: ‘future_vapply-1’
[17:45:18.049] Expression:
[17:45:18.049] {
[17:45:18.049]     do.call(function(...) {
[17:45:18.049]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.049]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.049]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.049]             on.exit(options(oopts), add = TRUE)
[17:45:18.049]         }
[17:45:18.049]         {
[17:45:18.049]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.049]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.049]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.049]             })
[17:45:18.049]         }
[17:45:18.049]     }, args = future.call.arguments)
[17:45:18.049] }
[17:45:18.049] Lazy evaluation: FALSE
[17:45:18.049] Asynchronous evaluation: FALSE
[17:45:18.049] Local evaluation: TRUE
[17:45:18.049] Environment: R_GlobalEnv
[17:45:18.049] Capture standard output: TRUE
[17:45:18.049] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.049] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.049] Packages: 1 packages (‘future.apply’)
[17:45:18.049] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.049] Resolved: TRUE
[17:45:18.049] Value: 1.34 KiB of class ‘list’
[17:45:18.049] Early signaling: FALSE
[17:45:18.049] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.049] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.050] Chunk #1 of 1 ... DONE
[17:45:18.050] Launching 1 futures (chunks) ... DONE
[17:45:18.050] Resolving 1 futures (chunks) ...
[17:45:18.050] resolve() on list ...
[17:45:18.050]  recursive: 0
[17:45:18.051]  length: 1
[17:45:18.051] 
[17:45:18.051] resolved() for ‘SequentialFuture’ ...
[17:45:18.051] - state: ‘finished’
[17:45:18.051] - run: TRUE
[17:45:18.051] - result: ‘FutureResult’
[17:45:18.051] resolved() for ‘SequentialFuture’ ... done
[17:45:18.051] Future #1
[17:45:18.051] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:18.051] - nx: 1
[17:45:18.052] - relay: TRUE
[17:45:18.052] - stdout: TRUE
[17:45:18.052] - signal: TRUE
[17:45:18.052] - resignal: FALSE
[17:45:18.052] - force: TRUE
[17:45:18.052] - relayed: [n=1] FALSE
[17:45:18.052] - queued futures: [n=1] FALSE
[17:45:18.052]  - until=1
[17:45:18.052]  - relaying element #1
[17:45:18.052] - relayed: [n=1] TRUE
[17:45:18.053] - queued futures: [n=1] TRUE
[17:45:18.053] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:18.053]  length: 0 (resolved future 1)
[17:45:18.053] Relaying remaining futures
[17:45:18.053] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.053] - nx: 1
[17:45:18.055] - relay: TRUE
[17:45:18.055] - stdout: TRUE
[17:45:18.055] - signal: TRUE
[17:45:18.055] - resignal: FALSE
[17:45:18.055] - force: TRUE
[17:45:18.055] - relayed: [n=1] TRUE
[17:45:18.055] - queued futures: [n=1] TRUE
 - flush all
[17:45:18.055] - relayed: [n=1] TRUE
[17:45:18.055] - queued futures: [n=1] TRUE
[17:45:18.056] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.056] resolve() on list ... DONE
[17:45:18.056]  - Number of value chunks collected: 1
[17:45:18.056] Resolving 1 futures (chunks) ... DONE
[17:45:18.056] Reducing values from 1 chunks ...
[17:45:18.056]  - Number of values collected after concatenation: 4
[17:45:18.056]  - Number of values expected: 4
[17:45:18.056] Reducing values from 1 chunks ... DONE
[17:45:18.056] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:45:18.058] future_lapply() ...
[17:45:18.060] Number of chunks: 1
[17:45:18.060] getGlobalsAndPackagesXApply() ...
[17:45:18.060]  - future.globals: TRUE
[17:45:18.060] getGlobalsAndPackages() ...
[17:45:18.060] Searching for globals...
[17:45:18.063] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:18.063] Searching for globals ... DONE
[17:45:18.064] Resolving globals: FALSE
[17:45:18.064] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:45:18.065] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.065] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.065] - packages: [1] ‘future.apply’
[17:45:18.065] getGlobalsAndPackages() ... DONE
[17:45:18.065]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.065]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.065] Finding globals ... DONE
[17:45:18.066]  - use_args: TRUE
[17:45:18.066]  - Getting '...' globals ...
[17:45:18.066] resolve() on list ...
[17:45:18.066]  recursive: 0
[17:45:18.066]  length: 1
[17:45:18.066]  elements: ‘...’
[17:45:18.066]  length: 0 (resolved future 1)
[17:45:18.066] resolve() on list ... DONE
[17:45:18.067]    - '...' content: [n=0] 
[17:45:18.067] List of 1
[17:45:18.067]  $ ...: list()
[17:45:18.067]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.067]  - attr(*, "where")=List of 1
[17:45:18.067]   ..$ ...:<environment: 0x5561f3a87298> 
[17:45:18.067]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.067]  - attr(*, "resolved")= logi TRUE
[17:45:18.067]  - attr(*, "total_size")= num NA
[17:45:18.069]  - Getting '...' globals ... DONE
[17:45:18.069] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.069] List of 8
[17:45:18.069]  $ ...future.FUN:function (x, ...)  
[17:45:18.069]  $ x_FUN        :function (x)  
[17:45:18.069]  $ times        : int 1
[17:45:18.069]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.069]  $ stop_if_not  :function (...)  
[17:45:18.069]  $ dim          : NULL
[17:45:18.069]  $ valid_types  : chr "logical"
[17:45:18.069]  $ ...          : list()
[17:45:18.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.069]  - attr(*, "where")=List of 8
[17:45:18.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.069]   ..$ ...          :<environment: 0x5561f3a87298> 
[17:45:18.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.069]  - attr(*, "resolved")= logi FALSE
[17:45:18.069]  - attr(*, "total_size")= num 94200
[17:45:18.074] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.075] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.075] Number of futures (= number of chunks): 1
[17:45:18.075] Launching 1 futures (chunks) ...
[17:45:18.075] Chunk #1 of 1 ...
[17:45:18.075]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.075] getGlobalsAndPackages() ...
[17:45:18.075] Searching for globals...
[17:45:18.076] 
[17:45:18.077] Searching for globals ... DONE
[17:45:18.077] - globals: [0] <none>
[17:45:18.077] getGlobalsAndPackages() ... DONE
[17:45:18.077]    + additional globals found: [n=0] 
[17:45:18.078]    + additional namespaces needed: [n=0] 
[17:45:18.078]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.078]  - seeds: <none>
[17:45:18.078]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.078] getGlobalsAndPackages() ...
[17:45:18.078] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.078] Resolving globals: FALSE
[17:45:18.078] Tweak future expression to call with '...' arguments ...
[17:45:18.078] {
[17:45:18.078]     do.call(function(...) {
[17:45:18.078]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.078]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.078]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.078]             on.exit(options(oopts), add = TRUE)
[17:45:18.078]         }
[17:45:18.078]         {
[17:45:18.078]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.078]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.078]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.078]             })
[17:45:18.078]         }
[17:45:18.078]     }, args = future.call.arguments)
[17:45:18.078] }
[17:45:18.079] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.079] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.079] - packages: [1] ‘future.apply’
[17:45:18.080] getGlobalsAndPackages() ... DONE
[17:45:18.080] run() for ‘Future’ ...
[17:45:18.080] - state: ‘created’
[17:45:18.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:18.080] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:18.081]   - Field: ‘label’
[17:45:18.081]   - Field: ‘local’
[17:45:18.081]   - Field: ‘owner’
[17:45:18.081]   - Field: ‘envir’
[17:45:18.081]   - Field: ‘packages’
[17:45:18.081]   - Field: ‘gc’
[17:45:18.081]   - Field: ‘conditions’
[17:45:18.081]   - Field: ‘expr’
[17:45:18.081]   - Field: ‘uuid’
[17:45:18.081]   - Field: ‘seed’
[17:45:18.081]   - Field: ‘version’
[17:45:18.082]   - Field: ‘result’
[17:45:18.082]   - Field: ‘asynchronous’
[17:45:18.082]   - Field: ‘calls’
[17:45:18.082]   - Field: ‘globals’
[17:45:18.082]   - Field: ‘stdout’
[17:45:18.082]   - Field: ‘earlySignal’
[17:45:18.082]   - Field: ‘lazy’
[17:45:18.082]   - Field: ‘state’
[17:45:18.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:18.082] - Launch lazy future ...
[17:45:18.083] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.083] Packages needed by future strategies (n = 0): <none>
[17:45:18.083] {
[17:45:18.083]     {
[17:45:18.083]         {
[17:45:18.083]             ...future.startTime <- base::Sys.time()
[17:45:18.083]             {
[17:45:18.083]                 {
[17:45:18.083]                   {
[17:45:18.083]                     {
[17:45:18.083]                       base::local({
[17:45:18.083]                         has_future <- base::requireNamespace("future", 
[17:45:18.083]                           quietly = TRUE)
[17:45:18.083]                         if (has_future) {
[17:45:18.083]                           ns <- base::getNamespace("future")
[17:45:18.083]                           version <- ns[[".package"]][["version"]]
[17:45:18.083]                           if (is.null(version)) 
[17:45:18.083]                             version <- utils::packageVersion("future")
[17:45:18.083]                         }
[17:45:18.083]                         else {
[17:45:18.083]                           version <- NULL
[17:45:18.083]                         }
[17:45:18.083]                         if (!has_future || version < "1.8.0") {
[17:45:18.083]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.083]                             "", base::R.version$version.string), 
[17:45:18.083]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:18.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:18.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.083]                               "release", "version")], collapse = " "), 
[17:45:18.083]                             hostname = base::Sys.info()[["nodename"]])
[17:45:18.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.083]                             info)
[17:45:18.083]                           info <- base::paste(info, collapse = "; ")
[17:45:18.083]                           if (!has_future) {
[17:45:18.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.083]                               info)
[17:45:18.083]                           }
[17:45:18.083]                           else {
[17:45:18.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.083]                               info, version)
[17:45:18.083]                           }
[17:45:18.083]                           base::stop(msg)
[17:45:18.083]                         }
[17:45:18.083]                       })
[17:45:18.083]                     }
[17:45:18.083]                     base::local({
[17:45:18.083]                       for (pkg in "future.apply") {
[17:45:18.083]                         base::loadNamespace(pkg)
[17:45:18.083]                         base::library(pkg, character.only = TRUE)
[17:45:18.083]                       }
[17:45:18.083]                     })
[17:45:18.083]                   }
[17:45:18.083]                   ...future.strategy.old <- future::plan("list")
[17:45:18.083]                   options(future.plan = NULL)
[17:45:18.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.083]                 }
[17:45:18.083]                 ...future.workdir <- getwd()
[17:45:18.083]             }
[17:45:18.083]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.083]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.083]         }
[17:45:18.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:18.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.083]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.083]             base::names(...future.oldOptions))
[17:45:18.083]     }
[17:45:18.083]     if (FALSE) {
[17:45:18.083]     }
[17:45:18.083]     else {
[17:45:18.083]         if (TRUE) {
[17:45:18.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.083]                 open = "w")
[17:45:18.083]         }
[17:45:18.083]         else {
[17:45:18.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.083]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.083]         }
[17:45:18.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.083]             base::sink(type = "output", split = FALSE)
[17:45:18.083]             base::close(...future.stdout)
[17:45:18.083]         }, add = TRUE)
[17:45:18.083]     }
[17:45:18.083]     ...future.frame <- base::sys.nframe()
[17:45:18.083]     ...future.conditions <- base::list()
[17:45:18.083]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.083]     if (FALSE) {
[17:45:18.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.083]     }
[17:45:18.083]     ...future.result <- base::tryCatch({
[17:45:18.083]         base::withCallingHandlers({
[17:45:18.083]             ...future.value <- base::withVisible(base::local({
[17:45:18.083]                 do.call(function(...) {
[17:45:18.083]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.083]                   if (!identical(...future.globals.maxSize.org, 
[17:45:18.083]                     ...future.globals.maxSize)) {
[17:45:18.083]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.083]                     on.exit(options(oopts), add = TRUE)
[17:45:18.083]                   }
[17:45:18.083]                   {
[17:45:18.083]                     lapply(seq_along(...future.elements_ii), 
[17:45:18.083]                       FUN = function(jj) {
[17:45:18.083]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.083]                         ...future.FUN(...future.X_jj, ...)
[17:45:18.083]                       })
[17:45:18.083]                   }
[17:45:18.083]                 }, args = future.call.arguments)
[17:45:18.083]             }))
[17:45:18.083]             future::FutureResult(value = ...future.value$value, 
[17:45:18.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.083]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.083]                     ...future.globalenv.names))
[17:45:18.083]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.083]         }, condition = base::local({
[17:45:18.083]             c <- base::c
[17:45:18.083]             inherits <- base::inherits
[17:45:18.083]             invokeRestart <- base::invokeRestart
[17:45:18.083]             length <- base::length
[17:45:18.083]             list <- base::list
[17:45:18.083]             seq.int <- base::seq.int
[17:45:18.083]             signalCondition <- base::signalCondition
[17:45:18.083]             sys.calls <- base::sys.calls
[17:45:18.083]             `[[` <- base::`[[`
[17:45:18.083]             `+` <- base::`+`
[17:45:18.083]             `<<-` <- base::`<<-`
[17:45:18.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.083]                   3L)]
[17:45:18.083]             }
[17:45:18.083]             function(cond) {
[17:45:18.083]                 is_error <- inherits(cond, "error")
[17:45:18.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.083]                   NULL)
[17:45:18.083]                 if (is_error) {
[17:45:18.083]                   sessionInformation <- function() {
[17:45:18.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.083]                       search = base::search(), system = base::Sys.info())
[17:45:18.083]                   }
[17:45:18.083]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.083]                     cond$call), session = sessionInformation(), 
[17:45:18.083]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.083]                   signalCondition(cond)
[17:45:18.083]                 }
[17:45:18.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.083]                 "immediateCondition"))) {
[17:45:18.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.083]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.083]                   if (TRUE && !signal) {
[17:45:18.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.083]                     {
[17:45:18.083]                       inherits <- base::inherits
[17:45:18.083]                       invokeRestart <- base::invokeRestart
[17:45:18.083]                       is.null <- base::is.null
[17:45:18.083]                       muffled <- FALSE
[17:45:18.083]                       if (inherits(cond, "message")) {
[17:45:18.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.083]                         if (muffled) 
[17:45:18.083]                           invokeRestart("muffleMessage")
[17:45:18.083]                       }
[17:45:18.083]                       else if (inherits(cond, "warning")) {
[17:45:18.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.083]                         if (muffled) 
[17:45:18.083]                           invokeRestart("muffleWarning")
[17:45:18.083]                       }
[17:45:18.083]                       else if (inherits(cond, "condition")) {
[17:45:18.083]                         if (!is.null(pattern)) {
[17:45:18.083]                           computeRestarts <- base::computeRestarts
[17:45:18.083]                           grepl <- base::grepl
[17:45:18.083]                           restarts <- computeRestarts(cond)
[17:45:18.083]                           for (restart in restarts) {
[17:45:18.083]                             name <- restart$name
[17:45:18.083]                             if (is.null(name)) 
[17:45:18.083]                               next
[17:45:18.083]                             if (!grepl(pattern, name)) 
[17:45:18.083]                               next
[17:45:18.083]                             invokeRestart(restart)
[17:45:18.083]                             muffled <- TRUE
[17:45:18.083]                             break
[17:45:18.083]                           }
[17:45:18.083]                         }
[17:45:18.083]                       }
[17:45:18.083]                       invisible(muffled)
[17:45:18.083]                     }
[17:45:18.083]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.083]                   }
[17:45:18.083]                 }
[17:45:18.083]                 else {
[17:45:18.083]                   if (TRUE) {
[17:45:18.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.083]                     {
[17:45:18.083]                       inherits <- base::inherits
[17:45:18.083]                       invokeRestart <- base::invokeRestart
[17:45:18.083]                       is.null <- base::is.null
[17:45:18.083]                       muffled <- FALSE
[17:45:18.083]                       if (inherits(cond, "message")) {
[17:45:18.083]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.083]                         if (muffled) 
[17:45:18.083]                           invokeRestart("muffleMessage")
[17:45:18.083]                       }
[17:45:18.083]                       else if (inherits(cond, "warning")) {
[17:45:18.083]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.083]                         if (muffled) 
[17:45:18.083]                           invokeRestart("muffleWarning")
[17:45:18.083]                       }
[17:45:18.083]                       else if (inherits(cond, "condition")) {
[17:45:18.083]                         if (!is.null(pattern)) {
[17:45:18.083]                           computeRestarts <- base::computeRestarts
[17:45:18.083]                           grepl <- base::grepl
[17:45:18.083]                           restarts <- computeRestarts(cond)
[17:45:18.083]                           for (restart in restarts) {
[17:45:18.083]                             name <- restart$name
[17:45:18.083]                             if (is.null(name)) 
[17:45:18.083]                               next
[17:45:18.083]                             if (!grepl(pattern, name)) 
[17:45:18.083]                               next
[17:45:18.083]                             invokeRestart(restart)
[17:45:18.083]                             muffled <- TRUE
[17:45:18.083]                             break
[17:45:18.083]                           }
[17:45:18.083]                         }
[17:45:18.083]                       }
[17:45:18.083]                       invisible(muffled)
[17:45:18.083]                     }
[17:45:18.083]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.083]                   }
[17:45:18.083]                 }
[17:45:18.083]             }
[17:45:18.083]         }))
[17:45:18.083]     }, error = function(ex) {
[17:45:18.083]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.083]                 ...future.rng), started = ...future.startTime, 
[17:45:18.083]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.083]             version = "1.8"), class = "FutureResult")
[17:45:18.083]     }, finally = {
[17:45:18.083]         if (!identical(...future.workdir, getwd())) 
[17:45:18.083]             setwd(...future.workdir)
[17:45:18.083]         {
[17:45:18.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.083]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.083]             }
[17:45:18.083]             base::options(...future.oldOptions)
[17:45:18.083]             if (.Platform$OS.type == "windows") {
[17:45:18.083]                 old_names <- names(...future.oldEnvVars)
[17:45:18.083]                 envs <- base::Sys.getenv()
[17:45:18.083]                 names <- names(envs)
[17:45:18.083]                 common <- intersect(names, old_names)
[17:45:18.083]                 added <- setdiff(names, old_names)
[17:45:18.083]                 removed <- setdiff(old_names, names)
[17:45:18.083]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.083]                   envs[common]]
[17:45:18.083]                 NAMES <- toupper(changed)
[17:45:18.083]                 args <- list()
[17:45:18.083]                 for (kk in seq_along(NAMES)) {
[17:45:18.083]                   name <- changed[[kk]]
[17:45:18.083]                   NAME <- NAMES[[kk]]
[17:45:18.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.083]                     next
[17:45:18.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.083]                 }
[17:45:18.083]                 NAMES <- toupper(added)
[17:45:18.083]                 for (kk in seq_along(NAMES)) {
[17:45:18.083]                   name <- added[[kk]]
[17:45:18.083]                   NAME <- NAMES[[kk]]
[17:45:18.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.083]                     next
[17:45:18.083]                   args[[name]] <- ""
[17:45:18.083]                 }
[17:45:18.083]                 NAMES <- toupper(removed)
[17:45:18.083]                 for (kk in seq_along(NAMES)) {
[17:45:18.083]                   name <- removed[[kk]]
[17:45:18.083]                   NAME <- NAMES[[kk]]
[17:45:18.083]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.083]                     next
[17:45:18.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.083]                 }
[17:45:18.083]                 if (length(args) > 0) 
[17:45:18.083]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.083]             }
[17:45:18.083]             else {
[17:45:18.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.083]             }
[17:45:18.083]             {
[17:45:18.083]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.083]                   0L) {
[17:45:18.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.083]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.083]                   base::options(opts)
[17:45:18.083]                 }
[17:45:18.083]                 {
[17:45:18.083]                   {
[17:45:18.083]                     NULL
[17:45:18.083]                     RNGkind("Mersenne-Twister")
[17:45:18.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:18.083]                       inherits = FALSE)
[17:45:18.083]                   }
[17:45:18.083]                   options(future.plan = NULL)
[17:45:18.083]                   if (is.na(NA_character_)) 
[17:45:18.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.083]                     .init = FALSE)
[17:45:18.083]                 }
[17:45:18.083]             }
[17:45:18.083]         }
[17:45:18.083]     })
[17:45:18.083]     if (TRUE) {
[17:45:18.083]         base::sink(type = "output", split = FALSE)
[17:45:18.083]         if (TRUE) {
[17:45:18.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.083]         }
[17:45:18.083]         else {
[17:45:18.083]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.083]         }
[17:45:18.083]         base::close(...future.stdout)
[17:45:18.083]         ...future.stdout <- NULL
[17:45:18.083]     }
[17:45:18.083]     ...future.result$conditions <- ...future.conditions
[17:45:18.083]     ...future.result$finished <- base::Sys.time()
[17:45:18.083]     ...future.result
[17:45:18.083] }
[17:45:18.085] assign_globals() ...
[17:45:18.085] List of 11
[17:45:18.085]  $ ...future.FUN            :function (x, ...)  
[17:45:18.085]  $ x_FUN                    :function (x)  
[17:45:18.085]  $ times                    : int 1
[17:45:18.085]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.085]  $ stop_if_not              :function (...)  
[17:45:18.085]  $ dim                      : NULL
[17:45:18.085]  $ valid_types              : chr "logical"
[17:45:18.085]  $ future.call.arguments    : list()
[17:45:18.085]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.085]  $ ...future.elements_ii    :List of 11
[17:45:18.085]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:45:18.085]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:45:18.085]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:45:18.085]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:45:18.085]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:45:18.085]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:45:18.085]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:45:18.085]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:45:18.085]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:45:18.085]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:45:18.085]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:45:18.085]  $ ...future.seeds_ii       : NULL
[17:45:18.085]  $ ...future.globals.maxSize: NULL
[17:45:18.085]  - attr(*, "where")=List of 11
[17:45:18.085]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.085]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.085]  - attr(*, "resolved")= logi FALSE
[17:45:18.085]  - attr(*, "total_size")= num 94200
[17:45:18.085]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.085]  - attr(*, "already-done")= logi TRUE
[17:45:18.095] - copied ‘...future.FUN’ to environment
[17:45:18.095] - copied ‘x_FUN’ to environment
[17:45:18.095] - copied ‘times’ to environment
[17:45:18.095] - copied ‘stopf’ to environment
[17:45:18.095] - copied ‘stop_if_not’ to environment
[17:45:18.095] - copied ‘dim’ to environment
[17:45:18.096] - copied ‘valid_types’ to environment
[17:45:18.096] - copied ‘future.call.arguments’ to environment
[17:45:18.096] - copied ‘...future.elements_ii’ to environment
[17:45:18.096] - copied ‘...future.seeds_ii’ to environment
[17:45:18.096] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.096] assign_globals() ... done
[17:45:18.096] plan(): Setting new future strategy stack:
[17:45:18.096] List of future strategies:
[17:45:18.096] 1. sequential:
[17:45:18.096]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.096]    - tweaked: FALSE
[17:45:18.096]    - call: NULL
[17:45:18.097] plan(): nbrOfWorkers() = 1
[17:45:18.098] plan(): Setting new future strategy stack:
[17:45:18.098] List of future strategies:
[17:45:18.098] 1. sequential:
[17:45:18.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.098]    - tweaked: FALSE
[17:45:18.098]    - call: plan(strategy)
[17:45:18.098] plan(): nbrOfWorkers() = 1
[17:45:18.098] SequentialFuture started (and completed)
[17:45:18.098] - Launch lazy future ... done
[17:45:18.099] run() for ‘SequentialFuture’ ... done
[17:45:18.099] Created future:
[17:45:18.099] SequentialFuture:
[17:45:18.099] Label: ‘future_vapply-1’
[17:45:18.099] Expression:
[17:45:18.099] {
[17:45:18.099]     do.call(function(...) {
[17:45:18.099]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.099]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.099]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.099]             on.exit(options(oopts), add = TRUE)
[17:45:18.099]         }
[17:45:18.099]         {
[17:45:18.099]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.099]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.099]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.099]             })
[17:45:18.099]         }
[17:45:18.099]     }, args = future.call.arguments)
[17:45:18.099] }
[17:45:18.099] Lazy evaluation: FALSE
[17:45:18.099] Asynchronous evaluation: FALSE
[17:45:18.099] Local evaluation: TRUE
[17:45:18.099] Environment: R_GlobalEnv
[17:45:18.099] Capture standard output: TRUE
[17:45:18.099] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.099] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.099] Packages: 1 packages (‘future.apply’)
[17:45:18.099] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.099] Resolved: TRUE
[17:45:18.099] Value: 616 bytes of class ‘list’
[17:45:18.099] Early signaling: FALSE
[17:45:18.099] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.099] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.101] Chunk #1 of 1 ... DONE
[17:45:18.101] Launching 1 futures (chunks) ... DONE
[17:45:18.101] Resolving 1 futures (chunks) ...
[17:45:18.102] resolve() on list ...
[17:45:18.102]  recursive: 0
[17:45:18.102]  length: 1
[17:45:18.102] 
[17:45:18.102] resolved() for ‘SequentialFuture’ ...
[17:45:18.102] - state: ‘finished’
[17:45:18.102] - run: TRUE
[17:45:18.102] - result: ‘FutureResult’
[17:45:18.102] resolved() for ‘SequentialFuture’ ... done
[17:45:18.102] Future #1
[17:45:18.103] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:18.103] - nx: 1
[17:45:18.103] - relay: TRUE
[17:45:18.103] - stdout: TRUE
[17:45:18.103] - signal: TRUE
[17:45:18.103] - resignal: FALSE
[17:45:18.103] - force: TRUE
[17:45:18.103] - relayed: [n=1] FALSE
[17:45:18.103] - queued futures: [n=1] FALSE
[17:45:18.103]  - until=1
[17:45:18.103]  - relaying element #1
[17:45:18.104] - relayed: [n=1] TRUE
[17:45:18.104] - queued futures: [n=1] TRUE
[17:45:18.104] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:18.104]  length: 0 (resolved future 1)
[17:45:18.104] Relaying remaining futures
[17:45:18.104] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.104] - nx: 1
[17:45:18.104] - relay: TRUE
[17:45:18.104] - stdout: TRUE
[17:45:18.104] - signal: TRUE
[17:45:18.105] - resignal: FALSE
[17:45:18.105] - force: TRUE
[17:45:18.105] - relayed: [n=1] TRUE
[17:45:18.105] - queued futures: [n=1] TRUE
 - flush all
[17:45:18.105] - relayed: [n=1] TRUE
[17:45:18.105] - queued futures: [n=1] TRUE
[17:45:18.105] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.105] resolve() on list ... DONE
[17:45:18.105]  - Number of value chunks collected: 1
[17:45:18.105] Resolving 1 futures (chunks) ... DONE
[17:45:18.105] Reducing values from 1 chunks ...
[17:45:18.106]  - Number of values collected after concatenation: 11
[17:45:18.106]  - Number of values expected: 11
[17:45:18.106] Reducing values from 1 chunks ... DONE
[17:45:18.106] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:45:18.107] future_lapply() ...
[17:45:18.108] Number of chunks: 1
[17:45:18.108] getGlobalsAndPackagesXApply() ...
[17:45:18.108]  - future.globals: TRUE
[17:45:18.109] getGlobalsAndPackages() ...
[17:45:18.109] Searching for globals...
[17:45:18.111] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:18.112] Searching for globals ... DONE
[17:45:18.112] Resolving globals: FALSE
[17:45:18.112] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:45:18.113] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.113] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.113] - packages: [1] ‘future.apply’
[17:45:18.113] getGlobalsAndPackages() ... DONE
[17:45:18.113]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.113]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.113] Finding globals ... DONE
[17:45:18.113]  - use_args: TRUE
[17:45:18.114]  - Getting '...' globals ...
[17:45:18.114] resolve() on list ...
[17:45:18.114]  recursive: 0
[17:45:18.114]  length: 1
[17:45:18.114]  elements: ‘...’
[17:45:18.114]  length: 0 (resolved future 1)
[17:45:18.114] resolve() on list ... DONE
[17:45:18.114]    - '...' content: [n=0] 
[17:45:18.115] List of 1
[17:45:18.115]  $ ...: list()
[17:45:18.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.115]  - attr(*, "where")=List of 1
[17:45:18.115]   ..$ ...:<environment: 0x5561f3c52518> 
[17:45:18.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.115]  - attr(*, "resolved")= logi TRUE
[17:45:18.115]  - attr(*, "total_size")= num NA
[17:45:18.117]  - Getting '...' globals ... DONE
[17:45:18.117] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.117] List of 8
[17:45:18.117]  $ ...future.FUN:function (x, ...)  
[17:45:18.117]  $ x_FUN        :function (x)  
[17:45:18.117]  $ times        : int 1
[17:45:18.117]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.117]  $ stop_if_not  :function (...)  
[17:45:18.117]  $ dim          : NULL
[17:45:18.117]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:18.117]  $ ...          : list()
[17:45:18.117]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.117]  - attr(*, "where")=List of 8
[17:45:18.117]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.117]   ..$ ...          :<environment: 0x5561f3c52518> 
[17:45:18.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.117]  - attr(*, "resolved")= logi FALSE
[17:45:18.117]  - attr(*, "total_size")= num 94264
[17:45:18.124] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.124] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.124] Number of futures (= number of chunks): 1
[17:45:18.124] Launching 1 futures (chunks) ...
[17:45:18.124] Chunk #1 of 1 ...
[17:45:18.125]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.125] getGlobalsAndPackages() ...
[17:45:18.125] Searching for globals...
[17:45:18.125] 
[17:45:18.125] Searching for globals ... DONE
[17:45:18.125] - globals: [0] <none>
[17:45:18.125] getGlobalsAndPackages() ... DONE
[17:45:18.125]    + additional globals found: [n=0] 
[17:45:18.125]    + additional namespaces needed: [n=0] 
[17:45:18.125]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.126]  - seeds: <none>
[17:45:18.126]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.126] getGlobalsAndPackages() ...
[17:45:18.126] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.126] Resolving globals: FALSE
[17:45:18.126] Tweak future expression to call with '...' arguments ...
[17:45:18.126] {
[17:45:18.126]     do.call(function(...) {
[17:45:18.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.126]             on.exit(options(oopts), add = TRUE)
[17:45:18.126]         }
[17:45:18.126]         {
[17:45:18.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.126]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.126]             })
[17:45:18.126]         }
[17:45:18.126]     }, args = future.call.arguments)
[17:45:18.126] }
[17:45:18.126] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.127] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.127] - packages: [1] ‘future.apply’
[17:45:18.127] getGlobalsAndPackages() ... DONE
[17:45:18.127] run() for ‘Future’ ...
[17:45:18.127] - state: ‘created’
[17:45:18.128] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:18.128] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:18.128]   - Field: ‘label’
[17:45:18.128]   - Field: ‘local’
[17:45:18.128]   - Field: ‘owner’
[17:45:18.128]   - Field: ‘envir’
[17:45:18.128]   - Field: ‘packages’
[17:45:18.129]   - Field: ‘gc’
[17:45:18.129]   - Field: ‘conditions’
[17:45:18.129]   - Field: ‘expr’
[17:45:18.129]   - Field: ‘uuid’
[17:45:18.129]   - Field: ‘seed’
[17:45:18.129]   - Field: ‘version’
[17:45:18.129]   - Field: ‘result’
[17:45:18.129]   - Field: ‘asynchronous’
[17:45:18.129]   - Field: ‘calls’
[17:45:18.129]   - Field: ‘globals’
[17:45:18.129]   - Field: ‘stdout’
[17:45:18.129]   - Field: ‘earlySignal’
[17:45:18.130]   - Field: ‘lazy’
[17:45:18.130]   - Field: ‘state’
[17:45:18.130] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:18.130] - Launch lazy future ...
[17:45:18.130] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.130] Packages needed by future strategies (n = 0): <none>
[17:45:18.131] {
[17:45:18.131]     {
[17:45:18.131]         {
[17:45:18.131]             ...future.startTime <- base::Sys.time()
[17:45:18.131]             {
[17:45:18.131]                 {
[17:45:18.131]                   {
[17:45:18.131]                     {
[17:45:18.131]                       base::local({
[17:45:18.131]                         has_future <- base::requireNamespace("future", 
[17:45:18.131]                           quietly = TRUE)
[17:45:18.131]                         if (has_future) {
[17:45:18.131]                           ns <- base::getNamespace("future")
[17:45:18.131]                           version <- ns[[".package"]][["version"]]
[17:45:18.131]                           if (is.null(version)) 
[17:45:18.131]                             version <- utils::packageVersion("future")
[17:45:18.131]                         }
[17:45:18.131]                         else {
[17:45:18.131]                           version <- NULL
[17:45:18.131]                         }
[17:45:18.131]                         if (!has_future || version < "1.8.0") {
[17:45:18.131]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.131]                             "", base::R.version$version.string), 
[17:45:18.131]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:18.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:18.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.131]                               "release", "version")], collapse = " "), 
[17:45:18.131]                             hostname = base::Sys.info()[["nodename"]])
[17:45:18.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.131]                             info)
[17:45:18.131]                           info <- base::paste(info, collapse = "; ")
[17:45:18.131]                           if (!has_future) {
[17:45:18.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.131]                               info)
[17:45:18.131]                           }
[17:45:18.131]                           else {
[17:45:18.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.131]                               info, version)
[17:45:18.131]                           }
[17:45:18.131]                           base::stop(msg)
[17:45:18.131]                         }
[17:45:18.131]                       })
[17:45:18.131]                     }
[17:45:18.131]                     base::local({
[17:45:18.131]                       for (pkg in "future.apply") {
[17:45:18.131]                         base::loadNamespace(pkg)
[17:45:18.131]                         base::library(pkg, character.only = TRUE)
[17:45:18.131]                       }
[17:45:18.131]                     })
[17:45:18.131]                   }
[17:45:18.131]                   ...future.strategy.old <- future::plan("list")
[17:45:18.131]                   options(future.plan = NULL)
[17:45:18.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.131]                 }
[17:45:18.131]                 ...future.workdir <- getwd()
[17:45:18.131]             }
[17:45:18.131]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.131]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.131]         }
[17:45:18.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:18.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.131]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.131]             base::names(...future.oldOptions))
[17:45:18.131]     }
[17:45:18.131]     if (FALSE) {
[17:45:18.131]     }
[17:45:18.131]     else {
[17:45:18.131]         if (TRUE) {
[17:45:18.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.131]                 open = "w")
[17:45:18.131]         }
[17:45:18.131]         else {
[17:45:18.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.131]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.131]         }
[17:45:18.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.131]             base::sink(type = "output", split = FALSE)
[17:45:18.131]             base::close(...future.stdout)
[17:45:18.131]         }, add = TRUE)
[17:45:18.131]     }
[17:45:18.131]     ...future.frame <- base::sys.nframe()
[17:45:18.131]     ...future.conditions <- base::list()
[17:45:18.131]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.131]     if (FALSE) {
[17:45:18.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.131]     }
[17:45:18.131]     ...future.result <- base::tryCatch({
[17:45:18.131]         base::withCallingHandlers({
[17:45:18.131]             ...future.value <- base::withVisible(base::local({
[17:45:18.131]                 do.call(function(...) {
[17:45:18.131]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.131]                   if (!identical(...future.globals.maxSize.org, 
[17:45:18.131]                     ...future.globals.maxSize)) {
[17:45:18.131]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.131]                     on.exit(options(oopts), add = TRUE)
[17:45:18.131]                   }
[17:45:18.131]                   {
[17:45:18.131]                     lapply(seq_along(...future.elements_ii), 
[17:45:18.131]                       FUN = function(jj) {
[17:45:18.131]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.131]                         ...future.FUN(...future.X_jj, ...)
[17:45:18.131]                       })
[17:45:18.131]                   }
[17:45:18.131]                 }, args = future.call.arguments)
[17:45:18.131]             }))
[17:45:18.131]             future::FutureResult(value = ...future.value$value, 
[17:45:18.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.131]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.131]                     ...future.globalenv.names))
[17:45:18.131]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.131]         }, condition = base::local({
[17:45:18.131]             c <- base::c
[17:45:18.131]             inherits <- base::inherits
[17:45:18.131]             invokeRestart <- base::invokeRestart
[17:45:18.131]             length <- base::length
[17:45:18.131]             list <- base::list
[17:45:18.131]             seq.int <- base::seq.int
[17:45:18.131]             signalCondition <- base::signalCondition
[17:45:18.131]             sys.calls <- base::sys.calls
[17:45:18.131]             `[[` <- base::`[[`
[17:45:18.131]             `+` <- base::`+`
[17:45:18.131]             `<<-` <- base::`<<-`
[17:45:18.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.131]                   3L)]
[17:45:18.131]             }
[17:45:18.131]             function(cond) {
[17:45:18.131]                 is_error <- inherits(cond, "error")
[17:45:18.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.131]                   NULL)
[17:45:18.131]                 if (is_error) {
[17:45:18.131]                   sessionInformation <- function() {
[17:45:18.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.131]                       search = base::search(), system = base::Sys.info())
[17:45:18.131]                   }
[17:45:18.131]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.131]                     cond$call), session = sessionInformation(), 
[17:45:18.131]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.131]                   signalCondition(cond)
[17:45:18.131]                 }
[17:45:18.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.131]                 "immediateCondition"))) {
[17:45:18.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.131]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.131]                   if (TRUE && !signal) {
[17:45:18.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.131]                     {
[17:45:18.131]                       inherits <- base::inherits
[17:45:18.131]                       invokeRestart <- base::invokeRestart
[17:45:18.131]                       is.null <- base::is.null
[17:45:18.131]                       muffled <- FALSE
[17:45:18.131]                       if (inherits(cond, "message")) {
[17:45:18.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.131]                         if (muffled) 
[17:45:18.131]                           invokeRestart("muffleMessage")
[17:45:18.131]                       }
[17:45:18.131]                       else if (inherits(cond, "warning")) {
[17:45:18.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.131]                         if (muffled) 
[17:45:18.131]                           invokeRestart("muffleWarning")
[17:45:18.131]                       }
[17:45:18.131]                       else if (inherits(cond, "condition")) {
[17:45:18.131]                         if (!is.null(pattern)) {
[17:45:18.131]                           computeRestarts <- base::computeRestarts
[17:45:18.131]                           grepl <- base::grepl
[17:45:18.131]                           restarts <- computeRestarts(cond)
[17:45:18.131]                           for (restart in restarts) {
[17:45:18.131]                             name <- restart$name
[17:45:18.131]                             if (is.null(name)) 
[17:45:18.131]                               next
[17:45:18.131]                             if (!grepl(pattern, name)) 
[17:45:18.131]                               next
[17:45:18.131]                             invokeRestart(restart)
[17:45:18.131]                             muffled <- TRUE
[17:45:18.131]                             break
[17:45:18.131]                           }
[17:45:18.131]                         }
[17:45:18.131]                       }
[17:45:18.131]                       invisible(muffled)
[17:45:18.131]                     }
[17:45:18.131]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.131]                   }
[17:45:18.131]                 }
[17:45:18.131]                 else {
[17:45:18.131]                   if (TRUE) {
[17:45:18.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.131]                     {
[17:45:18.131]                       inherits <- base::inherits
[17:45:18.131]                       invokeRestart <- base::invokeRestart
[17:45:18.131]                       is.null <- base::is.null
[17:45:18.131]                       muffled <- FALSE
[17:45:18.131]                       if (inherits(cond, "message")) {
[17:45:18.131]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.131]                         if (muffled) 
[17:45:18.131]                           invokeRestart("muffleMessage")
[17:45:18.131]                       }
[17:45:18.131]                       else if (inherits(cond, "warning")) {
[17:45:18.131]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.131]                         if (muffled) 
[17:45:18.131]                           invokeRestart("muffleWarning")
[17:45:18.131]                       }
[17:45:18.131]                       else if (inherits(cond, "condition")) {
[17:45:18.131]                         if (!is.null(pattern)) {
[17:45:18.131]                           computeRestarts <- base::computeRestarts
[17:45:18.131]                           grepl <- base::grepl
[17:45:18.131]                           restarts <- computeRestarts(cond)
[17:45:18.131]                           for (restart in restarts) {
[17:45:18.131]                             name <- restart$name
[17:45:18.131]                             if (is.null(name)) 
[17:45:18.131]                               next
[17:45:18.131]                             if (!grepl(pattern, name)) 
[17:45:18.131]                               next
[17:45:18.131]                             invokeRestart(restart)
[17:45:18.131]                             muffled <- TRUE
[17:45:18.131]                             break
[17:45:18.131]                           }
[17:45:18.131]                         }
[17:45:18.131]                       }
[17:45:18.131]                       invisible(muffled)
[17:45:18.131]                     }
[17:45:18.131]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.131]                   }
[17:45:18.131]                 }
[17:45:18.131]             }
[17:45:18.131]         }))
[17:45:18.131]     }, error = function(ex) {
[17:45:18.131]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.131]                 ...future.rng), started = ...future.startTime, 
[17:45:18.131]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.131]             version = "1.8"), class = "FutureResult")
[17:45:18.131]     }, finally = {
[17:45:18.131]         if (!identical(...future.workdir, getwd())) 
[17:45:18.131]             setwd(...future.workdir)
[17:45:18.131]         {
[17:45:18.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.131]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.131]             }
[17:45:18.131]             base::options(...future.oldOptions)
[17:45:18.131]             if (.Platform$OS.type == "windows") {
[17:45:18.131]                 old_names <- names(...future.oldEnvVars)
[17:45:18.131]                 envs <- base::Sys.getenv()
[17:45:18.131]                 names <- names(envs)
[17:45:18.131]                 common <- intersect(names, old_names)
[17:45:18.131]                 added <- setdiff(names, old_names)
[17:45:18.131]                 removed <- setdiff(old_names, names)
[17:45:18.131]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.131]                   envs[common]]
[17:45:18.131]                 NAMES <- toupper(changed)
[17:45:18.131]                 args <- list()
[17:45:18.131]                 for (kk in seq_along(NAMES)) {
[17:45:18.131]                   name <- changed[[kk]]
[17:45:18.131]                   NAME <- NAMES[[kk]]
[17:45:18.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.131]                     next
[17:45:18.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.131]                 }
[17:45:18.131]                 NAMES <- toupper(added)
[17:45:18.131]                 for (kk in seq_along(NAMES)) {
[17:45:18.131]                   name <- added[[kk]]
[17:45:18.131]                   NAME <- NAMES[[kk]]
[17:45:18.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.131]                     next
[17:45:18.131]                   args[[name]] <- ""
[17:45:18.131]                 }
[17:45:18.131]                 NAMES <- toupper(removed)
[17:45:18.131]                 for (kk in seq_along(NAMES)) {
[17:45:18.131]                   name <- removed[[kk]]
[17:45:18.131]                   NAME <- NAMES[[kk]]
[17:45:18.131]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.131]                     next
[17:45:18.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.131]                 }
[17:45:18.131]                 if (length(args) > 0) 
[17:45:18.131]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.131]             }
[17:45:18.131]             else {
[17:45:18.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.131]             }
[17:45:18.131]             {
[17:45:18.131]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.131]                   0L) {
[17:45:18.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.131]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.131]                   base::options(opts)
[17:45:18.131]                 }
[17:45:18.131]                 {
[17:45:18.131]                   {
[17:45:18.131]                     NULL
[17:45:18.131]                     RNGkind("Mersenne-Twister")
[17:45:18.131]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:18.131]                       inherits = FALSE)
[17:45:18.131]                   }
[17:45:18.131]                   options(future.plan = NULL)
[17:45:18.131]                   if (is.na(NA_character_)) 
[17:45:18.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.131]                     .init = FALSE)
[17:45:18.131]                 }
[17:45:18.131]             }
[17:45:18.131]         }
[17:45:18.131]     })
[17:45:18.131]     if (TRUE) {
[17:45:18.131]         base::sink(type = "output", split = FALSE)
[17:45:18.131]         if (TRUE) {
[17:45:18.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.131]         }
[17:45:18.131]         else {
[17:45:18.131]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.131]         }
[17:45:18.131]         base::close(...future.stdout)
[17:45:18.131]         ...future.stdout <- NULL
[17:45:18.131]     }
[17:45:18.131]     ...future.result$conditions <- ...future.conditions
[17:45:18.131]     ...future.result$finished <- base::Sys.time()
[17:45:18.131]     ...future.result
[17:45:18.131] }
[17:45:18.132] assign_globals() ...
[17:45:18.132] List of 11
[17:45:18.132]  $ ...future.FUN            :function (x, ...)  
[17:45:18.132]  $ x_FUN                    :function (x)  
[17:45:18.132]  $ times                    : int 1
[17:45:18.132]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.132]  $ stop_if_not              :function (...)  
[17:45:18.132]  $ dim                      : NULL
[17:45:18.132]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:18.132]  $ future.call.arguments    : list()
[17:45:18.132]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.132]  $ ...future.elements_ii    :List of 3
[17:45:18.132]   ..$ a: num 1
[17:45:18.132]   ..$ b: num 2
[17:45:18.132]   ..$ c: num 3
[17:45:18.132]  $ ...future.seeds_ii       : NULL
[17:45:18.132]  $ ...future.globals.maxSize: NULL
[17:45:18.132]  - attr(*, "where")=List of 11
[17:45:18.132]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.132]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.132]  - attr(*, "resolved")= logi FALSE
[17:45:18.132]  - attr(*, "total_size")= num 94264
[17:45:18.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.132]  - attr(*, "already-done")= logi TRUE
[17:45:18.140] - copied ‘...future.FUN’ to environment
[17:45:18.140] - copied ‘x_FUN’ to environment
[17:45:18.140] - copied ‘times’ to environment
[17:45:18.140] - copied ‘stopf’ to environment
[17:45:18.140] - copied ‘stop_if_not’ to environment
[17:45:18.140] - copied ‘dim’ to environment
[17:45:18.140] - copied ‘valid_types’ to environment
[17:45:18.141] - copied ‘future.call.arguments’ to environment
[17:45:18.141] - copied ‘...future.elements_ii’ to environment
[17:45:18.141] - copied ‘...future.seeds_ii’ to environment
[17:45:18.141] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.141] assign_globals() ... done
[17:45:18.141] plan(): Setting new future strategy stack:
[17:45:18.141] List of future strategies:
[17:45:18.141] 1. sequential:
[17:45:18.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.141]    - tweaked: FALSE
[17:45:18.141]    - call: NULL
[17:45:18.142] plan(): nbrOfWorkers() = 1
[17:45:18.143] plan(): Setting new future strategy stack:
[17:45:18.143] List of future strategies:
[17:45:18.143] 1. sequential:
[17:45:18.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.143]    - tweaked: FALSE
[17:45:18.143]    - call: plan(strategy)
[17:45:18.143] plan(): nbrOfWorkers() = 1
[17:45:18.143] SequentialFuture started (and completed)
[17:45:18.143] - Launch lazy future ... done
[17:45:18.144] run() for ‘SequentialFuture’ ... done
[17:45:18.144] Created future:
[17:45:18.144] SequentialFuture:
[17:45:18.144] Label: ‘future_vapply-1’
[17:45:18.144] Expression:
[17:45:18.144] {
[17:45:18.144]     do.call(function(...) {
[17:45:18.144]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.144]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.144]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.144]             on.exit(options(oopts), add = TRUE)
[17:45:18.144]         }
[17:45:18.144]         {
[17:45:18.144]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.144]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.144]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.144]             })
[17:45:18.144]         }
[17:45:18.144]     }, args = future.call.arguments)
[17:45:18.144] }
[17:45:18.144] Lazy evaluation: FALSE
[17:45:18.144] Asynchronous evaluation: FALSE
[17:45:18.144] Local evaluation: TRUE
[17:45:18.144] Environment: R_GlobalEnv
[17:45:18.144] Capture standard output: TRUE
[17:45:18.144] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.144] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.144] Packages: 1 packages (‘future.apply’)
[17:45:18.144] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.144] Resolved: TRUE
[17:45:18.144] Value: 168 bytes of class ‘list’
[17:45:18.144] Early signaling: FALSE
[17:45:18.144] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.144] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.146] Chunk #1 of 1 ... DONE
[17:45:18.147] Launching 1 futures (chunks) ... DONE
[17:45:18.147] Resolving 1 futures (chunks) ...
[17:45:18.147] resolve() on list ...
[17:45:18.147]  recursive: 0
[17:45:18.147]  length: 1
[17:45:18.147] 
[17:45:18.147] resolved() for ‘SequentialFuture’ ...
[17:45:18.147] - state: ‘finished’
[17:45:18.147] - run: TRUE
[17:45:18.148] - result: ‘FutureResult’
[17:45:18.148] resolved() for ‘SequentialFuture’ ... done
[17:45:18.148] Future #1
[17:45:18.148] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:18.148] - nx: 1
[17:45:18.148] - relay: TRUE
[17:45:18.148] - stdout: TRUE
[17:45:18.148] - signal: TRUE
[17:45:18.148] - resignal: FALSE
[17:45:18.148] - force: TRUE
[17:45:18.149] - relayed: [n=1] FALSE
[17:45:18.149] - queued futures: [n=1] FALSE
[17:45:18.149]  - until=1
[17:45:18.149]  - relaying element #1
[17:45:18.149] - relayed: [n=1] TRUE
[17:45:18.149] - queued futures: [n=1] TRUE
[17:45:18.149] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:18.149]  length: 0 (resolved future 1)
[17:45:18.149] Relaying remaining futures
[17:45:18.149] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.150] - nx: 1
[17:45:18.150] - relay: TRUE
[17:45:18.150] - stdout: TRUE
[17:45:18.150] - signal: TRUE
[17:45:18.150] - resignal: FALSE
[17:45:18.150] - force: TRUE
[17:45:18.150] - relayed: [n=1] TRUE
[17:45:18.150] - queued futures: [n=1] TRUE
 - flush all
[17:45:18.150] - relayed: [n=1] TRUE
[17:45:18.150] - queued futures: [n=1] TRUE
[17:45:18.150] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.151] resolve() on list ... DONE
[17:45:18.151]  - Number of value chunks collected: 1
[17:45:18.151] Resolving 1 futures (chunks) ... DONE
[17:45:18.151] Reducing values from 1 chunks ...
[17:45:18.151]  - Number of values collected after concatenation: 3
[17:45:18.151]  - Number of values expected: 3
[17:45:18.151] Reducing values from 1 chunks ... DONE
[17:45:18.151] future_lapply() ... DONE
- exceptions ...
[17:45:18.151] future_lapply() ...
[17:45:18.153] Number of chunks: 1
[17:45:18.153] getGlobalsAndPackagesXApply() ...
[17:45:18.153]  - future.globals: TRUE
[17:45:18.153] getGlobalsAndPackages() ...
[17:45:18.154] Searching for globals...
[17:45:18.157] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:18.157] Searching for globals ... DONE
[17:45:18.157] Resolving globals: FALSE
[17:45:18.158] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:45:18.158] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.158] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.158] - packages: [1] ‘future.apply’
[17:45:18.159] getGlobalsAndPackages() ... DONE
[17:45:18.159]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.159]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.159] Finding globals ... DONE
[17:45:18.159]  - use_args: TRUE
[17:45:18.159]  - Getting '...' globals ...
[17:45:18.159] resolve() on list ...
[17:45:18.159]  recursive: 0
[17:45:18.160]  length: 1
[17:45:18.160]  elements: ‘...’
[17:45:18.160]  length: 0 (resolved future 1)
[17:45:18.160] resolve() on list ... DONE
[17:45:18.160]    - '...' content: [n=0] 
[17:45:18.160] List of 1
[17:45:18.160]  $ ...: list()
[17:45:18.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.160]  - attr(*, "where")=List of 1
[17:45:18.160]   ..$ ...:<environment: 0x5561f2fab760> 
[17:45:18.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.160]  - attr(*, "resolved")= logi TRUE
[17:45:18.160]  - attr(*, "total_size")= num NA
[17:45:18.163]  - Getting '...' globals ... DONE
[17:45:18.163] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.163] List of 8
[17:45:18.163]  $ ...future.FUN:function (x, ...)  
[17:45:18.163]  $ x_FUN        :function (x)  
[17:45:18.163]  $ times        : int 2
[17:45:18.163]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.163]  $ stop_if_not  :function (...)  
[17:45:18.163]  $ dim          : NULL
[17:45:18.163]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:18.163]  $ ...          : list()
[17:45:18.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.163]  - attr(*, "where")=List of 8
[17:45:18.163]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.163]   ..$ ...          :<environment: 0x5561f2fab760> 
[17:45:18.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.163]  - attr(*, "resolved")= logi FALSE
[17:45:18.163]  - attr(*, "total_size")= num 95128
[17:45:18.170] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.170] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.170] Number of futures (= number of chunks): 1
[17:45:18.170] Launching 1 futures (chunks) ...
[17:45:18.170] Chunk #1 of 1 ...
[17:45:18.170]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.171] getGlobalsAndPackages() ...
[17:45:18.171] Searching for globals...
[17:45:18.171] 
[17:45:18.171] Searching for globals ... DONE
[17:45:18.171] - globals: [0] <none>
[17:45:18.171] getGlobalsAndPackages() ... DONE
[17:45:18.171]    + additional globals found: [n=0] 
[17:45:18.171]    + additional namespaces needed: [n=0] 
[17:45:18.171]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.172]  - seeds: <none>
[17:45:18.172]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.172] getGlobalsAndPackages() ...
[17:45:18.172] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.172] Resolving globals: FALSE
[17:45:18.172] Tweak future expression to call with '...' arguments ...
[17:45:18.172] {
[17:45:18.172]     do.call(function(...) {
[17:45:18.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.172]             on.exit(options(oopts), add = TRUE)
[17:45:18.172]         }
[17:45:18.172]         {
[17:45:18.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.172]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.172]             })
[17:45:18.172]         }
[17:45:18.172]     }, args = future.call.arguments)
[17:45:18.172] }
[17:45:18.172] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.173] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.173] - packages: [1] ‘future.apply’
[17:45:18.173] getGlobalsAndPackages() ... DONE
[17:45:18.173] run() for ‘Future’ ...
[17:45:18.173] - state: ‘created’
[17:45:18.174] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[17:45:18.174] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[17:45:18.174]   - Field: ‘label’
[17:45:18.174]   - Field: ‘local’
[17:45:18.174]   - Field: ‘owner’
[17:45:18.174]   - Field: ‘envir’
[17:45:18.174]   - Field: ‘packages’
[17:45:18.175]   - Field: ‘gc’
[17:45:18.175]   - Field: ‘conditions’
[17:45:18.175]   - Field: ‘expr’
[17:45:18.175]   - Field: ‘uuid’
[17:45:18.175]   - Field: ‘seed’
[17:45:18.175]   - Field: ‘version’
[17:45:18.175]   - Field: ‘result’
[17:45:18.175]   - Field: ‘asynchronous’
[17:45:18.175]   - Field: ‘calls’
[17:45:18.175]   - Field: ‘globals’
[17:45:18.175]   - Field: ‘stdout’
[17:45:18.176]   - Field: ‘earlySignal’
[17:45:18.176]   - Field: ‘lazy’
[17:45:18.176]   - Field: ‘state’
[17:45:18.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[17:45:18.176] - Launch lazy future ...
[17:45:18.176] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.176] Packages needed by future strategies (n = 0): <none>
[17:45:18.177] {
[17:45:18.177]     {
[17:45:18.177]         {
[17:45:18.177]             ...future.startTime <- base::Sys.time()
[17:45:18.177]             {
[17:45:18.177]                 {
[17:45:18.177]                   {
[17:45:18.177]                     {
[17:45:18.177]                       base::local({
[17:45:18.177]                         has_future <- base::requireNamespace("future", 
[17:45:18.177]                           quietly = TRUE)
[17:45:18.177]                         if (has_future) {
[17:45:18.177]                           ns <- base::getNamespace("future")
[17:45:18.177]                           version <- ns[[".package"]][["version"]]
[17:45:18.177]                           if (is.null(version)) 
[17:45:18.177]                             version <- utils::packageVersion("future")
[17:45:18.177]                         }
[17:45:18.177]                         else {
[17:45:18.177]                           version <- NULL
[17:45:18.177]                         }
[17:45:18.177]                         if (!has_future || version < "1.8.0") {
[17:45:18.177]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.177]                             "", base::R.version$version.string), 
[17:45:18.177]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:18.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:18.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.177]                               "release", "version")], collapse = " "), 
[17:45:18.177]                             hostname = base::Sys.info()[["nodename"]])
[17:45:18.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.177]                             info)
[17:45:18.177]                           info <- base::paste(info, collapse = "; ")
[17:45:18.177]                           if (!has_future) {
[17:45:18.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.177]                               info)
[17:45:18.177]                           }
[17:45:18.177]                           else {
[17:45:18.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.177]                               info, version)
[17:45:18.177]                           }
[17:45:18.177]                           base::stop(msg)
[17:45:18.177]                         }
[17:45:18.177]                       })
[17:45:18.177]                     }
[17:45:18.177]                     base::local({
[17:45:18.177]                       for (pkg in "future.apply") {
[17:45:18.177]                         base::loadNamespace(pkg)
[17:45:18.177]                         base::library(pkg, character.only = TRUE)
[17:45:18.177]                       }
[17:45:18.177]                     })
[17:45:18.177]                   }
[17:45:18.177]                   ...future.strategy.old <- future::plan("list")
[17:45:18.177]                   options(future.plan = NULL)
[17:45:18.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.177]                 }
[17:45:18.177]                 ...future.workdir <- getwd()
[17:45:18.177]             }
[17:45:18.177]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.177]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.177]         }
[17:45:18.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:18.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.177]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.177]             base::names(...future.oldOptions))
[17:45:18.177]     }
[17:45:18.177]     if (FALSE) {
[17:45:18.177]     }
[17:45:18.177]     else {
[17:45:18.177]         if (TRUE) {
[17:45:18.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.177]                 open = "w")
[17:45:18.177]         }
[17:45:18.177]         else {
[17:45:18.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.177]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.177]         }
[17:45:18.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.177]             base::sink(type = "output", split = FALSE)
[17:45:18.177]             base::close(...future.stdout)
[17:45:18.177]         }, add = TRUE)
[17:45:18.177]     }
[17:45:18.177]     ...future.frame <- base::sys.nframe()
[17:45:18.177]     ...future.conditions <- base::list()
[17:45:18.177]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.177]     if (FALSE) {
[17:45:18.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.177]     }
[17:45:18.177]     ...future.result <- base::tryCatch({
[17:45:18.177]         base::withCallingHandlers({
[17:45:18.177]             ...future.value <- base::withVisible(base::local({
[17:45:18.177]                 do.call(function(...) {
[17:45:18.177]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.177]                   if (!identical(...future.globals.maxSize.org, 
[17:45:18.177]                     ...future.globals.maxSize)) {
[17:45:18.177]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.177]                     on.exit(options(oopts), add = TRUE)
[17:45:18.177]                   }
[17:45:18.177]                   {
[17:45:18.177]                     lapply(seq_along(...future.elements_ii), 
[17:45:18.177]                       FUN = function(jj) {
[17:45:18.177]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.177]                         ...future.FUN(...future.X_jj, ...)
[17:45:18.177]                       })
[17:45:18.177]                   }
[17:45:18.177]                 }, args = future.call.arguments)
[17:45:18.177]             }))
[17:45:18.177]             future::FutureResult(value = ...future.value$value, 
[17:45:18.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.177]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.177]                     ...future.globalenv.names))
[17:45:18.177]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.177]         }, condition = base::local({
[17:45:18.177]             c <- base::c
[17:45:18.177]             inherits <- base::inherits
[17:45:18.177]             invokeRestart <- base::invokeRestart
[17:45:18.177]             length <- base::length
[17:45:18.177]             list <- base::list
[17:45:18.177]             seq.int <- base::seq.int
[17:45:18.177]             signalCondition <- base::signalCondition
[17:45:18.177]             sys.calls <- base::sys.calls
[17:45:18.177]             `[[` <- base::`[[`
[17:45:18.177]             `+` <- base::`+`
[17:45:18.177]             `<<-` <- base::`<<-`
[17:45:18.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.177]                   3L)]
[17:45:18.177]             }
[17:45:18.177]             function(cond) {
[17:45:18.177]                 is_error <- inherits(cond, "error")
[17:45:18.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.177]                   NULL)
[17:45:18.177]                 if (is_error) {
[17:45:18.177]                   sessionInformation <- function() {
[17:45:18.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.177]                       search = base::search(), system = base::Sys.info())
[17:45:18.177]                   }
[17:45:18.177]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.177]                     cond$call), session = sessionInformation(), 
[17:45:18.177]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.177]                   signalCondition(cond)
[17:45:18.177]                 }
[17:45:18.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.177]                 "immediateCondition"))) {
[17:45:18.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.177]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.177]                   if (TRUE && !signal) {
[17:45:18.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.177]                     {
[17:45:18.177]                       inherits <- base::inherits
[17:45:18.177]                       invokeRestart <- base::invokeRestart
[17:45:18.177]                       is.null <- base::is.null
[17:45:18.177]                       muffled <- FALSE
[17:45:18.177]                       if (inherits(cond, "message")) {
[17:45:18.177]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.177]                         if (muffled) 
[17:45:18.177]                           invokeRestart("muffleMessage")
[17:45:18.177]                       }
[17:45:18.177]                       else if (inherits(cond, "warning")) {
[17:45:18.177]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.177]                         if (muffled) 
[17:45:18.177]                           invokeRestart("muffleWarning")
[17:45:18.177]                       }
[17:45:18.177]                       else if (inherits(cond, "condition")) {
[17:45:18.177]                         if (!is.null(pattern)) {
[17:45:18.177]                           computeRestarts <- base::computeRestarts
[17:45:18.177]                           grepl <- base::grepl
[17:45:18.177]                           restarts <- computeRestarts(cond)
[17:45:18.177]                           for (restart in restarts) {
[17:45:18.177]                             name <- restart$name
[17:45:18.177]                             if (is.null(name)) 
[17:45:18.177]                               next
[17:45:18.177]                             if (!grepl(pattern, name)) 
[17:45:18.177]                               next
[17:45:18.177]                             invokeRestart(restart)
[17:45:18.177]                             muffled <- TRUE
[17:45:18.177]                             break
[17:45:18.177]                           }
[17:45:18.177]                         }
[17:45:18.177]                       }
[17:45:18.177]                       invisible(muffled)
[17:45:18.177]                     }
[17:45:18.177]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.177]                   }
[17:45:18.177]                 }
[17:45:18.177]                 else {
[17:45:18.177]                   if (TRUE) {
[17:45:18.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.177]                     {
[17:45:18.177]                       inherits <- base::inherits
[17:45:18.177]                       invokeRestart <- base::invokeRestart
[17:45:18.177]                       is.null <- base::is.null
[17:45:18.177]                       muffled <- FALSE
[17:45:18.177]                       if (inherits(cond, "message")) {
[17:45:18.177]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.177]                         if (muffled) 
[17:45:18.177]                           invokeRestart("muffleMessage")
[17:45:18.177]                       }
[17:45:18.177]                       else if (inherits(cond, "warning")) {
[17:45:18.177]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.177]                         if (muffled) 
[17:45:18.177]                           invokeRestart("muffleWarning")
[17:45:18.177]                       }
[17:45:18.177]                       else if (inherits(cond, "condition")) {
[17:45:18.177]                         if (!is.null(pattern)) {
[17:45:18.177]                           computeRestarts <- base::computeRestarts
[17:45:18.177]                           grepl <- base::grepl
[17:45:18.177]                           restarts <- computeRestarts(cond)
[17:45:18.177]                           for (restart in restarts) {
[17:45:18.177]                             name <- restart$name
[17:45:18.177]                             if (is.null(name)) 
[17:45:18.177]                               next
[17:45:18.177]                             if (!grepl(pattern, name)) 
[17:45:18.177]                               next
[17:45:18.177]                             invokeRestart(restart)
[17:45:18.177]                             muffled <- TRUE
[17:45:18.177]                             break
[17:45:18.177]                           }
[17:45:18.177]                         }
[17:45:18.177]                       }
[17:45:18.177]                       invisible(muffled)
[17:45:18.177]                     }
[17:45:18.177]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.177]                   }
[17:45:18.177]                 }
[17:45:18.177]             }
[17:45:18.177]         }))
[17:45:18.177]     }, error = function(ex) {
[17:45:18.177]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.177]                 ...future.rng), started = ...future.startTime, 
[17:45:18.177]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.177]             version = "1.8"), class = "FutureResult")
[17:45:18.177]     }, finally = {
[17:45:18.177]         if (!identical(...future.workdir, getwd())) 
[17:45:18.177]             setwd(...future.workdir)
[17:45:18.177]         {
[17:45:18.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.177]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.177]             }
[17:45:18.177]             base::options(...future.oldOptions)
[17:45:18.177]             if (.Platform$OS.type == "windows") {
[17:45:18.177]                 old_names <- names(...future.oldEnvVars)
[17:45:18.177]                 envs <- base::Sys.getenv()
[17:45:18.177]                 names <- names(envs)
[17:45:18.177]                 common <- intersect(names, old_names)
[17:45:18.177]                 added <- setdiff(names, old_names)
[17:45:18.177]                 removed <- setdiff(old_names, names)
[17:45:18.177]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.177]                   envs[common]]
[17:45:18.177]                 NAMES <- toupper(changed)
[17:45:18.177]                 args <- list()
[17:45:18.177]                 for (kk in seq_along(NAMES)) {
[17:45:18.177]                   name <- changed[[kk]]
[17:45:18.177]                   NAME <- NAMES[[kk]]
[17:45:18.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.177]                     next
[17:45:18.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.177]                 }
[17:45:18.177]                 NAMES <- toupper(added)
[17:45:18.177]                 for (kk in seq_along(NAMES)) {
[17:45:18.177]                   name <- added[[kk]]
[17:45:18.177]                   NAME <- NAMES[[kk]]
[17:45:18.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.177]                     next
[17:45:18.177]                   args[[name]] <- ""
[17:45:18.177]                 }
[17:45:18.177]                 NAMES <- toupper(removed)
[17:45:18.177]                 for (kk in seq_along(NAMES)) {
[17:45:18.177]                   name <- removed[[kk]]
[17:45:18.177]                   NAME <- NAMES[[kk]]
[17:45:18.177]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.177]                     next
[17:45:18.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.177]                 }
[17:45:18.177]                 if (length(args) > 0) 
[17:45:18.177]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.177]             }
[17:45:18.177]             else {
[17:45:18.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.177]             }
[17:45:18.177]             {
[17:45:18.177]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.177]                   0L) {
[17:45:18.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.177]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.177]                   base::options(opts)
[17:45:18.177]                 }
[17:45:18.177]                 {
[17:45:18.177]                   {
[17:45:18.177]                     NULL
[17:45:18.177]                     RNGkind("Mersenne-Twister")
[17:45:18.177]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[17:45:18.177]                       inherits = FALSE)
[17:45:18.177]                   }
[17:45:18.177]                   options(future.plan = NULL)
[17:45:18.177]                   if (is.na(NA_character_)) 
[17:45:18.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.177]                     .init = FALSE)
[17:45:18.177]                 }
[17:45:18.177]             }
[17:45:18.177]         }
[17:45:18.177]     })
[17:45:18.177]     if (TRUE) {
[17:45:18.177]         base::sink(type = "output", split = FALSE)
[17:45:18.177]         if (TRUE) {
[17:45:18.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.177]         }
[17:45:18.177]         else {
[17:45:18.177]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.177]         }
[17:45:18.177]         base::close(...future.stdout)
[17:45:18.177]         ...future.stdout <- NULL
[17:45:18.177]     }
[17:45:18.177]     ...future.result$conditions <- ...future.conditions
[17:45:18.177]     ...future.result$finished <- base::Sys.time()
[17:45:18.177]     ...future.result
[17:45:18.177] }
[17:45:18.178] assign_globals() ...
[17:45:18.179] List of 11
[17:45:18.179]  $ ...future.FUN            :function (x, ...)  
[17:45:18.179]  $ x_FUN                    :function (x)  
[17:45:18.179]  $ times                    : int 2
[17:45:18.179]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.179]  $ stop_if_not              :function (...)  
[17:45:18.179]  $ dim                      : NULL
[17:45:18.179]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.179]  $ future.call.arguments    : list()
[17:45:18.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.179]  $ ...future.elements_ii    :List of 3
[17:45:18.179]   ..$ : int 1
[17:45:18.179]   ..$ : int 2
[17:45:18.179]   ..$ : int 3
[17:45:18.179]  $ ...future.seeds_ii       : NULL
[17:45:18.179]  $ ...future.globals.maxSize: NULL
[17:45:18.179]  - attr(*, "where")=List of 11
[17:45:18.179]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.179]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.179]  - attr(*, "resolved")= logi FALSE
[17:45:18.179]  - attr(*, "total_size")= num 95128
[17:45:18.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.179]  - attr(*, "already-done")= logi TRUE
[17:45:18.186] - copied ‘...future.FUN’ to environment
[17:45:18.186] - copied ‘x_FUN’ to environment
[17:45:18.186] - copied ‘times’ to environment
[17:45:18.186] - copied ‘stopf’ to environment
[17:45:18.187] - copied ‘stop_if_not’ to environment
[17:45:18.187] - copied ‘dim’ to environment
[17:45:18.187] - copied ‘valid_types’ to environment
[17:45:18.187] - copied ‘future.call.arguments’ to environment
[17:45:18.187] - copied ‘...future.elements_ii’ to environment
[17:45:18.187] - copied ‘...future.seeds_ii’ to environment
[17:45:18.187] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.187] assign_globals() ... done
[17:45:18.188] plan(): Setting new future strategy stack:
[17:45:18.188] List of future strategies:
[17:45:18.188] 1. sequential:
[17:45:18.188]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.188]    - tweaked: FALSE
[17:45:18.188]    - call: NULL
[17:45:18.188] plan(): nbrOfWorkers() = 1
[17:45:18.189] plan(): Setting new future strategy stack:
[17:45:18.189] List of future strategies:
[17:45:18.189] 1. sequential:
[17:45:18.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.189]    - tweaked: FALSE
[17:45:18.189]    - call: plan(strategy)
[17:45:18.190] plan(): nbrOfWorkers() = 1
[17:45:18.190] SequentialFuture started (and completed)
[17:45:18.190] signalConditions() ...
[17:45:18.190]  - include = ‘immediateCondition’
[17:45:18.190]  - exclude = 
[17:45:18.192]  - resignal = FALSE
[17:45:18.192]  - Number of conditions: 1
[17:45:18.192] signalConditions() ... done
[17:45:18.192] - Launch lazy future ... done
[17:45:18.192] run() for ‘SequentialFuture’ ... done
[17:45:18.192] Created future:
[17:45:18.193] SequentialFuture:
[17:45:18.193] Label: ‘future_vapply-1’
[17:45:18.193] Expression:
[17:45:18.193] {
[17:45:18.193]     do.call(function(...) {
[17:45:18.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.193]             on.exit(options(oopts), add = TRUE)
[17:45:18.193]         }
[17:45:18.193]         {
[17:45:18.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.193]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.193]             })
[17:45:18.193]         }
[17:45:18.193]     }, args = future.call.arguments)
[17:45:18.193] }
[17:45:18.193] Lazy evaluation: FALSE
[17:45:18.193] Asynchronous evaluation: FALSE
[17:45:18.193] Local evaluation: TRUE
[17:45:18.193] Environment: R_GlobalEnv
[17:45:18.193] Capture standard output: TRUE
[17:45:18.193] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.193] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.193] Packages: 1 packages (‘future.apply’)
[17:45:18.193] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.193] Resolved: TRUE
[17:45:18.193] Value: 0 bytes of class ‘NULL’
[17:45:18.193] Conditions captured: [n=1] ‘simpleError’
[17:45:18.193] Early signaling: FALSE
[17:45:18.193] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.193] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[17:45:18.194] Chunk #1 of 1 ... DONE
[17:45:18.194] Launching 1 futures (chunks) ... DONE
[17:45:18.194] Resolving 1 futures (chunks) ...
[17:45:18.194] resolve() on list ...
[17:45:18.194]  recursive: 0
[17:45:18.194]  length: 1
[17:45:18.194] 
[17:45:18.195] resolved() for ‘SequentialFuture’ ...
[17:45:18.195] - state: ‘finished’
[17:45:18.195] - run: TRUE
[17:45:18.195] - result: ‘FutureResult’
[17:45:18.195] resolved() for ‘SequentialFuture’ ... done
[17:45:18.195] Future #1
[17:45:18.195] signalConditions() ...
[17:45:18.195]  - include = ‘immediateCondition’
[17:45:18.195]  - exclude = 
[17:45:18.195]  - resignal = FALSE
[17:45:18.195]  - Number of conditions: 1
[17:45:18.196] signalConditions() ... done
[17:45:18.196] signalConditionsASAP(SequentialFuture, pos=1) ...
[17:45:18.196] - nx: 1
[17:45:18.196] - relay: TRUE
[17:45:18.196] - stdout: TRUE
[17:45:18.196] - signal: TRUE
[17:45:18.196] - resignal: FALSE
[17:45:18.196] - force: TRUE
[17:45:18.196] - relayed: [n=1] FALSE
[17:45:18.196] - queued futures: [n=1] FALSE
[17:45:18.196]  - until=1
[17:45:18.197]  - relaying element #1
[17:45:18.197] signalConditions() ...
[17:45:18.197]  - include = ‘immediateCondition’
[17:45:18.197]  - exclude = 
[17:45:18.197]  - resignal = FALSE
[17:45:18.197]  - Number of conditions: 1
[17:45:18.197] signalConditions() ... done
[17:45:18.197] signalConditions() ...
[17:45:18.197]  - include = ‘immediateCondition’
[17:45:18.197]  - exclude = 
[17:45:18.197]  - resignal = FALSE
[17:45:18.198]  - Number of conditions: 1
[17:45:18.198] signalConditions() ... done
[17:45:18.198] signalConditions() ...
[17:45:18.198]  - include = ‘condition’
[17:45:18.198]  - exclude = ‘immediateCondition’
[17:45:18.198]  - resignal = TRUE
[17:45:18.198]  - Number of conditions: 1
[17:45:18.198]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:45:18.198] signalConditions() ... done
[17:45:18.198] - relayed: [n=1] FALSE
[17:45:18.198] - queued futures: [n=1] TRUE
[17:45:18.199] signalConditionsASAP(SequentialFuture, pos=1) ... done
[17:45:18.199] plan(): Setting new future strategy stack:
[17:45:18.199] List of future strategies:
[17:45:18.199] 1. sequential:
[17:45:18.199]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.199]    - tweaked: FALSE
[17:45:18.199]    - call: plan(sequential)
[17:45:18.199] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[17:45:18.200] plan(): Setting new future strategy stack:
[17:45:18.200] List of future strategies:
[17:45:18.200] 1. multicore:
[17:45:18.200]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.200]    - tweaked: FALSE
[17:45:18.200]    - call: plan(strategy)
[17:45:18.204] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:45:18.206] future_lapply() ...
[17:45:18.211] Number of chunks: 2
[17:45:18.211] getGlobalsAndPackagesXApply() ...
[17:45:18.211]  - future.globals: TRUE
[17:45:18.212] getGlobalsAndPackages() ...
[17:45:18.212] Searching for globals...
[17:45:18.214] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:18.215] Searching for globals ... DONE
[17:45:18.215] Resolving globals: FALSE
[17:45:18.216] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:45:18.216] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.216] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.216] - packages: [1] ‘future.apply’
[17:45:18.216] getGlobalsAndPackages() ... DONE
[17:45:18.216]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.217]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.217] Finding globals ... DONE
[17:45:18.217]  - use_args: TRUE
[17:45:18.217]  - Getting '...' globals ...
[17:45:18.217] resolve() on list ...
[17:45:18.217]  recursive: 0
[17:45:18.217]  length: 1
[17:45:18.217]  elements: ‘...’
[17:45:18.218]  length: 0 (resolved future 1)
[17:45:18.218] resolve() on list ... DONE
[17:45:18.219]    - '...' content: [n=0] 
[17:45:18.219] List of 1
[17:45:18.219]  $ ...: list()
[17:45:18.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.219]  - attr(*, "where")=List of 1
[17:45:18.219]   ..$ ...:<environment: 0x5561f50a2b50> 
[17:45:18.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.219]  - attr(*, "resolved")= logi TRUE
[17:45:18.219]  - attr(*, "total_size")= num NA
[17:45:18.222]  - Getting '...' globals ... DONE
[17:45:18.222] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.222] List of 8
[17:45:18.222]  $ ...future.FUN:function (x, ...)  
[17:45:18.222]  $ x_FUN        :function (x)  
[17:45:18.222]  $ times        : int 1
[17:45:18.222]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.222]  $ stop_if_not  :function (...)  
[17:45:18.222]  $ dim          : NULL
[17:45:18.222]  $ valid_types  : chr "character"
[17:45:18.222]  $ ...          : list()
[17:45:18.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.222]  - attr(*, "where")=List of 8
[17:45:18.222]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.222]   ..$ ...          :<environment: 0x5561f50a2b50> 
[17:45:18.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.222]  - attr(*, "resolved")= logi FALSE
[17:45:18.222]  - attr(*, "total_size")= num 94208
[17:45:18.228] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.228] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.228] Number of futures (= number of chunks): 2
[17:45:18.228] Launching 2 futures (chunks) ...
[17:45:18.228] Chunk #1 of 2 ...
[17:45:18.228]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.228] getGlobalsAndPackages() ...
[17:45:18.228] Searching for globals...
[17:45:18.229] 
[17:45:18.229] Searching for globals ... DONE
[17:45:18.229] - globals: [0] <none>
[17:45:18.229] getGlobalsAndPackages() ... DONE
[17:45:18.229]    + additional globals found: [n=0] 
[17:45:18.229]    + additional namespaces needed: [n=0] 
[17:45:18.229]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.229]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.229]  - seeds: <none>
[17:45:18.229]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.230] getGlobalsAndPackages() ...
[17:45:18.230] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.230] Resolving globals: FALSE
[17:45:18.230] Tweak future expression to call with '...' arguments ...
[17:45:18.230] {
[17:45:18.230]     do.call(function(...) {
[17:45:18.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.230]             on.exit(options(oopts), add = TRUE)
[17:45:18.230]         }
[17:45:18.230]         {
[17:45:18.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.230]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.230]             })
[17:45:18.230]         }
[17:45:18.230]     }, args = future.call.arguments)
[17:45:18.230] }
[17:45:18.230] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.231] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.231] - packages: [1] ‘future.apply’
[17:45:18.231] getGlobalsAndPackages() ... DONE
[17:45:18.231] run() for ‘Future’ ...
[17:45:18.231] - state: ‘created’
[17:45:18.231] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.235] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.235] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.235]   - Field: ‘label’
[17:45:18.235]   - Field: ‘local’
[17:45:18.235]   - Field: ‘owner’
[17:45:18.236]   - Field: ‘envir’
[17:45:18.236]   - Field: ‘workers’
[17:45:18.236]   - Field: ‘packages’
[17:45:18.236]   - Field: ‘gc’
[17:45:18.236]   - Field: ‘job’
[17:45:18.236]   - Field: ‘conditions’
[17:45:18.236]   - Field: ‘expr’
[17:45:18.236]   - Field: ‘uuid’
[17:45:18.236]   - Field: ‘seed’
[17:45:18.236]   - Field: ‘version’
[17:45:18.236]   - Field: ‘result’
[17:45:18.236]   - Field: ‘asynchronous’
[17:45:18.237]   - Field: ‘calls’
[17:45:18.237]   - Field: ‘globals’
[17:45:18.237]   - Field: ‘stdout’
[17:45:18.237]   - Field: ‘earlySignal’
[17:45:18.237]   - Field: ‘lazy’
[17:45:18.237]   - Field: ‘state’
[17:45:18.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.237] - Launch lazy future ...
[17:45:18.238] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.238] Packages needed by future strategies (n = 0): <none>
[17:45:18.239] {
[17:45:18.239]     {
[17:45:18.239]         {
[17:45:18.239]             ...future.startTime <- base::Sys.time()
[17:45:18.239]             {
[17:45:18.239]                 {
[17:45:18.239]                   {
[17:45:18.239]                     {
[17:45:18.239]                       {
[17:45:18.239]                         base::local({
[17:45:18.239]                           has_future <- base::requireNamespace("future", 
[17:45:18.239]                             quietly = TRUE)
[17:45:18.239]                           if (has_future) {
[17:45:18.239]                             ns <- base::getNamespace("future")
[17:45:18.239]                             version <- ns[[".package"]][["version"]]
[17:45:18.239]                             if (is.null(version)) 
[17:45:18.239]                               version <- utils::packageVersion("future")
[17:45:18.239]                           }
[17:45:18.239]                           else {
[17:45:18.239]                             version <- NULL
[17:45:18.239]                           }
[17:45:18.239]                           if (!has_future || version < "1.8.0") {
[17:45:18.239]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.239]                               "", base::R.version$version.string), 
[17:45:18.239]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.239]                                 base::R.version$platform, 8 * 
[17:45:18.239]                                   base::.Machine$sizeof.pointer), 
[17:45:18.239]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.239]                                 "release", "version")], collapse = " "), 
[17:45:18.239]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.239]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.239]                               info)
[17:45:18.239]                             info <- base::paste(info, collapse = "; ")
[17:45:18.239]                             if (!has_future) {
[17:45:18.239]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.239]                                 info)
[17:45:18.239]                             }
[17:45:18.239]                             else {
[17:45:18.239]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.239]                                 info, version)
[17:45:18.239]                             }
[17:45:18.239]                             base::stop(msg)
[17:45:18.239]                           }
[17:45:18.239]                         })
[17:45:18.239]                       }
[17:45:18.239]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.239]                       base::options(mc.cores = 1L)
[17:45:18.239]                     }
[17:45:18.239]                     base::local({
[17:45:18.239]                       for (pkg in "future.apply") {
[17:45:18.239]                         base::loadNamespace(pkg)
[17:45:18.239]                         base::library(pkg, character.only = TRUE)
[17:45:18.239]                       }
[17:45:18.239]                     })
[17:45:18.239]                   }
[17:45:18.239]                   ...future.strategy.old <- future::plan("list")
[17:45:18.239]                   options(future.plan = NULL)
[17:45:18.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.239]                 }
[17:45:18.239]                 ...future.workdir <- getwd()
[17:45:18.239]             }
[17:45:18.239]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.239]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.239]         }
[17:45:18.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.239]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.239]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.239]             base::names(...future.oldOptions))
[17:45:18.239]     }
[17:45:18.239]     if (FALSE) {
[17:45:18.239]     }
[17:45:18.239]     else {
[17:45:18.239]         if (TRUE) {
[17:45:18.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.239]                 open = "w")
[17:45:18.239]         }
[17:45:18.239]         else {
[17:45:18.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.239]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.239]         }
[17:45:18.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.239]             base::sink(type = "output", split = FALSE)
[17:45:18.239]             base::close(...future.stdout)
[17:45:18.239]         }, add = TRUE)
[17:45:18.239]     }
[17:45:18.239]     ...future.frame <- base::sys.nframe()
[17:45:18.239]     ...future.conditions <- base::list()
[17:45:18.239]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.239]     if (FALSE) {
[17:45:18.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.239]     }
[17:45:18.239]     ...future.result <- base::tryCatch({
[17:45:18.239]         base::withCallingHandlers({
[17:45:18.239]             ...future.value <- base::withVisible(base::local({
[17:45:18.239]                 withCallingHandlers({
[17:45:18.239]                   {
[17:45:18.239]                     do.call(function(...) {
[17:45:18.239]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.239]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.239]                         ...future.globals.maxSize)) {
[17:45:18.239]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.239]                         on.exit(options(oopts), add = TRUE)
[17:45:18.239]                       }
[17:45:18.239]                       {
[17:45:18.239]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.239]                           FUN = function(jj) {
[17:45:18.239]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.239]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.239]                           })
[17:45:18.239]                       }
[17:45:18.239]                     }, args = future.call.arguments)
[17:45:18.239]                   }
[17:45:18.239]                 }, immediateCondition = function(cond) {
[17:45:18.239]                   save_rds <- function (object, pathname, ...) 
[17:45:18.239]                   {
[17:45:18.239]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.239]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.239]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.239]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.239]                         fi_tmp[["mtime"]])
[17:45:18.239]                     }
[17:45:18.239]                     tryCatch({
[17:45:18.239]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.239]                     }, error = function(ex) {
[17:45:18.239]                       msg <- conditionMessage(ex)
[17:45:18.239]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.239]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.239]                         fi_tmp[["mtime"]], msg)
[17:45:18.239]                       ex$message <- msg
[17:45:18.239]                       stop(ex)
[17:45:18.239]                     })
[17:45:18.239]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.239]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.239]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.239]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.239]                       fi <- file.info(pathname)
[17:45:18.239]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.239]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.239]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.239]                         fi[["size"]], fi[["mtime"]])
[17:45:18.239]                       stop(msg)
[17:45:18.239]                     }
[17:45:18.239]                     invisible(pathname)
[17:45:18.239]                   }
[17:45:18.239]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.239]                     rootPath = tempdir()) 
[17:45:18.239]                   {
[17:45:18.239]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.239]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.239]                       tmpdir = path, fileext = ".rds")
[17:45:18.239]                     save_rds(obj, file)
[17:45:18.239]                   }
[17:45:18.239]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.239]                   {
[17:45:18.239]                     inherits <- base::inherits
[17:45:18.239]                     invokeRestart <- base::invokeRestart
[17:45:18.239]                     is.null <- base::is.null
[17:45:18.239]                     muffled <- FALSE
[17:45:18.239]                     if (inherits(cond, "message")) {
[17:45:18.239]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.239]                       if (muffled) 
[17:45:18.239]                         invokeRestart("muffleMessage")
[17:45:18.239]                     }
[17:45:18.239]                     else if (inherits(cond, "warning")) {
[17:45:18.239]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.239]                       if (muffled) 
[17:45:18.239]                         invokeRestart("muffleWarning")
[17:45:18.239]                     }
[17:45:18.239]                     else if (inherits(cond, "condition")) {
[17:45:18.239]                       if (!is.null(pattern)) {
[17:45:18.239]                         computeRestarts <- base::computeRestarts
[17:45:18.239]                         grepl <- base::grepl
[17:45:18.239]                         restarts <- computeRestarts(cond)
[17:45:18.239]                         for (restart in restarts) {
[17:45:18.239]                           name <- restart$name
[17:45:18.239]                           if (is.null(name)) 
[17:45:18.239]                             next
[17:45:18.239]                           if (!grepl(pattern, name)) 
[17:45:18.239]                             next
[17:45:18.239]                           invokeRestart(restart)
[17:45:18.239]                           muffled <- TRUE
[17:45:18.239]                           break
[17:45:18.239]                         }
[17:45:18.239]                       }
[17:45:18.239]                     }
[17:45:18.239]                     invisible(muffled)
[17:45:18.239]                   }
[17:45:18.239]                   muffleCondition(cond)
[17:45:18.239]                 })
[17:45:18.239]             }))
[17:45:18.239]             future::FutureResult(value = ...future.value$value, 
[17:45:18.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.239]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.239]                     ...future.globalenv.names))
[17:45:18.239]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.239]         }, condition = base::local({
[17:45:18.239]             c <- base::c
[17:45:18.239]             inherits <- base::inherits
[17:45:18.239]             invokeRestart <- base::invokeRestart
[17:45:18.239]             length <- base::length
[17:45:18.239]             list <- base::list
[17:45:18.239]             seq.int <- base::seq.int
[17:45:18.239]             signalCondition <- base::signalCondition
[17:45:18.239]             sys.calls <- base::sys.calls
[17:45:18.239]             `[[` <- base::`[[`
[17:45:18.239]             `+` <- base::`+`
[17:45:18.239]             `<<-` <- base::`<<-`
[17:45:18.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.239]                   3L)]
[17:45:18.239]             }
[17:45:18.239]             function(cond) {
[17:45:18.239]                 is_error <- inherits(cond, "error")
[17:45:18.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.239]                   NULL)
[17:45:18.239]                 if (is_error) {
[17:45:18.239]                   sessionInformation <- function() {
[17:45:18.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.239]                       search = base::search(), system = base::Sys.info())
[17:45:18.239]                   }
[17:45:18.239]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.239]                     cond$call), session = sessionInformation(), 
[17:45:18.239]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.239]                   signalCondition(cond)
[17:45:18.239]                 }
[17:45:18.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.239]                 "immediateCondition"))) {
[17:45:18.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.239]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.239]                   if (TRUE && !signal) {
[17:45:18.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.239]                     {
[17:45:18.239]                       inherits <- base::inherits
[17:45:18.239]                       invokeRestart <- base::invokeRestart
[17:45:18.239]                       is.null <- base::is.null
[17:45:18.239]                       muffled <- FALSE
[17:45:18.239]                       if (inherits(cond, "message")) {
[17:45:18.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.239]                         if (muffled) 
[17:45:18.239]                           invokeRestart("muffleMessage")
[17:45:18.239]                       }
[17:45:18.239]                       else if (inherits(cond, "warning")) {
[17:45:18.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.239]                         if (muffled) 
[17:45:18.239]                           invokeRestart("muffleWarning")
[17:45:18.239]                       }
[17:45:18.239]                       else if (inherits(cond, "condition")) {
[17:45:18.239]                         if (!is.null(pattern)) {
[17:45:18.239]                           computeRestarts <- base::computeRestarts
[17:45:18.239]                           grepl <- base::grepl
[17:45:18.239]                           restarts <- computeRestarts(cond)
[17:45:18.239]                           for (restart in restarts) {
[17:45:18.239]                             name <- restart$name
[17:45:18.239]                             if (is.null(name)) 
[17:45:18.239]                               next
[17:45:18.239]                             if (!grepl(pattern, name)) 
[17:45:18.239]                               next
[17:45:18.239]                             invokeRestart(restart)
[17:45:18.239]                             muffled <- TRUE
[17:45:18.239]                             break
[17:45:18.239]                           }
[17:45:18.239]                         }
[17:45:18.239]                       }
[17:45:18.239]                       invisible(muffled)
[17:45:18.239]                     }
[17:45:18.239]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.239]                   }
[17:45:18.239]                 }
[17:45:18.239]                 else {
[17:45:18.239]                   if (TRUE) {
[17:45:18.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.239]                     {
[17:45:18.239]                       inherits <- base::inherits
[17:45:18.239]                       invokeRestart <- base::invokeRestart
[17:45:18.239]                       is.null <- base::is.null
[17:45:18.239]                       muffled <- FALSE
[17:45:18.239]                       if (inherits(cond, "message")) {
[17:45:18.239]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.239]                         if (muffled) 
[17:45:18.239]                           invokeRestart("muffleMessage")
[17:45:18.239]                       }
[17:45:18.239]                       else if (inherits(cond, "warning")) {
[17:45:18.239]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.239]                         if (muffled) 
[17:45:18.239]                           invokeRestart("muffleWarning")
[17:45:18.239]                       }
[17:45:18.239]                       else if (inherits(cond, "condition")) {
[17:45:18.239]                         if (!is.null(pattern)) {
[17:45:18.239]                           computeRestarts <- base::computeRestarts
[17:45:18.239]                           grepl <- base::grepl
[17:45:18.239]                           restarts <- computeRestarts(cond)
[17:45:18.239]                           for (restart in restarts) {
[17:45:18.239]                             name <- restart$name
[17:45:18.239]                             if (is.null(name)) 
[17:45:18.239]                               next
[17:45:18.239]                             if (!grepl(pattern, name)) 
[17:45:18.239]                               next
[17:45:18.239]                             invokeRestart(restart)
[17:45:18.239]                             muffled <- TRUE
[17:45:18.239]                             break
[17:45:18.239]                           }
[17:45:18.239]                         }
[17:45:18.239]                       }
[17:45:18.239]                       invisible(muffled)
[17:45:18.239]                     }
[17:45:18.239]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.239]                   }
[17:45:18.239]                 }
[17:45:18.239]             }
[17:45:18.239]         }))
[17:45:18.239]     }, error = function(ex) {
[17:45:18.239]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.239]                 ...future.rng), started = ...future.startTime, 
[17:45:18.239]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.239]             version = "1.8"), class = "FutureResult")
[17:45:18.239]     }, finally = {
[17:45:18.239]         if (!identical(...future.workdir, getwd())) 
[17:45:18.239]             setwd(...future.workdir)
[17:45:18.239]         {
[17:45:18.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.239]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.239]             }
[17:45:18.239]             base::options(...future.oldOptions)
[17:45:18.239]             if (.Platform$OS.type == "windows") {
[17:45:18.239]                 old_names <- names(...future.oldEnvVars)
[17:45:18.239]                 envs <- base::Sys.getenv()
[17:45:18.239]                 names <- names(envs)
[17:45:18.239]                 common <- intersect(names, old_names)
[17:45:18.239]                 added <- setdiff(names, old_names)
[17:45:18.239]                 removed <- setdiff(old_names, names)
[17:45:18.239]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.239]                   envs[common]]
[17:45:18.239]                 NAMES <- toupper(changed)
[17:45:18.239]                 args <- list()
[17:45:18.239]                 for (kk in seq_along(NAMES)) {
[17:45:18.239]                   name <- changed[[kk]]
[17:45:18.239]                   NAME <- NAMES[[kk]]
[17:45:18.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.239]                     next
[17:45:18.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.239]                 }
[17:45:18.239]                 NAMES <- toupper(added)
[17:45:18.239]                 for (kk in seq_along(NAMES)) {
[17:45:18.239]                   name <- added[[kk]]
[17:45:18.239]                   NAME <- NAMES[[kk]]
[17:45:18.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.239]                     next
[17:45:18.239]                   args[[name]] <- ""
[17:45:18.239]                 }
[17:45:18.239]                 NAMES <- toupper(removed)
[17:45:18.239]                 for (kk in seq_along(NAMES)) {
[17:45:18.239]                   name <- removed[[kk]]
[17:45:18.239]                   NAME <- NAMES[[kk]]
[17:45:18.239]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.239]                     next
[17:45:18.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.239]                 }
[17:45:18.239]                 if (length(args) > 0) 
[17:45:18.239]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.239]             }
[17:45:18.239]             else {
[17:45:18.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.239]             }
[17:45:18.239]             {
[17:45:18.239]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.239]                   0L) {
[17:45:18.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.239]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.239]                   base::options(opts)
[17:45:18.239]                 }
[17:45:18.239]                 {
[17:45:18.239]                   {
[17:45:18.239]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.239]                     NULL
[17:45:18.239]                   }
[17:45:18.239]                   options(future.plan = NULL)
[17:45:18.239]                   if (is.na(NA_character_)) 
[17:45:18.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.239]                     .init = FALSE)
[17:45:18.239]                 }
[17:45:18.239]             }
[17:45:18.239]         }
[17:45:18.239]     })
[17:45:18.239]     if (TRUE) {
[17:45:18.239]         base::sink(type = "output", split = FALSE)
[17:45:18.239]         if (TRUE) {
[17:45:18.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.239]         }
[17:45:18.239]         else {
[17:45:18.239]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.239]         }
[17:45:18.239]         base::close(...future.stdout)
[17:45:18.239]         ...future.stdout <- NULL
[17:45:18.239]     }
[17:45:18.239]     ...future.result$conditions <- ...future.conditions
[17:45:18.239]     ...future.result$finished <- base::Sys.time()
[17:45:18.239]     ...future.result
[17:45:18.239] }
[17:45:18.241] assign_globals() ...
[17:45:18.241] List of 11
[17:45:18.241]  $ ...future.FUN            :function (x, ...)  
[17:45:18.241]  $ x_FUN                    :function (x)  
[17:45:18.241]  $ times                    : int 1
[17:45:18.241]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.241]  $ stop_if_not              :function (...)  
[17:45:18.241]  $ dim                      : NULL
[17:45:18.241]  $ valid_types              : chr "character"
[17:45:18.241]  $ future.call.arguments    : list()
[17:45:18.241]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.241]  $ ...future.elements_ii    :List of 1
[17:45:18.241]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:45:18.241]  $ ...future.seeds_ii       : NULL
[17:45:18.241]  $ ...future.globals.maxSize: NULL
[17:45:18.241]  - attr(*, "where")=List of 11
[17:45:18.241]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.241]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.241]  - attr(*, "resolved")= logi FALSE
[17:45:18.241]  - attr(*, "total_size")= num 94208
[17:45:18.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.241]  - attr(*, "already-done")= logi TRUE
[17:45:18.250] - copied ‘...future.FUN’ to environment
[17:45:18.250] - copied ‘x_FUN’ to environment
[17:45:18.250] - copied ‘times’ to environment
[17:45:18.250] - copied ‘stopf’ to environment
[17:45:18.250] - copied ‘stop_if_not’ to environment
[17:45:18.251] - copied ‘dim’ to environment
[17:45:18.251] - copied ‘valid_types’ to environment
[17:45:18.251] - copied ‘future.call.arguments’ to environment
[17:45:18.251] - copied ‘...future.elements_ii’ to environment
[17:45:18.251] - copied ‘...future.seeds_ii’ to environment
[17:45:18.251] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.251] assign_globals() ... done
[17:45:18.251] requestCore(): workers = 2
[17:45:18.254] MulticoreFuture started
[17:45:18.255] - Launch lazy future ... done
[17:45:18.255] run() for ‘MulticoreFuture’ ... done
[17:45:18.255] Created future:
[17:45:18.255] plan(): Setting new future strategy stack:
[17:45:18.256] List of future strategies:
[17:45:18.256] 1. sequential:
[17:45:18.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.256]    - tweaked: FALSE
[17:45:18.256]    - call: NULL
[17:45:18.257] plan(): nbrOfWorkers() = 1
[17:45:18.259] plan(): Setting new future strategy stack:
[17:45:18.259] List of future strategies:
[17:45:18.259] 1. multicore:
[17:45:18.259]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.259]    - tweaked: FALSE
[17:45:18.259]    - call: plan(strategy)
[17:45:18.264] plan(): nbrOfWorkers() = 2
[17:45:18.256] MulticoreFuture:
[17:45:18.256] Label: ‘future_vapply-1’
[17:45:18.256] Expression:
[17:45:18.256] {
[17:45:18.256]     do.call(function(...) {
[17:45:18.256]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.256]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.256]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.256]             on.exit(options(oopts), add = TRUE)
[17:45:18.256]         }
[17:45:18.256]         {
[17:45:18.256]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.256]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.256]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.256]             })
[17:45:18.256]         }
[17:45:18.256]     }, args = future.call.arguments)
[17:45:18.256] }
[17:45:18.256] Lazy evaluation: FALSE
[17:45:18.256] Asynchronous evaluation: TRUE
[17:45:18.256] Local evaluation: TRUE
[17:45:18.256] Environment: R_GlobalEnv
[17:45:18.256] Capture standard output: TRUE
[17:45:18.256] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.256] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.256] Packages: 1 packages (‘future.apply’)
[17:45:18.256] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.256] Resolved: TRUE
[17:45:18.256] Value: <not collected>
[17:45:18.256] Conditions captured: <none>
[17:45:18.256] Early signaling: FALSE
[17:45:18.256] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.256] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.265] Chunk #1 of 2 ... DONE
[17:45:18.265] Chunk #2 of 2 ...
[17:45:18.266]  - Finding globals in 'X' for chunk #2 ...
[17:45:18.266] getGlobalsAndPackages() ...
[17:45:18.266] Searching for globals...
[17:45:18.266] 
[17:45:18.267] Searching for globals ... DONE
[17:45:18.267] - globals: [0] <none>
[17:45:18.267] getGlobalsAndPackages() ... DONE
[17:45:18.267]    + additional globals found: [n=0] 
[17:45:18.267]    + additional namespaces needed: [n=0] 
[17:45:18.267]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:18.267]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.268]  - seeds: <none>
[17:45:18.268]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.268] getGlobalsAndPackages() ...
[17:45:18.268] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.268] Resolving globals: FALSE
[17:45:18.268] Tweak future expression to call with '...' arguments ...
[17:45:18.269] {
[17:45:18.269]     do.call(function(...) {
[17:45:18.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.269]             on.exit(options(oopts), add = TRUE)
[17:45:18.269]         }
[17:45:18.269]         {
[17:45:18.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.269]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.269]             })
[17:45:18.269]         }
[17:45:18.269]     }, args = future.call.arguments)
[17:45:18.269] }
[17:45:18.269] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.270] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.270] - packages: [1] ‘future.apply’
[17:45:18.270] getGlobalsAndPackages() ... DONE
[17:45:18.271] run() for ‘Future’ ...
[17:45:18.271] - state: ‘created’
[17:45:18.271] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.276] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.276] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.276]   - Field: ‘label’
[17:45:18.276]   - Field: ‘local’
[17:45:18.276]   - Field: ‘owner’
[17:45:18.276]   - Field: ‘envir’
[17:45:18.276]   - Field: ‘workers’
[17:45:18.277]   - Field: ‘packages’
[17:45:18.277]   - Field: ‘gc’
[17:45:18.277]   - Field: ‘job’
[17:45:18.277]   - Field: ‘conditions’
[17:45:18.277]   - Field: ‘expr’
[17:45:18.277]   - Field: ‘uuid’
[17:45:18.277]   - Field: ‘seed’
[17:45:18.277]   - Field: ‘version’
[17:45:18.278]   - Field: ‘result’
[17:45:18.278]   - Field: ‘asynchronous’
[17:45:18.278]   - Field: ‘calls’
[17:45:18.278]   - Field: ‘globals’
[17:45:18.278]   - Field: ‘stdout’
[17:45:18.278]   - Field: ‘earlySignal’
[17:45:18.278]   - Field: ‘lazy’
[17:45:18.279]   - Field: ‘state’
[17:45:18.279] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.279] - Launch lazy future ...
[17:45:18.279] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.280] Packages needed by future strategies (n = 0): <none>
[17:45:18.280] {
[17:45:18.280]     {
[17:45:18.280]         {
[17:45:18.280]             ...future.startTime <- base::Sys.time()
[17:45:18.280]             {
[17:45:18.280]                 {
[17:45:18.280]                   {
[17:45:18.280]                     {
[17:45:18.280]                       {
[17:45:18.280]                         base::local({
[17:45:18.280]                           has_future <- base::requireNamespace("future", 
[17:45:18.280]                             quietly = TRUE)
[17:45:18.280]                           if (has_future) {
[17:45:18.280]                             ns <- base::getNamespace("future")
[17:45:18.280]                             version <- ns[[".package"]][["version"]]
[17:45:18.280]                             if (is.null(version)) 
[17:45:18.280]                               version <- utils::packageVersion("future")
[17:45:18.280]                           }
[17:45:18.280]                           else {
[17:45:18.280]                             version <- NULL
[17:45:18.280]                           }
[17:45:18.280]                           if (!has_future || version < "1.8.0") {
[17:45:18.280]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.280]                               "", base::R.version$version.string), 
[17:45:18.280]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.280]                                 base::R.version$platform, 8 * 
[17:45:18.280]                                   base::.Machine$sizeof.pointer), 
[17:45:18.280]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.280]                                 "release", "version")], collapse = " "), 
[17:45:18.280]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.280]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.280]                               info)
[17:45:18.280]                             info <- base::paste(info, collapse = "; ")
[17:45:18.280]                             if (!has_future) {
[17:45:18.280]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.280]                                 info)
[17:45:18.280]                             }
[17:45:18.280]                             else {
[17:45:18.280]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.280]                                 info, version)
[17:45:18.280]                             }
[17:45:18.280]                             base::stop(msg)
[17:45:18.280]                           }
[17:45:18.280]                         })
[17:45:18.280]                       }
[17:45:18.280]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.280]                       base::options(mc.cores = 1L)
[17:45:18.280]                     }
[17:45:18.280]                     base::local({
[17:45:18.280]                       for (pkg in "future.apply") {
[17:45:18.280]                         base::loadNamespace(pkg)
[17:45:18.280]                         base::library(pkg, character.only = TRUE)
[17:45:18.280]                       }
[17:45:18.280]                     })
[17:45:18.280]                   }
[17:45:18.280]                   ...future.strategy.old <- future::plan("list")
[17:45:18.280]                   options(future.plan = NULL)
[17:45:18.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.280]                 }
[17:45:18.280]                 ...future.workdir <- getwd()
[17:45:18.280]             }
[17:45:18.280]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.280]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.280]         }
[17:45:18.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.280]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.280]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.280]             base::names(...future.oldOptions))
[17:45:18.280]     }
[17:45:18.280]     if (FALSE) {
[17:45:18.280]     }
[17:45:18.280]     else {
[17:45:18.280]         if (TRUE) {
[17:45:18.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.280]                 open = "w")
[17:45:18.280]         }
[17:45:18.280]         else {
[17:45:18.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.280]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.280]         }
[17:45:18.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.280]             base::sink(type = "output", split = FALSE)
[17:45:18.280]             base::close(...future.stdout)
[17:45:18.280]         }, add = TRUE)
[17:45:18.280]     }
[17:45:18.280]     ...future.frame <- base::sys.nframe()
[17:45:18.280]     ...future.conditions <- base::list()
[17:45:18.280]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.280]     if (FALSE) {
[17:45:18.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.280]     }
[17:45:18.280]     ...future.result <- base::tryCatch({
[17:45:18.280]         base::withCallingHandlers({
[17:45:18.280]             ...future.value <- base::withVisible(base::local({
[17:45:18.280]                 withCallingHandlers({
[17:45:18.280]                   {
[17:45:18.280]                     do.call(function(...) {
[17:45:18.280]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.280]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.280]                         ...future.globals.maxSize)) {
[17:45:18.280]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.280]                         on.exit(options(oopts), add = TRUE)
[17:45:18.280]                       }
[17:45:18.280]                       {
[17:45:18.280]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.280]                           FUN = function(jj) {
[17:45:18.280]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.280]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.280]                           })
[17:45:18.280]                       }
[17:45:18.280]                     }, args = future.call.arguments)
[17:45:18.280]                   }
[17:45:18.280]                 }, immediateCondition = function(cond) {
[17:45:18.280]                   save_rds <- function (object, pathname, ...) 
[17:45:18.280]                   {
[17:45:18.280]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.280]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.280]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.280]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.280]                         fi_tmp[["mtime"]])
[17:45:18.280]                     }
[17:45:18.280]                     tryCatch({
[17:45:18.280]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.280]                     }, error = function(ex) {
[17:45:18.280]                       msg <- conditionMessage(ex)
[17:45:18.280]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.280]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.280]                         fi_tmp[["mtime"]], msg)
[17:45:18.280]                       ex$message <- msg
[17:45:18.280]                       stop(ex)
[17:45:18.280]                     })
[17:45:18.280]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.280]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.280]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.280]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.280]                       fi <- file.info(pathname)
[17:45:18.280]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.280]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.280]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.280]                         fi[["size"]], fi[["mtime"]])
[17:45:18.280]                       stop(msg)
[17:45:18.280]                     }
[17:45:18.280]                     invisible(pathname)
[17:45:18.280]                   }
[17:45:18.280]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.280]                     rootPath = tempdir()) 
[17:45:18.280]                   {
[17:45:18.280]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.280]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.280]                       tmpdir = path, fileext = ".rds")
[17:45:18.280]                     save_rds(obj, file)
[17:45:18.280]                   }
[17:45:18.280]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.280]                   {
[17:45:18.280]                     inherits <- base::inherits
[17:45:18.280]                     invokeRestart <- base::invokeRestart
[17:45:18.280]                     is.null <- base::is.null
[17:45:18.280]                     muffled <- FALSE
[17:45:18.280]                     if (inherits(cond, "message")) {
[17:45:18.280]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.280]                       if (muffled) 
[17:45:18.280]                         invokeRestart("muffleMessage")
[17:45:18.280]                     }
[17:45:18.280]                     else if (inherits(cond, "warning")) {
[17:45:18.280]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.280]                       if (muffled) 
[17:45:18.280]                         invokeRestart("muffleWarning")
[17:45:18.280]                     }
[17:45:18.280]                     else if (inherits(cond, "condition")) {
[17:45:18.280]                       if (!is.null(pattern)) {
[17:45:18.280]                         computeRestarts <- base::computeRestarts
[17:45:18.280]                         grepl <- base::grepl
[17:45:18.280]                         restarts <- computeRestarts(cond)
[17:45:18.280]                         for (restart in restarts) {
[17:45:18.280]                           name <- restart$name
[17:45:18.280]                           if (is.null(name)) 
[17:45:18.280]                             next
[17:45:18.280]                           if (!grepl(pattern, name)) 
[17:45:18.280]                             next
[17:45:18.280]                           invokeRestart(restart)
[17:45:18.280]                           muffled <- TRUE
[17:45:18.280]                           break
[17:45:18.280]                         }
[17:45:18.280]                       }
[17:45:18.280]                     }
[17:45:18.280]                     invisible(muffled)
[17:45:18.280]                   }
[17:45:18.280]                   muffleCondition(cond)
[17:45:18.280]                 })
[17:45:18.280]             }))
[17:45:18.280]             future::FutureResult(value = ...future.value$value, 
[17:45:18.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.280]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.280]                     ...future.globalenv.names))
[17:45:18.280]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.280]         }, condition = base::local({
[17:45:18.280]             c <- base::c
[17:45:18.280]             inherits <- base::inherits
[17:45:18.280]             invokeRestart <- base::invokeRestart
[17:45:18.280]             length <- base::length
[17:45:18.280]             list <- base::list
[17:45:18.280]             seq.int <- base::seq.int
[17:45:18.280]             signalCondition <- base::signalCondition
[17:45:18.280]             sys.calls <- base::sys.calls
[17:45:18.280]             `[[` <- base::`[[`
[17:45:18.280]             `+` <- base::`+`
[17:45:18.280]             `<<-` <- base::`<<-`
[17:45:18.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.280]                   3L)]
[17:45:18.280]             }
[17:45:18.280]             function(cond) {
[17:45:18.280]                 is_error <- inherits(cond, "error")
[17:45:18.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.280]                   NULL)
[17:45:18.280]                 if (is_error) {
[17:45:18.280]                   sessionInformation <- function() {
[17:45:18.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.280]                       search = base::search(), system = base::Sys.info())
[17:45:18.280]                   }
[17:45:18.280]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.280]                     cond$call), session = sessionInformation(), 
[17:45:18.280]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.280]                   signalCondition(cond)
[17:45:18.280]                 }
[17:45:18.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.280]                 "immediateCondition"))) {
[17:45:18.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.280]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.280]                   if (TRUE && !signal) {
[17:45:18.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.280]                     {
[17:45:18.280]                       inherits <- base::inherits
[17:45:18.280]                       invokeRestart <- base::invokeRestart
[17:45:18.280]                       is.null <- base::is.null
[17:45:18.280]                       muffled <- FALSE
[17:45:18.280]                       if (inherits(cond, "message")) {
[17:45:18.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.280]                         if (muffled) 
[17:45:18.280]                           invokeRestart("muffleMessage")
[17:45:18.280]                       }
[17:45:18.280]                       else if (inherits(cond, "warning")) {
[17:45:18.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.280]                         if (muffled) 
[17:45:18.280]                           invokeRestart("muffleWarning")
[17:45:18.280]                       }
[17:45:18.280]                       else if (inherits(cond, "condition")) {
[17:45:18.280]                         if (!is.null(pattern)) {
[17:45:18.280]                           computeRestarts <- base::computeRestarts
[17:45:18.280]                           grepl <- base::grepl
[17:45:18.280]                           restarts <- computeRestarts(cond)
[17:45:18.280]                           for (restart in restarts) {
[17:45:18.280]                             name <- restart$name
[17:45:18.280]                             if (is.null(name)) 
[17:45:18.280]                               next
[17:45:18.280]                             if (!grepl(pattern, name)) 
[17:45:18.280]                               next
[17:45:18.280]                             invokeRestart(restart)
[17:45:18.280]                             muffled <- TRUE
[17:45:18.280]                             break
[17:45:18.280]                           }
[17:45:18.280]                         }
[17:45:18.280]                       }
[17:45:18.280]                       invisible(muffled)
[17:45:18.280]                     }
[17:45:18.280]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.280]                   }
[17:45:18.280]                 }
[17:45:18.280]                 else {
[17:45:18.280]                   if (TRUE) {
[17:45:18.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.280]                     {
[17:45:18.280]                       inherits <- base::inherits
[17:45:18.280]                       invokeRestart <- base::invokeRestart
[17:45:18.280]                       is.null <- base::is.null
[17:45:18.280]                       muffled <- FALSE
[17:45:18.280]                       if (inherits(cond, "message")) {
[17:45:18.280]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.280]                         if (muffled) 
[17:45:18.280]                           invokeRestart("muffleMessage")
[17:45:18.280]                       }
[17:45:18.280]                       else if (inherits(cond, "warning")) {
[17:45:18.280]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.280]                         if (muffled) 
[17:45:18.280]                           invokeRestart("muffleWarning")
[17:45:18.280]                       }
[17:45:18.280]                       else if (inherits(cond, "condition")) {
[17:45:18.280]                         if (!is.null(pattern)) {
[17:45:18.280]                           computeRestarts <- base::computeRestarts
[17:45:18.280]                           grepl <- base::grepl
[17:45:18.280]                           restarts <- computeRestarts(cond)
[17:45:18.280]                           for (restart in restarts) {
[17:45:18.280]                             name <- restart$name
[17:45:18.280]                             if (is.null(name)) 
[17:45:18.280]                               next
[17:45:18.280]                             if (!grepl(pattern, name)) 
[17:45:18.280]                               next
[17:45:18.280]                             invokeRestart(restart)
[17:45:18.280]                             muffled <- TRUE
[17:45:18.280]                             break
[17:45:18.280]                           }
[17:45:18.280]                         }
[17:45:18.280]                       }
[17:45:18.280]                       invisible(muffled)
[17:45:18.280]                     }
[17:45:18.280]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.280]                   }
[17:45:18.280]                 }
[17:45:18.280]             }
[17:45:18.280]         }))
[17:45:18.280]     }, error = function(ex) {
[17:45:18.280]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.280]                 ...future.rng), started = ...future.startTime, 
[17:45:18.280]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.280]             version = "1.8"), class = "FutureResult")
[17:45:18.280]     }, finally = {
[17:45:18.280]         if (!identical(...future.workdir, getwd())) 
[17:45:18.280]             setwd(...future.workdir)
[17:45:18.280]         {
[17:45:18.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.280]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.280]             }
[17:45:18.280]             base::options(...future.oldOptions)
[17:45:18.280]             if (.Platform$OS.type == "windows") {
[17:45:18.280]                 old_names <- names(...future.oldEnvVars)
[17:45:18.280]                 envs <- base::Sys.getenv()
[17:45:18.280]                 names <- names(envs)
[17:45:18.280]                 common <- intersect(names, old_names)
[17:45:18.280]                 added <- setdiff(names, old_names)
[17:45:18.280]                 removed <- setdiff(old_names, names)
[17:45:18.280]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.280]                   envs[common]]
[17:45:18.280]                 NAMES <- toupper(changed)
[17:45:18.280]                 args <- list()
[17:45:18.280]                 for (kk in seq_along(NAMES)) {
[17:45:18.280]                   name <- changed[[kk]]
[17:45:18.280]                   NAME <- NAMES[[kk]]
[17:45:18.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.280]                     next
[17:45:18.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.280]                 }
[17:45:18.280]                 NAMES <- toupper(added)
[17:45:18.280]                 for (kk in seq_along(NAMES)) {
[17:45:18.280]                   name <- added[[kk]]
[17:45:18.280]                   NAME <- NAMES[[kk]]
[17:45:18.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.280]                     next
[17:45:18.280]                   args[[name]] <- ""
[17:45:18.280]                 }
[17:45:18.280]                 NAMES <- toupper(removed)
[17:45:18.280]                 for (kk in seq_along(NAMES)) {
[17:45:18.280]                   name <- removed[[kk]]
[17:45:18.280]                   NAME <- NAMES[[kk]]
[17:45:18.280]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.280]                     next
[17:45:18.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.280]                 }
[17:45:18.280]                 if (length(args) > 0) 
[17:45:18.280]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.280]             }
[17:45:18.280]             else {
[17:45:18.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.280]             }
[17:45:18.280]             {
[17:45:18.280]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.280]                   0L) {
[17:45:18.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.280]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.280]                   base::options(opts)
[17:45:18.280]                 }
[17:45:18.280]                 {
[17:45:18.280]                   {
[17:45:18.280]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.280]                     NULL
[17:45:18.280]                   }
[17:45:18.280]                   options(future.plan = NULL)
[17:45:18.280]                   if (is.na(NA_character_)) 
[17:45:18.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.280]                     .init = FALSE)
[17:45:18.280]                 }
[17:45:18.280]             }
[17:45:18.280]         }
[17:45:18.280]     })
[17:45:18.280]     if (TRUE) {
[17:45:18.280]         base::sink(type = "output", split = FALSE)
[17:45:18.280]         if (TRUE) {
[17:45:18.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.280]         }
[17:45:18.280]         else {
[17:45:18.280]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.280]         }
[17:45:18.280]         base::close(...future.stdout)
[17:45:18.280]         ...future.stdout <- NULL
[17:45:18.280]     }
[17:45:18.280]     ...future.result$conditions <- ...future.conditions
[17:45:18.280]     ...future.result$finished <- base::Sys.time()
[17:45:18.280]     ...future.result
[17:45:18.280] }
[17:45:18.284] assign_globals() ...
[17:45:18.284] List of 11
[17:45:18.284]  $ ...future.FUN            :function (x, ...)  
[17:45:18.284]  $ x_FUN                    :function (x)  
[17:45:18.284]  $ times                    : int 1
[17:45:18.284]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.284]  $ stop_if_not              :function (...)  
[17:45:18.284]  $ dim                      : NULL
[17:45:18.284]  $ valid_types              : chr "character"
[17:45:18.284]  $ future.call.arguments    : list()
[17:45:18.284]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.284]  $ ...future.elements_ii    :List of 1
[17:45:18.284]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[17:45:18.284]  $ ...future.seeds_ii       : NULL
[17:45:18.284]  $ ...future.globals.maxSize: NULL
[17:45:18.284]  - attr(*, "where")=List of 11
[17:45:18.284]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.284]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.284]  - attr(*, "resolved")= logi FALSE
[17:45:18.284]  - attr(*, "total_size")= num 94208
[17:45:18.284]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.284]  - attr(*, "already-done")= logi TRUE
[17:45:18.299] - copied ‘...future.FUN’ to environment
[17:45:18.299] - copied ‘x_FUN’ to environment
[17:45:18.299] - copied ‘times’ to environment
[17:45:18.299] - copied ‘stopf’ to environment
[17:45:18.299] - copied ‘stop_if_not’ to environment
[17:45:18.299] - copied ‘dim’ to environment
[17:45:18.300] - copied ‘valid_types’ to environment
[17:45:18.300] - copied ‘future.call.arguments’ to environment
[17:45:18.300] - copied ‘...future.elements_ii’ to environment
[17:45:18.300] - copied ‘...future.seeds_ii’ to environment
[17:45:18.300] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.300] assign_globals() ... done
[17:45:18.300] requestCore(): workers = 2
[17:45:18.305] MulticoreFuture started
[17:45:18.306] - Launch lazy future ... done
[17:45:18.306] run() for ‘MulticoreFuture’ ... done
[17:45:18.306] Created future:
[17:45:18.307] plan(): Setting new future strategy stack:
[17:45:18.307] List of future strategies:
[17:45:18.307] 1. sequential:
[17:45:18.307]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.307]    - tweaked: FALSE
[17:45:18.307]    - call: NULL
[17:45:18.308] plan(): nbrOfWorkers() = 1
[17:45:18.310] plan(): Setting new future strategy stack:
[17:45:18.310] List of future strategies:
[17:45:18.310] 1. multicore:
[17:45:18.310]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.310]    - tweaked: FALSE
[17:45:18.310]    - call: plan(strategy)
[17:45:18.315] plan(): nbrOfWorkers() = 2
[17:45:18.306] MulticoreFuture:
[17:45:18.306] Label: ‘future_vapply-2’
[17:45:18.306] Expression:
[17:45:18.306] {
[17:45:18.306]     do.call(function(...) {
[17:45:18.306]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.306]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.306]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.306]             on.exit(options(oopts), add = TRUE)
[17:45:18.306]         }
[17:45:18.306]         {
[17:45:18.306]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.306]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.306]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.306]             })
[17:45:18.306]         }
[17:45:18.306]     }, args = future.call.arguments)
[17:45:18.306] }
[17:45:18.306] Lazy evaluation: FALSE
[17:45:18.306] Asynchronous evaluation: TRUE
[17:45:18.306] Local evaluation: TRUE
[17:45:18.306] Environment: R_GlobalEnv
[17:45:18.306] Capture standard output: TRUE
[17:45:18.306] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.306] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.306] Packages: 1 packages (‘future.apply’)
[17:45:18.306] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.306] Resolved: TRUE
[17:45:18.306] Value: <not collected>
[17:45:18.306] Conditions captured: <none>
[17:45:18.306] Early signaling: FALSE
[17:45:18.306] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.306] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.316] Chunk #2 of 2 ... DONE
[17:45:18.316] Launching 2 futures (chunks) ... DONE
[17:45:18.316] Resolving 2 futures (chunks) ...
[17:45:18.317] resolve() on list ...
[17:45:18.317]  recursive: 0
[17:45:18.317]  length: 2
[17:45:18.317] 
[17:45:18.317] Future #1
[17:45:18.318] result() for MulticoreFuture ...
[17:45:18.320] result() for MulticoreFuture ...
[17:45:18.320] result() for MulticoreFuture ... done
[17:45:18.320] result() for MulticoreFuture ... done
[17:45:18.320] result() for MulticoreFuture ...
[17:45:18.320] result() for MulticoreFuture ... done
[17:45:18.320] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:18.321] - nx: 2
[17:45:18.321] - relay: TRUE
[17:45:18.321] - stdout: TRUE
[17:45:18.321] - signal: TRUE
[17:45:18.321] - resignal: FALSE
[17:45:18.321] - force: TRUE
[17:45:18.321] - relayed: [n=2] FALSE, FALSE
[17:45:18.322] - queued futures: [n=2] FALSE, FALSE
[17:45:18.322]  - until=1
[17:45:18.322]  - relaying element #1
[17:45:18.322] result() for MulticoreFuture ...
[17:45:18.322] result() for MulticoreFuture ... done
[17:45:18.322] result() for MulticoreFuture ...
[17:45:18.322] result() for MulticoreFuture ... done
[17:45:18.323] result() for MulticoreFuture ...
[17:45:18.323] result() for MulticoreFuture ... done
[17:45:18.323] result() for MulticoreFuture ...
[17:45:18.323] result() for MulticoreFuture ... done
[17:45:18.323] - relayed: [n=2] TRUE, FALSE
[17:45:18.323] - queued futures: [n=2] TRUE, FALSE
[17:45:18.323] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:18.324]  length: 1 (resolved future 1)
[17:45:18.324] Future #2
[17:45:18.324] result() for MulticoreFuture ...
[17:45:18.325] result() for MulticoreFuture ...
[17:45:18.325] result() for MulticoreFuture ... done
[17:45:18.325] result() for MulticoreFuture ... done
[17:45:18.325] result() for MulticoreFuture ...
[17:45:18.325] result() for MulticoreFuture ... done
[17:45:18.325] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:18.326] - nx: 2
[17:45:18.326] - relay: TRUE
[17:45:18.326] - stdout: TRUE
[17:45:18.326] - signal: TRUE
[17:45:18.326] - resignal: FALSE
[17:45:18.326] - force: TRUE
[17:45:18.326] - relayed: [n=2] TRUE, FALSE
[17:45:18.326] - queued futures: [n=2] TRUE, FALSE
[17:45:18.327]  - until=2
[17:45:18.327]  - relaying element #2
[17:45:18.327] result() for MulticoreFuture ...
[17:45:18.327] result() for MulticoreFuture ... done
[17:45:18.327] result() for MulticoreFuture ...
[17:45:18.327] result() for MulticoreFuture ... done
[17:45:18.327] result() for MulticoreFuture ...
[17:45:18.327] result() for MulticoreFuture ... done
[17:45:18.328] result() for MulticoreFuture ...
[17:45:18.328] result() for MulticoreFuture ... done
[17:45:18.328] - relayed: [n=2] TRUE, TRUE
[17:45:18.328] - queued futures: [n=2] TRUE, TRUE
[17:45:18.328] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:18.328]  length: 0 (resolved future 2)
[17:45:18.328] Relaying remaining futures
[17:45:18.328] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.328] - nx: 2
[17:45:18.329] - relay: TRUE
[17:45:18.329] - stdout: TRUE
[17:45:18.329] - signal: TRUE
[17:45:18.329] - resignal: FALSE
[17:45:18.329] - force: TRUE
[17:45:18.329] - relayed: [n=2] TRUE, TRUE
[17:45:18.329] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:18.329] - relayed: [n=2] TRUE, TRUE
[17:45:18.329] - queued futures: [n=2] TRUE, TRUE
[17:45:18.330] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.330] resolve() on list ... DONE
[17:45:18.330] result() for MulticoreFuture ...
[17:45:18.330] result() for MulticoreFuture ... done
[17:45:18.330] result() for MulticoreFuture ...
[17:45:18.330] result() for MulticoreFuture ... done
[17:45:18.330] result() for MulticoreFuture ...
[17:45:18.330] result() for MulticoreFuture ... done
[17:45:18.330] result() for MulticoreFuture ...
[17:45:18.330] result() for MulticoreFuture ... done
[17:45:18.331]  - Number of value chunks collected: 2
[17:45:18.331] Resolving 2 futures (chunks) ... DONE
[17:45:18.331] Reducing values from 2 chunks ...
[17:45:18.331]  - Number of values collected after concatenation: 2
[17:45:18.331]  - Number of values expected: 2
[17:45:18.337] Reducing values from 2 chunks ... DONE
[17:45:18.337] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:45:18.338] future_lapply() ...
[17:45:18.345] Number of chunks: 2
[17:45:18.345] getGlobalsAndPackagesXApply() ...
[17:45:18.345]  - future.globals: TRUE
[17:45:18.345] getGlobalsAndPackages() ...
[17:45:18.345] Searching for globals...
[17:45:18.349] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:45:18.349] Searching for globals ... DONE
[17:45:18.349] Resolving globals: FALSE
[17:45:18.350] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:45:18.351] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.351] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.351] - packages: [1] ‘future.apply’
[17:45:18.351] getGlobalsAndPackages() ... DONE
[17:45:18.351]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.351]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.351] Finding globals ... DONE
[17:45:18.352]  - use_args: TRUE
[17:45:18.352]  - Getting '...' globals ...
[17:45:18.352] resolve() on list ...
[17:45:18.352]  recursive: 0
[17:45:18.352]  length: 1
[17:45:18.352]  elements: ‘...’
[17:45:18.352]  length: 0 (resolved future 1)
[17:45:18.352] resolve() on list ... DONE
[17:45:18.353]    - '...' content: [n=0] 
[17:45:18.353] List of 1
[17:45:18.353]  $ ...: list()
[17:45:18.353]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.353]  - attr(*, "where")=List of 1
[17:45:18.353]   ..$ ...:<environment: 0x5561f3e75b20> 
[17:45:18.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.353]  - attr(*, "resolved")= logi TRUE
[17:45:18.353]  - attr(*, "total_size")= num NA
[17:45:18.355]  - Getting '...' globals ... DONE
[17:45:18.355] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.356] List of 8
[17:45:18.356]  $ ...future.FUN:function (x, ...)  
[17:45:18.356]  $ x_FUN        :function (x)  
[17:45:18.356]  $ times        : int 0
[17:45:18.356]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.356]  $ stop_if_not  :function (...)  
[17:45:18.356]  $ dim          : NULL
[17:45:18.356]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:18.356]  $ ...          : list()
[17:45:18.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.356]  - attr(*, "where")=List of 8
[17:45:18.356]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.356]   ..$ ...          :<environment: 0x5561f3e75b20> 
[17:45:18.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.356]  - attr(*, "resolved")= logi FALSE
[17:45:18.356]  - attr(*, "total_size")= num 95472
[17:45:18.361] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.361] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.361] Number of futures (= number of chunks): 2
[17:45:18.361] Launching 2 futures (chunks) ...
[17:45:18.361] Chunk #1 of 2 ...
[17:45:18.361]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.362] getGlobalsAndPackages() ...
[17:45:18.362] Searching for globals...
[17:45:18.362] 
[17:45:18.364] Searching for globals ... DONE
[17:45:18.364] - globals: [0] <none>
[17:45:18.364] getGlobalsAndPackages() ... DONE
[17:45:18.364]    + additional globals found: [n=0] 
[17:45:18.364]    + additional namespaces needed: [n=0] 
[17:45:18.364]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.364]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.364]  - seeds: <none>
[17:45:18.364]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.365] getGlobalsAndPackages() ...
[17:45:18.365] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.365] Resolving globals: FALSE
[17:45:18.365] Tweak future expression to call with '...' arguments ...
[17:45:18.365] {
[17:45:18.365]     do.call(function(...) {
[17:45:18.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.365]             on.exit(options(oopts), add = TRUE)
[17:45:18.365]         }
[17:45:18.365]         {
[17:45:18.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.365]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.365]             })
[17:45:18.365]         }
[17:45:18.365]     }, args = future.call.arguments)
[17:45:18.365] }
[17:45:18.365] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.366] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.366] - packages: [1] ‘future.apply’
[17:45:18.366] getGlobalsAndPackages() ... DONE
[17:45:18.367] run() for ‘Future’ ...
[17:45:18.367] - state: ‘created’
[17:45:18.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.371]   - Field: ‘label’
[17:45:18.371]   - Field: ‘local’
[17:45:18.371]   - Field: ‘owner’
[17:45:18.371]   - Field: ‘envir’
[17:45:18.371]   - Field: ‘workers’
[17:45:18.371]   - Field: ‘packages’
[17:45:18.371]   - Field: ‘gc’
[17:45:18.371]   - Field: ‘job’
[17:45:18.372]   - Field: ‘conditions’
[17:45:18.372]   - Field: ‘expr’
[17:45:18.372]   - Field: ‘uuid’
[17:45:18.372]   - Field: ‘seed’
[17:45:18.372]   - Field: ‘version’
[17:45:18.372]   - Field: ‘result’
[17:45:18.372]   - Field: ‘asynchronous’
[17:45:18.372]   - Field: ‘calls’
[17:45:18.372]   - Field: ‘globals’
[17:45:18.372]   - Field: ‘stdout’
[17:45:18.372]   - Field: ‘earlySignal’
[17:45:18.373]   - Field: ‘lazy’
[17:45:18.373]   - Field: ‘state’
[17:45:18.373] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.373] - Launch lazy future ...
[17:45:18.373] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.373] Packages needed by future strategies (n = 0): <none>
[17:45:18.374] {
[17:45:18.374]     {
[17:45:18.374]         {
[17:45:18.374]             ...future.startTime <- base::Sys.time()
[17:45:18.374]             {
[17:45:18.374]                 {
[17:45:18.374]                   {
[17:45:18.374]                     {
[17:45:18.374]                       {
[17:45:18.374]                         base::local({
[17:45:18.374]                           has_future <- base::requireNamespace("future", 
[17:45:18.374]                             quietly = TRUE)
[17:45:18.374]                           if (has_future) {
[17:45:18.374]                             ns <- base::getNamespace("future")
[17:45:18.374]                             version <- ns[[".package"]][["version"]]
[17:45:18.374]                             if (is.null(version)) 
[17:45:18.374]                               version <- utils::packageVersion("future")
[17:45:18.374]                           }
[17:45:18.374]                           else {
[17:45:18.374]                             version <- NULL
[17:45:18.374]                           }
[17:45:18.374]                           if (!has_future || version < "1.8.0") {
[17:45:18.374]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.374]                               "", base::R.version$version.string), 
[17:45:18.374]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.374]                                 base::R.version$platform, 8 * 
[17:45:18.374]                                   base::.Machine$sizeof.pointer), 
[17:45:18.374]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.374]                                 "release", "version")], collapse = " "), 
[17:45:18.374]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.374]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.374]                               info)
[17:45:18.374]                             info <- base::paste(info, collapse = "; ")
[17:45:18.374]                             if (!has_future) {
[17:45:18.374]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.374]                                 info)
[17:45:18.374]                             }
[17:45:18.374]                             else {
[17:45:18.374]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.374]                                 info, version)
[17:45:18.374]                             }
[17:45:18.374]                             base::stop(msg)
[17:45:18.374]                           }
[17:45:18.374]                         })
[17:45:18.374]                       }
[17:45:18.374]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.374]                       base::options(mc.cores = 1L)
[17:45:18.374]                     }
[17:45:18.374]                     base::local({
[17:45:18.374]                       for (pkg in "future.apply") {
[17:45:18.374]                         base::loadNamespace(pkg)
[17:45:18.374]                         base::library(pkg, character.only = TRUE)
[17:45:18.374]                       }
[17:45:18.374]                     })
[17:45:18.374]                   }
[17:45:18.374]                   ...future.strategy.old <- future::plan("list")
[17:45:18.374]                   options(future.plan = NULL)
[17:45:18.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.374]                 }
[17:45:18.374]                 ...future.workdir <- getwd()
[17:45:18.374]             }
[17:45:18.374]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.374]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.374]         }
[17:45:18.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.374]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.374]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.374]             base::names(...future.oldOptions))
[17:45:18.374]     }
[17:45:18.374]     if (FALSE) {
[17:45:18.374]     }
[17:45:18.374]     else {
[17:45:18.374]         if (TRUE) {
[17:45:18.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.374]                 open = "w")
[17:45:18.374]         }
[17:45:18.374]         else {
[17:45:18.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.374]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.374]         }
[17:45:18.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.374]             base::sink(type = "output", split = FALSE)
[17:45:18.374]             base::close(...future.stdout)
[17:45:18.374]         }, add = TRUE)
[17:45:18.374]     }
[17:45:18.374]     ...future.frame <- base::sys.nframe()
[17:45:18.374]     ...future.conditions <- base::list()
[17:45:18.374]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.374]     if (FALSE) {
[17:45:18.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.374]     }
[17:45:18.374]     ...future.result <- base::tryCatch({
[17:45:18.374]         base::withCallingHandlers({
[17:45:18.374]             ...future.value <- base::withVisible(base::local({
[17:45:18.374]                 withCallingHandlers({
[17:45:18.374]                   {
[17:45:18.374]                     do.call(function(...) {
[17:45:18.374]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.374]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.374]                         ...future.globals.maxSize)) {
[17:45:18.374]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.374]                         on.exit(options(oopts), add = TRUE)
[17:45:18.374]                       }
[17:45:18.374]                       {
[17:45:18.374]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.374]                           FUN = function(jj) {
[17:45:18.374]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.374]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.374]                           })
[17:45:18.374]                       }
[17:45:18.374]                     }, args = future.call.arguments)
[17:45:18.374]                   }
[17:45:18.374]                 }, immediateCondition = function(cond) {
[17:45:18.374]                   save_rds <- function (object, pathname, ...) 
[17:45:18.374]                   {
[17:45:18.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.374]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.374]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.374]                         fi_tmp[["mtime"]])
[17:45:18.374]                     }
[17:45:18.374]                     tryCatch({
[17:45:18.374]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.374]                     }, error = function(ex) {
[17:45:18.374]                       msg <- conditionMessage(ex)
[17:45:18.374]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.374]                         fi_tmp[["mtime"]], msg)
[17:45:18.374]                       ex$message <- msg
[17:45:18.374]                       stop(ex)
[17:45:18.374]                     })
[17:45:18.374]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.374]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.374]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.374]                       fi <- file.info(pathname)
[17:45:18.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.374]                         fi[["size"]], fi[["mtime"]])
[17:45:18.374]                       stop(msg)
[17:45:18.374]                     }
[17:45:18.374]                     invisible(pathname)
[17:45:18.374]                   }
[17:45:18.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.374]                     rootPath = tempdir()) 
[17:45:18.374]                   {
[17:45:18.374]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.374]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.374]                       tmpdir = path, fileext = ".rds")
[17:45:18.374]                     save_rds(obj, file)
[17:45:18.374]                   }
[17:45:18.374]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.374]                   {
[17:45:18.374]                     inherits <- base::inherits
[17:45:18.374]                     invokeRestart <- base::invokeRestart
[17:45:18.374]                     is.null <- base::is.null
[17:45:18.374]                     muffled <- FALSE
[17:45:18.374]                     if (inherits(cond, "message")) {
[17:45:18.374]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.374]                       if (muffled) 
[17:45:18.374]                         invokeRestart("muffleMessage")
[17:45:18.374]                     }
[17:45:18.374]                     else if (inherits(cond, "warning")) {
[17:45:18.374]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.374]                       if (muffled) 
[17:45:18.374]                         invokeRestart("muffleWarning")
[17:45:18.374]                     }
[17:45:18.374]                     else if (inherits(cond, "condition")) {
[17:45:18.374]                       if (!is.null(pattern)) {
[17:45:18.374]                         computeRestarts <- base::computeRestarts
[17:45:18.374]                         grepl <- base::grepl
[17:45:18.374]                         restarts <- computeRestarts(cond)
[17:45:18.374]                         for (restart in restarts) {
[17:45:18.374]                           name <- restart$name
[17:45:18.374]                           if (is.null(name)) 
[17:45:18.374]                             next
[17:45:18.374]                           if (!grepl(pattern, name)) 
[17:45:18.374]                             next
[17:45:18.374]                           invokeRestart(restart)
[17:45:18.374]                           muffled <- TRUE
[17:45:18.374]                           break
[17:45:18.374]                         }
[17:45:18.374]                       }
[17:45:18.374]                     }
[17:45:18.374]                     invisible(muffled)
[17:45:18.374]                   }
[17:45:18.374]                   muffleCondition(cond)
[17:45:18.374]                 })
[17:45:18.374]             }))
[17:45:18.374]             future::FutureResult(value = ...future.value$value, 
[17:45:18.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.374]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.374]                     ...future.globalenv.names))
[17:45:18.374]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.374]         }, condition = base::local({
[17:45:18.374]             c <- base::c
[17:45:18.374]             inherits <- base::inherits
[17:45:18.374]             invokeRestart <- base::invokeRestart
[17:45:18.374]             length <- base::length
[17:45:18.374]             list <- base::list
[17:45:18.374]             seq.int <- base::seq.int
[17:45:18.374]             signalCondition <- base::signalCondition
[17:45:18.374]             sys.calls <- base::sys.calls
[17:45:18.374]             `[[` <- base::`[[`
[17:45:18.374]             `+` <- base::`+`
[17:45:18.374]             `<<-` <- base::`<<-`
[17:45:18.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.374]                   3L)]
[17:45:18.374]             }
[17:45:18.374]             function(cond) {
[17:45:18.374]                 is_error <- inherits(cond, "error")
[17:45:18.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.374]                   NULL)
[17:45:18.374]                 if (is_error) {
[17:45:18.374]                   sessionInformation <- function() {
[17:45:18.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.374]                       search = base::search(), system = base::Sys.info())
[17:45:18.374]                   }
[17:45:18.374]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.374]                     cond$call), session = sessionInformation(), 
[17:45:18.374]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.374]                   signalCondition(cond)
[17:45:18.374]                 }
[17:45:18.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.374]                 "immediateCondition"))) {
[17:45:18.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.374]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.374]                   if (TRUE && !signal) {
[17:45:18.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.374]                     {
[17:45:18.374]                       inherits <- base::inherits
[17:45:18.374]                       invokeRestart <- base::invokeRestart
[17:45:18.374]                       is.null <- base::is.null
[17:45:18.374]                       muffled <- FALSE
[17:45:18.374]                       if (inherits(cond, "message")) {
[17:45:18.374]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.374]                         if (muffled) 
[17:45:18.374]                           invokeRestart("muffleMessage")
[17:45:18.374]                       }
[17:45:18.374]                       else if (inherits(cond, "warning")) {
[17:45:18.374]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.374]                         if (muffled) 
[17:45:18.374]                           invokeRestart("muffleWarning")
[17:45:18.374]                       }
[17:45:18.374]                       else if (inherits(cond, "condition")) {
[17:45:18.374]                         if (!is.null(pattern)) {
[17:45:18.374]                           computeRestarts <- base::computeRestarts
[17:45:18.374]                           grepl <- base::grepl
[17:45:18.374]                           restarts <- computeRestarts(cond)
[17:45:18.374]                           for (restart in restarts) {
[17:45:18.374]                             name <- restart$name
[17:45:18.374]                             if (is.null(name)) 
[17:45:18.374]                               next
[17:45:18.374]                             if (!grepl(pattern, name)) 
[17:45:18.374]                               next
[17:45:18.374]                             invokeRestart(restart)
[17:45:18.374]                             muffled <- TRUE
[17:45:18.374]                             break
[17:45:18.374]                           }
[17:45:18.374]                         }
[17:45:18.374]                       }
[17:45:18.374]                       invisible(muffled)
[17:45:18.374]                     }
[17:45:18.374]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.374]                   }
[17:45:18.374]                 }
[17:45:18.374]                 else {
[17:45:18.374]                   if (TRUE) {
[17:45:18.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.374]                     {
[17:45:18.374]                       inherits <- base::inherits
[17:45:18.374]                       invokeRestart <- base::invokeRestart
[17:45:18.374]                       is.null <- base::is.null
[17:45:18.374]                       muffled <- FALSE
[17:45:18.374]                       if (inherits(cond, "message")) {
[17:45:18.374]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.374]                         if (muffled) 
[17:45:18.374]                           invokeRestart("muffleMessage")
[17:45:18.374]                       }
[17:45:18.374]                       else if (inherits(cond, "warning")) {
[17:45:18.374]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.374]                         if (muffled) 
[17:45:18.374]                           invokeRestart("muffleWarning")
[17:45:18.374]                       }
[17:45:18.374]                       else if (inherits(cond, "condition")) {
[17:45:18.374]                         if (!is.null(pattern)) {
[17:45:18.374]                           computeRestarts <- base::computeRestarts
[17:45:18.374]                           grepl <- base::grepl
[17:45:18.374]                           restarts <- computeRestarts(cond)
[17:45:18.374]                           for (restart in restarts) {
[17:45:18.374]                             name <- restart$name
[17:45:18.374]                             if (is.null(name)) 
[17:45:18.374]                               next
[17:45:18.374]                             if (!grepl(pattern, name)) 
[17:45:18.374]                               next
[17:45:18.374]                             invokeRestart(restart)
[17:45:18.374]                             muffled <- TRUE
[17:45:18.374]                             break
[17:45:18.374]                           }
[17:45:18.374]                         }
[17:45:18.374]                       }
[17:45:18.374]                       invisible(muffled)
[17:45:18.374]                     }
[17:45:18.374]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.374]                   }
[17:45:18.374]                 }
[17:45:18.374]             }
[17:45:18.374]         }))
[17:45:18.374]     }, error = function(ex) {
[17:45:18.374]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.374]                 ...future.rng), started = ...future.startTime, 
[17:45:18.374]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.374]             version = "1.8"), class = "FutureResult")
[17:45:18.374]     }, finally = {
[17:45:18.374]         if (!identical(...future.workdir, getwd())) 
[17:45:18.374]             setwd(...future.workdir)
[17:45:18.374]         {
[17:45:18.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.374]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.374]             }
[17:45:18.374]             base::options(...future.oldOptions)
[17:45:18.374]             if (.Platform$OS.type == "windows") {
[17:45:18.374]                 old_names <- names(...future.oldEnvVars)
[17:45:18.374]                 envs <- base::Sys.getenv()
[17:45:18.374]                 names <- names(envs)
[17:45:18.374]                 common <- intersect(names, old_names)
[17:45:18.374]                 added <- setdiff(names, old_names)
[17:45:18.374]                 removed <- setdiff(old_names, names)
[17:45:18.374]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.374]                   envs[common]]
[17:45:18.374]                 NAMES <- toupper(changed)
[17:45:18.374]                 args <- list()
[17:45:18.374]                 for (kk in seq_along(NAMES)) {
[17:45:18.374]                   name <- changed[[kk]]
[17:45:18.374]                   NAME <- NAMES[[kk]]
[17:45:18.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.374]                     next
[17:45:18.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.374]                 }
[17:45:18.374]                 NAMES <- toupper(added)
[17:45:18.374]                 for (kk in seq_along(NAMES)) {
[17:45:18.374]                   name <- added[[kk]]
[17:45:18.374]                   NAME <- NAMES[[kk]]
[17:45:18.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.374]                     next
[17:45:18.374]                   args[[name]] <- ""
[17:45:18.374]                 }
[17:45:18.374]                 NAMES <- toupper(removed)
[17:45:18.374]                 for (kk in seq_along(NAMES)) {
[17:45:18.374]                   name <- removed[[kk]]
[17:45:18.374]                   NAME <- NAMES[[kk]]
[17:45:18.374]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.374]                     next
[17:45:18.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.374]                 }
[17:45:18.374]                 if (length(args) > 0) 
[17:45:18.374]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.374]             }
[17:45:18.374]             else {
[17:45:18.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.374]             }
[17:45:18.374]             {
[17:45:18.374]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.374]                   0L) {
[17:45:18.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.374]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.374]                   base::options(opts)
[17:45:18.374]                 }
[17:45:18.374]                 {
[17:45:18.374]                   {
[17:45:18.374]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.374]                     NULL
[17:45:18.374]                   }
[17:45:18.374]                   options(future.plan = NULL)
[17:45:18.374]                   if (is.na(NA_character_)) 
[17:45:18.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.374]                     .init = FALSE)
[17:45:18.374]                 }
[17:45:18.374]             }
[17:45:18.374]         }
[17:45:18.374]     })
[17:45:18.374]     if (TRUE) {
[17:45:18.374]         base::sink(type = "output", split = FALSE)
[17:45:18.374]         if (TRUE) {
[17:45:18.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.374]         }
[17:45:18.374]         else {
[17:45:18.374]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.374]         }
[17:45:18.374]         base::close(...future.stdout)
[17:45:18.374]         ...future.stdout <- NULL
[17:45:18.374]     }
[17:45:18.374]     ...future.result$conditions <- ...future.conditions
[17:45:18.374]     ...future.result$finished <- base::Sys.time()
[17:45:18.374]     ...future.result
[17:45:18.374] }
[17:45:18.376] assign_globals() ...
[17:45:18.376] List of 11
[17:45:18.376]  $ ...future.FUN            :function (x, ...)  
[17:45:18.376]  $ x_FUN                    :function (x)  
[17:45:18.376]  $ times                    : int 0
[17:45:18.376]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.376]  $ stop_if_not              :function (...)  
[17:45:18.376]  $ dim                      : NULL
[17:45:18.376]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.376]  $ future.call.arguments    : list()
[17:45:18.376]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.376]  $ ...future.elements_ii    :List of 5
[17:45:18.376]   ..$ : int 1
[17:45:18.376]   ..$ : int 2
[17:45:18.376]   ..$ : int 3
[17:45:18.376]   ..$ : int 4
[17:45:18.376]   ..$ : int 5
[17:45:18.376]  $ ...future.seeds_ii       : NULL
[17:45:18.376]  $ ...future.globals.maxSize: NULL
[17:45:18.376]  - attr(*, "where")=List of 11
[17:45:18.376]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.376]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.376]  - attr(*, "resolved")= logi FALSE
[17:45:18.376]  - attr(*, "total_size")= num 95472
[17:45:18.376]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.376]  - attr(*, "already-done")= logi TRUE
[17:45:18.384] - copied ‘...future.FUN’ to environment
[17:45:18.385] - reassign environment for ‘x_FUN’
[17:45:18.385] - copied ‘x_FUN’ to environment
[17:45:18.385] - copied ‘times’ to environment
[17:45:18.385] - copied ‘stopf’ to environment
[17:45:18.385] - copied ‘stop_if_not’ to environment
[17:45:18.385] - copied ‘dim’ to environment
[17:45:18.385] - copied ‘valid_types’ to environment
[17:45:18.385] - copied ‘future.call.arguments’ to environment
[17:45:18.385] - copied ‘...future.elements_ii’ to environment
[17:45:18.385] - copied ‘...future.seeds_ii’ to environment
[17:45:18.385] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.386] assign_globals() ... done
[17:45:18.386] requestCore(): workers = 2
[17:45:18.388] MulticoreFuture started
[17:45:18.388] - Launch lazy future ... done
[17:45:18.389] run() for ‘MulticoreFuture’ ... done
[17:45:18.389] Created future:
[17:45:18.390] plan(): Setting new future strategy stack:
[17:45:18.390] List of future strategies:
[17:45:18.390] 1. sequential:
[17:45:18.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.390]    - tweaked: FALSE
[17:45:18.390]    - call: NULL
[17:45:18.391] plan(): nbrOfWorkers() = 1
[17:45:18.394] plan(): Setting new future strategy stack:
[17:45:18.394] List of future strategies:
[17:45:18.394] 1. multicore:
[17:45:18.394]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.394]    - tweaked: FALSE
[17:45:18.394]    - call: plan(strategy)
[17:45:18.399] plan(): nbrOfWorkers() = 2
[17:45:18.389] MulticoreFuture:
[17:45:18.389] Label: ‘future_vapply-1’
[17:45:18.389] Expression:
[17:45:18.389] {
[17:45:18.389]     do.call(function(...) {
[17:45:18.389]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.389]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.389]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.389]             on.exit(options(oopts), add = TRUE)
[17:45:18.389]         }
[17:45:18.389]         {
[17:45:18.389]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.389]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.389]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.389]             })
[17:45:18.389]         }
[17:45:18.389]     }, args = future.call.arguments)
[17:45:18.389] }
[17:45:18.389] Lazy evaluation: FALSE
[17:45:18.389] Asynchronous evaluation: TRUE
[17:45:18.389] Local evaluation: TRUE
[17:45:18.389] Environment: R_GlobalEnv
[17:45:18.389] Capture standard output: TRUE
[17:45:18.389] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.389] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.389] Packages: 1 packages (‘future.apply’)
[17:45:18.389] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.389] Resolved: TRUE
[17:45:18.389] Value: <not collected>
[17:45:18.389] Conditions captured: <none>
[17:45:18.389] Early signaling: FALSE
[17:45:18.389] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.389] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.400] Chunk #1 of 2 ... DONE
[17:45:18.400] Chunk #2 of 2 ...
[17:45:18.400]  - Finding globals in 'X' for chunk #2 ...
[17:45:18.400] getGlobalsAndPackages() ...
[17:45:18.400] Searching for globals...
[17:45:18.401] 
[17:45:18.401] Searching for globals ... DONE
[17:45:18.401] - globals: [0] <none>
[17:45:18.401] getGlobalsAndPackages() ... DONE
[17:45:18.401]    + additional globals found: [n=0] 
[17:45:18.401]    + additional namespaces needed: [n=0] 
[17:45:18.401]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:18.402]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.402]  - seeds: <none>
[17:45:18.402]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.406] getGlobalsAndPackages() ...
[17:45:18.406] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.407] Resolving globals: FALSE
[17:45:18.407] Tweak future expression to call with '...' arguments ...
[17:45:18.408] {
[17:45:18.408]     do.call(function(...) {
[17:45:18.408]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.408]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.408]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.408]             on.exit(options(oopts), add = TRUE)
[17:45:18.408]         }
[17:45:18.408]         {
[17:45:18.408]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.408]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.408]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.408]             })
[17:45:18.408]         }
[17:45:18.408]     }, args = future.call.arguments)
[17:45:18.408] }
[17:45:18.408] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.410] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.410] - packages: [1] ‘future.apply’
[17:45:18.410] getGlobalsAndPackages() ... DONE
[17:45:18.411] run() for ‘Future’ ...
[17:45:18.411] - state: ‘created’
[17:45:18.412] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.417] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.418] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.418]   - Field: ‘label’
[17:45:18.418]   - Field: ‘local’
[17:45:18.418]   - Field: ‘owner’
[17:45:18.418]   - Field: ‘envir’
[17:45:18.418]   - Field: ‘workers’
[17:45:18.419]   - Field: ‘packages’
[17:45:18.419]   - Field: ‘gc’
[17:45:18.419]   - Field: ‘job’
[17:45:18.419]   - Field: ‘conditions’
[17:45:18.419]   - Field: ‘expr’
[17:45:18.419]   - Field: ‘uuid’
[17:45:18.420]   - Field: ‘seed’
[17:45:18.420]   - Field: ‘version’
[17:45:18.420]   - Field: ‘result’
[17:45:18.420]   - Field: ‘asynchronous’
[17:45:18.420]   - Field: ‘calls’
[17:45:18.420]   - Field: ‘globals’
[17:45:18.420]   - Field: ‘stdout’
[17:45:18.421]   - Field: ‘earlySignal’
[17:45:18.421]   - Field: ‘lazy’
[17:45:18.421]   - Field: ‘state’
[17:45:18.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.421] - Launch lazy future ...
[17:45:18.422] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.422] Packages needed by future strategies (n = 0): <none>
[17:45:18.422] {
[17:45:18.422]     {
[17:45:18.422]         {
[17:45:18.422]             ...future.startTime <- base::Sys.time()
[17:45:18.422]             {
[17:45:18.422]                 {
[17:45:18.422]                   {
[17:45:18.422]                     {
[17:45:18.422]                       {
[17:45:18.422]                         base::local({
[17:45:18.422]                           has_future <- base::requireNamespace("future", 
[17:45:18.422]                             quietly = TRUE)
[17:45:18.422]                           if (has_future) {
[17:45:18.422]                             ns <- base::getNamespace("future")
[17:45:18.422]                             version <- ns[[".package"]][["version"]]
[17:45:18.422]                             if (is.null(version)) 
[17:45:18.422]                               version <- utils::packageVersion("future")
[17:45:18.422]                           }
[17:45:18.422]                           else {
[17:45:18.422]                             version <- NULL
[17:45:18.422]                           }
[17:45:18.422]                           if (!has_future || version < "1.8.0") {
[17:45:18.422]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.422]                               "", base::R.version$version.string), 
[17:45:18.422]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.422]                                 base::R.version$platform, 8 * 
[17:45:18.422]                                   base::.Machine$sizeof.pointer), 
[17:45:18.422]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.422]                                 "release", "version")], collapse = " "), 
[17:45:18.422]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.422]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.422]                               info)
[17:45:18.422]                             info <- base::paste(info, collapse = "; ")
[17:45:18.422]                             if (!has_future) {
[17:45:18.422]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.422]                                 info)
[17:45:18.422]                             }
[17:45:18.422]                             else {
[17:45:18.422]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.422]                                 info, version)
[17:45:18.422]                             }
[17:45:18.422]                             base::stop(msg)
[17:45:18.422]                           }
[17:45:18.422]                         })
[17:45:18.422]                       }
[17:45:18.422]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.422]                       base::options(mc.cores = 1L)
[17:45:18.422]                     }
[17:45:18.422]                     base::local({
[17:45:18.422]                       for (pkg in "future.apply") {
[17:45:18.422]                         base::loadNamespace(pkg)
[17:45:18.422]                         base::library(pkg, character.only = TRUE)
[17:45:18.422]                       }
[17:45:18.422]                     })
[17:45:18.422]                   }
[17:45:18.422]                   ...future.strategy.old <- future::plan("list")
[17:45:18.422]                   options(future.plan = NULL)
[17:45:18.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.422]                 }
[17:45:18.422]                 ...future.workdir <- getwd()
[17:45:18.422]             }
[17:45:18.422]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.422]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.422]         }
[17:45:18.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.422]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.422]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.422]             base::names(...future.oldOptions))
[17:45:18.422]     }
[17:45:18.422]     if (FALSE) {
[17:45:18.422]     }
[17:45:18.422]     else {
[17:45:18.422]         if (TRUE) {
[17:45:18.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.422]                 open = "w")
[17:45:18.422]         }
[17:45:18.422]         else {
[17:45:18.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.422]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.422]         }
[17:45:18.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.422]             base::sink(type = "output", split = FALSE)
[17:45:18.422]             base::close(...future.stdout)
[17:45:18.422]         }, add = TRUE)
[17:45:18.422]     }
[17:45:18.422]     ...future.frame <- base::sys.nframe()
[17:45:18.422]     ...future.conditions <- base::list()
[17:45:18.422]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.422]     if (FALSE) {
[17:45:18.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.422]     }
[17:45:18.422]     ...future.result <- base::tryCatch({
[17:45:18.422]         base::withCallingHandlers({
[17:45:18.422]             ...future.value <- base::withVisible(base::local({
[17:45:18.422]                 withCallingHandlers({
[17:45:18.422]                   {
[17:45:18.422]                     do.call(function(...) {
[17:45:18.422]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.422]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.422]                         ...future.globals.maxSize)) {
[17:45:18.422]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.422]                         on.exit(options(oopts), add = TRUE)
[17:45:18.422]                       }
[17:45:18.422]                       {
[17:45:18.422]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.422]                           FUN = function(jj) {
[17:45:18.422]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.422]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.422]                           })
[17:45:18.422]                       }
[17:45:18.422]                     }, args = future.call.arguments)
[17:45:18.422]                   }
[17:45:18.422]                 }, immediateCondition = function(cond) {
[17:45:18.422]                   save_rds <- function (object, pathname, ...) 
[17:45:18.422]                   {
[17:45:18.422]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.422]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.422]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.422]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.422]                         fi_tmp[["mtime"]])
[17:45:18.422]                     }
[17:45:18.422]                     tryCatch({
[17:45:18.422]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.422]                     }, error = function(ex) {
[17:45:18.422]                       msg <- conditionMessage(ex)
[17:45:18.422]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.422]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.422]                         fi_tmp[["mtime"]], msg)
[17:45:18.422]                       ex$message <- msg
[17:45:18.422]                       stop(ex)
[17:45:18.422]                     })
[17:45:18.422]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.422]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.422]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.422]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.422]                       fi <- file.info(pathname)
[17:45:18.422]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.422]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.422]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.422]                         fi[["size"]], fi[["mtime"]])
[17:45:18.422]                       stop(msg)
[17:45:18.422]                     }
[17:45:18.422]                     invisible(pathname)
[17:45:18.422]                   }
[17:45:18.422]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.422]                     rootPath = tempdir()) 
[17:45:18.422]                   {
[17:45:18.422]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.422]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.422]                       tmpdir = path, fileext = ".rds")
[17:45:18.422]                     save_rds(obj, file)
[17:45:18.422]                   }
[17:45:18.422]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.422]                   {
[17:45:18.422]                     inherits <- base::inherits
[17:45:18.422]                     invokeRestart <- base::invokeRestart
[17:45:18.422]                     is.null <- base::is.null
[17:45:18.422]                     muffled <- FALSE
[17:45:18.422]                     if (inherits(cond, "message")) {
[17:45:18.422]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.422]                       if (muffled) 
[17:45:18.422]                         invokeRestart("muffleMessage")
[17:45:18.422]                     }
[17:45:18.422]                     else if (inherits(cond, "warning")) {
[17:45:18.422]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.422]                       if (muffled) 
[17:45:18.422]                         invokeRestart("muffleWarning")
[17:45:18.422]                     }
[17:45:18.422]                     else if (inherits(cond, "condition")) {
[17:45:18.422]                       if (!is.null(pattern)) {
[17:45:18.422]                         computeRestarts <- base::computeRestarts
[17:45:18.422]                         grepl <- base::grepl
[17:45:18.422]                         restarts <- computeRestarts(cond)
[17:45:18.422]                         for (restart in restarts) {
[17:45:18.422]                           name <- restart$name
[17:45:18.422]                           if (is.null(name)) 
[17:45:18.422]                             next
[17:45:18.422]                           if (!grepl(pattern, name)) 
[17:45:18.422]                             next
[17:45:18.422]                           invokeRestart(restart)
[17:45:18.422]                           muffled <- TRUE
[17:45:18.422]                           break
[17:45:18.422]                         }
[17:45:18.422]                       }
[17:45:18.422]                     }
[17:45:18.422]                     invisible(muffled)
[17:45:18.422]                   }
[17:45:18.422]                   muffleCondition(cond)
[17:45:18.422]                 })
[17:45:18.422]             }))
[17:45:18.422]             future::FutureResult(value = ...future.value$value, 
[17:45:18.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.422]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.422]                     ...future.globalenv.names))
[17:45:18.422]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.422]         }, condition = base::local({
[17:45:18.422]             c <- base::c
[17:45:18.422]             inherits <- base::inherits
[17:45:18.422]             invokeRestart <- base::invokeRestart
[17:45:18.422]             length <- base::length
[17:45:18.422]             list <- base::list
[17:45:18.422]             seq.int <- base::seq.int
[17:45:18.422]             signalCondition <- base::signalCondition
[17:45:18.422]             sys.calls <- base::sys.calls
[17:45:18.422]             `[[` <- base::`[[`
[17:45:18.422]             `+` <- base::`+`
[17:45:18.422]             `<<-` <- base::`<<-`
[17:45:18.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.422]                   3L)]
[17:45:18.422]             }
[17:45:18.422]             function(cond) {
[17:45:18.422]                 is_error <- inherits(cond, "error")
[17:45:18.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.422]                   NULL)
[17:45:18.422]                 if (is_error) {
[17:45:18.422]                   sessionInformation <- function() {
[17:45:18.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.422]                       search = base::search(), system = base::Sys.info())
[17:45:18.422]                   }
[17:45:18.422]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.422]                     cond$call), session = sessionInformation(), 
[17:45:18.422]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.422]                   signalCondition(cond)
[17:45:18.422]                 }
[17:45:18.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.422]                 "immediateCondition"))) {
[17:45:18.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.422]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.422]                   if (TRUE && !signal) {
[17:45:18.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.422]                     {
[17:45:18.422]                       inherits <- base::inherits
[17:45:18.422]                       invokeRestart <- base::invokeRestart
[17:45:18.422]                       is.null <- base::is.null
[17:45:18.422]                       muffled <- FALSE
[17:45:18.422]                       if (inherits(cond, "message")) {
[17:45:18.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.422]                         if (muffled) 
[17:45:18.422]                           invokeRestart("muffleMessage")
[17:45:18.422]                       }
[17:45:18.422]                       else if (inherits(cond, "warning")) {
[17:45:18.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.422]                         if (muffled) 
[17:45:18.422]                           invokeRestart("muffleWarning")
[17:45:18.422]                       }
[17:45:18.422]                       else if (inherits(cond, "condition")) {
[17:45:18.422]                         if (!is.null(pattern)) {
[17:45:18.422]                           computeRestarts <- base::computeRestarts
[17:45:18.422]                           grepl <- base::grepl
[17:45:18.422]                           restarts <- computeRestarts(cond)
[17:45:18.422]                           for (restart in restarts) {
[17:45:18.422]                             name <- restart$name
[17:45:18.422]                             if (is.null(name)) 
[17:45:18.422]                               next
[17:45:18.422]                             if (!grepl(pattern, name)) 
[17:45:18.422]                               next
[17:45:18.422]                             invokeRestart(restart)
[17:45:18.422]                             muffled <- TRUE
[17:45:18.422]                             break
[17:45:18.422]                           }
[17:45:18.422]                         }
[17:45:18.422]                       }
[17:45:18.422]                       invisible(muffled)
[17:45:18.422]                     }
[17:45:18.422]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.422]                   }
[17:45:18.422]                 }
[17:45:18.422]                 else {
[17:45:18.422]                   if (TRUE) {
[17:45:18.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.422]                     {
[17:45:18.422]                       inherits <- base::inherits
[17:45:18.422]                       invokeRestart <- base::invokeRestart
[17:45:18.422]                       is.null <- base::is.null
[17:45:18.422]                       muffled <- FALSE
[17:45:18.422]                       if (inherits(cond, "message")) {
[17:45:18.422]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.422]                         if (muffled) 
[17:45:18.422]                           invokeRestart("muffleMessage")
[17:45:18.422]                       }
[17:45:18.422]                       else if (inherits(cond, "warning")) {
[17:45:18.422]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.422]                         if (muffled) 
[17:45:18.422]                           invokeRestart("muffleWarning")
[17:45:18.422]                       }
[17:45:18.422]                       else if (inherits(cond, "condition")) {
[17:45:18.422]                         if (!is.null(pattern)) {
[17:45:18.422]                           computeRestarts <- base::computeRestarts
[17:45:18.422]                           grepl <- base::grepl
[17:45:18.422]                           restarts <- computeRestarts(cond)
[17:45:18.422]                           for (restart in restarts) {
[17:45:18.422]                             name <- restart$name
[17:45:18.422]                             if (is.null(name)) 
[17:45:18.422]                               next
[17:45:18.422]                             if (!grepl(pattern, name)) 
[17:45:18.422]                               next
[17:45:18.422]                             invokeRestart(restart)
[17:45:18.422]                             muffled <- TRUE
[17:45:18.422]                             break
[17:45:18.422]                           }
[17:45:18.422]                         }
[17:45:18.422]                       }
[17:45:18.422]                       invisible(muffled)
[17:45:18.422]                     }
[17:45:18.422]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.422]                   }
[17:45:18.422]                 }
[17:45:18.422]             }
[17:45:18.422]         }))
[17:45:18.422]     }, error = function(ex) {
[17:45:18.422]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.422]                 ...future.rng), started = ...future.startTime, 
[17:45:18.422]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.422]             version = "1.8"), class = "FutureResult")
[17:45:18.422]     }, finally = {
[17:45:18.422]         if (!identical(...future.workdir, getwd())) 
[17:45:18.422]             setwd(...future.workdir)
[17:45:18.422]         {
[17:45:18.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.422]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.422]             }
[17:45:18.422]             base::options(...future.oldOptions)
[17:45:18.422]             if (.Platform$OS.type == "windows") {
[17:45:18.422]                 old_names <- names(...future.oldEnvVars)
[17:45:18.422]                 envs <- base::Sys.getenv()
[17:45:18.422]                 names <- names(envs)
[17:45:18.422]                 common <- intersect(names, old_names)
[17:45:18.422]                 added <- setdiff(names, old_names)
[17:45:18.422]                 removed <- setdiff(old_names, names)
[17:45:18.422]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.422]                   envs[common]]
[17:45:18.422]                 NAMES <- toupper(changed)
[17:45:18.422]                 args <- list()
[17:45:18.422]                 for (kk in seq_along(NAMES)) {
[17:45:18.422]                   name <- changed[[kk]]
[17:45:18.422]                   NAME <- NAMES[[kk]]
[17:45:18.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.422]                     next
[17:45:18.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.422]                 }
[17:45:18.422]                 NAMES <- toupper(added)
[17:45:18.422]                 for (kk in seq_along(NAMES)) {
[17:45:18.422]                   name <- added[[kk]]
[17:45:18.422]                   NAME <- NAMES[[kk]]
[17:45:18.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.422]                     next
[17:45:18.422]                   args[[name]] <- ""
[17:45:18.422]                 }
[17:45:18.422]                 NAMES <- toupper(removed)
[17:45:18.422]                 for (kk in seq_along(NAMES)) {
[17:45:18.422]                   name <- removed[[kk]]
[17:45:18.422]                   NAME <- NAMES[[kk]]
[17:45:18.422]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.422]                     next
[17:45:18.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.422]                 }
[17:45:18.422]                 if (length(args) > 0) 
[17:45:18.422]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.422]             }
[17:45:18.422]             else {
[17:45:18.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.422]             }
[17:45:18.422]             {
[17:45:18.422]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.422]                   0L) {
[17:45:18.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.422]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.422]                   base::options(opts)
[17:45:18.422]                 }
[17:45:18.422]                 {
[17:45:18.422]                   {
[17:45:18.422]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.422]                     NULL
[17:45:18.422]                   }
[17:45:18.422]                   options(future.plan = NULL)
[17:45:18.422]                   if (is.na(NA_character_)) 
[17:45:18.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.422]                     .init = FALSE)
[17:45:18.422]                 }
[17:45:18.422]             }
[17:45:18.422]         }
[17:45:18.422]     })
[17:45:18.422]     if (TRUE) {
[17:45:18.422]         base::sink(type = "output", split = FALSE)
[17:45:18.422]         if (TRUE) {
[17:45:18.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.422]         }
[17:45:18.422]         else {
[17:45:18.422]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.422]         }
[17:45:18.422]         base::close(...future.stdout)
[17:45:18.422]         ...future.stdout <- NULL
[17:45:18.422]     }
[17:45:18.422]     ...future.result$conditions <- ...future.conditions
[17:45:18.422]     ...future.result$finished <- base::Sys.time()
[17:45:18.422]     ...future.result
[17:45:18.422] }
[17:45:18.425] assign_globals() ...
[17:45:18.425] List of 11
[17:45:18.425]  $ ...future.FUN            :function (x, ...)  
[17:45:18.425]  $ x_FUN                    :function (x)  
[17:45:18.425]  $ times                    : int 0
[17:45:18.425]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.425]  $ stop_if_not              :function (...)  
[17:45:18.425]  $ dim                      : NULL
[17:45:18.425]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.425]  $ future.call.arguments    : list()
[17:45:18.425]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.425]  $ ...future.elements_ii    :List of 5
[17:45:18.425]   ..$ : int 6
[17:45:18.425]   ..$ : int 7
[17:45:18.425]   ..$ : int 8
[17:45:18.425]   ..$ : int 9
[17:45:18.425]   ..$ : int 10
[17:45:18.425]  $ ...future.seeds_ii       : NULL
[17:45:18.425]  $ ...future.globals.maxSize: NULL
[17:45:18.425]  - attr(*, "where")=List of 11
[17:45:18.425]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.425]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.425]  - attr(*, "resolved")= logi FALSE
[17:45:18.425]  - attr(*, "total_size")= num 95472
[17:45:18.425]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.425]  - attr(*, "already-done")= logi TRUE
[17:45:18.436] - copied ‘...future.FUN’ to environment
[17:45:18.436] - reassign environment for ‘x_FUN’
[17:45:18.436] - copied ‘x_FUN’ to environment
[17:45:18.436] - copied ‘times’ to environment
[17:45:18.436] - copied ‘stopf’ to environment
[17:45:18.436] - copied ‘stop_if_not’ to environment
[17:45:18.436] - copied ‘dim’ to environment
[17:45:18.436] - copied ‘valid_types’ to environment
[17:45:18.437] - copied ‘future.call.arguments’ to environment
[17:45:18.437] - copied ‘...future.elements_ii’ to environment
[17:45:18.437] - copied ‘...future.seeds_ii’ to environment
[17:45:18.437] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.437] assign_globals() ... done
[17:45:18.437] requestCore(): workers = 2
[17:45:18.439] MulticoreFuture started
[17:45:18.440] - Launch lazy future ... done
[17:45:18.440] run() for ‘MulticoreFuture’ ... done
[17:45:18.440] Created future:
[17:45:18.441] plan(): Setting new future strategy stack:
[17:45:18.441] List of future strategies:
[17:45:18.441] 1. sequential:
[17:45:18.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.441]    - tweaked: FALSE
[17:45:18.441]    - call: NULL
[17:45:18.442] plan(): nbrOfWorkers() = 1
[17:45:18.444] plan(): Setting new future strategy stack:
[17:45:18.444] List of future strategies:
[17:45:18.444] 1. multicore:
[17:45:18.444]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.444]    - tweaked: FALSE
[17:45:18.444]    - call: plan(strategy)
[17:45:18.450] plan(): nbrOfWorkers() = 2
[17:45:18.440] MulticoreFuture:
[17:45:18.440] Label: ‘future_vapply-2’
[17:45:18.440] Expression:
[17:45:18.440] {
[17:45:18.440]     do.call(function(...) {
[17:45:18.440]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.440]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.440]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.440]             on.exit(options(oopts), add = TRUE)
[17:45:18.440]         }
[17:45:18.440]         {
[17:45:18.440]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.440]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.440]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.440]             })
[17:45:18.440]         }
[17:45:18.440]     }, args = future.call.arguments)
[17:45:18.440] }
[17:45:18.440] Lazy evaluation: FALSE
[17:45:18.440] Asynchronous evaluation: TRUE
[17:45:18.440] Local evaluation: TRUE
[17:45:18.440] Environment: R_GlobalEnv
[17:45:18.440] Capture standard output: TRUE
[17:45:18.440] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.440] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.440] Packages: 1 packages (‘future.apply’)
[17:45:18.440] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.440] Resolved: TRUE
[17:45:18.440] Value: <not collected>
[17:45:18.440] Conditions captured: <none>
[17:45:18.440] Early signaling: FALSE
[17:45:18.440] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.440] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.451] Chunk #2 of 2 ... DONE
[17:45:18.451] Launching 2 futures (chunks) ... DONE
[17:45:18.451] Resolving 2 futures (chunks) ...
[17:45:18.451] resolve() on list ...
[17:45:18.452]  recursive: 0
[17:45:18.452]  length: 2
[17:45:18.452] 
[17:45:18.452] Future #1
[17:45:18.452] result() for MulticoreFuture ...
[17:45:18.453] result() for MulticoreFuture ...
[17:45:18.453] result() for MulticoreFuture ... done
[17:45:18.453] result() for MulticoreFuture ... done
[17:45:18.454] result() for MulticoreFuture ...
[17:45:18.454] result() for MulticoreFuture ... done
[17:45:18.454] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:18.454] - nx: 2
[17:45:18.454] - relay: TRUE
[17:45:18.454] - stdout: TRUE
[17:45:18.454] - signal: TRUE
[17:45:18.455] - resignal: FALSE
[17:45:18.455] - force: TRUE
[17:45:18.455] - relayed: [n=2] FALSE, FALSE
[17:45:18.459] - queued futures: [n=2] FALSE, FALSE
[17:45:18.459]  - until=1
[17:45:18.460]  - relaying element #1
[17:45:18.460] result() for MulticoreFuture ...
[17:45:18.460] result() for MulticoreFuture ... done
[17:45:18.461] result() for MulticoreFuture ...
[17:45:18.461] result() for MulticoreFuture ... done
[17:45:18.461] result() for MulticoreFuture ...
[17:45:18.462] result() for MulticoreFuture ... done
[17:45:18.462] result() for MulticoreFuture ...
[17:45:18.462] result() for MulticoreFuture ... done
[17:45:18.462] - relayed: [n=2] TRUE, FALSE
[17:45:18.463] - queued futures: [n=2] TRUE, FALSE
[17:45:18.463] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:18.463]  length: 1 (resolved future 1)
[17:45:18.464] Future #2
[17:45:18.464] result() for MulticoreFuture ...
[17:45:18.465] result() for MulticoreFuture ...
[17:45:18.465] result() for MulticoreFuture ... done
[17:45:18.466] result() for MulticoreFuture ... done
[17:45:18.466] result() for MulticoreFuture ...
[17:45:18.466] result() for MulticoreFuture ... done
[17:45:18.466] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:18.466] - nx: 2
[17:45:18.467] - relay: TRUE
[17:45:18.467] - stdout: TRUE
[17:45:18.467] - signal: TRUE
[17:45:18.467] - resignal: FALSE
[17:45:18.467] - force: TRUE
[17:45:18.467] - relayed: [n=2] TRUE, FALSE
[17:45:18.468] - queued futures: [n=2] TRUE, FALSE
[17:45:18.468]  - until=2
[17:45:18.468]  - relaying element #2
[17:45:18.468] result() for MulticoreFuture ...
[17:45:18.468] result() for MulticoreFuture ... done
[17:45:18.468] result() for MulticoreFuture ...
[17:45:18.468] result() for MulticoreFuture ... done
[17:45:18.468] result() for MulticoreFuture ...
[17:45:18.469] result() for MulticoreFuture ... done
[17:45:18.469] result() for MulticoreFuture ...
[17:45:18.469] result() for MulticoreFuture ... done
[17:45:18.469] - relayed: [n=2] TRUE, TRUE
[17:45:18.469] - queued futures: [n=2] TRUE, TRUE
[17:45:18.469] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:18.469]  length: 0 (resolved future 2)
[17:45:18.469] Relaying remaining futures
[17:45:18.469] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.470] - nx: 2
[17:45:18.470] - relay: TRUE
[17:45:18.470] - stdout: TRUE
[17:45:18.470] - signal: TRUE
[17:45:18.470] - resignal: FALSE
[17:45:18.470] - force: TRUE
[17:45:18.470] - relayed: [n=2] TRUE, TRUE
[17:45:18.470] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:18.470] - relayed: [n=2] TRUE, TRUE
[17:45:18.471] - queued futures: [n=2] TRUE, TRUE
[17:45:18.471] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.471] resolve() on list ... DONE
[17:45:18.471] result() for MulticoreFuture ...
[17:45:18.471] result() for MulticoreFuture ... done
[17:45:18.471] result() for MulticoreFuture ...
[17:45:18.471] result() for MulticoreFuture ... done
[17:45:18.471] result() for MulticoreFuture ...
[17:45:18.471] result() for MulticoreFuture ... done
[17:45:18.472] result() for MulticoreFuture ...
[17:45:18.472] result() for MulticoreFuture ... done
[17:45:18.472]  - Number of value chunks collected: 2
[17:45:18.472] Resolving 2 futures (chunks) ... DONE
[17:45:18.472] Reducing values from 2 chunks ...
[17:45:18.472]  - Number of values collected after concatenation: 10
[17:45:18.472]  - Number of values expected: 10
[17:45:18.472] Reducing values from 2 chunks ... DONE
[17:45:18.472] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:45:18.473] future_lapply() ...
[17:45:18.480] Number of chunks: 2
[17:45:18.480] getGlobalsAndPackagesXApply() ...
[17:45:18.480]  - future.globals: TRUE
[17:45:18.480] getGlobalsAndPackages() ...
[17:45:18.480] Searching for globals...
[17:45:18.484] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:45:18.484] Searching for globals ... DONE
[17:45:18.484] Resolving globals: FALSE
[17:45:18.485] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:45:18.485] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.486] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.486] - packages: [1] ‘future.apply’
[17:45:18.486] getGlobalsAndPackages() ... DONE
[17:45:18.486]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.486]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.486] Finding globals ... DONE
[17:45:18.486]  - use_args: TRUE
[17:45:18.486]  - Getting '...' globals ...
[17:45:18.487] resolve() on list ...
[17:45:18.487]  recursive: 0
[17:45:18.487]  length: 1
[17:45:18.487]  elements: ‘...’
[17:45:18.487]  length: 0 (resolved future 1)
[17:45:18.487] resolve() on list ... DONE
[17:45:18.487]    - '...' content: [n=0] 
[17:45:18.487] List of 1
[17:45:18.487]  $ ...: list()
[17:45:18.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.487]  - attr(*, "where")=List of 1
[17:45:18.487]   ..$ ...:<environment: 0x5561f3a261e8> 
[17:45:18.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.487]  - attr(*, "resolved")= logi TRUE
[17:45:18.487]  - attr(*, "total_size")= num NA
[17:45:18.492]  - Getting '...' globals ... DONE
[17:45:18.492] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.492] List of 8
[17:45:18.492]  $ ...future.FUN:function (x, ...)  
[17:45:18.492]  $ x_FUN        :function (x)  
[17:45:18.492]  $ times        : int 0
[17:45:18.492]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.492]  $ stop_if_not  :function (...)  
[17:45:18.492]  $ dim          : NULL
[17:45:18.492]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:18.492]  $ ...          : list()
[17:45:18.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.492]  - attr(*, "where")=List of 8
[17:45:18.492]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.492]   ..$ ...          :<environment: 0x5561f3a261e8> 
[17:45:18.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.492]  - attr(*, "resolved")= logi FALSE
[17:45:18.492]  - attr(*, "total_size")= num 95400
[17:45:18.498] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.498] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.499] Number of futures (= number of chunks): 2
[17:45:18.499] Launching 2 futures (chunks) ...
[17:45:18.499] Chunk #1 of 2 ...
[17:45:18.499]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.499] getGlobalsAndPackages() ...
[17:45:18.499] Searching for globals...
[17:45:18.499] 
[17:45:18.500] Searching for globals ... DONE
[17:45:18.500] - globals: [0] <none>
[17:45:18.500] getGlobalsAndPackages() ... DONE
[17:45:18.500]    + additional globals found: [n=0] 
[17:45:18.500]    + additional namespaces needed: [n=0] 
[17:45:18.500]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.500]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.500]  - seeds: <none>
[17:45:18.500]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.500] getGlobalsAndPackages() ...
[17:45:18.500] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.501] Resolving globals: FALSE
[17:45:18.501] Tweak future expression to call with '...' arguments ...
[17:45:18.501] {
[17:45:18.501]     do.call(function(...) {
[17:45:18.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.501]             on.exit(options(oopts), add = TRUE)
[17:45:18.501]         }
[17:45:18.501]         {
[17:45:18.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.501]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.501]             })
[17:45:18.501]         }
[17:45:18.501]     }, args = future.call.arguments)
[17:45:18.501] }
[17:45:18.501] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.502] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.502] - packages: [1] ‘future.apply’
[17:45:18.502] getGlobalsAndPackages() ... DONE
[17:45:18.502] run() for ‘Future’ ...
[17:45:18.502] - state: ‘created’
[17:45:18.502] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.506] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.507] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.507]   - Field: ‘label’
[17:45:18.507]   - Field: ‘local’
[17:45:18.507]   - Field: ‘owner’
[17:45:18.507]   - Field: ‘envir’
[17:45:18.507]   - Field: ‘workers’
[17:45:18.507]   - Field: ‘packages’
[17:45:18.507]   - Field: ‘gc’
[17:45:18.508]   - Field: ‘job’
[17:45:18.508]   - Field: ‘conditions’
[17:45:18.508]   - Field: ‘expr’
[17:45:18.508]   - Field: ‘uuid’
[17:45:18.508]   - Field: ‘seed’
[17:45:18.508]   - Field: ‘version’
[17:45:18.508]   - Field: ‘result’
[17:45:18.508]   - Field: ‘asynchronous’
[17:45:18.508]   - Field: ‘calls’
[17:45:18.508]   - Field: ‘globals’
[17:45:18.509]   - Field: ‘stdout’
[17:45:18.509]   - Field: ‘earlySignal’
[17:45:18.509]   - Field: ‘lazy’
[17:45:18.509]   - Field: ‘state’
[17:45:18.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.509] - Launch lazy future ...
[17:45:18.509] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.509] Packages needed by future strategies (n = 0): <none>
[17:45:18.510] {
[17:45:18.510]     {
[17:45:18.510]         {
[17:45:18.510]             ...future.startTime <- base::Sys.time()
[17:45:18.510]             {
[17:45:18.510]                 {
[17:45:18.510]                   {
[17:45:18.510]                     {
[17:45:18.510]                       {
[17:45:18.510]                         base::local({
[17:45:18.510]                           has_future <- base::requireNamespace("future", 
[17:45:18.510]                             quietly = TRUE)
[17:45:18.510]                           if (has_future) {
[17:45:18.510]                             ns <- base::getNamespace("future")
[17:45:18.510]                             version <- ns[[".package"]][["version"]]
[17:45:18.510]                             if (is.null(version)) 
[17:45:18.510]                               version <- utils::packageVersion("future")
[17:45:18.510]                           }
[17:45:18.510]                           else {
[17:45:18.510]                             version <- NULL
[17:45:18.510]                           }
[17:45:18.510]                           if (!has_future || version < "1.8.0") {
[17:45:18.510]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.510]                               "", base::R.version$version.string), 
[17:45:18.510]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.510]                                 base::R.version$platform, 8 * 
[17:45:18.510]                                   base::.Machine$sizeof.pointer), 
[17:45:18.510]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.510]                                 "release", "version")], collapse = " "), 
[17:45:18.510]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.510]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.510]                               info)
[17:45:18.510]                             info <- base::paste(info, collapse = "; ")
[17:45:18.510]                             if (!has_future) {
[17:45:18.510]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.510]                                 info)
[17:45:18.510]                             }
[17:45:18.510]                             else {
[17:45:18.510]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.510]                                 info, version)
[17:45:18.510]                             }
[17:45:18.510]                             base::stop(msg)
[17:45:18.510]                           }
[17:45:18.510]                         })
[17:45:18.510]                       }
[17:45:18.510]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.510]                       base::options(mc.cores = 1L)
[17:45:18.510]                     }
[17:45:18.510]                     base::local({
[17:45:18.510]                       for (pkg in "future.apply") {
[17:45:18.510]                         base::loadNamespace(pkg)
[17:45:18.510]                         base::library(pkg, character.only = TRUE)
[17:45:18.510]                       }
[17:45:18.510]                     })
[17:45:18.510]                   }
[17:45:18.510]                   ...future.strategy.old <- future::plan("list")
[17:45:18.510]                   options(future.plan = NULL)
[17:45:18.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.510]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.510]                 }
[17:45:18.510]                 ...future.workdir <- getwd()
[17:45:18.510]             }
[17:45:18.510]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.510]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.510]         }
[17:45:18.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.510]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.510]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.510]             base::names(...future.oldOptions))
[17:45:18.510]     }
[17:45:18.510]     if (FALSE) {
[17:45:18.510]     }
[17:45:18.510]     else {
[17:45:18.510]         if (TRUE) {
[17:45:18.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.510]                 open = "w")
[17:45:18.510]         }
[17:45:18.510]         else {
[17:45:18.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.510]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.510]         }
[17:45:18.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.510]             base::sink(type = "output", split = FALSE)
[17:45:18.510]             base::close(...future.stdout)
[17:45:18.510]         }, add = TRUE)
[17:45:18.510]     }
[17:45:18.510]     ...future.frame <- base::sys.nframe()
[17:45:18.510]     ...future.conditions <- base::list()
[17:45:18.510]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.510]     if (FALSE) {
[17:45:18.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.510]     }
[17:45:18.510]     ...future.result <- base::tryCatch({
[17:45:18.510]         base::withCallingHandlers({
[17:45:18.510]             ...future.value <- base::withVisible(base::local({
[17:45:18.510]                 withCallingHandlers({
[17:45:18.510]                   {
[17:45:18.510]                     do.call(function(...) {
[17:45:18.510]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.510]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.510]                         ...future.globals.maxSize)) {
[17:45:18.510]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.510]                         on.exit(options(oopts), add = TRUE)
[17:45:18.510]                       }
[17:45:18.510]                       {
[17:45:18.510]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.510]                           FUN = function(jj) {
[17:45:18.510]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.510]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.510]                           })
[17:45:18.510]                       }
[17:45:18.510]                     }, args = future.call.arguments)
[17:45:18.510]                   }
[17:45:18.510]                 }, immediateCondition = function(cond) {
[17:45:18.510]                   save_rds <- function (object, pathname, ...) 
[17:45:18.510]                   {
[17:45:18.510]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.510]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.510]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.510]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.510]                         fi_tmp[["mtime"]])
[17:45:18.510]                     }
[17:45:18.510]                     tryCatch({
[17:45:18.510]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.510]                     }, error = function(ex) {
[17:45:18.510]                       msg <- conditionMessage(ex)
[17:45:18.510]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.510]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.510]                         fi_tmp[["mtime"]], msg)
[17:45:18.510]                       ex$message <- msg
[17:45:18.510]                       stop(ex)
[17:45:18.510]                     })
[17:45:18.510]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.510]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.510]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.510]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.510]                       fi <- file.info(pathname)
[17:45:18.510]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.510]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.510]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.510]                         fi[["size"]], fi[["mtime"]])
[17:45:18.510]                       stop(msg)
[17:45:18.510]                     }
[17:45:18.510]                     invisible(pathname)
[17:45:18.510]                   }
[17:45:18.510]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.510]                     rootPath = tempdir()) 
[17:45:18.510]                   {
[17:45:18.510]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.510]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.510]                       tmpdir = path, fileext = ".rds")
[17:45:18.510]                     save_rds(obj, file)
[17:45:18.510]                   }
[17:45:18.510]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.510]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.510]                   {
[17:45:18.510]                     inherits <- base::inherits
[17:45:18.510]                     invokeRestart <- base::invokeRestart
[17:45:18.510]                     is.null <- base::is.null
[17:45:18.510]                     muffled <- FALSE
[17:45:18.510]                     if (inherits(cond, "message")) {
[17:45:18.510]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.510]                       if (muffled) 
[17:45:18.510]                         invokeRestart("muffleMessage")
[17:45:18.510]                     }
[17:45:18.510]                     else if (inherits(cond, "warning")) {
[17:45:18.510]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.510]                       if (muffled) 
[17:45:18.510]                         invokeRestart("muffleWarning")
[17:45:18.510]                     }
[17:45:18.510]                     else if (inherits(cond, "condition")) {
[17:45:18.510]                       if (!is.null(pattern)) {
[17:45:18.510]                         computeRestarts <- base::computeRestarts
[17:45:18.510]                         grepl <- base::grepl
[17:45:18.510]                         restarts <- computeRestarts(cond)
[17:45:18.510]                         for (restart in restarts) {
[17:45:18.510]                           name <- restart$name
[17:45:18.510]                           if (is.null(name)) 
[17:45:18.510]                             next
[17:45:18.510]                           if (!grepl(pattern, name)) 
[17:45:18.510]                             next
[17:45:18.510]                           invokeRestart(restart)
[17:45:18.510]                           muffled <- TRUE
[17:45:18.510]                           break
[17:45:18.510]                         }
[17:45:18.510]                       }
[17:45:18.510]                     }
[17:45:18.510]                     invisible(muffled)
[17:45:18.510]                   }
[17:45:18.510]                   muffleCondition(cond)
[17:45:18.510]                 })
[17:45:18.510]             }))
[17:45:18.510]             future::FutureResult(value = ...future.value$value, 
[17:45:18.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.510]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.510]                     ...future.globalenv.names))
[17:45:18.510]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.510]         }, condition = base::local({
[17:45:18.510]             c <- base::c
[17:45:18.510]             inherits <- base::inherits
[17:45:18.510]             invokeRestart <- base::invokeRestart
[17:45:18.510]             length <- base::length
[17:45:18.510]             list <- base::list
[17:45:18.510]             seq.int <- base::seq.int
[17:45:18.510]             signalCondition <- base::signalCondition
[17:45:18.510]             sys.calls <- base::sys.calls
[17:45:18.510]             `[[` <- base::`[[`
[17:45:18.510]             `+` <- base::`+`
[17:45:18.510]             `<<-` <- base::`<<-`
[17:45:18.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.510]                   3L)]
[17:45:18.510]             }
[17:45:18.510]             function(cond) {
[17:45:18.510]                 is_error <- inherits(cond, "error")
[17:45:18.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.510]                   NULL)
[17:45:18.510]                 if (is_error) {
[17:45:18.510]                   sessionInformation <- function() {
[17:45:18.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.510]                       search = base::search(), system = base::Sys.info())
[17:45:18.510]                   }
[17:45:18.510]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.510]                     cond$call), session = sessionInformation(), 
[17:45:18.510]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.510]                   signalCondition(cond)
[17:45:18.510]                 }
[17:45:18.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.510]                 "immediateCondition"))) {
[17:45:18.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.510]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.510]                   if (TRUE && !signal) {
[17:45:18.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.510]                     {
[17:45:18.510]                       inherits <- base::inherits
[17:45:18.510]                       invokeRestart <- base::invokeRestart
[17:45:18.510]                       is.null <- base::is.null
[17:45:18.510]                       muffled <- FALSE
[17:45:18.510]                       if (inherits(cond, "message")) {
[17:45:18.510]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.510]                         if (muffled) 
[17:45:18.510]                           invokeRestart("muffleMessage")
[17:45:18.510]                       }
[17:45:18.510]                       else if (inherits(cond, "warning")) {
[17:45:18.510]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.510]                         if (muffled) 
[17:45:18.510]                           invokeRestart("muffleWarning")
[17:45:18.510]                       }
[17:45:18.510]                       else if (inherits(cond, "condition")) {
[17:45:18.510]                         if (!is.null(pattern)) {
[17:45:18.510]                           computeRestarts <- base::computeRestarts
[17:45:18.510]                           grepl <- base::grepl
[17:45:18.510]                           restarts <- computeRestarts(cond)
[17:45:18.510]                           for (restart in restarts) {
[17:45:18.510]                             name <- restart$name
[17:45:18.510]                             if (is.null(name)) 
[17:45:18.510]                               next
[17:45:18.510]                             if (!grepl(pattern, name)) 
[17:45:18.510]                               next
[17:45:18.510]                             invokeRestart(restart)
[17:45:18.510]                             muffled <- TRUE
[17:45:18.510]                             break
[17:45:18.510]                           }
[17:45:18.510]                         }
[17:45:18.510]                       }
[17:45:18.510]                       invisible(muffled)
[17:45:18.510]                     }
[17:45:18.510]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.510]                   }
[17:45:18.510]                 }
[17:45:18.510]                 else {
[17:45:18.510]                   if (TRUE) {
[17:45:18.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.510]                     {
[17:45:18.510]                       inherits <- base::inherits
[17:45:18.510]                       invokeRestart <- base::invokeRestart
[17:45:18.510]                       is.null <- base::is.null
[17:45:18.510]                       muffled <- FALSE
[17:45:18.510]                       if (inherits(cond, "message")) {
[17:45:18.510]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.510]                         if (muffled) 
[17:45:18.510]                           invokeRestart("muffleMessage")
[17:45:18.510]                       }
[17:45:18.510]                       else if (inherits(cond, "warning")) {
[17:45:18.510]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.510]                         if (muffled) 
[17:45:18.510]                           invokeRestart("muffleWarning")
[17:45:18.510]                       }
[17:45:18.510]                       else if (inherits(cond, "condition")) {
[17:45:18.510]                         if (!is.null(pattern)) {
[17:45:18.510]                           computeRestarts <- base::computeRestarts
[17:45:18.510]                           grepl <- base::grepl
[17:45:18.510]                           restarts <- computeRestarts(cond)
[17:45:18.510]                           for (restart in restarts) {
[17:45:18.510]                             name <- restart$name
[17:45:18.510]                             if (is.null(name)) 
[17:45:18.510]                               next
[17:45:18.510]                             if (!grepl(pattern, name)) 
[17:45:18.510]                               next
[17:45:18.510]                             invokeRestart(restart)
[17:45:18.510]                             muffled <- TRUE
[17:45:18.510]                             break
[17:45:18.510]                           }
[17:45:18.510]                         }
[17:45:18.510]                       }
[17:45:18.510]                       invisible(muffled)
[17:45:18.510]                     }
[17:45:18.510]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.510]                   }
[17:45:18.510]                 }
[17:45:18.510]             }
[17:45:18.510]         }))
[17:45:18.510]     }, error = function(ex) {
[17:45:18.510]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.510]                 ...future.rng), started = ...future.startTime, 
[17:45:18.510]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.510]             version = "1.8"), class = "FutureResult")
[17:45:18.510]     }, finally = {
[17:45:18.510]         if (!identical(...future.workdir, getwd())) 
[17:45:18.510]             setwd(...future.workdir)
[17:45:18.510]         {
[17:45:18.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.510]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.510]             }
[17:45:18.510]             base::options(...future.oldOptions)
[17:45:18.510]             if (.Platform$OS.type == "windows") {
[17:45:18.510]                 old_names <- names(...future.oldEnvVars)
[17:45:18.510]                 envs <- base::Sys.getenv()
[17:45:18.510]                 names <- names(envs)
[17:45:18.510]                 common <- intersect(names, old_names)
[17:45:18.510]                 added <- setdiff(names, old_names)
[17:45:18.510]                 removed <- setdiff(old_names, names)
[17:45:18.510]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.510]                   envs[common]]
[17:45:18.510]                 NAMES <- toupper(changed)
[17:45:18.510]                 args <- list()
[17:45:18.510]                 for (kk in seq_along(NAMES)) {
[17:45:18.510]                   name <- changed[[kk]]
[17:45:18.510]                   NAME <- NAMES[[kk]]
[17:45:18.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.510]                     next
[17:45:18.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.510]                 }
[17:45:18.510]                 NAMES <- toupper(added)
[17:45:18.510]                 for (kk in seq_along(NAMES)) {
[17:45:18.510]                   name <- added[[kk]]
[17:45:18.510]                   NAME <- NAMES[[kk]]
[17:45:18.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.510]                     next
[17:45:18.510]                   args[[name]] <- ""
[17:45:18.510]                 }
[17:45:18.510]                 NAMES <- toupper(removed)
[17:45:18.510]                 for (kk in seq_along(NAMES)) {
[17:45:18.510]                   name <- removed[[kk]]
[17:45:18.510]                   NAME <- NAMES[[kk]]
[17:45:18.510]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.510]                     next
[17:45:18.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.510]                 }
[17:45:18.510]                 if (length(args) > 0) 
[17:45:18.510]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.510]             }
[17:45:18.510]             else {
[17:45:18.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.510]             }
[17:45:18.510]             {
[17:45:18.510]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.510]                   0L) {
[17:45:18.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.510]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.510]                   base::options(opts)
[17:45:18.510]                 }
[17:45:18.510]                 {
[17:45:18.510]                   {
[17:45:18.510]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.510]                     NULL
[17:45:18.510]                   }
[17:45:18.510]                   options(future.plan = NULL)
[17:45:18.510]                   if (is.na(NA_character_)) 
[17:45:18.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.510]                     .init = FALSE)
[17:45:18.510]                 }
[17:45:18.510]             }
[17:45:18.510]         }
[17:45:18.510]     })
[17:45:18.510]     if (TRUE) {
[17:45:18.510]         base::sink(type = "output", split = FALSE)
[17:45:18.510]         if (TRUE) {
[17:45:18.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.510]         }
[17:45:18.510]         else {
[17:45:18.510]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.510]         }
[17:45:18.510]         base::close(...future.stdout)
[17:45:18.510]         ...future.stdout <- NULL
[17:45:18.510]     }
[17:45:18.510]     ...future.result$conditions <- ...future.conditions
[17:45:18.510]     ...future.result$finished <- base::Sys.time()
[17:45:18.510]     ...future.result
[17:45:18.510] }
[17:45:18.512] assign_globals() ...
[17:45:18.512] List of 11
[17:45:18.512]  $ ...future.FUN            :function (x, ...)  
[17:45:18.512]  $ x_FUN                    :function (x)  
[17:45:18.512]  $ times                    : int 0
[17:45:18.512]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.512]  $ stop_if_not              :function (...)  
[17:45:18.512]  $ dim                      : NULL
[17:45:18.512]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:18.512]  $ future.call.arguments    : list()
[17:45:18.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.512]  $ ...future.elements_ii    :List of 5
[17:45:18.512]   ..$ : int 1
[17:45:18.512]   ..$ : int 2
[17:45:18.512]   ..$ : int 3
[17:45:18.512]   ..$ : int 4
[17:45:18.512]   ..$ : int 5
[17:45:18.512]  $ ...future.seeds_ii       : NULL
[17:45:18.512]  $ ...future.globals.maxSize: NULL
[17:45:18.512]  - attr(*, "where")=List of 11
[17:45:18.512]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.512]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.512]  - attr(*, "resolved")= logi FALSE
[17:45:18.512]  - attr(*, "total_size")= num 95400
[17:45:18.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.512]  - attr(*, "already-done")= logi TRUE
[17:45:18.523] - copied ‘...future.FUN’ to environment
[17:45:18.524] - reassign environment for ‘x_FUN’
[17:45:18.524] - copied ‘x_FUN’ to environment
[17:45:18.524] - copied ‘times’ to environment
[17:45:18.524] - copied ‘stopf’ to environment
[17:45:18.524] - copied ‘stop_if_not’ to environment
[17:45:18.524] - copied ‘dim’ to environment
[17:45:18.524] - copied ‘valid_types’ to environment
[17:45:18.524] - copied ‘future.call.arguments’ to environment
[17:45:18.524] - copied ‘...future.elements_ii’ to environment
[17:45:18.524] - copied ‘...future.seeds_ii’ to environment
[17:45:18.525] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.525] assign_globals() ... done
[17:45:18.525] requestCore(): workers = 2
[17:45:18.527] MulticoreFuture started
[17:45:18.528] - Launch lazy future ... done
[17:45:18.528] run() for ‘MulticoreFuture’ ... done
[17:45:18.529] Created future:
[17:45:18.529] plan(): Setting new future strategy stack:
[17:45:18.530] List of future strategies:
[17:45:18.530] 1. sequential:
[17:45:18.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.530]    - tweaked: FALSE
[17:45:18.530]    - call: NULL
[17:45:18.531] plan(): nbrOfWorkers() = 1
[17:45:18.533] plan(): Setting new future strategy stack:
[17:45:18.533] List of future strategies:
[17:45:18.533] 1. multicore:
[17:45:18.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.533]    - tweaked: FALSE
[17:45:18.533]    - call: plan(strategy)
[17:45:18.538] plan(): nbrOfWorkers() = 2
[17:45:18.529] MulticoreFuture:
[17:45:18.529] Label: ‘future_vapply-1’
[17:45:18.529] Expression:
[17:45:18.529] {
[17:45:18.529]     do.call(function(...) {
[17:45:18.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.529]             on.exit(options(oopts), add = TRUE)
[17:45:18.529]         }
[17:45:18.529]         {
[17:45:18.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.529]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.529]             })
[17:45:18.529]         }
[17:45:18.529]     }, args = future.call.arguments)
[17:45:18.529] }
[17:45:18.529] Lazy evaluation: FALSE
[17:45:18.529] Asynchronous evaluation: TRUE
[17:45:18.529] Local evaluation: TRUE
[17:45:18.529] Environment: R_GlobalEnv
[17:45:18.529] Capture standard output: TRUE
[17:45:18.529] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.529] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.529] Packages: 1 packages (‘future.apply’)
[17:45:18.529] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.529] Resolved: TRUE
[17:45:18.529] Value: <not collected>
[17:45:18.529] Conditions captured: <none>
[17:45:18.529] Early signaling: FALSE
[17:45:18.529] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.529] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.539] Chunk #1 of 2 ... DONE
[17:45:18.540] Chunk #2 of 2 ...
[17:45:18.540]  - Finding globals in 'X' for chunk #2 ...
[17:45:18.540] getGlobalsAndPackages() ...
[17:45:18.540] Searching for globals...
[17:45:18.541] 
[17:45:18.541] Searching for globals ... DONE
[17:45:18.541] - globals: [0] <none>
[17:45:18.541] getGlobalsAndPackages() ... DONE
[17:45:18.541]    + additional globals found: [n=0] 
[17:45:18.541]    + additional namespaces needed: [n=0] 
[17:45:18.541]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:18.542]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.542]  - seeds: <none>
[17:45:18.542]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.542] getGlobalsAndPackages() ...
[17:45:18.542] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.542] Resolving globals: FALSE
[17:45:18.543] Tweak future expression to call with '...' arguments ...
[17:45:18.543] {
[17:45:18.543]     do.call(function(...) {
[17:45:18.543]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.543]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.543]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.543]             on.exit(options(oopts), add = TRUE)
[17:45:18.543]         }
[17:45:18.543]         {
[17:45:18.543]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.543]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.543]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.543]             })
[17:45:18.543]         }
[17:45:18.543]     }, args = future.call.arguments)
[17:45:18.543] }
[17:45:18.543] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.544] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.544] - packages: [1] ‘future.apply’
[17:45:18.544] getGlobalsAndPackages() ... DONE
[17:45:18.545] run() for ‘Future’ ...
[17:45:18.545] - state: ‘created’
[17:45:18.545] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.550] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.550]   - Field: ‘label’
[17:45:18.550]   - Field: ‘local’
[17:45:18.551]   - Field: ‘owner’
[17:45:18.551]   - Field: ‘envir’
[17:45:18.551]   - Field: ‘workers’
[17:45:18.551]   - Field: ‘packages’
[17:45:18.551]   - Field: ‘gc’
[17:45:18.551]   - Field: ‘job’
[17:45:18.552]   - Field: ‘conditions’
[17:45:18.552]   - Field: ‘expr’
[17:45:18.552]   - Field: ‘uuid’
[17:45:18.552]   - Field: ‘seed’
[17:45:18.552]   - Field: ‘version’
[17:45:18.552]   - Field: ‘result’
[17:45:18.552]   - Field: ‘asynchronous’
[17:45:18.553]   - Field: ‘calls’
[17:45:18.553]   - Field: ‘globals’
[17:45:18.553]   - Field: ‘stdout’
[17:45:18.553]   - Field: ‘earlySignal’
[17:45:18.553]   - Field: ‘lazy’
[17:45:18.553]   - Field: ‘state’
[17:45:18.553] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.554] - Launch lazy future ...
[17:45:18.554] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.554] Packages needed by future strategies (n = 0): <none>
[17:45:18.555] {
[17:45:18.555]     {
[17:45:18.555]         {
[17:45:18.555]             ...future.startTime <- base::Sys.time()
[17:45:18.555]             {
[17:45:18.555]                 {
[17:45:18.555]                   {
[17:45:18.555]                     {
[17:45:18.555]                       {
[17:45:18.555]                         base::local({
[17:45:18.555]                           has_future <- base::requireNamespace("future", 
[17:45:18.555]                             quietly = TRUE)
[17:45:18.555]                           if (has_future) {
[17:45:18.555]                             ns <- base::getNamespace("future")
[17:45:18.555]                             version <- ns[[".package"]][["version"]]
[17:45:18.555]                             if (is.null(version)) 
[17:45:18.555]                               version <- utils::packageVersion("future")
[17:45:18.555]                           }
[17:45:18.555]                           else {
[17:45:18.555]                             version <- NULL
[17:45:18.555]                           }
[17:45:18.555]                           if (!has_future || version < "1.8.0") {
[17:45:18.555]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.555]                               "", base::R.version$version.string), 
[17:45:18.555]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.555]                                 base::R.version$platform, 8 * 
[17:45:18.555]                                   base::.Machine$sizeof.pointer), 
[17:45:18.555]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.555]                                 "release", "version")], collapse = " "), 
[17:45:18.555]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.555]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.555]                               info)
[17:45:18.555]                             info <- base::paste(info, collapse = "; ")
[17:45:18.555]                             if (!has_future) {
[17:45:18.555]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.555]                                 info)
[17:45:18.555]                             }
[17:45:18.555]                             else {
[17:45:18.555]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.555]                                 info, version)
[17:45:18.555]                             }
[17:45:18.555]                             base::stop(msg)
[17:45:18.555]                           }
[17:45:18.555]                         })
[17:45:18.555]                       }
[17:45:18.555]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.555]                       base::options(mc.cores = 1L)
[17:45:18.555]                     }
[17:45:18.555]                     base::local({
[17:45:18.555]                       for (pkg in "future.apply") {
[17:45:18.555]                         base::loadNamespace(pkg)
[17:45:18.555]                         base::library(pkg, character.only = TRUE)
[17:45:18.555]                       }
[17:45:18.555]                     })
[17:45:18.555]                   }
[17:45:18.555]                   ...future.strategy.old <- future::plan("list")
[17:45:18.555]                   options(future.plan = NULL)
[17:45:18.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.555]                 }
[17:45:18.555]                 ...future.workdir <- getwd()
[17:45:18.555]             }
[17:45:18.555]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.555]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.555]         }
[17:45:18.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.555]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.555]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.555]             base::names(...future.oldOptions))
[17:45:18.555]     }
[17:45:18.555]     if (FALSE) {
[17:45:18.555]     }
[17:45:18.555]     else {
[17:45:18.555]         if (TRUE) {
[17:45:18.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.555]                 open = "w")
[17:45:18.555]         }
[17:45:18.555]         else {
[17:45:18.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.555]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.555]         }
[17:45:18.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.555]             base::sink(type = "output", split = FALSE)
[17:45:18.555]             base::close(...future.stdout)
[17:45:18.555]         }, add = TRUE)
[17:45:18.555]     }
[17:45:18.555]     ...future.frame <- base::sys.nframe()
[17:45:18.555]     ...future.conditions <- base::list()
[17:45:18.555]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.555]     if (FALSE) {
[17:45:18.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.555]     }
[17:45:18.555]     ...future.result <- base::tryCatch({
[17:45:18.555]         base::withCallingHandlers({
[17:45:18.555]             ...future.value <- base::withVisible(base::local({
[17:45:18.555]                 withCallingHandlers({
[17:45:18.555]                   {
[17:45:18.555]                     do.call(function(...) {
[17:45:18.555]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.555]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.555]                         ...future.globals.maxSize)) {
[17:45:18.555]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.555]                         on.exit(options(oopts), add = TRUE)
[17:45:18.555]                       }
[17:45:18.555]                       {
[17:45:18.555]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.555]                           FUN = function(jj) {
[17:45:18.555]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.555]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.555]                           })
[17:45:18.555]                       }
[17:45:18.555]                     }, args = future.call.arguments)
[17:45:18.555]                   }
[17:45:18.555]                 }, immediateCondition = function(cond) {
[17:45:18.555]                   save_rds <- function (object, pathname, ...) 
[17:45:18.555]                   {
[17:45:18.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.555]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.555]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.555]                         fi_tmp[["mtime"]])
[17:45:18.555]                     }
[17:45:18.555]                     tryCatch({
[17:45:18.555]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.555]                     }, error = function(ex) {
[17:45:18.555]                       msg <- conditionMessage(ex)
[17:45:18.555]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.555]                         fi_tmp[["mtime"]], msg)
[17:45:18.555]                       ex$message <- msg
[17:45:18.555]                       stop(ex)
[17:45:18.555]                     })
[17:45:18.555]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.555]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.555]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.555]                       fi <- file.info(pathname)
[17:45:18.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.555]                         fi[["size"]], fi[["mtime"]])
[17:45:18.555]                       stop(msg)
[17:45:18.555]                     }
[17:45:18.555]                     invisible(pathname)
[17:45:18.555]                   }
[17:45:18.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.555]                     rootPath = tempdir()) 
[17:45:18.555]                   {
[17:45:18.555]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.555]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.555]                       tmpdir = path, fileext = ".rds")
[17:45:18.555]                     save_rds(obj, file)
[17:45:18.555]                   }
[17:45:18.555]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.555]                   {
[17:45:18.555]                     inherits <- base::inherits
[17:45:18.555]                     invokeRestart <- base::invokeRestart
[17:45:18.555]                     is.null <- base::is.null
[17:45:18.555]                     muffled <- FALSE
[17:45:18.555]                     if (inherits(cond, "message")) {
[17:45:18.555]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.555]                       if (muffled) 
[17:45:18.555]                         invokeRestart("muffleMessage")
[17:45:18.555]                     }
[17:45:18.555]                     else if (inherits(cond, "warning")) {
[17:45:18.555]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.555]                       if (muffled) 
[17:45:18.555]                         invokeRestart("muffleWarning")
[17:45:18.555]                     }
[17:45:18.555]                     else if (inherits(cond, "condition")) {
[17:45:18.555]                       if (!is.null(pattern)) {
[17:45:18.555]                         computeRestarts <- base::computeRestarts
[17:45:18.555]                         grepl <- base::grepl
[17:45:18.555]                         restarts <- computeRestarts(cond)
[17:45:18.555]                         for (restart in restarts) {
[17:45:18.555]                           name <- restart$name
[17:45:18.555]                           if (is.null(name)) 
[17:45:18.555]                             next
[17:45:18.555]                           if (!grepl(pattern, name)) 
[17:45:18.555]                             next
[17:45:18.555]                           invokeRestart(restart)
[17:45:18.555]                           muffled <- TRUE
[17:45:18.555]                           break
[17:45:18.555]                         }
[17:45:18.555]                       }
[17:45:18.555]                     }
[17:45:18.555]                     invisible(muffled)
[17:45:18.555]                   }
[17:45:18.555]                   muffleCondition(cond)
[17:45:18.555]                 })
[17:45:18.555]             }))
[17:45:18.555]             future::FutureResult(value = ...future.value$value, 
[17:45:18.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.555]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.555]                     ...future.globalenv.names))
[17:45:18.555]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.555]         }, condition = base::local({
[17:45:18.555]             c <- base::c
[17:45:18.555]             inherits <- base::inherits
[17:45:18.555]             invokeRestart <- base::invokeRestart
[17:45:18.555]             length <- base::length
[17:45:18.555]             list <- base::list
[17:45:18.555]             seq.int <- base::seq.int
[17:45:18.555]             signalCondition <- base::signalCondition
[17:45:18.555]             sys.calls <- base::sys.calls
[17:45:18.555]             `[[` <- base::`[[`
[17:45:18.555]             `+` <- base::`+`
[17:45:18.555]             `<<-` <- base::`<<-`
[17:45:18.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.555]                   3L)]
[17:45:18.555]             }
[17:45:18.555]             function(cond) {
[17:45:18.555]                 is_error <- inherits(cond, "error")
[17:45:18.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.555]                   NULL)
[17:45:18.555]                 if (is_error) {
[17:45:18.555]                   sessionInformation <- function() {
[17:45:18.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.555]                       search = base::search(), system = base::Sys.info())
[17:45:18.555]                   }
[17:45:18.555]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.555]                     cond$call), session = sessionInformation(), 
[17:45:18.555]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.555]                   signalCondition(cond)
[17:45:18.555]                 }
[17:45:18.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.555]                 "immediateCondition"))) {
[17:45:18.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.555]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.555]                   if (TRUE && !signal) {
[17:45:18.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.555]                     {
[17:45:18.555]                       inherits <- base::inherits
[17:45:18.555]                       invokeRestart <- base::invokeRestart
[17:45:18.555]                       is.null <- base::is.null
[17:45:18.555]                       muffled <- FALSE
[17:45:18.555]                       if (inherits(cond, "message")) {
[17:45:18.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.555]                         if (muffled) 
[17:45:18.555]                           invokeRestart("muffleMessage")
[17:45:18.555]                       }
[17:45:18.555]                       else if (inherits(cond, "warning")) {
[17:45:18.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.555]                         if (muffled) 
[17:45:18.555]                           invokeRestart("muffleWarning")
[17:45:18.555]                       }
[17:45:18.555]                       else if (inherits(cond, "condition")) {
[17:45:18.555]                         if (!is.null(pattern)) {
[17:45:18.555]                           computeRestarts <- base::computeRestarts
[17:45:18.555]                           grepl <- base::grepl
[17:45:18.555]                           restarts <- computeRestarts(cond)
[17:45:18.555]                           for (restart in restarts) {
[17:45:18.555]                             name <- restart$name
[17:45:18.555]                             if (is.null(name)) 
[17:45:18.555]                               next
[17:45:18.555]                             if (!grepl(pattern, name)) 
[17:45:18.555]                               next
[17:45:18.555]                             invokeRestart(restart)
[17:45:18.555]                             muffled <- TRUE
[17:45:18.555]                             break
[17:45:18.555]                           }
[17:45:18.555]                         }
[17:45:18.555]                       }
[17:45:18.555]                       invisible(muffled)
[17:45:18.555]                     }
[17:45:18.555]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.555]                   }
[17:45:18.555]                 }
[17:45:18.555]                 else {
[17:45:18.555]                   if (TRUE) {
[17:45:18.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.555]                     {
[17:45:18.555]                       inherits <- base::inherits
[17:45:18.555]                       invokeRestart <- base::invokeRestart
[17:45:18.555]                       is.null <- base::is.null
[17:45:18.555]                       muffled <- FALSE
[17:45:18.555]                       if (inherits(cond, "message")) {
[17:45:18.555]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.555]                         if (muffled) 
[17:45:18.555]                           invokeRestart("muffleMessage")
[17:45:18.555]                       }
[17:45:18.555]                       else if (inherits(cond, "warning")) {
[17:45:18.555]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.555]                         if (muffled) 
[17:45:18.555]                           invokeRestart("muffleWarning")
[17:45:18.555]                       }
[17:45:18.555]                       else if (inherits(cond, "condition")) {
[17:45:18.555]                         if (!is.null(pattern)) {
[17:45:18.555]                           computeRestarts <- base::computeRestarts
[17:45:18.555]                           grepl <- base::grepl
[17:45:18.555]                           restarts <- computeRestarts(cond)
[17:45:18.555]                           for (restart in restarts) {
[17:45:18.555]                             name <- restart$name
[17:45:18.555]                             if (is.null(name)) 
[17:45:18.555]                               next
[17:45:18.555]                             if (!grepl(pattern, name)) 
[17:45:18.555]                               next
[17:45:18.555]                             invokeRestart(restart)
[17:45:18.555]                             muffled <- TRUE
[17:45:18.555]                             break
[17:45:18.555]                           }
[17:45:18.555]                         }
[17:45:18.555]                       }
[17:45:18.555]                       invisible(muffled)
[17:45:18.555]                     }
[17:45:18.555]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.555]                   }
[17:45:18.555]                 }
[17:45:18.555]             }
[17:45:18.555]         }))
[17:45:18.555]     }, error = function(ex) {
[17:45:18.555]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.555]                 ...future.rng), started = ...future.startTime, 
[17:45:18.555]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.555]             version = "1.8"), class = "FutureResult")
[17:45:18.555]     }, finally = {
[17:45:18.555]         if (!identical(...future.workdir, getwd())) 
[17:45:18.555]             setwd(...future.workdir)
[17:45:18.555]         {
[17:45:18.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.555]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.555]             }
[17:45:18.555]             base::options(...future.oldOptions)
[17:45:18.555]             if (.Platform$OS.type == "windows") {
[17:45:18.555]                 old_names <- names(...future.oldEnvVars)
[17:45:18.555]                 envs <- base::Sys.getenv()
[17:45:18.555]                 names <- names(envs)
[17:45:18.555]                 common <- intersect(names, old_names)
[17:45:18.555]                 added <- setdiff(names, old_names)
[17:45:18.555]                 removed <- setdiff(old_names, names)
[17:45:18.555]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.555]                   envs[common]]
[17:45:18.555]                 NAMES <- toupper(changed)
[17:45:18.555]                 args <- list()
[17:45:18.555]                 for (kk in seq_along(NAMES)) {
[17:45:18.555]                   name <- changed[[kk]]
[17:45:18.555]                   NAME <- NAMES[[kk]]
[17:45:18.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.555]                     next
[17:45:18.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.555]                 }
[17:45:18.555]                 NAMES <- toupper(added)
[17:45:18.555]                 for (kk in seq_along(NAMES)) {
[17:45:18.555]                   name <- added[[kk]]
[17:45:18.555]                   NAME <- NAMES[[kk]]
[17:45:18.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.555]                     next
[17:45:18.555]                   args[[name]] <- ""
[17:45:18.555]                 }
[17:45:18.555]                 NAMES <- toupper(removed)
[17:45:18.555]                 for (kk in seq_along(NAMES)) {
[17:45:18.555]                   name <- removed[[kk]]
[17:45:18.555]                   NAME <- NAMES[[kk]]
[17:45:18.555]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.555]                     next
[17:45:18.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.555]                 }
[17:45:18.555]                 if (length(args) > 0) 
[17:45:18.555]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.555]             }
[17:45:18.555]             else {
[17:45:18.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.555]             }
[17:45:18.555]             {
[17:45:18.555]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.555]                   0L) {
[17:45:18.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.555]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.555]                   base::options(opts)
[17:45:18.555]                 }
[17:45:18.555]                 {
[17:45:18.555]                   {
[17:45:18.555]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.555]                     NULL
[17:45:18.555]                   }
[17:45:18.555]                   options(future.plan = NULL)
[17:45:18.555]                   if (is.na(NA_character_)) 
[17:45:18.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.555]                     .init = FALSE)
[17:45:18.555]                 }
[17:45:18.555]             }
[17:45:18.555]         }
[17:45:18.555]     })
[17:45:18.555]     if (TRUE) {
[17:45:18.555]         base::sink(type = "output", split = FALSE)
[17:45:18.555]         if (TRUE) {
[17:45:18.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.555]         }
[17:45:18.555]         else {
[17:45:18.555]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.555]         }
[17:45:18.555]         base::close(...future.stdout)
[17:45:18.555]         ...future.stdout <- NULL
[17:45:18.555]     }
[17:45:18.555]     ...future.result$conditions <- ...future.conditions
[17:45:18.555]     ...future.result$finished <- base::Sys.time()
[17:45:18.555]     ...future.result
[17:45:18.555] }
[17:45:18.559] assign_globals() ...
[17:45:18.559] List of 11
[17:45:18.559]  $ ...future.FUN            :function (x, ...)  
[17:45:18.559]  $ x_FUN                    :function (x)  
[17:45:18.559]  $ times                    : int 0
[17:45:18.559]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.559]  $ stop_if_not              :function (...)  
[17:45:18.559]  $ dim                      : NULL
[17:45:18.559]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:18.559]  $ future.call.arguments    : list()
[17:45:18.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.559]  $ ...future.elements_ii    :List of 5
[17:45:18.559]   ..$ : int 6
[17:45:18.559]   ..$ : int 7
[17:45:18.559]   ..$ : int 8
[17:45:18.559]   ..$ : int 9
[17:45:18.559]   ..$ : int 10
[17:45:18.559]  $ ...future.seeds_ii       : NULL
[17:45:18.559]  $ ...future.globals.maxSize: NULL
[17:45:18.559]  - attr(*, "where")=List of 11
[17:45:18.559]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.559]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.559]  - attr(*, "resolved")= logi FALSE
[17:45:18.559]  - attr(*, "total_size")= num 95400
[17:45:18.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.559]  - attr(*, "already-done")= logi TRUE
[17:45:18.575] - copied ‘...future.FUN’ to environment
[17:45:18.575] - reassign environment for ‘x_FUN’
[17:45:18.575] - copied ‘x_FUN’ to environment
[17:45:18.576] - copied ‘times’ to environment
[17:45:18.576] - copied ‘stopf’ to environment
[17:45:18.576] - copied ‘stop_if_not’ to environment
[17:45:18.576] - copied ‘dim’ to environment
[17:45:18.576] - copied ‘valid_types’ to environment
[17:45:18.576] - copied ‘future.call.arguments’ to environment
[17:45:18.576] - copied ‘...future.elements_ii’ to environment
[17:45:18.577] - copied ‘...future.seeds_ii’ to environment
[17:45:18.577] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.577] assign_globals() ... done
[17:45:18.577] requestCore(): workers = 2
[17:45:18.579] MulticoreFuture started
[17:45:18.580] - Launch lazy future ... done
[17:45:18.580] run() for ‘MulticoreFuture’ ... done
[17:45:18.581] Created future:
[17:45:18.581] plan(): Setting new future strategy stack:
[17:45:18.581] List of future strategies:
[17:45:18.581] 1. sequential:
[17:45:18.581]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.581]    - tweaked: FALSE
[17:45:18.581]    - call: NULL
[17:45:18.583] plan(): nbrOfWorkers() = 1
[17:45:18.585] plan(): Setting new future strategy stack:
[17:45:18.585] List of future strategies:
[17:45:18.585] 1. multicore:
[17:45:18.585]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.585]    - tweaked: FALSE
[17:45:18.585]    - call: plan(strategy)
[17:45:18.590] plan(): nbrOfWorkers() = 2
[17:45:18.581] MulticoreFuture:
[17:45:18.581] Label: ‘future_vapply-2’
[17:45:18.581] Expression:
[17:45:18.581] {
[17:45:18.581]     do.call(function(...) {
[17:45:18.581]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.581]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.581]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.581]             on.exit(options(oopts), add = TRUE)
[17:45:18.581]         }
[17:45:18.581]         {
[17:45:18.581]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.581]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.581]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.581]             })
[17:45:18.581]         }
[17:45:18.581]     }, args = future.call.arguments)
[17:45:18.581] }
[17:45:18.581] Lazy evaluation: FALSE
[17:45:18.581] Asynchronous evaluation: TRUE
[17:45:18.581] Local evaluation: TRUE
[17:45:18.581] Environment: R_GlobalEnv
[17:45:18.581] Capture standard output: TRUE
[17:45:18.581] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.581] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.581] Packages: 1 packages (‘future.apply’)
[17:45:18.581] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.581] Resolved: TRUE
[17:45:18.581] Value: <not collected>
[17:45:18.581] Conditions captured: <none>
[17:45:18.581] Early signaling: FALSE
[17:45:18.581] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.581] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.591] Chunk #2 of 2 ... DONE
[17:45:18.592] Launching 2 futures (chunks) ... DONE
[17:45:18.592] Resolving 2 futures (chunks) ...
[17:45:18.592] resolve() on list ...
[17:45:18.592]  recursive: 0
[17:45:18.592]  length: 2
[17:45:18.592] 
[17:45:18.593] Future #1
[17:45:18.593] result() for MulticoreFuture ...
[17:45:18.594] result() for MulticoreFuture ...
[17:45:18.594] result() for MulticoreFuture ... done
[17:45:18.594] result() for MulticoreFuture ... done
[17:45:18.594] result() for MulticoreFuture ...
[17:45:18.594] result() for MulticoreFuture ... done
[17:45:18.595] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:18.595] - nx: 2
[17:45:18.595] - relay: TRUE
[17:45:18.595] - stdout: TRUE
[17:45:18.595] - signal: TRUE
[17:45:18.595] - resignal: FALSE
[17:45:18.595] - force: TRUE
[17:45:18.595] - relayed: [n=2] FALSE, FALSE
[17:45:18.596] - queued futures: [n=2] FALSE, FALSE
[17:45:18.596]  - until=1
[17:45:18.596]  - relaying element #1
[17:45:18.596] result() for MulticoreFuture ...
[17:45:18.596] result() for MulticoreFuture ... done
[17:45:18.596] result() for MulticoreFuture ...
[17:45:18.597] result() for MulticoreFuture ... done
[17:45:18.597] result() for MulticoreFuture ...
[17:45:18.597] result() for MulticoreFuture ... done
[17:45:18.597] result() for MulticoreFuture ...
[17:45:18.597] result() for MulticoreFuture ... done
[17:45:18.597] - relayed: [n=2] TRUE, FALSE
[17:45:18.597] - queued futures: [n=2] TRUE, FALSE
[17:45:18.598] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:18.598]  length: 1 (resolved future 1)
[17:45:18.598] Future #2
[17:45:18.598] result() for MulticoreFuture ...
[17:45:18.599] result() for MulticoreFuture ...
[17:45:18.599] result() for MulticoreFuture ... done
[17:45:18.599] result() for MulticoreFuture ... done
[17:45:18.600] result() for MulticoreFuture ...
[17:45:18.600] result() for MulticoreFuture ... done
[17:45:18.600] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:18.600] - nx: 2
[17:45:18.600] - relay: TRUE
[17:45:18.600] - stdout: TRUE
[17:45:18.600] - signal: TRUE
[17:45:18.600] - resignal: FALSE
[17:45:18.600] - force: TRUE
[17:45:18.601] - relayed: [n=2] TRUE, FALSE
[17:45:18.601] - queued futures: [n=2] TRUE, FALSE
[17:45:18.601]  - until=2
[17:45:18.601]  - relaying element #2
[17:45:18.601] result() for MulticoreFuture ...
[17:45:18.601] result() for MulticoreFuture ... done
[17:45:18.601] result() for MulticoreFuture ...
[17:45:18.601] result() for MulticoreFuture ... done
[17:45:18.602] result() for MulticoreFuture ...
[17:45:18.602] result() for MulticoreFuture ... done
[17:45:18.602] result() for MulticoreFuture ...
[17:45:18.602] result() for MulticoreFuture ... done
[17:45:18.602] - relayed: [n=2] TRUE, TRUE
[17:45:18.602] - queued futures: [n=2] TRUE, TRUE
[17:45:18.602] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:18.602]  length: 0 (resolved future 2)
[17:45:18.603] Relaying remaining futures
[17:45:18.603] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.603] - nx: 2
[17:45:18.603] - relay: TRUE
[17:45:18.603] - stdout: TRUE
[17:45:18.603] - signal: TRUE
[17:45:18.603] - resignal: FALSE
[17:45:18.603] - force: TRUE
[17:45:18.603] - relayed: [n=2] TRUE, TRUE
[17:45:18.604] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:18.604] - relayed: [n=2] TRUE, TRUE
[17:45:18.604] - queued futures: [n=2] TRUE, TRUE
[17:45:18.604] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.604] resolve() on list ... DONE
[17:45:18.604] result() for MulticoreFuture ...
[17:45:18.604] result() for MulticoreFuture ... done
[17:45:18.604] result() for MulticoreFuture ...
[17:45:18.604] result() for MulticoreFuture ... done
[17:45:18.605] result() for MulticoreFuture ...
[17:45:18.605] result() for MulticoreFuture ... done
[17:45:18.605] result() for MulticoreFuture ...
[17:45:18.605] result() for MulticoreFuture ... done
[17:45:18.605]  - Number of value chunks collected: 2
[17:45:18.605] Resolving 2 futures (chunks) ... DONE
[17:45:18.605] Reducing values from 2 chunks ...
[17:45:18.605]  - Number of values collected after concatenation: 10
[17:45:18.605]  - Number of values expected: 10
[17:45:18.606] Reducing values from 2 chunks ... DONE
[17:45:18.606] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:45:18.607] future_lapply() ...
[17:45:18.613] Number of chunks: 2
[17:45:18.614] getGlobalsAndPackagesXApply() ...
[17:45:18.614]  - future.globals: TRUE
[17:45:18.614] getGlobalsAndPackages() ...
[17:45:18.614] Searching for globals...
[17:45:18.621] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:18.621] Searching for globals ... DONE
[17:45:18.621] Resolving globals: FALSE
[17:45:18.623] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:45:18.623] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.623] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.623] - packages: [1] ‘future.apply’
[17:45:18.624] getGlobalsAndPackages() ... DONE
[17:45:18.624]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.624]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.624] Finding globals ... DONE
[17:45:18.624]  - use_args: TRUE
[17:45:18.624]  - Getting '...' globals ...
[17:45:18.624] resolve() on list ...
[17:45:18.625]  recursive: 0
[17:45:18.625]  length: 1
[17:45:18.625]  elements: ‘...’
[17:45:18.625]  length: 0 (resolved future 1)
[17:45:18.625] resolve() on list ... DONE
[17:45:18.625]    - '...' content: [n=0] 
[17:45:18.625] List of 1
[17:45:18.625]  $ ...: list()
[17:45:18.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.625]  - attr(*, "where")=List of 1
[17:45:18.625]   ..$ ...:<environment: 0x5561f54400f8> 
[17:45:18.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.625]  - attr(*, "resolved")= logi TRUE
[17:45:18.625]  - attr(*, "total_size")= num NA
[17:45:18.628]  - Getting '...' globals ... DONE
[17:45:18.628] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.628] List of 8
[17:45:18.628]  $ ...future.FUN:function (x, ...)  
[17:45:18.628]  $ x_FUN        :function (x)  
[17:45:18.628]  $ times        : int 1
[17:45:18.628]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.628]  $ stop_if_not  :function (...)  
[17:45:18.628]  $ dim          : NULL
[17:45:18.628]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:18.628]  $ ...          : list()
[17:45:18.628]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.628]  - attr(*, "where")=List of 8
[17:45:18.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.628]   ..$ ...          :<environment: 0x5561f54400f8> 
[17:45:18.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.628]  - attr(*, "resolved")= logi FALSE
[17:45:18.628]  - attr(*, "total_size")= num 94336
[17:45:18.634] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.634] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.634] Number of futures (= number of chunks): 2
[17:45:18.634] Launching 2 futures (chunks) ...
[17:45:18.634] Chunk #1 of 2 ...
[17:45:18.634]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.634] getGlobalsAndPackages() ...
[17:45:18.634] Searching for globals...
[17:45:18.635] 
[17:45:18.635] Searching for globals ... DONE
[17:45:18.635] - globals: [0] <none>
[17:45:18.635] getGlobalsAndPackages() ... DONE
[17:45:18.635]    + additional globals found: [n=0] 
[17:45:18.635]    + additional namespaces needed: [n=0] 
[17:45:18.635]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.635]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.635]  - seeds: <none>
[17:45:18.636]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.636] getGlobalsAndPackages() ...
[17:45:18.636] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.636] Resolving globals: FALSE
[17:45:18.636] Tweak future expression to call with '...' arguments ...
[17:45:18.636] {
[17:45:18.636]     do.call(function(...) {
[17:45:18.636]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.636]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.636]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.636]             on.exit(options(oopts), add = TRUE)
[17:45:18.636]         }
[17:45:18.636]         {
[17:45:18.636]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.636]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.636]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.636]             })
[17:45:18.636]         }
[17:45:18.636]     }, args = future.call.arguments)
[17:45:18.636] }
[17:45:18.636] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.637] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.637] - packages: [1] ‘future.apply’
[17:45:18.637] getGlobalsAndPackages() ... DONE
[17:45:18.638] run() for ‘Future’ ...
[17:45:18.638] - state: ‘created’
[17:45:18.638] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.642] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.642] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.642]   - Field: ‘label’
[17:45:18.643]   - Field: ‘local’
[17:45:18.643]   - Field: ‘owner’
[17:45:18.643]   - Field: ‘envir’
[17:45:18.643]   - Field: ‘workers’
[17:45:18.643]   - Field: ‘packages’
[17:45:18.643]   - Field: ‘gc’
[17:45:18.645]   - Field: ‘job’
[17:45:18.645]   - Field: ‘conditions’
[17:45:18.645]   - Field: ‘expr’
[17:45:18.646]   - Field: ‘uuid’
[17:45:18.646]   - Field: ‘seed’
[17:45:18.646]   - Field: ‘version’
[17:45:18.646]   - Field: ‘result’
[17:45:18.646]   - Field: ‘asynchronous’
[17:45:18.646]   - Field: ‘calls’
[17:45:18.646]   - Field: ‘globals’
[17:45:18.646]   - Field: ‘stdout’
[17:45:18.647]   - Field: ‘earlySignal’
[17:45:18.647]   - Field: ‘lazy’
[17:45:18.647]   - Field: ‘state’
[17:45:18.647] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.647] - Launch lazy future ...
[17:45:18.647] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.648] Packages needed by future strategies (n = 0): <none>
[17:45:18.648] {
[17:45:18.648]     {
[17:45:18.648]         {
[17:45:18.648]             ...future.startTime <- base::Sys.time()
[17:45:18.648]             {
[17:45:18.648]                 {
[17:45:18.648]                   {
[17:45:18.648]                     {
[17:45:18.648]                       {
[17:45:18.648]                         base::local({
[17:45:18.648]                           has_future <- base::requireNamespace("future", 
[17:45:18.648]                             quietly = TRUE)
[17:45:18.648]                           if (has_future) {
[17:45:18.648]                             ns <- base::getNamespace("future")
[17:45:18.648]                             version <- ns[[".package"]][["version"]]
[17:45:18.648]                             if (is.null(version)) 
[17:45:18.648]                               version <- utils::packageVersion("future")
[17:45:18.648]                           }
[17:45:18.648]                           else {
[17:45:18.648]                             version <- NULL
[17:45:18.648]                           }
[17:45:18.648]                           if (!has_future || version < "1.8.0") {
[17:45:18.648]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.648]                               "", base::R.version$version.string), 
[17:45:18.648]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.648]                                 base::R.version$platform, 8 * 
[17:45:18.648]                                   base::.Machine$sizeof.pointer), 
[17:45:18.648]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.648]                                 "release", "version")], collapse = " "), 
[17:45:18.648]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.648]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.648]                               info)
[17:45:18.648]                             info <- base::paste(info, collapse = "; ")
[17:45:18.648]                             if (!has_future) {
[17:45:18.648]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.648]                                 info)
[17:45:18.648]                             }
[17:45:18.648]                             else {
[17:45:18.648]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.648]                                 info, version)
[17:45:18.648]                             }
[17:45:18.648]                             base::stop(msg)
[17:45:18.648]                           }
[17:45:18.648]                         })
[17:45:18.648]                       }
[17:45:18.648]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.648]                       base::options(mc.cores = 1L)
[17:45:18.648]                     }
[17:45:18.648]                     base::local({
[17:45:18.648]                       for (pkg in "future.apply") {
[17:45:18.648]                         base::loadNamespace(pkg)
[17:45:18.648]                         base::library(pkg, character.only = TRUE)
[17:45:18.648]                       }
[17:45:18.648]                     })
[17:45:18.648]                   }
[17:45:18.648]                   ...future.strategy.old <- future::plan("list")
[17:45:18.648]                   options(future.plan = NULL)
[17:45:18.648]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.648]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.648]                 }
[17:45:18.648]                 ...future.workdir <- getwd()
[17:45:18.648]             }
[17:45:18.648]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.648]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.648]         }
[17:45:18.648]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.648]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.648]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.648]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.648]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.648]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.648]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.648]             base::names(...future.oldOptions))
[17:45:18.648]     }
[17:45:18.648]     if (FALSE) {
[17:45:18.648]     }
[17:45:18.648]     else {
[17:45:18.648]         if (TRUE) {
[17:45:18.648]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.648]                 open = "w")
[17:45:18.648]         }
[17:45:18.648]         else {
[17:45:18.648]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.648]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.648]         }
[17:45:18.648]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.648]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.648]             base::sink(type = "output", split = FALSE)
[17:45:18.648]             base::close(...future.stdout)
[17:45:18.648]         }, add = TRUE)
[17:45:18.648]     }
[17:45:18.648]     ...future.frame <- base::sys.nframe()
[17:45:18.648]     ...future.conditions <- base::list()
[17:45:18.648]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.648]     if (FALSE) {
[17:45:18.648]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.648]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.648]     }
[17:45:18.648]     ...future.result <- base::tryCatch({
[17:45:18.648]         base::withCallingHandlers({
[17:45:18.648]             ...future.value <- base::withVisible(base::local({
[17:45:18.648]                 withCallingHandlers({
[17:45:18.648]                   {
[17:45:18.648]                     do.call(function(...) {
[17:45:18.648]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.648]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.648]                         ...future.globals.maxSize)) {
[17:45:18.648]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.648]                         on.exit(options(oopts), add = TRUE)
[17:45:18.648]                       }
[17:45:18.648]                       {
[17:45:18.648]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.648]                           FUN = function(jj) {
[17:45:18.648]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.648]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.648]                           })
[17:45:18.648]                       }
[17:45:18.648]                     }, args = future.call.arguments)
[17:45:18.648]                   }
[17:45:18.648]                 }, immediateCondition = function(cond) {
[17:45:18.648]                   save_rds <- function (object, pathname, ...) 
[17:45:18.648]                   {
[17:45:18.648]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.648]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.648]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.648]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.648]                         fi_tmp[["mtime"]])
[17:45:18.648]                     }
[17:45:18.648]                     tryCatch({
[17:45:18.648]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.648]                     }, error = function(ex) {
[17:45:18.648]                       msg <- conditionMessage(ex)
[17:45:18.648]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.648]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.648]                         fi_tmp[["mtime"]], msg)
[17:45:18.648]                       ex$message <- msg
[17:45:18.648]                       stop(ex)
[17:45:18.648]                     })
[17:45:18.648]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.648]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.648]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.648]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.648]                       fi <- file.info(pathname)
[17:45:18.648]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.648]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.648]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.648]                         fi[["size"]], fi[["mtime"]])
[17:45:18.648]                       stop(msg)
[17:45:18.648]                     }
[17:45:18.648]                     invisible(pathname)
[17:45:18.648]                   }
[17:45:18.648]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.648]                     rootPath = tempdir()) 
[17:45:18.648]                   {
[17:45:18.648]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.648]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.648]                       tmpdir = path, fileext = ".rds")
[17:45:18.648]                     save_rds(obj, file)
[17:45:18.648]                   }
[17:45:18.648]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.648]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.648]                   {
[17:45:18.648]                     inherits <- base::inherits
[17:45:18.648]                     invokeRestart <- base::invokeRestart
[17:45:18.648]                     is.null <- base::is.null
[17:45:18.648]                     muffled <- FALSE
[17:45:18.648]                     if (inherits(cond, "message")) {
[17:45:18.648]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.648]                       if (muffled) 
[17:45:18.648]                         invokeRestart("muffleMessage")
[17:45:18.648]                     }
[17:45:18.648]                     else if (inherits(cond, "warning")) {
[17:45:18.648]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.648]                       if (muffled) 
[17:45:18.648]                         invokeRestart("muffleWarning")
[17:45:18.648]                     }
[17:45:18.648]                     else if (inherits(cond, "condition")) {
[17:45:18.648]                       if (!is.null(pattern)) {
[17:45:18.648]                         computeRestarts <- base::computeRestarts
[17:45:18.648]                         grepl <- base::grepl
[17:45:18.648]                         restarts <- computeRestarts(cond)
[17:45:18.648]                         for (restart in restarts) {
[17:45:18.648]                           name <- restart$name
[17:45:18.648]                           if (is.null(name)) 
[17:45:18.648]                             next
[17:45:18.648]                           if (!grepl(pattern, name)) 
[17:45:18.648]                             next
[17:45:18.648]                           invokeRestart(restart)
[17:45:18.648]                           muffled <- TRUE
[17:45:18.648]                           break
[17:45:18.648]                         }
[17:45:18.648]                       }
[17:45:18.648]                     }
[17:45:18.648]                     invisible(muffled)
[17:45:18.648]                   }
[17:45:18.648]                   muffleCondition(cond)
[17:45:18.648]                 })
[17:45:18.648]             }))
[17:45:18.648]             future::FutureResult(value = ...future.value$value, 
[17:45:18.648]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.648]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.648]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.648]                     ...future.globalenv.names))
[17:45:18.648]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.648]         }, condition = base::local({
[17:45:18.648]             c <- base::c
[17:45:18.648]             inherits <- base::inherits
[17:45:18.648]             invokeRestart <- base::invokeRestart
[17:45:18.648]             length <- base::length
[17:45:18.648]             list <- base::list
[17:45:18.648]             seq.int <- base::seq.int
[17:45:18.648]             signalCondition <- base::signalCondition
[17:45:18.648]             sys.calls <- base::sys.calls
[17:45:18.648]             `[[` <- base::`[[`
[17:45:18.648]             `+` <- base::`+`
[17:45:18.648]             `<<-` <- base::`<<-`
[17:45:18.648]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.648]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.648]                   3L)]
[17:45:18.648]             }
[17:45:18.648]             function(cond) {
[17:45:18.648]                 is_error <- inherits(cond, "error")
[17:45:18.648]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.648]                   NULL)
[17:45:18.648]                 if (is_error) {
[17:45:18.648]                   sessionInformation <- function() {
[17:45:18.648]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.648]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.648]                       search = base::search(), system = base::Sys.info())
[17:45:18.648]                   }
[17:45:18.648]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.648]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.648]                     cond$call), session = sessionInformation(), 
[17:45:18.648]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.648]                   signalCondition(cond)
[17:45:18.648]                 }
[17:45:18.648]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.648]                 "immediateCondition"))) {
[17:45:18.648]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.648]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.648]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.648]                   if (TRUE && !signal) {
[17:45:18.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.648]                     {
[17:45:18.648]                       inherits <- base::inherits
[17:45:18.648]                       invokeRestart <- base::invokeRestart
[17:45:18.648]                       is.null <- base::is.null
[17:45:18.648]                       muffled <- FALSE
[17:45:18.648]                       if (inherits(cond, "message")) {
[17:45:18.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.648]                         if (muffled) 
[17:45:18.648]                           invokeRestart("muffleMessage")
[17:45:18.648]                       }
[17:45:18.648]                       else if (inherits(cond, "warning")) {
[17:45:18.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.648]                         if (muffled) 
[17:45:18.648]                           invokeRestart("muffleWarning")
[17:45:18.648]                       }
[17:45:18.648]                       else if (inherits(cond, "condition")) {
[17:45:18.648]                         if (!is.null(pattern)) {
[17:45:18.648]                           computeRestarts <- base::computeRestarts
[17:45:18.648]                           grepl <- base::grepl
[17:45:18.648]                           restarts <- computeRestarts(cond)
[17:45:18.648]                           for (restart in restarts) {
[17:45:18.648]                             name <- restart$name
[17:45:18.648]                             if (is.null(name)) 
[17:45:18.648]                               next
[17:45:18.648]                             if (!grepl(pattern, name)) 
[17:45:18.648]                               next
[17:45:18.648]                             invokeRestart(restart)
[17:45:18.648]                             muffled <- TRUE
[17:45:18.648]                             break
[17:45:18.648]                           }
[17:45:18.648]                         }
[17:45:18.648]                       }
[17:45:18.648]                       invisible(muffled)
[17:45:18.648]                     }
[17:45:18.648]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.648]                   }
[17:45:18.648]                 }
[17:45:18.648]                 else {
[17:45:18.648]                   if (TRUE) {
[17:45:18.648]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.648]                     {
[17:45:18.648]                       inherits <- base::inherits
[17:45:18.648]                       invokeRestart <- base::invokeRestart
[17:45:18.648]                       is.null <- base::is.null
[17:45:18.648]                       muffled <- FALSE
[17:45:18.648]                       if (inherits(cond, "message")) {
[17:45:18.648]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.648]                         if (muffled) 
[17:45:18.648]                           invokeRestart("muffleMessage")
[17:45:18.648]                       }
[17:45:18.648]                       else if (inherits(cond, "warning")) {
[17:45:18.648]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.648]                         if (muffled) 
[17:45:18.648]                           invokeRestart("muffleWarning")
[17:45:18.648]                       }
[17:45:18.648]                       else if (inherits(cond, "condition")) {
[17:45:18.648]                         if (!is.null(pattern)) {
[17:45:18.648]                           computeRestarts <- base::computeRestarts
[17:45:18.648]                           grepl <- base::grepl
[17:45:18.648]                           restarts <- computeRestarts(cond)
[17:45:18.648]                           for (restart in restarts) {
[17:45:18.648]                             name <- restart$name
[17:45:18.648]                             if (is.null(name)) 
[17:45:18.648]                               next
[17:45:18.648]                             if (!grepl(pattern, name)) 
[17:45:18.648]                               next
[17:45:18.648]                             invokeRestart(restart)
[17:45:18.648]                             muffled <- TRUE
[17:45:18.648]                             break
[17:45:18.648]                           }
[17:45:18.648]                         }
[17:45:18.648]                       }
[17:45:18.648]                       invisible(muffled)
[17:45:18.648]                     }
[17:45:18.648]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.648]                   }
[17:45:18.648]                 }
[17:45:18.648]             }
[17:45:18.648]         }))
[17:45:18.648]     }, error = function(ex) {
[17:45:18.648]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.648]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.648]                 ...future.rng), started = ...future.startTime, 
[17:45:18.648]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.648]             version = "1.8"), class = "FutureResult")
[17:45:18.648]     }, finally = {
[17:45:18.648]         if (!identical(...future.workdir, getwd())) 
[17:45:18.648]             setwd(...future.workdir)
[17:45:18.648]         {
[17:45:18.648]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.648]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.648]             }
[17:45:18.648]             base::options(...future.oldOptions)
[17:45:18.648]             if (.Platform$OS.type == "windows") {
[17:45:18.648]                 old_names <- names(...future.oldEnvVars)
[17:45:18.648]                 envs <- base::Sys.getenv()
[17:45:18.648]                 names <- names(envs)
[17:45:18.648]                 common <- intersect(names, old_names)
[17:45:18.648]                 added <- setdiff(names, old_names)
[17:45:18.648]                 removed <- setdiff(old_names, names)
[17:45:18.648]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.648]                   envs[common]]
[17:45:18.648]                 NAMES <- toupper(changed)
[17:45:18.648]                 args <- list()
[17:45:18.648]                 for (kk in seq_along(NAMES)) {
[17:45:18.648]                   name <- changed[[kk]]
[17:45:18.648]                   NAME <- NAMES[[kk]]
[17:45:18.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.648]                     next
[17:45:18.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.648]                 }
[17:45:18.648]                 NAMES <- toupper(added)
[17:45:18.648]                 for (kk in seq_along(NAMES)) {
[17:45:18.648]                   name <- added[[kk]]
[17:45:18.648]                   NAME <- NAMES[[kk]]
[17:45:18.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.648]                     next
[17:45:18.648]                   args[[name]] <- ""
[17:45:18.648]                 }
[17:45:18.648]                 NAMES <- toupper(removed)
[17:45:18.648]                 for (kk in seq_along(NAMES)) {
[17:45:18.648]                   name <- removed[[kk]]
[17:45:18.648]                   NAME <- NAMES[[kk]]
[17:45:18.648]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.648]                     next
[17:45:18.648]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.648]                 }
[17:45:18.648]                 if (length(args) > 0) 
[17:45:18.648]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.648]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.648]             }
[17:45:18.648]             else {
[17:45:18.648]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.648]             }
[17:45:18.648]             {
[17:45:18.648]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.648]                   0L) {
[17:45:18.648]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.648]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.648]                   base::options(opts)
[17:45:18.648]                 }
[17:45:18.648]                 {
[17:45:18.648]                   {
[17:45:18.648]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.648]                     NULL
[17:45:18.648]                   }
[17:45:18.648]                   options(future.plan = NULL)
[17:45:18.648]                   if (is.na(NA_character_)) 
[17:45:18.648]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.648]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.648]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.648]                     .init = FALSE)
[17:45:18.648]                 }
[17:45:18.648]             }
[17:45:18.648]         }
[17:45:18.648]     })
[17:45:18.648]     if (TRUE) {
[17:45:18.648]         base::sink(type = "output", split = FALSE)
[17:45:18.648]         if (TRUE) {
[17:45:18.648]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.648]         }
[17:45:18.648]         else {
[17:45:18.648]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.648]         }
[17:45:18.648]         base::close(...future.stdout)
[17:45:18.648]         ...future.stdout <- NULL
[17:45:18.648]     }
[17:45:18.648]     ...future.result$conditions <- ...future.conditions
[17:45:18.648]     ...future.result$finished <- base::Sys.time()
[17:45:18.648]     ...future.result
[17:45:18.648] }
[17:45:18.651] assign_globals() ...
[17:45:18.651] List of 11
[17:45:18.651]  $ ...future.FUN            :function (x, ...)  
[17:45:18.651]  $ x_FUN                    :function (x)  
[17:45:18.651]  $ times                    : int 1
[17:45:18.651]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.651]  $ stop_if_not              :function (...)  
[17:45:18.651]  $ dim                      : NULL
[17:45:18.651]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.651]  $ future.call.arguments    : list()
[17:45:18.651]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.651]  $ ...future.elements_ii    :List of 5
[17:45:18.651]   ..$ : int 1
[17:45:18.651]   ..$ : int 2
[17:45:18.651]   ..$ : int 3
[17:45:18.651]   ..$ : int 4
[17:45:18.651]   ..$ : int 5
[17:45:18.651]  $ ...future.seeds_ii       : NULL
[17:45:18.651]  $ ...future.globals.maxSize: NULL
[17:45:18.651]  - attr(*, "where")=List of 11
[17:45:18.651]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.651]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.651]  - attr(*, "resolved")= logi FALSE
[17:45:18.651]  - attr(*, "total_size")= num 94336
[17:45:18.651]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.651]  - attr(*, "already-done")= logi TRUE
[17:45:18.660] - copied ‘...future.FUN’ to environment
[17:45:18.660] - copied ‘x_FUN’ to environment
[17:45:18.661] - copied ‘times’ to environment
[17:45:18.661] - copied ‘stopf’ to environment
[17:45:18.661] - copied ‘stop_if_not’ to environment
[17:45:18.661] - copied ‘dim’ to environment
[17:45:18.661] - copied ‘valid_types’ to environment
[17:45:18.661] - copied ‘future.call.arguments’ to environment
[17:45:18.661] - copied ‘...future.elements_ii’ to environment
[17:45:18.661] - copied ‘...future.seeds_ii’ to environment
[17:45:18.661] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.661] assign_globals() ... done
[17:45:18.662] requestCore(): workers = 2
[17:45:18.664] MulticoreFuture started
[17:45:18.664] - Launch lazy future ... done
[17:45:18.664] run() for ‘MulticoreFuture’ ... done
[17:45:18.665] Created future:
[17:45:18.665] plan(): Setting new future strategy stack:
[17:45:18.666] List of future strategies:
[17:45:18.666] 1. sequential:
[17:45:18.666]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.666]    - tweaked: FALSE
[17:45:18.666]    - call: NULL
[17:45:18.667] plan(): nbrOfWorkers() = 1
[17:45:18.669] plan(): Setting new future strategy stack:
[17:45:18.669] List of future strategies:
[17:45:18.669] 1. multicore:
[17:45:18.669]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.669]    - tweaked: FALSE
[17:45:18.669]    - call: plan(strategy)
[17:45:18.674] plan(): nbrOfWorkers() = 2
[17:45:18.665] MulticoreFuture:
[17:45:18.665] Label: ‘future_vapply-1’
[17:45:18.665] Expression:
[17:45:18.665] {
[17:45:18.665]     do.call(function(...) {
[17:45:18.665]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.665]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.665]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.665]             on.exit(options(oopts), add = TRUE)
[17:45:18.665]         }
[17:45:18.665]         {
[17:45:18.665]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.665]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.665]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.665]             })
[17:45:18.665]         }
[17:45:18.665]     }, args = future.call.arguments)
[17:45:18.665] }
[17:45:18.665] Lazy evaluation: FALSE
[17:45:18.665] Asynchronous evaluation: TRUE
[17:45:18.665] Local evaluation: TRUE
[17:45:18.665] Environment: R_GlobalEnv
[17:45:18.665] Capture standard output: TRUE
[17:45:18.665] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.665] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.665] Packages: 1 packages (‘future.apply’)
[17:45:18.665] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.665] Resolved: TRUE
[17:45:18.665] Value: <not collected>
[17:45:18.665] Conditions captured: <none>
[17:45:18.665] Early signaling: FALSE
[17:45:18.665] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.665] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.675] Chunk #1 of 2 ... DONE
[17:45:18.675] Chunk #2 of 2 ...
[17:45:18.675]  - Finding globals in 'X' for chunk #2 ...
[17:45:18.676] getGlobalsAndPackages() ...
[17:45:18.676] Searching for globals...
[17:45:18.676] 
[17:45:18.676] Searching for globals ... DONE
[17:45:18.676] - globals: [0] <none>
[17:45:18.677] getGlobalsAndPackages() ... DONE
[17:45:18.677]    + additional globals found: [n=0] 
[17:45:18.677]    + additional namespaces needed: [n=0] 
[17:45:18.677]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:18.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.677]  - seeds: <none>
[17:45:18.677]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.677] getGlobalsAndPackages() ...
[17:45:18.678] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.678] Resolving globals: FALSE
[17:45:18.678] Tweak future expression to call with '...' arguments ...
[17:45:18.678] {
[17:45:18.678]     do.call(function(...) {
[17:45:18.678]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.678]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.678]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.678]             on.exit(options(oopts), add = TRUE)
[17:45:18.678]         }
[17:45:18.678]         {
[17:45:18.678]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.678]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.678]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.678]             })
[17:45:18.678]         }
[17:45:18.678]     }, args = future.call.arguments)
[17:45:18.678] }
[17:45:18.679] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.680] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.680] - packages: [1] ‘future.apply’
[17:45:18.680] getGlobalsAndPackages() ... DONE
[17:45:18.680] run() for ‘Future’ ...
[17:45:18.681] - state: ‘created’
[17:45:18.681] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.685] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.686]   - Field: ‘label’
[17:45:18.686]   - Field: ‘local’
[17:45:18.686]   - Field: ‘owner’
[17:45:18.686]   - Field: ‘envir’
[17:45:18.686]   - Field: ‘workers’
[17:45:18.687]   - Field: ‘packages’
[17:45:18.687]   - Field: ‘gc’
[17:45:18.690]   - Field: ‘job’
[17:45:18.690]   - Field: ‘conditions’
[17:45:18.691]   - Field: ‘expr’
[17:45:18.691]   - Field: ‘uuid’
[17:45:18.692]   - Field: ‘seed’
[17:45:18.692]   - Field: ‘version’
[17:45:18.692]   - Field: ‘result’
[17:45:18.692]   - Field: ‘asynchronous’
[17:45:18.693]   - Field: ‘calls’
[17:45:18.693]   - Field: ‘globals’
[17:45:18.693]   - Field: ‘stdout’
[17:45:18.693]   - Field: ‘earlySignal’
[17:45:18.694]   - Field: ‘lazy’
[17:45:18.694]   - Field: ‘state’
[17:45:18.694] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.694] - Launch lazy future ...
[17:45:18.695] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.695] Packages needed by future strategies (n = 0): <none>
[17:45:18.696] {
[17:45:18.696]     {
[17:45:18.696]         {
[17:45:18.696]             ...future.startTime <- base::Sys.time()
[17:45:18.696]             {
[17:45:18.696]                 {
[17:45:18.696]                   {
[17:45:18.696]                     {
[17:45:18.696]                       {
[17:45:18.696]                         base::local({
[17:45:18.696]                           has_future <- base::requireNamespace("future", 
[17:45:18.696]                             quietly = TRUE)
[17:45:18.696]                           if (has_future) {
[17:45:18.696]                             ns <- base::getNamespace("future")
[17:45:18.696]                             version <- ns[[".package"]][["version"]]
[17:45:18.696]                             if (is.null(version)) 
[17:45:18.696]                               version <- utils::packageVersion("future")
[17:45:18.696]                           }
[17:45:18.696]                           else {
[17:45:18.696]                             version <- NULL
[17:45:18.696]                           }
[17:45:18.696]                           if (!has_future || version < "1.8.0") {
[17:45:18.696]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.696]                               "", base::R.version$version.string), 
[17:45:18.696]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.696]                                 base::R.version$platform, 8 * 
[17:45:18.696]                                   base::.Machine$sizeof.pointer), 
[17:45:18.696]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.696]                                 "release", "version")], collapse = " "), 
[17:45:18.696]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.696]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.696]                               info)
[17:45:18.696]                             info <- base::paste(info, collapse = "; ")
[17:45:18.696]                             if (!has_future) {
[17:45:18.696]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.696]                                 info)
[17:45:18.696]                             }
[17:45:18.696]                             else {
[17:45:18.696]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.696]                                 info, version)
[17:45:18.696]                             }
[17:45:18.696]                             base::stop(msg)
[17:45:18.696]                           }
[17:45:18.696]                         })
[17:45:18.696]                       }
[17:45:18.696]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.696]                       base::options(mc.cores = 1L)
[17:45:18.696]                     }
[17:45:18.696]                     base::local({
[17:45:18.696]                       for (pkg in "future.apply") {
[17:45:18.696]                         base::loadNamespace(pkg)
[17:45:18.696]                         base::library(pkg, character.only = TRUE)
[17:45:18.696]                       }
[17:45:18.696]                     })
[17:45:18.696]                   }
[17:45:18.696]                   ...future.strategy.old <- future::plan("list")
[17:45:18.696]                   options(future.plan = NULL)
[17:45:18.696]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.696]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.696]                 }
[17:45:18.696]                 ...future.workdir <- getwd()
[17:45:18.696]             }
[17:45:18.696]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.696]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.696]         }
[17:45:18.696]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.696]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.696]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.696]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.696]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.696]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.696]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.696]             base::names(...future.oldOptions))
[17:45:18.696]     }
[17:45:18.696]     if (FALSE) {
[17:45:18.696]     }
[17:45:18.696]     else {
[17:45:18.696]         if (TRUE) {
[17:45:18.696]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.696]                 open = "w")
[17:45:18.696]         }
[17:45:18.696]         else {
[17:45:18.696]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.696]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.696]         }
[17:45:18.696]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.696]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.696]             base::sink(type = "output", split = FALSE)
[17:45:18.696]             base::close(...future.stdout)
[17:45:18.696]         }, add = TRUE)
[17:45:18.696]     }
[17:45:18.696]     ...future.frame <- base::sys.nframe()
[17:45:18.696]     ...future.conditions <- base::list()
[17:45:18.696]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.696]     if (FALSE) {
[17:45:18.696]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.696]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.696]     }
[17:45:18.696]     ...future.result <- base::tryCatch({
[17:45:18.696]         base::withCallingHandlers({
[17:45:18.696]             ...future.value <- base::withVisible(base::local({
[17:45:18.696]                 withCallingHandlers({
[17:45:18.696]                   {
[17:45:18.696]                     do.call(function(...) {
[17:45:18.696]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.696]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.696]                         ...future.globals.maxSize)) {
[17:45:18.696]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.696]                         on.exit(options(oopts), add = TRUE)
[17:45:18.696]                       }
[17:45:18.696]                       {
[17:45:18.696]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.696]                           FUN = function(jj) {
[17:45:18.696]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.696]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.696]                           })
[17:45:18.696]                       }
[17:45:18.696]                     }, args = future.call.arguments)
[17:45:18.696]                   }
[17:45:18.696]                 }, immediateCondition = function(cond) {
[17:45:18.696]                   save_rds <- function (object, pathname, ...) 
[17:45:18.696]                   {
[17:45:18.696]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.696]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.696]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.696]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.696]                         fi_tmp[["mtime"]])
[17:45:18.696]                     }
[17:45:18.696]                     tryCatch({
[17:45:18.696]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.696]                     }, error = function(ex) {
[17:45:18.696]                       msg <- conditionMessage(ex)
[17:45:18.696]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.696]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.696]                         fi_tmp[["mtime"]], msg)
[17:45:18.696]                       ex$message <- msg
[17:45:18.696]                       stop(ex)
[17:45:18.696]                     })
[17:45:18.696]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.696]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.696]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.696]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.696]                       fi <- file.info(pathname)
[17:45:18.696]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.696]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.696]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.696]                         fi[["size"]], fi[["mtime"]])
[17:45:18.696]                       stop(msg)
[17:45:18.696]                     }
[17:45:18.696]                     invisible(pathname)
[17:45:18.696]                   }
[17:45:18.696]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.696]                     rootPath = tempdir()) 
[17:45:18.696]                   {
[17:45:18.696]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.696]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.696]                       tmpdir = path, fileext = ".rds")
[17:45:18.696]                     save_rds(obj, file)
[17:45:18.696]                   }
[17:45:18.696]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.696]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.696]                   {
[17:45:18.696]                     inherits <- base::inherits
[17:45:18.696]                     invokeRestart <- base::invokeRestart
[17:45:18.696]                     is.null <- base::is.null
[17:45:18.696]                     muffled <- FALSE
[17:45:18.696]                     if (inherits(cond, "message")) {
[17:45:18.696]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.696]                       if (muffled) 
[17:45:18.696]                         invokeRestart("muffleMessage")
[17:45:18.696]                     }
[17:45:18.696]                     else if (inherits(cond, "warning")) {
[17:45:18.696]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.696]                       if (muffled) 
[17:45:18.696]                         invokeRestart("muffleWarning")
[17:45:18.696]                     }
[17:45:18.696]                     else if (inherits(cond, "condition")) {
[17:45:18.696]                       if (!is.null(pattern)) {
[17:45:18.696]                         computeRestarts <- base::computeRestarts
[17:45:18.696]                         grepl <- base::grepl
[17:45:18.696]                         restarts <- computeRestarts(cond)
[17:45:18.696]                         for (restart in restarts) {
[17:45:18.696]                           name <- restart$name
[17:45:18.696]                           if (is.null(name)) 
[17:45:18.696]                             next
[17:45:18.696]                           if (!grepl(pattern, name)) 
[17:45:18.696]                             next
[17:45:18.696]                           invokeRestart(restart)
[17:45:18.696]                           muffled <- TRUE
[17:45:18.696]                           break
[17:45:18.696]                         }
[17:45:18.696]                       }
[17:45:18.696]                     }
[17:45:18.696]                     invisible(muffled)
[17:45:18.696]                   }
[17:45:18.696]                   muffleCondition(cond)
[17:45:18.696]                 })
[17:45:18.696]             }))
[17:45:18.696]             future::FutureResult(value = ...future.value$value, 
[17:45:18.696]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.696]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.696]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.696]                     ...future.globalenv.names))
[17:45:18.696]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.696]         }, condition = base::local({
[17:45:18.696]             c <- base::c
[17:45:18.696]             inherits <- base::inherits
[17:45:18.696]             invokeRestart <- base::invokeRestart
[17:45:18.696]             length <- base::length
[17:45:18.696]             list <- base::list
[17:45:18.696]             seq.int <- base::seq.int
[17:45:18.696]             signalCondition <- base::signalCondition
[17:45:18.696]             sys.calls <- base::sys.calls
[17:45:18.696]             `[[` <- base::`[[`
[17:45:18.696]             `+` <- base::`+`
[17:45:18.696]             `<<-` <- base::`<<-`
[17:45:18.696]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.696]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.696]                   3L)]
[17:45:18.696]             }
[17:45:18.696]             function(cond) {
[17:45:18.696]                 is_error <- inherits(cond, "error")
[17:45:18.696]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.696]                   NULL)
[17:45:18.696]                 if (is_error) {
[17:45:18.696]                   sessionInformation <- function() {
[17:45:18.696]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.696]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.696]                       search = base::search(), system = base::Sys.info())
[17:45:18.696]                   }
[17:45:18.696]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.696]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.696]                     cond$call), session = sessionInformation(), 
[17:45:18.696]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.696]                   signalCondition(cond)
[17:45:18.696]                 }
[17:45:18.696]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.696]                 "immediateCondition"))) {
[17:45:18.696]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.696]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.696]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.696]                   if (TRUE && !signal) {
[17:45:18.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.696]                     {
[17:45:18.696]                       inherits <- base::inherits
[17:45:18.696]                       invokeRestart <- base::invokeRestart
[17:45:18.696]                       is.null <- base::is.null
[17:45:18.696]                       muffled <- FALSE
[17:45:18.696]                       if (inherits(cond, "message")) {
[17:45:18.696]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.696]                         if (muffled) 
[17:45:18.696]                           invokeRestart("muffleMessage")
[17:45:18.696]                       }
[17:45:18.696]                       else if (inherits(cond, "warning")) {
[17:45:18.696]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.696]                         if (muffled) 
[17:45:18.696]                           invokeRestart("muffleWarning")
[17:45:18.696]                       }
[17:45:18.696]                       else if (inherits(cond, "condition")) {
[17:45:18.696]                         if (!is.null(pattern)) {
[17:45:18.696]                           computeRestarts <- base::computeRestarts
[17:45:18.696]                           grepl <- base::grepl
[17:45:18.696]                           restarts <- computeRestarts(cond)
[17:45:18.696]                           for (restart in restarts) {
[17:45:18.696]                             name <- restart$name
[17:45:18.696]                             if (is.null(name)) 
[17:45:18.696]                               next
[17:45:18.696]                             if (!grepl(pattern, name)) 
[17:45:18.696]                               next
[17:45:18.696]                             invokeRestart(restart)
[17:45:18.696]                             muffled <- TRUE
[17:45:18.696]                             break
[17:45:18.696]                           }
[17:45:18.696]                         }
[17:45:18.696]                       }
[17:45:18.696]                       invisible(muffled)
[17:45:18.696]                     }
[17:45:18.696]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.696]                   }
[17:45:18.696]                 }
[17:45:18.696]                 else {
[17:45:18.696]                   if (TRUE) {
[17:45:18.696]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.696]                     {
[17:45:18.696]                       inherits <- base::inherits
[17:45:18.696]                       invokeRestart <- base::invokeRestart
[17:45:18.696]                       is.null <- base::is.null
[17:45:18.696]                       muffled <- FALSE
[17:45:18.696]                       if (inherits(cond, "message")) {
[17:45:18.696]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.696]                         if (muffled) 
[17:45:18.696]                           invokeRestart("muffleMessage")
[17:45:18.696]                       }
[17:45:18.696]                       else if (inherits(cond, "warning")) {
[17:45:18.696]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.696]                         if (muffled) 
[17:45:18.696]                           invokeRestart("muffleWarning")
[17:45:18.696]                       }
[17:45:18.696]                       else if (inherits(cond, "condition")) {
[17:45:18.696]                         if (!is.null(pattern)) {
[17:45:18.696]                           computeRestarts <- base::computeRestarts
[17:45:18.696]                           grepl <- base::grepl
[17:45:18.696]                           restarts <- computeRestarts(cond)
[17:45:18.696]                           for (restart in restarts) {
[17:45:18.696]                             name <- restart$name
[17:45:18.696]                             if (is.null(name)) 
[17:45:18.696]                               next
[17:45:18.696]                             if (!grepl(pattern, name)) 
[17:45:18.696]                               next
[17:45:18.696]                             invokeRestart(restart)
[17:45:18.696]                             muffled <- TRUE
[17:45:18.696]                             break
[17:45:18.696]                           }
[17:45:18.696]                         }
[17:45:18.696]                       }
[17:45:18.696]                       invisible(muffled)
[17:45:18.696]                     }
[17:45:18.696]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.696]                   }
[17:45:18.696]                 }
[17:45:18.696]             }
[17:45:18.696]         }))
[17:45:18.696]     }, error = function(ex) {
[17:45:18.696]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.696]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.696]                 ...future.rng), started = ...future.startTime, 
[17:45:18.696]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.696]             version = "1.8"), class = "FutureResult")
[17:45:18.696]     }, finally = {
[17:45:18.696]         if (!identical(...future.workdir, getwd())) 
[17:45:18.696]             setwd(...future.workdir)
[17:45:18.696]         {
[17:45:18.696]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.696]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.696]             }
[17:45:18.696]             base::options(...future.oldOptions)
[17:45:18.696]             if (.Platform$OS.type == "windows") {
[17:45:18.696]                 old_names <- names(...future.oldEnvVars)
[17:45:18.696]                 envs <- base::Sys.getenv()
[17:45:18.696]                 names <- names(envs)
[17:45:18.696]                 common <- intersect(names, old_names)
[17:45:18.696]                 added <- setdiff(names, old_names)
[17:45:18.696]                 removed <- setdiff(old_names, names)
[17:45:18.696]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.696]                   envs[common]]
[17:45:18.696]                 NAMES <- toupper(changed)
[17:45:18.696]                 args <- list()
[17:45:18.696]                 for (kk in seq_along(NAMES)) {
[17:45:18.696]                   name <- changed[[kk]]
[17:45:18.696]                   NAME <- NAMES[[kk]]
[17:45:18.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.696]                     next
[17:45:18.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.696]                 }
[17:45:18.696]                 NAMES <- toupper(added)
[17:45:18.696]                 for (kk in seq_along(NAMES)) {
[17:45:18.696]                   name <- added[[kk]]
[17:45:18.696]                   NAME <- NAMES[[kk]]
[17:45:18.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.696]                     next
[17:45:18.696]                   args[[name]] <- ""
[17:45:18.696]                 }
[17:45:18.696]                 NAMES <- toupper(removed)
[17:45:18.696]                 for (kk in seq_along(NAMES)) {
[17:45:18.696]                   name <- removed[[kk]]
[17:45:18.696]                   NAME <- NAMES[[kk]]
[17:45:18.696]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.696]                     next
[17:45:18.696]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.696]                 }
[17:45:18.696]                 if (length(args) > 0) 
[17:45:18.696]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.696]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.696]             }
[17:45:18.696]             else {
[17:45:18.696]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.696]             }
[17:45:18.696]             {
[17:45:18.696]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.696]                   0L) {
[17:45:18.696]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.696]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.696]                   base::options(opts)
[17:45:18.696]                 }
[17:45:18.696]                 {
[17:45:18.696]                   {
[17:45:18.696]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.696]                     NULL
[17:45:18.696]                   }
[17:45:18.696]                   options(future.plan = NULL)
[17:45:18.696]                   if (is.na(NA_character_)) 
[17:45:18.696]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.696]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.696]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.696]                     .init = FALSE)
[17:45:18.696]                 }
[17:45:18.696]             }
[17:45:18.696]         }
[17:45:18.696]     })
[17:45:18.696]     if (TRUE) {
[17:45:18.696]         base::sink(type = "output", split = FALSE)
[17:45:18.696]         if (TRUE) {
[17:45:18.696]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.696]         }
[17:45:18.696]         else {
[17:45:18.696]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.696]         }
[17:45:18.696]         base::close(...future.stdout)
[17:45:18.696]         ...future.stdout <- NULL
[17:45:18.696]     }
[17:45:18.696]     ...future.result$conditions <- ...future.conditions
[17:45:18.696]     ...future.result$finished <- base::Sys.time()
[17:45:18.696]     ...future.result
[17:45:18.696] }
[17:45:18.699] assign_globals() ...
[17:45:18.700] List of 11
[17:45:18.700]  $ ...future.FUN            :function (x, ...)  
[17:45:18.700]  $ x_FUN                    :function (x)  
[17:45:18.700]  $ times                    : int 1
[17:45:18.700]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.700]  $ stop_if_not              :function (...)  
[17:45:18.700]  $ dim                      : NULL
[17:45:18.700]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.700]  $ future.call.arguments    : list()
[17:45:18.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.700]  $ ...future.elements_ii    :List of 5
[17:45:18.700]   ..$ : int 6
[17:45:18.700]   ..$ : int 7
[17:45:18.700]   ..$ : int 8
[17:45:18.700]   ..$ : int 9
[17:45:18.700]   ..$ : int 10
[17:45:18.700]  $ ...future.seeds_ii       : NULL
[17:45:18.700]  $ ...future.globals.maxSize: NULL
[17:45:18.700]  - attr(*, "where")=List of 11
[17:45:18.700]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.700]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.700]  - attr(*, "resolved")= logi FALSE
[17:45:18.700]  - attr(*, "total_size")= num 94336
[17:45:18.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.700]  - attr(*, "already-done")= logi TRUE
[17:45:18.711] - copied ‘...future.FUN’ to environment
[17:45:18.711] - copied ‘x_FUN’ to environment
[17:45:18.711] - copied ‘times’ to environment
[17:45:18.712] - copied ‘stopf’ to environment
[17:45:18.712] - copied ‘stop_if_not’ to environment
[17:45:18.712] - copied ‘dim’ to environment
[17:45:18.712] - copied ‘valid_types’ to environment
[17:45:18.712] - copied ‘future.call.arguments’ to environment
[17:45:18.712] - copied ‘...future.elements_ii’ to environment
[17:45:18.712] - copied ‘...future.seeds_ii’ to environment
[17:45:18.712] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.713] assign_globals() ... done
[17:45:18.713] requestCore(): workers = 2
[17:45:18.715] MulticoreFuture started
[17:45:18.715] - Launch lazy future ... done
[17:45:18.716] run() for ‘MulticoreFuture’ ... done
[17:45:18.716] Created future:
[17:45:18.716] plan(): Setting new future strategy stack:
[17:45:18.717] List of future strategies:
[17:45:18.717] 1. sequential:
[17:45:18.717]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.717]    - tweaked: FALSE
[17:45:18.717]    - call: NULL
[17:45:18.718] plan(): nbrOfWorkers() = 1
[17:45:18.720] plan(): Setting new future strategy stack:
[17:45:18.720] List of future strategies:
[17:45:18.720] 1. multicore:
[17:45:18.720]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.720]    - tweaked: FALSE
[17:45:18.720]    - call: plan(strategy)
[17:45:18.725] plan(): nbrOfWorkers() = 2
[17:45:18.716] MulticoreFuture:
[17:45:18.716] Label: ‘future_vapply-2’
[17:45:18.716] Expression:
[17:45:18.716] {
[17:45:18.716]     do.call(function(...) {
[17:45:18.716]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.716]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.716]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.716]             on.exit(options(oopts), add = TRUE)
[17:45:18.716]         }
[17:45:18.716]         {
[17:45:18.716]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.716]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.716]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.716]             })
[17:45:18.716]         }
[17:45:18.716]     }, args = future.call.arguments)
[17:45:18.716] }
[17:45:18.716] Lazy evaluation: FALSE
[17:45:18.716] Asynchronous evaluation: TRUE
[17:45:18.716] Local evaluation: TRUE
[17:45:18.716] Environment: R_GlobalEnv
[17:45:18.716] Capture standard output: TRUE
[17:45:18.716] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.716] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.716] Packages: 1 packages (‘future.apply’)
[17:45:18.716] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.716] Resolved: TRUE
[17:45:18.716] Value: <not collected>
[17:45:18.716] Conditions captured: <none>
[17:45:18.716] Early signaling: FALSE
[17:45:18.716] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.716] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.726] Chunk #2 of 2 ... DONE
[17:45:18.726] Launching 2 futures (chunks) ... DONE
[17:45:18.726] Resolving 2 futures (chunks) ...
[17:45:18.726] resolve() on list ...
[17:45:18.727]  recursive: 0
[17:45:18.727]  length: 2
[17:45:18.727] 
[17:45:18.727] Future #1
[17:45:18.727] result() for MulticoreFuture ...
[17:45:18.728] result() for MulticoreFuture ...
[17:45:18.728] result() for MulticoreFuture ... done
[17:45:18.729] result() for MulticoreFuture ... done
[17:45:18.729] result() for MulticoreFuture ...
[17:45:18.729] result() for MulticoreFuture ... done
[17:45:18.729] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:18.729] - nx: 2
[17:45:18.729] - relay: TRUE
[17:45:18.729] - stdout: TRUE
[17:45:18.730] - signal: TRUE
[17:45:18.730] - resignal: FALSE
[17:45:18.730] - force: TRUE
[17:45:18.730] - relayed: [n=2] FALSE, FALSE
[17:45:18.730] - queued futures: [n=2] FALSE, FALSE
[17:45:18.730]  - until=1
[17:45:18.730]  - relaying element #1
[17:45:18.730] result() for MulticoreFuture ...
[17:45:18.731] result() for MulticoreFuture ... done
[17:45:18.731] result() for MulticoreFuture ...
[17:45:18.731] result() for MulticoreFuture ... done
[17:45:18.731] result() for MulticoreFuture ...
[17:45:18.731] result() for MulticoreFuture ... done
[17:45:18.731] result() for MulticoreFuture ...
[17:45:18.732] result() for MulticoreFuture ... done
[17:45:18.732] - relayed: [n=2] TRUE, FALSE
[17:45:18.732] - queued futures: [n=2] TRUE, FALSE
[17:45:18.732] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:18.732]  length: 1 (resolved future 1)
[17:45:18.732] Future #2
[17:45:18.733] result() for MulticoreFuture ...
[17:45:18.733] result() for MulticoreFuture ...
[17:45:18.733] result() for MulticoreFuture ... done
[17:45:18.734] result() for MulticoreFuture ... done
[17:45:18.734] result() for MulticoreFuture ...
[17:45:18.734] result() for MulticoreFuture ... done
[17:45:18.734] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:18.734] - nx: 2
[17:45:18.734] - relay: TRUE
[17:45:18.734] - stdout: TRUE
[17:45:18.735] - signal: TRUE
[17:45:18.737] - resignal: FALSE
[17:45:18.737] - force: TRUE
[17:45:18.738] - relayed: [n=2] TRUE, FALSE
[17:45:18.738] - queued futures: [n=2] TRUE, FALSE
[17:45:18.738]  - until=2
[17:45:18.738]  - relaying element #2
[17:45:18.738] result() for MulticoreFuture ...
[17:45:18.739] result() for MulticoreFuture ... done
[17:45:18.739] result() for MulticoreFuture ...
[17:45:18.739] result() for MulticoreFuture ... done
[17:45:18.739] result() for MulticoreFuture ...
[17:45:18.739] result() for MulticoreFuture ... done
[17:45:18.740] result() for MulticoreFuture ...
[17:45:18.740] result() for MulticoreFuture ... done
[17:45:18.740] - relayed: [n=2] TRUE, TRUE
[17:45:18.740] - queued futures: [n=2] TRUE, TRUE
[17:45:18.740] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:18.740]  length: 0 (resolved future 2)
[17:45:18.741] Relaying remaining futures
[17:45:18.741] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.741] - nx: 2
[17:45:18.741] - relay: TRUE
[17:45:18.741] - stdout: TRUE
[17:45:18.741] - signal: TRUE
[17:45:18.741] - resignal: FALSE
[17:45:18.742] - force: TRUE
[17:45:18.742] - relayed: [n=2] TRUE, TRUE
[17:45:18.742] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:18.742] - relayed: [n=2] TRUE, TRUE
[17:45:18.742] - queued futures: [n=2] TRUE, TRUE
[17:45:18.742] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.743] resolve() on list ... DONE
[17:45:18.743] result() for MulticoreFuture ...
[17:45:18.743] result() for MulticoreFuture ... done
[17:45:18.743] result() for MulticoreFuture ...
[17:45:18.743] result() for MulticoreFuture ... done
[17:45:18.743] result() for MulticoreFuture ...
[17:45:18.743] result() for MulticoreFuture ... done
[17:45:18.743] result() for MulticoreFuture ...
[17:45:18.744] result() for MulticoreFuture ... done
[17:45:18.744]  - Number of value chunks collected: 2
[17:45:18.744] Resolving 2 futures (chunks) ... DONE
[17:45:18.744] Reducing values from 2 chunks ...
[17:45:18.744]  - Number of values collected after concatenation: 10
[17:45:18.744]  - Number of values expected: 10
[17:45:18.744] Reducing values from 2 chunks ... DONE
[17:45:18.744] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:45:18.745] future_lapply() ...
[17:45:18.751] Number of chunks: 2
[17:45:18.751] getGlobalsAndPackagesXApply() ...
[17:45:18.751]  - future.globals: TRUE
[17:45:18.752] getGlobalsAndPackages() ...
[17:45:18.752] Searching for globals...
[17:45:18.755] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:45:18.756] Searching for globals ... DONE
[17:45:18.756] Resolving globals: FALSE
[17:45:18.757] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:45:18.757] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.757] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.757] - packages: [1] ‘future.apply’
[17:45:18.757] getGlobalsAndPackages() ... DONE
[17:45:18.758]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.758]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.758] Finding globals ... DONE
[17:45:18.758]  - use_args: TRUE
[17:45:18.758]  - Getting '...' globals ...
[17:45:18.758] resolve() on list ...
[17:45:18.758]  recursive: 0
[17:45:18.758]  length: 1
[17:45:18.759]  elements: ‘...’
[17:45:18.759]  length: 0 (resolved future 1)
[17:45:18.759] resolve() on list ... DONE
[17:45:18.759]    - '...' content: [n=0] 
[17:45:18.759] List of 1
[17:45:18.759]  $ ...: list()
[17:45:18.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.759]  - attr(*, "where")=List of 1
[17:45:18.759]   ..$ ...:<environment: 0x5561f3968530> 
[17:45:18.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.759]  - attr(*, "resolved")= logi TRUE
[17:45:18.759]  - attr(*, "total_size")= num NA
[17:45:18.761]  - Getting '...' globals ... DONE
[17:45:18.762] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.762] List of 8
[17:45:18.762]  $ ...future.FUN:function (x, ...)  
[17:45:18.762]  $ x_FUN        :function (x)  
[17:45:18.762]  $ times        : int 2
[17:45:18.762]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.762]  $ stop_if_not  :function (...)  
[17:45:18.762]  $ dim          : NULL
[17:45:18.762]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:18.762]  $ ...          : list()
[17:45:18.762]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.762]  - attr(*, "where")=List of 8
[17:45:18.762]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.762]   ..$ ...          :<environment: 0x5561f3968530> 
[17:45:18.762]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.762]  - attr(*, "resolved")= logi FALSE
[17:45:18.762]  - attr(*, "total_size")= num 96456
[17:45:18.769] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.770] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.770] Number of futures (= number of chunks): 2
[17:45:18.770] Launching 2 futures (chunks) ...
[17:45:18.770] Chunk #1 of 2 ...
[17:45:18.770]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.770] getGlobalsAndPackages() ...
[17:45:18.770] Searching for globals...
[17:45:18.770] 
[17:45:18.771] Searching for globals ... DONE
[17:45:18.771] - globals: [0] <none>
[17:45:18.771] getGlobalsAndPackages() ... DONE
[17:45:18.771]    + additional globals found: [n=0] 
[17:45:18.771]    + additional namespaces needed: [n=0] 
[17:45:18.771]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.771]  - seeds: <none>
[17:45:18.771]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.771] getGlobalsAndPackages() ...
[17:45:18.772] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.772] Resolving globals: FALSE
[17:45:18.772] Tweak future expression to call with '...' arguments ...
[17:45:18.772] {
[17:45:18.772]     do.call(function(...) {
[17:45:18.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.772]             on.exit(options(oopts), add = TRUE)
[17:45:18.772]         }
[17:45:18.772]         {
[17:45:18.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.772]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.772]             })
[17:45:18.772]         }
[17:45:18.772]     }, args = future.call.arguments)
[17:45:18.772] }
[17:45:18.772] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.773] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.773] - packages: [1] ‘future.apply’
[17:45:18.773] getGlobalsAndPackages() ... DONE
[17:45:18.773] run() for ‘Future’ ...
[17:45:18.773] - state: ‘created’
[17:45:18.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.777] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.778]   - Field: ‘label’
[17:45:18.778]   - Field: ‘local’
[17:45:18.778]   - Field: ‘owner’
[17:45:18.778]   - Field: ‘envir’
[17:45:18.778]   - Field: ‘workers’
[17:45:18.778]   - Field: ‘packages’
[17:45:18.778]   - Field: ‘gc’
[17:45:18.778]   - Field: ‘job’
[17:45:18.779]   - Field: ‘conditions’
[17:45:18.779]   - Field: ‘expr’
[17:45:18.779]   - Field: ‘uuid’
[17:45:18.779]   - Field: ‘seed’
[17:45:18.779]   - Field: ‘version’
[17:45:18.779]   - Field: ‘result’
[17:45:18.779]   - Field: ‘asynchronous’
[17:45:18.779]   - Field: ‘calls’
[17:45:18.779]   - Field: ‘globals’
[17:45:18.780]   - Field: ‘stdout’
[17:45:18.780]   - Field: ‘earlySignal’
[17:45:18.780]   - Field: ‘lazy’
[17:45:18.780]   - Field: ‘state’
[17:45:18.780] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.780] - Launch lazy future ...
[17:45:18.780] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.780] Packages needed by future strategies (n = 0): <none>
[17:45:18.781] {
[17:45:18.781]     {
[17:45:18.781]         {
[17:45:18.781]             ...future.startTime <- base::Sys.time()
[17:45:18.781]             {
[17:45:18.781]                 {
[17:45:18.781]                   {
[17:45:18.781]                     {
[17:45:18.781]                       {
[17:45:18.781]                         base::local({
[17:45:18.781]                           has_future <- base::requireNamespace("future", 
[17:45:18.781]                             quietly = TRUE)
[17:45:18.781]                           if (has_future) {
[17:45:18.781]                             ns <- base::getNamespace("future")
[17:45:18.781]                             version <- ns[[".package"]][["version"]]
[17:45:18.781]                             if (is.null(version)) 
[17:45:18.781]                               version <- utils::packageVersion("future")
[17:45:18.781]                           }
[17:45:18.781]                           else {
[17:45:18.781]                             version <- NULL
[17:45:18.781]                           }
[17:45:18.781]                           if (!has_future || version < "1.8.0") {
[17:45:18.781]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.781]                               "", base::R.version$version.string), 
[17:45:18.781]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.781]                                 base::R.version$platform, 8 * 
[17:45:18.781]                                   base::.Machine$sizeof.pointer), 
[17:45:18.781]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.781]                                 "release", "version")], collapse = " "), 
[17:45:18.781]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.781]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.781]                               info)
[17:45:18.781]                             info <- base::paste(info, collapse = "; ")
[17:45:18.781]                             if (!has_future) {
[17:45:18.781]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.781]                                 info)
[17:45:18.781]                             }
[17:45:18.781]                             else {
[17:45:18.781]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.781]                                 info, version)
[17:45:18.781]                             }
[17:45:18.781]                             base::stop(msg)
[17:45:18.781]                           }
[17:45:18.781]                         })
[17:45:18.781]                       }
[17:45:18.781]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.781]                       base::options(mc.cores = 1L)
[17:45:18.781]                     }
[17:45:18.781]                     base::local({
[17:45:18.781]                       for (pkg in "future.apply") {
[17:45:18.781]                         base::loadNamespace(pkg)
[17:45:18.781]                         base::library(pkg, character.only = TRUE)
[17:45:18.781]                       }
[17:45:18.781]                     })
[17:45:18.781]                   }
[17:45:18.781]                   ...future.strategy.old <- future::plan("list")
[17:45:18.781]                   options(future.plan = NULL)
[17:45:18.781]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.781]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.781]                 }
[17:45:18.781]                 ...future.workdir <- getwd()
[17:45:18.781]             }
[17:45:18.781]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.781]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.781]         }
[17:45:18.781]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.781]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.781]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.781]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.781]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.781]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.781]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.781]             base::names(...future.oldOptions))
[17:45:18.781]     }
[17:45:18.781]     if (FALSE) {
[17:45:18.781]     }
[17:45:18.781]     else {
[17:45:18.781]         if (TRUE) {
[17:45:18.781]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.781]                 open = "w")
[17:45:18.781]         }
[17:45:18.781]         else {
[17:45:18.781]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.781]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.781]         }
[17:45:18.781]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.781]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.781]             base::sink(type = "output", split = FALSE)
[17:45:18.781]             base::close(...future.stdout)
[17:45:18.781]         }, add = TRUE)
[17:45:18.781]     }
[17:45:18.781]     ...future.frame <- base::sys.nframe()
[17:45:18.781]     ...future.conditions <- base::list()
[17:45:18.781]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.781]     if (FALSE) {
[17:45:18.781]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.781]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.781]     }
[17:45:18.781]     ...future.result <- base::tryCatch({
[17:45:18.781]         base::withCallingHandlers({
[17:45:18.781]             ...future.value <- base::withVisible(base::local({
[17:45:18.781]                 withCallingHandlers({
[17:45:18.781]                   {
[17:45:18.781]                     do.call(function(...) {
[17:45:18.781]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.781]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.781]                         ...future.globals.maxSize)) {
[17:45:18.781]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.781]                         on.exit(options(oopts), add = TRUE)
[17:45:18.781]                       }
[17:45:18.781]                       {
[17:45:18.781]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.781]                           FUN = function(jj) {
[17:45:18.781]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.781]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.781]                           })
[17:45:18.781]                       }
[17:45:18.781]                     }, args = future.call.arguments)
[17:45:18.781]                   }
[17:45:18.781]                 }, immediateCondition = function(cond) {
[17:45:18.781]                   save_rds <- function (object, pathname, ...) 
[17:45:18.781]                   {
[17:45:18.781]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.781]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.781]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.781]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.781]                         fi_tmp[["mtime"]])
[17:45:18.781]                     }
[17:45:18.781]                     tryCatch({
[17:45:18.781]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.781]                     }, error = function(ex) {
[17:45:18.781]                       msg <- conditionMessage(ex)
[17:45:18.781]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.781]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.781]                         fi_tmp[["mtime"]], msg)
[17:45:18.781]                       ex$message <- msg
[17:45:18.781]                       stop(ex)
[17:45:18.781]                     })
[17:45:18.781]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.781]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.781]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.781]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.781]                       fi <- file.info(pathname)
[17:45:18.781]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.781]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.781]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.781]                         fi[["size"]], fi[["mtime"]])
[17:45:18.781]                       stop(msg)
[17:45:18.781]                     }
[17:45:18.781]                     invisible(pathname)
[17:45:18.781]                   }
[17:45:18.781]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.781]                     rootPath = tempdir()) 
[17:45:18.781]                   {
[17:45:18.781]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.781]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.781]                       tmpdir = path, fileext = ".rds")
[17:45:18.781]                     save_rds(obj, file)
[17:45:18.781]                   }
[17:45:18.781]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.781]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.781]                   {
[17:45:18.781]                     inherits <- base::inherits
[17:45:18.781]                     invokeRestart <- base::invokeRestart
[17:45:18.781]                     is.null <- base::is.null
[17:45:18.781]                     muffled <- FALSE
[17:45:18.781]                     if (inherits(cond, "message")) {
[17:45:18.781]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.781]                       if (muffled) 
[17:45:18.781]                         invokeRestart("muffleMessage")
[17:45:18.781]                     }
[17:45:18.781]                     else if (inherits(cond, "warning")) {
[17:45:18.781]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.781]                       if (muffled) 
[17:45:18.781]                         invokeRestart("muffleWarning")
[17:45:18.781]                     }
[17:45:18.781]                     else if (inherits(cond, "condition")) {
[17:45:18.781]                       if (!is.null(pattern)) {
[17:45:18.781]                         computeRestarts <- base::computeRestarts
[17:45:18.781]                         grepl <- base::grepl
[17:45:18.781]                         restarts <- computeRestarts(cond)
[17:45:18.781]                         for (restart in restarts) {
[17:45:18.781]                           name <- restart$name
[17:45:18.781]                           if (is.null(name)) 
[17:45:18.781]                             next
[17:45:18.781]                           if (!grepl(pattern, name)) 
[17:45:18.781]                             next
[17:45:18.781]                           invokeRestart(restart)
[17:45:18.781]                           muffled <- TRUE
[17:45:18.781]                           break
[17:45:18.781]                         }
[17:45:18.781]                       }
[17:45:18.781]                     }
[17:45:18.781]                     invisible(muffled)
[17:45:18.781]                   }
[17:45:18.781]                   muffleCondition(cond)
[17:45:18.781]                 })
[17:45:18.781]             }))
[17:45:18.781]             future::FutureResult(value = ...future.value$value, 
[17:45:18.781]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.781]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.781]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.781]                     ...future.globalenv.names))
[17:45:18.781]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.781]         }, condition = base::local({
[17:45:18.781]             c <- base::c
[17:45:18.781]             inherits <- base::inherits
[17:45:18.781]             invokeRestart <- base::invokeRestart
[17:45:18.781]             length <- base::length
[17:45:18.781]             list <- base::list
[17:45:18.781]             seq.int <- base::seq.int
[17:45:18.781]             signalCondition <- base::signalCondition
[17:45:18.781]             sys.calls <- base::sys.calls
[17:45:18.781]             `[[` <- base::`[[`
[17:45:18.781]             `+` <- base::`+`
[17:45:18.781]             `<<-` <- base::`<<-`
[17:45:18.781]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.781]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.781]                   3L)]
[17:45:18.781]             }
[17:45:18.781]             function(cond) {
[17:45:18.781]                 is_error <- inherits(cond, "error")
[17:45:18.781]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.781]                   NULL)
[17:45:18.781]                 if (is_error) {
[17:45:18.781]                   sessionInformation <- function() {
[17:45:18.781]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.781]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.781]                       search = base::search(), system = base::Sys.info())
[17:45:18.781]                   }
[17:45:18.781]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.781]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.781]                     cond$call), session = sessionInformation(), 
[17:45:18.781]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.781]                   signalCondition(cond)
[17:45:18.781]                 }
[17:45:18.781]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.781]                 "immediateCondition"))) {
[17:45:18.781]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.781]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.781]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.781]                   if (TRUE && !signal) {
[17:45:18.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.781]                     {
[17:45:18.781]                       inherits <- base::inherits
[17:45:18.781]                       invokeRestart <- base::invokeRestart
[17:45:18.781]                       is.null <- base::is.null
[17:45:18.781]                       muffled <- FALSE
[17:45:18.781]                       if (inherits(cond, "message")) {
[17:45:18.781]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.781]                         if (muffled) 
[17:45:18.781]                           invokeRestart("muffleMessage")
[17:45:18.781]                       }
[17:45:18.781]                       else if (inherits(cond, "warning")) {
[17:45:18.781]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.781]                         if (muffled) 
[17:45:18.781]                           invokeRestart("muffleWarning")
[17:45:18.781]                       }
[17:45:18.781]                       else if (inherits(cond, "condition")) {
[17:45:18.781]                         if (!is.null(pattern)) {
[17:45:18.781]                           computeRestarts <- base::computeRestarts
[17:45:18.781]                           grepl <- base::grepl
[17:45:18.781]                           restarts <- computeRestarts(cond)
[17:45:18.781]                           for (restart in restarts) {
[17:45:18.781]                             name <- restart$name
[17:45:18.781]                             if (is.null(name)) 
[17:45:18.781]                               next
[17:45:18.781]                             if (!grepl(pattern, name)) 
[17:45:18.781]                               next
[17:45:18.781]                             invokeRestart(restart)
[17:45:18.781]                             muffled <- TRUE
[17:45:18.781]                             break
[17:45:18.781]                           }
[17:45:18.781]                         }
[17:45:18.781]                       }
[17:45:18.781]                       invisible(muffled)
[17:45:18.781]                     }
[17:45:18.781]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.781]                   }
[17:45:18.781]                 }
[17:45:18.781]                 else {
[17:45:18.781]                   if (TRUE) {
[17:45:18.781]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.781]                     {
[17:45:18.781]                       inherits <- base::inherits
[17:45:18.781]                       invokeRestart <- base::invokeRestart
[17:45:18.781]                       is.null <- base::is.null
[17:45:18.781]                       muffled <- FALSE
[17:45:18.781]                       if (inherits(cond, "message")) {
[17:45:18.781]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.781]                         if (muffled) 
[17:45:18.781]                           invokeRestart("muffleMessage")
[17:45:18.781]                       }
[17:45:18.781]                       else if (inherits(cond, "warning")) {
[17:45:18.781]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.781]                         if (muffled) 
[17:45:18.781]                           invokeRestart("muffleWarning")
[17:45:18.781]                       }
[17:45:18.781]                       else if (inherits(cond, "condition")) {
[17:45:18.781]                         if (!is.null(pattern)) {
[17:45:18.781]                           computeRestarts <- base::computeRestarts
[17:45:18.781]                           grepl <- base::grepl
[17:45:18.781]                           restarts <- computeRestarts(cond)
[17:45:18.781]                           for (restart in restarts) {
[17:45:18.781]                             name <- restart$name
[17:45:18.781]                             if (is.null(name)) 
[17:45:18.781]                               next
[17:45:18.781]                             if (!grepl(pattern, name)) 
[17:45:18.781]                               next
[17:45:18.781]                             invokeRestart(restart)
[17:45:18.781]                             muffled <- TRUE
[17:45:18.781]                             break
[17:45:18.781]                           }
[17:45:18.781]                         }
[17:45:18.781]                       }
[17:45:18.781]                       invisible(muffled)
[17:45:18.781]                     }
[17:45:18.781]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.781]                   }
[17:45:18.781]                 }
[17:45:18.781]             }
[17:45:18.781]         }))
[17:45:18.781]     }, error = function(ex) {
[17:45:18.781]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.781]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.781]                 ...future.rng), started = ...future.startTime, 
[17:45:18.781]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.781]             version = "1.8"), class = "FutureResult")
[17:45:18.781]     }, finally = {
[17:45:18.781]         if (!identical(...future.workdir, getwd())) 
[17:45:18.781]             setwd(...future.workdir)
[17:45:18.781]         {
[17:45:18.781]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.781]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.781]             }
[17:45:18.781]             base::options(...future.oldOptions)
[17:45:18.781]             if (.Platform$OS.type == "windows") {
[17:45:18.781]                 old_names <- names(...future.oldEnvVars)
[17:45:18.781]                 envs <- base::Sys.getenv()
[17:45:18.781]                 names <- names(envs)
[17:45:18.781]                 common <- intersect(names, old_names)
[17:45:18.781]                 added <- setdiff(names, old_names)
[17:45:18.781]                 removed <- setdiff(old_names, names)
[17:45:18.781]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.781]                   envs[common]]
[17:45:18.781]                 NAMES <- toupper(changed)
[17:45:18.781]                 args <- list()
[17:45:18.781]                 for (kk in seq_along(NAMES)) {
[17:45:18.781]                   name <- changed[[kk]]
[17:45:18.781]                   NAME <- NAMES[[kk]]
[17:45:18.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.781]                     next
[17:45:18.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.781]                 }
[17:45:18.781]                 NAMES <- toupper(added)
[17:45:18.781]                 for (kk in seq_along(NAMES)) {
[17:45:18.781]                   name <- added[[kk]]
[17:45:18.781]                   NAME <- NAMES[[kk]]
[17:45:18.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.781]                     next
[17:45:18.781]                   args[[name]] <- ""
[17:45:18.781]                 }
[17:45:18.781]                 NAMES <- toupper(removed)
[17:45:18.781]                 for (kk in seq_along(NAMES)) {
[17:45:18.781]                   name <- removed[[kk]]
[17:45:18.781]                   NAME <- NAMES[[kk]]
[17:45:18.781]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.781]                     next
[17:45:18.781]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.781]                 }
[17:45:18.781]                 if (length(args) > 0) 
[17:45:18.781]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.781]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.781]             }
[17:45:18.781]             else {
[17:45:18.781]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.781]             }
[17:45:18.781]             {
[17:45:18.781]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.781]                   0L) {
[17:45:18.781]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.781]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.781]                   base::options(opts)
[17:45:18.781]                 }
[17:45:18.781]                 {
[17:45:18.781]                   {
[17:45:18.781]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.781]                     NULL
[17:45:18.781]                   }
[17:45:18.781]                   options(future.plan = NULL)
[17:45:18.781]                   if (is.na(NA_character_)) 
[17:45:18.781]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.781]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.781]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.781]                     .init = FALSE)
[17:45:18.781]                 }
[17:45:18.781]             }
[17:45:18.781]         }
[17:45:18.781]     })
[17:45:18.781]     if (TRUE) {
[17:45:18.781]         base::sink(type = "output", split = FALSE)
[17:45:18.781]         if (TRUE) {
[17:45:18.781]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.781]         }
[17:45:18.781]         else {
[17:45:18.781]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.781]         }
[17:45:18.781]         base::close(...future.stdout)
[17:45:18.781]         ...future.stdout <- NULL
[17:45:18.781]     }
[17:45:18.781]     ...future.result$conditions <- ...future.conditions
[17:45:18.781]     ...future.result$finished <- base::Sys.time()
[17:45:18.781]     ...future.result
[17:45:18.781] }
[17:45:18.783] assign_globals() ...
[17:45:18.783] List of 11
[17:45:18.783]  $ ...future.FUN            :function (x, ...)  
[17:45:18.783]  $ x_FUN                    :function (x)  
[17:45:18.783]  $ times                    : int 2
[17:45:18.783]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.783]  $ stop_if_not              :function (...)  
[17:45:18.783]  $ dim                      : NULL
[17:45:18.783]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.783]  $ future.call.arguments    : list()
[17:45:18.783]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.783]  $ ...future.elements_ii    :List of 5
[17:45:18.783]   ..$ : int 1
[17:45:18.783]   ..$ : int 2
[17:45:18.783]   ..$ : int 3
[17:45:18.783]   ..$ : int 4
[17:45:18.783]   ..$ : int 5
[17:45:18.783]  $ ...future.seeds_ii       : NULL
[17:45:18.783]  $ ...future.globals.maxSize: NULL
[17:45:18.783]  - attr(*, "where")=List of 11
[17:45:18.783]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.783]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.783]  - attr(*, "resolved")= logi FALSE
[17:45:18.783]  - attr(*, "total_size")= num 96456
[17:45:18.783]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.783]  - attr(*, "already-done")= logi TRUE
[17:45:18.794] - copied ‘...future.FUN’ to environment
[17:45:18.794] - reassign environment for ‘x_FUN’
[17:45:18.794] - copied ‘x_FUN’ to environment
[17:45:18.794] - copied ‘times’ to environment
[17:45:18.794] - copied ‘stopf’ to environment
[17:45:18.794] - copied ‘stop_if_not’ to environment
[17:45:18.794] - copied ‘dim’ to environment
[17:45:18.794] - copied ‘valid_types’ to environment
[17:45:18.795] - copied ‘future.call.arguments’ to environment
[17:45:18.795] - copied ‘...future.elements_ii’ to environment
[17:45:18.795] - copied ‘...future.seeds_ii’ to environment
[17:45:18.795] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.795] assign_globals() ... done
[17:45:18.795] requestCore(): workers = 2
[17:45:18.797] MulticoreFuture started
[17:45:18.798] - Launch lazy future ... done
[17:45:18.798] run() for ‘MulticoreFuture’ ... done
[17:45:18.799] Created future:
[17:45:18.799] plan(): Setting new future strategy stack:
[17:45:18.799] List of future strategies:
[17:45:18.799] 1. sequential:
[17:45:18.799]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.799]    - tweaked: FALSE
[17:45:18.799]    - call: NULL
[17:45:18.800] plan(): nbrOfWorkers() = 1
[17:45:18.803] plan(): Setting new future strategy stack:
[17:45:18.803] List of future strategies:
[17:45:18.803] 1. multicore:
[17:45:18.803]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.803]    - tweaked: FALSE
[17:45:18.803]    - call: plan(strategy)
[17:45:18.808] plan(): nbrOfWorkers() = 2
[17:45:18.799] MulticoreFuture:
[17:45:18.799] Label: ‘future_vapply-1’
[17:45:18.799] Expression:
[17:45:18.799] {
[17:45:18.799]     do.call(function(...) {
[17:45:18.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.799]             on.exit(options(oopts), add = TRUE)
[17:45:18.799]         }
[17:45:18.799]         {
[17:45:18.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.799]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.799]             })
[17:45:18.799]         }
[17:45:18.799]     }, args = future.call.arguments)
[17:45:18.799] }
[17:45:18.799] Lazy evaluation: FALSE
[17:45:18.799] Asynchronous evaluation: TRUE
[17:45:18.799] Local evaluation: TRUE
[17:45:18.799] Environment: R_GlobalEnv
[17:45:18.799] Capture standard output: TRUE
[17:45:18.799] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.799] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.799] Packages: 1 packages (‘future.apply’)
[17:45:18.799] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.799] Resolved: TRUE
[17:45:18.799] Value: <not collected>
[17:45:18.799] Conditions captured: <none>
[17:45:18.799] Early signaling: FALSE
[17:45:18.799] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.799] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.809] Chunk #1 of 2 ... DONE
[17:45:18.809] Chunk #2 of 2 ...
[17:45:18.809]  - Finding globals in 'X' for chunk #2 ...
[17:45:18.809] getGlobalsAndPackages() ...
[17:45:18.809] Searching for globals...
[17:45:18.810] 
[17:45:18.810] Searching for globals ... DONE
[17:45:18.810] - globals: [0] <none>
[17:45:18.810] getGlobalsAndPackages() ... DONE
[17:45:18.810]    + additional globals found: [n=0] 
[17:45:18.811]    + additional namespaces needed: [n=0] 
[17:45:18.811]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:18.811]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.811]  - seeds: <none>
[17:45:18.811]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.811] getGlobalsAndPackages() ...
[17:45:18.811] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.812] Resolving globals: FALSE
[17:45:18.812] Tweak future expression to call with '...' arguments ...
[17:45:18.812] {
[17:45:18.812]     do.call(function(...) {
[17:45:18.812]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.812]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.812]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.812]             on.exit(options(oopts), add = TRUE)
[17:45:18.812]         }
[17:45:18.812]         {
[17:45:18.812]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.812]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.812]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.812]             })
[17:45:18.812]         }
[17:45:18.812]     }, args = future.call.arguments)
[17:45:18.812] }
[17:45:18.812] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.813] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.813] - packages: [1] ‘future.apply’
[17:45:18.814] getGlobalsAndPackages() ... DONE
[17:45:18.814] run() for ‘Future’ ...
[17:45:18.814] - state: ‘created’
[17:45:18.814] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.819] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.819] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.819]   - Field: ‘label’
[17:45:18.820]   - Field: ‘local’
[17:45:18.820]   - Field: ‘owner’
[17:45:18.820]   - Field: ‘envir’
[17:45:18.820]   - Field: ‘workers’
[17:45:18.820]   - Field: ‘packages’
[17:45:18.820]   - Field: ‘gc’
[17:45:18.820]   - Field: ‘job’
[17:45:18.821]   - Field: ‘conditions’
[17:45:18.821]   - Field: ‘expr’
[17:45:18.821]   - Field: ‘uuid’
[17:45:18.821]   - Field: ‘seed’
[17:45:18.821]   - Field: ‘version’
[17:45:18.821]   - Field: ‘result’
[17:45:18.821]   - Field: ‘asynchronous’
[17:45:18.822]   - Field: ‘calls’
[17:45:18.822]   - Field: ‘globals’
[17:45:18.822]   - Field: ‘stdout’
[17:45:18.822]   - Field: ‘earlySignal’
[17:45:18.822]   - Field: ‘lazy’
[17:45:18.822]   - Field: ‘state’
[17:45:18.822] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.823] - Launch lazy future ...
[17:45:18.823] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.823] Packages needed by future strategies (n = 0): <none>
[17:45:18.824] {
[17:45:18.824]     {
[17:45:18.824]         {
[17:45:18.824]             ...future.startTime <- base::Sys.time()
[17:45:18.824]             {
[17:45:18.824]                 {
[17:45:18.824]                   {
[17:45:18.824]                     {
[17:45:18.824]                       {
[17:45:18.824]                         base::local({
[17:45:18.824]                           has_future <- base::requireNamespace("future", 
[17:45:18.824]                             quietly = TRUE)
[17:45:18.824]                           if (has_future) {
[17:45:18.824]                             ns <- base::getNamespace("future")
[17:45:18.824]                             version <- ns[[".package"]][["version"]]
[17:45:18.824]                             if (is.null(version)) 
[17:45:18.824]                               version <- utils::packageVersion("future")
[17:45:18.824]                           }
[17:45:18.824]                           else {
[17:45:18.824]                             version <- NULL
[17:45:18.824]                           }
[17:45:18.824]                           if (!has_future || version < "1.8.0") {
[17:45:18.824]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.824]                               "", base::R.version$version.string), 
[17:45:18.824]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.824]                                 base::R.version$platform, 8 * 
[17:45:18.824]                                   base::.Machine$sizeof.pointer), 
[17:45:18.824]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.824]                                 "release", "version")], collapse = " "), 
[17:45:18.824]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.824]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.824]                               info)
[17:45:18.824]                             info <- base::paste(info, collapse = "; ")
[17:45:18.824]                             if (!has_future) {
[17:45:18.824]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.824]                                 info)
[17:45:18.824]                             }
[17:45:18.824]                             else {
[17:45:18.824]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.824]                                 info, version)
[17:45:18.824]                             }
[17:45:18.824]                             base::stop(msg)
[17:45:18.824]                           }
[17:45:18.824]                         })
[17:45:18.824]                       }
[17:45:18.824]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.824]                       base::options(mc.cores = 1L)
[17:45:18.824]                     }
[17:45:18.824]                     base::local({
[17:45:18.824]                       for (pkg in "future.apply") {
[17:45:18.824]                         base::loadNamespace(pkg)
[17:45:18.824]                         base::library(pkg, character.only = TRUE)
[17:45:18.824]                       }
[17:45:18.824]                     })
[17:45:18.824]                   }
[17:45:18.824]                   ...future.strategy.old <- future::plan("list")
[17:45:18.824]                   options(future.plan = NULL)
[17:45:18.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.824]                 }
[17:45:18.824]                 ...future.workdir <- getwd()
[17:45:18.824]             }
[17:45:18.824]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.824]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.824]         }
[17:45:18.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.824]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.824]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.824]             base::names(...future.oldOptions))
[17:45:18.824]     }
[17:45:18.824]     if (FALSE) {
[17:45:18.824]     }
[17:45:18.824]     else {
[17:45:18.824]         if (TRUE) {
[17:45:18.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.824]                 open = "w")
[17:45:18.824]         }
[17:45:18.824]         else {
[17:45:18.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.824]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.824]         }
[17:45:18.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.824]             base::sink(type = "output", split = FALSE)
[17:45:18.824]             base::close(...future.stdout)
[17:45:18.824]         }, add = TRUE)
[17:45:18.824]     }
[17:45:18.824]     ...future.frame <- base::sys.nframe()
[17:45:18.824]     ...future.conditions <- base::list()
[17:45:18.824]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.824]     if (FALSE) {
[17:45:18.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.824]     }
[17:45:18.824]     ...future.result <- base::tryCatch({
[17:45:18.824]         base::withCallingHandlers({
[17:45:18.824]             ...future.value <- base::withVisible(base::local({
[17:45:18.824]                 withCallingHandlers({
[17:45:18.824]                   {
[17:45:18.824]                     do.call(function(...) {
[17:45:18.824]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.824]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.824]                         ...future.globals.maxSize)) {
[17:45:18.824]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.824]                         on.exit(options(oopts), add = TRUE)
[17:45:18.824]                       }
[17:45:18.824]                       {
[17:45:18.824]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.824]                           FUN = function(jj) {
[17:45:18.824]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.824]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.824]                           })
[17:45:18.824]                       }
[17:45:18.824]                     }, args = future.call.arguments)
[17:45:18.824]                   }
[17:45:18.824]                 }, immediateCondition = function(cond) {
[17:45:18.824]                   save_rds <- function (object, pathname, ...) 
[17:45:18.824]                   {
[17:45:18.824]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.824]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.824]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.824]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.824]                         fi_tmp[["mtime"]])
[17:45:18.824]                     }
[17:45:18.824]                     tryCatch({
[17:45:18.824]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.824]                     }, error = function(ex) {
[17:45:18.824]                       msg <- conditionMessage(ex)
[17:45:18.824]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.824]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.824]                         fi_tmp[["mtime"]], msg)
[17:45:18.824]                       ex$message <- msg
[17:45:18.824]                       stop(ex)
[17:45:18.824]                     })
[17:45:18.824]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.824]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.824]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.824]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.824]                       fi <- file.info(pathname)
[17:45:18.824]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.824]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.824]                         fi[["size"]], fi[["mtime"]])
[17:45:18.824]                       stop(msg)
[17:45:18.824]                     }
[17:45:18.824]                     invisible(pathname)
[17:45:18.824]                   }
[17:45:18.824]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.824]                     rootPath = tempdir()) 
[17:45:18.824]                   {
[17:45:18.824]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.824]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.824]                       tmpdir = path, fileext = ".rds")
[17:45:18.824]                     save_rds(obj, file)
[17:45:18.824]                   }
[17:45:18.824]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.824]                   {
[17:45:18.824]                     inherits <- base::inherits
[17:45:18.824]                     invokeRestart <- base::invokeRestart
[17:45:18.824]                     is.null <- base::is.null
[17:45:18.824]                     muffled <- FALSE
[17:45:18.824]                     if (inherits(cond, "message")) {
[17:45:18.824]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.824]                       if (muffled) 
[17:45:18.824]                         invokeRestart("muffleMessage")
[17:45:18.824]                     }
[17:45:18.824]                     else if (inherits(cond, "warning")) {
[17:45:18.824]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.824]                       if (muffled) 
[17:45:18.824]                         invokeRestart("muffleWarning")
[17:45:18.824]                     }
[17:45:18.824]                     else if (inherits(cond, "condition")) {
[17:45:18.824]                       if (!is.null(pattern)) {
[17:45:18.824]                         computeRestarts <- base::computeRestarts
[17:45:18.824]                         grepl <- base::grepl
[17:45:18.824]                         restarts <- computeRestarts(cond)
[17:45:18.824]                         for (restart in restarts) {
[17:45:18.824]                           name <- restart$name
[17:45:18.824]                           if (is.null(name)) 
[17:45:18.824]                             next
[17:45:18.824]                           if (!grepl(pattern, name)) 
[17:45:18.824]                             next
[17:45:18.824]                           invokeRestart(restart)
[17:45:18.824]                           muffled <- TRUE
[17:45:18.824]                           break
[17:45:18.824]                         }
[17:45:18.824]                       }
[17:45:18.824]                     }
[17:45:18.824]                     invisible(muffled)
[17:45:18.824]                   }
[17:45:18.824]                   muffleCondition(cond)
[17:45:18.824]                 })
[17:45:18.824]             }))
[17:45:18.824]             future::FutureResult(value = ...future.value$value, 
[17:45:18.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.824]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.824]                     ...future.globalenv.names))
[17:45:18.824]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.824]         }, condition = base::local({
[17:45:18.824]             c <- base::c
[17:45:18.824]             inherits <- base::inherits
[17:45:18.824]             invokeRestart <- base::invokeRestart
[17:45:18.824]             length <- base::length
[17:45:18.824]             list <- base::list
[17:45:18.824]             seq.int <- base::seq.int
[17:45:18.824]             signalCondition <- base::signalCondition
[17:45:18.824]             sys.calls <- base::sys.calls
[17:45:18.824]             `[[` <- base::`[[`
[17:45:18.824]             `+` <- base::`+`
[17:45:18.824]             `<<-` <- base::`<<-`
[17:45:18.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.824]                   3L)]
[17:45:18.824]             }
[17:45:18.824]             function(cond) {
[17:45:18.824]                 is_error <- inherits(cond, "error")
[17:45:18.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.824]                   NULL)
[17:45:18.824]                 if (is_error) {
[17:45:18.824]                   sessionInformation <- function() {
[17:45:18.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.824]                       search = base::search(), system = base::Sys.info())
[17:45:18.824]                   }
[17:45:18.824]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.824]                     cond$call), session = sessionInformation(), 
[17:45:18.824]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.824]                   signalCondition(cond)
[17:45:18.824]                 }
[17:45:18.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.824]                 "immediateCondition"))) {
[17:45:18.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.824]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.824]                   if (TRUE && !signal) {
[17:45:18.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.824]                     {
[17:45:18.824]                       inherits <- base::inherits
[17:45:18.824]                       invokeRestart <- base::invokeRestart
[17:45:18.824]                       is.null <- base::is.null
[17:45:18.824]                       muffled <- FALSE
[17:45:18.824]                       if (inherits(cond, "message")) {
[17:45:18.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.824]                         if (muffled) 
[17:45:18.824]                           invokeRestart("muffleMessage")
[17:45:18.824]                       }
[17:45:18.824]                       else if (inherits(cond, "warning")) {
[17:45:18.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.824]                         if (muffled) 
[17:45:18.824]                           invokeRestart("muffleWarning")
[17:45:18.824]                       }
[17:45:18.824]                       else if (inherits(cond, "condition")) {
[17:45:18.824]                         if (!is.null(pattern)) {
[17:45:18.824]                           computeRestarts <- base::computeRestarts
[17:45:18.824]                           grepl <- base::grepl
[17:45:18.824]                           restarts <- computeRestarts(cond)
[17:45:18.824]                           for (restart in restarts) {
[17:45:18.824]                             name <- restart$name
[17:45:18.824]                             if (is.null(name)) 
[17:45:18.824]                               next
[17:45:18.824]                             if (!grepl(pattern, name)) 
[17:45:18.824]                               next
[17:45:18.824]                             invokeRestart(restart)
[17:45:18.824]                             muffled <- TRUE
[17:45:18.824]                             break
[17:45:18.824]                           }
[17:45:18.824]                         }
[17:45:18.824]                       }
[17:45:18.824]                       invisible(muffled)
[17:45:18.824]                     }
[17:45:18.824]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.824]                   }
[17:45:18.824]                 }
[17:45:18.824]                 else {
[17:45:18.824]                   if (TRUE) {
[17:45:18.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.824]                     {
[17:45:18.824]                       inherits <- base::inherits
[17:45:18.824]                       invokeRestart <- base::invokeRestart
[17:45:18.824]                       is.null <- base::is.null
[17:45:18.824]                       muffled <- FALSE
[17:45:18.824]                       if (inherits(cond, "message")) {
[17:45:18.824]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.824]                         if (muffled) 
[17:45:18.824]                           invokeRestart("muffleMessage")
[17:45:18.824]                       }
[17:45:18.824]                       else if (inherits(cond, "warning")) {
[17:45:18.824]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.824]                         if (muffled) 
[17:45:18.824]                           invokeRestart("muffleWarning")
[17:45:18.824]                       }
[17:45:18.824]                       else if (inherits(cond, "condition")) {
[17:45:18.824]                         if (!is.null(pattern)) {
[17:45:18.824]                           computeRestarts <- base::computeRestarts
[17:45:18.824]                           grepl <- base::grepl
[17:45:18.824]                           restarts <- computeRestarts(cond)
[17:45:18.824]                           for (restart in restarts) {
[17:45:18.824]                             name <- restart$name
[17:45:18.824]                             if (is.null(name)) 
[17:45:18.824]                               next
[17:45:18.824]                             if (!grepl(pattern, name)) 
[17:45:18.824]                               next
[17:45:18.824]                             invokeRestart(restart)
[17:45:18.824]                             muffled <- TRUE
[17:45:18.824]                             break
[17:45:18.824]                           }
[17:45:18.824]                         }
[17:45:18.824]                       }
[17:45:18.824]                       invisible(muffled)
[17:45:18.824]                     }
[17:45:18.824]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.824]                   }
[17:45:18.824]                 }
[17:45:18.824]             }
[17:45:18.824]         }))
[17:45:18.824]     }, error = function(ex) {
[17:45:18.824]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.824]                 ...future.rng), started = ...future.startTime, 
[17:45:18.824]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.824]             version = "1.8"), class = "FutureResult")
[17:45:18.824]     }, finally = {
[17:45:18.824]         if (!identical(...future.workdir, getwd())) 
[17:45:18.824]             setwd(...future.workdir)
[17:45:18.824]         {
[17:45:18.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.824]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.824]             }
[17:45:18.824]             base::options(...future.oldOptions)
[17:45:18.824]             if (.Platform$OS.type == "windows") {
[17:45:18.824]                 old_names <- names(...future.oldEnvVars)
[17:45:18.824]                 envs <- base::Sys.getenv()
[17:45:18.824]                 names <- names(envs)
[17:45:18.824]                 common <- intersect(names, old_names)
[17:45:18.824]                 added <- setdiff(names, old_names)
[17:45:18.824]                 removed <- setdiff(old_names, names)
[17:45:18.824]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.824]                   envs[common]]
[17:45:18.824]                 NAMES <- toupper(changed)
[17:45:18.824]                 args <- list()
[17:45:18.824]                 for (kk in seq_along(NAMES)) {
[17:45:18.824]                   name <- changed[[kk]]
[17:45:18.824]                   NAME <- NAMES[[kk]]
[17:45:18.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.824]                     next
[17:45:18.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.824]                 }
[17:45:18.824]                 NAMES <- toupper(added)
[17:45:18.824]                 for (kk in seq_along(NAMES)) {
[17:45:18.824]                   name <- added[[kk]]
[17:45:18.824]                   NAME <- NAMES[[kk]]
[17:45:18.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.824]                     next
[17:45:18.824]                   args[[name]] <- ""
[17:45:18.824]                 }
[17:45:18.824]                 NAMES <- toupper(removed)
[17:45:18.824]                 for (kk in seq_along(NAMES)) {
[17:45:18.824]                   name <- removed[[kk]]
[17:45:18.824]                   NAME <- NAMES[[kk]]
[17:45:18.824]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.824]                     next
[17:45:18.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.824]                 }
[17:45:18.824]                 if (length(args) > 0) 
[17:45:18.824]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.824]             }
[17:45:18.824]             else {
[17:45:18.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.824]             }
[17:45:18.824]             {
[17:45:18.824]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.824]                   0L) {
[17:45:18.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.824]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.824]                   base::options(opts)
[17:45:18.824]                 }
[17:45:18.824]                 {
[17:45:18.824]                   {
[17:45:18.824]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.824]                     NULL
[17:45:18.824]                   }
[17:45:18.824]                   options(future.plan = NULL)
[17:45:18.824]                   if (is.na(NA_character_)) 
[17:45:18.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.824]                     .init = FALSE)
[17:45:18.824]                 }
[17:45:18.824]             }
[17:45:18.824]         }
[17:45:18.824]     })
[17:45:18.824]     if (TRUE) {
[17:45:18.824]         base::sink(type = "output", split = FALSE)
[17:45:18.824]         if (TRUE) {
[17:45:18.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.824]         }
[17:45:18.824]         else {
[17:45:18.824]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.824]         }
[17:45:18.824]         base::close(...future.stdout)
[17:45:18.824]         ...future.stdout <- NULL
[17:45:18.824]     }
[17:45:18.824]     ...future.result$conditions <- ...future.conditions
[17:45:18.824]     ...future.result$finished <- base::Sys.time()
[17:45:18.824]     ...future.result
[17:45:18.824] }
[17:45:18.828] assign_globals() ...
[17:45:18.828] List of 11
[17:45:18.828]  $ ...future.FUN            :function (x, ...)  
[17:45:18.828]  $ x_FUN                    :function (x)  
[17:45:18.828]  $ times                    : int 2
[17:45:18.828]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.828]  $ stop_if_not              :function (...)  
[17:45:18.828]  $ dim                      : NULL
[17:45:18.828]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:18.828]  $ future.call.arguments    : list()
[17:45:18.828]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.828]  $ ...future.elements_ii    :List of 5
[17:45:18.828]   ..$ : int 6
[17:45:18.828]   ..$ : int 7
[17:45:18.828]   ..$ : int 8
[17:45:18.828]   ..$ : int 9
[17:45:18.828]   ..$ : int 10
[17:45:18.828]  $ ...future.seeds_ii       : NULL
[17:45:18.828]  $ ...future.globals.maxSize: NULL
[17:45:18.828]  - attr(*, "where")=List of 11
[17:45:18.828]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.828]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.828]  - attr(*, "resolved")= logi FALSE
[17:45:18.828]  - attr(*, "total_size")= num 96456
[17:45:18.828]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.828]  - attr(*, "already-done")= logi TRUE
[17:45:18.844] - copied ‘...future.FUN’ to environment
[17:45:18.844] - reassign environment for ‘x_FUN’
[17:45:18.844] - copied ‘x_FUN’ to environment
[17:45:18.844] - copied ‘times’ to environment
[17:45:18.844] - copied ‘stopf’ to environment
[17:45:18.844] - copied ‘stop_if_not’ to environment
[17:45:18.845] - copied ‘dim’ to environment
[17:45:18.845] - copied ‘valid_types’ to environment
[17:45:18.845] - copied ‘future.call.arguments’ to environment
[17:45:18.845] - copied ‘...future.elements_ii’ to environment
[17:45:18.845] - copied ‘...future.seeds_ii’ to environment
[17:45:18.845] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.845] assign_globals() ... done
[17:45:18.845] requestCore(): workers = 2
[17:45:18.848] MulticoreFuture started
[17:45:18.848] - Launch lazy future ... done
[17:45:18.848] run() for ‘MulticoreFuture’ ... done
[17:45:18.849] Created future:
[17:45:18.849] plan(): Setting new future strategy stack:
[17:45:18.850] List of future strategies:
[17:45:18.850] 1. sequential:
[17:45:18.850]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.850]    - tweaked: FALSE
[17:45:18.850]    - call: NULL
[17:45:18.851] plan(): nbrOfWorkers() = 1
[17:45:18.853] plan(): Setting new future strategy stack:
[17:45:18.853] List of future strategies:
[17:45:18.853] 1. multicore:
[17:45:18.853]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.853]    - tweaked: FALSE
[17:45:18.853]    - call: plan(strategy)
[17:45:18.858] plan(): nbrOfWorkers() = 2
[17:45:18.849] MulticoreFuture:
[17:45:18.849] Label: ‘future_vapply-2’
[17:45:18.849] Expression:
[17:45:18.849] {
[17:45:18.849]     do.call(function(...) {
[17:45:18.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.849]             on.exit(options(oopts), add = TRUE)
[17:45:18.849]         }
[17:45:18.849]         {
[17:45:18.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.849]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.849]             })
[17:45:18.849]         }
[17:45:18.849]     }, args = future.call.arguments)
[17:45:18.849] }
[17:45:18.849] Lazy evaluation: FALSE
[17:45:18.849] Asynchronous evaluation: TRUE
[17:45:18.849] Local evaluation: TRUE
[17:45:18.849] Environment: R_GlobalEnv
[17:45:18.849] Capture standard output: TRUE
[17:45:18.849] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.849] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.849] Packages: 1 packages (‘future.apply’)
[17:45:18.849] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.849] Resolved: TRUE
[17:45:18.849] Value: <not collected>
[17:45:18.849] Conditions captured: <none>
[17:45:18.849] Early signaling: FALSE
[17:45:18.849] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.849] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.859] Chunk #2 of 2 ... DONE
[17:45:18.859] Launching 2 futures (chunks) ... DONE
[17:45:18.860] Resolving 2 futures (chunks) ...
[17:45:18.860] resolve() on list ...
[17:45:18.860]  recursive: 0
[17:45:18.860]  length: 2
[17:45:18.860] 
[17:45:18.861] Future #1
[17:45:18.861] result() for MulticoreFuture ...
[17:45:18.862] result() for MulticoreFuture ...
[17:45:18.862] result() for MulticoreFuture ... done
[17:45:18.862] result() for MulticoreFuture ... done
[17:45:18.862] result() for MulticoreFuture ...
[17:45:18.862] result() for MulticoreFuture ... done
[17:45:18.862] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:18.862] - nx: 2
[17:45:18.863] - relay: TRUE
[17:45:18.863] - stdout: TRUE
[17:45:18.863] - signal: TRUE
[17:45:18.863] - resignal: FALSE
[17:45:18.863] - force: TRUE
[17:45:18.863] - relayed: [n=2] FALSE, FALSE
[17:45:18.863] - queued futures: [n=2] FALSE, FALSE
[17:45:18.864]  - until=1
[17:45:18.864]  - relaying element #1
[17:45:18.864] result() for MulticoreFuture ...
[17:45:18.864] result() for MulticoreFuture ... done
[17:45:18.864] result() for MulticoreFuture ...
[17:45:18.864] result() for MulticoreFuture ... done
[17:45:18.864] result() for MulticoreFuture ...
[17:45:18.865] result() for MulticoreFuture ... done
[17:45:18.865] result() for MulticoreFuture ...
[17:45:18.865] result() for MulticoreFuture ... done
[17:45:18.865] - relayed: [n=2] TRUE, FALSE
[17:45:18.865] - queued futures: [n=2] TRUE, FALSE
[17:45:18.865] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:18.866]  length: 1 (resolved future 1)
[17:45:18.866] Future #2
[17:45:18.866] result() for MulticoreFuture ...
[17:45:18.867] result() for MulticoreFuture ...
[17:45:18.867] result() for MulticoreFuture ... done
[17:45:18.867] result() for MulticoreFuture ... done
[17:45:18.867] result() for MulticoreFuture ...
[17:45:18.867] result() for MulticoreFuture ... done
[17:45:18.868] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:18.868] - nx: 2
[17:45:18.868] - relay: TRUE
[17:45:18.868] - stdout: TRUE
[17:45:18.868] - signal: TRUE
[17:45:18.868] - resignal: FALSE
[17:45:18.868] - force: TRUE
[17:45:18.868] - relayed: [n=2] TRUE, FALSE
[17:45:18.869] - queued futures: [n=2] TRUE, FALSE
[17:45:18.869]  - until=2
[17:45:18.869]  - relaying element #2
[17:45:18.869] result() for MulticoreFuture ...
[17:45:18.869] result() for MulticoreFuture ... done
[17:45:18.869] result() for MulticoreFuture ...
[17:45:18.869] result() for MulticoreFuture ... done
[17:45:18.869] result() for MulticoreFuture ...
[17:45:18.870] result() for MulticoreFuture ... done
[17:45:18.870] result() for MulticoreFuture ...
[17:45:18.870] result() for MulticoreFuture ... done
[17:45:18.870] - relayed: [n=2] TRUE, TRUE
[17:45:18.870] - queued futures: [n=2] TRUE, TRUE
[17:45:18.870] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:18.870]  length: 0 (resolved future 2)
[17:45:18.870] Relaying remaining futures
[17:45:18.871] signalConditionsASAP(NULL, pos=0) ...
[17:45:18.871] - nx: 2
[17:45:18.871] - relay: TRUE
[17:45:18.871] - stdout: TRUE
[17:45:18.871] - signal: TRUE
[17:45:18.871] - resignal: FALSE
[17:45:18.871] - force: TRUE
[17:45:18.871] - relayed: [n=2] TRUE, TRUE
[17:45:18.871] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:18.872] - relayed: [n=2] TRUE, TRUE
[17:45:18.872] - queued futures: [n=2] TRUE, TRUE
[17:45:18.872] signalConditionsASAP(NULL, pos=0) ... done
[17:45:18.872] resolve() on list ... DONE
[17:45:18.872] result() for MulticoreFuture ...
[17:45:18.872] result() for MulticoreFuture ... done
[17:45:18.872] result() for MulticoreFuture ...
[17:45:18.872] result() for MulticoreFuture ... done
[17:45:18.872] result() for MulticoreFuture ...
[17:45:18.873] result() for MulticoreFuture ... done
[17:45:18.873] result() for MulticoreFuture ...
[17:45:18.873] result() for MulticoreFuture ... done
[17:45:18.873]  - Number of value chunks collected: 2
[17:45:18.873] Resolving 2 futures (chunks) ... DONE
[17:45:18.873] Reducing values from 2 chunks ...
[17:45:18.873]  - Number of values collected after concatenation: 10
[17:45:18.873]  - Number of values expected: 10
[17:45:18.873] Reducing values from 2 chunks ... DONE
[17:45:18.874] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:45:18.875] future_lapply() ...
[17:45:18.883] Number of chunks: 2
[17:45:18.883] getGlobalsAndPackagesXApply() ...
[17:45:18.883]  - future.globals: TRUE
[17:45:18.883] getGlobalsAndPackages() ...
[17:45:18.884] Searching for globals...
[17:45:18.889] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:45:18.889] Searching for globals ... DONE
[17:45:18.889] Resolving globals: FALSE
[17:45:18.890] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:45:18.890] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:18.890] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.890] - packages: [1] ‘future.apply’
[17:45:18.891] getGlobalsAndPackages() ... DONE
[17:45:18.891]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:18.891]  - needed namespaces: [n=1] ‘future.apply’
[17:45:18.891] Finding globals ... DONE
[17:45:18.891]  - use_args: TRUE
[17:45:18.891]  - Getting '...' globals ...
[17:45:18.891] resolve() on list ...
[17:45:18.892]  recursive: 0
[17:45:18.892]  length: 1
[17:45:18.892]  elements: ‘...’
[17:45:18.892]  length: 0 (resolved future 1)
[17:45:18.892] resolve() on list ... DONE
[17:45:18.892]    - '...' content: [n=0] 
[17:45:18.892] List of 1
[17:45:18.892]  $ ...: list()
[17:45:18.892]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.892]  - attr(*, "where")=List of 1
[17:45:18.892]   ..$ ...:<environment: 0x5561f548c578> 
[17:45:18.892]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.892]  - attr(*, "resolved")= logi TRUE
[17:45:18.892]  - attr(*, "total_size")= num NA
[17:45:18.895]  - Getting '...' globals ... DONE
[17:45:18.895] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:18.895] List of 8
[17:45:18.895]  $ ...future.FUN:function (x, ...)  
[17:45:18.895]  $ x_FUN        :function (x)  
[17:45:18.895]  $ times        : int 4
[17:45:18.895]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.895]  $ stop_if_not  :function (...)  
[17:45:18.895]  $ dim          : int [1:2] 2 2
[17:45:18.895]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:18.895]  $ ...          : list()
[17:45:18.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.895]  - attr(*, "where")=List of 8
[17:45:18.895]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:18.895]   ..$ ...          :<environment: 0x5561f548c578> 
[17:45:18.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.895]  - attr(*, "resolved")= logi FALSE
[17:45:18.895]  - attr(*, "total_size")= num 97232
[17:45:18.900] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:18.900] getGlobalsAndPackagesXApply() ... DONE
[17:45:18.901] Number of futures (= number of chunks): 2
[17:45:18.901] Launching 2 futures (chunks) ...
[17:45:18.901] Chunk #1 of 2 ...
[17:45:18.901]  - Finding globals in 'X' for chunk #1 ...
[17:45:18.901] getGlobalsAndPackages() ...
[17:45:18.901] Searching for globals...
[17:45:18.901] 
[17:45:18.901] Searching for globals ... DONE
[17:45:18.902] - globals: [0] <none>
[17:45:18.902] getGlobalsAndPackages() ... DONE
[17:45:18.902]    + additional globals found: [n=0] 
[17:45:18.902]    + additional namespaces needed: [n=0] 
[17:45:18.902]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:18.902]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.902]  - seeds: <none>
[17:45:18.902]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.902] getGlobalsAndPackages() ...
[17:45:18.902] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.902] Resolving globals: FALSE
[17:45:18.903] Tweak future expression to call with '...' arguments ...
[17:45:18.903] {
[17:45:18.903]     do.call(function(...) {
[17:45:18.903]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.903]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.903]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.903]             on.exit(options(oopts), add = TRUE)
[17:45:18.903]         }
[17:45:18.903]         {
[17:45:18.903]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.903]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.903]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.903]             })
[17:45:18.903]         }
[17:45:18.903]     }, args = future.call.arguments)
[17:45:18.903] }
[17:45:18.903] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.905] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.905] - packages: [1] ‘future.apply’
[17:45:18.905] getGlobalsAndPackages() ... DONE
[17:45:18.906] run() for ‘Future’ ...
[17:45:18.906] - state: ‘created’
[17:45:18.906] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.910]   - Field: ‘label’
[17:45:18.910]   - Field: ‘local’
[17:45:18.910]   - Field: ‘owner’
[17:45:18.910]   - Field: ‘envir’
[17:45:18.911]   - Field: ‘workers’
[17:45:18.911]   - Field: ‘packages’
[17:45:18.911]   - Field: ‘gc’
[17:45:18.911]   - Field: ‘job’
[17:45:18.911]   - Field: ‘conditions’
[17:45:18.911]   - Field: ‘expr’
[17:45:18.911]   - Field: ‘uuid’
[17:45:18.911]   - Field: ‘seed’
[17:45:18.911]   - Field: ‘version’
[17:45:18.912]   - Field: ‘result’
[17:45:18.912]   - Field: ‘asynchronous’
[17:45:18.912]   - Field: ‘calls’
[17:45:18.912]   - Field: ‘globals’
[17:45:18.912]   - Field: ‘stdout’
[17:45:18.912]   - Field: ‘earlySignal’
[17:45:18.912]   - Field: ‘lazy’
[17:45:18.912]   - Field: ‘state’
[17:45:18.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.913] - Launch lazy future ...
[17:45:18.913] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.913] Packages needed by future strategies (n = 0): <none>
[17:45:18.914] {
[17:45:18.914]     {
[17:45:18.914]         {
[17:45:18.914]             ...future.startTime <- base::Sys.time()
[17:45:18.914]             {
[17:45:18.914]                 {
[17:45:18.914]                   {
[17:45:18.914]                     {
[17:45:18.914]                       {
[17:45:18.914]                         base::local({
[17:45:18.914]                           has_future <- base::requireNamespace("future", 
[17:45:18.914]                             quietly = TRUE)
[17:45:18.914]                           if (has_future) {
[17:45:18.914]                             ns <- base::getNamespace("future")
[17:45:18.914]                             version <- ns[[".package"]][["version"]]
[17:45:18.914]                             if (is.null(version)) 
[17:45:18.914]                               version <- utils::packageVersion("future")
[17:45:18.914]                           }
[17:45:18.914]                           else {
[17:45:18.914]                             version <- NULL
[17:45:18.914]                           }
[17:45:18.914]                           if (!has_future || version < "1.8.0") {
[17:45:18.914]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.914]                               "", base::R.version$version.string), 
[17:45:18.914]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.914]                                 base::R.version$platform, 8 * 
[17:45:18.914]                                   base::.Machine$sizeof.pointer), 
[17:45:18.914]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.914]                                 "release", "version")], collapse = " "), 
[17:45:18.914]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.914]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.914]                               info)
[17:45:18.914]                             info <- base::paste(info, collapse = "; ")
[17:45:18.914]                             if (!has_future) {
[17:45:18.914]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.914]                                 info)
[17:45:18.914]                             }
[17:45:18.914]                             else {
[17:45:18.914]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.914]                                 info, version)
[17:45:18.914]                             }
[17:45:18.914]                             base::stop(msg)
[17:45:18.914]                           }
[17:45:18.914]                         })
[17:45:18.914]                       }
[17:45:18.914]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.914]                       base::options(mc.cores = 1L)
[17:45:18.914]                     }
[17:45:18.914]                     base::local({
[17:45:18.914]                       for (pkg in "future.apply") {
[17:45:18.914]                         base::loadNamespace(pkg)
[17:45:18.914]                         base::library(pkg, character.only = TRUE)
[17:45:18.914]                       }
[17:45:18.914]                     })
[17:45:18.914]                   }
[17:45:18.914]                   ...future.strategy.old <- future::plan("list")
[17:45:18.914]                   options(future.plan = NULL)
[17:45:18.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.914]                 }
[17:45:18.914]                 ...future.workdir <- getwd()
[17:45:18.914]             }
[17:45:18.914]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.914]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.914]         }
[17:45:18.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.914]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.914]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.914]             base::names(...future.oldOptions))
[17:45:18.914]     }
[17:45:18.914]     if (FALSE) {
[17:45:18.914]     }
[17:45:18.914]     else {
[17:45:18.914]         if (TRUE) {
[17:45:18.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.914]                 open = "w")
[17:45:18.914]         }
[17:45:18.914]         else {
[17:45:18.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.914]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.914]         }
[17:45:18.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.914]             base::sink(type = "output", split = FALSE)
[17:45:18.914]             base::close(...future.stdout)
[17:45:18.914]         }, add = TRUE)
[17:45:18.914]     }
[17:45:18.914]     ...future.frame <- base::sys.nframe()
[17:45:18.914]     ...future.conditions <- base::list()
[17:45:18.914]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.914]     if (FALSE) {
[17:45:18.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.914]     }
[17:45:18.914]     ...future.result <- base::tryCatch({
[17:45:18.914]         base::withCallingHandlers({
[17:45:18.914]             ...future.value <- base::withVisible(base::local({
[17:45:18.914]                 withCallingHandlers({
[17:45:18.914]                   {
[17:45:18.914]                     do.call(function(...) {
[17:45:18.914]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.914]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.914]                         ...future.globals.maxSize)) {
[17:45:18.914]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.914]                         on.exit(options(oopts), add = TRUE)
[17:45:18.914]                       }
[17:45:18.914]                       {
[17:45:18.914]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.914]                           FUN = function(jj) {
[17:45:18.914]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.914]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.914]                           })
[17:45:18.914]                       }
[17:45:18.914]                     }, args = future.call.arguments)
[17:45:18.914]                   }
[17:45:18.914]                 }, immediateCondition = function(cond) {
[17:45:18.914]                   save_rds <- function (object, pathname, ...) 
[17:45:18.914]                   {
[17:45:18.914]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.914]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.914]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.914]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.914]                         fi_tmp[["mtime"]])
[17:45:18.914]                     }
[17:45:18.914]                     tryCatch({
[17:45:18.914]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.914]                     }, error = function(ex) {
[17:45:18.914]                       msg <- conditionMessage(ex)
[17:45:18.914]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.914]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.914]                         fi_tmp[["mtime"]], msg)
[17:45:18.914]                       ex$message <- msg
[17:45:18.914]                       stop(ex)
[17:45:18.914]                     })
[17:45:18.914]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.914]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.914]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.914]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.914]                       fi <- file.info(pathname)
[17:45:18.914]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.914]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.914]                         fi[["size"]], fi[["mtime"]])
[17:45:18.914]                       stop(msg)
[17:45:18.914]                     }
[17:45:18.914]                     invisible(pathname)
[17:45:18.914]                   }
[17:45:18.914]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.914]                     rootPath = tempdir()) 
[17:45:18.914]                   {
[17:45:18.914]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.914]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.914]                       tmpdir = path, fileext = ".rds")
[17:45:18.914]                     save_rds(obj, file)
[17:45:18.914]                   }
[17:45:18.914]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.914]                   {
[17:45:18.914]                     inherits <- base::inherits
[17:45:18.914]                     invokeRestart <- base::invokeRestart
[17:45:18.914]                     is.null <- base::is.null
[17:45:18.914]                     muffled <- FALSE
[17:45:18.914]                     if (inherits(cond, "message")) {
[17:45:18.914]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.914]                       if (muffled) 
[17:45:18.914]                         invokeRestart("muffleMessage")
[17:45:18.914]                     }
[17:45:18.914]                     else if (inherits(cond, "warning")) {
[17:45:18.914]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.914]                       if (muffled) 
[17:45:18.914]                         invokeRestart("muffleWarning")
[17:45:18.914]                     }
[17:45:18.914]                     else if (inherits(cond, "condition")) {
[17:45:18.914]                       if (!is.null(pattern)) {
[17:45:18.914]                         computeRestarts <- base::computeRestarts
[17:45:18.914]                         grepl <- base::grepl
[17:45:18.914]                         restarts <- computeRestarts(cond)
[17:45:18.914]                         for (restart in restarts) {
[17:45:18.914]                           name <- restart$name
[17:45:18.914]                           if (is.null(name)) 
[17:45:18.914]                             next
[17:45:18.914]                           if (!grepl(pattern, name)) 
[17:45:18.914]                             next
[17:45:18.914]                           invokeRestart(restart)
[17:45:18.914]                           muffled <- TRUE
[17:45:18.914]                           break
[17:45:18.914]                         }
[17:45:18.914]                       }
[17:45:18.914]                     }
[17:45:18.914]                     invisible(muffled)
[17:45:18.914]                   }
[17:45:18.914]                   muffleCondition(cond)
[17:45:18.914]                 })
[17:45:18.914]             }))
[17:45:18.914]             future::FutureResult(value = ...future.value$value, 
[17:45:18.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.914]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.914]                     ...future.globalenv.names))
[17:45:18.914]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.914]         }, condition = base::local({
[17:45:18.914]             c <- base::c
[17:45:18.914]             inherits <- base::inherits
[17:45:18.914]             invokeRestart <- base::invokeRestart
[17:45:18.914]             length <- base::length
[17:45:18.914]             list <- base::list
[17:45:18.914]             seq.int <- base::seq.int
[17:45:18.914]             signalCondition <- base::signalCondition
[17:45:18.914]             sys.calls <- base::sys.calls
[17:45:18.914]             `[[` <- base::`[[`
[17:45:18.914]             `+` <- base::`+`
[17:45:18.914]             `<<-` <- base::`<<-`
[17:45:18.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.914]                   3L)]
[17:45:18.914]             }
[17:45:18.914]             function(cond) {
[17:45:18.914]                 is_error <- inherits(cond, "error")
[17:45:18.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.914]                   NULL)
[17:45:18.914]                 if (is_error) {
[17:45:18.914]                   sessionInformation <- function() {
[17:45:18.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.914]                       search = base::search(), system = base::Sys.info())
[17:45:18.914]                   }
[17:45:18.914]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.914]                     cond$call), session = sessionInformation(), 
[17:45:18.914]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.914]                   signalCondition(cond)
[17:45:18.914]                 }
[17:45:18.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.914]                 "immediateCondition"))) {
[17:45:18.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.914]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.914]                   if (TRUE && !signal) {
[17:45:18.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.914]                     {
[17:45:18.914]                       inherits <- base::inherits
[17:45:18.914]                       invokeRestart <- base::invokeRestart
[17:45:18.914]                       is.null <- base::is.null
[17:45:18.914]                       muffled <- FALSE
[17:45:18.914]                       if (inherits(cond, "message")) {
[17:45:18.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.914]                         if (muffled) 
[17:45:18.914]                           invokeRestart("muffleMessage")
[17:45:18.914]                       }
[17:45:18.914]                       else if (inherits(cond, "warning")) {
[17:45:18.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.914]                         if (muffled) 
[17:45:18.914]                           invokeRestart("muffleWarning")
[17:45:18.914]                       }
[17:45:18.914]                       else if (inherits(cond, "condition")) {
[17:45:18.914]                         if (!is.null(pattern)) {
[17:45:18.914]                           computeRestarts <- base::computeRestarts
[17:45:18.914]                           grepl <- base::grepl
[17:45:18.914]                           restarts <- computeRestarts(cond)
[17:45:18.914]                           for (restart in restarts) {
[17:45:18.914]                             name <- restart$name
[17:45:18.914]                             if (is.null(name)) 
[17:45:18.914]                               next
[17:45:18.914]                             if (!grepl(pattern, name)) 
[17:45:18.914]                               next
[17:45:18.914]                             invokeRestart(restart)
[17:45:18.914]                             muffled <- TRUE
[17:45:18.914]                             break
[17:45:18.914]                           }
[17:45:18.914]                         }
[17:45:18.914]                       }
[17:45:18.914]                       invisible(muffled)
[17:45:18.914]                     }
[17:45:18.914]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.914]                   }
[17:45:18.914]                 }
[17:45:18.914]                 else {
[17:45:18.914]                   if (TRUE) {
[17:45:18.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.914]                     {
[17:45:18.914]                       inherits <- base::inherits
[17:45:18.914]                       invokeRestart <- base::invokeRestart
[17:45:18.914]                       is.null <- base::is.null
[17:45:18.914]                       muffled <- FALSE
[17:45:18.914]                       if (inherits(cond, "message")) {
[17:45:18.914]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.914]                         if (muffled) 
[17:45:18.914]                           invokeRestart("muffleMessage")
[17:45:18.914]                       }
[17:45:18.914]                       else if (inherits(cond, "warning")) {
[17:45:18.914]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.914]                         if (muffled) 
[17:45:18.914]                           invokeRestart("muffleWarning")
[17:45:18.914]                       }
[17:45:18.914]                       else if (inherits(cond, "condition")) {
[17:45:18.914]                         if (!is.null(pattern)) {
[17:45:18.914]                           computeRestarts <- base::computeRestarts
[17:45:18.914]                           grepl <- base::grepl
[17:45:18.914]                           restarts <- computeRestarts(cond)
[17:45:18.914]                           for (restart in restarts) {
[17:45:18.914]                             name <- restart$name
[17:45:18.914]                             if (is.null(name)) 
[17:45:18.914]                               next
[17:45:18.914]                             if (!grepl(pattern, name)) 
[17:45:18.914]                               next
[17:45:18.914]                             invokeRestart(restart)
[17:45:18.914]                             muffled <- TRUE
[17:45:18.914]                             break
[17:45:18.914]                           }
[17:45:18.914]                         }
[17:45:18.914]                       }
[17:45:18.914]                       invisible(muffled)
[17:45:18.914]                     }
[17:45:18.914]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.914]                   }
[17:45:18.914]                 }
[17:45:18.914]             }
[17:45:18.914]         }))
[17:45:18.914]     }, error = function(ex) {
[17:45:18.914]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.914]                 ...future.rng), started = ...future.startTime, 
[17:45:18.914]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.914]             version = "1.8"), class = "FutureResult")
[17:45:18.914]     }, finally = {
[17:45:18.914]         if (!identical(...future.workdir, getwd())) 
[17:45:18.914]             setwd(...future.workdir)
[17:45:18.914]         {
[17:45:18.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.914]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.914]             }
[17:45:18.914]             base::options(...future.oldOptions)
[17:45:18.914]             if (.Platform$OS.type == "windows") {
[17:45:18.914]                 old_names <- names(...future.oldEnvVars)
[17:45:18.914]                 envs <- base::Sys.getenv()
[17:45:18.914]                 names <- names(envs)
[17:45:18.914]                 common <- intersect(names, old_names)
[17:45:18.914]                 added <- setdiff(names, old_names)
[17:45:18.914]                 removed <- setdiff(old_names, names)
[17:45:18.914]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.914]                   envs[common]]
[17:45:18.914]                 NAMES <- toupper(changed)
[17:45:18.914]                 args <- list()
[17:45:18.914]                 for (kk in seq_along(NAMES)) {
[17:45:18.914]                   name <- changed[[kk]]
[17:45:18.914]                   NAME <- NAMES[[kk]]
[17:45:18.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.914]                     next
[17:45:18.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.914]                 }
[17:45:18.914]                 NAMES <- toupper(added)
[17:45:18.914]                 for (kk in seq_along(NAMES)) {
[17:45:18.914]                   name <- added[[kk]]
[17:45:18.914]                   NAME <- NAMES[[kk]]
[17:45:18.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.914]                     next
[17:45:18.914]                   args[[name]] <- ""
[17:45:18.914]                 }
[17:45:18.914]                 NAMES <- toupper(removed)
[17:45:18.914]                 for (kk in seq_along(NAMES)) {
[17:45:18.914]                   name <- removed[[kk]]
[17:45:18.914]                   NAME <- NAMES[[kk]]
[17:45:18.914]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.914]                     next
[17:45:18.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.914]                 }
[17:45:18.914]                 if (length(args) > 0) 
[17:45:18.914]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.914]             }
[17:45:18.914]             else {
[17:45:18.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.914]             }
[17:45:18.914]             {
[17:45:18.914]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.914]                   0L) {
[17:45:18.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.914]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.914]                   base::options(opts)
[17:45:18.914]                 }
[17:45:18.914]                 {
[17:45:18.914]                   {
[17:45:18.914]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.914]                     NULL
[17:45:18.914]                   }
[17:45:18.914]                   options(future.plan = NULL)
[17:45:18.914]                   if (is.na(NA_character_)) 
[17:45:18.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.914]                     .init = FALSE)
[17:45:18.914]                 }
[17:45:18.914]             }
[17:45:18.914]         }
[17:45:18.914]     })
[17:45:18.914]     if (TRUE) {
[17:45:18.914]         base::sink(type = "output", split = FALSE)
[17:45:18.914]         if (TRUE) {
[17:45:18.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.914]         }
[17:45:18.914]         else {
[17:45:18.914]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.914]         }
[17:45:18.914]         base::close(...future.stdout)
[17:45:18.914]         ...future.stdout <- NULL
[17:45:18.914]     }
[17:45:18.914]     ...future.result$conditions <- ...future.conditions
[17:45:18.914]     ...future.result$finished <- base::Sys.time()
[17:45:18.914]     ...future.result
[17:45:18.914] }
[17:45:18.919] assign_globals() ...
[17:45:18.919] List of 11
[17:45:18.919]  $ ...future.FUN            :function (x, ...)  
[17:45:18.919]  $ x_FUN                    :function (x)  
[17:45:18.919]  $ times                    : int 4
[17:45:18.919]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.919]  $ stop_if_not              :function (...)  
[17:45:18.919]  $ dim                      : int [1:2] 2 2
[17:45:18.919]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:18.919]  $ future.call.arguments    : list()
[17:45:18.919]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.919]  $ ...future.elements_ii    :List of 5
[17:45:18.919]   ..$ : int 1
[17:45:18.919]   ..$ : int 2
[17:45:18.919]   ..$ : int 3
[17:45:18.919]   ..$ : int 4
[17:45:18.919]   ..$ : int 5
[17:45:18.919]  $ ...future.seeds_ii       : NULL
[17:45:18.919]  $ ...future.globals.maxSize: NULL
[17:45:18.919]  - attr(*, "where")=List of 11
[17:45:18.919]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.919]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.919]  - attr(*, "resolved")= logi FALSE
[17:45:18.919]  - attr(*, "total_size")= num 97232
[17:45:18.919]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.919]  - attr(*, "already-done")= logi TRUE
[17:45:18.935] - copied ‘...future.FUN’ to environment
[17:45:18.935] - reassign environment for ‘x_FUN’
[17:45:18.936] - copied ‘x_FUN’ to environment
[17:45:18.936] - copied ‘times’ to environment
[17:45:18.936] - copied ‘stopf’ to environment
[17:45:18.936] - copied ‘stop_if_not’ to environment
[17:45:18.936] - copied ‘dim’ to environment
[17:45:18.936] - copied ‘valid_types’ to environment
[17:45:18.936] - copied ‘future.call.arguments’ to environment
[17:45:18.936] - copied ‘...future.elements_ii’ to environment
[17:45:18.936] - copied ‘...future.seeds_ii’ to environment
[17:45:18.936] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.937] assign_globals() ... done
[17:45:18.937] requestCore(): workers = 2
[17:45:18.939] MulticoreFuture started
[17:45:18.940] - Launch lazy future ... done
[17:45:18.940] run() for ‘MulticoreFuture’ ... done
[17:45:18.940] Created future:
[17:45:18.941] plan(): Setting new future strategy stack:
[17:45:18.941] List of future strategies:
[17:45:18.941] 1. sequential:
[17:45:18.941]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:18.941]    - tweaked: FALSE
[17:45:18.941]    - call: NULL
[17:45:18.943] plan(): nbrOfWorkers() = 1
[17:45:18.945] plan(): Setting new future strategy stack:
[17:45:18.946] List of future strategies:
[17:45:18.946] 1. multicore:
[17:45:18.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:18.946]    - tweaked: FALSE
[17:45:18.946]    - call: plan(strategy)
[17:45:18.941] MulticoreFuture:
[17:45:18.941] Label: ‘future_vapply-1’
[17:45:18.941] Expression:
[17:45:18.941] {
[17:45:18.941]     do.call(function(...) {
[17:45:18.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.941]             on.exit(options(oopts), add = TRUE)
[17:45:18.941]         }
[17:45:18.941]         {
[17:45:18.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.941]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.941]             })
[17:45:18.941]         }
[17:45:18.941]     }, args = future.call.arguments)
[17:45:18.941] }
[17:45:18.941] Lazy evaluation: FALSE
[17:45:18.941] Asynchronous evaluation: TRUE
[17:45:18.941] Local evaluation: TRUE
[17:45:18.941] Environment: R_GlobalEnv
[17:45:18.941] Capture standard output: TRUE
[17:45:18.941] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:18.941] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:18.941] Packages: 1 packages (‘future.apply’)
[17:45:18.941] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:18.941] Resolved: FALSE
[17:45:18.941] Value: <not collected>
[17:45:18.941] Conditions captured: <none>
[17:45:18.941] Early signaling: FALSE
[17:45:18.941] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:18.941] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.955] Chunk #1 of 2 ... DONE
[17:45:18.955] Chunk #2 of 2 ...
[17:45:18.955]  - Finding globals in 'X' for chunk #2 ...
[17:45:18.955] getGlobalsAndPackages() ...
[17:45:18.956] Searching for globals...
[17:45:18.956] plan(): nbrOfWorkers() = 2
[17:45:18.956] 
[17:45:18.957] Searching for globals ... DONE
[17:45:18.957] - globals: [0] <none>
[17:45:18.957] getGlobalsAndPackages() ... DONE
[17:45:18.957]    + additional globals found: [n=0] 
[17:45:18.957]    + additional namespaces needed: [n=0] 
[17:45:18.957]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:18.958]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:18.960]  - seeds: <none>
[17:45:18.961]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.962] getGlobalsAndPackages() ...
[17:45:18.962] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.963] Resolving globals: FALSE
[17:45:18.963] Tweak future expression to call with '...' arguments ...
[17:45:18.964] {
[17:45:18.964]     do.call(function(...) {
[17:45:18.964]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.964]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:18.964]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.964]             on.exit(options(oopts), add = TRUE)
[17:45:18.964]         }
[17:45:18.964]         {
[17:45:18.964]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:18.964]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.964]                 ...future.FUN(...future.X_jj, ...)
[17:45:18.964]             })
[17:45:18.964]         }
[17:45:18.964]     }, args = future.call.arguments)
[17:45:18.964] }
[17:45:18.965] Tweak future expression to call with '...' arguments ... DONE
[17:45:18.967] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:18.968] - packages: [1] ‘future.apply’
[17:45:18.968] getGlobalsAndPackages() ... DONE
[17:45:18.969] run() for ‘Future’ ...
[17:45:18.969] - state: ‘created’
[17:45:18.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:18.977] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:18.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:18.978]   - Field: ‘label’
[17:45:18.978]   - Field: ‘local’
[17:45:18.978]   - Field: ‘owner’
[17:45:18.978]   - Field: ‘envir’
[17:45:18.978]   - Field: ‘workers’
[17:45:18.979]   - Field: ‘packages’
[17:45:18.979]   - Field: ‘gc’
[17:45:18.979]   - Field: ‘job’
[17:45:18.979]   - Field: ‘conditions’
[17:45:18.979]   - Field: ‘expr’
[17:45:18.980]   - Field: ‘uuid’
[17:45:18.980]   - Field: ‘seed’
[17:45:18.980]   - Field: ‘version’
[17:45:18.980]   - Field: ‘result’
[17:45:18.981]   - Field: ‘asynchronous’
[17:45:18.981]   - Field: ‘calls’
[17:45:18.981]   - Field: ‘globals’
[17:45:18.981]   - Field: ‘stdout’
[17:45:18.981]   - Field: ‘earlySignal’
[17:45:18.982]   - Field: ‘lazy’
[17:45:18.982]   - Field: ‘state’
[17:45:18.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:18.982] - Launch lazy future ...
[17:45:18.983] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:18.983] Packages needed by future strategies (n = 0): <none>
[17:45:18.984] {
[17:45:18.984]     {
[17:45:18.984]         {
[17:45:18.984]             ...future.startTime <- base::Sys.time()
[17:45:18.984]             {
[17:45:18.984]                 {
[17:45:18.984]                   {
[17:45:18.984]                     {
[17:45:18.984]                       {
[17:45:18.984]                         base::local({
[17:45:18.984]                           has_future <- base::requireNamespace("future", 
[17:45:18.984]                             quietly = TRUE)
[17:45:18.984]                           if (has_future) {
[17:45:18.984]                             ns <- base::getNamespace("future")
[17:45:18.984]                             version <- ns[[".package"]][["version"]]
[17:45:18.984]                             if (is.null(version)) 
[17:45:18.984]                               version <- utils::packageVersion("future")
[17:45:18.984]                           }
[17:45:18.984]                           else {
[17:45:18.984]                             version <- NULL
[17:45:18.984]                           }
[17:45:18.984]                           if (!has_future || version < "1.8.0") {
[17:45:18.984]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:18.984]                               "", base::R.version$version.string), 
[17:45:18.984]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:18.984]                                 base::R.version$platform, 8 * 
[17:45:18.984]                                   base::.Machine$sizeof.pointer), 
[17:45:18.984]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:18.984]                                 "release", "version")], collapse = " "), 
[17:45:18.984]                               hostname = base::Sys.info()[["nodename"]])
[17:45:18.984]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:18.984]                               info)
[17:45:18.984]                             info <- base::paste(info, collapse = "; ")
[17:45:18.984]                             if (!has_future) {
[17:45:18.984]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:18.984]                                 info)
[17:45:18.984]                             }
[17:45:18.984]                             else {
[17:45:18.984]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:18.984]                                 info, version)
[17:45:18.984]                             }
[17:45:18.984]                             base::stop(msg)
[17:45:18.984]                           }
[17:45:18.984]                         })
[17:45:18.984]                       }
[17:45:18.984]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:18.984]                       base::options(mc.cores = 1L)
[17:45:18.984]                     }
[17:45:18.984]                     base::local({
[17:45:18.984]                       for (pkg in "future.apply") {
[17:45:18.984]                         base::loadNamespace(pkg)
[17:45:18.984]                         base::library(pkg, character.only = TRUE)
[17:45:18.984]                       }
[17:45:18.984]                     })
[17:45:18.984]                   }
[17:45:18.984]                   ...future.strategy.old <- future::plan("list")
[17:45:18.984]                   options(future.plan = NULL)
[17:45:18.984]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.984]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:18.984]                 }
[17:45:18.984]                 ...future.workdir <- getwd()
[17:45:18.984]             }
[17:45:18.984]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:18.984]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:18.984]         }
[17:45:18.984]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:18.984]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:18.984]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:18.984]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:18.984]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:18.984]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:18.984]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:18.984]             base::names(...future.oldOptions))
[17:45:18.984]     }
[17:45:18.984]     if (FALSE) {
[17:45:18.984]     }
[17:45:18.984]     else {
[17:45:18.984]         if (TRUE) {
[17:45:18.984]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:18.984]                 open = "w")
[17:45:18.984]         }
[17:45:18.984]         else {
[17:45:18.984]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:18.984]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:18.984]         }
[17:45:18.984]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:18.984]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:18.984]             base::sink(type = "output", split = FALSE)
[17:45:18.984]             base::close(...future.stdout)
[17:45:18.984]         }, add = TRUE)
[17:45:18.984]     }
[17:45:18.984]     ...future.frame <- base::sys.nframe()
[17:45:18.984]     ...future.conditions <- base::list()
[17:45:18.984]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:18.984]     if (FALSE) {
[17:45:18.984]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:18.984]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:18.984]     }
[17:45:18.984]     ...future.result <- base::tryCatch({
[17:45:18.984]         base::withCallingHandlers({
[17:45:18.984]             ...future.value <- base::withVisible(base::local({
[17:45:18.984]                 withCallingHandlers({
[17:45:18.984]                   {
[17:45:18.984]                     do.call(function(...) {
[17:45:18.984]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:18.984]                       if (!identical(...future.globals.maxSize.org, 
[17:45:18.984]                         ...future.globals.maxSize)) {
[17:45:18.984]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:18.984]                         on.exit(options(oopts), add = TRUE)
[17:45:18.984]                       }
[17:45:18.984]                       {
[17:45:18.984]                         lapply(seq_along(...future.elements_ii), 
[17:45:18.984]                           FUN = function(jj) {
[17:45:18.984]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:18.984]                             ...future.FUN(...future.X_jj, ...)
[17:45:18.984]                           })
[17:45:18.984]                       }
[17:45:18.984]                     }, args = future.call.arguments)
[17:45:18.984]                   }
[17:45:18.984]                 }, immediateCondition = function(cond) {
[17:45:18.984]                   save_rds <- function (object, pathname, ...) 
[17:45:18.984]                   {
[17:45:18.984]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:18.984]                     if (file_test("-f", pathname_tmp)) {
[17:45:18.984]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.984]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:18.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.984]                         fi_tmp[["mtime"]])
[17:45:18.984]                     }
[17:45:18.984]                     tryCatch({
[17:45:18.984]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:18.984]                     }, error = function(ex) {
[17:45:18.984]                       msg <- conditionMessage(ex)
[17:45:18.984]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.984]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:18.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.984]                         fi_tmp[["mtime"]], msg)
[17:45:18.984]                       ex$message <- msg
[17:45:18.984]                       stop(ex)
[17:45:18.984]                     })
[17:45:18.984]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:18.984]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:18.984]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:18.984]                       fi_tmp <- file.info(pathname_tmp)
[17:45:18.984]                       fi <- file.info(pathname)
[17:45:18.984]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:18.984]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:18.984]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:18.984]                         fi[["size"]], fi[["mtime"]])
[17:45:18.984]                       stop(msg)
[17:45:18.984]                     }
[17:45:18.984]                     invisible(pathname)
[17:45:18.984]                   }
[17:45:18.984]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:18.984]                     rootPath = tempdir()) 
[17:45:18.984]                   {
[17:45:18.984]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:18.984]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:18.984]                       tmpdir = path, fileext = ".rds")
[17:45:18.984]                     save_rds(obj, file)
[17:45:18.984]                   }
[17:45:18.984]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:18.984]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.984]                   {
[17:45:18.984]                     inherits <- base::inherits
[17:45:18.984]                     invokeRestart <- base::invokeRestart
[17:45:18.984]                     is.null <- base::is.null
[17:45:18.984]                     muffled <- FALSE
[17:45:18.984]                     if (inherits(cond, "message")) {
[17:45:18.984]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:18.984]                       if (muffled) 
[17:45:18.984]                         invokeRestart("muffleMessage")
[17:45:18.984]                     }
[17:45:18.984]                     else if (inherits(cond, "warning")) {
[17:45:18.984]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:18.984]                       if (muffled) 
[17:45:18.984]                         invokeRestart("muffleWarning")
[17:45:18.984]                     }
[17:45:18.984]                     else if (inherits(cond, "condition")) {
[17:45:18.984]                       if (!is.null(pattern)) {
[17:45:18.984]                         computeRestarts <- base::computeRestarts
[17:45:18.984]                         grepl <- base::grepl
[17:45:18.984]                         restarts <- computeRestarts(cond)
[17:45:18.984]                         for (restart in restarts) {
[17:45:18.984]                           name <- restart$name
[17:45:18.984]                           if (is.null(name)) 
[17:45:18.984]                             next
[17:45:18.984]                           if (!grepl(pattern, name)) 
[17:45:18.984]                             next
[17:45:18.984]                           invokeRestart(restart)
[17:45:18.984]                           muffled <- TRUE
[17:45:18.984]                           break
[17:45:18.984]                         }
[17:45:18.984]                       }
[17:45:18.984]                     }
[17:45:18.984]                     invisible(muffled)
[17:45:18.984]                   }
[17:45:18.984]                   muffleCondition(cond)
[17:45:18.984]                 })
[17:45:18.984]             }))
[17:45:18.984]             future::FutureResult(value = ...future.value$value, 
[17:45:18.984]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.984]                   ...future.rng), globalenv = if (FALSE) 
[17:45:18.984]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:18.984]                     ...future.globalenv.names))
[17:45:18.984]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:18.984]         }, condition = base::local({
[17:45:18.984]             c <- base::c
[17:45:18.984]             inherits <- base::inherits
[17:45:18.984]             invokeRestart <- base::invokeRestart
[17:45:18.984]             length <- base::length
[17:45:18.984]             list <- base::list
[17:45:18.984]             seq.int <- base::seq.int
[17:45:18.984]             signalCondition <- base::signalCondition
[17:45:18.984]             sys.calls <- base::sys.calls
[17:45:18.984]             `[[` <- base::`[[`
[17:45:18.984]             `+` <- base::`+`
[17:45:18.984]             `<<-` <- base::`<<-`
[17:45:18.984]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:18.984]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:18.984]                   3L)]
[17:45:18.984]             }
[17:45:18.984]             function(cond) {
[17:45:18.984]                 is_error <- inherits(cond, "error")
[17:45:18.984]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:18.984]                   NULL)
[17:45:18.984]                 if (is_error) {
[17:45:18.984]                   sessionInformation <- function() {
[17:45:18.984]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:18.984]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:18.984]                       search = base::search(), system = base::Sys.info())
[17:45:18.984]                   }
[17:45:18.984]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.984]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:18.984]                     cond$call), session = sessionInformation(), 
[17:45:18.984]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:18.984]                   signalCondition(cond)
[17:45:18.984]                 }
[17:45:18.984]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:18.984]                 "immediateCondition"))) {
[17:45:18.984]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:18.984]                   ...future.conditions[[length(...future.conditions) + 
[17:45:18.984]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:18.984]                   if (TRUE && !signal) {
[17:45:18.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.984]                     {
[17:45:18.984]                       inherits <- base::inherits
[17:45:18.984]                       invokeRestart <- base::invokeRestart
[17:45:18.984]                       is.null <- base::is.null
[17:45:18.984]                       muffled <- FALSE
[17:45:18.984]                       if (inherits(cond, "message")) {
[17:45:18.984]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.984]                         if (muffled) 
[17:45:18.984]                           invokeRestart("muffleMessage")
[17:45:18.984]                       }
[17:45:18.984]                       else if (inherits(cond, "warning")) {
[17:45:18.984]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.984]                         if (muffled) 
[17:45:18.984]                           invokeRestart("muffleWarning")
[17:45:18.984]                       }
[17:45:18.984]                       else if (inherits(cond, "condition")) {
[17:45:18.984]                         if (!is.null(pattern)) {
[17:45:18.984]                           computeRestarts <- base::computeRestarts
[17:45:18.984]                           grepl <- base::grepl
[17:45:18.984]                           restarts <- computeRestarts(cond)
[17:45:18.984]                           for (restart in restarts) {
[17:45:18.984]                             name <- restart$name
[17:45:18.984]                             if (is.null(name)) 
[17:45:18.984]                               next
[17:45:18.984]                             if (!grepl(pattern, name)) 
[17:45:18.984]                               next
[17:45:18.984]                             invokeRestart(restart)
[17:45:18.984]                             muffled <- TRUE
[17:45:18.984]                             break
[17:45:18.984]                           }
[17:45:18.984]                         }
[17:45:18.984]                       }
[17:45:18.984]                       invisible(muffled)
[17:45:18.984]                     }
[17:45:18.984]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.984]                   }
[17:45:18.984]                 }
[17:45:18.984]                 else {
[17:45:18.984]                   if (TRUE) {
[17:45:18.984]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:18.984]                     {
[17:45:18.984]                       inherits <- base::inherits
[17:45:18.984]                       invokeRestart <- base::invokeRestart
[17:45:18.984]                       is.null <- base::is.null
[17:45:18.984]                       muffled <- FALSE
[17:45:18.984]                       if (inherits(cond, "message")) {
[17:45:18.984]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:18.984]                         if (muffled) 
[17:45:18.984]                           invokeRestart("muffleMessage")
[17:45:18.984]                       }
[17:45:18.984]                       else if (inherits(cond, "warning")) {
[17:45:18.984]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:18.984]                         if (muffled) 
[17:45:18.984]                           invokeRestart("muffleWarning")
[17:45:18.984]                       }
[17:45:18.984]                       else if (inherits(cond, "condition")) {
[17:45:18.984]                         if (!is.null(pattern)) {
[17:45:18.984]                           computeRestarts <- base::computeRestarts
[17:45:18.984]                           grepl <- base::grepl
[17:45:18.984]                           restarts <- computeRestarts(cond)
[17:45:18.984]                           for (restart in restarts) {
[17:45:18.984]                             name <- restart$name
[17:45:18.984]                             if (is.null(name)) 
[17:45:18.984]                               next
[17:45:18.984]                             if (!grepl(pattern, name)) 
[17:45:18.984]                               next
[17:45:18.984]                             invokeRestart(restart)
[17:45:18.984]                             muffled <- TRUE
[17:45:18.984]                             break
[17:45:18.984]                           }
[17:45:18.984]                         }
[17:45:18.984]                       }
[17:45:18.984]                       invisible(muffled)
[17:45:18.984]                     }
[17:45:18.984]                     muffleCondition(cond, pattern = "^muffle")
[17:45:18.984]                   }
[17:45:18.984]                 }
[17:45:18.984]             }
[17:45:18.984]         }))
[17:45:18.984]     }, error = function(ex) {
[17:45:18.984]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:18.984]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:18.984]                 ...future.rng), started = ...future.startTime, 
[17:45:18.984]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:18.984]             version = "1.8"), class = "FutureResult")
[17:45:18.984]     }, finally = {
[17:45:18.984]         if (!identical(...future.workdir, getwd())) 
[17:45:18.984]             setwd(...future.workdir)
[17:45:18.984]         {
[17:45:18.984]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:18.984]                 ...future.oldOptions$nwarnings <- NULL
[17:45:18.984]             }
[17:45:18.984]             base::options(...future.oldOptions)
[17:45:18.984]             if (.Platform$OS.type == "windows") {
[17:45:18.984]                 old_names <- names(...future.oldEnvVars)
[17:45:18.984]                 envs <- base::Sys.getenv()
[17:45:18.984]                 names <- names(envs)
[17:45:18.984]                 common <- intersect(names, old_names)
[17:45:18.984]                 added <- setdiff(names, old_names)
[17:45:18.984]                 removed <- setdiff(old_names, names)
[17:45:18.984]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:18.984]                   envs[common]]
[17:45:18.984]                 NAMES <- toupper(changed)
[17:45:18.984]                 args <- list()
[17:45:18.984]                 for (kk in seq_along(NAMES)) {
[17:45:18.984]                   name <- changed[[kk]]
[17:45:18.984]                   NAME <- NAMES[[kk]]
[17:45:18.984]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.984]                     next
[17:45:18.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.984]                 }
[17:45:18.984]                 NAMES <- toupper(added)
[17:45:18.984]                 for (kk in seq_along(NAMES)) {
[17:45:18.984]                   name <- added[[kk]]
[17:45:18.984]                   NAME <- NAMES[[kk]]
[17:45:18.984]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.984]                     next
[17:45:18.984]                   args[[name]] <- ""
[17:45:18.984]                 }
[17:45:18.984]                 NAMES <- toupper(removed)
[17:45:18.984]                 for (kk in seq_along(NAMES)) {
[17:45:18.984]                   name <- removed[[kk]]
[17:45:18.984]                   NAME <- NAMES[[kk]]
[17:45:18.984]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:18.984]                     next
[17:45:18.984]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:18.984]                 }
[17:45:18.984]                 if (length(args) > 0) 
[17:45:18.984]                   base::do.call(base::Sys.setenv, args = args)
[17:45:18.984]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:18.984]             }
[17:45:18.984]             else {
[17:45:18.984]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:18.984]             }
[17:45:18.984]             {
[17:45:18.984]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:18.984]                   0L) {
[17:45:18.984]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:18.984]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:18.984]                   base::options(opts)
[17:45:18.984]                 }
[17:45:18.984]                 {
[17:45:18.984]                   {
[17:45:18.984]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:18.984]                     NULL
[17:45:18.984]                   }
[17:45:18.984]                   options(future.plan = NULL)
[17:45:18.984]                   if (is.na(NA_character_)) 
[17:45:18.984]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:18.984]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:18.984]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:18.984]                     .init = FALSE)
[17:45:18.984]                 }
[17:45:18.984]             }
[17:45:18.984]         }
[17:45:18.984]     })
[17:45:18.984]     if (TRUE) {
[17:45:18.984]         base::sink(type = "output", split = FALSE)
[17:45:18.984]         if (TRUE) {
[17:45:18.984]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:18.984]         }
[17:45:18.984]         else {
[17:45:18.984]             ...future.result["stdout"] <- base::list(NULL)
[17:45:18.984]         }
[17:45:18.984]         base::close(...future.stdout)
[17:45:18.984]         ...future.stdout <- NULL
[17:45:18.984]     }
[17:45:18.984]     ...future.result$conditions <- ...future.conditions
[17:45:18.984]     ...future.result$finished <- base::Sys.time()
[17:45:18.984]     ...future.result
[17:45:18.984] }
[17:45:18.987] assign_globals() ...
[17:45:18.987] List of 11
[17:45:18.987]  $ ...future.FUN            :function (x, ...)  
[17:45:18.987]  $ x_FUN                    :function (x)  
[17:45:18.987]  $ times                    : int 4
[17:45:18.987]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:18.987]  $ stop_if_not              :function (...)  
[17:45:18.987]  $ dim                      : int [1:2] 2 2
[17:45:18.987]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:18.987]  $ future.call.arguments    : list()
[17:45:18.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:18.987]  $ ...future.elements_ii    :List of 5
[17:45:18.987]   ..$ : int 6
[17:45:18.987]   ..$ : int 7
[17:45:18.987]   ..$ : int 8
[17:45:18.987]   ..$ : int 9
[17:45:18.987]   ..$ : int 10
[17:45:18.987]  $ ...future.seeds_ii       : NULL
[17:45:18.987]  $ ...future.globals.maxSize: NULL
[17:45:18.987]  - attr(*, "where")=List of 11
[17:45:18.987]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:18.987]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:18.987]  - attr(*, "resolved")= logi FALSE
[17:45:18.987]  - attr(*, "total_size")= num 97232
[17:45:18.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:18.987]  - attr(*, "already-done")= logi TRUE
[17:45:18.997] - copied ‘...future.FUN’ to environment
[17:45:18.998] - reassign environment for ‘x_FUN’
[17:45:18.998] - copied ‘x_FUN’ to environment
[17:45:18.998] - copied ‘times’ to environment
[17:45:18.998] - copied ‘stopf’ to environment
[17:45:18.998] - copied ‘stop_if_not’ to environment
[17:45:18.998] - copied ‘dim’ to environment
[17:45:18.998] - copied ‘valid_types’ to environment
[17:45:18.998] - copied ‘future.call.arguments’ to environment
[17:45:18.998] - copied ‘...future.elements_ii’ to environment
[17:45:18.999] - copied ‘...future.seeds_ii’ to environment
[17:45:18.999] - copied ‘...future.globals.maxSize’ to environment
[17:45:18.999] assign_globals() ... done
[17:45:18.999] requestCore(): workers = 2
[17:45:19.001] MulticoreFuture started
[17:45:19.002] - Launch lazy future ... done
[17:45:19.002] run() for ‘MulticoreFuture’ ... done
[17:45:19.002] Created future:
[17:45:19.003] plan(): Setting new future strategy stack:
[17:45:19.003] List of future strategies:
[17:45:19.003] 1. sequential:
[17:45:19.003]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.003]    - tweaked: FALSE
[17:45:19.003]    - call: NULL
[17:45:19.004] plan(): nbrOfWorkers() = 1
[17:45:19.006] plan(): Setting new future strategy stack:
[17:45:19.011] List of future strategies:
[17:45:19.011] 1. multicore:
[17:45:19.011]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.011]    - tweaked: FALSE
[17:45:19.011]    - call: plan(strategy)
[17:45:19.002] MulticoreFuture:
[17:45:19.002] Label: ‘future_vapply-2’
[17:45:19.002] Expression:
[17:45:19.002] {
[17:45:19.002]     do.call(function(...) {
[17:45:19.002]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.002]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.002]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.002]             on.exit(options(oopts), add = TRUE)
[17:45:19.002]         }
[17:45:19.002]         {
[17:45:19.002]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.002]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.002]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.002]             })
[17:45:19.002]         }
[17:45:19.002]     }, args = future.call.arguments)
[17:45:19.002] }
[17:45:19.002] Lazy evaluation: FALSE
[17:45:19.002] Asynchronous evaluation: TRUE
[17:45:19.002] Local evaluation: TRUE
[17:45:19.002] Environment: R_GlobalEnv
[17:45:19.002] Capture standard output: TRUE
[17:45:19.002] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.002] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.002] Packages: 1 packages (‘future.apply’)
[17:45:19.002] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.002] Resolved: FALSE
[17:45:19.002] Value: <not collected>
[17:45:19.002] Conditions captured: <none>
[17:45:19.002] Early signaling: FALSE
[17:45:19.002] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.002] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.015] Chunk #2 of 2 ... DONE
[17:45:19.019] plan(): nbrOfWorkers() = 2
[17:45:19.019] Launching 2 futures (chunks) ... DONE
[17:45:19.020] Resolving 2 futures (chunks) ...
[17:45:19.020] resolve() on list ...
[17:45:19.020]  recursive: 0
[17:45:19.021]  length: 2
[17:45:19.021] 
[17:45:19.021] Future #1
[17:45:19.021] result() for MulticoreFuture ...
[17:45:19.023] result() for MulticoreFuture ...
[17:45:19.023] result() for MulticoreFuture ... done
[17:45:19.023] result() for MulticoreFuture ... done
[17:45:19.023] result() for MulticoreFuture ...
[17:45:19.023] result() for MulticoreFuture ... done
[17:45:19.024] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.024] - nx: 2
[17:45:19.024] - relay: TRUE
[17:45:19.025] - stdout: TRUE
[17:45:19.025] - signal: TRUE
[17:45:19.025] - resignal: FALSE
[17:45:19.025] - force: TRUE
[17:45:19.025] - relayed: [n=2] FALSE, FALSE
[17:45:19.026] - queued futures: [n=2] FALSE, FALSE
[17:45:19.026]  - until=1
[17:45:19.026]  - relaying element #1
[17:45:19.027] result() for MulticoreFuture ...
[17:45:19.027] result() for MulticoreFuture ... done
[17:45:19.027] result() for MulticoreFuture ...
[17:45:19.027] result() for MulticoreFuture ... done
[17:45:19.028] result() for MulticoreFuture ...
[17:45:19.028] result() for MulticoreFuture ... done
[17:45:19.028] result() for MulticoreFuture ...
[17:45:19.028] result() for MulticoreFuture ... done
[17:45:19.028] - relayed: [n=2] TRUE, FALSE
[17:45:19.028] - queued futures: [n=2] TRUE, FALSE
[17:45:19.028] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.029]  length: 1 (resolved future 1)
[17:45:19.029] Future #2
[17:45:19.029] result() for MulticoreFuture ...
[17:45:19.030] result() for MulticoreFuture ...
[17:45:19.030] result() for MulticoreFuture ... done
[17:45:19.031] result() for MulticoreFuture ... done
[17:45:19.031] result() for MulticoreFuture ...
[17:45:19.031] result() for MulticoreFuture ... done
[17:45:19.031] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.031] - nx: 2
[17:45:19.031] - relay: TRUE
[17:45:19.032] - stdout: TRUE
[17:45:19.032] - signal: TRUE
[17:45:19.032] - resignal: FALSE
[17:45:19.032] - force: TRUE
[17:45:19.032] - relayed: [n=2] TRUE, FALSE
[17:45:19.032] - queued futures: [n=2] TRUE, FALSE
[17:45:19.032]  - until=2
[17:45:19.033]  - relaying element #2
[17:45:19.033] result() for MulticoreFuture ...
[17:45:19.033] result() for MulticoreFuture ... done
[17:45:19.033] result() for MulticoreFuture ...
[17:45:19.033] result() for MulticoreFuture ... done
[17:45:19.033] result() for MulticoreFuture ...
[17:45:19.034] result() for MulticoreFuture ... done
[17:45:19.034] result() for MulticoreFuture ...
[17:45:19.034] result() for MulticoreFuture ... done
[17:45:19.034] - relayed: [n=2] TRUE, TRUE
[17:45:19.034] - queued futures: [n=2] TRUE, TRUE
[17:45:19.034] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.034]  length: 0 (resolved future 2)
[17:45:19.034] Relaying remaining futures
[17:45:19.034] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.035] - nx: 2
[17:45:19.035] - relay: TRUE
[17:45:19.035] - stdout: TRUE
[17:45:19.035] - signal: TRUE
[17:45:19.035] - resignal: FALSE
[17:45:19.035] - force: TRUE
[17:45:19.035] - relayed: [n=2] TRUE, TRUE
[17:45:19.035] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.035] - relayed: [n=2] TRUE, TRUE
[17:45:19.035] - queued futures: [n=2] TRUE, TRUE
[17:45:19.036] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.036] resolve() on list ... DONE
[17:45:19.036] result() for MulticoreFuture ...
[17:45:19.036] result() for MulticoreFuture ... done
[17:45:19.036] result() for MulticoreFuture ...
[17:45:19.036] result() for MulticoreFuture ... done
[17:45:19.036] result() for MulticoreFuture ...
[17:45:19.036] result() for MulticoreFuture ... done
[17:45:19.036] result() for MulticoreFuture ...
[17:45:19.037] result() for MulticoreFuture ... done
[17:45:19.037]  - Number of value chunks collected: 2
[17:45:19.037] Resolving 2 futures (chunks) ... DONE
[17:45:19.037] Reducing values from 2 chunks ...
[17:45:19.037]  - Number of values collected after concatenation: 10
[17:45:19.037]  - Number of values expected: 10
[17:45:19.037] Reducing values from 2 chunks ... DONE
[17:45:19.037] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:45:19.038] future_lapply() ...
[17:45:19.044] Number of chunks: 2
[17:45:19.045] getGlobalsAndPackagesXApply() ...
[17:45:19.045]  - future.globals: TRUE
[17:45:19.045] getGlobalsAndPackages() ...
[17:45:19.045] Searching for globals...
[17:45:19.049] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:45:19.049] Searching for globals ... DONE
[17:45:19.049] Resolving globals: FALSE
[17:45:19.050] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:45:19.050] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:19.053] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.053] - packages: [1] ‘future.apply’
[17:45:19.053] getGlobalsAndPackages() ... DONE
[17:45:19.053]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.053]  - needed namespaces: [n=1] ‘future.apply’
[17:45:19.053] Finding globals ... DONE
[17:45:19.053]  - use_args: TRUE
[17:45:19.054]  - Getting '...' globals ...
[17:45:19.054] resolve() on list ...
[17:45:19.054]  recursive: 0
[17:45:19.054]  length: 1
[17:45:19.054]  elements: ‘...’
[17:45:19.054]  length: 0 (resolved future 1)
[17:45:19.055] resolve() on list ... DONE
[17:45:19.055]    - '...' content: [n=0] 
[17:45:19.055] List of 1
[17:45:19.055]  $ ...: list()
[17:45:19.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.055]  - attr(*, "where")=List of 1
[17:45:19.055]   ..$ ...:<environment: 0x5561f4bca428> 
[17:45:19.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.055]  - attr(*, "resolved")= logi TRUE
[17:45:19.055]  - attr(*, "total_size")= num NA
[17:45:19.058]  - Getting '...' globals ... DONE
[17:45:19.058] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:19.058] List of 8
[17:45:19.058]  $ ...future.FUN:function (x, ...)  
[17:45:19.058]  $ x_FUN        :function (x)  
[17:45:19.058]  $ times        : int 4
[17:45:19.058]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.058]  $ stop_if_not  :function (...)  
[17:45:19.058]  $ dim          : int [1:2] 2 2
[17:45:19.058]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:19.058]  $ ...          : list()
[17:45:19.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.058]  - attr(*, "where")=List of 8
[17:45:19.058]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:19.058]   ..$ ...          :<environment: 0x5561f4bca428> 
[17:45:19.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.058]  - attr(*, "resolved")= logi FALSE
[17:45:19.058]  - attr(*, "total_size")= num 97304
[17:45:19.064] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:19.064] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.064] Number of futures (= number of chunks): 2
[17:45:19.064] Launching 2 futures (chunks) ...
[17:45:19.064] Chunk #1 of 2 ...
[17:45:19.064]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.064] getGlobalsAndPackages() ...
[17:45:19.064] Searching for globals...
[17:45:19.065] 
[17:45:19.065] Searching for globals ... DONE
[17:45:19.065] - globals: [0] <none>
[17:45:19.065] getGlobalsAndPackages() ... DONE
[17:45:19.065]    + additional globals found: [n=0] 
[17:45:19.065]    + additional namespaces needed: [n=0] 
[17:45:19.065]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.065]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.065]  - seeds: <none>
[17:45:19.065]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.066] getGlobalsAndPackages() ...
[17:45:19.066] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.066] Resolving globals: FALSE
[17:45:19.066] Tweak future expression to call with '...' arguments ...
[17:45:19.066] {
[17:45:19.066]     do.call(function(...) {
[17:45:19.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.066]             on.exit(options(oopts), add = TRUE)
[17:45:19.066]         }
[17:45:19.066]         {
[17:45:19.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.066]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.066]             })
[17:45:19.066]         }
[17:45:19.066]     }, args = future.call.arguments)
[17:45:19.066] }
[17:45:19.066] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.067] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.067] - packages: [1] ‘future.apply’
[17:45:19.067] getGlobalsAndPackages() ... DONE
[17:45:19.067] run() for ‘Future’ ...
[17:45:19.068] - state: ‘created’
[17:45:19.068] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.072] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.072]   - Field: ‘label’
[17:45:19.072]   - Field: ‘local’
[17:45:19.072]   - Field: ‘owner’
[17:45:19.072]   - Field: ‘envir’
[17:45:19.072]   - Field: ‘workers’
[17:45:19.073]   - Field: ‘packages’
[17:45:19.073]   - Field: ‘gc’
[17:45:19.073]   - Field: ‘job’
[17:45:19.073]   - Field: ‘conditions’
[17:45:19.073]   - Field: ‘expr’
[17:45:19.073]   - Field: ‘uuid’
[17:45:19.073]   - Field: ‘seed’
[17:45:19.073]   - Field: ‘version’
[17:45:19.073]   - Field: ‘result’
[17:45:19.074]   - Field: ‘asynchronous’
[17:45:19.074]   - Field: ‘calls’
[17:45:19.074]   - Field: ‘globals’
[17:45:19.074]   - Field: ‘stdout’
[17:45:19.074]   - Field: ‘earlySignal’
[17:45:19.074]   - Field: ‘lazy’
[17:45:19.074]   - Field: ‘state’
[17:45:19.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.074] - Launch lazy future ...
[17:45:19.075] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:19.075] Packages needed by future strategies (n = 0): <none>
[17:45:19.075] {
[17:45:19.075]     {
[17:45:19.075]         {
[17:45:19.075]             ...future.startTime <- base::Sys.time()
[17:45:19.075]             {
[17:45:19.075]                 {
[17:45:19.075]                   {
[17:45:19.075]                     {
[17:45:19.075]                       {
[17:45:19.075]                         base::local({
[17:45:19.075]                           has_future <- base::requireNamespace("future", 
[17:45:19.075]                             quietly = TRUE)
[17:45:19.075]                           if (has_future) {
[17:45:19.075]                             ns <- base::getNamespace("future")
[17:45:19.075]                             version <- ns[[".package"]][["version"]]
[17:45:19.075]                             if (is.null(version)) 
[17:45:19.075]                               version <- utils::packageVersion("future")
[17:45:19.075]                           }
[17:45:19.075]                           else {
[17:45:19.075]                             version <- NULL
[17:45:19.075]                           }
[17:45:19.075]                           if (!has_future || version < "1.8.0") {
[17:45:19.075]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.075]                               "", base::R.version$version.string), 
[17:45:19.075]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.075]                                 base::R.version$platform, 8 * 
[17:45:19.075]                                   base::.Machine$sizeof.pointer), 
[17:45:19.075]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.075]                                 "release", "version")], collapse = " "), 
[17:45:19.075]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.075]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.075]                               info)
[17:45:19.075]                             info <- base::paste(info, collapse = "; ")
[17:45:19.075]                             if (!has_future) {
[17:45:19.075]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.075]                                 info)
[17:45:19.075]                             }
[17:45:19.075]                             else {
[17:45:19.075]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.075]                                 info, version)
[17:45:19.075]                             }
[17:45:19.075]                             base::stop(msg)
[17:45:19.075]                           }
[17:45:19.075]                         })
[17:45:19.075]                       }
[17:45:19.075]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.075]                       base::options(mc.cores = 1L)
[17:45:19.075]                     }
[17:45:19.075]                     base::local({
[17:45:19.075]                       for (pkg in "future.apply") {
[17:45:19.075]                         base::loadNamespace(pkg)
[17:45:19.075]                         base::library(pkg, character.only = TRUE)
[17:45:19.075]                       }
[17:45:19.075]                     })
[17:45:19.075]                   }
[17:45:19.075]                   ...future.strategy.old <- future::plan("list")
[17:45:19.075]                   options(future.plan = NULL)
[17:45:19.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.075]                 }
[17:45:19.075]                 ...future.workdir <- getwd()
[17:45:19.075]             }
[17:45:19.075]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.075]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.075]         }
[17:45:19.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.075]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.075]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.075]             base::names(...future.oldOptions))
[17:45:19.075]     }
[17:45:19.075]     if (FALSE) {
[17:45:19.075]     }
[17:45:19.075]     else {
[17:45:19.075]         if (TRUE) {
[17:45:19.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.075]                 open = "w")
[17:45:19.075]         }
[17:45:19.075]         else {
[17:45:19.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.075]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.075]         }
[17:45:19.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.075]             base::sink(type = "output", split = FALSE)
[17:45:19.075]             base::close(...future.stdout)
[17:45:19.075]         }, add = TRUE)
[17:45:19.075]     }
[17:45:19.075]     ...future.frame <- base::sys.nframe()
[17:45:19.075]     ...future.conditions <- base::list()
[17:45:19.075]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.075]     if (FALSE) {
[17:45:19.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.075]     }
[17:45:19.075]     ...future.result <- base::tryCatch({
[17:45:19.075]         base::withCallingHandlers({
[17:45:19.075]             ...future.value <- base::withVisible(base::local({
[17:45:19.075]                 withCallingHandlers({
[17:45:19.075]                   {
[17:45:19.075]                     do.call(function(...) {
[17:45:19.075]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.075]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.075]                         ...future.globals.maxSize)) {
[17:45:19.075]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.075]                         on.exit(options(oopts), add = TRUE)
[17:45:19.075]                       }
[17:45:19.075]                       {
[17:45:19.075]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.075]                           FUN = function(jj) {
[17:45:19.075]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.075]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.075]                           })
[17:45:19.075]                       }
[17:45:19.075]                     }, args = future.call.arguments)
[17:45:19.075]                   }
[17:45:19.075]                 }, immediateCondition = function(cond) {
[17:45:19.075]                   save_rds <- function (object, pathname, ...) 
[17:45:19.075]                   {
[17:45:19.075]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.075]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.075]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.075]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.075]                         fi_tmp[["mtime"]])
[17:45:19.075]                     }
[17:45:19.075]                     tryCatch({
[17:45:19.075]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.075]                     }, error = function(ex) {
[17:45:19.075]                       msg <- conditionMessage(ex)
[17:45:19.075]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.075]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.075]                         fi_tmp[["mtime"]], msg)
[17:45:19.075]                       ex$message <- msg
[17:45:19.075]                       stop(ex)
[17:45:19.075]                     })
[17:45:19.075]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.075]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.075]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.075]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.075]                       fi <- file.info(pathname)
[17:45:19.075]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.075]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.075]                         fi[["size"]], fi[["mtime"]])
[17:45:19.075]                       stop(msg)
[17:45:19.075]                     }
[17:45:19.075]                     invisible(pathname)
[17:45:19.075]                   }
[17:45:19.075]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.075]                     rootPath = tempdir()) 
[17:45:19.075]                   {
[17:45:19.075]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.075]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.075]                       tmpdir = path, fileext = ".rds")
[17:45:19.075]                     save_rds(obj, file)
[17:45:19.075]                   }
[17:45:19.075]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.075]                   {
[17:45:19.075]                     inherits <- base::inherits
[17:45:19.075]                     invokeRestart <- base::invokeRestart
[17:45:19.075]                     is.null <- base::is.null
[17:45:19.075]                     muffled <- FALSE
[17:45:19.075]                     if (inherits(cond, "message")) {
[17:45:19.075]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.075]                       if (muffled) 
[17:45:19.075]                         invokeRestart("muffleMessage")
[17:45:19.075]                     }
[17:45:19.075]                     else if (inherits(cond, "warning")) {
[17:45:19.075]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.075]                       if (muffled) 
[17:45:19.075]                         invokeRestart("muffleWarning")
[17:45:19.075]                     }
[17:45:19.075]                     else if (inherits(cond, "condition")) {
[17:45:19.075]                       if (!is.null(pattern)) {
[17:45:19.075]                         computeRestarts <- base::computeRestarts
[17:45:19.075]                         grepl <- base::grepl
[17:45:19.075]                         restarts <- computeRestarts(cond)
[17:45:19.075]                         for (restart in restarts) {
[17:45:19.075]                           name <- restart$name
[17:45:19.075]                           if (is.null(name)) 
[17:45:19.075]                             next
[17:45:19.075]                           if (!grepl(pattern, name)) 
[17:45:19.075]                             next
[17:45:19.075]                           invokeRestart(restart)
[17:45:19.075]                           muffled <- TRUE
[17:45:19.075]                           break
[17:45:19.075]                         }
[17:45:19.075]                       }
[17:45:19.075]                     }
[17:45:19.075]                     invisible(muffled)
[17:45:19.075]                   }
[17:45:19.075]                   muffleCondition(cond)
[17:45:19.075]                 })
[17:45:19.075]             }))
[17:45:19.075]             future::FutureResult(value = ...future.value$value, 
[17:45:19.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.075]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.075]                     ...future.globalenv.names))
[17:45:19.075]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.075]         }, condition = base::local({
[17:45:19.075]             c <- base::c
[17:45:19.075]             inherits <- base::inherits
[17:45:19.075]             invokeRestart <- base::invokeRestart
[17:45:19.075]             length <- base::length
[17:45:19.075]             list <- base::list
[17:45:19.075]             seq.int <- base::seq.int
[17:45:19.075]             signalCondition <- base::signalCondition
[17:45:19.075]             sys.calls <- base::sys.calls
[17:45:19.075]             `[[` <- base::`[[`
[17:45:19.075]             `+` <- base::`+`
[17:45:19.075]             `<<-` <- base::`<<-`
[17:45:19.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.075]                   3L)]
[17:45:19.075]             }
[17:45:19.075]             function(cond) {
[17:45:19.075]                 is_error <- inherits(cond, "error")
[17:45:19.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.075]                   NULL)
[17:45:19.075]                 if (is_error) {
[17:45:19.075]                   sessionInformation <- function() {
[17:45:19.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.075]                       search = base::search(), system = base::Sys.info())
[17:45:19.075]                   }
[17:45:19.075]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.075]                     cond$call), session = sessionInformation(), 
[17:45:19.075]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.075]                   signalCondition(cond)
[17:45:19.075]                 }
[17:45:19.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.075]                 "immediateCondition"))) {
[17:45:19.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.075]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.075]                   if (TRUE && !signal) {
[17:45:19.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.075]                     {
[17:45:19.075]                       inherits <- base::inherits
[17:45:19.075]                       invokeRestart <- base::invokeRestart
[17:45:19.075]                       is.null <- base::is.null
[17:45:19.075]                       muffled <- FALSE
[17:45:19.075]                       if (inherits(cond, "message")) {
[17:45:19.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.075]                         if (muffled) 
[17:45:19.075]                           invokeRestart("muffleMessage")
[17:45:19.075]                       }
[17:45:19.075]                       else if (inherits(cond, "warning")) {
[17:45:19.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.075]                         if (muffled) 
[17:45:19.075]                           invokeRestart("muffleWarning")
[17:45:19.075]                       }
[17:45:19.075]                       else if (inherits(cond, "condition")) {
[17:45:19.075]                         if (!is.null(pattern)) {
[17:45:19.075]                           computeRestarts <- base::computeRestarts
[17:45:19.075]                           grepl <- base::grepl
[17:45:19.075]                           restarts <- computeRestarts(cond)
[17:45:19.075]                           for (restart in restarts) {
[17:45:19.075]                             name <- restart$name
[17:45:19.075]                             if (is.null(name)) 
[17:45:19.075]                               next
[17:45:19.075]                             if (!grepl(pattern, name)) 
[17:45:19.075]                               next
[17:45:19.075]                             invokeRestart(restart)
[17:45:19.075]                             muffled <- TRUE
[17:45:19.075]                             break
[17:45:19.075]                           }
[17:45:19.075]                         }
[17:45:19.075]                       }
[17:45:19.075]                       invisible(muffled)
[17:45:19.075]                     }
[17:45:19.075]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.075]                   }
[17:45:19.075]                 }
[17:45:19.075]                 else {
[17:45:19.075]                   if (TRUE) {
[17:45:19.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.075]                     {
[17:45:19.075]                       inherits <- base::inherits
[17:45:19.075]                       invokeRestart <- base::invokeRestart
[17:45:19.075]                       is.null <- base::is.null
[17:45:19.075]                       muffled <- FALSE
[17:45:19.075]                       if (inherits(cond, "message")) {
[17:45:19.075]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.075]                         if (muffled) 
[17:45:19.075]                           invokeRestart("muffleMessage")
[17:45:19.075]                       }
[17:45:19.075]                       else if (inherits(cond, "warning")) {
[17:45:19.075]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.075]                         if (muffled) 
[17:45:19.075]                           invokeRestart("muffleWarning")
[17:45:19.075]                       }
[17:45:19.075]                       else if (inherits(cond, "condition")) {
[17:45:19.075]                         if (!is.null(pattern)) {
[17:45:19.075]                           computeRestarts <- base::computeRestarts
[17:45:19.075]                           grepl <- base::grepl
[17:45:19.075]                           restarts <- computeRestarts(cond)
[17:45:19.075]                           for (restart in restarts) {
[17:45:19.075]                             name <- restart$name
[17:45:19.075]                             if (is.null(name)) 
[17:45:19.075]                               next
[17:45:19.075]                             if (!grepl(pattern, name)) 
[17:45:19.075]                               next
[17:45:19.075]                             invokeRestart(restart)
[17:45:19.075]                             muffled <- TRUE
[17:45:19.075]                             break
[17:45:19.075]                           }
[17:45:19.075]                         }
[17:45:19.075]                       }
[17:45:19.075]                       invisible(muffled)
[17:45:19.075]                     }
[17:45:19.075]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.075]                   }
[17:45:19.075]                 }
[17:45:19.075]             }
[17:45:19.075]         }))
[17:45:19.075]     }, error = function(ex) {
[17:45:19.075]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.075]                 ...future.rng), started = ...future.startTime, 
[17:45:19.075]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.075]             version = "1.8"), class = "FutureResult")
[17:45:19.075]     }, finally = {
[17:45:19.075]         if (!identical(...future.workdir, getwd())) 
[17:45:19.075]             setwd(...future.workdir)
[17:45:19.075]         {
[17:45:19.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.075]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.075]             }
[17:45:19.075]             base::options(...future.oldOptions)
[17:45:19.075]             if (.Platform$OS.type == "windows") {
[17:45:19.075]                 old_names <- names(...future.oldEnvVars)
[17:45:19.075]                 envs <- base::Sys.getenv()
[17:45:19.075]                 names <- names(envs)
[17:45:19.075]                 common <- intersect(names, old_names)
[17:45:19.075]                 added <- setdiff(names, old_names)
[17:45:19.075]                 removed <- setdiff(old_names, names)
[17:45:19.075]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.075]                   envs[common]]
[17:45:19.075]                 NAMES <- toupper(changed)
[17:45:19.075]                 args <- list()
[17:45:19.075]                 for (kk in seq_along(NAMES)) {
[17:45:19.075]                   name <- changed[[kk]]
[17:45:19.075]                   NAME <- NAMES[[kk]]
[17:45:19.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.075]                     next
[17:45:19.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.075]                 }
[17:45:19.075]                 NAMES <- toupper(added)
[17:45:19.075]                 for (kk in seq_along(NAMES)) {
[17:45:19.075]                   name <- added[[kk]]
[17:45:19.075]                   NAME <- NAMES[[kk]]
[17:45:19.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.075]                     next
[17:45:19.075]                   args[[name]] <- ""
[17:45:19.075]                 }
[17:45:19.075]                 NAMES <- toupper(removed)
[17:45:19.075]                 for (kk in seq_along(NAMES)) {
[17:45:19.075]                   name <- removed[[kk]]
[17:45:19.075]                   NAME <- NAMES[[kk]]
[17:45:19.075]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.075]                     next
[17:45:19.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.075]                 }
[17:45:19.075]                 if (length(args) > 0) 
[17:45:19.075]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.075]             }
[17:45:19.075]             else {
[17:45:19.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.075]             }
[17:45:19.075]             {
[17:45:19.075]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.075]                   0L) {
[17:45:19.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.075]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.075]                   base::options(opts)
[17:45:19.075]                 }
[17:45:19.075]                 {
[17:45:19.075]                   {
[17:45:19.075]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.075]                     NULL
[17:45:19.075]                   }
[17:45:19.075]                   options(future.plan = NULL)
[17:45:19.075]                   if (is.na(NA_character_)) 
[17:45:19.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.075]                     .init = FALSE)
[17:45:19.075]                 }
[17:45:19.075]             }
[17:45:19.075]         }
[17:45:19.075]     })
[17:45:19.075]     if (TRUE) {
[17:45:19.075]         base::sink(type = "output", split = FALSE)
[17:45:19.075]         if (TRUE) {
[17:45:19.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.075]         }
[17:45:19.075]         else {
[17:45:19.075]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.075]         }
[17:45:19.075]         base::close(...future.stdout)
[17:45:19.075]         ...future.stdout <- NULL
[17:45:19.075]     }
[17:45:19.075]     ...future.result$conditions <- ...future.conditions
[17:45:19.075]     ...future.result$finished <- base::Sys.time()
[17:45:19.075]     ...future.result
[17:45:19.075] }
[17:45:19.080] assign_globals() ...
[17:45:19.080] List of 11
[17:45:19.080]  $ ...future.FUN            :function (x, ...)  
[17:45:19.080]  $ x_FUN                    :function (x)  
[17:45:19.080]  $ times                    : int 4
[17:45:19.080]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.080]  $ stop_if_not              :function (...)  
[17:45:19.080]  $ dim                      : int [1:2] 2 2
[17:45:19.080]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.080]  $ future.call.arguments    : list()
[17:45:19.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.080]  $ ...future.elements_ii    :List of 5
[17:45:19.080]   ..$ : int 1
[17:45:19.080]   ..$ : int 2
[17:45:19.080]   ..$ : int 3
[17:45:19.080]   ..$ : int 4
[17:45:19.080]   ..$ : int 5
[17:45:19.080]  $ ...future.seeds_ii       : NULL
[17:45:19.080]  $ ...future.globals.maxSize: NULL
[17:45:19.080]  - attr(*, "where")=List of 11
[17:45:19.080]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.080]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.080]  - attr(*, "resolved")= logi FALSE
[17:45:19.080]  - attr(*, "total_size")= num 97304
[17:45:19.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.080]  - attr(*, "already-done")= logi TRUE
[17:45:19.089] - copied ‘...future.FUN’ to environment
[17:45:19.090] - reassign environment for ‘x_FUN’
[17:45:19.090] - copied ‘x_FUN’ to environment
[17:45:19.090] - copied ‘times’ to environment
[17:45:19.090] - copied ‘stopf’ to environment
[17:45:19.090] - copied ‘stop_if_not’ to environment
[17:45:19.090] - copied ‘dim’ to environment
[17:45:19.090] - copied ‘valid_types’ to environment
[17:45:19.090] - copied ‘future.call.arguments’ to environment
[17:45:19.090] - copied ‘...future.elements_ii’ to environment
[17:45:19.090] - copied ‘...future.seeds_ii’ to environment
[17:45:19.090] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.091] assign_globals() ... done
[17:45:19.091] requestCore(): workers = 2
[17:45:19.093] MulticoreFuture started
[17:45:19.094] - Launch lazy future ... done
[17:45:19.094] run() for ‘MulticoreFuture’ ... done
[17:45:19.094] Created future:
[17:45:19.094] plan(): Setting new future strategy stack:
[17:45:19.095] List of future strategies:
[17:45:19.095] 1. sequential:
[17:45:19.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.095]    - tweaked: FALSE
[17:45:19.095]    - call: NULL
[17:45:19.096] plan(): nbrOfWorkers() = 1
[17:45:19.098] plan(): Setting new future strategy stack:
[17:45:19.098] List of future strategies:
[17:45:19.098] 1. multicore:
[17:45:19.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.098]    - tweaked: FALSE
[17:45:19.098]    - call: plan(strategy)
[17:45:19.103] plan(): nbrOfWorkers() = 2
[17:45:19.094] MulticoreFuture:
[17:45:19.094] Label: ‘future_vapply-1’
[17:45:19.094] Expression:
[17:45:19.094] {
[17:45:19.094]     do.call(function(...) {
[17:45:19.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.094]             on.exit(options(oopts), add = TRUE)
[17:45:19.094]         }
[17:45:19.094]         {
[17:45:19.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.094]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.094]             })
[17:45:19.094]         }
[17:45:19.094]     }, args = future.call.arguments)
[17:45:19.094] }
[17:45:19.094] Lazy evaluation: FALSE
[17:45:19.094] Asynchronous evaluation: TRUE
[17:45:19.094] Local evaluation: TRUE
[17:45:19.094] Environment: R_GlobalEnv
[17:45:19.094] Capture standard output: TRUE
[17:45:19.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.094] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.094] Packages: 1 packages (‘future.apply’)
[17:45:19.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.094] Resolved: TRUE
[17:45:19.094] Value: <not collected>
[17:45:19.094] Conditions captured: <none>
[17:45:19.094] Early signaling: FALSE
[17:45:19.094] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.094] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.104] Chunk #1 of 2 ... DONE
[17:45:19.104] Chunk #2 of 2 ...
[17:45:19.105]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.105] getGlobalsAndPackages() ...
[17:45:19.105] Searching for globals...
[17:45:19.105] 
[17:45:19.106] Searching for globals ... DONE
[17:45:19.106] - globals: [0] <none>
[17:45:19.106] getGlobalsAndPackages() ... DONE
[17:45:19.106]    + additional globals found: [n=0] 
[17:45:19.106]    + additional namespaces needed: [n=0] 
[17:45:19.106]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.106]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.106]  - seeds: <none>
[17:45:19.107]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.107] getGlobalsAndPackages() ...
[17:45:19.107] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.107] Resolving globals: FALSE
[17:45:19.107] Tweak future expression to call with '...' arguments ...
[17:45:19.107] {
[17:45:19.107]     do.call(function(...) {
[17:45:19.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.107]             on.exit(options(oopts), add = TRUE)
[17:45:19.107]         }
[17:45:19.107]         {
[17:45:19.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.107]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.107]             })
[17:45:19.107]         }
[17:45:19.107]     }, args = future.call.arguments)
[17:45:19.107] }
[17:45:19.108] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.109] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.109] - packages: [1] ‘future.apply’
[17:45:19.109] getGlobalsAndPackages() ... DONE
[17:45:19.110] run() for ‘Future’ ...
[17:45:19.110] - state: ‘created’
[17:45:19.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.115] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.115]   - Field: ‘label’
[17:45:19.115]   - Field: ‘local’
[17:45:19.115]   - Field: ‘owner’
[17:45:19.116]   - Field: ‘envir’
[17:45:19.116]   - Field: ‘workers’
[17:45:19.116]   - Field: ‘packages’
[17:45:19.116]   - Field: ‘gc’
[17:45:19.116]   - Field: ‘job’
[17:45:19.116]   - Field: ‘conditions’
[17:45:19.116]   - Field: ‘expr’
[17:45:19.117]   - Field: ‘uuid’
[17:45:19.117]   - Field: ‘seed’
[17:45:19.117]   - Field: ‘version’
[17:45:19.117]   - Field: ‘result’
[17:45:19.117]   - Field: ‘asynchronous’
[17:45:19.117]   - Field: ‘calls’
[17:45:19.117]   - Field: ‘globals’
[17:45:19.118]   - Field: ‘stdout’
[17:45:19.120]   - Field: ‘earlySignal’
[17:45:19.121]   - Field: ‘lazy’
[17:45:19.121]   - Field: ‘state’
[17:45:19.122] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.122] - Launch lazy future ...
[17:45:19.123] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:19.123] Packages needed by future strategies (n = 0): <none>
[17:45:19.125] {
[17:45:19.125]     {
[17:45:19.125]         {
[17:45:19.125]             ...future.startTime <- base::Sys.time()
[17:45:19.125]             {
[17:45:19.125]                 {
[17:45:19.125]                   {
[17:45:19.125]                     {
[17:45:19.125]                       {
[17:45:19.125]                         base::local({
[17:45:19.125]                           has_future <- base::requireNamespace("future", 
[17:45:19.125]                             quietly = TRUE)
[17:45:19.125]                           if (has_future) {
[17:45:19.125]                             ns <- base::getNamespace("future")
[17:45:19.125]                             version <- ns[[".package"]][["version"]]
[17:45:19.125]                             if (is.null(version)) 
[17:45:19.125]                               version <- utils::packageVersion("future")
[17:45:19.125]                           }
[17:45:19.125]                           else {
[17:45:19.125]                             version <- NULL
[17:45:19.125]                           }
[17:45:19.125]                           if (!has_future || version < "1.8.0") {
[17:45:19.125]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.125]                               "", base::R.version$version.string), 
[17:45:19.125]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.125]                                 base::R.version$platform, 8 * 
[17:45:19.125]                                   base::.Machine$sizeof.pointer), 
[17:45:19.125]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.125]                                 "release", "version")], collapse = " "), 
[17:45:19.125]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.125]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.125]                               info)
[17:45:19.125]                             info <- base::paste(info, collapse = "; ")
[17:45:19.125]                             if (!has_future) {
[17:45:19.125]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.125]                                 info)
[17:45:19.125]                             }
[17:45:19.125]                             else {
[17:45:19.125]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.125]                                 info, version)
[17:45:19.125]                             }
[17:45:19.125]                             base::stop(msg)
[17:45:19.125]                           }
[17:45:19.125]                         })
[17:45:19.125]                       }
[17:45:19.125]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.125]                       base::options(mc.cores = 1L)
[17:45:19.125]                     }
[17:45:19.125]                     base::local({
[17:45:19.125]                       for (pkg in "future.apply") {
[17:45:19.125]                         base::loadNamespace(pkg)
[17:45:19.125]                         base::library(pkg, character.only = TRUE)
[17:45:19.125]                       }
[17:45:19.125]                     })
[17:45:19.125]                   }
[17:45:19.125]                   ...future.strategy.old <- future::plan("list")
[17:45:19.125]                   options(future.plan = NULL)
[17:45:19.125]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.125]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.125]                 }
[17:45:19.125]                 ...future.workdir <- getwd()
[17:45:19.125]             }
[17:45:19.125]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.125]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.125]         }
[17:45:19.125]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.125]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.125]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.125]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.125]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.125]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.125]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.125]             base::names(...future.oldOptions))
[17:45:19.125]     }
[17:45:19.125]     if (FALSE) {
[17:45:19.125]     }
[17:45:19.125]     else {
[17:45:19.125]         if (TRUE) {
[17:45:19.125]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.125]                 open = "w")
[17:45:19.125]         }
[17:45:19.125]         else {
[17:45:19.125]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.125]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.125]         }
[17:45:19.125]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.125]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.125]             base::sink(type = "output", split = FALSE)
[17:45:19.125]             base::close(...future.stdout)
[17:45:19.125]         }, add = TRUE)
[17:45:19.125]     }
[17:45:19.125]     ...future.frame <- base::sys.nframe()
[17:45:19.125]     ...future.conditions <- base::list()
[17:45:19.125]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.125]     if (FALSE) {
[17:45:19.125]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.125]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.125]     }
[17:45:19.125]     ...future.result <- base::tryCatch({
[17:45:19.125]         base::withCallingHandlers({
[17:45:19.125]             ...future.value <- base::withVisible(base::local({
[17:45:19.125]                 withCallingHandlers({
[17:45:19.125]                   {
[17:45:19.125]                     do.call(function(...) {
[17:45:19.125]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.125]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.125]                         ...future.globals.maxSize)) {
[17:45:19.125]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.125]                         on.exit(options(oopts), add = TRUE)
[17:45:19.125]                       }
[17:45:19.125]                       {
[17:45:19.125]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.125]                           FUN = function(jj) {
[17:45:19.125]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.125]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.125]                           })
[17:45:19.125]                       }
[17:45:19.125]                     }, args = future.call.arguments)
[17:45:19.125]                   }
[17:45:19.125]                 }, immediateCondition = function(cond) {
[17:45:19.125]                   save_rds <- function (object, pathname, ...) 
[17:45:19.125]                   {
[17:45:19.125]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.125]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.125]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.125]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.125]                         fi_tmp[["mtime"]])
[17:45:19.125]                     }
[17:45:19.125]                     tryCatch({
[17:45:19.125]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.125]                     }, error = function(ex) {
[17:45:19.125]                       msg <- conditionMessage(ex)
[17:45:19.125]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.125]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.125]                         fi_tmp[["mtime"]], msg)
[17:45:19.125]                       ex$message <- msg
[17:45:19.125]                       stop(ex)
[17:45:19.125]                     })
[17:45:19.125]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.125]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.125]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.125]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.125]                       fi <- file.info(pathname)
[17:45:19.125]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.125]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.125]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.125]                         fi[["size"]], fi[["mtime"]])
[17:45:19.125]                       stop(msg)
[17:45:19.125]                     }
[17:45:19.125]                     invisible(pathname)
[17:45:19.125]                   }
[17:45:19.125]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.125]                     rootPath = tempdir()) 
[17:45:19.125]                   {
[17:45:19.125]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.125]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.125]                       tmpdir = path, fileext = ".rds")
[17:45:19.125]                     save_rds(obj, file)
[17:45:19.125]                   }
[17:45:19.125]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.125]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.125]                   {
[17:45:19.125]                     inherits <- base::inherits
[17:45:19.125]                     invokeRestart <- base::invokeRestart
[17:45:19.125]                     is.null <- base::is.null
[17:45:19.125]                     muffled <- FALSE
[17:45:19.125]                     if (inherits(cond, "message")) {
[17:45:19.125]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.125]                       if (muffled) 
[17:45:19.125]                         invokeRestart("muffleMessage")
[17:45:19.125]                     }
[17:45:19.125]                     else if (inherits(cond, "warning")) {
[17:45:19.125]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.125]                       if (muffled) 
[17:45:19.125]                         invokeRestart("muffleWarning")
[17:45:19.125]                     }
[17:45:19.125]                     else if (inherits(cond, "condition")) {
[17:45:19.125]                       if (!is.null(pattern)) {
[17:45:19.125]                         computeRestarts <- base::computeRestarts
[17:45:19.125]                         grepl <- base::grepl
[17:45:19.125]                         restarts <- computeRestarts(cond)
[17:45:19.125]                         for (restart in restarts) {
[17:45:19.125]                           name <- restart$name
[17:45:19.125]                           if (is.null(name)) 
[17:45:19.125]                             next
[17:45:19.125]                           if (!grepl(pattern, name)) 
[17:45:19.125]                             next
[17:45:19.125]                           invokeRestart(restart)
[17:45:19.125]                           muffled <- TRUE
[17:45:19.125]                           break
[17:45:19.125]                         }
[17:45:19.125]                       }
[17:45:19.125]                     }
[17:45:19.125]                     invisible(muffled)
[17:45:19.125]                   }
[17:45:19.125]                   muffleCondition(cond)
[17:45:19.125]                 })
[17:45:19.125]             }))
[17:45:19.125]             future::FutureResult(value = ...future.value$value, 
[17:45:19.125]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.125]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.125]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.125]                     ...future.globalenv.names))
[17:45:19.125]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.125]         }, condition = base::local({
[17:45:19.125]             c <- base::c
[17:45:19.125]             inherits <- base::inherits
[17:45:19.125]             invokeRestart <- base::invokeRestart
[17:45:19.125]             length <- base::length
[17:45:19.125]             list <- base::list
[17:45:19.125]             seq.int <- base::seq.int
[17:45:19.125]             signalCondition <- base::signalCondition
[17:45:19.125]             sys.calls <- base::sys.calls
[17:45:19.125]             `[[` <- base::`[[`
[17:45:19.125]             `+` <- base::`+`
[17:45:19.125]             `<<-` <- base::`<<-`
[17:45:19.125]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.125]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.125]                   3L)]
[17:45:19.125]             }
[17:45:19.125]             function(cond) {
[17:45:19.125]                 is_error <- inherits(cond, "error")
[17:45:19.125]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.125]                   NULL)
[17:45:19.125]                 if (is_error) {
[17:45:19.125]                   sessionInformation <- function() {
[17:45:19.125]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.125]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.125]                       search = base::search(), system = base::Sys.info())
[17:45:19.125]                   }
[17:45:19.125]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.125]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.125]                     cond$call), session = sessionInformation(), 
[17:45:19.125]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.125]                   signalCondition(cond)
[17:45:19.125]                 }
[17:45:19.125]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.125]                 "immediateCondition"))) {
[17:45:19.125]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.125]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.125]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.125]                   if (TRUE && !signal) {
[17:45:19.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.125]                     {
[17:45:19.125]                       inherits <- base::inherits
[17:45:19.125]                       invokeRestart <- base::invokeRestart
[17:45:19.125]                       is.null <- base::is.null
[17:45:19.125]                       muffled <- FALSE
[17:45:19.125]                       if (inherits(cond, "message")) {
[17:45:19.125]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.125]                         if (muffled) 
[17:45:19.125]                           invokeRestart("muffleMessage")
[17:45:19.125]                       }
[17:45:19.125]                       else if (inherits(cond, "warning")) {
[17:45:19.125]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.125]                         if (muffled) 
[17:45:19.125]                           invokeRestart("muffleWarning")
[17:45:19.125]                       }
[17:45:19.125]                       else if (inherits(cond, "condition")) {
[17:45:19.125]                         if (!is.null(pattern)) {
[17:45:19.125]                           computeRestarts <- base::computeRestarts
[17:45:19.125]                           grepl <- base::grepl
[17:45:19.125]                           restarts <- computeRestarts(cond)
[17:45:19.125]                           for (restart in restarts) {
[17:45:19.125]                             name <- restart$name
[17:45:19.125]                             if (is.null(name)) 
[17:45:19.125]                               next
[17:45:19.125]                             if (!grepl(pattern, name)) 
[17:45:19.125]                               next
[17:45:19.125]                             invokeRestart(restart)
[17:45:19.125]                             muffled <- TRUE
[17:45:19.125]                             break
[17:45:19.125]                           }
[17:45:19.125]                         }
[17:45:19.125]                       }
[17:45:19.125]                       invisible(muffled)
[17:45:19.125]                     }
[17:45:19.125]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.125]                   }
[17:45:19.125]                 }
[17:45:19.125]                 else {
[17:45:19.125]                   if (TRUE) {
[17:45:19.125]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.125]                     {
[17:45:19.125]                       inherits <- base::inherits
[17:45:19.125]                       invokeRestart <- base::invokeRestart
[17:45:19.125]                       is.null <- base::is.null
[17:45:19.125]                       muffled <- FALSE
[17:45:19.125]                       if (inherits(cond, "message")) {
[17:45:19.125]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.125]                         if (muffled) 
[17:45:19.125]                           invokeRestart("muffleMessage")
[17:45:19.125]                       }
[17:45:19.125]                       else if (inherits(cond, "warning")) {
[17:45:19.125]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.125]                         if (muffled) 
[17:45:19.125]                           invokeRestart("muffleWarning")
[17:45:19.125]                       }
[17:45:19.125]                       else if (inherits(cond, "condition")) {
[17:45:19.125]                         if (!is.null(pattern)) {
[17:45:19.125]                           computeRestarts <- base::computeRestarts
[17:45:19.125]                           grepl <- base::grepl
[17:45:19.125]                           restarts <- computeRestarts(cond)
[17:45:19.125]                           for (restart in restarts) {
[17:45:19.125]                             name <- restart$name
[17:45:19.125]                             if (is.null(name)) 
[17:45:19.125]                               next
[17:45:19.125]                             if (!grepl(pattern, name)) 
[17:45:19.125]                               next
[17:45:19.125]                             invokeRestart(restart)
[17:45:19.125]                             muffled <- TRUE
[17:45:19.125]                             break
[17:45:19.125]                           }
[17:45:19.125]                         }
[17:45:19.125]                       }
[17:45:19.125]                       invisible(muffled)
[17:45:19.125]                     }
[17:45:19.125]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.125]                   }
[17:45:19.125]                 }
[17:45:19.125]             }
[17:45:19.125]         }))
[17:45:19.125]     }, error = function(ex) {
[17:45:19.125]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.125]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.125]                 ...future.rng), started = ...future.startTime, 
[17:45:19.125]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.125]             version = "1.8"), class = "FutureResult")
[17:45:19.125]     }, finally = {
[17:45:19.125]         if (!identical(...future.workdir, getwd())) 
[17:45:19.125]             setwd(...future.workdir)
[17:45:19.125]         {
[17:45:19.125]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.125]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.125]             }
[17:45:19.125]             base::options(...future.oldOptions)
[17:45:19.125]             if (.Platform$OS.type == "windows") {
[17:45:19.125]                 old_names <- names(...future.oldEnvVars)
[17:45:19.125]                 envs <- base::Sys.getenv()
[17:45:19.125]                 names <- names(envs)
[17:45:19.125]                 common <- intersect(names, old_names)
[17:45:19.125]                 added <- setdiff(names, old_names)
[17:45:19.125]                 removed <- setdiff(old_names, names)
[17:45:19.125]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.125]                   envs[common]]
[17:45:19.125]                 NAMES <- toupper(changed)
[17:45:19.125]                 args <- list()
[17:45:19.125]                 for (kk in seq_along(NAMES)) {
[17:45:19.125]                   name <- changed[[kk]]
[17:45:19.125]                   NAME <- NAMES[[kk]]
[17:45:19.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.125]                     next
[17:45:19.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.125]                 }
[17:45:19.125]                 NAMES <- toupper(added)
[17:45:19.125]                 for (kk in seq_along(NAMES)) {
[17:45:19.125]                   name <- added[[kk]]
[17:45:19.125]                   NAME <- NAMES[[kk]]
[17:45:19.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.125]                     next
[17:45:19.125]                   args[[name]] <- ""
[17:45:19.125]                 }
[17:45:19.125]                 NAMES <- toupper(removed)
[17:45:19.125]                 for (kk in seq_along(NAMES)) {
[17:45:19.125]                   name <- removed[[kk]]
[17:45:19.125]                   NAME <- NAMES[[kk]]
[17:45:19.125]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.125]                     next
[17:45:19.125]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.125]                 }
[17:45:19.125]                 if (length(args) > 0) 
[17:45:19.125]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.125]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.125]             }
[17:45:19.125]             else {
[17:45:19.125]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.125]             }
[17:45:19.125]             {
[17:45:19.125]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.125]                   0L) {
[17:45:19.125]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.125]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.125]                   base::options(opts)
[17:45:19.125]                 }
[17:45:19.125]                 {
[17:45:19.125]                   {
[17:45:19.125]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.125]                     NULL
[17:45:19.125]                   }
[17:45:19.125]                   options(future.plan = NULL)
[17:45:19.125]                   if (is.na(NA_character_)) 
[17:45:19.125]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.125]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.125]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.125]                     .init = FALSE)
[17:45:19.125]                 }
[17:45:19.125]             }
[17:45:19.125]         }
[17:45:19.125]     })
[17:45:19.125]     if (TRUE) {
[17:45:19.125]         base::sink(type = "output", split = FALSE)
[17:45:19.125]         if (TRUE) {
[17:45:19.125]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.125]         }
[17:45:19.125]         else {
[17:45:19.125]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.125]         }
[17:45:19.125]         base::close(...future.stdout)
[17:45:19.125]         ...future.stdout <- NULL
[17:45:19.125]     }
[17:45:19.125]     ...future.result$conditions <- ...future.conditions
[17:45:19.125]     ...future.result$finished <- base::Sys.time()
[17:45:19.125]     ...future.result
[17:45:19.125] }
[17:45:19.128] assign_globals() ...
[17:45:19.128] List of 11
[17:45:19.128]  $ ...future.FUN            :function (x, ...)  
[17:45:19.128]  $ x_FUN                    :function (x)  
[17:45:19.128]  $ times                    : int 4
[17:45:19.128]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.128]  $ stop_if_not              :function (...)  
[17:45:19.128]  $ dim                      : int [1:2] 2 2
[17:45:19.128]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.128]  $ future.call.arguments    : list()
[17:45:19.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.128]  $ ...future.elements_ii    :List of 5
[17:45:19.128]   ..$ : int 6
[17:45:19.128]   ..$ : int 7
[17:45:19.128]   ..$ : int 8
[17:45:19.128]   ..$ : int 9
[17:45:19.128]   ..$ : int 10
[17:45:19.128]  $ ...future.seeds_ii       : NULL
[17:45:19.128]  $ ...future.globals.maxSize: NULL
[17:45:19.128]  - attr(*, "where")=List of 11
[17:45:19.128]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.128]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.128]  - attr(*, "resolved")= logi FALSE
[17:45:19.128]  - attr(*, "total_size")= num 97304
[17:45:19.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.128]  - attr(*, "already-done")= logi TRUE
[17:45:19.142] - copied ‘...future.FUN’ to environment
[17:45:19.142] - reassign environment for ‘x_FUN’
[17:45:19.142] - copied ‘x_FUN’ to environment
[17:45:19.142] - copied ‘times’ to environment
[17:45:19.142] - copied ‘stopf’ to environment
[17:45:19.142] - copied ‘stop_if_not’ to environment
[17:45:19.142] - copied ‘dim’ to environment
[17:45:19.142] - copied ‘valid_types’ to environment
[17:45:19.142] - copied ‘future.call.arguments’ to environment
[17:45:19.143] - copied ‘...future.elements_ii’ to environment
[17:45:19.143] - copied ‘...future.seeds_ii’ to environment
[17:45:19.143] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.143] assign_globals() ... done
[17:45:19.143] requestCore(): workers = 2
[17:45:19.145] MulticoreFuture started
[17:45:19.146] - Launch lazy future ... done
[17:45:19.146] run() for ‘MulticoreFuture’ ... done
[17:45:19.146] Created future:
[17:45:19.147] plan(): Setting new future strategy stack:
[17:45:19.147] List of future strategies:
[17:45:19.147] 1. sequential:
[17:45:19.147]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.147]    - tweaked: FALSE
[17:45:19.147]    - call: NULL
[17:45:19.148] plan(): nbrOfWorkers() = 1
[17:45:19.150] plan(): Setting new future strategy stack:
[17:45:19.150] List of future strategies:
[17:45:19.150] 1. multicore:
[17:45:19.150]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.150]    - tweaked: FALSE
[17:45:19.150]    - call: plan(strategy)
[17:45:19.156] plan(): nbrOfWorkers() = 2
[17:45:19.146] MulticoreFuture:
[17:45:19.146] Label: ‘future_vapply-2’
[17:45:19.146] Expression:
[17:45:19.146] {
[17:45:19.146]     do.call(function(...) {
[17:45:19.146]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.146]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.146]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.146]             on.exit(options(oopts), add = TRUE)
[17:45:19.146]         }
[17:45:19.146]         {
[17:45:19.146]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.146]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.146]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.146]             })
[17:45:19.146]         }
[17:45:19.146]     }, args = future.call.arguments)
[17:45:19.146] }
[17:45:19.146] Lazy evaluation: FALSE
[17:45:19.146] Asynchronous evaluation: TRUE
[17:45:19.146] Local evaluation: TRUE
[17:45:19.146] Environment: R_GlobalEnv
[17:45:19.146] Capture standard output: TRUE
[17:45:19.146] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.146] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.146] Packages: 1 packages (‘future.apply’)
[17:45:19.146] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.146] Resolved: TRUE
[17:45:19.146] Value: <not collected>
[17:45:19.146] Conditions captured: <none>
[17:45:19.146] Early signaling: FALSE
[17:45:19.146] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.146] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.157] Chunk #2 of 2 ... DONE
[17:45:19.157] Launching 2 futures (chunks) ... DONE
[17:45:19.157] Resolving 2 futures (chunks) ...
[17:45:19.157] resolve() on list ...
[17:45:19.157]  recursive: 0
[17:45:19.157]  length: 2
[17:45:19.157] 
[17:45:19.158] Future #1
[17:45:19.158] result() for MulticoreFuture ...
[17:45:19.159] result() for MulticoreFuture ...
[17:45:19.159] result() for MulticoreFuture ... done
[17:45:19.159] result() for MulticoreFuture ... done
[17:45:19.159] result() for MulticoreFuture ...
[17:45:19.160] result() for MulticoreFuture ... done
[17:45:19.160] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.160] - nx: 2
[17:45:19.160] - relay: TRUE
[17:45:19.160] - stdout: TRUE
[17:45:19.161] - signal: TRUE
[17:45:19.161] - resignal: FALSE
[17:45:19.161] - force: TRUE
[17:45:19.161] - relayed: [n=2] FALSE, FALSE
[17:45:19.161] - queued futures: [n=2] FALSE, FALSE
[17:45:19.161]  - until=1
[17:45:19.162]  - relaying element #1
[17:45:19.162] result() for MulticoreFuture ...
[17:45:19.162] result() for MulticoreFuture ... done
[17:45:19.162] result() for MulticoreFuture ...
[17:45:19.162] result() for MulticoreFuture ... done
[17:45:19.163] result() for MulticoreFuture ...
[17:45:19.163] result() for MulticoreFuture ... done
[17:45:19.163] result() for MulticoreFuture ...
[17:45:19.163] result() for MulticoreFuture ... done
[17:45:19.163] - relayed: [n=2] TRUE, FALSE
[17:45:19.164] - queued futures: [n=2] TRUE, FALSE
[17:45:19.164] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.164]  length: 1 (resolved future 1)
[17:45:19.164] Future #2
[17:45:19.164] result() for MulticoreFuture ...
[17:45:19.165] result() for MulticoreFuture ...
[17:45:19.165] result() for MulticoreFuture ... done
[17:45:19.165] result() for MulticoreFuture ... done
[17:45:19.166] result() for MulticoreFuture ...
[17:45:19.166] result() for MulticoreFuture ... done
[17:45:19.171] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.171] - nx: 2
[17:45:19.171] - relay: TRUE
[17:45:19.172] - stdout: TRUE
[17:45:19.172] - signal: TRUE
[17:45:19.172] - resignal: FALSE
[17:45:19.172] - force: TRUE
[17:45:19.172] - relayed: [n=2] TRUE, FALSE
[17:45:19.172] - queued futures: [n=2] TRUE, FALSE
[17:45:19.172]  - until=2
[17:45:19.172]  - relaying element #2
[17:45:19.172] result() for MulticoreFuture ...
[17:45:19.172] result() for MulticoreFuture ... done
[17:45:19.173] result() for MulticoreFuture ...
[17:45:19.173] result() for MulticoreFuture ... done
[17:45:19.173] result() for MulticoreFuture ...
[17:45:19.173] result() for MulticoreFuture ... done
[17:45:19.173] result() for MulticoreFuture ...
[17:45:19.173] result() for MulticoreFuture ... done
[17:45:19.174] - relayed: [n=2] TRUE, TRUE
[17:45:19.174] - queued futures: [n=2] TRUE, TRUE
[17:45:19.174] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.174]  length: 0 (resolved future 2)
[17:45:19.174] Relaying remaining futures
[17:45:19.174] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.174] - nx: 2
[17:45:19.175] - relay: TRUE
[17:45:19.175] - stdout: TRUE
[17:45:19.175] - signal: TRUE
[17:45:19.175] - resignal: FALSE
[17:45:19.175] - force: TRUE
[17:45:19.175] - relayed: [n=2] TRUE, TRUE
[17:45:19.175] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.176] - relayed: [n=2] TRUE, TRUE
[17:45:19.176] - queued futures: [n=2] TRUE, TRUE
[17:45:19.176] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.176] resolve() on list ... DONE
[17:45:19.176] result() for MulticoreFuture ...
[17:45:19.176] result() for MulticoreFuture ... done
[17:45:19.176] result() for MulticoreFuture ...
[17:45:19.177] result() for MulticoreFuture ... done
[17:45:19.177] result() for MulticoreFuture ...
[17:45:19.177] result() for MulticoreFuture ... done
[17:45:19.177] result() for MulticoreFuture ...
[17:45:19.177] result() for MulticoreFuture ... done
[17:45:19.177]  - Number of value chunks collected: 2
[17:45:19.178] Resolving 2 futures (chunks) ... DONE
[17:45:19.178] Reducing values from 2 chunks ...
[17:45:19.178]  - Number of values collected after concatenation: 10
[17:45:19.178]  - Number of values expected: 10
[17:45:19.178] Reducing values from 2 chunks ... DONE
[17:45:19.178] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:45:19.180] future_lapply() ...
[17:45:19.186] Number of chunks: 2
[17:45:19.186] getGlobalsAndPackagesXApply() ...
[17:45:19.187]  - future.globals: TRUE
[17:45:19.187] getGlobalsAndPackages() ...
[17:45:19.187] Searching for globals...
[17:45:19.191] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:45:19.191] Searching for globals ... DONE
[17:45:19.191] Resolving globals: FALSE
[17:45:19.192] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:45:19.192] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:19.193] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.193] - packages: [1] ‘future.apply’
[17:45:19.193] getGlobalsAndPackages() ... DONE
[17:45:19.193]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.193]  - needed namespaces: [n=1] ‘future.apply’
[17:45:19.193] Finding globals ... DONE
[17:45:19.193]  - use_args: TRUE
[17:45:19.193]  - Getting '...' globals ...
[17:45:19.194] resolve() on list ...
[17:45:19.194]  recursive: 0
[17:45:19.194]  length: 1
[17:45:19.194]  elements: ‘...’
[17:45:19.194]  length: 0 (resolved future 1)
[17:45:19.194] resolve() on list ... DONE
[17:45:19.194]    - '...' content: [n=0] 
[17:45:19.194] List of 1
[17:45:19.194]  $ ...: list()
[17:45:19.194]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.194]  - attr(*, "where")=List of 1
[17:45:19.194]   ..$ ...:<environment: 0x5561f3528df8> 
[17:45:19.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.194]  - attr(*, "resolved")= logi TRUE
[17:45:19.194]  - attr(*, "total_size")= num NA
[17:45:19.199]  - Getting '...' globals ... DONE
[17:45:19.199] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:19.199] List of 8
[17:45:19.199]  $ ...future.FUN:function (x, ...)  
[17:45:19.199]  $ x_FUN        :function (x)  
[17:45:19.199]  $ times        : int 4
[17:45:19.199]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.199]  $ stop_if_not  :function (...)  
[17:45:19.199]  $ dim          : int [1:2] 2 2
[17:45:19.199]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:19.199]  $ ...          : list()
[17:45:19.199]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.199]  - attr(*, "where")=List of 8
[17:45:19.199]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:19.199]   ..$ ...          :<environment: 0x5561f3528df8> 
[17:45:19.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.199]  - attr(*, "resolved")= logi FALSE
[17:45:19.199]  - attr(*, "total_size")= num 105552
[17:45:19.206] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:19.206] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.206] Number of futures (= number of chunks): 2
[17:45:19.206] Launching 2 futures (chunks) ...
[17:45:19.206] Chunk #1 of 2 ...
[17:45:19.206]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.206] getGlobalsAndPackages() ...
[17:45:19.206] Searching for globals...
[17:45:19.207] 
[17:45:19.207] Searching for globals ... DONE
[17:45:19.207] - globals: [0] <none>
[17:45:19.207] getGlobalsAndPackages() ... DONE
[17:45:19.207]    + additional globals found: [n=0] 
[17:45:19.207]    + additional namespaces needed: [n=0] 
[17:45:19.207]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.207]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.208]  - seeds: <none>
[17:45:19.208]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.208] getGlobalsAndPackages() ...
[17:45:19.208] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.208] Resolving globals: FALSE
[17:45:19.208] Tweak future expression to call with '...' arguments ...
[17:45:19.208] {
[17:45:19.208]     do.call(function(...) {
[17:45:19.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.208]             on.exit(options(oopts), add = TRUE)
[17:45:19.208]         }
[17:45:19.208]         {
[17:45:19.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.208]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.208]             })
[17:45:19.208]         }
[17:45:19.208]     }, args = future.call.arguments)
[17:45:19.208] }
[17:45:19.208] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.209] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.209] - packages: [1] ‘future.apply’
[17:45:19.209] getGlobalsAndPackages() ... DONE
[17:45:19.210] run() for ‘Future’ ...
[17:45:19.210] - state: ‘created’
[17:45:19.210] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.214] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.214] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.214]   - Field: ‘label’
[17:45:19.214]   - Field: ‘local’
[17:45:19.214]   - Field: ‘owner’
[17:45:19.214]   - Field: ‘envir’
[17:45:19.214]   - Field: ‘workers’
[17:45:19.214]   - Field: ‘packages’
[17:45:19.214]   - Field: ‘gc’
[17:45:19.215]   - Field: ‘job’
[17:45:19.215]   - Field: ‘conditions’
[17:45:19.215]   - Field: ‘expr’
[17:45:19.215]   - Field: ‘uuid’
[17:45:19.215]   - Field: ‘seed’
[17:45:19.215]   - Field: ‘version’
[17:45:19.215]   - Field: ‘result’
[17:45:19.215]   - Field: ‘asynchronous’
[17:45:19.215]   - Field: ‘calls’
[17:45:19.215]   - Field: ‘globals’
[17:45:19.216]   - Field: ‘stdout’
[17:45:19.216]   - Field: ‘earlySignal’
[17:45:19.216]   - Field: ‘lazy’
[17:45:19.216]   - Field: ‘state’
[17:45:19.216] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.216] - Launch lazy future ...
[17:45:19.216] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:19.216] Packages needed by future strategies (n = 0): <none>
[17:45:19.217] {
[17:45:19.217]     {
[17:45:19.217]         {
[17:45:19.217]             ...future.startTime <- base::Sys.time()
[17:45:19.217]             {
[17:45:19.217]                 {
[17:45:19.217]                   {
[17:45:19.217]                     {
[17:45:19.217]                       {
[17:45:19.217]                         base::local({
[17:45:19.217]                           has_future <- base::requireNamespace("future", 
[17:45:19.217]                             quietly = TRUE)
[17:45:19.217]                           if (has_future) {
[17:45:19.217]                             ns <- base::getNamespace("future")
[17:45:19.217]                             version <- ns[[".package"]][["version"]]
[17:45:19.217]                             if (is.null(version)) 
[17:45:19.217]                               version <- utils::packageVersion("future")
[17:45:19.217]                           }
[17:45:19.217]                           else {
[17:45:19.217]                             version <- NULL
[17:45:19.217]                           }
[17:45:19.217]                           if (!has_future || version < "1.8.0") {
[17:45:19.217]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.217]                               "", base::R.version$version.string), 
[17:45:19.217]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.217]                                 base::R.version$platform, 8 * 
[17:45:19.217]                                   base::.Machine$sizeof.pointer), 
[17:45:19.217]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.217]                                 "release", "version")], collapse = " "), 
[17:45:19.217]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.217]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.217]                               info)
[17:45:19.217]                             info <- base::paste(info, collapse = "; ")
[17:45:19.217]                             if (!has_future) {
[17:45:19.217]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.217]                                 info)
[17:45:19.217]                             }
[17:45:19.217]                             else {
[17:45:19.217]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.217]                                 info, version)
[17:45:19.217]                             }
[17:45:19.217]                             base::stop(msg)
[17:45:19.217]                           }
[17:45:19.217]                         })
[17:45:19.217]                       }
[17:45:19.217]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.217]                       base::options(mc.cores = 1L)
[17:45:19.217]                     }
[17:45:19.217]                     base::local({
[17:45:19.217]                       for (pkg in "future.apply") {
[17:45:19.217]                         base::loadNamespace(pkg)
[17:45:19.217]                         base::library(pkg, character.only = TRUE)
[17:45:19.217]                       }
[17:45:19.217]                     })
[17:45:19.217]                   }
[17:45:19.217]                   ...future.strategy.old <- future::plan("list")
[17:45:19.217]                   options(future.plan = NULL)
[17:45:19.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.217]                 }
[17:45:19.217]                 ...future.workdir <- getwd()
[17:45:19.217]             }
[17:45:19.217]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.217]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.217]         }
[17:45:19.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.217]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.217]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.217]             base::names(...future.oldOptions))
[17:45:19.217]     }
[17:45:19.217]     if (FALSE) {
[17:45:19.217]     }
[17:45:19.217]     else {
[17:45:19.217]         if (TRUE) {
[17:45:19.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.217]                 open = "w")
[17:45:19.217]         }
[17:45:19.217]         else {
[17:45:19.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.217]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.217]         }
[17:45:19.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.217]             base::sink(type = "output", split = FALSE)
[17:45:19.217]             base::close(...future.stdout)
[17:45:19.217]         }, add = TRUE)
[17:45:19.217]     }
[17:45:19.217]     ...future.frame <- base::sys.nframe()
[17:45:19.217]     ...future.conditions <- base::list()
[17:45:19.217]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.217]     if (FALSE) {
[17:45:19.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.217]     }
[17:45:19.217]     ...future.result <- base::tryCatch({
[17:45:19.217]         base::withCallingHandlers({
[17:45:19.217]             ...future.value <- base::withVisible(base::local({
[17:45:19.217]                 withCallingHandlers({
[17:45:19.217]                   {
[17:45:19.217]                     do.call(function(...) {
[17:45:19.217]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.217]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.217]                         ...future.globals.maxSize)) {
[17:45:19.217]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.217]                         on.exit(options(oopts), add = TRUE)
[17:45:19.217]                       }
[17:45:19.217]                       {
[17:45:19.217]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.217]                           FUN = function(jj) {
[17:45:19.217]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.217]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.217]                           })
[17:45:19.217]                       }
[17:45:19.217]                     }, args = future.call.arguments)
[17:45:19.217]                   }
[17:45:19.217]                 }, immediateCondition = function(cond) {
[17:45:19.217]                   save_rds <- function (object, pathname, ...) 
[17:45:19.217]                   {
[17:45:19.217]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.217]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.217]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.217]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.217]                         fi_tmp[["mtime"]])
[17:45:19.217]                     }
[17:45:19.217]                     tryCatch({
[17:45:19.217]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.217]                     }, error = function(ex) {
[17:45:19.217]                       msg <- conditionMessage(ex)
[17:45:19.217]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.217]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.217]                         fi_tmp[["mtime"]], msg)
[17:45:19.217]                       ex$message <- msg
[17:45:19.217]                       stop(ex)
[17:45:19.217]                     })
[17:45:19.217]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.217]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.217]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.217]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.217]                       fi <- file.info(pathname)
[17:45:19.217]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.217]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.217]                         fi[["size"]], fi[["mtime"]])
[17:45:19.217]                       stop(msg)
[17:45:19.217]                     }
[17:45:19.217]                     invisible(pathname)
[17:45:19.217]                   }
[17:45:19.217]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.217]                     rootPath = tempdir()) 
[17:45:19.217]                   {
[17:45:19.217]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.217]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.217]                       tmpdir = path, fileext = ".rds")
[17:45:19.217]                     save_rds(obj, file)
[17:45:19.217]                   }
[17:45:19.217]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.217]                   {
[17:45:19.217]                     inherits <- base::inherits
[17:45:19.217]                     invokeRestart <- base::invokeRestart
[17:45:19.217]                     is.null <- base::is.null
[17:45:19.217]                     muffled <- FALSE
[17:45:19.217]                     if (inherits(cond, "message")) {
[17:45:19.217]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.217]                       if (muffled) 
[17:45:19.217]                         invokeRestart("muffleMessage")
[17:45:19.217]                     }
[17:45:19.217]                     else if (inherits(cond, "warning")) {
[17:45:19.217]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.217]                       if (muffled) 
[17:45:19.217]                         invokeRestart("muffleWarning")
[17:45:19.217]                     }
[17:45:19.217]                     else if (inherits(cond, "condition")) {
[17:45:19.217]                       if (!is.null(pattern)) {
[17:45:19.217]                         computeRestarts <- base::computeRestarts
[17:45:19.217]                         grepl <- base::grepl
[17:45:19.217]                         restarts <- computeRestarts(cond)
[17:45:19.217]                         for (restart in restarts) {
[17:45:19.217]                           name <- restart$name
[17:45:19.217]                           if (is.null(name)) 
[17:45:19.217]                             next
[17:45:19.217]                           if (!grepl(pattern, name)) 
[17:45:19.217]                             next
[17:45:19.217]                           invokeRestart(restart)
[17:45:19.217]                           muffled <- TRUE
[17:45:19.217]                           break
[17:45:19.217]                         }
[17:45:19.217]                       }
[17:45:19.217]                     }
[17:45:19.217]                     invisible(muffled)
[17:45:19.217]                   }
[17:45:19.217]                   muffleCondition(cond)
[17:45:19.217]                 })
[17:45:19.217]             }))
[17:45:19.217]             future::FutureResult(value = ...future.value$value, 
[17:45:19.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.217]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.217]                     ...future.globalenv.names))
[17:45:19.217]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.217]         }, condition = base::local({
[17:45:19.217]             c <- base::c
[17:45:19.217]             inherits <- base::inherits
[17:45:19.217]             invokeRestart <- base::invokeRestart
[17:45:19.217]             length <- base::length
[17:45:19.217]             list <- base::list
[17:45:19.217]             seq.int <- base::seq.int
[17:45:19.217]             signalCondition <- base::signalCondition
[17:45:19.217]             sys.calls <- base::sys.calls
[17:45:19.217]             `[[` <- base::`[[`
[17:45:19.217]             `+` <- base::`+`
[17:45:19.217]             `<<-` <- base::`<<-`
[17:45:19.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.217]                   3L)]
[17:45:19.217]             }
[17:45:19.217]             function(cond) {
[17:45:19.217]                 is_error <- inherits(cond, "error")
[17:45:19.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.217]                   NULL)
[17:45:19.217]                 if (is_error) {
[17:45:19.217]                   sessionInformation <- function() {
[17:45:19.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.217]                       search = base::search(), system = base::Sys.info())
[17:45:19.217]                   }
[17:45:19.217]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.217]                     cond$call), session = sessionInformation(), 
[17:45:19.217]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.217]                   signalCondition(cond)
[17:45:19.217]                 }
[17:45:19.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.217]                 "immediateCondition"))) {
[17:45:19.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.217]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.217]                   if (TRUE && !signal) {
[17:45:19.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.217]                     {
[17:45:19.217]                       inherits <- base::inherits
[17:45:19.217]                       invokeRestart <- base::invokeRestart
[17:45:19.217]                       is.null <- base::is.null
[17:45:19.217]                       muffled <- FALSE
[17:45:19.217]                       if (inherits(cond, "message")) {
[17:45:19.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.217]                         if (muffled) 
[17:45:19.217]                           invokeRestart("muffleMessage")
[17:45:19.217]                       }
[17:45:19.217]                       else if (inherits(cond, "warning")) {
[17:45:19.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.217]                         if (muffled) 
[17:45:19.217]                           invokeRestart("muffleWarning")
[17:45:19.217]                       }
[17:45:19.217]                       else if (inherits(cond, "condition")) {
[17:45:19.217]                         if (!is.null(pattern)) {
[17:45:19.217]                           computeRestarts <- base::computeRestarts
[17:45:19.217]                           grepl <- base::grepl
[17:45:19.217]                           restarts <- computeRestarts(cond)
[17:45:19.217]                           for (restart in restarts) {
[17:45:19.217]                             name <- restart$name
[17:45:19.217]                             if (is.null(name)) 
[17:45:19.217]                               next
[17:45:19.217]                             if (!grepl(pattern, name)) 
[17:45:19.217]                               next
[17:45:19.217]                             invokeRestart(restart)
[17:45:19.217]                             muffled <- TRUE
[17:45:19.217]                             break
[17:45:19.217]                           }
[17:45:19.217]                         }
[17:45:19.217]                       }
[17:45:19.217]                       invisible(muffled)
[17:45:19.217]                     }
[17:45:19.217]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.217]                   }
[17:45:19.217]                 }
[17:45:19.217]                 else {
[17:45:19.217]                   if (TRUE) {
[17:45:19.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.217]                     {
[17:45:19.217]                       inherits <- base::inherits
[17:45:19.217]                       invokeRestart <- base::invokeRestart
[17:45:19.217]                       is.null <- base::is.null
[17:45:19.217]                       muffled <- FALSE
[17:45:19.217]                       if (inherits(cond, "message")) {
[17:45:19.217]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.217]                         if (muffled) 
[17:45:19.217]                           invokeRestart("muffleMessage")
[17:45:19.217]                       }
[17:45:19.217]                       else if (inherits(cond, "warning")) {
[17:45:19.217]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.217]                         if (muffled) 
[17:45:19.217]                           invokeRestart("muffleWarning")
[17:45:19.217]                       }
[17:45:19.217]                       else if (inherits(cond, "condition")) {
[17:45:19.217]                         if (!is.null(pattern)) {
[17:45:19.217]                           computeRestarts <- base::computeRestarts
[17:45:19.217]                           grepl <- base::grepl
[17:45:19.217]                           restarts <- computeRestarts(cond)
[17:45:19.217]                           for (restart in restarts) {
[17:45:19.217]                             name <- restart$name
[17:45:19.217]                             if (is.null(name)) 
[17:45:19.217]                               next
[17:45:19.217]                             if (!grepl(pattern, name)) 
[17:45:19.217]                               next
[17:45:19.217]                             invokeRestart(restart)
[17:45:19.217]                             muffled <- TRUE
[17:45:19.217]                             break
[17:45:19.217]                           }
[17:45:19.217]                         }
[17:45:19.217]                       }
[17:45:19.217]                       invisible(muffled)
[17:45:19.217]                     }
[17:45:19.217]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.217]                   }
[17:45:19.217]                 }
[17:45:19.217]             }
[17:45:19.217]         }))
[17:45:19.217]     }, error = function(ex) {
[17:45:19.217]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.217]                 ...future.rng), started = ...future.startTime, 
[17:45:19.217]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.217]             version = "1.8"), class = "FutureResult")
[17:45:19.217]     }, finally = {
[17:45:19.217]         if (!identical(...future.workdir, getwd())) 
[17:45:19.217]             setwd(...future.workdir)
[17:45:19.217]         {
[17:45:19.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.217]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.217]             }
[17:45:19.217]             base::options(...future.oldOptions)
[17:45:19.217]             if (.Platform$OS.type == "windows") {
[17:45:19.217]                 old_names <- names(...future.oldEnvVars)
[17:45:19.217]                 envs <- base::Sys.getenv()
[17:45:19.217]                 names <- names(envs)
[17:45:19.217]                 common <- intersect(names, old_names)
[17:45:19.217]                 added <- setdiff(names, old_names)
[17:45:19.217]                 removed <- setdiff(old_names, names)
[17:45:19.217]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.217]                   envs[common]]
[17:45:19.217]                 NAMES <- toupper(changed)
[17:45:19.217]                 args <- list()
[17:45:19.217]                 for (kk in seq_along(NAMES)) {
[17:45:19.217]                   name <- changed[[kk]]
[17:45:19.217]                   NAME <- NAMES[[kk]]
[17:45:19.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.217]                     next
[17:45:19.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.217]                 }
[17:45:19.217]                 NAMES <- toupper(added)
[17:45:19.217]                 for (kk in seq_along(NAMES)) {
[17:45:19.217]                   name <- added[[kk]]
[17:45:19.217]                   NAME <- NAMES[[kk]]
[17:45:19.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.217]                     next
[17:45:19.217]                   args[[name]] <- ""
[17:45:19.217]                 }
[17:45:19.217]                 NAMES <- toupper(removed)
[17:45:19.217]                 for (kk in seq_along(NAMES)) {
[17:45:19.217]                   name <- removed[[kk]]
[17:45:19.217]                   NAME <- NAMES[[kk]]
[17:45:19.217]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.217]                     next
[17:45:19.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.217]                 }
[17:45:19.217]                 if (length(args) > 0) 
[17:45:19.217]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.217]             }
[17:45:19.217]             else {
[17:45:19.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.217]             }
[17:45:19.217]             {
[17:45:19.217]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.217]                   0L) {
[17:45:19.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.217]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.217]                   base::options(opts)
[17:45:19.217]                 }
[17:45:19.217]                 {
[17:45:19.217]                   {
[17:45:19.217]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.217]                     NULL
[17:45:19.217]                   }
[17:45:19.217]                   options(future.plan = NULL)
[17:45:19.217]                   if (is.na(NA_character_)) 
[17:45:19.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.217]                     .init = FALSE)
[17:45:19.217]                 }
[17:45:19.217]             }
[17:45:19.217]         }
[17:45:19.217]     })
[17:45:19.217]     if (TRUE) {
[17:45:19.217]         base::sink(type = "output", split = FALSE)
[17:45:19.217]         if (TRUE) {
[17:45:19.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.217]         }
[17:45:19.217]         else {
[17:45:19.217]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.217]         }
[17:45:19.217]         base::close(...future.stdout)
[17:45:19.217]         ...future.stdout <- NULL
[17:45:19.217]     }
[17:45:19.217]     ...future.result$conditions <- ...future.conditions
[17:45:19.217]     ...future.result$finished <- base::Sys.time()
[17:45:19.217]     ...future.result
[17:45:19.217] }
[17:45:19.219] assign_globals() ...
[17:45:19.220] List of 11
[17:45:19.220]  $ ...future.FUN            :function (x, ...)  
[17:45:19.220]  $ x_FUN                    :function (x)  
[17:45:19.220]  $ times                    : int 4
[17:45:19.220]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.220]  $ stop_if_not              :function (...)  
[17:45:19.220]  $ dim                      : int [1:2] 2 2
[17:45:19.220]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.220]  $ future.call.arguments    : list()
[17:45:19.220]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.220]  $ ...future.elements_ii    :List of 5
[17:45:19.220]   ..$ : int 1
[17:45:19.220]   ..$ : int 2
[17:45:19.220]   ..$ : int 3
[17:45:19.220]   ..$ : int 4
[17:45:19.220]   ..$ : int 5
[17:45:19.220]  $ ...future.seeds_ii       : NULL
[17:45:19.220]  $ ...future.globals.maxSize: NULL
[17:45:19.220]  - attr(*, "where")=List of 11
[17:45:19.220]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.220]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.220]  - attr(*, "resolved")= logi FALSE
[17:45:19.220]  - attr(*, "total_size")= num 105552
[17:45:19.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.220]  - attr(*, "already-done")= logi TRUE
[17:45:19.231] - copied ‘...future.FUN’ to environment
[17:45:19.231] - reassign environment for ‘x_FUN’
[17:45:19.231] - copied ‘x_FUN’ to environment
[17:45:19.231] - copied ‘times’ to environment
[17:45:19.231] - copied ‘stopf’ to environment
[17:45:19.232] - copied ‘stop_if_not’ to environment
[17:45:19.232] - copied ‘dim’ to environment
[17:45:19.232] - copied ‘valid_types’ to environment
[17:45:19.232] - copied ‘future.call.arguments’ to environment
[17:45:19.232] - copied ‘...future.elements_ii’ to environment
[17:45:19.232] - copied ‘...future.seeds_ii’ to environment
[17:45:19.232] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.232] assign_globals() ... done
[17:45:19.232] requestCore(): workers = 2
[17:45:19.235] MulticoreFuture started
[17:45:19.235] - Launch lazy future ... done
[17:45:19.235] run() for ‘MulticoreFuture’ ... done
[17:45:19.236] Created future:
[17:45:19.236] plan(): Setting new future strategy stack:
[17:45:19.237] List of future strategies:
[17:45:19.237] 1. sequential:
[17:45:19.237]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.237]    - tweaked: FALSE
[17:45:19.237]    - call: NULL
[17:45:19.238] plan(): nbrOfWorkers() = 1
[17:45:19.240] plan(): Setting new future strategy stack:
[17:45:19.240] List of future strategies:
[17:45:19.240] 1. multicore:
[17:45:19.240]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.240]    - tweaked: FALSE
[17:45:19.240]    - call: plan(strategy)
[17:45:19.246] plan(): nbrOfWorkers() = 2
[17:45:19.236] MulticoreFuture:
[17:45:19.236] Label: ‘future_vapply-1’
[17:45:19.236] Expression:
[17:45:19.236] {
[17:45:19.236]     do.call(function(...) {
[17:45:19.236]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.236]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.236]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.236]             on.exit(options(oopts), add = TRUE)
[17:45:19.236]         }
[17:45:19.236]         {
[17:45:19.236]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.236]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.236]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.236]             })
[17:45:19.236]         }
[17:45:19.236]     }, args = future.call.arguments)
[17:45:19.236] }
[17:45:19.236] Lazy evaluation: FALSE
[17:45:19.236] Asynchronous evaluation: TRUE
[17:45:19.236] Local evaluation: TRUE
[17:45:19.236] Environment: R_GlobalEnv
[17:45:19.236] Capture standard output: TRUE
[17:45:19.236] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.236] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.236] Packages: 1 packages (‘future.apply’)
[17:45:19.236] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.236] Resolved: TRUE
[17:45:19.236] Value: <not collected>
[17:45:19.236] Conditions captured: <none>
[17:45:19.236] Early signaling: FALSE
[17:45:19.236] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.236] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.247] Chunk #1 of 2 ... DONE
[17:45:19.247] Chunk #2 of 2 ...
[17:45:19.247]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.248] getGlobalsAndPackages() ...
[17:45:19.248] Searching for globals...
[17:45:19.248] 
[17:45:19.249] Searching for globals ... DONE
[17:45:19.249] - globals: [0] <none>
[17:45:19.249] getGlobalsAndPackages() ... DONE
[17:45:19.249]    + additional globals found: [n=0] 
[17:45:19.249]    + additional namespaces needed: [n=0] 
[17:45:19.249]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.249]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.250]  - seeds: <none>
[17:45:19.250]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.250] getGlobalsAndPackages() ...
[17:45:19.250] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.250] Resolving globals: FALSE
[17:45:19.250] Tweak future expression to call with '...' arguments ...
[17:45:19.251] {
[17:45:19.251]     do.call(function(...) {
[17:45:19.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.251]             on.exit(options(oopts), add = TRUE)
[17:45:19.251]         }
[17:45:19.251]         {
[17:45:19.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.251]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.251]             })
[17:45:19.251]         }
[17:45:19.251]     }, args = future.call.arguments)
[17:45:19.251] }
[17:45:19.251] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.252] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.252] - packages: [1] ‘future.apply’
[17:45:19.252] getGlobalsAndPackages() ... DONE
[17:45:19.253] run() for ‘Future’ ...
[17:45:19.253] - state: ‘created’
[17:45:19.253] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.258] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.258] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.258]   - Field: ‘label’
[17:45:19.258]   - Field: ‘local’
[17:45:19.258]   - Field: ‘owner’
[17:45:19.259]   - Field: ‘envir’
[17:45:19.259]   - Field: ‘workers’
[17:45:19.259]   - Field: ‘packages’
[17:45:19.259]   - Field: ‘gc’
[17:45:19.259]   - Field: ‘job’
[17:45:19.259]   - Field: ‘conditions’
[17:45:19.259]   - Field: ‘expr’
[17:45:19.260]   - Field: ‘uuid’
[17:45:19.260]   - Field: ‘seed’
[17:45:19.260]   - Field: ‘version’
[17:45:19.260]   - Field: ‘result’
[17:45:19.260]   - Field: ‘asynchronous’
[17:45:19.260]   - Field: ‘calls’
[17:45:19.261]   - Field: ‘globals’
[17:45:19.261]   - Field: ‘stdout’
[17:45:19.261]   - Field: ‘earlySignal’
[17:45:19.261]   - Field: ‘lazy’
[17:45:19.261]   - Field: ‘state’
[17:45:19.261] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.261] - Launch lazy future ...
[17:45:19.262] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:19.262] Packages needed by future strategies (n = 0): <none>
[17:45:19.263] {
[17:45:19.263]     {
[17:45:19.263]         {
[17:45:19.263]             ...future.startTime <- base::Sys.time()
[17:45:19.263]             {
[17:45:19.263]                 {
[17:45:19.263]                   {
[17:45:19.263]                     {
[17:45:19.263]                       {
[17:45:19.263]                         base::local({
[17:45:19.263]                           has_future <- base::requireNamespace("future", 
[17:45:19.263]                             quietly = TRUE)
[17:45:19.263]                           if (has_future) {
[17:45:19.263]                             ns <- base::getNamespace("future")
[17:45:19.263]                             version <- ns[[".package"]][["version"]]
[17:45:19.263]                             if (is.null(version)) 
[17:45:19.263]                               version <- utils::packageVersion("future")
[17:45:19.263]                           }
[17:45:19.263]                           else {
[17:45:19.263]                             version <- NULL
[17:45:19.263]                           }
[17:45:19.263]                           if (!has_future || version < "1.8.0") {
[17:45:19.263]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.263]                               "", base::R.version$version.string), 
[17:45:19.263]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.263]                                 base::R.version$platform, 8 * 
[17:45:19.263]                                   base::.Machine$sizeof.pointer), 
[17:45:19.263]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.263]                                 "release", "version")], collapse = " "), 
[17:45:19.263]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.263]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.263]                               info)
[17:45:19.263]                             info <- base::paste(info, collapse = "; ")
[17:45:19.263]                             if (!has_future) {
[17:45:19.263]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.263]                                 info)
[17:45:19.263]                             }
[17:45:19.263]                             else {
[17:45:19.263]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.263]                                 info, version)
[17:45:19.263]                             }
[17:45:19.263]                             base::stop(msg)
[17:45:19.263]                           }
[17:45:19.263]                         })
[17:45:19.263]                       }
[17:45:19.263]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.263]                       base::options(mc.cores = 1L)
[17:45:19.263]                     }
[17:45:19.263]                     base::local({
[17:45:19.263]                       for (pkg in "future.apply") {
[17:45:19.263]                         base::loadNamespace(pkg)
[17:45:19.263]                         base::library(pkg, character.only = TRUE)
[17:45:19.263]                       }
[17:45:19.263]                     })
[17:45:19.263]                   }
[17:45:19.263]                   ...future.strategy.old <- future::plan("list")
[17:45:19.263]                   options(future.plan = NULL)
[17:45:19.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.263]                 }
[17:45:19.263]                 ...future.workdir <- getwd()
[17:45:19.263]             }
[17:45:19.263]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.263]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.263]         }
[17:45:19.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.263]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.263]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.263]             base::names(...future.oldOptions))
[17:45:19.263]     }
[17:45:19.263]     if (FALSE) {
[17:45:19.263]     }
[17:45:19.263]     else {
[17:45:19.263]         if (TRUE) {
[17:45:19.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.263]                 open = "w")
[17:45:19.263]         }
[17:45:19.263]         else {
[17:45:19.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.263]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.263]         }
[17:45:19.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.263]             base::sink(type = "output", split = FALSE)
[17:45:19.263]             base::close(...future.stdout)
[17:45:19.263]         }, add = TRUE)
[17:45:19.263]     }
[17:45:19.263]     ...future.frame <- base::sys.nframe()
[17:45:19.263]     ...future.conditions <- base::list()
[17:45:19.263]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.263]     if (FALSE) {
[17:45:19.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.263]     }
[17:45:19.263]     ...future.result <- base::tryCatch({
[17:45:19.263]         base::withCallingHandlers({
[17:45:19.263]             ...future.value <- base::withVisible(base::local({
[17:45:19.263]                 withCallingHandlers({
[17:45:19.263]                   {
[17:45:19.263]                     do.call(function(...) {
[17:45:19.263]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.263]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.263]                         ...future.globals.maxSize)) {
[17:45:19.263]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.263]                         on.exit(options(oopts), add = TRUE)
[17:45:19.263]                       }
[17:45:19.263]                       {
[17:45:19.263]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.263]                           FUN = function(jj) {
[17:45:19.263]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.263]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.263]                           })
[17:45:19.263]                       }
[17:45:19.263]                     }, args = future.call.arguments)
[17:45:19.263]                   }
[17:45:19.263]                 }, immediateCondition = function(cond) {
[17:45:19.263]                   save_rds <- function (object, pathname, ...) 
[17:45:19.263]                   {
[17:45:19.263]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.263]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.263]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.263]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.263]                         fi_tmp[["mtime"]])
[17:45:19.263]                     }
[17:45:19.263]                     tryCatch({
[17:45:19.263]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.263]                     }, error = function(ex) {
[17:45:19.263]                       msg <- conditionMessage(ex)
[17:45:19.263]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.263]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.263]                         fi_tmp[["mtime"]], msg)
[17:45:19.263]                       ex$message <- msg
[17:45:19.263]                       stop(ex)
[17:45:19.263]                     })
[17:45:19.263]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.263]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.263]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.263]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.263]                       fi <- file.info(pathname)
[17:45:19.263]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.263]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.263]                         fi[["size"]], fi[["mtime"]])
[17:45:19.263]                       stop(msg)
[17:45:19.263]                     }
[17:45:19.263]                     invisible(pathname)
[17:45:19.263]                   }
[17:45:19.263]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.263]                     rootPath = tempdir()) 
[17:45:19.263]                   {
[17:45:19.263]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.263]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.263]                       tmpdir = path, fileext = ".rds")
[17:45:19.263]                     save_rds(obj, file)
[17:45:19.263]                   }
[17:45:19.263]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.263]                   {
[17:45:19.263]                     inherits <- base::inherits
[17:45:19.263]                     invokeRestart <- base::invokeRestart
[17:45:19.263]                     is.null <- base::is.null
[17:45:19.263]                     muffled <- FALSE
[17:45:19.263]                     if (inherits(cond, "message")) {
[17:45:19.263]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.263]                       if (muffled) 
[17:45:19.263]                         invokeRestart("muffleMessage")
[17:45:19.263]                     }
[17:45:19.263]                     else if (inherits(cond, "warning")) {
[17:45:19.263]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.263]                       if (muffled) 
[17:45:19.263]                         invokeRestart("muffleWarning")
[17:45:19.263]                     }
[17:45:19.263]                     else if (inherits(cond, "condition")) {
[17:45:19.263]                       if (!is.null(pattern)) {
[17:45:19.263]                         computeRestarts <- base::computeRestarts
[17:45:19.263]                         grepl <- base::grepl
[17:45:19.263]                         restarts <- computeRestarts(cond)
[17:45:19.263]                         for (restart in restarts) {
[17:45:19.263]                           name <- restart$name
[17:45:19.263]                           if (is.null(name)) 
[17:45:19.263]                             next
[17:45:19.263]                           if (!grepl(pattern, name)) 
[17:45:19.263]                             next
[17:45:19.263]                           invokeRestart(restart)
[17:45:19.263]                           muffled <- TRUE
[17:45:19.263]                           break
[17:45:19.263]                         }
[17:45:19.263]                       }
[17:45:19.263]                     }
[17:45:19.263]                     invisible(muffled)
[17:45:19.263]                   }
[17:45:19.263]                   muffleCondition(cond)
[17:45:19.263]                 })
[17:45:19.263]             }))
[17:45:19.263]             future::FutureResult(value = ...future.value$value, 
[17:45:19.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.263]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.263]                     ...future.globalenv.names))
[17:45:19.263]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.263]         }, condition = base::local({
[17:45:19.263]             c <- base::c
[17:45:19.263]             inherits <- base::inherits
[17:45:19.263]             invokeRestart <- base::invokeRestart
[17:45:19.263]             length <- base::length
[17:45:19.263]             list <- base::list
[17:45:19.263]             seq.int <- base::seq.int
[17:45:19.263]             signalCondition <- base::signalCondition
[17:45:19.263]             sys.calls <- base::sys.calls
[17:45:19.263]             `[[` <- base::`[[`
[17:45:19.263]             `+` <- base::`+`
[17:45:19.263]             `<<-` <- base::`<<-`
[17:45:19.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.263]                   3L)]
[17:45:19.263]             }
[17:45:19.263]             function(cond) {
[17:45:19.263]                 is_error <- inherits(cond, "error")
[17:45:19.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.263]                   NULL)
[17:45:19.263]                 if (is_error) {
[17:45:19.263]                   sessionInformation <- function() {
[17:45:19.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.263]                       search = base::search(), system = base::Sys.info())
[17:45:19.263]                   }
[17:45:19.263]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.263]                     cond$call), session = sessionInformation(), 
[17:45:19.263]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.263]                   signalCondition(cond)
[17:45:19.263]                 }
[17:45:19.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.263]                 "immediateCondition"))) {
[17:45:19.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.263]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.263]                   if (TRUE && !signal) {
[17:45:19.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.263]                     {
[17:45:19.263]                       inherits <- base::inherits
[17:45:19.263]                       invokeRestart <- base::invokeRestart
[17:45:19.263]                       is.null <- base::is.null
[17:45:19.263]                       muffled <- FALSE
[17:45:19.263]                       if (inherits(cond, "message")) {
[17:45:19.263]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.263]                         if (muffled) 
[17:45:19.263]                           invokeRestart("muffleMessage")
[17:45:19.263]                       }
[17:45:19.263]                       else if (inherits(cond, "warning")) {
[17:45:19.263]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.263]                         if (muffled) 
[17:45:19.263]                           invokeRestart("muffleWarning")
[17:45:19.263]                       }
[17:45:19.263]                       else if (inherits(cond, "condition")) {
[17:45:19.263]                         if (!is.null(pattern)) {
[17:45:19.263]                           computeRestarts <- base::computeRestarts
[17:45:19.263]                           grepl <- base::grepl
[17:45:19.263]                           restarts <- computeRestarts(cond)
[17:45:19.263]                           for (restart in restarts) {
[17:45:19.263]                             name <- restart$name
[17:45:19.263]                             if (is.null(name)) 
[17:45:19.263]                               next
[17:45:19.263]                             if (!grepl(pattern, name)) 
[17:45:19.263]                               next
[17:45:19.263]                             invokeRestart(restart)
[17:45:19.263]                             muffled <- TRUE
[17:45:19.263]                             break
[17:45:19.263]                           }
[17:45:19.263]                         }
[17:45:19.263]                       }
[17:45:19.263]                       invisible(muffled)
[17:45:19.263]                     }
[17:45:19.263]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.263]                   }
[17:45:19.263]                 }
[17:45:19.263]                 else {
[17:45:19.263]                   if (TRUE) {
[17:45:19.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.263]                     {
[17:45:19.263]                       inherits <- base::inherits
[17:45:19.263]                       invokeRestart <- base::invokeRestart
[17:45:19.263]                       is.null <- base::is.null
[17:45:19.263]                       muffled <- FALSE
[17:45:19.263]                       if (inherits(cond, "message")) {
[17:45:19.263]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.263]                         if (muffled) 
[17:45:19.263]                           invokeRestart("muffleMessage")
[17:45:19.263]                       }
[17:45:19.263]                       else if (inherits(cond, "warning")) {
[17:45:19.263]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.263]                         if (muffled) 
[17:45:19.263]                           invokeRestart("muffleWarning")
[17:45:19.263]                       }
[17:45:19.263]                       else if (inherits(cond, "condition")) {
[17:45:19.263]                         if (!is.null(pattern)) {
[17:45:19.263]                           computeRestarts <- base::computeRestarts
[17:45:19.263]                           grepl <- base::grepl
[17:45:19.263]                           restarts <- computeRestarts(cond)
[17:45:19.263]                           for (restart in restarts) {
[17:45:19.263]                             name <- restart$name
[17:45:19.263]                             if (is.null(name)) 
[17:45:19.263]                               next
[17:45:19.263]                             if (!grepl(pattern, name)) 
[17:45:19.263]                               next
[17:45:19.263]                             invokeRestart(restart)
[17:45:19.263]                             muffled <- TRUE
[17:45:19.263]                             break
[17:45:19.263]                           }
[17:45:19.263]                         }
[17:45:19.263]                       }
[17:45:19.263]                       invisible(muffled)
[17:45:19.263]                     }
[17:45:19.263]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.263]                   }
[17:45:19.263]                 }
[17:45:19.263]             }
[17:45:19.263]         }))
[17:45:19.263]     }, error = function(ex) {
[17:45:19.263]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.263]                 ...future.rng), started = ...future.startTime, 
[17:45:19.263]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.263]             version = "1.8"), class = "FutureResult")
[17:45:19.263]     }, finally = {
[17:45:19.263]         if (!identical(...future.workdir, getwd())) 
[17:45:19.263]             setwd(...future.workdir)
[17:45:19.263]         {
[17:45:19.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.263]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.263]             }
[17:45:19.263]             base::options(...future.oldOptions)
[17:45:19.263]             if (.Platform$OS.type == "windows") {
[17:45:19.263]                 old_names <- names(...future.oldEnvVars)
[17:45:19.263]                 envs <- base::Sys.getenv()
[17:45:19.263]                 names <- names(envs)
[17:45:19.263]                 common <- intersect(names, old_names)
[17:45:19.263]                 added <- setdiff(names, old_names)
[17:45:19.263]                 removed <- setdiff(old_names, names)
[17:45:19.263]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.263]                   envs[common]]
[17:45:19.263]                 NAMES <- toupper(changed)
[17:45:19.263]                 args <- list()
[17:45:19.263]                 for (kk in seq_along(NAMES)) {
[17:45:19.263]                   name <- changed[[kk]]
[17:45:19.263]                   NAME <- NAMES[[kk]]
[17:45:19.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.263]                     next
[17:45:19.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.263]                 }
[17:45:19.263]                 NAMES <- toupper(added)
[17:45:19.263]                 for (kk in seq_along(NAMES)) {
[17:45:19.263]                   name <- added[[kk]]
[17:45:19.263]                   NAME <- NAMES[[kk]]
[17:45:19.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.263]                     next
[17:45:19.263]                   args[[name]] <- ""
[17:45:19.263]                 }
[17:45:19.263]                 NAMES <- toupper(removed)
[17:45:19.263]                 for (kk in seq_along(NAMES)) {
[17:45:19.263]                   name <- removed[[kk]]
[17:45:19.263]                   NAME <- NAMES[[kk]]
[17:45:19.263]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.263]                     next
[17:45:19.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.263]                 }
[17:45:19.263]                 if (length(args) > 0) 
[17:45:19.263]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.263]             }
[17:45:19.263]             else {
[17:45:19.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.263]             }
[17:45:19.263]             {
[17:45:19.263]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.263]                   0L) {
[17:45:19.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.263]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.263]                   base::options(opts)
[17:45:19.263]                 }
[17:45:19.263]                 {
[17:45:19.263]                   {
[17:45:19.263]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.263]                     NULL
[17:45:19.263]                   }
[17:45:19.263]                   options(future.plan = NULL)
[17:45:19.263]                   if (is.na(NA_character_)) 
[17:45:19.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.263]                     .init = FALSE)
[17:45:19.263]                 }
[17:45:19.263]             }
[17:45:19.263]         }
[17:45:19.263]     })
[17:45:19.263]     if (TRUE) {
[17:45:19.263]         base::sink(type = "output", split = FALSE)
[17:45:19.263]         if (TRUE) {
[17:45:19.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.263]         }
[17:45:19.263]         else {
[17:45:19.263]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.263]         }
[17:45:19.263]         base::close(...future.stdout)
[17:45:19.263]         ...future.stdout <- NULL
[17:45:19.263]     }
[17:45:19.263]     ...future.result$conditions <- ...future.conditions
[17:45:19.263]     ...future.result$finished <- base::Sys.time()
[17:45:19.263]     ...future.result
[17:45:19.263] }
[17:45:19.267] assign_globals() ...
[17:45:19.267] List of 11
[17:45:19.267]  $ ...future.FUN            :function (x, ...)  
[17:45:19.267]  $ x_FUN                    :function (x)  
[17:45:19.267]  $ times                    : int 4
[17:45:19.267]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.267]  $ stop_if_not              :function (...)  
[17:45:19.267]  $ dim                      : int [1:2] 2 2
[17:45:19.267]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.267]  $ future.call.arguments    : list()
[17:45:19.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.267]  $ ...future.elements_ii    :List of 5
[17:45:19.267]   ..$ : int 6
[17:45:19.267]   ..$ : int 7
[17:45:19.267]   ..$ : int 8
[17:45:19.267]   ..$ : int 9
[17:45:19.267]   ..$ : int 10
[17:45:19.267]  $ ...future.seeds_ii       : NULL
[17:45:19.267]  $ ...future.globals.maxSize: NULL
[17:45:19.267]  - attr(*, "where")=List of 11
[17:45:19.267]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.267]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.267]  - attr(*, "resolved")= logi FALSE
[17:45:19.267]  - attr(*, "total_size")= num 105552
[17:45:19.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.267]  - attr(*, "already-done")= logi TRUE
[17:45:19.284] - copied ‘...future.FUN’ to environment
[17:45:19.284] - reassign environment for ‘x_FUN’
[17:45:19.284] - copied ‘x_FUN’ to environment
[17:45:19.285] - copied ‘times’ to environment
[17:45:19.285] - copied ‘stopf’ to environment
[17:45:19.285] - copied ‘stop_if_not’ to environment
[17:45:19.285] - copied ‘dim’ to environment
[17:45:19.285] - copied ‘valid_types’ to environment
[17:45:19.285] - copied ‘future.call.arguments’ to environment
[17:45:19.285] - copied ‘...future.elements_ii’ to environment
[17:45:19.286] - copied ‘...future.seeds_ii’ to environment
[17:45:19.286] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.286] assign_globals() ... done
[17:45:19.286] requestCore(): workers = 2
[17:45:19.288] MulticoreFuture started
[17:45:19.289] - Launch lazy future ... done
[17:45:19.289] run() for ‘MulticoreFuture’ ... done
[17:45:19.289] Created future:
[17:45:19.290] plan(): Setting new future strategy stack:
[17:45:19.290] List of future strategies:
[17:45:19.290] 1. sequential:
[17:45:19.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.290]    - tweaked: FALSE
[17:45:19.290]    - call: NULL
[17:45:19.291] plan(): nbrOfWorkers() = 1
[17:45:19.293] plan(): Setting new future strategy stack:
[17:45:19.293] List of future strategies:
[17:45:19.293] 1. multicore:
[17:45:19.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.293]    - tweaked: FALSE
[17:45:19.293]    - call: plan(strategy)
[17:45:19.298] plan(): nbrOfWorkers() = 2
[17:45:19.290] MulticoreFuture:
[17:45:19.290] Label: ‘future_vapply-2’
[17:45:19.290] Expression:
[17:45:19.290] {
[17:45:19.290]     do.call(function(...) {
[17:45:19.290]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.290]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.290]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.290]             on.exit(options(oopts), add = TRUE)
[17:45:19.290]         }
[17:45:19.290]         {
[17:45:19.290]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.290]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.290]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.290]             })
[17:45:19.290]         }
[17:45:19.290]     }, args = future.call.arguments)
[17:45:19.290] }
[17:45:19.290] Lazy evaluation: FALSE
[17:45:19.290] Asynchronous evaluation: TRUE
[17:45:19.290] Local evaluation: TRUE
[17:45:19.290] Environment: R_GlobalEnv
[17:45:19.290] Capture standard output: TRUE
[17:45:19.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.290] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.290] Packages: 1 packages (‘future.apply’)
[17:45:19.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.290] Resolved: TRUE
[17:45:19.290] Value: <not collected>
[17:45:19.290] Conditions captured: <none>
[17:45:19.290] Early signaling: FALSE
[17:45:19.290] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.290] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.300] Chunk #2 of 2 ... DONE
[17:45:19.300] Launching 2 futures (chunks) ... DONE
[17:45:19.300] Resolving 2 futures (chunks) ...
[17:45:19.300] resolve() on list ...
[17:45:19.300]  recursive: 0
[17:45:19.300]  length: 2
[17:45:19.300] 
[17:45:19.301] Future #1
[17:45:19.301] result() for MulticoreFuture ...
[17:45:19.302] result() for MulticoreFuture ...
[17:45:19.302] result() for MulticoreFuture ... done
[17:45:19.302] result() for MulticoreFuture ... done
[17:45:19.302] result() for MulticoreFuture ...
[17:45:19.302] result() for MulticoreFuture ... done
[17:45:19.303] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.303] - nx: 2
[17:45:19.303] - relay: TRUE
[17:45:19.303] - stdout: TRUE
[17:45:19.303] - signal: TRUE
[17:45:19.303] - resignal: FALSE
[17:45:19.303] - force: TRUE
[17:45:19.304] - relayed: [n=2] FALSE, FALSE
[17:45:19.304] - queued futures: [n=2] FALSE, FALSE
[17:45:19.304]  - until=1
[17:45:19.304]  - relaying element #1
[17:45:19.304] result() for MulticoreFuture ...
[17:45:19.304] result() for MulticoreFuture ... done
[17:45:19.304] result() for MulticoreFuture ...
[17:45:19.305] result() for MulticoreFuture ... done
[17:45:19.305] result() for MulticoreFuture ...
[17:45:19.305] result() for MulticoreFuture ... done
[17:45:19.305] result() for MulticoreFuture ...
[17:45:19.305] result() for MulticoreFuture ... done
[17:45:19.305] - relayed: [n=2] TRUE, FALSE
[17:45:19.306] - queued futures: [n=2] TRUE, FALSE
[17:45:19.306] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.306]  length: 1 (resolved future 1)
[17:45:19.306] Future #2
[17:45:19.306] result() for MulticoreFuture ...
[17:45:19.307] result() for MulticoreFuture ...
[17:45:19.307] result() for MulticoreFuture ... done
[17:45:19.307] result() for MulticoreFuture ... done
[17:45:19.308] result() for MulticoreFuture ...
[17:45:19.308] result() for MulticoreFuture ... done
[17:45:19.308] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.308] - nx: 2
[17:45:19.308] - relay: TRUE
[17:45:19.308] - stdout: TRUE
[17:45:19.308] - signal: TRUE
[17:45:19.308] - resignal: FALSE
[17:45:19.309] - force: TRUE
[17:45:19.309] - relayed: [n=2] TRUE, FALSE
[17:45:19.309] - queued futures: [n=2] TRUE, FALSE
[17:45:19.309]  - until=2
[17:45:19.309]  - relaying element #2
[17:45:19.309] result() for MulticoreFuture ...
[17:45:19.309] result() for MulticoreFuture ... done
[17:45:19.309] result() for MulticoreFuture ...
[17:45:19.310] result() for MulticoreFuture ... done
[17:45:19.310] result() for MulticoreFuture ...
[17:45:19.310] result() for MulticoreFuture ... done
[17:45:19.310] result() for MulticoreFuture ...
[17:45:19.310] result() for MulticoreFuture ... done
[17:45:19.310] - relayed: [n=2] TRUE, TRUE
[17:45:19.310] - queued futures: [n=2] TRUE, TRUE
[17:45:19.310] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.311]  length: 0 (resolved future 2)
[17:45:19.311] Relaying remaining futures
[17:45:19.311] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.311] - nx: 2
[17:45:19.311] - relay: TRUE
[17:45:19.311] - stdout: TRUE
[17:45:19.311] - signal: TRUE
[17:45:19.311] - resignal: FALSE
[17:45:19.312] - force: TRUE
[17:45:19.312] - relayed: [n=2] TRUE, TRUE
[17:45:19.312] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.312] - relayed: [n=2] TRUE, TRUE
[17:45:19.312] - queued futures: [n=2] TRUE, TRUE
[17:45:19.312] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.312] resolve() on list ... DONE
[17:45:19.312] result() for MulticoreFuture ...
[17:45:19.312] result() for MulticoreFuture ... done
[17:45:19.313] result() for MulticoreFuture ...
[17:45:19.313] result() for MulticoreFuture ... done
[17:45:19.313] result() for MulticoreFuture ...
[17:45:19.313] result() for MulticoreFuture ... done
[17:45:19.313] result() for MulticoreFuture ...
[17:45:19.313] result() for MulticoreFuture ... done
[17:45:19.313]  - Number of value chunks collected: 2
[17:45:19.313] Resolving 2 futures (chunks) ... DONE
[17:45:19.313] Reducing values from 2 chunks ...
[17:45:19.314]  - Number of values collected after concatenation: 10
[17:45:19.314]  - Number of values expected: 10
[17:45:19.314] Reducing values from 2 chunks ... DONE
[17:45:19.314] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:45:19.317] future_lapply() ...
[17:45:19.327] Number of chunks: 2
[17:45:19.327] getGlobalsAndPackagesXApply() ...
[17:45:19.327]  - future.globals: TRUE
[17:45:19.328] getGlobalsAndPackages() ...
[17:45:19.328] Searching for globals...
[17:45:19.332] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:45:19.332] Searching for globals ... DONE
[17:45:19.333] Resolving globals: FALSE
[17:45:19.333] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:45:19.334] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:19.334] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.334] - packages: [2] ‘stats’, ‘future.apply’
[17:45:19.334] getGlobalsAndPackages() ... DONE
[17:45:19.334]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.335]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:45:19.335] Finding globals ... DONE
[17:45:19.335]  - use_args: TRUE
[17:45:19.335]  - Getting '...' globals ...
[17:45:19.335] resolve() on list ...
[17:45:19.335]  recursive: 0
[17:45:19.335]  length: 1
[17:45:19.336]  elements: ‘...’
[17:45:19.336]  length: 0 (resolved future 1)
[17:45:19.336] resolve() on list ... DONE
[17:45:19.336]    - '...' content: [n=0] 
[17:45:19.336] List of 1
[17:45:19.336]  $ ...: list()
[17:45:19.336]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.336]  - attr(*, "where")=List of 1
[17:45:19.336]   ..$ ...:<environment: 0x5561f561d480> 
[17:45:19.336]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.336]  - attr(*, "resolved")= logi TRUE
[17:45:19.336]  - attr(*, "total_size")= num NA
[17:45:19.339]  - Getting '...' globals ... DONE
[17:45:19.339] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:19.339] List of 8
[17:45:19.339]  $ ...future.FUN:function (x, ...)  
[17:45:19.339]  $ x_FUN        :function (x, ...)  
[17:45:19.339]  $ times        : int 5
[17:45:19.339]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.339]  $ stop_if_not  :function (...)  
[17:45:19.339]  $ dim          : NULL
[17:45:19.339]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:19.339]  $ ...          : list()
[17:45:19.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.339]  - attr(*, "where")=List of 8
[17:45:19.339]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:19.339]   ..$ ...          :<environment: 0x5561f561d480> 
[17:45:19.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.339]  - attr(*, "resolved")= logi FALSE
[17:45:19.339]  - attr(*, "total_size")= num 95528
[17:45:19.344] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:45:19.344] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.345] Number of futures (= number of chunks): 2
[17:45:19.345] Launching 2 futures (chunks) ...
[17:45:19.345] Chunk #1 of 2 ...
[17:45:19.345]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.347] getGlobalsAndPackages() ...
[17:45:19.347] Searching for globals...
[17:45:19.348] 
[17:45:19.348] Searching for globals ... DONE
[17:45:19.348] - globals: [0] <none>
[17:45:19.348] getGlobalsAndPackages() ... DONE
[17:45:19.348]    + additional globals found: [n=0] 
[17:45:19.348]    + additional namespaces needed: [n=0] 
[17:45:19.348]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.349]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.349]  - seeds: <none>
[17:45:19.349]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.349] getGlobalsAndPackages() ...
[17:45:19.349] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.349] Resolving globals: FALSE
[17:45:19.349] Tweak future expression to call with '...' arguments ...
[17:45:19.349] {
[17:45:19.349]     do.call(function(...) {
[17:45:19.349]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.349]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.349]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.349]             on.exit(options(oopts), add = TRUE)
[17:45:19.349]         }
[17:45:19.349]         {
[17:45:19.349]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.349]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.349]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.349]             })
[17:45:19.349]         }
[17:45:19.349]     }, args = future.call.arguments)
[17:45:19.349] }
[17:45:19.350] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.350] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.351] - packages: [2] ‘stats’, ‘future.apply’
[17:45:19.351] getGlobalsAndPackages() ... DONE
[17:45:19.351] run() for ‘Future’ ...
[17:45:19.351] - state: ‘created’
[17:45:19.351] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.356]   - Field: ‘label’
[17:45:19.356]   - Field: ‘local’
[17:45:19.357]   - Field: ‘owner’
[17:45:19.357]   - Field: ‘envir’
[17:45:19.357]   - Field: ‘workers’
[17:45:19.357]   - Field: ‘packages’
[17:45:19.357]   - Field: ‘gc’
[17:45:19.357]   - Field: ‘job’
[17:45:19.357]   - Field: ‘conditions’
[17:45:19.357]   - Field: ‘expr’
[17:45:19.357]   - Field: ‘uuid’
[17:45:19.358]   - Field: ‘seed’
[17:45:19.358]   - Field: ‘version’
[17:45:19.358]   - Field: ‘result’
[17:45:19.358]   - Field: ‘asynchronous’
[17:45:19.358]   - Field: ‘calls’
[17:45:19.358]   - Field: ‘globals’
[17:45:19.358]   - Field: ‘stdout’
[17:45:19.358]   - Field: ‘earlySignal’
[17:45:19.358]   - Field: ‘lazy’
[17:45:19.358]   - Field: ‘state’
[17:45:19.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.359] - Launch lazy future ...
[17:45:19.359] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:19.359] Packages needed by future strategies (n = 0): <none>
[17:45:19.360] {
[17:45:19.360]     {
[17:45:19.360]         {
[17:45:19.360]             ...future.startTime <- base::Sys.time()
[17:45:19.360]             {
[17:45:19.360]                 {
[17:45:19.360]                   {
[17:45:19.360]                     {
[17:45:19.360]                       {
[17:45:19.360]                         base::local({
[17:45:19.360]                           has_future <- base::requireNamespace("future", 
[17:45:19.360]                             quietly = TRUE)
[17:45:19.360]                           if (has_future) {
[17:45:19.360]                             ns <- base::getNamespace("future")
[17:45:19.360]                             version <- ns[[".package"]][["version"]]
[17:45:19.360]                             if (is.null(version)) 
[17:45:19.360]                               version <- utils::packageVersion("future")
[17:45:19.360]                           }
[17:45:19.360]                           else {
[17:45:19.360]                             version <- NULL
[17:45:19.360]                           }
[17:45:19.360]                           if (!has_future || version < "1.8.0") {
[17:45:19.360]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.360]                               "", base::R.version$version.string), 
[17:45:19.360]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.360]                                 base::R.version$platform, 8 * 
[17:45:19.360]                                   base::.Machine$sizeof.pointer), 
[17:45:19.360]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.360]                                 "release", "version")], collapse = " "), 
[17:45:19.360]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.360]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.360]                               info)
[17:45:19.360]                             info <- base::paste(info, collapse = "; ")
[17:45:19.360]                             if (!has_future) {
[17:45:19.360]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.360]                                 info)
[17:45:19.360]                             }
[17:45:19.360]                             else {
[17:45:19.360]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.360]                                 info, version)
[17:45:19.360]                             }
[17:45:19.360]                             base::stop(msg)
[17:45:19.360]                           }
[17:45:19.360]                         })
[17:45:19.360]                       }
[17:45:19.360]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.360]                       base::options(mc.cores = 1L)
[17:45:19.360]                     }
[17:45:19.360]                     base::local({
[17:45:19.360]                       for (pkg in c("stats", "future.apply")) {
[17:45:19.360]                         base::loadNamespace(pkg)
[17:45:19.360]                         base::library(pkg, character.only = TRUE)
[17:45:19.360]                       }
[17:45:19.360]                     })
[17:45:19.360]                   }
[17:45:19.360]                   ...future.strategy.old <- future::plan("list")
[17:45:19.360]                   options(future.plan = NULL)
[17:45:19.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.360]                 }
[17:45:19.360]                 ...future.workdir <- getwd()
[17:45:19.360]             }
[17:45:19.360]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.360]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.360]         }
[17:45:19.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.360]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.360]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.360]             base::names(...future.oldOptions))
[17:45:19.360]     }
[17:45:19.360]     if (FALSE) {
[17:45:19.360]     }
[17:45:19.360]     else {
[17:45:19.360]         if (TRUE) {
[17:45:19.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.360]                 open = "w")
[17:45:19.360]         }
[17:45:19.360]         else {
[17:45:19.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.360]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.360]         }
[17:45:19.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.360]             base::sink(type = "output", split = FALSE)
[17:45:19.360]             base::close(...future.stdout)
[17:45:19.360]         }, add = TRUE)
[17:45:19.360]     }
[17:45:19.360]     ...future.frame <- base::sys.nframe()
[17:45:19.360]     ...future.conditions <- base::list()
[17:45:19.360]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.360]     if (FALSE) {
[17:45:19.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.360]     }
[17:45:19.360]     ...future.result <- base::tryCatch({
[17:45:19.360]         base::withCallingHandlers({
[17:45:19.360]             ...future.value <- base::withVisible(base::local({
[17:45:19.360]                 withCallingHandlers({
[17:45:19.360]                   {
[17:45:19.360]                     do.call(function(...) {
[17:45:19.360]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.360]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.360]                         ...future.globals.maxSize)) {
[17:45:19.360]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.360]                         on.exit(options(oopts), add = TRUE)
[17:45:19.360]                       }
[17:45:19.360]                       {
[17:45:19.360]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.360]                           FUN = function(jj) {
[17:45:19.360]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.360]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.360]                           })
[17:45:19.360]                       }
[17:45:19.360]                     }, args = future.call.arguments)
[17:45:19.360]                   }
[17:45:19.360]                 }, immediateCondition = function(cond) {
[17:45:19.360]                   save_rds <- function (object, pathname, ...) 
[17:45:19.360]                   {
[17:45:19.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.360]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.360]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.360]                         fi_tmp[["mtime"]])
[17:45:19.360]                     }
[17:45:19.360]                     tryCatch({
[17:45:19.360]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.360]                     }, error = function(ex) {
[17:45:19.360]                       msg <- conditionMessage(ex)
[17:45:19.360]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.360]                         fi_tmp[["mtime"]], msg)
[17:45:19.360]                       ex$message <- msg
[17:45:19.360]                       stop(ex)
[17:45:19.360]                     })
[17:45:19.360]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.360]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.360]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.360]                       fi <- file.info(pathname)
[17:45:19.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.360]                         fi[["size"]], fi[["mtime"]])
[17:45:19.360]                       stop(msg)
[17:45:19.360]                     }
[17:45:19.360]                     invisible(pathname)
[17:45:19.360]                   }
[17:45:19.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.360]                     rootPath = tempdir()) 
[17:45:19.360]                   {
[17:45:19.360]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.360]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.360]                       tmpdir = path, fileext = ".rds")
[17:45:19.360]                     save_rds(obj, file)
[17:45:19.360]                   }
[17:45:19.360]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.360]                   {
[17:45:19.360]                     inherits <- base::inherits
[17:45:19.360]                     invokeRestart <- base::invokeRestart
[17:45:19.360]                     is.null <- base::is.null
[17:45:19.360]                     muffled <- FALSE
[17:45:19.360]                     if (inherits(cond, "message")) {
[17:45:19.360]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.360]                       if (muffled) 
[17:45:19.360]                         invokeRestart("muffleMessage")
[17:45:19.360]                     }
[17:45:19.360]                     else if (inherits(cond, "warning")) {
[17:45:19.360]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.360]                       if (muffled) 
[17:45:19.360]                         invokeRestart("muffleWarning")
[17:45:19.360]                     }
[17:45:19.360]                     else if (inherits(cond, "condition")) {
[17:45:19.360]                       if (!is.null(pattern)) {
[17:45:19.360]                         computeRestarts <- base::computeRestarts
[17:45:19.360]                         grepl <- base::grepl
[17:45:19.360]                         restarts <- computeRestarts(cond)
[17:45:19.360]                         for (restart in restarts) {
[17:45:19.360]                           name <- restart$name
[17:45:19.360]                           if (is.null(name)) 
[17:45:19.360]                             next
[17:45:19.360]                           if (!grepl(pattern, name)) 
[17:45:19.360]                             next
[17:45:19.360]                           invokeRestart(restart)
[17:45:19.360]                           muffled <- TRUE
[17:45:19.360]                           break
[17:45:19.360]                         }
[17:45:19.360]                       }
[17:45:19.360]                     }
[17:45:19.360]                     invisible(muffled)
[17:45:19.360]                   }
[17:45:19.360]                   muffleCondition(cond)
[17:45:19.360]                 })
[17:45:19.360]             }))
[17:45:19.360]             future::FutureResult(value = ...future.value$value, 
[17:45:19.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.360]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.360]                     ...future.globalenv.names))
[17:45:19.360]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.360]         }, condition = base::local({
[17:45:19.360]             c <- base::c
[17:45:19.360]             inherits <- base::inherits
[17:45:19.360]             invokeRestart <- base::invokeRestart
[17:45:19.360]             length <- base::length
[17:45:19.360]             list <- base::list
[17:45:19.360]             seq.int <- base::seq.int
[17:45:19.360]             signalCondition <- base::signalCondition
[17:45:19.360]             sys.calls <- base::sys.calls
[17:45:19.360]             `[[` <- base::`[[`
[17:45:19.360]             `+` <- base::`+`
[17:45:19.360]             `<<-` <- base::`<<-`
[17:45:19.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.360]                   3L)]
[17:45:19.360]             }
[17:45:19.360]             function(cond) {
[17:45:19.360]                 is_error <- inherits(cond, "error")
[17:45:19.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.360]                   NULL)
[17:45:19.360]                 if (is_error) {
[17:45:19.360]                   sessionInformation <- function() {
[17:45:19.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.360]                       search = base::search(), system = base::Sys.info())
[17:45:19.360]                   }
[17:45:19.360]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.360]                     cond$call), session = sessionInformation(), 
[17:45:19.360]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.360]                   signalCondition(cond)
[17:45:19.360]                 }
[17:45:19.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.360]                 "immediateCondition"))) {
[17:45:19.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.360]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.360]                   if (TRUE && !signal) {
[17:45:19.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.360]                     {
[17:45:19.360]                       inherits <- base::inherits
[17:45:19.360]                       invokeRestart <- base::invokeRestart
[17:45:19.360]                       is.null <- base::is.null
[17:45:19.360]                       muffled <- FALSE
[17:45:19.360]                       if (inherits(cond, "message")) {
[17:45:19.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.360]                         if (muffled) 
[17:45:19.360]                           invokeRestart("muffleMessage")
[17:45:19.360]                       }
[17:45:19.360]                       else if (inherits(cond, "warning")) {
[17:45:19.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.360]                         if (muffled) 
[17:45:19.360]                           invokeRestart("muffleWarning")
[17:45:19.360]                       }
[17:45:19.360]                       else if (inherits(cond, "condition")) {
[17:45:19.360]                         if (!is.null(pattern)) {
[17:45:19.360]                           computeRestarts <- base::computeRestarts
[17:45:19.360]                           grepl <- base::grepl
[17:45:19.360]                           restarts <- computeRestarts(cond)
[17:45:19.360]                           for (restart in restarts) {
[17:45:19.360]                             name <- restart$name
[17:45:19.360]                             if (is.null(name)) 
[17:45:19.360]                               next
[17:45:19.360]                             if (!grepl(pattern, name)) 
[17:45:19.360]                               next
[17:45:19.360]                             invokeRestart(restart)
[17:45:19.360]                             muffled <- TRUE
[17:45:19.360]                             break
[17:45:19.360]                           }
[17:45:19.360]                         }
[17:45:19.360]                       }
[17:45:19.360]                       invisible(muffled)
[17:45:19.360]                     }
[17:45:19.360]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.360]                   }
[17:45:19.360]                 }
[17:45:19.360]                 else {
[17:45:19.360]                   if (TRUE) {
[17:45:19.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.360]                     {
[17:45:19.360]                       inherits <- base::inherits
[17:45:19.360]                       invokeRestart <- base::invokeRestart
[17:45:19.360]                       is.null <- base::is.null
[17:45:19.360]                       muffled <- FALSE
[17:45:19.360]                       if (inherits(cond, "message")) {
[17:45:19.360]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.360]                         if (muffled) 
[17:45:19.360]                           invokeRestart("muffleMessage")
[17:45:19.360]                       }
[17:45:19.360]                       else if (inherits(cond, "warning")) {
[17:45:19.360]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.360]                         if (muffled) 
[17:45:19.360]                           invokeRestart("muffleWarning")
[17:45:19.360]                       }
[17:45:19.360]                       else if (inherits(cond, "condition")) {
[17:45:19.360]                         if (!is.null(pattern)) {
[17:45:19.360]                           computeRestarts <- base::computeRestarts
[17:45:19.360]                           grepl <- base::grepl
[17:45:19.360]                           restarts <- computeRestarts(cond)
[17:45:19.360]                           for (restart in restarts) {
[17:45:19.360]                             name <- restart$name
[17:45:19.360]                             if (is.null(name)) 
[17:45:19.360]                               next
[17:45:19.360]                             if (!grepl(pattern, name)) 
[17:45:19.360]                               next
[17:45:19.360]                             invokeRestart(restart)
[17:45:19.360]                             muffled <- TRUE
[17:45:19.360]                             break
[17:45:19.360]                           }
[17:45:19.360]                         }
[17:45:19.360]                       }
[17:45:19.360]                       invisible(muffled)
[17:45:19.360]                     }
[17:45:19.360]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.360]                   }
[17:45:19.360]                 }
[17:45:19.360]             }
[17:45:19.360]         }))
[17:45:19.360]     }, error = function(ex) {
[17:45:19.360]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.360]                 ...future.rng), started = ...future.startTime, 
[17:45:19.360]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.360]             version = "1.8"), class = "FutureResult")
[17:45:19.360]     }, finally = {
[17:45:19.360]         if (!identical(...future.workdir, getwd())) 
[17:45:19.360]             setwd(...future.workdir)
[17:45:19.360]         {
[17:45:19.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.360]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.360]             }
[17:45:19.360]             base::options(...future.oldOptions)
[17:45:19.360]             if (.Platform$OS.type == "windows") {
[17:45:19.360]                 old_names <- names(...future.oldEnvVars)
[17:45:19.360]                 envs <- base::Sys.getenv()
[17:45:19.360]                 names <- names(envs)
[17:45:19.360]                 common <- intersect(names, old_names)
[17:45:19.360]                 added <- setdiff(names, old_names)
[17:45:19.360]                 removed <- setdiff(old_names, names)
[17:45:19.360]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.360]                   envs[common]]
[17:45:19.360]                 NAMES <- toupper(changed)
[17:45:19.360]                 args <- list()
[17:45:19.360]                 for (kk in seq_along(NAMES)) {
[17:45:19.360]                   name <- changed[[kk]]
[17:45:19.360]                   NAME <- NAMES[[kk]]
[17:45:19.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.360]                     next
[17:45:19.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.360]                 }
[17:45:19.360]                 NAMES <- toupper(added)
[17:45:19.360]                 for (kk in seq_along(NAMES)) {
[17:45:19.360]                   name <- added[[kk]]
[17:45:19.360]                   NAME <- NAMES[[kk]]
[17:45:19.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.360]                     next
[17:45:19.360]                   args[[name]] <- ""
[17:45:19.360]                 }
[17:45:19.360]                 NAMES <- toupper(removed)
[17:45:19.360]                 for (kk in seq_along(NAMES)) {
[17:45:19.360]                   name <- removed[[kk]]
[17:45:19.360]                   NAME <- NAMES[[kk]]
[17:45:19.360]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.360]                     next
[17:45:19.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.360]                 }
[17:45:19.360]                 if (length(args) > 0) 
[17:45:19.360]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.360]             }
[17:45:19.360]             else {
[17:45:19.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.360]             }
[17:45:19.360]             {
[17:45:19.360]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.360]                   0L) {
[17:45:19.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.360]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.360]                   base::options(opts)
[17:45:19.360]                 }
[17:45:19.360]                 {
[17:45:19.360]                   {
[17:45:19.360]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.360]                     NULL
[17:45:19.360]                   }
[17:45:19.360]                   options(future.plan = NULL)
[17:45:19.360]                   if (is.na(NA_character_)) 
[17:45:19.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.360]                     .init = FALSE)
[17:45:19.360]                 }
[17:45:19.360]             }
[17:45:19.360]         }
[17:45:19.360]     })
[17:45:19.360]     if (TRUE) {
[17:45:19.360]         base::sink(type = "output", split = FALSE)
[17:45:19.360]         if (TRUE) {
[17:45:19.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.360]         }
[17:45:19.360]         else {
[17:45:19.360]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.360]         }
[17:45:19.360]         base::close(...future.stdout)
[17:45:19.360]         ...future.stdout <- NULL
[17:45:19.360]     }
[17:45:19.360]     ...future.result$conditions <- ...future.conditions
[17:45:19.360]     ...future.result$finished <- base::Sys.time()
[17:45:19.360]     ...future.result
[17:45:19.360] }
[17:45:19.362] assign_globals() ...
[17:45:19.362] List of 11
[17:45:19.362]  $ ...future.FUN            :function (x, ...)  
[17:45:19.362]  $ x_FUN                    :function (x, ...)  
[17:45:19.362]  $ times                    : int 5
[17:45:19.362]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.362]  $ stop_if_not              :function (...)  
[17:45:19.362]  $ dim                      : NULL
[17:45:19.362]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.362]  $ future.call.arguments    : list()
[17:45:19.362]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.362]  $ ...future.elements_ii    :List of 1
[17:45:19.362]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[17:45:19.362]  $ ...future.seeds_ii       : NULL
[17:45:19.362]  $ ...future.globals.maxSize: NULL
[17:45:19.362]  - attr(*, "where")=List of 11
[17:45:19.362]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.362]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.362]  - attr(*, "resolved")= logi FALSE
[17:45:19.362]  - attr(*, "total_size")= num 95528
[17:45:19.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.362]  - attr(*, "already-done")= logi TRUE
[17:45:19.370] - copied ‘...future.FUN’ to environment
[17:45:19.370] - copied ‘x_FUN’ to environment
[17:45:19.370] - copied ‘times’ to environment
[17:45:19.370] - copied ‘stopf’ to environment
[17:45:19.370] - copied ‘stop_if_not’ to environment
[17:45:19.370] - copied ‘dim’ to environment
[17:45:19.370] - copied ‘valid_types’ to environment
[17:45:19.371] - copied ‘future.call.arguments’ to environment
[17:45:19.371] - copied ‘...future.elements_ii’ to environment
[17:45:19.371] - copied ‘...future.seeds_ii’ to environment
[17:45:19.371] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.371] assign_globals() ... done
[17:45:19.371] requestCore(): workers = 2
[17:45:19.373] MulticoreFuture started
[17:45:19.374] - Launch lazy future ... done
[17:45:19.374] run() for ‘MulticoreFuture’ ... done
[17:45:19.374] Created future:
[17:45:19.375] plan(): Setting new future strategy stack:
[17:45:19.375] List of future strategies:
[17:45:19.375] 1. sequential:
[17:45:19.375]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.375]    - tweaked: FALSE
[17:45:19.375]    - call: NULL
[17:45:19.376] plan(): nbrOfWorkers() = 1
[17:45:19.379] plan(): Setting new future strategy stack:
[17:45:19.379] List of future strategies:
[17:45:19.379] 1. multicore:
[17:45:19.379]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.379]    - tweaked: FALSE
[17:45:19.379]    - call: plan(strategy)
[17:45:19.374] MulticoreFuture:
[17:45:19.374] Label: ‘future_vapply-1’
[17:45:19.374] Expression:
[17:45:19.374] {
[17:45:19.374]     do.call(function(...) {
[17:45:19.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.374]             on.exit(options(oopts), add = TRUE)
[17:45:19.374]         }
[17:45:19.374]         {
[17:45:19.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.374]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.374]             })
[17:45:19.374]         }
[17:45:19.374]     }, args = future.call.arguments)
[17:45:19.374] }
[17:45:19.374] Lazy evaluation: FALSE
[17:45:19.374] Asynchronous evaluation: TRUE
[17:45:19.374] Local evaluation: TRUE
[17:45:19.374] Environment: R_GlobalEnv
[17:45:19.374] Capture standard output: TRUE
[17:45:19.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.374] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.374] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:19.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.374] Resolved: FALSE
[17:45:19.374] Value: <not collected>
[17:45:19.374] Conditions captured: <none>
[17:45:19.374] Early signaling: FALSE
[17:45:19.374] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.374] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.388] Chunk #1 of 2 ... DONE
[17:45:19.388] Chunk #2 of 2 ...
[17:45:19.388]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.388] getGlobalsAndPackages() ...
[17:45:19.389] Searching for globals...
[17:45:19.389] 
[17:45:19.390] Searching for globals ... DONE
[17:45:19.391] plan(): nbrOfWorkers() = 2
[17:45:19.390] - globals: [0] <none>
[17:45:19.393] getGlobalsAndPackages() ... DONE
[17:45:19.393]    + additional globals found: [n=0] 
[17:45:19.394]    + additional namespaces needed: [n=0] 
[17:45:19.394]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.394]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.394]  - seeds: <none>
[17:45:19.395]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.395] getGlobalsAndPackages() ...
[17:45:19.395] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.395] Resolving globals: FALSE
[17:45:19.396] Tweak future expression to call with '...' arguments ...
[17:45:19.396] {
[17:45:19.396]     do.call(function(...) {
[17:45:19.396]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.396]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.396]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.396]             on.exit(options(oopts), add = TRUE)
[17:45:19.396]         }
[17:45:19.396]         {
[17:45:19.396]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.396]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.396]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.396]             })
[17:45:19.396]         }
[17:45:19.396]     }, args = future.call.arguments)
[17:45:19.396] }
[17:45:19.397] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.398] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.399] - packages: [2] ‘stats’, ‘future.apply’
[17:45:19.399] getGlobalsAndPackages() ... DONE
[17:45:19.400] run() for ‘Future’ ...
[17:45:19.400] - state: ‘created’
[17:45:19.400] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.407]   - Field: ‘label’
[17:45:19.407]   - Field: ‘local’
[17:45:19.407]   - Field: ‘owner’
[17:45:19.407]   - Field: ‘envir’
[17:45:19.408]   - Field: ‘workers’
[17:45:19.408]   - Field: ‘packages’
[17:45:19.408]   - Field: ‘gc’
[17:45:19.408]   - Field: ‘job’
[17:45:19.408]   - Field: ‘conditions’
[17:45:19.408]   - Field: ‘expr’
[17:45:19.409]   - Field: ‘uuid’
[17:45:19.409]   - Field: ‘seed’
[17:45:19.409]   - Field: ‘version’
[17:45:19.409]   - Field: ‘result’
[17:45:19.409]   - Field: ‘asynchronous’
[17:45:19.409]   - Field: ‘calls’
[17:45:19.409]   - Field: ‘globals’
[17:45:19.410]   - Field: ‘stdout’
[17:45:19.410]   - Field: ‘earlySignal’
[17:45:19.410]   - Field: ‘lazy’
[17:45:19.410]   - Field: ‘state’
[17:45:19.410] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.410] - Launch lazy future ...
[17:45:19.411] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:19.411] Packages needed by future strategies (n = 0): <none>
[17:45:19.412] {
[17:45:19.412]     {
[17:45:19.412]         {
[17:45:19.412]             ...future.startTime <- base::Sys.time()
[17:45:19.412]             {
[17:45:19.412]                 {
[17:45:19.412]                   {
[17:45:19.412]                     {
[17:45:19.412]                       {
[17:45:19.412]                         base::local({
[17:45:19.412]                           has_future <- base::requireNamespace("future", 
[17:45:19.412]                             quietly = TRUE)
[17:45:19.412]                           if (has_future) {
[17:45:19.412]                             ns <- base::getNamespace("future")
[17:45:19.412]                             version <- ns[[".package"]][["version"]]
[17:45:19.412]                             if (is.null(version)) 
[17:45:19.412]                               version <- utils::packageVersion("future")
[17:45:19.412]                           }
[17:45:19.412]                           else {
[17:45:19.412]                             version <- NULL
[17:45:19.412]                           }
[17:45:19.412]                           if (!has_future || version < "1.8.0") {
[17:45:19.412]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.412]                               "", base::R.version$version.string), 
[17:45:19.412]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.412]                                 base::R.version$platform, 8 * 
[17:45:19.412]                                   base::.Machine$sizeof.pointer), 
[17:45:19.412]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.412]                                 "release", "version")], collapse = " "), 
[17:45:19.412]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.412]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.412]                               info)
[17:45:19.412]                             info <- base::paste(info, collapse = "; ")
[17:45:19.412]                             if (!has_future) {
[17:45:19.412]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.412]                                 info)
[17:45:19.412]                             }
[17:45:19.412]                             else {
[17:45:19.412]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.412]                                 info, version)
[17:45:19.412]                             }
[17:45:19.412]                             base::stop(msg)
[17:45:19.412]                           }
[17:45:19.412]                         })
[17:45:19.412]                       }
[17:45:19.412]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.412]                       base::options(mc.cores = 1L)
[17:45:19.412]                     }
[17:45:19.412]                     base::local({
[17:45:19.412]                       for (pkg in c("stats", "future.apply")) {
[17:45:19.412]                         base::loadNamespace(pkg)
[17:45:19.412]                         base::library(pkg, character.only = TRUE)
[17:45:19.412]                       }
[17:45:19.412]                     })
[17:45:19.412]                   }
[17:45:19.412]                   ...future.strategy.old <- future::plan("list")
[17:45:19.412]                   options(future.plan = NULL)
[17:45:19.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.412]                 }
[17:45:19.412]                 ...future.workdir <- getwd()
[17:45:19.412]             }
[17:45:19.412]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.412]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.412]         }
[17:45:19.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.412]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.412]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.412]             base::names(...future.oldOptions))
[17:45:19.412]     }
[17:45:19.412]     if (FALSE) {
[17:45:19.412]     }
[17:45:19.412]     else {
[17:45:19.412]         if (TRUE) {
[17:45:19.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.412]                 open = "w")
[17:45:19.412]         }
[17:45:19.412]         else {
[17:45:19.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.412]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.412]         }
[17:45:19.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.412]             base::sink(type = "output", split = FALSE)
[17:45:19.412]             base::close(...future.stdout)
[17:45:19.412]         }, add = TRUE)
[17:45:19.412]     }
[17:45:19.412]     ...future.frame <- base::sys.nframe()
[17:45:19.412]     ...future.conditions <- base::list()
[17:45:19.412]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.412]     if (FALSE) {
[17:45:19.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.412]     }
[17:45:19.412]     ...future.result <- base::tryCatch({
[17:45:19.412]         base::withCallingHandlers({
[17:45:19.412]             ...future.value <- base::withVisible(base::local({
[17:45:19.412]                 withCallingHandlers({
[17:45:19.412]                   {
[17:45:19.412]                     do.call(function(...) {
[17:45:19.412]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.412]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.412]                         ...future.globals.maxSize)) {
[17:45:19.412]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.412]                         on.exit(options(oopts), add = TRUE)
[17:45:19.412]                       }
[17:45:19.412]                       {
[17:45:19.412]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.412]                           FUN = function(jj) {
[17:45:19.412]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.412]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.412]                           })
[17:45:19.412]                       }
[17:45:19.412]                     }, args = future.call.arguments)
[17:45:19.412]                   }
[17:45:19.412]                 }, immediateCondition = function(cond) {
[17:45:19.412]                   save_rds <- function (object, pathname, ...) 
[17:45:19.412]                   {
[17:45:19.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.412]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.412]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.412]                         fi_tmp[["mtime"]])
[17:45:19.412]                     }
[17:45:19.412]                     tryCatch({
[17:45:19.412]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.412]                     }, error = function(ex) {
[17:45:19.412]                       msg <- conditionMessage(ex)
[17:45:19.412]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.412]                         fi_tmp[["mtime"]], msg)
[17:45:19.412]                       ex$message <- msg
[17:45:19.412]                       stop(ex)
[17:45:19.412]                     })
[17:45:19.412]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.412]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.412]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.412]                       fi <- file.info(pathname)
[17:45:19.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.412]                         fi[["size"]], fi[["mtime"]])
[17:45:19.412]                       stop(msg)
[17:45:19.412]                     }
[17:45:19.412]                     invisible(pathname)
[17:45:19.412]                   }
[17:45:19.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.412]                     rootPath = tempdir()) 
[17:45:19.412]                   {
[17:45:19.412]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.412]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.412]                       tmpdir = path, fileext = ".rds")
[17:45:19.412]                     save_rds(obj, file)
[17:45:19.412]                   }
[17:45:19.412]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.412]                   {
[17:45:19.412]                     inherits <- base::inherits
[17:45:19.412]                     invokeRestart <- base::invokeRestart
[17:45:19.412]                     is.null <- base::is.null
[17:45:19.412]                     muffled <- FALSE
[17:45:19.412]                     if (inherits(cond, "message")) {
[17:45:19.412]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.412]                       if (muffled) 
[17:45:19.412]                         invokeRestart("muffleMessage")
[17:45:19.412]                     }
[17:45:19.412]                     else if (inherits(cond, "warning")) {
[17:45:19.412]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.412]                       if (muffled) 
[17:45:19.412]                         invokeRestart("muffleWarning")
[17:45:19.412]                     }
[17:45:19.412]                     else if (inherits(cond, "condition")) {
[17:45:19.412]                       if (!is.null(pattern)) {
[17:45:19.412]                         computeRestarts <- base::computeRestarts
[17:45:19.412]                         grepl <- base::grepl
[17:45:19.412]                         restarts <- computeRestarts(cond)
[17:45:19.412]                         for (restart in restarts) {
[17:45:19.412]                           name <- restart$name
[17:45:19.412]                           if (is.null(name)) 
[17:45:19.412]                             next
[17:45:19.412]                           if (!grepl(pattern, name)) 
[17:45:19.412]                             next
[17:45:19.412]                           invokeRestart(restart)
[17:45:19.412]                           muffled <- TRUE
[17:45:19.412]                           break
[17:45:19.412]                         }
[17:45:19.412]                       }
[17:45:19.412]                     }
[17:45:19.412]                     invisible(muffled)
[17:45:19.412]                   }
[17:45:19.412]                   muffleCondition(cond)
[17:45:19.412]                 })
[17:45:19.412]             }))
[17:45:19.412]             future::FutureResult(value = ...future.value$value, 
[17:45:19.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.412]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.412]                     ...future.globalenv.names))
[17:45:19.412]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.412]         }, condition = base::local({
[17:45:19.412]             c <- base::c
[17:45:19.412]             inherits <- base::inherits
[17:45:19.412]             invokeRestart <- base::invokeRestart
[17:45:19.412]             length <- base::length
[17:45:19.412]             list <- base::list
[17:45:19.412]             seq.int <- base::seq.int
[17:45:19.412]             signalCondition <- base::signalCondition
[17:45:19.412]             sys.calls <- base::sys.calls
[17:45:19.412]             `[[` <- base::`[[`
[17:45:19.412]             `+` <- base::`+`
[17:45:19.412]             `<<-` <- base::`<<-`
[17:45:19.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.412]                   3L)]
[17:45:19.412]             }
[17:45:19.412]             function(cond) {
[17:45:19.412]                 is_error <- inherits(cond, "error")
[17:45:19.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.412]                   NULL)
[17:45:19.412]                 if (is_error) {
[17:45:19.412]                   sessionInformation <- function() {
[17:45:19.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.412]                       search = base::search(), system = base::Sys.info())
[17:45:19.412]                   }
[17:45:19.412]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.412]                     cond$call), session = sessionInformation(), 
[17:45:19.412]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.412]                   signalCondition(cond)
[17:45:19.412]                 }
[17:45:19.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.412]                 "immediateCondition"))) {
[17:45:19.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.412]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.412]                   if (TRUE && !signal) {
[17:45:19.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.412]                     {
[17:45:19.412]                       inherits <- base::inherits
[17:45:19.412]                       invokeRestart <- base::invokeRestart
[17:45:19.412]                       is.null <- base::is.null
[17:45:19.412]                       muffled <- FALSE
[17:45:19.412]                       if (inherits(cond, "message")) {
[17:45:19.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.412]                         if (muffled) 
[17:45:19.412]                           invokeRestart("muffleMessage")
[17:45:19.412]                       }
[17:45:19.412]                       else if (inherits(cond, "warning")) {
[17:45:19.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.412]                         if (muffled) 
[17:45:19.412]                           invokeRestart("muffleWarning")
[17:45:19.412]                       }
[17:45:19.412]                       else if (inherits(cond, "condition")) {
[17:45:19.412]                         if (!is.null(pattern)) {
[17:45:19.412]                           computeRestarts <- base::computeRestarts
[17:45:19.412]                           grepl <- base::grepl
[17:45:19.412]                           restarts <- computeRestarts(cond)
[17:45:19.412]                           for (restart in restarts) {
[17:45:19.412]                             name <- restart$name
[17:45:19.412]                             if (is.null(name)) 
[17:45:19.412]                               next
[17:45:19.412]                             if (!grepl(pattern, name)) 
[17:45:19.412]                               next
[17:45:19.412]                             invokeRestart(restart)
[17:45:19.412]                             muffled <- TRUE
[17:45:19.412]                             break
[17:45:19.412]                           }
[17:45:19.412]                         }
[17:45:19.412]                       }
[17:45:19.412]                       invisible(muffled)
[17:45:19.412]                     }
[17:45:19.412]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.412]                   }
[17:45:19.412]                 }
[17:45:19.412]                 else {
[17:45:19.412]                   if (TRUE) {
[17:45:19.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.412]                     {
[17:45:19.412]                       inherits <- base::inherits
[17:45:19.412]                       invokeRestart <- base::invokeRestart
[17:45:19.412]                       is.null <- base::is.null
[17:45:19.412]                       muffled <- FALSE
[17:45:19.412]                       if (inherits(cond, "message")) {
[17:45:19.412]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.412]                         if (muffled) 
[17:45:19.412]                           invokeRestart("muffleMessage")
[17:45:19.412]                       }
[17:45:19.412]                       else if (inherits(cond, "warning")) {
[17:45:19.412]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.412]                         if (muffled) 
[17:45:19.412]                           invokeRestart("muffleWarning")
[17:45:19.412]                       }
[17:45:19.412]                       else if (inherits(cond, "condition")) {
[17:45:19.412]                         if (!is.null(pattern)) {
[17:45:19.412]                           computeRestarts <- base::computeRestarts
[17:45:19.412]                           grepl <- base::grepl
[17:45:19.412]                           restarts <- computeRestarts(cond)
[17:45:19.412]                           for (restart in restarts) {
[17:45:19.412]                             name <- restart$name
[17:45:19.412]                             if (is.null(name)) 
[17:45:19.412]                               next
[17:45:19.412]                             if (!grepl(pattern, name)) 
[17:45:19.412]                               next
[17:45:19.412]                             invokeRestart(restart)
[17:45:19.412]                             muffled <- TRUE
[17:45:19.412]                             break
[17:45:19.412]                           }
[17:45:19.412]                         }
[17:45:19.412]                       }
[17:45:19.412]                       invisible(muffled)
[17:45:19.412]                     }
[17:45:19.412]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.412]                   }
[17:45:19.412]                 }
[17:45:19.412]             }
[17:45:19.412]         }))
[17:45:19.412]     }, error = function(ex) {
[17:45:19.412]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.412]                 ...future.rng), started = ...future.startTime, 
[17:45:19.412]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.412]             version = "1.8"), class = "FutureResult")
[17:45:19.412]     }, finally = {
[17:45:19.412]         if (!identical(...future.workdir, getwd())) 
[17:45:19.412]             setwd(...future.workdir)
[17:45:19.412]         {
[17:45:19.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.412]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.412]             }
[17:45:19.412]             base::options(...future.oldOptions)
[17:45:19.412]             if (.Platform$OS.type == "windows") {
[17:45:19.412]                 old_names <- names(...future.oldEnvVars)
[17:45:19.412]                 envs <- base::Sys.getenv()
[17:45:19.412]                 names <- names(envs)
[17:45:19.412]                 common <- intersect(names, old_names)
[17:45:19.412]                 added <- setdiff(names, old_names)
[17:45:19.412]                 removed <- setdiff(old_names, names)
[17:45:19.412]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.412]                   envs[common]]
[17:45:19.412]                 NAMES <- toupper(changed)
[17:45:19.412]                 args <- list()
[17:45:19.412]                 for (kk in seq_along(NAMES)) {
[17:45:19.412]                   name <- changed[[kk]]
[17:45:19.412]                   NAME <- NAMES[[kk]]
[17:45:19.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.412]                     next
[17:45:19.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.412]                 }
[17:45:19.412]                 NAMES <- toupper(added)
[17:45:19.412]                 for (kk in seq_along(NAMES)) {
[17:45:19.412]                   name <- added[[kk]]
[17:45:19.412]                   NAME <- NAMES[[kk]]
[17:45:19.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.412]                     next
[17:45:19.412]                   args[[name]] <- ""
[17:45:19.412]                 }
[17:45:19.412]                 NAMES <- toupper(removed)
[17:45:19.412]                 for (kk in seq_along(NAMES)) {
[17:45:19.412]                   name <- removed[[kk]]
[17:45:19.412]                   NAME <- NAMES[[kk]]
[17:45:19.412]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.412]                     next
[17:45:19.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.412]                 }
[17:45:19.412]                 if (length(args) > 0) 
[17:45:19.412]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.412]             }
[17:45:19.412]             else {
[17:45:19.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.412]             }
[17:45:19.412]             {
[17:45:19.412]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.412]                   0L) {
[17:45:19.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.412]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.412]                   base::options(opts)
[17:45:19.412]                 }
[17:45:19.412]                 {
[17:45:19.412]                   {
[17:45:19.412]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.412]                     NULL
[17:45:19.412]                   }
[17:45:19.412]                   options(future.plan = NULL)
[17:45:19.412]                   if (is.na(NA_character_)) 
[17:45:19.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.412]                     .init = FALSE)
[17:45:19.412]                 }
[17:45:19.412]             }
[17:45:19.412]         }
[17:45:19.412]     })
[17:45:19.412]     if (TRUE) {
[17:45:19.412]         base::sink(type = "output", split = FALSE)
[17:45:19.412]         if (TRUE) {
[17:45:19.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.412]         }
[17:45:19.412]         else {
[17:45:19.412]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.412]         }
[17:45:19.412]         base::close(...future.stdout)
[17:45:19.412]         ...future.stdout <- NULL
[17:45:19.412]     }
[17:45:19.412]     ...future.result$conditions <- ...future.conditions
[17:45:19.412]     ...future.result$finished <- base::Sys.time()
[17:45:19.412]     ...future.result
[17:45:19.412] }
[17:45:19.415] assign_globals() ...
[17:45:19.415] List of 11
[17:45:19.415]  $ ...future.FUN            :function (x, ...)  
[17:45:19.415]  $ x_FUN                    :function (x, ...)  
[17:45:19.415]  $ times                    : int 5
[17:45:19.415]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.415]  $ stop_if_not              :function (...)  
[17:45:19.415]  $ dim                      : NULL
[17:45:19.415]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.415]  $ future.call.arguments    : list()
[17:45:19.415]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.415]  $ ...future.elements_ii    :List of 2
[17:45:19.415]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[17:45:19.415]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[17:45:19.415]  $ ...future.seeds_ii       : NULL
[17:45:19.415]  $ ...future.globals.maxSize: NULL
[17:45:19.415]  - attr(*, "where")=List of 11
[17:45:19.415]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.415]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.415]  - attr(*, "resolved")= logi FALSE
[17:45:19.415]  - attr(*, "total_size")= num 95528
[17:45:19.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.415]  - attr(*, "already-done")= logi TRUE
[17:45:19.424] - copied ‘...future.FUN’ to environment
[17:45:19.424] - copied ‘x_FUN’ to environment
[17:45:19.424] - copied ‘times’ to environment
[17:45:19.424] - copied ‘stopf’ to environment
[17:45:19.425] - copied ‘stop_if_not’ to environment
[17:45:19.425] - copied ‘dim’ to environment
[17:45:19.425] - copied ‘valid_types’ to environment
[17:45:19.425] - copied ‘future.call.arguments’ to environment
[17:45:19.425] - copied ‘...future.elements_ii’ to environment
[17:45:19.425] - copied ‘...future.seeds_ii’ to environment
[17:45:19.425] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.425] assign_globals() ... done
[17:45:19.425] requestCore(): workers = 2
[17:45:19.428] MulticoreFuture started
[17:45:19.428] - Launch lazy future ... done
[17:45:19.428] run() for ‘MulticoreFuture’ ... done
[17:45:19.428] Created future:
[17:45:19.429] plan(): Setting new future strategy stack:
[17:45:19.429] List of future strategies:
[17:45:19.429] 1. sequential:
[17:45:19.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.429]    - tweaked: FALSE
[17:45:19.429]    - call: NULL
[17:45:19.430] plan(): nbrOfWorkers() = 1
[17:45:19.433] plan(): Setting new future strategy stack:
[17:45:19.433] List of future strategies:
[17:45:19.433] 1. multicore:
[17:45:19.433]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.433]    - tweaked: FALSE
[17:45:19.433]    - call: plan(strategy)
[17:45:19.429] MulticoreFuture:
[17:45:19.429] Label: ‘future_vapply-2’
[17:45:19.429] Expression:
[17:45:19.429] {
[17:45:19.429]     do.call(function(...) {
[17:45:19.429]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.429]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.429]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.429]             on.exit(options(oopts), add = TRUE)
[17:45:19.429]         }
[17:45:19.429]         {
[17:45:19.429]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.429]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.429]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.429]             })
[17:45:19.429]         }
[17:45:19.429]     }, args = future.call.arguments)
[17:45:19.429] }
[17:45:19.429] Lazy evaluation: FALSE
[17:45:19.429] Asynchronous evaluation: TRUE
[17:45:19.429] Local evaluation: TRUE
[17:45:19.429] Environment: R_GlobalEnv
[17:45:19.429] Capture standard output: TRUE
[17:45:19.429] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.429] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.429] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:19.429] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.429] Resolved: FALSE
[17:45:19.429] Value: <not collected>
[17:45:19.429] Conditions captured: <none>
[17:45:19.429] Early signaling: FALSE
[17:45:19.429] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.429] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.442] Chunk #2 of 2 ... DONE
[17:45:19.442] Launching 2 futures (chunks) ... DONE
[17:45:19.442] Resolving 2 futures (chunks) ...
[17:45:19.442] resolve() on list ...
[17:45:19.442]  recursive: 0
[17:45:19.443]  length: 2
[17:45:19.443] 
[17:45:19.443] Future #1
[17:45:19.443] result() for MulticoreFuture ...
[17:45:19.444] plan(): nbrOfWorkers() = 2
[17:45:19.447] result() for MulticoreFuture ...
[17:45:19.448] result() for MulticoreFuture ... done
[17:45:19.448] result() for MulticoreFuture ... done
[17:45:19.448] result() for MulticoreFuture ...
[17:45:19.448] result() for MulticoreFuture ... done
[17:45:19.448] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.449] - nx: 2
[17:45:19.449] - relay: TRUE
[17:45:19.449] - stdout: TRUE
[17:45:19.449] - signal: TRUE
[17:45:19.450] - resignal: FALSE
[17:45:19.450] - force: TRUE
[17:45:19.450] - relayed: [n=2] FALSE, FALSE
[17:45:19.450] - queued futures: [n=2] FALSE, FALSE
[17:45:19.451]  - until=1
[17:45:19.451]  - relaying element #1
[17:45:19.451] result() for MulticoreFuture ...
[17:45:19.452] result() for MulticoreFuture ... done
[17:45:19.452] result() for MulticoreFuture ...
[17:45:19.452] result() for MulticoreFuture ... done
[17:45:19.452] result() for MulticoreFuture ...
[17:45:19.453] result() for MulticoreFuture ... done
[17:45:19.453] result() for MulticoreFuture ...
[17:45:19.453] result() for MulticoreFuture ... done
[17:45:19.453] - relayed: [n=2] TRUE, FALSE
[17:45:19.454] - queued futures: [n=2] TRUE, FALSE
[17:45:19.454] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.454]  length: 1 (resolved future 1)
[17:45:19.454] Future #2
[17:45:19.455] result() for MulticoreFuture ...
[17:45:19.456] result() for MulticoreFuture ...
[17:45:19.456] result() for MulticoreFuture ... done
[17:45:19.456] result() for MulticoreFuture ... done
[17:45:19.456] result() for MulticoreFuture ...
[17:45:19.456] result() for MulticoreFuture ... done
[17:45:19.457] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.457] - nx: 2
[17:45:19.457] - relay: TRUE
[17:45:19.457] - stdout: TRUE
[17:45:19.457] - signal: TRUE
[17:45:19.457] - resignal: FALSE
[17:45:19.458] - force: TRUE
[17:45:19.458] - relayed: [n=2] TRUE, FALSE
[17:45:19.458] - queued futures: [n=2] TRUE, FALSE
[17:45:19.458]  - until=2
[17:45:19.458]  - relaying element #2
[17:45:19.458] result() for MulticoreFuture ...
[17:45:19.458] result() for MulticoreFuture ... done
[17:45:19.458] result() for MulticoreFuture ...
[17:45:19.459] result() for MulticoreFuture ... done
[17:45:19.459] result() for MulticoreFuture ...
[17:45:19.459] result() for MulticoreFuture ... done
[17:45:19.459] result() for MulticoreFuture ...
[17:45:19.459] result() for MulticoreFuture ... done
[17:45:19.459] - relayed: [n=2] TRUE, TRUE
[17:45:19.459] - queued futures: [n=2] TRUE, TRUE
[17:45:19.459] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.460]  length: 0 (resolved future 2)
[17:45:19.460] Relaying remaining futures
[17:45:19.460] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.460] - nx: 2
[17:45:19.460] - relay: TRUE
[17:45:19.460] - stdout: TRUE
[17:45:19.460] - signal: TRUE
[17:45:19.460] - resignal: FALSE
[17:45:19.460] - force: TRUE
[17:45:19.460] - relayed: [n=2] TRUE, TRUE
[17:45:19.460] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.461] - relayed: [n=2] TRUE, TRUE
[17:45:19.461] - queued futures: [n=2] TRUE, TRUE
[17:45:19.461] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.461] resolve() on list ... DONE
[17:45:19.461] result() for MulticoreFuture ...
[17:45:19.461] result() for MulticoreFuture ... done
[17:45:19.461] result() for MulticoreFuture ...
[17:45:19.461] result() for MulticoreFuture ... done
[17:45:19.462] result() for MulticoreFuture ...
[17:45:19.462] result() for MulticoreFuture ... done
[17:45:19.462] result() for MulticoreFuture ...
[17:45:19.462] result() for MulticoreFuture ... done
[17:45:19.462]  - Number of value chunks collected: 2
[17:45:19.462] Resolving 2 futures (chunks) ... DONE
[17:45:19.462] Reducing values from 2 chunks ...
[17:45:19.462]  - Number of values collected after concatenation: 3
[17:45:19.462]  - Number of values expected: 3
[17:45:19.462] Reducing values from 2 chunks ... DONE
[17:45:19.462] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:45:19.464] future_lapply() ...
[17:45:19.473] Number of chunks: 2
[17:45:19.473] getGlobalsAndPackagesXApply() ...
[17:45:19.473]  - future.globals: TRUE
[17:45:19.473] getGlobalsAndPackages() ...
[17:45:19.473] Searching for globals...
[17:45:19.481] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:45:19.481] Searching for globals ... DONE
[17:45:19.481] Resolving globals: FALSE
[17:45:19.482] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:45:19.482] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:45:19.482] - globals: [1] ‘FUN’
[17:45:19.482] - packages: [1] ‘stats’
[17:45:19.483] getGlobalsAndPackages() ... DONE
[17:45:19.483]  - globals found/used: [n=1] ‘FUN’
[17:45:19.483]  - needed namespaces: [n=1] ‘stats’
[17:45:19.483] Finding globals ... DONE
[17:45:19.483]  - use_args: TRUE
[17:45:19.483]  - Getting '...' globals ...
[17:45:19.483] resolve() on list ...
[17:45:19.483]  recursive: 0
[17:45:19.484]  length: 1
[17:45:19.484]  elements: ‘...’
[17:45:19.484]  length: 0 (resolved future 1)
[17:45:19.484] resolve() on list ... DONE
[17:45:19.484]    - '...' content: [n=0] 
[17:45:19.484] List of 1
[17:45:19.484]  $ ...: list()
[17:45:19.484]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.484]  - attr(*, "where")=List of 1
[17:45:19.484]   ..$ ...:<environment: 0x5561f3bc0d28> 
[17:45:19.484]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.484]  - attr(*, "resolved")= logi TRUE
[17:45:19.484]  - attr(*, "total_size")= num NA
[17:45:19.487]  - Getting '...' globals ... DONE
[17:45:19.487] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:19.487] List of 2
[17:45:19.487]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:45:19.487]  $ ...          : list()
[17:45:19.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.487]  - attr(*, "where")=List of 2
[17:45:19.487]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.487]   ..$ ...          :<environment: 0x5561f3bc0d28> 
[17:45:19.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.487]  - attr(*, "resolved")= logi FALSE
[17:45:19.487]  - attr(*, "total_size")= num 46960
[17:45:19.489] Packages to be attached in all futures: [n=1] ‘stats’
[17:45:19.490] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.490] Number of futures (= number of chunks): 2
[17:45:19.490] Launching 2 futures (chunks) ...
[17:45:19.490] Chunk #1 of 2 ...
[17:45:19.490]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.490] getGlobalsAndPackages() ...
[17:45:19.490] Searching for globals...
[17:45:19.491] 
[17:45:19.491] Searching for globals ... DONE
[17:45:19.491] - globals: [0] <none>
[17:45:19.491] getGlobalsAndPackages() ... DONE
[17:45:19.491]    + additional globals found: [n=0] 
[17:45:19.491]    + additional namespaces needed: [n=0] 
[17:45:19.491]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.491]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.491]  - seeds: <none>
[17:45:19.491]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.492] getGlobalsAndPackages() ...
[17:45:19.492] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.492] Resolving globals: FALSE
[17:45:19.492] Tweak future expression to call with '...' arguments ...
[17:45:19.492] {
[17:45:19.492]     do.call(function(...) {
[17:45:19.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.492]             on.exit(options(oopts), add = TRUE)
[17:45:19.492]         }
[17:45:19.492]         {
[17:45:19.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.492]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.492]             })
[17:45:19.492]         }
[17:45:19.492]     }, args = future.call.arguments)
[17:45:19.492] }
[17:45:19.492] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.493] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.493] - packages: [1] ‘stats’
[17:45:19.493] getGlobalsAndPackages() ... DONE
[17:45:19.493] run() for ‘Future’ ...
[17:45:19.493] - state: ‘created’
[17:45:19.493] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.497] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.497]   - Field: ‘label’
[17:45:19.497]   - Field: ‘local’
[17:45:19.498]   - Field: ‘owner’
[17:45:19.498]   - Field: ‘envir’
[17:45:19.498]   - Field: ‘workers’
[17:45:19.498]   - Field: ‘packages’
[17:45:19.498]   - Field: ‘gc’
[17:45:19.498]   - Field: ‘job’
[17:45:19.498]   - Field: ‘conditions’
[17:45:19.498]   - Field: ‘expr’
[17:45:19.498]   - Field: ‘uuid’
[17:45:19.498]   - Field: ‘seed’
[17:45:19.498]   - Field: ‘version’
[17:45:19.499]   - Field: ‘result’
[17:45:19.499]   - Field: ‘asynchronous’
[17:45:19.499]   - Field: ‘calls’
[17:45:19.499]   - Field: ‘globals’
[17:45:19.499]   - Field: ‘stdout’
[17:45:19.499]   - Field: ‘earlySignal’
[17:45:19.499]   - Field: ‘lazy’
[17:45:19.499]   - Field: ‘state’
[17:45:19.499] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.499] - Launch lazy future ...
[17:45:19.500] Packages needed by the future expression (n = 1): ‘stats’
[17:45:19.500] Packages needed by future strategies (n = 0): <none>
[17:45:19.502] {
[17:45:19.502]     {
[17:45:19.502]         {
[17:45:19.502]             ...future.startTime <- base::Sys.time()
[17:45:19.502]             {
[17:45:19.502]                 {
[17:45:19.502]                   {
[17:45:19.502]                     {
[17:45:19.502]                       {
[17:45:19.502]                         base::local({
[17:45:19.502]                           has_future <- base::requireNamespace("future", 
[17:45:19.502]                             quietly = TRUE)
[17:45:19.502]                           if (has_future) {
[17:45:19.502]                             ns <- base::getNamespace("future")
[17:45:19.502]                             version <- ns[[".package"]][["version"]]
[17:45:19.502]                             if (is.null(version)) 
[17:45:19.502]                               version <- utils::packageVersion("future")
[17:45:19.502]                           }
[17:45:19.502]                           else {
[17:45:19.502]                             version <- NULL
[17:45:19.502]                           }
[17:45:19.502]                           if (!has_future || version < "1.8.0") {
[17:45:19.502]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.502]                               "", base::R.version$version.string), 
[17:45:19.502]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.502]                                 base::R.version$platform, 8 * 
[17:45:19.502]                                   base::.Machine$sizeof.pointer), 
[17:45:19.502]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.502]                                 "release", "version")], collapse = " "), 
[17:45:19.502]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.502]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.502]                               info)
[17:45:19.502]                             info <- base::paste(info, collapse = "; ")
[17:45:19.502]                             if (!has_future) {
[17:45:19.502]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.502]                                 info)
[17:45:19.502]                             }
[17:45:19.502]                             else {
[17:45:19.502]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.502]                                 info, version)
[17:45:19.502]                             }
[17:45:19.502]                             base::stop(msg)
[17:45:19.502]                           }
[17:45:19.502]                         })
[17:45:19.502]                       }
[17:45:19.502]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.502]                       base::options(mc.cores = 1L)
[17:45:19.502]                     }
[17:45:19.502]                     base::local({
[17:45:19.502]                       for (pkg in "stats") {
[17:45:19.502]                         base::loadNamespace(pkg)
[17:45:19.502]                         base::library(pkg, character.only = TRUE)
[17:45:19.502]                       }
[17:45:19.502]                     })
[17:45:19.502]                   }
[17:45:19.502]                   ...future.strategy.old <- future::plan("list")
[17:45:19.502]                   options(future.plan = NULL)
[17:45:19.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.502]                 }
[17:45:19.502]                 ...future.workdir <- getwd()
[17:45:19.502]             }
[17:45:19.502]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.502]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.502]         }
[17:45:19.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.502]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.502]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.502]             base::names(...future.oldOptions))
[17:45:19.502]     }
[17:45:19.502]     if (FALSE) {
[17:45:19.502]     }
[17:45:19.502]     else {
[17:45:19.502]         if (TRUE) {
[17:45:19.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.502]                 open = "w")
[17:45:19.502]         }
[17:45:19.502]         else {
[17:45:19.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.502]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.502]         }
[17:45:19.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.502]             base::sink(type = "output", split = FALSE)
[17:45:19.502]             base::close(...future.stdout)
[17:45:19.502]         }, add = TRUE)
[17:45:19.502]     }
[17:45:19.502]     ...future.frame <- base::sys.nframe()
[17:45:19.502]     ...future.conditions <- base::list()
[17:45:19.502]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.502]     if (FALSE) {
[17:45:19.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.502]     }
[17:45:19.502]     ...future.result <- base::tryCatch({
[17:45:19.502]         base::withCallingHandlers({
[17:45:19.502]             ...future.value <- base::withVisible(base::local({
[17:45:19.502]                 withCallingHandlers({
[17:45:19.502]                   {
[17:45:19.502]                     do.call(function(...) {
[17:45:19.502]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.502]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.502]                         ...future.globals.maxSize)) {
[17:45:19.502]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.502]                         on.exit(options(oopts), add = TRUE)
[17:45:19.502]                       }
[17:45:19.502]                       {
[17:45:19.502]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.502]                           FUN = function(jj) {
[17:45:19.502]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.502]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.502]                           })
[17:45:19.502]                       }
[17:45:19.502]                     }, args = future.call.arguments)
[17:45:19.502]                   }
[17:45:19.502]                 }, immediateCondition = function(cond) {
[17:45:19.502]                   save_rds <- function (object, pathname, ...) 
[17:45:19.502]                   {
[17:45:19.502]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.502]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.502]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.502]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.502]                         fi_tmp[["mtime"]])
[17:45:19.502]                     }
[17:45:19.502]                     tryCatch({
[17:45:19.502]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.502]                     }, error = function(ex) {
[17:45:19.502]                       msg <- conditionMessage(ex)
[17:45:19.502]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.502]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.502]                         fi_tmp[["mtime"]], msg)
[17:45:19.502]                       ex$message <- msg
[17:45:19.502]                       stop(ex)
[17:45:19.502]                     })
[17:45:19.502]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.502]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.502]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.502]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.502]                       fi <- file.info(pathname)
[17:45:19.502]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.502]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.502]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.502]                         fi[["size"]], fi[["mtime"]])
[17:45:19.502]                       stop(msg)
[17:45:19.502]                     }
[17:45:19.502]                     invisible(pathname)
[17:45:19.502]                   }
[17:45:19.502]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.502]                     rootPath = tempdir()) 
[17:45:19.502]                   {
[17:45:19.502]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.502]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.502]                       tmpdir = path, fileext = ".rds")
[17:45:19.502]                     save_rds(obj, file)
[17:45:19.502]                   }
[17:45:19.502]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.502]                   {
[17:45:19.502]                     inherits <- base::inherits
[17:45:19.502]                     invokeRestart <- base::invokeRestart
[17:45:19.502]                     is.null <- base::is.null
[17:45:19.502]                     muffled <- FALSE
[17:45:19.502]                     if (inherits(cond, "message")) {
[17:45:19.502]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.502]                       if (muffled) 
[17:45:19.502]                         invokeRestart("muffleMessage")
[17:45:19.502]                     }
[17:45:19.502]                     else if (inherits(cond, "warning")) {
[17:45:19.502]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.502]                       if (muffled) 
[17:45:19.502]                         invokeRestart("muffleWarning")
[17:45:19.502]                     }
[17:45:19.502]                     else if (inherits(cond, "condition")) {
[17:45:19.502]                       if (!is.null(pattern)) {
[17:45:19.502]                         computeRestarts <- base::computeRestarts
[17:45:19.502]                         grepl <- base::grepl
[17:45:19.502]                         restarts <- computeRestarts(cond)
[17:45:19.502]                         for (restart in restarts) {
[17:45:19.502]                           name <- restart$name
[17:45:19.502]                           if (is.null(name)) 
[17:45:19.502]                             next
[17:45:19.502]                           if (!grepl(pattern, name)) 
[17:45:19.502]                             next
[17:45:19.502]                           invokeRestart(restart)
[17:45:19.502]                           muffled <- TRUE
[17:45:19.502]                           break
[17:45:19.502]                         }
[17:45:19.502]                       }
[17:45:19.502]                     }
[17:45:19.502]                     invisible(muffled)
[17:45:19.502]                   }
[17:45:19.502]                   muffleCondition(cond)
[17:45:19.502]                 })
[17:45:19.502]             }))
[17:45:19.502]             future::FutureResult(value = ...future.value$value, 
[17:45:19.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.502]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.502]                     ...future.globalenv.names))
[17:45:19.502]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.502]         }, condition = base::local({
[17:45:19.502]             c <- base::c
[17:45:19.502]             inherits <- base::inherits
[17:45:19.502]             invokeRestart <- base::invokeRestart
[17:45:19.502]             length <- base::length
[17:45:19.502]             list <- base::list
[17:45:19.502]             seq.int <- base::seq.int
[17:45:19.502]             signalCondition <- base::signalCondition
[17:45:19.502]             sys.calls <- base::sys.calls
[17:45:19.502]             `[[` <- base::`[[`
[17:45:19.502]             `+` <- base::`+`
[17:45:19.502]             `<<-` <- base::`<<-`
[17:45:19.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.502]                   3L)]
[17:45:19.502]             }
[17:45:19.502]             function(cond) {
[17:45:19.502]                 is_error <- inherits(cond, "error")
[17:45:19.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.502]                   NULL)
[17:45:19.502]                 if (is_error) {
[17:45:19.502]                   sessionInformation <- function() {
[17:45:19.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.502]                       search = base::search(), system = base::Sys.info())
[17:45:19.502]                   }
[17:45:19.502]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.502]                     cond$call), session = sessionInformation(), 
[17:45:19.502]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.502]                   signalCondition(cond)
[17:45:19.502]                 }
[17:45:19.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.502]                 "immediateCondition"))) {
[17:45:19.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.502]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.502]                   if (TRUE && !signal) {
[17:45:19.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.502]                     {
[17:45:19.502]                       inherits <- base::inherits
[17:45:19.502]                       invokeRestart <- base::invokeRestart
[17:45:19.502]                       is.null <- base::is.null
[17:45:19.502]                       muffled <- FALSE
[17:45:19.502]                       if (inherits(cond, "message")) {
[17:45:19.502]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.502]                         if (muffled) 
[17:45:19.502]                           invokeRestart("muffleMessage")
[17:45:19.502]                       }
[17:45:19.502]                       else if (inherits(cond, "warning")) {
[17:45:19.502]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.502]                         if (muffled) 
[17:45:19.502]                           invokeRestart("muffleWarning")
[17:45:19.502]                       }
[17:45:19.502]                       else if (inherits(cond, "condition")) {
[17:45:19.502]                         if (!is.null(pattern)) {
[17:45:19.502]                           computeRestarts <- base::computeRestarts
[17:45:19.502]                           grepl <- base::grepl
[17:45:19.502]                           restarts <- computeRestarts(cond)
[17:45:19.502]                           for (restart in restarts) {
[17:45:19.502]                             name <- restart$name
[17:45:19.502]                             if (is.null(name)) 
[17:45:19.502]                               next
[17:45:19.502]                             if (!grepl(pattern, name)) 
[17:45:19.502]                               next
[17:45:19.502]                             invokeRestart(restart)
[17:45:19.502]                             muffled <- TRUE
[17:45:19.502]                             break
[17:45:19.502]                           }
[17:45:19.502]                         }
[17:45:19.502]                       }
[17:45:19.502]                       invisible(muffled)
[17:45:19.502]                     }
[17:45:19.502]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.502]                   }
[17:45:19.502]                 }
[17:45:19.502]                 else {
[17:45:19.502]                   if (TRUE) {
[17:45:19.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.502]                     {
[17:45:19.502]                       inherits <- base::inherits
[17:45:19.502]                       invokeRestart <- base::invokeRestart
[17:45:19.502]                       is.null <- base::is.null
[17:45:19.502]                       muffled <- FALSE
[17:45:19.502]                       if (inherits(cond, "message")) {
[17:45:19.502]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.502]                         if (muffled) 
[17:45:19.502]                           invokeRestart("muffleMessage")
[17:45:19.502]                       }
[17:45:19.502]                       else if (inherits(cond, "warning")) {
[17:45:19.502]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.502]                         if (muffled) 
[17:45:19.502]                           invokeRestart("muffleWarning")
[17:45:19.502]                       }
[17:45:19.502]                       else if (inherits(cond, "condition")) {
[17:45:19.502]                         if (!is.null(pattern)) {
[17:45:19.502]                           computeRestarts <- base::computeRestarts
[17:45:19.502]                           grepl <- base::grepl
[17:45:19.502]                           restarts <- computeRestarts(cond)
[17:45:19.502]                           for (restart in restarts) {
[17:45:19.502]                             name <- restart$name
[17:45:19.502]                             if (is.null(name)) 
[17:45:19.502]                               next
[17:45:19.502]                             if (!grepl(pattern, name)) 
[17:45:19.502]                               next
[17:45:19.502]                             invokeRestart(restart)
[17:45:19.502]                             muffled <- TRUE
[17:45:19.502]                             break
[17:45:19.502]                           }
[17:45:19.502]                         }
[17:45:19.502]                       }
[17:45:19.502]                       invisible(muffled)
[17:45:19.502]                     }
[17:45:19.502]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.502]                   }
[17:45:19.502]                 }
[17:45:19.502]             }
[17:45:19.502]         }))
[17:45:19.502]     }, error = function(ex) {
[17:45:19.502]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.502]                 ...future.rng), started = ...future.startTime, 
[17:45:19.502]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.502]             version = "1.8"), class = "FutureResult")
[17:45:19.502]     }, finally = {
[17:45:19.502]         if (!identical(...future.workdir, getwd())) 
[17:45:19.502]             setwd(...future.workdir)
[17:45:19.502]         {
[17:45:19.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.502]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.502]             }
[17:45:19.502]             base::options(...future.oldOptions)
[17:45:19.502]             if (.Platform$OS.type == "windows") {
[17:45:19.502]                 old_names <- names(...future.oldEnvVars)
[17:45:19.502]                 envs <- base::Sys.getenv()
[17:45:19.502]                 names <- names(envs)
[17:45:19.502]                 common <- intersect(names, old_names)
[17:45:19.502]                 added <- setdiff(names, old_names)
[17:45:19.502]                 removed <- setdiff(old_names, names)
[17:45:19.502]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.502]                   envs[common]]
[17:45:19.502]                 NAMES <- toupper(changed)
[17:45:19.502]                 args <- list()
[17:45:19.502]                 for (kk in seq_along(NAMES)) {
[17:45:19.502]                   name <- changed[[kk]]
[17:45:19.502]                   NAME <- NAMES[[kk]]
[17:45:19.502]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.502]                     next
[17:45:19.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.502]                 }
[17:45:19.502]                 NAMES <- toupper(added)
[17:45:19.502]                 for (kk in seq_along(NAMES)) {
[17:45:19.502]                   name <- added[[kk]]
[17:45:19.502]                   NAME <- NAMES[[kk]]
[17:45:19.502]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.502]                     next
[17:45:19.502]                   args[[name]] <- ""
[17:45:19.502]                 }
[17:45:19.502]                 NAMES <- toupper(removed)
[17:45:19.502]                 for (kk in seq_along(NAMES)) {
[17:45:19.502]                   name <- removed[[kk]]
[17:45:19.502]                   NAME <- NAMES[[kk]]
[17:45:19.502]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.502]                     next
[17:45:19.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.502]                 }
[17:45:19.502]                 if (length(args) > 0) 
[17:45:19.502]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.502]             }
[17:45:19.502]             else {
[17:45:19.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.502]             }
[17:45:19.502]             {
[17:45:19.502]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.502]                   0L) {
[17:45:19.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.502]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.502]                   base::options(opts)
[17:45:19.502]                 }
[17:45:19.502]                 {
[17:45:19.502]                   {
[17:45:19.502]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.502]                     NULL
[17:45:19.502]                   }
[17:45:19.502]                   options(future.plan = NULL)
[17:45:19.502]                   if (is.na(NA_character_)) 
[17:45:19.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.502]                     .init = FALSE)
[17:45:19.502]                 }
[17:45:19.502]             }
[17:45:19.502]         }
[17:45:19.502]     })
[17:45:19.502]     if (TRUE) {
[17:45:19.502]         base::sink(type = "output", split = FALSE)
[17:45:19.502]         if (TRUE) {
[17:45:19.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.502]         }
[17:45:19.502]         else {
[17:45:19.502]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.502]         }
[17:45:19.502]         base::close(...future.stdout)
[17:45:19.502]         ...future.stdout <- NULL
[17:45:19.502]     }
[17:45:19.502]     ...future.result$conditions <- ...future.conditions
[17:45:19.502]     ...future.result$finished <- base::Sys.time()
[17:45:19.502]     ...future.result
[17:45:19.502] }
[17:45:19.505] assign_globals() ...
[17:45:19.505] List of 5
[17:45:19.505]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:45:19.505]  $ future.call.arguments    : list()
[17:45:19.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.505]  $ ...future.elements_ii    :List of 4
[17:45:19.505]   ..$ : int [1:3] 1 2 3
[17:45:19.505]   ..$ : int [1:4] 1 2 3 4
[17:45:19.505]   ..$ : int [1:5] 1 2 3 4 5
[17:45:19.505]   ..$ : int [1:6] 1 2 3 4 5 6
[17:45:19.505]  $ ...future.seeds_ii       : NULL
[17:45:19.505]  $ ...future.globals.maxSize: NULL
[17:45:19.505]  - attr(*, "where")=List of 5
[17:45:19.505]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.505]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.505]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.505]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.505]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.505]  - attr(*, "resolved")= logi FALSE
[17:45:19.505]  - attr(*, "total_size")= num 46960
[17:45:19.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.505]  - attr(*, "already-done")= logi TRUE
[17:45:19.511] - copied ‘...future.FUN’ to environment
[17:45:19.511] - copied ‘future.call.arguments’ to environment
[17:45:19.511] - copied ‘...future.elements_ii’ to environment
[17:45:19.511] - copied ‘...future.seeds_ii’ to environment
[17:45:19.511] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.512] assign_globals() ... done
[17:45:19.512] requestCore(): workers = 2
[17:45:19.514] MulticoreFuture started
[17:45:19.514] - Launch lazy future ... done
[17:45:19.515] run() for ‘MulticoreFuture’ ... done
[17:45:19.515] Created future:
[17:45:19.516] plan(): Setting new future strategy stack:
[17:45:19.516] List of future strategies:
[17:45:19.516] 1. sequential:
[17:45:19.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.516]    - tweaked: FALSE
[17:45:19.516]    - call: NULL
[17:45:19.517] plan(): nbrOfWorkers() = 1
[17:45:19.519] plan(): Setting new future strategy stack:
[17:45:19.519] List of future strategies:
[17:45:19.519] 1. multicore:
[17:45:19.519]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.519]    - tweaked: FALSE
[17:45:19.519]    - call: plan(strategy)
[17:45:19.524] plan(): nbrOfWorkers() = 2
[17:45:19.515] MulticoreFuture:
[17:45:19.515] Label: ‘future_sapply-1’
[17:45:19.515] Expression:
[17:45:19.515] {
[17:45:19.515]     do.call(function(...) {
[17:45:19.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.515]             on.exit(options(oopts), add = TRUE)
[17:45:19.515]         }
[17:45:19.515]         {
[17:45:19.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.515]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.515]             })
[17:45:19.515]         }
[17:45:19.515]     }, args = future.call.arguments)
[17:45:19.515] }
[17:45:19.515] Lazy evaluation: FALSE
[17:45:19.515] Asynchronous evaluation: TRUE
[17:45:19.515] Local evaluation: TRUE
[17:45:19.515] Environment: R_GlobalEnv
[17:45:19.515] Capture standard output: TRUE
[17:45:19.515] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.515] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:19.515] Packages: 1 packages (‘stats’)
[17:45:19.515] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.515] Resolved: TRUE
[17:45:19.515] Value: <not collected>
[17:45:19.515] Conditions captured: <none>
[17:45:19.515] Early signaling: FALSE
[17:45:19.515] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.515] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.525] Chunk #1 of 2 ... DONE
[17:45:19.525] Chunk #2 of 2 ...
[17:45:19.526]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.526] getGlobalsAndPackages() ...
[17:45:19.526] Searching for globals...
[17:45:19.527] 
[17:45:19.527] Searching for globals ... DONE
[17:45:19.527] - globals: [0] <none>
[17:45:19.527] getGlobalsAndPackages() ... DONE
[17:45:19.527]    + additional globals found: [n=0] 
[17:45:19.527]    + additional namespaces needed: [n=0] 
[17:45:19.527]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.527]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.528]  - seeds: <none>
[17:45:19.528]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.528] getGlobalsAndPackages() ...
[17:45:19.528] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.528] Resolving globals: FALSE
[17:45:19.528] Tweak future expression to call with '...' arguments ...
[17:45:19.529] {
[17:45:19.529]     do.call(function(...) {
[17:45:19.529]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.529]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.529]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.529]             on.exit(options(oopts), add = TRUE)
[17:45:19.529]         }
[17:45:19.529]         {
[17:45:19.529]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.529]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.529]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.529]             })
[17:45:19.529]         }
[17:45:19.529]     }, args = future.call.arguments)
[17:45:19.529] }
[17:45:19.529] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.530] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.530] - packages: [1] ‘stats’
[17:45:19.530] getGlobalsAndPackages() ... DONE
[17:45:19.531] run() for ‘Future’ ...
[17:45:19.531] - state: ‘created’
[17:45:19.531] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.537] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.538]   - Field: ‘label’
[17:45:19.538]   - Field: ‘local’
[17:45:19.538]   - Field: ‘owner’
[17:45:19.538]   - Field: ‘envir’
[17:45:19.539]   - Field: ‘workers’
[17:45:19.539]   - Field: ‘packages’
[17:45:19.539]   - Field: ‘gc’
[17:45:19.539]   - Field: ‘job’
[17:45:19.539]   - Field: ‘conditions’
[17:45:19.539]   - Field: ‘expr’
[17:45:19.540]   - Field: ‘uuid’
[17:45:19.540]   - Field: ‘seed’
[17:45:19.540]   - Field: ‘version’
[17:45:19.540]   - Field: ‘result’
[17:45:19.540]   - Field: ‘asynchronous’
[17:45:19.540]   - Field: ‘calls’
[17:45:19.541]   - Field: ‘globals’
[17:45:19.541]   - Field: ‘stdout’
[17:45:19.541]   - Field: ‘earlySignal’
[17:45:19.541]   - Field: ‘lazy’
[17:45:19.541]   - Field: ‘state’
[17:45:19.541] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.541] - Launch lazy future ...
[17:45:19.542] Packages needed by the future expression (n = 1): ‘stats’
[17:45:19.542] Packages needed by future strategies (n = 0): <none>
[17:45:19.543] {
[17:45:19.543]     {
[17:45:19.543]         {
[17:45:19.543]             ...future.startTime <- base::Sys.time()
[17:45:19.543]             {
[17:45:19.543]                 {
[17:45:19.543]                   {
[17:45:19.543]                     {
[17:45:19.543]                       {
[17:45:19.543]                         base::local({
[17:45:19.543]                           has_future <- base::requireNamespace("future", 
[17:45:19.543]                             quietly = TRUE)
[17:45:19.543]                           if (has_future) {
[17:45:19.543]                             ns <- base::getNamespace("future")
[17:45:19.543]                             version <- ns[[".package"]][["version"]]
[17:45:19.543]                             if (is.null(version)) 
[17:45:19.543]                               version <- utils::packageVersion("future")
[17:45:19.543]                           }
[17:45:19.543]                           else {
[17:45:19.543]                             version <- NULL
[17:45:19.543]                           }
[17:45:19.543]                           if (!has_future || version < "1.8.0") {
[17:45:19.543]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.543]                               "", base::R.version$version.string), 
[17:45:19.543]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.543]                                 base::R.version$platform, 8 * 
[17:45:19.543]                                   base::.Machine$sizeof.pointer), 
[17:45:19.543]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.543]                                 "release", "version")], collapse = " "), 
[17:45:19.543]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.543]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.543]                               info)
[17:45:19.543]                             info <- base::paste(info, collapse = "; ")
[17:45:19.543]                             if (!has_future) {
[17:45:19.543]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.543]                                 info)
[17:45:19.543]                             }
[17:45:19.543]                             else {
[17:45:19.543]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.543]                                 info, version)
[17:45:19.543]                             }
[17:45:19.543]                             base::stop(msg)
[17:45:19.543]                           }
[17:45:19.543]                         })
[17:45:19.543]                       }
[17:45:19.543]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.543]                       base::options(mc.cores = 1L)
[17:45:19.543]                     }
[17:45:19.543]                     base::local({
[17:45:19.543]                       for (pkg in "stats") {
[17:45:19.543]                         base::loadNamespace(pkg)
[17:45:19.543]                         base::library(pkg, character.only = TRUE)
[17:45:19.543]                       }
[17:45:19.543]                     })
[17:45:19.543]                   }
[17:45:19.543]                   ...future.strategy.old <- future::plan("list")
[17:45:19.543]                   options(future.plan = NULL)
[17:45:19.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.543]                 }
[17:45:19.543]                 ...future.workdir <- getwd()
[17:45:19.543]             }
[17:45:19.543]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.543]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.543]         }
[17:45:19.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.543]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.543]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.543]             base::names(...future.oldOptions))
[17:45:19.543]     }
[17:45:19.543]     if (FALSE) {
[17:45:19.543]     }
[17:45:19.543]     else {
[17:45:19.543]         if (TRUE) {
[17:45:19.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.543]                 open = "w")
[17:45:19.543]         }
[17:45:19.543]         else {
[17:45:19.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.543]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.543]         }
[17:45:19.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.543]             base::sink(type = "output", split = FALSE)
[17:45:19.543]             base::close(...future.stdout)
[17:45:19.543]         }, add = TRUE)
[17:45:19.543]     }
[17:45:19.543]     ...future.frame <- base::sys.nframe()
[17:45:19.543]     ...future.conditions <- base::list()
[17:45:19.543]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.543]     if (FALSE) {
[17:45:19.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.543]     }
[17:45:19.543]     ...future.result <- base::tryCatch({
[17:45:19.543]         base::withCallingHandlers({
[17:45:19.543]             ...future.value <- base::withVisible(base::local({
[17:45:19.543]                 withCallingHandlers({
[17:45:19.543]                   {
[17:45:19.543]                     do.call(function(...) {
[17:45:19.543]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.543]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.543]                         ...future.globals.maxSize)) {
[17:45:19.543]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.543]                         on.exit(options(oopts), add = TRUE)
[17:45:19.543]                       }
[17:45:19.543]                       {
[17:45:19.543]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.543]                           FUN = function(jj) {
[17:45:19.543]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.543]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.543]                           })
[17:45:19.543]                       }
[17:45:19.543]                     }, args = future.call.arguments)
[17:45:19.543]                   }
[17:45:19.543]                 }, immediateCondition = function(cond) {
[17:45:19.543]                   save_rds <- function (object, pathname, ...) 
[17:45:19.543]                   {
[17:45:19.543]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.543]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.543]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.543]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.543]                         fi_tmp[["mtime"]])
[17:45:19.543]                     }
[17:45:19.543]                     tryCatch({
[17:45:19.543]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.543]                     }, error = function(ex) {
[17:45:19.543]                       msg <- conditionMessage(ex)
[17:45:19.543]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.543]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.543]                         fi_tmp[["mtime"]], msg)
[17:45:19.543]                       ex$message <- msg
[17:45:19.543]                       stop(ex)
[17:45:19.543]                     })
[17:45:19.543]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.543]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.543]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.543]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.543]                       fi <- file.info(pathname)
[17:45:19.543]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.543]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.543]                         fi[["size"]], fi[["mtime"]])
[17:45:19.543]                       stop(msg)
[17:45:19.543]                     }
[17:45:19.543]                     invisible(pathname)
[17:45:19.543]                   }
[17:45:19.543]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.543]                     rootPath = tempdir()) 
[17:45:19.543]                   {
[17:45:19.543]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.543]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.543]                       tmpdir = path, fileext = ".rds")
[17:45:19.543]                     save_rds(obj, file)
[17:45:19.543]                   }
[17:45:19.543]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.543]                   {
[17:45:19.543]                     inherits <- base::inherits
[17:45:19.543]                     invokeRestart <- base::invokeRestart
[17:45:19.543]                     is.null <- base::is.null
[17:45:19.543]                     muffled <- FALSE
[17:45:19.543]                     if (inherits(cond, "message")) {
[17:45:19.543]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.543]                       if (muffled) 
[17:45:19.543]                         invokeRestart("muffleMessage")
[17:45:19.543]                     }
[17:45:19.543]                     else if (inherits(cond, "warning")) {
[17:45:19.543]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.543]                       if (muffled) 
[17:45:19.543]                         invokeRestart("muffleWarning")
[17:45:19.543]                     }
[17:45:19.543]                     else if (inherits(cond, "condition")) {
[17:45:19.543]                       if (!is.null(pattern)) {
[17:45:19.543]                         computeRestarts <- base::computeRestarts
[17:45:19.543]                         grepl <- base::grepl
[17:45:19.543]                         restarts <- computeRestarts(cond)
[17:45:19.543]                         for (restart in restarts) {
[17:45:19.543]                           name <- restart$name
[17:45:19.543]                           if (is.null(name)) 
[17:45:19.543]                             next
[17:45:19.543]                           if (!grepl(pattern, name)) 
[17:45:19.543]                             next
[17:45:19.543]                           invokeRestart(restart)
[17:45:19.543]                           muffled <- TRUE
[17:45:19.543]                           break
[17:45:19.543]                         }
[17:45:19.543]                       }
[17:45:19.543]                     }
[17:45:19.543]                     invisible(muffled)
[17:45:19.543]                   }
[17:45:19.543]                   muffleCondition(cond)
[17:45:19.543]                 })
[17:45:19.543]             }))
[17:45:19.543]             future::FutureResult(value = ...future.value$value, 
[17:45:19.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.543]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.543]                     ...future.globalenv.names))
[17:45:19.543]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.543]         }, condition = base::local({
[17:45:19.543]             c <- base::c
[17:45:19.543]             inherits <- base::inherits
[17:45:19.543]             invokeRestart <- base::invokeRestart
[17:45:19.543]             length <- base::length
[17:45:19.543]             list <- base::list
[17:45:19.543]             seq.int <- base::seq.int
[17:45:19.543]             signalCondition <- base::signalCondition
[17:45:19.543]             sys.calls <- base::sys.calls
[17:45:19.543]             `[[` <- base::`[[`
[17:45:19.543]             `+` <- base::`+`
[17:45:19.543]             `<<-` <- base::`<<-`
[17:45:19.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.543]                   3L)]
[17:45:19.543]             }
[17:45:19.543]             function(cond) {
[17:45:19.543]                 is_error <- inherits(cond, "error")
[17:45:19.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.543]                   NULL)
[17:45:19.543]                 if (is_error) {
[17:45:19.543]                   sessionInformation <- function() {
[17:45:19.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.543]                       search = base::search(), system = base::Sys.info())
[17:45:19.543]                   }
[17:45:19.543]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.543]                     cond$call), session = sessionInformation(), 
[17:45:19.543]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.543]                   signalCondition(cond)
[17:45:19.543]                 }
[17:45:19.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.543]                 "immediateCondition"))) {
[17:45:19.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.543]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.543]                   if (TRUE && !signal) {
[17:45:19.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.543]                     {
[17:45:19.543]                       inherits <- base::inherits
[17:45:19.543]                       invokeRestart <- base::invokeRestart
[17:45:19.543]                       is.null <- base::is.null
[17:45:19.543]                       muffled <- FALSE
[17:45:19.543]                       if (inherits(cond, "message")) {
[17:45:19.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.543]                         if (muffled) 
[17:45:19.543]                           invokeRestart("muffleMessage")
[17:45:19.543]                       }
[17:45:19.543]                       else if (inherits(cond, "warning")) {
[17:45:19.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.543]                         if (muffled) 
[17:45:19.543]                           invokeRestart("muffleWarning")
[17:45:19.543]                       }
[17:45:19.543]                       else if (inherits(cond, "condition")) {
[17:45:19.543]                         if (!is.null(pattern)) {
[17:45:19.543]                           computeRestarts <- base::computeRestarts
[17:45:19.543]                           grepl <- base::grepl
[17:45:19.543]                           restarts <- computeRestarts(cond)
[17:45:19.543]                           for (restart in restarts) {
[17:45:19.543]                             name <- restart$name
[17:45:19.543]                             if (is.null(name)) 
[17:45:19.543]                               next
[17:45:19.543]                             if (!grepl(pattern, name)) 
[17:45:19.543]                               next
[17:45:19.543]                             invokeRestart(restart)
[17:45:19.543]                             muffled <- TRUE
[17:45:19.543]                             break
[17:45:19.543]                           }
[17:45:19.543]                         }
[17:45:19.543]                       }
[17:45:19.543]                       invisible(muffled)
[17:45:19.543]                     }
[17:45:19.543]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.543]                   }
[17:45:19.543]                 }
[17:45:19.543]                 else {
[17:45:19.543]                   if (TRUE) {
[17:45:19.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.543]                     {
[17:45:19.543]                       inherits <- base::inherits
[17:45:19.543]                       invokeRestart <- base::invokeRestart
[17:45:19.543]                       is.null <- base::is.null
[17:45:19.543]                       muffled <- FALSE
[17:45:19.543]                       if (inherits(cond, "message")) {
[17:45:19.543]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.543]                         if (muffled) 
[17:45:19.543]                           invokeRestart("muffleMessage")
[17:45:19.543]                       }
[17:45:19.543]                       else if (inherits(cond, "warning")) {
[17:45:19.543]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.543]                         if (muffled) 
[17:45:19.543]                           invokeRestart("muffleWarning")
[17:45:19.543]                       }
[17:45:19.543]                       else if (inherits(cond, "condition")) {
[17:45:19.543]                         if (!is.null(pattern)) {
[17:45:19.543]                           computeRestarts <- base::computeRestarts
[17:45:19.543]                           grepl <- base::grepl
[17:45:19.543]                           restarts <- computeRestarts(cond)
[17:45:19.543]                           for (restart in restarts) {
[17:45:19.543]                             name <- restart$name
[17:45:19.543]                             if (is.null(name)) 
[17:45:19.543]                               next
[17:45:19.543]                             if (!grepl(pattern, name)) 
[17:45:19.543]                               next
[17:45:19.543]                             invokeRestart(restart)
[17:45:19.543]                             muffled <- TRUE
[17:45:19.543]                             break
[17:45:19.543]                           }
[17:45:19.543]                         }
[17:45:19.543]                       }
[17:45:19.543]                       invisible(muffled)
[17:45:19.543]                     }
[17:45:19.543]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.543]                   }
[17:45:19.543]                 }
[17:45:19.543]             }
[17:45:19.543]         }))
[17:45:19.543]     }, error = function(ex) {
[17:45:19.543]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.543]                 ...future.rng), started = ...future.startTime, 
[17:45:19.543]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.543]             version = "1.8"), class = "FutureResult")
[17:45:19.543]     }, finally = {
[17:45:19.543]         if (!identical(...future.workdir, getwd())) 
[17:45:19.543]             setwd(...future.workdir)
[17:45:19.543]         {
[17:45:19.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.543]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.543]             }
[17:45:19.543]             base::options(...future.oldOptions)
[17:45:19.543]             if (.Platform$OS.type == "windows") {
[17:45:19.543]                 old_names <- names(...future.oldEnvVars)
[17:45:19.543]                 envs <- base::Sys.getenv()
[17:45:19.543]                 names <- names(envs)
[17:45:19.543]                 common <- intersect(names, old_names)
[17:45:19.543]                 added <- setdiff(names, old_names)
[17:45:19.543]                 removed <- setdiff(old_names, names)
[17:45:19.543]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.543]                   envs[common]]
[17:45:19.543]                 NAMES <- toupper(changed)
[17:45:19.543]                 args <- list()
[17:45:19.543]                 for (kk in seq_along(NAMES)) {
[17:45:19.543]                   name <- changed[[kk]]
[17:45:19.543]                   NAME <- NAMES[[kk]]
[17:45:19.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.543]                     next
[17:45:19.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.543]                 }
[17:45:19.543]                 NAMES <- toupper(added)
[17:45:19.543]                 for (kk in seq_along(NAMES)) {
[17:45:19.543]                   name <- added[[kk]]
[17:45:19.543]                   NAME <- NAMES[[kk]]
[17:45:19.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.543]                     next
[17:45:19.543]                   args[[name]] <- ""
[17:45:19.543]                 }
[17:45:19.543]                 NAMES <- toupper(removed)
[17:45:19.543]                 for (kk in seq_along(NAMES)) {
[17:45:19.543]                   name <- removed[[kk]]
[17:45:19.543]                   NAME <- NAMES[[kk]]
[17:45:19.543]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.543]                     next
[17:45:19.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.543]                 }
[17:45:19.543]                 if (length(args) > 0) 
[17:45:19.543]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.543]             }
[17:45:19.543]             else {
[17:45:19.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.543]             }
[17:45:19.543]             {
[17:45:19.543]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.543]                   0L) {
[17:45:19.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.543]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.543]                   base::options(opts)
[17:45:19.543]                 }
[17:45:19.543]                 {
[17:45:19.543]                   {
[17:45:19.543]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.543]                     NULL
[17:45:19.543]                   }
[17:45:19.543]                   options(future.plan = NULL)
[17:45:19.543]                   if (is.na(NA_character_)) 
[17:45:19.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.543]                     .init = FALSE)
[17:45:19.543]                 }
[17:45:19.543]             }
[17:45:19.543]         }
[17:45:19.543]     })
[17:45:19.543]     if (TRUE) {
[17:45:19.543]         base::sink(type = "output", split = FALSE)
[17:45:19.543]         if (TRUE) {
[17:45:19.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.543]         }
[17:45:19.543]         else {
[17:45:19.543]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.543]         }
[17:45:19.543]         base::close(...future.stdout)
[17:45:19.543]         ...future.stdout <- NULL
[17:45:19.543]     }
[17:45:19.543]     ...future.result$conditions <- ...future.conditions
[17:45:19.543]     ...future.result$finished <- base::Sys.time()
[17:45:19.543]     ...future.result
[17:45:19.543] }
[17:45:19.546] assign_globals() ...
[17:45:19.546] List of 5
[17:45:19.546]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[17:45:19.546]  $ future.call.arguments    : list()
[17:45:19.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.546]  $ ...future.elements_ii    :List of 3
[17:45:19.546]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:45:19.546]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:45:19.546]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:45:19.546]  $ ...future.seeds_ii       : NULL
[17:45:19.546]  $ ...future.globals.maxSize: NULL
[17:45:19.546]  - attr(*, "where")=List of 5
[17:45:19.546]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.546]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.546]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.546]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.546]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.546]  - attr(*, "resolved")= logi FALSE
[17:45:19.546]  - attr(*, "total_size")= num 46960
[17:45:19.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.546]  - attr(*, "already-done")= logi TRUE
[17:45:19.559] - copied ‘...future.FUN’ to environment
[17:45:19.560] - copied ‘future.call.arguments’ to environment
[17:45:19.560] - copied ‘...future.elements_ii’ to environment
[17:45:19.560] - copied ‘...future.seeds_ii’ to environment
[17:45:19.560] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.560] assign_globals() ... done
[17:45:19.561] requestCore(): workers = 2
[17:45:19.563] MulticoreFuture started
[17:45:19.564] - Launch lazy future ... done
[17:45:19.564] run() for ‘MulticoreFuture’ ... done
[17:45:19.565] Created future:
[17:45:19.565] plan(): Setting new future strategy stack:
[17:45:19.566] List of future strategies:
[17:45:19.566] 1. sequential:
[17:45:19.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.566]    - tweaked: FALSE
[17:45:19.566]    - call: NULL
[17:45:19.567] plan(): nbrOfWorkers() = 1
[17:45:19.569] plan(): Setting new future strategy stack:
[17:45:19.570] List of future strategies:
[17:45:19.570] 1. multicore:
[17:45:19.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.570]    - tweaked: FALSE
[17:45:19.570]    - call: plan(strategy)
[17:45:19.575] plan(): nbrOfWorkers() = 2
[17:45:19.565] MulticoreFuture:
[17:45:19.565] Label: ‘future_sapply-2’
[17:45:19.565] Expression:
[17:45:19.565] {
[17:45:19.565]     do.call(function(...) {
[17:45:19.565]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.565]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.565]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.565]             on.exit(options(oopts), add = TRUE)
[17:45:19.565]         }
[17:45:19.565]         {
[17:45:19.565]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.565]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.565]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.565]             })
[17:45:19.565]         }
[17:45:19.565]     }, args = future.call.arguments)
[17:45:19.565] }
[17:45:19.565] Lazy evaluation: FALSE
[17:45:19.565] Asynchronous evaluation: TRUE
[17:45:19.565] Local evaluation: TRUE
[17:45:19.565] Environment: R_GlobalEnv
[17:45:19.565] Capture standard output: TRUE
[17:45:19.565] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.565] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:19.565] Packages: 1 packages (‘stats’)
[17:45:19.565] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.565] Resolved: TRUE
[17:45:19.565] Value: <not collected>
[17:45:19.565] Conditions captured: <none>
[17:45:19.565] Early signaling: FALSE
[17:45:19.565] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.565] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.576] Chunk #2 of 2 ... DONE
[17:45:19.576] Launching 2 futures (chunks) ... DONE
[17:45:19.576] Resolving 2 futures (chunks) ...
[17:45:19.577] resolve() on list ...
[17:45:19.577]  recursive: 0
[17:45:19.577]  length: 2
[17:45:19.577] 
[17:45:19.577] Future #1
[17:45:19.578] result() for MulticoreFuture ...
[17:45:19.579] result() for MulticoreFuture ...
[17:45:19.579] result() for MulticoreFuture ... done
[17:45:19.579] result() for MulticoreFuture ... done
[17:45:19.579] result() for MulticoreFuture ...
[17:45:19.579] result() for MulticoreFuture ... done
[17:45:19.580] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.580] - nx: 2
[17:45:19.580] - relay: TRUE
[17:45:19.580] - stdout: TRUE
[17:45:19.580] - signal: TRUE
[17:45:19.580] - resignal: FALSE
[17:45:19.580] - force: TRUE
[17:45:19.580] - relayed: [n=2] FALSE, FALSE
[17:45:19.581] - queued futures: [n=2] FALSE, FALSE
[17:45:19.581]  - until=1
[17:45:19.581]  - relaying element #1
[17:45:19.581] result() for MulticoreFuture ...
[17:45:19.581] result() for MulticoreFuture ... done
[17:45:19.581] result() for MulticoreFuture ...
[17:45:19.582] result() for MulticoreFuture ... done
[17:45:19.582] result() for MulticoreFuture ...
[17:45:19.582] result() for MulticoreFuture ... done
[17:45:19.582] result() for MulticoreFuture ...
[17:45:19.582] result() for MulticoreFuture ... done
[17:45:19.582] - relayed: [n=2] TRUE, FALSE
[17:45:19.582] - queued futures: [n=2] TRUE, FALSE
[17:45:19.583] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.583]  length: 1 (resolved future 1)
[17:45:19.583] Future #2
[17:45:19.583] result() for MulticoreFuture ...
[17:45:19.584] result() for MulticoreFuture ...
[17:45:19.584] result() for MulticoreFuture ... done
[17:45:19.584] result() for MulticoreFuture ... done
[17:45:19.584] result() for MulticoreFuture ...
[17:45:19.585] result() for MulticoreFuture ... done
[17:45:19.585] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.585] - nx: 2
[17:45:19.585] - relay: TRUE
[17:45:19.585] - stdout: TRUE
[17:45:19.585] - signal: TRUE
[17:45:19.586] - resignal: FALSE
[17:45:19.586] - force: TRUE
[17:45:19.586] - relayed: [n=2] TRUE, FALSE
[17:45:19.586] - queued futures: [n=2] TRUE, FALSE
[17:45:19.586]  - until=2
[17:45:19.586]  - relaying element #2
[17:45:19.587] result() for MulticoreFuture ...
[17:45:19.587] result() for MulticoreFuture ... done
[17:45:19.587] result() for MulticoreFuture ...
[17:45:19.587] result() for MulticoreFuture ... done
[17:45:19.587] result() for MulticoreFuture ...
[17:45:19.587] result() for MulticoreFuture ... done
[17:45:19.587] result() for MulticoreFuture ...
[17:45:19.587] result() for MulticoreFuture ... done
[17:45:19.588] - relayed: [n=2] TRUE, TRUE
[17:45:19.588] - queued futures: [n=2] TRUE, TRUE
[17:45:19.588] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.588]  length: 0 (resolved future 2)
[17:45:19.588] Relaying remaining futures
[17:45:19.588] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.588] - nx: 2
[17:45:19.588] - relay: TRUE
[17:45:19.588] - stdout: TRUE
[17:45:19.589] - signal: TRUE
[17:45:19.589] - resignal: FALSE
[17:45:19.589] - force: TRUE
[17:45:19.589] - relayed: [n=2] TRUE, TRUE
[17:45:19.589] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.589] - relayed: [n=2] TRUE, TRUE
[17:45:19.589] - queued futures: [n=2] TRUE, TRUE
[17:45:19.589] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.589] resolve() on list ... DONE
[17:45:19.590] result() for MulticoreFuture ...
[17:45:19.590] result() for MulticoreFuture ... done
[17:45:19.590] result() for MulticoreFuture ...
[17:45:19.590] result() for MulticoreFuture ... done
[17:45:19.590] result() for MulticoreFuture ...
[17:45:19.590] result() for MulticoreFuture ... done
[17:45:19.590] result() for MulticoreFuture ...
[17:45:19.590] result() for MulticoreFuture ... done
[17:45:19.590]  - Number of value chunks collected: 2
[17:45:19.591] Resolving 2 futures (chunks) ... DONE
[17:45:19.591] Reducing values from 2 chunks ...
[17:45:19.591]  - Number of values collected after concatenation: 7
[17:45:19.591]  - Number of values expected: 7
[17:45:19.591] Reducing values from 2 chunks ... DONE
[17:45:19.591] future_lapply() ... DONE
[17:45:19.592] future_lapply() ...
[17:45:19.598] Number of chunks: 2
[17:45:19.598] getGlobalsAndPackagesXApply() ...
[17:45:19.598]  - future.globals: TRUE
[17:45:19.598] getGlobalsAndPackages() ...
[17:45:19.598] Searching for globals...
[17:45:19.609] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:45:19.609] Searching for globals ... DONE
[17:45:19.609] Resolving globals: FALSE
[17:45:19.611] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:45:19.611] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:45:19.611] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.611] - packages: [2] ‘stats’, ‘future.apply’
[17:45:19.611] getGlobalsAndPackages() ... DONE
[17:45:19.612]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.612]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:45:19.612] Finding globals ... DONE
[17:45:19.612]  - use_args: TRUE
[17:45:19.612]  - Getting '...' globals ...
[17:45:19.612] resolve() on list ...
[17:45:19.612]  recursive: 0
[17:45:19.612]  length: 1
[17:45:19.613]  elements: ‘...’
[17:45:19.613]  length: 0 (resolved future 1)
[17:45:19.613] resolve() on list ... DONE
[17:45:19.613]    - '...' content: [n=0] 
[17:45:19.613] List of 1
[17:45:19.613]  $ ...: list()
[17:45:19.613]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.613]  - attr(*, "where")=List of 1
[17:45:19.613]   ..$ ...:<environment: 0x5561f52d8298> 
[17:45:19.613]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.613]  - attr(*, "resolved")= logi TRUE
[17:45:19.613]  - attr(*, "total_size")= num NA
[17:45:19.616]  - Getting '...' globals ... DONE
[17:45:19.616] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:19.616] List of 8
[17:45:19.616]  $ ...future.FUN:function (x, ...)  
[17:45:19.616]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:45:19.616]  $ times        : int 5
[17:45:19.616]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.616]  $ stop_if_not  :function (...)  
[17:45:19.616]  $ dim          : NULL
[17:45:19.616]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:19.616]  $ ...          : list()
[17:45:19.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.616]  - attr(*, "where")=List of 8
[17:45:19.616]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:19.616]   ..$ ...          :<environment: 0x5561f52d8298> 
[17:45:19.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.616]  - attr(*, "resolved")= logi FALSE
[17:45:19.616]  - attr(*, "total_size")= num 141240
[17:45:19.623] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:45:19.624] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.624] Number of futures (= number of chunks): 2
[17:45:19.624] Launching 2 futures (chunks) ...
[17:45:19.624] Chunk #1 of 2 ...
[17:45:19.624]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.624] getGlobalsAndPackages() ...
[17:45:19.624] Searching for globals...
[17:45:19.625] 
[17:45:19.625] Searching for globals ... DONE
[17:45:19.625] - globals: [0] <none>
[17:45:19.625] getGlobalsAndPackages() ... DONE
[17:45:19.625]    + additional globals found: [n=0] 
[17:45:19.625]    + additional namespaces needed: [n=0] 
[17:45:19.625]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.625]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.626]  - seeds: <none>
[17:45:19.626]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.626] getGlobalsAndPackages() ...
[17:45:19.626] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.626] Resolving globals: FALSE
[17:45:19.626] Tweak future expression to call with '...' arguments ...
[17:45:19.626] {
[17:45:19.626]     do.call(function(...) {
[17:45:19.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.626]             on.exit(options(oopts), add = TRUE)
[17:45:19.626]         }
[17:45:19.626]         {
[17:45:19.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.626]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.626]             })
[17:45:19.626]         }
[17:45:19.626]     }, args = future.call.arguments)
[17:45:19.626] }
[17:45:19.626] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.627] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.627] - packages: [2] ‘stats’, ‘future.apply’
[17:45:19.627] getGlobalsAndPackages() ... DONE
[17:45:19.628] run() for ‘Future’ ...
[17:45:19.628] - state: ‘created’
[17:45:19.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.631] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.632]   - Field: ‘label’
[17:45:19.632]   - Field: ‘local’
[17:45:19.632]   - Field: ‘owner’
[17:45:19.632]   - Field: ‘envir’
[17:45:19.632]   - Field: ‘workers’
[17:45:19.632]   - Field: ‘packages’
[17:45:19.632]   - Field: ‘gc’
[17:45:19.632]   - Field: ‘job’
[17:45:19.632]   - Field: ‘conditions’
[17:45:19.633]   - Field: ‘expr’
[17:45:19.633]   - Field: ‘uuid’
[17:45:19.633]   - Field: ‘seed’
[17:45:19.633]   - Field: ‘version’
[17:45:19.633]   - Field: ‘result’
[17:45:19.633]   - Field: ‘asynchronous’
[17:45:19.633]   - Field: ‘calls’
[17:45:19.633]   - Field: ‘globals’
[17:45:19.633]   - Field: ‘stdout’
[17:45:19.633]   - Field: ‘earlySignal’
[17:45:19.633]   - Field: ‘lazy’
[17:45:19.634]   - Field: ‘state’
[17:45:19.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.634] - Launch lazy future ...
[17:45:19.634] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:19.634] Packages needed by future strategies (n = 0): <none>
[17:45:19.635] {
[17:45:19.635]     {
[17:45:19.635]         {
[17:45:19.635]             ...future.startTime <- base::Sys.time()
[17:45:19.635]             {
[17:45:19.635]                 {
[17:45:19.635]                   {
[17:45:19.635]                     {
[17:45:19.635]                       {
[17:45:19.635]                         base::local({
[17:45:19.635]                           has_future <- base::requireNamespace("future", 
[17:45:19.635]                             quietly = TRUE)
[17:45:19.635]                           if (has_future) {
[17:45:19.635]                             ns <- base::getNamespace("future")
[17:45:19.635]                             version <- ns[[".package"]][["version"]]
[17:45:19.635]                             if (is.null(version)) 
[17:45:19.635]                               version <- utils::packageVersion("future")
[17:45:19.635]                           }
[17:45:19.635]                           else {
[17:45:19.635]                             version <- NULL
[17:45:19.635]                           }
[17:45:19.635]                           if (!has_future || version < "1.8.0") {
[17:45:19.635]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.635]                               "", base::R.version$version.string), 
[17:45:19.635]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.635]                                 base::R.version$platform, 8 * 
[17:45:19.635]                                   base::.Machine$sizeof.pointer), 
[17:45:19.635]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.635]                                 "release", "version")], collapse = " "), 
[17:45:19.635]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.635]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.635]                               info)
[17:45:19.635]                             info <- base::paste(info, collapse = "; ")
[17:45:19.635]                             if (!has_future) {
[17:45:19.635]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.635]                                 info)
[17:45:19.635]                             }
[17:45:19.635]                             else {
[17:45:19.635]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.635]                                 info, version)
[17:45:19.635]                             }
[17:45:19.635]                             base::stop(msg)
[17:45:19.635]                           }
[17:45:19.635]                         })
[17:45:19.635]                       }
[17:45:19.635]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.635]                       base::options(mc.cores = 1L)
[17:45:19.635]                     }
[17:45:19.635]                     base::local({
[17:45:19.635]                       for (pkg in c("stats", "future.apply")) {
[17:45:19.635]                         base::loadNamespace(pkg)
[17:45:19.635]                         base::library(pkg, character.only = TRUE)
[17:45:19.635]                       }
[17:45:19.635]                     })
[17:45:19.635]                   }
[17:45:19.635]                   ...future.strategy.old <- future::plan("list")
[17:45:19.635]                   options(future.plan = NULL)
[17:45:19.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.635]                 }
[17:45:19.635]                 ...future.workdir <- getwd()
[17:45:19.635]             }
[17:45:19.635]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.635]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.635]         }
[17:45:19.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.635]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.635]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.635]             base::names(...future.oldOptions))
[17:45:19.635]     }
[17:45:19.635]     if (FALSE) {
[17:45:19.635]     }
[17:45:19.635]     else {
[17:45:19.635]         if (TRUE) {
[17:45:19.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.635]                 open = "w")
[17:45:19.635]         }
[17:45:19.635]         else {
[17:45:19.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.635]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.635]         }
[17:45:19.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.635]             base::sink(type = "output", split = FALSE)
[17:45:19.635]             base::close(...future.stdout)
[17:45:19.635]         }, add = TRUE)
[17:45:19.635]     }
[17:45:19.635]     ...future.frame <- base::sys.nframe()
[17:45:19.635]     ...future.conditions <- base::list()
[17:45:19.635]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.635]     if (FALSE) {
[17:45:19.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.635]     }
[17:45:19.635]     ...future.result <- base::tryCatch({
[17:45:19.635]         base::withCallingHandlers({
[17:45:19.635]             ...future.value <- base::withVisible(base::local({
[17:45:19.635]                 withCallingHandlers({
[17:45:19.635]                   {
[17:45:19.635]                     do.call(function(...) {
[17:45:19.635]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.635]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.635]                         ...future.globals.maxSize)) {
[17:45:19.635]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.635]                         on.exit(options(oopts), add = TRUE)
[17:45:19.635]                       }
[17:45:19.635]                       {
[17:45:19.635]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.635]                           FUN = function(jj) {
[17:45:19.635]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.635]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.635]                           })
[17:45:19.635]                       }
[17:45:19.635]                     }, args = future.call.arguments)
[17:45:19.635]                   }
[17:45:19.635]                 }, immediateCondition = function(cond) {
[17:45:19.635]                   save_rds <- function (object, pathname, ...) 
[17:45:19.635]                   {
[17:45:19.635]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.635]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.635]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.635]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.635]                         fi_tmp[["mtime"]])
[17:45:19.635]                     }
[17:45:19.635]                     tryCatch({
[17:45:19.635]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.635]                     }, error = function(ex) {
[17:45:19.635]                       msg <- conditionMessage(ex)
[17:45:19.635]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.635]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.635]                         fi_tmp[["mtime"]], msg)
[17:45:19.635]                       ex$message <- msg
[17:45:19.635]                       stop(ex)
[17:45:19.635]                     })
[17:45:19.635]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.635]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.635]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.635]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.635]                       fi <- file.info(pathname)
[17:45:19.635]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.635]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.635]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.635]                         fi[["size"]], fi[["mtime"]])
[17:45:19.635]                       stop(msg)
[17:45:19.635]                     }
[17:45:19.635]                     invisible(pathname)
[17:45:19.635]                   }
[17:45:19.635]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.635]                     rootPath = tempdir()) 
[17:45:19.635]                   {
[17:45:19.635]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.635]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.635]                       tmpdir = path, fileext = ".rds")
[17:45:19.635]                     save_rds(obj, file)
[17:45:19.635]                   }
[17:45:19.635]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.635]                   {
[17:45:19.635]                     inherits <- base::inherits
[17:45:19.635]                     invokeRestart <- base::invokeRestart
[17:45:19.635]                     is.null <- base::is.null
[17:45:19.635]                     muffled <- FALSE
[17:45:19.635]                     if (inherits(cond, "message")) {
[17:45:19.635]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.635]                       if (muffled) 
[17:45:19.635]                         invokeRestart("muffleMessage")
[17:45:19.635]                     }
[17:45:19.635]                     else if (inherits(cond, "warning")) {
[17:45:19.635]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.635]                       if (muffled) 
[17:45:19.635]                         invokeRestart("muffleWarning")
[17:45:19.635]                     }
[17:45:19.635]                     else if (inherits(cond, "condition")) {
[17:45:19.635]                       if (!is.null(pattern)) {
[17:45:19.635]                         computeRestarts <- base::computeRestarts
[17:45:19.635]                         grepl <- base::grepl
[17:45:19.635]                         restarts <- computeRestarts(cond)
[17:45:19.635]                         for (restart in restarts) {
[17:45:19.635]                           name <- restart$name
[17:45:19.635]                           if (is.null(name)) 
[17:45:19.635]                             next
[17:45:19.635]                           if (!grepl(pattern, name)) 
[17:45:19.635]                             next
[17:45:19.635]                           invokeRestart(restart)
[17:45:19.635]                           muffled <- TRUE
[17:45:19.635]                           break
[17:45:19.635]                         }
[17:45:19.635]                       }
[17:45:19.635]                     }
[17:45:19.635]                     invisible(muffled)
[17:45:19.635]                   }
[17:45:19.635]                   muffleCondition(cond)
[17:45:19.635]                 })
[17:45:19.635]             }))
[17:45:19.635]             future::FutureResult(value = ...future.value$value, 
[17:45:19.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.635]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.635]                     ...future.globalenv.names))
[17:45:19.635]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.635]         }, condition = base::local({
[17:45:19.635]             c <- base::c
[17:45:19.635]             inherits <- base::inherits
[17:45:19.635]             invokeRestart <- base::invokeRestart
[17:45:19.635]             length <- base::length
[17:45:19.635]             list <- base::list
[17:45:19.635]             seq.int <- base::seq.int
[17:45:19.635]             signalCondition <- base::signalCondition
[17:45:19.635]             sys.calls <- base::sys.calls
[17:45:19.635]             `[[` <- base::`[[`
[17:45:19.635]             `+` <- base::`+`
[17:45:19.635]             `<<-` <- base::`<<-`
[17:45:19.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.635]                   3L)]
[17:45:19.635]             }
[17:45:19.635]             function(cond) {
[17:45:19.635]                 is_error <- inherits(cond, "error")
[17:45:19.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.635]                   NULL)
[17:45:19.635]                 if (is_error) {
[17:45:19.635]                   sessionInformation <- function() {
[17:45:19.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.635]                       search = base::search(), system = base::Sys.info())
[17:45:19.635]                   }
[17:45:19.635]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.635]                     cond$call), session = sessionInformation(), 
[17:45:19.635]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.635]                   signalCondition(cond)
[17:45:19.635]                 }
[17:45:19.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.635]                 "immediateCondition"))) {
[17:45:19.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.635]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.635]                   if (TRUE && !signal) {
[17:45:19.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.635]                     {
[17:45:19.635]                       inherits <- base::inherits
[17:45:19.635]                       invokeRestart <- base::invokeRestart
[17:45:19.635]                       is.null <- base::is.null
[17:45:19.635]                       muffled <- FALSE
[17:45:19.635]                       if (inherits(cond, "message")) {
[17:45:19.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.635]                         if (muffled) 
[17:45:19.635]                           invokeRestart("muffleMessage")
[17:45:19.635]                       }
[17:45:19.635]                       else if (inherits(cond, "warning")) {
[17:45:19.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.635]                         if (muffled) 
[17:45:19.635]                           invokeRestart("muffleWarning")
[17:45:19.635]                       }
[17:45:19.635]                       else if (inherits(cond, "condition")) {
[17:45:19.635]                         if (!is.null(pattern)) {
[17:45:19.635]                           computeRestarts <- base::computeRestarts
[17:45:19.635]                           grepl <- base::grepl
[17:45:19.635]                           restarts <- computeRestarts(cond)
[17:45:19.635]                           for (restart in restarts) {
[17:45:19.635]                             name <- restart$name
[17:45:19.635]                             if (is.null(name)) 
[17:45:19.635]                               next
[17:45:19.635]                             if (!grepl(pattern, name)) 
[17:45:19.635]                               next
[17:45:19.635]                             invokeRestart(restart)
[17:45:19.635]                             muffled <- TRUE
[17:45:19.635]                             break
[17:45:19.635]                           }
[17:45:19.635]                         }
[17:45:19.635]                       }
[17:45:19.635]                       invisible(muffled)
[17:45:19.635]                     }
[17:45:19.635]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.635]                   }
[17:45:19.635]                 }
[17:45:19.635]                 else {
[17:45:19.635]                   if (TRUE) {
[17:45:19.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.635]                     {
[17:45:19.635]                       inherits <- base::inherits
[17:45:19.635]                       invokeRestart <- base::invokeRestart
[17:45:19.635]                       is.null <- base::is.null
[17:45:19.635]                       muffled <- FALSE
[17:45:19.635]                       if (inherits(cond, "message")) {
[17:45:19.635]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.635]                         if (muffled) 
[17:45:19.635]                           invokeRestart("muffleMessage")
[17:45:19.635]                       }
[17:45:19.635]                       else if (inherits(cond, "warning")) {
[17:45:19.635]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.635]                         if (muffled) 
[17:45:19.635]                           invokeRestart("muffleWarning")
[17:45:19.635]                       }
[17:45:19.635]                       else if (inherits(cond, "condition")) {
[17:45:19.635]                         if (!is.null(pattern)) {
[17:45:19.635]                           computeRestarts <- base::computeRestarts
[17:45:19.635]                           grepl <- base::grepl
[17:45:19.635]                           restarts <- computeRestarts(cond)
[17:45:19.635]                           for (restart in restarts) {
[17:45:19.635]                             name <- restart$name
[17:45:19.635]                             if (is.null(name)) 
[17:45:19.635]                               next
[17:45:19.635]                             if (!grepl(pattern, name)) 
[17:45:19.635]                               next
[17:45:19.635]                             invokeRestart(restart)
[17:45:19.635]                             muffled <- TRUE
[17:45:19.635]                             break
[17:45:19.635]                           }
[17:45:19.635]                         }
[17:45:19.635]                       }
[17:45:19.635]                       invisible(muffled)
[17:45:19.635]                     }
[17:45:19.635]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.635]                   }
[17:45:19.635]                 }
[17:45:19.635]             }
[17:45:19.635]         }))
[17:45:19.635]     }, error = function(ex) {
[17:45:19.635]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.635]                 ...future.rng), started = ...future.startTime, 
[17:45:19.635]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.635]             version = "1.8"), class = "FutureResult")
[17:45:19.635]     }, finally = {
[17:45:19.635]         if (!identical(...future.workdir, getwd())) 
[17:45:19.635]             setwd(...future.workdir)
[17:45:19.635]         {
[17:45:19.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.635]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.635]             }
[17:45:19.635]             base::options(...future.oldOptions)
[17:45:19.635]             if (.Platform$OS.type == "windows") {
[17:45:19.635]                 old_names <- names(...future.oldEnvVars)
[17:45:19.635]                 envs <- base::Sys.getenv()
[17:45:19.635]                 names <- names(envs)
[17:45:19.635]                 common <- intersect(names, old_names)
[17:45:19.635]                 added <- setdiff(names, old_names)
[17:45:19.635]                 removed <- setdiff(old_names, names)
[17:45:19.635]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.635]                   envs[common]]
[17:45:19.635]                 NAMES <- toupper(changed)
[17:45:19.635]                 args <- list()
[17:45:19.635]                 for (kk in seq_along(NAMES)) {
[17:45:19.635]                   name <- changed[[kk]]
[17:45:19.635]                   NAME <- NAMES[[kk]]
[17:45:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.635]                     next
[17:45:19.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.635]                 }
[17:45:19.635]                 NAMES <- toupper(added)
[17:45:19.635]                 for (kk in seq_along(NAMES)) {
[17:45:19.635]                   name <- added[[kk]]
[17:45:19.635]                   NAME <- NAMES[[kk]]
[17:45:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.635]                     next
[17:45:19.635]                   args[[name]] <- ""
[17:45:19.635]                 }
[17:45:19.635]                 NAMES <- toupper(removed)
[17:45:19.635]                 for (kk in seq_along(NAMES)) {
[17:45:19.635]                   name <- removed[[kk]]
[17:45:19.635]                   NAME <- NAMES[[kk]]
[17:45:19.635]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.635]                     next
[17:45:19.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.635]                 }
[17:45:19.635]                 if (length(args) > 0) 
[17:45:19.635]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.635]             }
[17:45:19.635]             else {
[17:45:19.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.635]             }
[17:45:19.635]             {
[17:45:19.635]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.635]                   0L) {
[17:45:19.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.635]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.635]                   base::options(opts)
[17:45:19.635]                 }
[17:45:19.635]                 {
[17:45:19.635]                   {
[17:45:19.635]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.635]                     NULL
[17:45:19.635]                   }
[17:45:19.635]                   options(future.plan = NULL)
[17:45:19.635]                   if (is.na(NA_character_)) 
[17:45:19.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.635]                     .init = FALSE)
[17:45:19.635]                 }
[17:45:19.635]             }
[17:45:19.635]         }
[17:45:19.635]     })
[17:45:19.635]     if (TRUE) {
[17:45:19.635]         base::sink(type = "output", split = FALSE)
[17:45:19.635]         if (TRUE) {
[17:45:19.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.635]         }
[17:45:19.635]         else {
[17:45:19.635]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.635]         }
[17:45:19.635]         base::close(...future.stdout)
[17:45:19.635]         ...future.stdout <- NULL
[17:45:19.635]     }
[17:45:19.635]     ...future.result$conditions <- ...future.conditions
[17:45:19.635]     ...future.result$finished <- base::Sys.time()
[17:45:19.635]     ...future.result
[17:45:19.635] }
[17:45:19.637] assign_globals() ...
[17:45:19.637] List of 11
[17:45:19.637]  $ ...future.FUN            :function (x, ...)  
[17:45:19.637]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:45:19.637]  $ times                    : int 5
[17:45:19.637]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.637]  $ stop_if_not              :function (...)  
[17:45:19.637]  $ dim                      : NULL
[17:45:19.637]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.637]  $ future.call.arguments    : list()
[17:45:19.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.637]  $ ...future.elements_ii    :List of 4
[17:45:19.637]   ..$ : int [1:3] 1 2 3
[17:45:19.637]   ..$ : int [1:4] 1 2 3 4
[17:45:19.637]   ..$ : int [1:5] 1 2 3 4 5
[17:45:19.637]   ..$ : int [1:6] 1 2 3 4 5 6
[17:45:19.637]  $ ...future.seeds_ii       : NULL
[17:45:19.637]  $ ...future.globals.maxSize: NULL
[17:45:19.637]  - attr(*, "where")=List of 11
[17:45:19.637]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.637]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.637]  - attr(*, "resolved")= logi FALSE
[17:45:19.637]  - attr(*, "total_size")= num 141240
[17:45:19.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.637]  - attr(*, "already-done")= logi TRUE
[17:45:19.648] - copied ‘...future.FUN’ to environment
[17:45:19.648] - copied ‘x_FUN’ to environment
[17:45:19.648] - copied ‘times’ to environment
[17:45:19.648] - copied ‘stopf’ to environment
[17:45:19.648] - copied ‘stop_if_not’ to environment
[17:45:19.648] - copied ‘dim’ to environment
[17:45:19.648] - copied ‘valid_types’ to environment
[17:45:19.648] - copied ‘future.call.arguments’ to environment
[17:45:19.648] - copied ‘...future.elements_ii’ to environment
[17:45:19.649] - copied ‘...future.seeds_ii’ to environment
[17:45:19.649] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.649] assign_globals() ... done
[17:45:19.649] requestCore(): workers = 2
[17:45:19.651] MulticoreFuture started
[17:45:19.652] - Launch lazy future ... done
[17:45:19.652] run() for ‘MulticoreFuture’ ... done
[17:45:19.653] Created future:
[17:45:19.654] plan(): Setting new future strategy stack:
[17:45:19.654] List of future strategies:
[17:45:19.654] 1. sequential:
[17:45:19.654]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.654]    - tweaked: FALSE
[17:45:19.654]    - call: NULL
[17:45:19.656] plan(): nbrOfWorkers() = 1
[17:45:19.659] plan(): Setting new future strategy stack:
[17:45:19.660] List of future strategies:
[17:45:19.660] 1. multicore:
[17:45:19.660]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.660]    - tweaked: FALSE
[17:45:19.660]    - call: plan(strategy)
[17:45:19.665] plan(): nbrOfWorkers() = 2
[17:45:19.653] MulticoreFuture:
[17:45:19.653] Label: ‘future_vapply-1’
[17:45:19.653] Expression:
[17:45:19.653] {
[17:45:19.653]     do.call(function(...) {
[17:45:19.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.653]             on.exit(options(oopts), add = TRUE)
[17:45:19.653]         }
[17:45:19.653]         {
[17:45:19.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.653]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.653]             })
[17:45:19.653]         }
[17:45:19.653]     }, args = future.call.arguments)
[17:45:19.653] }
[17:45:19.653] Lazy evaluation: FALSE
[17:45:19.653] Asynchronous evaluation: TRUE
[17:45:19.653] Local evaluation: TRUE
[17:45:19.653] Environment: R_GlobalEnv
[17:45:19.653] Capture standard output: TRUE
[17:45:19.653] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.653] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.653] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:19.653] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.653] Resolved: TRUE
[17:45:19.653] Value: <not collected>
[17:45:19.653] Conditions captured: <none>
[17:45:19.653] Early signaling: FALSE
[17:45:19.653] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.653] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.666] Chunk #1 of 2 ... DONE
[17:45:19.667] Chunk #2 of 2 ...
[17:45:19.667]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.667] getGlobalsAndPackages() ...
[17:45:19.667] Searching for globals...
[17:45:19.668] 
[17:45:19.668] Searching for globals ... DONE
[17:45:19.668] - globals: [0] <none>
[17:45:19.668] getGlobalsAndPackages() ... DONE
[17:45:19.668]    + additional globals found: [n=0] 
[17:45:19.669]    + additional namespaces needed: [n=0] 
[17:45:19.669]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.669]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.669]  - seeds: <none>
[17:45:19.669]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.669] getGlobalsAndPackages() ...
[17:45:19.669] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.670] Resolving globals: FALSE
[17:45:19.670] Tweak future expression to call with '...' arguments ...
[17:45:19.670] {
[17:45:19.670]     do.call(function(...) {
[17:45:19.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.670]             on.exit(options(oopts), add = TRUE)
[17:45:19.670]         }
[17:45:19.670]         {
[17:45:19.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.670]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.670]             })
[17:45:19.670]         }
[17:45:19.670]     }, args = future.call.arguments)
[17:45:19.670] }
[17:45:19.671] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.671] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.672] - packages: [2] ‘stats’, ‘future.apply’
[17:45:19.672] getGlobalsAndPackages() ... DONE
[17:45:19.672] run() for ‘Future’ ...
[17:45:19.672] - state: ‘created’
[17:45:19.673] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.677] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.677] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.677]   - Field: ‘label’
[17:45:19.677]   - Field: ‘local’
[17:45:19.677]   - Field: ‘owner’
[17:45:19.678]   - Field: ‘envir’
[17:45:19.678]   - Field: ‘workers’
[17:45:19.678]   - Field: ‘packages’
[17:45:19.678]   - Field: ‘gc’
[17:45:19.678]   - Field: ‘job’
[17:45:19.678]   - Field: ‘conditions’
[17:45:19.678]   - Field: ‘expr’
[17:45:19.678]   - Field: ‘uuid’
[17:45:19.679]   - Field: ‘seed’
[17:45:19.679]   - Field: ‘version’
[17:45:19.679]   - Field: ‘result’
[17:45:19.679]   - Field: ‘asynchronous’
[17:45:19.679]   - Field: ‘calls’
[17:45:19.679]   - Field: ‘globals’
[17:45:19.679]   - Field: ‘stdout’
[17:45:19.680]   - Field: ‘earlySignal’
[17:45:19.680]   - Field: ‘lazy’
[17:45:19.680]   - Field: ‘state’
[17:45:19.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.680] - Launch lazy future ...
[17:45:19.680] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:19.681] Packages needed by future strategies (n = 0): <none>
[17:45:19.681] {
[17:45:19.681]     {
[17:45:19.681]         {
[17:45:19.681]             ...future.startTime <- base::Sys.time()
[17:45:19.681]             {
[17:45:19.681]                 {
[17:45:19.681]                   {
[17:45:19.681]                     {
[17:45:19.681]                       {
[17:45:19.681]                         base::local({
[17:45:19.681]                           has_future <- base::requireNamespace("future", 
[17:45:19.681]                             quietly = TRUE)
[17:45:19.681]                           if (has_future) {
[17:45:19.681]                             ns <- base::getNamespace("future")
[17:45:19.681]                             version <- ns[[".package"]][["version"]]
[17:45:19.681]                             if (is.null(version)) 
[17:45:19.681]                               version <- utils::packageVersion("future")
[17:45:19.681]                           }
[17:45:19.681]                           else {
[17:45:19.681]                             version <- NULL
[17:45:19.681]                           }
[17:45:19.681]                           if (!has_future || version < "1.8.0") {
[17:45:19.681]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.681]                               "", base::R.version$version.string), 
[17:45:19.681]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.681]                                 base::R.version$platform, 8 * 
[17:45:19.681]                                   base::.Machine$sizeof.pointer), 
[17:45:19.681]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.681]                                 "release", "version")], collapse = " "), 
[17:45:19.681]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.681]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.681]                               info)
[17:45:19.681]                             info <- base::paste(info, collapse = "; ")
[17:45:19.681]                             if (!has_future) {
[17:45:19.681]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.681]                                 info)
[17:45:19.681]                             }
[17:45:19.681]                             else {
[17:45:19.681]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.681]                                 info, version)
[17:45:19.681]                             }
[17:45:19.681]                             base::stop(msg)
[17:45:19.681]                           }
[17:45:19.681]                         })
[17:45:19.681]                       }
[17:45:19.681]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.681]                       base::options(mc.cores = 1L)
[17:45:19.681]                     }
[17:45:19.681]                     base::local({
[17:45:19.681]                       for (pkg in c("stats", "future.apply")) {
[17:45:19.681]                         base::loadNamespace(pkg)
[17:45:19.681]                         base::library(pkg, character.only = TRUE)
[17:45:19.681]                       }
[17:45:19.681]                     })
[17:45:19.681]                   }
[17:45:19.681]                   ...future.strategy.old <- future::plan("list")
[17:45:19.681]                   options(future.plan = NULL)
[17:45:19.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.681]                 }
[17:45:19.681]                 ...future.workdir <- getwd()
[17:45:19.681]             }
[17:45:19.681]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.681]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.681]         }
[17:45:19.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.681]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.681]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.681]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.681]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.681]             base::names(...future.oldOptions))
[17:45:19.681]     }
[17:45:19.681]     if (FALSE) {
[17:45:19.681]     }
[17:45:19.681]     else {
[17:45:19.681]         if (TRUE) {
[17:45:19.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.681]                 open = "w")
[17:45:19.681]         }
[17:45:19.681]         else {
[17:45:19.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.681]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.681]         }
[17:45:19.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.681]             base::sink(type = "output", split = FALSE)
[17:45:19.681]             base::close(...future.stdout)
[17:45:19.681]         }, add = TRUE)
[17:45:19.681]     }
[17:45:19.681]     ...future.frame <- base::sys.nframe()
[17:45:19.681]     ...future.conditions <- base::list()
[17:45:19.681]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.681]     if (FALSE) {
[17:45:19.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.681]     }
[17:45:19.681]     ...future.result <- base::tryCatch({
[17:45:19.681]         base::withCallingHandlers({
[17:45:19.681]             ...future.value <- base::withVisible(base::local({
[17:45:19.681]                 withCallingHandlers({
[17:45:19.681]                   {
[17:45:19.681]                     do.call(function(...) {
[17:45:19.681]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.681]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.681]                         ...future.globals.maxSize)) {
[17:45:19.681]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.681]                         on.exit(options(oopts), add = TRUE)
[17:45:19.681]                       }
[17:45:19.681]                       {
[17:45:19.681]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.681]                           FUN = function(jj) {
[17:45:19.681]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.681]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.681]                           })
[17:45:19.681]                       }
[17:45:19.681]                     }, args = future.call.arguments)
[17:45:19.681]                   }
[17:45:19.681]                 }, immediateCondition = function(cond) {
[17:45:19.681]                   save_rds <- function (object, pathname, ...) 
[17:45:19.681]                   {
[17:45:19.681]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.681]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.681]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.681]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.681]                         fi_tmp[["mtime"]])
[17:45:19.681]                     }
[17:45:19.681]                     tryCatch({
[17:45:19.681]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.681]                     }, error = function(ex) {
[17:45:19.681]                       msg <- conditionMessage(ex)
[17:45:19.681]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.681]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.681]                         fi_tmp[["mtime"]], msg)
[17:45:19.681]                       ex$message <- msg
[17:45:19.681]                       stop(ex)
[17:45:19.681]                     })
[17:45:19.681]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.681]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.681]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.681]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.681]                       fi <- file.info(pathname)
[17:45:19.681]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.681]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.681]                         fi[["size"]], fi[["mtime"]])
[17:45:19.681]                       stop(msg)
[17:45:19.681]                     }
[17:45:19.681]                     invisible(pathname)
[17:45:19.681]                   }
[17:45:19.681]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.681]                     rootPath = tempdir()) 
[17:45:19.681]                   {
[17:45:19.681]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.681]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.681]                       tmpdir = path, fileext = ".rds")
[17:45:19.681]                     save_rds(obj, file)
[17:45:19.681]                   }
[17:45:19.681]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.681]                   {
[17:45:19.681]                     inherits <- base::inherits
[17:45:19.681]                     invokeRestart <- base::invokeRestart
[17:45:19.681]                     is.null <- base::is.null
[17:45:19.681]                     muffled <- FALSE
[17:45:19.681]                     if (inherits(cond, "message")) {
[17:45:19.681]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.681]                       if (muffled) 
[17:45:19.681]                         invokeRestart("muffleMessage")
[17:45:19.681]                     }
[17:45:19.681]                     else if (inherits(cond, "warning")) {
[17:45:19.681]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.681]                       if (muffled) 
[17:45:19.681]                         invokeRestart("muffleWarning")
[17:45:19.681]                     }
[17:45:19.681]                     else if (inherits(cond, "condition")) {
[17:45:19.681]                       if (!is.null(pattern)) {
[17:45:19.681]                         computeRestarts <- base::computeRestarts
[17:45:19.681]                         grepl <- base::grepl
[17:45:19.681]                         restarts <- computeRestarts(cond)
[17:45:19.681]                         for (restart in restarts) {
[17:45:19.681]                           name <- restart$name
[17:45:19.681]                           if (is.null(name)) 
[17:45:19.681]                             next
[17:45:19.681]                           if (!grepl(pattern, name)) 
[17:45:19.681]                             next
[17:45:19.681]                           invokeRestart(restart)
[17:45:19.681]                           muffled <- TRUE
[17:45:19.681]                           break
[17:45:19.681]                         }
[17:45:19.681]                       }
[17:45:19.681]                     }
[17:45:19.681]                     invisible(muffled)
[17:45:19.681]                   }
[17:45:19.681]                   muffleCondition(cond)
[17:45:19.681]                 })
[17:45:19.681]             }))
[17:45:19.681]             future::FutureResult(value = ...future.value$value, 
[17:45:19.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.681]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.681]                     ...future.globalenv.names))
[17:45:19.681]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.681]         }, condition = base::local({
[17:45:19.681]             c <- base::c
[17:45:19.681]             inherits <- base::inherits
[17:45:19.681]             invokeRestart <- base::invokeRestart
[17:45:19.681]             length <- base::length
[17:45:19.681]             list <- base::list
[17:45:19.681]             seq.int <- base::seq.int
[17:45:19.681]             signalCondition <- base::signalCondition
[17:45:19.681]             sys.calls <- base::sys.calls
[17:45:19.681]             `[[` <- base::`[[`
[17:45:19.681]             `+` <- base::`+`
[17:45:19.681]             `<<-` <- base::`<<-`
[17:45:19.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.681]                   3L)]
[17:45:19.681]             }
[17:45:19.681]             function(cond) {
[17:45:19.681]                 is_error <- inherits(cond, "error")
[17:45:19.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.681]                   NULL)
[17:45:19.681]                 if (is_error) {
[17:45:19.681]                   sessionInformation <- function() {
[17:45:19.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.681]                       search = base::search(), system = base::Sys.info())
[17:45:19.681]                   }
[17:45:19.681]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.681]                     cond$call), session = sessionInformation(), 
[17:45:19.681]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.681]                   signalCondition(cond)
[17:45:19.681]                 }
[17:45:19.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.681]                 "immediateCondition"))) {
[17:45:19.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.681]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.681]                   if (TRUE && !signal) {
[17:45:19.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.681]                     {
[17:45:19.681]                       inherits <- base::inherits
[17:45:19.681]                       invokeRestart <- base::invokeRestart
[17:45:19.681]                       is.null <- base::is.null
[17:45:19.681]                       muffled <- FALSE
[17:45:19.681]                       if (inherits(cond, "message")) {
[17:45:19.681]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.681]                         if (muffled) 
[17:45:19.681]                           invokeRestart("muffleMessage")
[17:45:19.681]                       }
[17:45:19.681]                       else if (inherits(cond, "warning")) {
[17:45:19.681]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.681]                         if (muffled) 
[17:45:19.681]                           invokeRestart("muffleWarning")
[17:45:19.681]                       }
[17:45:19.681]                       else if (inherits(cond, "condition")) {
[17:45:19.681]                         if (!is.null(pattern)) {
[17:45:19.681]                           computeRestarts <- base::computeRestarts
[17:45:19.681]                           grepl <- base::grepl
[17:45:19.681]                           restarts <- computeRestarts(cond)
[17:45:19.681]                           for (restart in restarts) {
[17:45:19.681]                             name <- restart$name
[17:45:19.681]                             if (is.null(name)) 
[17:45:19.681]                               next
[17:45:19.681]                             if (!grepl(pattern, name)) 
[17:45:19.681]                               next
[17:45:19.681]                             invokeRestart(restart)
[17:45:19.681]                             muffled <- TRUE
[17:45:19.681]                             break
[17:45:19.681]                           }
[17:45:19.681]                         }
[17:45:19.681]                       }
[17:45:19.681]                       invisible(muffled)
[17:45:19.681]                     }
[17:45:19.681]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.681]                   }
[17:45:19.681]                 }
[17:45:19.681]                 else {
[17:45:19.681]                   if (TRUE) {
[17:45:19.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.681]                     {
[17:45:19.681]                       inherits <- base::inherits
[17:45:19.681]                       invokeRestart <- base::invokeRestart
[17:45:19.681]                       is.null <- base::is.null
[17:45:19.681]                       muffled <- FALSE
[17:45:19.681]                       if (inherits(cond, "message")) {
[17:45:19.681]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.681]                         if (muffled) 
[17:45:19.681]                           invokeRestart("muffleMessage")
[17:45:19.681]                       }
[17:45:19.681]                       else if (inherits(cond, "warning")) {
[17:45:19.681]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.681]                         if (muffled) 
[17:45:19.681]                           invokeRestart("muffleWarning")
[17:45:19.681]                       }
[17:45:19.681]                       else if (inherits(cond, "condition")) {
[17:45:19.681]                         if (!is.null(pattern)) {
[17:45:19.681]                           computeRestarts <- base::computeRestarts
[17:45:19.681]                           grepl <- base::grepl
[17:45:19.681]                           restarts <- computeRestarts(cond)
[17:45:19.681]                           for (restart in restarts) {
[17:45:19.681]                             name <- restart$name
[17:45:19.681]                             if (is.null(name)) 
[17:45:19.681]                               next
[17:45:19.681]                             if (!grepl(pattern, name)) 
[17:45:19.681]                               next
[17:45:19.681]                             invokeRestart(restart)
[17:45:19.681]                             muffled <- TRUE
[17:45:19.681]                             break
[17:45:19.681]                           }
[17:45:19.681]                         }
[17:45:19.681]                       }
[17:45:19.681]                       invisible(muffled)
[17:45:19.681]                     }
[17:45:19.681]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.681]                   }
[17:45:19.681]                 }
[17:45:19.681]             }
[17:45:19.681]         }))
[17:45:19.681]     }, error = function(ex) {
[17:45:19.681]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.681]                 ...future.rng), started = ...future.startTime, 
[17:45:19.681]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.681]             version = "1.8"), class = "FutureResult")
[17:45:19.681]     }, finally = {
[17:45:19.681]         if (!identical(...future.workdir, getwd())) 
[17:45:19.681]             setwd(...future.workdir)
[17:45:19.681]         {
[17:45:19.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.681]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.681]             }
[17:45:19.681]             base::options(...future.oldOptions)
[17:45:19.681]             if (.Platform$OS.type == "windows") {
[17:45:19.681]                 old_names <- names(...future.oldEnvVars)
[17:45:19.681]                 envs <- base::Sys.getenv()
[17:45:19.681]                 names <- names(envs)
[17:45:19.681]                 common <- intersect(names, old_names)
[17:45:19.681]                 added <- setdiff(names, old_names)
[17:45:19.681]                 removed <- setdiff(old_names, names)
[17:45:19.681]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.681]                   envs[common]]
[17:45:19.681]                 NAMES <- toupper(changed)
[17:45:19.681]                 args <- list()
[17:45:19.681]                 for (kk in seq_along(NAMES)) {
[17:45:19.681]                   name <- changed[[kk]]
[17:45:19.681]                   NAME <- NAMES[[kk]]
[17:45:19.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.681]                     next
[17:45:19.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.681]                 }
[17:45:19.681]                 NAMES <- toupper(added)
[17:45:19.681]                 for (kk in seq_along(NAMES)) {
[17:45:19.681]                   name <- added[[kk]]
[17:45:19.681]                   NAME <- NAMES[[kk]]
[17:45:19.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.681]                     next
[17:45:19.681]                   args[[name]] <- ""
[17:45:19.681]                 }
[17:45:19.681]                 NAMES <- toupper(removed)
[17:45:19.681]                 for (kk in seq_along(NAMES)) {
[17:45:19.681]                   name <- removed[[kk]]
[17:45:19.681]                   NAME <- NAMES[[kk]]
[17:45:19.681]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.681]                     next
[17:45:19.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.681]                 }
[17:45:19.681]                 if (length(args) > 0) 
[17:45:19.681]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.681]             }
[17:45:19.681]             else {
[17:45:19.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.681]             }
[17:45:19.681]             {
[17:45:19.681]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.681]                   0L) {
[17:45:19.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.681]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.681]                   base::options(opts)
[17:45:19.681]                 }
[17:45:19.681]                 {
[17:45:19.681]                   {
[17:45:19.681]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.681]                     NULL
[17:45:19.681]                   }
[17:45:19.681]                   options(future.plan = NULL)
[17:45:19.681]                   if (is.na(NA_character_)) 
[17:45:19.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.681]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.681]                     .init = FALSE)
[17:45:19.681]                 }
[17:45:19.681]             }
[17:45:19.681]         }
[17:45:19.681]     })
[17:45:19.681]     if (TRUE) {
[17:45:19.681]         base::sink(type = "output", split = FALSE)
[17:45:19.681]         if (TRUE) {
[17:45:19.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.681]         }
[17:45:19.681]         else {
[17:45:19.681]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.681]         }
[17:45:19.681]         base::close(...future.stdout)
[17:45:19.681]         ...future.stdout <- NULL
[17:45:19.681]     }
[17:45:19.681]     ...future.result$conditions <- ...future.conditions
[17:45:19.681]     ...future.result$finished <- base::Sys.time()
[17:45:19.681]     ...future.result
[17:45:19.681] }
[17:45:19.685] assign_globals() ...
[17:45:19.685] List of 11
[17:45:19.685]  $ ...future.FUN            :function (x, ...)  
[17:45:19.685]  $ x_FUN                    :function (x, na.rm = TRUE)  
[17:45:19.685]  $ times                    : int 5
[17:45:19.685]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.685]  $ stop_if_not              :function (...)  
[17:45:19.685]  $ dim                      : NULL
[17:45:19.685]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.685]  $ future.call.arguments    : list()
[17:45:19.685]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.685]  $ ...future.elements_ii    :List of 3
[17:45:19.685]   ..$ : int [1:7] 1 2 3 4 5 6 7
[17:45:19.685]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[17:45:19.685]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[17:45:19.685]  $ ...future.seeds_ii       : NULL
[17:45:19.685]  $ ...future.globals.maxSize: NULL
[17:45:19.685]  - attr(*, "where")=List of 11
[17:45:19.685]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.685]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.685]  - attr(*, "resolved")= logi FALSE
[17:45:19.685]  - attr(*, "total_size")= num 141240
[17:45:19.685]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.685]  - attr(*, "already-done")= logi TRUE
[17:45:19.698] - copied ‘...future.FUN’ to environment
[17:45:19.698] - copied ‘x_FUN’ to environment
[17:45:19.699] - copied ‘times’ to environment
[17:45:19.699] - copied ‘stopf’ to environment
[17:45:19.699] - copied ‘stop_if_not’ to environment
[17:45:19.699] - copied ‘dim’ to environment
[17:45:19.699] - copied ‘valid_types’ to environment
[17:45:19.699] - copied ‘future.call.arguments’ to environment
[17:45:19.699] - copied ‘...future.elements_ii’ to environment
[17:45:19.699] - copied ‘...future.seeds_ii’ to environment
[17:45:19.700] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.700] assign_globals() ... done
[17:45:19.700] requestCore(): workers = 2
[17:45:19.702] MulticoreFuture started
[17:45:19.703] - Launch lazy future ... done
[17:45:19.704] run() for ‘MulticoreFuture’ ... done
[17:45:19.704] Created future:
[17:45:19.705] plan(): Setting new future strategy stack:
[17:45:19.705] List of future strategies:
[17:45:19.705] 1. sequential:
[17:45:19.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.705]    - tweaked: FALSE
[17:45:19.705]    - call: NULL
[17:45:19.707] plan(): nbrOfWorkers() = 1
[17:45:19.709] plan(): Setting new future strategy stack:
[17:45:19.710] List of future strategies:
[17:45:19.710] 1. multicore:
[17:45:19.710]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.710]    - tweaked: FALSE
[17:45:19.710]    - call: plan(strategy)
[17:45:19.715] plan(): nbrOfWorkers() = 2
[17:45:19.704] MulticoreFuture:
[17:45:19.704] Label: ‘future_vapply-2’
[17:45:19.704] Expression:
[17:45:19.704] {
[17:45:19.704]     do.call(function(...) {
[17:45:19.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.704]             on.exit(options(oopts), add = TRUE)
[17:45:19.704]         }
[17:45:19.704]         {
[17:45:19.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.704]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.704]             })
[17:45:19.704]         }
[17:45:19.704]     }, args = future.call.arguments)
[17:45:19.704] }
[17:45:19.704] Lazy evaluation: FALSE
[17:45:19.704] Asynchronous evaluation: TRUE
[17:45:19.704] Local evaluation: TRUE
[17:45:19.704] Environment: R_GlobalEnv
[17:45:19.704] Capture standard output: TRUE
[17:45:19.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.704] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.704] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:19.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.704] Resolved: TRUE
[17:45:19.704] Value: <not collected>
[17:45:19.704] Conditions captured: <none>
[17:45:19.704] Early signaling: FALSE
[17:45:19.704] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.704] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.716] Chunk #2 of 2 ... DONE
[17:45:19.716] Launching 2 futures (chunks) ... DONE
[17:45:19.716] Resolving 2 futures (chunks) ...
[17:45:19.717] resolve() on list ...
[17:45:19.717]  recursive: 0
[17:45:19.717]  length: 2
[17:45:19.717] 
[17:45:19.717] Future #1
[17:45:19.718] result() for MulticoreFuture ...
[17:45:19.718] result() for MulticoreFuture ...
[17:45:19.719] result() for MulticoreFuture ... done
[17:45:19.719] result() for MulticoreFuture ... done
[17:45:19.719] result() for MulticoreFuture ...
[17:45:19.719] result() for MulticoreFuture ... done
[17:45:19.719] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.719] - nx: 2
[17:45:19.719] - relay: TRUE
[17:45:19.720] - stdout: TRUE
[17:45:19.720] - signal: TRUE
[17:45:19.720] - resignal: FALSE
[17:45:19.720] - force: TRUE
[17:45:19.720] - relayed: [n=2] FALSE, FALSE
[17:45:19.720] - queued futures: [n=2] FALSE, FALSE
[17:45:19.720]  - until=1
[17:45:19.721]  - relaying element #1
[17:45:19.721] result() for MulticoreFuture ...
[17:45:19.721] result() for MulticoreFuture ... done
[17:45:19.721] result() for MulticoreFuture ...
[17:45:19.721] result() for MulticoreFuture ... done
[17:45:19.721] result() for MulticoreFuture ...
[17:45:19.721] result() for MulticoreFuture ... done
[17:45:19.722] result() for MulticoreFuture ...
[17:45:19.722] result() for MulticoreFuture ... done
[17:45:19.722] - relayed: [n=2] TRUE, FALSE
[17:45:19.722] - queued futures: [n=2] TRUE, FALSE
[17:45:19.722] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.722]  length: 1 (resolved future 1)
[17:45:19.723] Future #2
[17:45:19.723] result() for MulticoreFuture ...
[17:45:19.724] result() for MulticoreFuture ...
[17:45:19.724] result() for MulticoreFuture ... done
[17:45:19.724] result() for MulticoreFuture ... done
[17:45:19.724] result() for MulticoreFuture ...
[17:45:19.724] result() for MulticoreFuture ... done
[17:45:19.724] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.724] - nx: 2
[17:45:19.724] - relay: TRUE
[17:45:19.725] - stdout: TRUE
[17:45:19.725] - signal: TRUE
[17:45:19.725] - resignal: FALSE
[17:45:19.725] - force: TRUE
[17:45:19.725] - relayed: [n=2] TRUE, FALSE
[17:45:19.725] - queued futures: [n=2] TRUE, FALSE
[17:45:19.725]  - until=2
[17:45:19.725]  - relaying element #2
[17:45:19.725] result() for MulticoreFuture ...
[17:45:19.726] result() for MulticoreFuture ... done
[17:45:19.726] result() for MulticoreFuture ...
[17:45:19.726] result() for MulticoreFuture ... done
[17:45:19.726] result() for MulticoreFuture ...
[17:45:19.726] result() for MulticoreFuture ... done
[17:45:19.726] result() for MulticoreFuture ...
[17:45:19.726] result() for MulticoreFuture ... done
[17:45:19.726] - relayed: [n=2] TRUE, TRUE
[17:45:19.726] - queued futures: [n=2] TRUE, TRUE
[17:45:19.727] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.727]  length: 0 (resolved future 2)
[17:45:19.727] Relaying remaining futures
[17:45:19.727] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.727] - nx: 2
[17:45:19.727] - relay: TRUE
[17:45:19.727] - stdout: TRUE
[17:45:19.727] - signal: TRUE
[17:45:19.727] - resignal: FALSE
[17:45:19.728] - force: TRUE
[17:45:19.728] - relayed: [n=2] TRUE, TRUE
[17:45:19.728] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.728] - relayed: [n=2] TRUE, TRUE
[17:45:19.728] - queued futures: [n=2] TRUE, TRUE
[17:45:19.728] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.728] resolve() on list ... DONE
[17:45:19.728] result() for MulticoreFuture ...
[17:45:19.728] result() for MulticoreFuture ... done
[17:45:19.729] result() for MulticoreFuture ...
[17:45:19.729] result() for MulticoreFuture ... done
[17:45:19.729] result() for MulticoreFuture ...
[17:45:19.729] result() for MulticoreFuture ... done
[17:45:19.729] result() for MulticoreFuture ...
[17:45:19.729] result() for MulticoreFuture ... done
[17:45:19.729]  - Number of value chunks collected: 2
[17:45:19.729] Resolving 2 futures (chunks) ... DONE
[17:45:19.729] Reducing values from 2 chunks ...
[17:45:19.730]  - Number of values collected after concatenation: 7
[17:45:19.730]  - Number of values expected: 7
[17:45:19.730] Reducing values from 2 chunks ... DONE
[17:45:19.730] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:45:19.732] future_lapply() ...
[17:45:19.737] Number of chunks: 2
[17:45:19.737] getGlobalsAndPackagesXApply() ...
[17:45:19.737]  - future.globals: TRUE
[17:45:19.737] getGlobalsAndPackages() ...
[17:45:19.737] Searching for globals...
[17:45:19.741] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:45:19.741] Searching for globals ... DONE
[17:45:19.742] Resolving globals: FALSE
[17:45:19.742] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:45:19.743] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:45:19.743] - globals: [1] ‘FUN’
[17:45:19.743] 
[17:45:19.743] getGlobalsAndPackages() ... DONE
[17:45:19.743]  - globals found/used: [n=1] ‘FUN’
[17:45:19.743]  - needed namespaces: [n=0] 
[17:45:19.743] Finding globals ... DONE
[17:45:19.744]  - use_args: TRUE
[17:45:19.744]  - Getting '...' globals ...
[17:45:19.744] resolve() on list ...
[17:45:19.744]  recursive: 0
[17:45:19.744]  length: 1
[17:45:19.745]  elements: ‘...’
[17:45:19.745]  length: 0 (resolved future 1)
[17:45:19.745] resolve() on list ... DONE
[17:45:19.745]    - '...' content: [n=1] ‘y’
[17:45:19.745] List of 1
[17:45:19.745]  $ ...:List of 1
[17:45:19.745]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.745]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.745]  - attr(*, "where")=List of 1
[17:45:19.745]   ..$ ...:<environment: 0x5561f53ccbe8> 
[17:45:19.745]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.745]  - attr(*, "resolved")= logi TRUE
[17:45:19.745]  - attr(*, "total_size")= num NA
[17:45:19.748]  - Getting '...' globals ... DONE
[17:45:19.749] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:19.749] List of 2
[17:45:19.749]  $ ...future.FUN:function (x, y)  
[17:45:19.749]  $ ...          :List of 1
[17:45:19.749]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.749]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.749]  - attr(*, "where")=List of 2
[17:45:19.749]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.749]   ..$ ...          :<environment: 0x5561f53ccbe8> 
[17:45:19.749]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.749]  - attr(*, "resolved")= logi FALSE
[17:45:19.749]  - attr(*, "total_size")= num 4264
[17:45:19.752] Packages to be attached in all futures: [n=0] 
[17:45:19.752] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.752] Number of futures (= number of chunks): 2
[17:45:19.752] Launching 2 futures (chunks) ...
[17:45:19.752] Chunk #1 of 2 ...
[17:45:19.752]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.753] getGlobalsAndPackages() ...
[17:45:19.753] Searching for globals...
[17:45:19.753] 
[17:45:19.753] Searching for globals ... DONE
[17:45:19.753] - globals: [0] <none>
[17:45:19.753] getGlobalsAndPackages() ... DONE
[17:45:19.753]    + additional globals found: [n=0] 
[17:45:19.753]    + additional namespaces needed: [n=0] 
[17:45:19.753]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.754]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.754]  - seeds: <none>
[17:45:19.754]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.754] getGlobalsAndPackages() ...
[17:45:19.754] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.754] Resolving globals: FALSE
[17:45:19.754] Tweak future expression to call with '...' arguments ...
[17:45:19.754] {
[17:45:19.754]     do.call(function(...) {
[17:45:19.754]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.754]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.754]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.754]             on.exit(options(oopts), add = TRUE)
[17:45:19.754]         }
[17:45:19.754]         {
[17:45:19.754]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.754]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.754]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.754]             })
[17:45:19.754]         }
[17:45:19.754]     }, args = future.call.arguments)
[17:45:19.754] }
[17:45:19.755] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.755] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.755] 
[17:45:19.755] getGlobalsAndPackages() ... DONE
[17:45:19.755] run() for ‘Future’ ...
[17:45:19.756] - state: ‘created’
[17:45:19.756] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.759] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.759]   - Field: ‘label’
[17:45:19.760]   - Field: ‘local’
[17:45:19.760]   - Field: ‘owner’
[17:45:19.760]   - Field: ‘envir’
[17:45:19.760]   - Field: ‘workers’
[17:45:19.760]   - Field: ‘packages’
[17:45:19.760]   - Field: ‘gc’
[17:45:19.760]   - Field: ‘job’
[17:45:19.760]   - Field: ‘conditions’
[17:45:19.760]   - Field: ‘expr’
[17:45:19.760]   - Field: ‘uuid’
[17:45:19.760]   - Field: ‘seed’
[17:45:19.761]   - Field: ‘version’
[17:45:19.761]   - Field: ‘result’
[17:45:19.761]   - Field: ‘asynchronous’
[17:45:19.761]   - Field: ‘calls’
[17:45:19.761]   - Field: ‘globals’
[17:45:19.761]   - Field: ‘stdout’
[17:45:19.761]   - Field: ‘earlySignal’
[17:45:19.761]   - Field: ‘lazy’
[17:45:19.761]   - Field: ‘state’
[17:45:19.761] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.762] - Launch lazy future ...
[17:45:19.762] Packages needed by the future expression (n = 0): <none>
[17:45:19.762] Packages needed by future strategies (n = 0): <none>
[17:45:19.762] {
[17:45:19.762]     {
[17:45:19.762]         {
[17:45:19.762]             ...future.startTime <- base::Sys.time()
[17:45:19.762]             {
[17:45:19.762]                 {
[17:45:19.762]                   {
[17:45:19.762]                     {
[17:45:19.762]                       base::local({
[17:45:19.762]                         has_future <- base::requireNamespace("future", 
[17:45:19.762]                           quietly = TRUE)
[17:45:19.762]                         if (has_future) {
[17:45:19.762]                           ns <- base::getNamespace("future")
[17:45:19.762]                           version <- ns[[".package"]][["version"]]
[17:45:19.762]                           if (is.null(version)) 
[17:45:19.762]                             version <- utils::packageVersion("future")
[17:45:19.762]                         }
[17:45:19.762]                         else {
[17:45:19.762]                           version <- NULL
[17:45:19.762]                         }
[17:45:19.762]                         if (!has_future || version < "1.8.0") {
[17:45:19.762]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.762]                             "", base::R.version$version.string), 
[17:45:19.762]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:19.762]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:19.762]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.762]                               "release", "version")], collapse = " "), 
[17:45:19.762]                             hostname = base::Sys.info()[["nodename"]])
[17:45:19.762]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.762]                             info)
[17:45:19.762]                           info <- base::paste(info, collapse = "; ")
[17:45:19.762]                           if (!has_future) {
[17:45:19.762]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.762]                               info)
[17:45:19.762]                           }
[17:45:19.762]                           else {
[17:45:19.762]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.762]                               info, version)
[17:45:19.762]                           }
[17:45:19.762]                           base::stop(msg)
[17:45:19.762]                         }
[17:45:19.762]                       })
[17:45:19.762]                     }
[17:45:19.762]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.762]                     base::options(mc.cores = 1L)
[17:45:19.762]                   }
[17:45:19.762]                   ...future.strategy.old <- future::plan("list")
[17:45:19.762]                   options(future.plan = NULL)
[17:45:19.762]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.762]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.762]                 }
[17:45:19.762]                 ...future.workdir <- getwd()
[17:45:19.762]             }
[17:45:19.762]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.762]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.762]         }
[17:45:19.762]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.762]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.762]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.762]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.762]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.762]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.762]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.762]             base::names(...future.oldOptions))
[17:45:19.762]     }
[17:45:19.762]     if (FALSE) {
[17:45:19.762]     }
[17:45:19.762]     else {
[17:45:19.762]         if (TRUE) {
[17:45:19.762]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.762]                 open = "w")
[17:45:19.762]         }
[17:45:19.762]         else {
[17:45:19.762]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.762]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.762]         }
[17:45:19.762]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.762]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.762]             base::sink(type = "output", split = FALSE)
[17:45:19.762]             base::close(...future.stdout)
[17:45:19.762]         }, add = TRUE)
[17:45:19.762]     }
[17:45:19.762]     ...future.frame <- base::sys.nframe()
[17:45:19.762]     ...future.conditions <- base::list()
[17:45:19.762]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.762]     if (FALSE) {
[17:45:19.762]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.762]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.762]     }
[17:45:19.762]     ...future.result <- base::tryCatch({
[17:45:19.762]         base::withCallingHandlers({
[17:45:19.762]             ...future.value <- base::withVisible(base::local({
[17:45:19.762]                 withCallingHandlers({
[17:45:19.762]                   {
[17:45:19.762]                     do.call(function(...) {
[17:45:19.762]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.762]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.762]                         ...future.globals.maxSize)) {
[17:45:19.762]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.762]                         on.exit(options(oopts), add = TRUE)
[17:45:19.762]                       }
[17:45:19.762]                       {
[17:45:19.762]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.762]                           FUN = function(jj) {
[17:45:19.762]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.762]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.762]                           })
[17:45:19.762]                       }
[17:45:19.762]                     }, args = future.call.arguments)
[17:45:19.762]                   }
[17:45:19.762]                 }, immediateCondition = function(cond) {
[17:45:19.762]                   save_rds <- function (object, pathname, ...) 
[17:45:19.762]                   {
[17:45:19.762]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.762]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.762]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.762]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.762]                         fi_tmp[["mtime"]])
[17:45:19.762]                     }
[17:45:19.762]                     tryCatch({
[17:45:19.762]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.762]                     }, error = function(ex) {
[17:45:19.762]                       msg <- conditionMessage(ex)
[17:45:19.762]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.762]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.762]                         fi_tmp[["mtime"]], msg)
[17:45:19.762]                       ex$message <- msg
[17:45:19.762]                       stop(ex)
[17:45:19.762]                     })
[17:45:19.762]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.762]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.762]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.762]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.762]                       fi <- file.info(pathname)
[17:45:19.762]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.762]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.762]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.762]                         fi[["size"]], fi[["mtime"]])
[17:45:19.762]                       stop(msg)
[17:45:19.762]                     }
[17:45:19.762]                     invisible(pathname)
[17:45:19.762]                   }
[17:45:19.762]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.762]                     rootPath = tempdir()) 
[17:45:19.762]                   {
[17:45:19.762]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.762]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.762]                       tmpdir = path, fileext = ".rds")
[17:45:19.762]                     save_rds(obj, file)
[17:45:19.762]                   }
[17:45:19.762]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.762]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.762]                   {
[17:45:19.762]                     inherits <- base::inherits
[17:45:19.762]                     invokeRestart <- base::invokeRestart
[17:45:19.762]                     is.null <- base::is.null
[17:45:19.762]                     muffled <- FALSE
[17:45:19.762]                     if (inherits(cond, "message")) {
[17:45:19.762]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.762]                       if (muffled) 
[17:45:19.762]                         invokeRestart("muffleMessage")
[17:45:19.762]                     }
[17:45:19.762]                     else if (inherits(cond, "warning")) {
[17:45:19.762]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.762]                       if (muffled) 
[17:45:19.762]                         invokeRestart("muffleWarning")
[17:45:19.762]                     }
[17:45:19.762]                     else if (inherits(cond, "condition")) {
[17:45:19.762]                       if (!is.null(pattern)) {
[17:45:19.762]                         computeRestarts <- base::computeRestarts
[17:45:19.762]                         grepl <- base::grepl
[17:45:19.762]                         restarts <- computeRestarts(cond)
[17:45:19.762]                         for (restart in restarts) {
[17:45:19.762]                           name <- restart$name
[17:45:19.762]                           if (is.null(name)) 
[17:45:19.762]                             next
[17:45:19.762]                           if (!grepl(pattern, name)) 
[17:45:19.762]                             next
[17:45:19.762]                           invokeRestart(restart)
[17:45:19.762]                           muffled <- TRUE
[17:45:19.762]                           break
[17:45:19.762]                         }
[17:45:19.762]                       }
[17:45:19.762]                     }
[17:45:19.762]                     invisible(muffled)
[17:45:19.762]                   }
[17:45:19.762]                   muffleCondition(cond)
[17:45:19.762]                 })
[17:45:19.762]             }))
[17:45:19.762]             future::FutureResult(value = ...future.value$value, 
[17:45:19.762]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.762]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.762]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.762]                     ...future.globalenv.names))
[17:45:19.762]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.762]         }, condition = base::local({
[17:45:19.762]             c <- base::c
[17:45:19.762]             inherits <- base::inherits
[17:45:19.762]             invokeRestart <- base::invokeRestart
[17:45:19.762]             length <- base::length
[17:45:19.762]             list <- base::list
[17:45:19.762]             seq.int <- base::seq.int
[17:45:19.762]             signalCondition <- base::signalCondition
[17:45:19.762]             sys.calls <- base::sys.calls
[17:45:19.762]             `[[` <- base::`[[`
[17:45:19.762]             `+` <- base::`+`
[17:45:19.762]             `<<-` <- base::`<<-`
[17:45:19.762]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.762]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.762]                   3L)]
[17:45:19.762]             }
[17:45:19.762]             function(cond) {
[17:45:19.762]                 is_error <- inherits(cond, "error")
[17:45:19.762]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.762]                   NULL)
[17:45:19.762]                 if (is_error) {
[17:45:19.762]                   sessionInformation <- function() {
[17:45:19.762]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.762]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.762]                       search = base::search(), system = base::Sys.info())
[17:45:19.762]                   }
[17:45:19.762]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.762]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.762]                     cond$call), session = sessionInformation(), 
[17:45:19.762]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.762]                   signalCondition(cond)
[17:45:19.762]                 }
[17:45:19.762]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.762]                 "immediateCondition"))) {
[17:45:19.762]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.762]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.762]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.762]                   if (TRUE && !signal) {
[17:45:19.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.762]                     {
[17:45:19.762]                       inherits <- base::inherits
[17:45:19.762]                       invokeRestart <- base::invokeRestart
[17:45:19.762]                       is.null <- base::is.null
[17:45:19.762]                       muffled <- FALSE
[17:45:19.762]                       if (inherits(cond, "message")) {
[17:45:19.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.762]                         if (muffled) 
[17:45:19.762]                           invokeRestart("muffleMessage")
[17:45:19.762]                       }
[17:45:19.762]                       else if (inherits(cond, "warning")) {
[17:45:19.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.762]                         if (muffled) 
[17:45:19.762]                           invokeRestart("muffleWarning")
[17:45:19.762]                       }
[17:45:19.762]                       else if (inherits(cond, "condition")) {
[17:45:19.762]                         if (!is.null(pattern)) {
[17:45:19.762]                           computeRestarts <- base::computeRestarts
[17:45:19.762]                           grepl <- base::grepl
[17:45:19.762]                           restarts <- computeRestarts(cond)
[17:45:19.762]                           for (restart in restarts) {
[17:45:19.762]                             name <- restart$name
[17:45:19.762]                             if (is.null(name)) 
[17:45:19.762]                               next
[17:45:19.762]                             if (!grepl(pattern, name)) 
[17:45:19.762]                               next
[17:45:19.762]                             invokeRestart(restart)
[17:45:19.762]                             muffled <- TRUE
[17:45:19.762]                             break
[17:45:19.762]                           }
[17:45:19.762]                         }
[17:45:19.762]                       }
[17:45:19.762]                       invisible(muffled)
[17:45:19.762]                     }
[17:45:19.762]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.762]                   }
[17:45:19.762]                 }
[17:45:19.762]                 else {
[17:45:19.762]                   if (TRUE) {
[17:45:19.762]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.762]                     {
[17:45:19.762]                       inherits <- base::inherits
[17:45:19.762]                       invokeRestart <- base::invokeRestart
[17:45:19.762]                       is.null <- base::is.null
[17:45:19.762]                       muffled <- FALSE
[17:45:19.762]                       if (inherits(cond, "message")) {
[17:45:19.762]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.762]                         if (muffled) 
[17:45:19.762]                           invokeRestart("muffleMessage")
[17:45:19.762]                       }
[17:45:19.762]                       else if (inherits(cond, "warning")) {
[17:45:19.762]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.762]                         if (muffled) 
[17:45:19.762]                           invokeRestart("muffleWarning")
[17:45:19.762]                       }
[17:45:19.762]                       else if (inherits(cond, "condition")) {
[17:45:19.762]                         if (!is.null(pattern)) {
[17:45:19.762]                           computeRestarts <- base::computeRestarts
[17:45:19.762]                           grepl <- base::grepl
[17:45:19.762]                           restarts <- computeRestarts(cond)
[17:45:19.762]                           for (restart in restarts) {
[17:45:19.762]                             name <- restart$name
[17:45:19.762]                             if (is.null(name)) 
[17:45:19.762]                               next
[17:45:19.762]                             if (!grepl(pattern, name)) 
[17:45:19.762]                               next
[17:45:19.762]                             invokeRestart(restart)
[17:45:19.762]                             muffled <- TRUE
[17:45:19.762]                             break
[17:45:19.762]                           }
[17:45:19.762]                         }
[17:45:19.762]                       }
[17:45:19.762]                       invisible(muffled)
[17:45:19.762]                     }
[17:45:19.762]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.762]                   }
[17:45:19.762]                 }
[17:45:19.762]             }
[17:45:19.762]         }))
[17:45:19.762]     }, error = function(ex) {
[17:45:19.762]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.762]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.762]                 ...future.rng), started = ...future.startTime, 
[17:45:19.762]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.762]             version = "1.8"), class = "FutureResult")
[17:45:19.762]     }, finally = {
[17:45:19.762]         if (!identical(...future.workdir, getwd())) 
[17:45:19.762]             setwd(...future.workdir)
[17:45:19.762]         {
[17:45:19.762]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.762]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.762]             }
[17:45:19.762]             base::options(...future.oldOptions)
[17:45:19.762]             if (.Platform$OS.type == "windows") {
[17:45:19.762]                 old_names <- names(...future.oldEnvVars)
[17:45:19.762]                 envs <- base::Sys.getenv()
[17:45:19.762]                 names <- names(envs)
[17:45:19.762]                 common <- intersect(names, old_names)
[17:45:19.762]                 added <- setdiff(names, old_names)
[17:45:19.762]                 removed <- setdiff(old_names, names)
[17:45:19.762]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.762]                   envs[common]]
[17:45:19.762]                 NAMES <- toupper(changed)
[17:45:19.762]                 args <- list()
[17:45:19.762]                 for (kk in seq_along(NAMES)) {
[17:45:19.762]                   name <- changed[[kk]]
[17:45:19.762]                   NAME <- NAMES[[kk]]
[17:45:19.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.762]                     next
[17:45:19.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.762]                 }
[17:45:19.762]                 NAMES <- toupper(added)
[17:45:19.762]                 for (kk in seq_along(NAMES)) {
[17:45:19.762]                   name <- added[[kk]]
[17:45:19.762]                   NAME <- NAMES[[kk]]
[17:45:19.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.762]                     next
[17:45:19.762]                   args[[name]] <- ""
[17:45:19.762]                 }
[17:45:19.762]                 NAMES <- toupper(removed)
[17:45:19.762]                 for (kk in seq_along(NAMES)) {
[17:45:19.762]                   name <- removed[[kk]]
[17:45:19.762]                   NAME <- NAMES[[kk]]
[17:45:19.762]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.762]                     next
[17:45:19.762]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.762]                 }
[17:45:19.762]                 if (length(args) > 0) 
[17:45:19.762]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.762]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.762]             }
[17:45:19.762]             else {
[17:45:19.762]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.762]             }
[17:45:19.762]             {
[17:45:19.762]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.762]                   0L) {
[17:45:19.762]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.762]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.762]                   base::options(opts)
[17:45:19.762]                 }
[17:45:19.762]                 {
[17:45:19.762]                   {
[17:45:19.762]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.762]                     NULL
[17:45:19.762]                   }
[17:45:19.762]                   options(future.plan = NULL)
[17:45:19.762]                   if (is.na(NA_character_)) 
[17:45:19.762]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.762]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.762]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.762]                     .init = FALSE)
[17:45:19.762]                 }
[17:45:19.762]             }
[17:45:19.762]         }
[17:45:19.762]     })
[17:45:19.762]     if (TRUE) {
[17:45:19.762]         base::sink(type = "output", split = FALSE)
[17:45:19.762]         if (TRUE) {
[17:45:19.762]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.762]         }
[17:45:19.762]         else {
[17:45:19.762]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.762]         }
[17:45:19.762]         base::close(...future.stdout)
[17:45:19.762]         ...future.stdout <- NULL
[17:45:19.762]     }
[17:45:19.762]     ...future.result$conditions <- ...future.conditions
[17:45:19.762]     ...future.result$finished <- base::Sys.time()
[17:45:19.762]     ...future.result
[17:45:19.762] }
[17:45:19.765] assign_globals() ...
[17:45:19.767] List of 5
[17:45:19.767]  $ ...future.FUN            :function (x, y)  
[17:45:19.767]  $ future.call.arguments    :List of 1
[17:45:19.767]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.767]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.767]  $ ...future.elements_ii    :List of 2
[17:45:19.767]   ..$ A: num 50
[17:45:19.767]   ..$ B: num 60
[17:45:19.767]  $ ...future.seeds_ii       : NULL
[17:45:19.767]  $ ...future.globals.maxSize: NULL
[17:45:19.767]  - attr(*, "where")=List of 5
[17:45:19.767]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.767]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.767]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.767]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.767]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.767]  - attr(*, "resolved")= logi FALSE
[17:45:19.767]  - attr(*, "total_size")= num 4264
[17:45:19.767]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.767]  - attr(*, "already-done")= logi TRUE
[17:45:19.774] - reassign environment for ‘...future.FUN’
[17:45:19.774] - copied ‘...future.FUN’ to environment
[17:45:19.774] - copied ‘future.call.arguments’ to environment
[17:45:19.774] - copied ‘...future.elements_ii’ to environment
[17:45:19.774] - copied ‘...future.seeds_ii’ to environment
[17:45:19.774] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.774] assign_globals() ... done
[17:45:19.774] requestCore(): workers = 2
[17:45:19.777] MulticoreFuture started
[17:45:19.777] - Launch lazy future ... done
[17:45:19.777] run() for ‘MulticoreFuture’ ... done
[17:45:19.778] Created future:
[17:45:19.778] plan(): Setting new future strategy stack:
[17:45:19.778] List of future strategies:
[17:45:19.778] 1. sequential:
[17:45:19.778]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.778]    - tweaked: FALSE
[17:45:19.778]    - call: NULL
[17:45:19.779] plan(): nbrOfWorkers() = 1
[17:45:19.781] plan(): Setting new future strategy stack:
[17:45:19.781] List of future strategies:
[17:45:19.781] 1. multicore:
[17:45:19.781]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.781]    - tweaked: FALSE
[17:45:19.781]    - call: plan(strategy)
[17:45:19.786] plan(): nbrOfWorkers() = 2
[17:45:19.778] MulticoreFuture:
[17:45:19.778] Label: ‘future_sapply-1’
[17:45:19.778] Expression:
[17:45:19.778] {
[17:45:19.778]     do.call(function(...) {
[17:45:19.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.778]             on.exit(options(oopts), add = TRUE)
[17:45:19.778]         }
[17:45:19.778]         {
[17:45:19.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.778]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.778]             })
[17:45:19.778]         }
[17:45:19.778]     }, args = future.call.arguments)
[17:45:19.778] }
[17:45:19.778] Lazy evaluation: FALSE
[17:45:19.778] Asynchronous evaluation: TRUE
[17:45:19.778] Local evaluation: TRUE
[17:45:19.778] Environment: R_GlobalEnv
[17:45:19.778] Capture standard output: TRUE
[17:45:19.778] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.778] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:19.778] Packages: <none>
[17:45:19.778] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.778] Resolved: TRUE
[17:45:19.778] Value: <not collected>
[17:45:19.778] Conditions captured: <none>
[17:45:19.778] Early signaling: FALSE
[17:45:19.778] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.778] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.788] Chunk #1 of 2 ... DONE
[17:45:19.788] Chunk #2 of 2 ...
[17:45:19.788]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.788] getGlobalsAndPackages() ...
[17:45:19.788] Searching for globals...
[17:45:19.789] 
[17:45:19.789] Searching for globals ... DONE
[17:45:19.789] - globals: [0] <none>
[17:45:19.789] getGlobalsAndPackages() ... DONE
[17:45:19.789]    + additional globals found: [n=0] 
[17:45:19.789]    + additional namespaces needed: [n=0] 
[17:45:19.789]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.790]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.790]  - seeds: <none>
[17:45:19.790]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.790] getGlobalsAndPackages() ...
[17:45:19.790] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.790] Resolving globals: FALSE
[17:45:19.791] Tweak future expression to call with '...' arguments ...
[17:45:19.791] {
[17:45:19.791]     do.call(function(...) {
[17:45:19.791]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.791]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.791]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.791]             on.exit(options(oopts), add = TRUE)
[17:45:19.791]         }
[17:45:19.791]         {
[17:45:19.791]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.791]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.791]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.791]             })
[17:45:19.791]         }
[17:45:19.791]     }, args = future.call.arguments)
[17:45:19.791] }
[17:45:19.791] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.792] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.792] 
[17:45:19.792] getGlobalsAndPackages() ... DONE
[17:45:19.793] run() for ‘Future’ ...
[17:45:19.793] - state: ‘created’
[17:45:19.793] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.798] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.798] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.798]   - Field: ‘label’
[17:45:19.798]   - Field: ‘local’
[17:45:19.799]   - Field: ‘owner’
[17:45:19.799]   - Field: ‘envir’
[17:45:19.799]   - Field: ‘workers’
[17:45:19.799]   - Field: ‘packages’
[17:45:19.799]   - Field: ‘gc’
[17:45:19.799]   - Field: ‘job’
[17:45:19.800]   - Field: ‘conditions’
[17:45:19.800]   - Field: ‘expr’
[17:45:19.800]   - Field: ‘uuid’
[17:45:19.800]   - Field: ‘seed’
[17:45:19.800]   - Field: ‘version’
[17:45:19.800]   - Field: ‘result’
[17:45:19.800]   - Field: ‘asynchronous’
[17:45:19.801]   - Field: ‘calls’
[17:45:19.801]   - Field: ‘globals’
[17:45:19.801]   - Field: ‘stdout’
[17:45:19.801]   - Field: ‘earlySignal’
[17:45:19.801]   - Field: ‘lazy’
[17:45:19.801]   - Field: ‘state’
[17:45:19.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.802] - Launch lazy future ...
[17:45:19.802] Packages needed by the future expression (n = 0): <none>
[17:45:19.802] Packages needed by future strategies (n = 0): <none>
[17:45:19.803] {
[17:45:19.803]     {
[17:45:19.803]         {
[17:45:19.803]             ...future.startTime <- base::Sys.time()
[17:45:19.803]             {
[17:45:19.803]                 {
[17:45:19.803]                   {
[17:45:19.803]                     {
[17:45:19.803]                       base::local({
[17:45:19.803]                         has_future <- base::requireNamespace("future", 
[17:45:19.803]                           quietly = TRUE)
[17:45:19.803]                         if (has_future) {
[17:45:19.803]                           ns <- base::getNamespace("future")
[17:45:19.803]                           version <- ns[[".package"]][["version"]]
[17:45:19.803]                           if (is.null(version)) 
[17:45:19.803]                             version <- utils::packageVersion("future")
[17:45:19.803]                         }
[17:45:19.803]                         else {
[17:45:19.803]                           version <- NULL
[17:45:19.803]                         }
[17:45:19.803]                         if (!has_future || version < "1.8.0") {
[17:45:19.803]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.803]                             "", base::R.version$version.string), 
[17:45:19.803]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:19.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:19.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.803]                               "release", "version")], collapse = " "), 
[17:45:19.803]                             hostname = base::Sys.info()[["nodename"]])
[17:45:19.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.803]                             info)
[17:45:19.803]                           info <- base::paste(info, collapse = "; ")
[17:45:19.803]                           if (!has_future) {
[17:45:19.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.803]                               info)
[17:45:19.803]                           }
[17:45:19.803]                           else {
[17:45:19.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.803]                               info, version)
[17:45:19.803]                           }
[17:45:19.803]                           base::stop(msg)
[17:45:19.803]                         }
[17:45:19.803]                       })
[17:45:19.803]                     }
[17:45:19.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.803]                     base::options(mc.cores = 1L)
[17:45:19.803]                   }
[17:45:19.803]                   ...future.strategy.old <- future::plan("list")
[17:45:19.803]                   options(future.plan = NULL)
[17:45:19.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.803]                 }
[17:45:19.803]                 ...future.workdir <- getwd()
[17:45:19.803]             }
[17:45:19.803]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.803]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.803]         }
[17:45:19.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.803]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.803]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.803]             base::names(...future.oldOptions))
[17:45:19.803]     }
[17:45:19.803]     if (FALSE) {
[17:45:19.803]     }
[17:45:19.803]     else {
[17:45:19.803]         if (TRUE) {
[17:45:19.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.803]                 open = "w")
[17:45:19.803]         }
[17:45:19.803]         else {
[17:45:19.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.803]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.803]         }
[17:45:19.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.803]             base::sink(type = "output", split = FALSE)
[17:45:19.803]             base::close(...future.stdout)
[17:45:19.803]         }, add = TRUE)
[17:45:19.803]     }
[17:45:19.803]     ...future.frame <- base::sys.nframe()
[17:45:19.803]     ...future.conditions <- base::list()
[17:45:19.803]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.803]     if (FALSE) {
[17:45:19.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.803]     }
[17:45:19.803]     ...future.result <- base::tryCatch({
[17:45:19.803]         base::withCallingHandlers({
[17:45:19.803]             ...future.value <- base::withVisible(base::local({
[17:45:19.803]                 withCallingHandlers({
[17:45:19.803]                   {
[17:45:19.803]                     do.call(function(...) {
[17:45:19.803]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.803]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.803]                         ...future.globals.maxSize)) {
[17:45:19.803]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.803]                         on.exit(options(oopts), add = TRUE)
[17:45:19.803]                       }
[17:45:19.803]                       {
[17:45:19.803]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.803]                           FUN = function(jj) {
[17:45:19.803]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.803]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.803]                           })
[17:45:19.803]                       }
[17:45:19.803]                     }, args = future.call.arguments)
[17:45:19.803]                   }
[17:45:19.803]                 }, immediateCondition = function(cond) {
[17:45:19.803]                   save_rds <- function (object, pathname, ...) 
[17:45:19.803]                   {
[17:45:19.803]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.803]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.803]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.803]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.803]                         fi_tmp[["mtime"]])
[17:45:19.803]                     }
[17:45:19.803]                     tryCatch({
[17:45:19.803]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.803]                     }, error = function(ex) {
[17:45:19.803]                       msg <- conditionMessage(ex)
[17:45:19.803]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.803]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.803]                         fi_tmp[["mtime"]], msg)
[17:45:19.803]                       ex$message <- msg
[17:45:19.803]                       stop(ex)
[17:45:19.803]                     })
[17:45:19.803]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.803]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.803]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.803]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.803]                       fi <- file.info(pathname)
[17:45:19.803]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.803]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.803]                         fi[["size"]], fi[["mtime"]])
[17:45:19.803]                       stop(msg)
[17:45:19.803]                     }
[17:45:19.803]                     invisible(pathname)
[17:45:19.803]                   }
[17:45:19.803]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.803]                     rootPath = tempdir()) 
[17:45:19.803]                   {
[17:45:19.803]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.803]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.803]                       tmpdir = path, fileext = ".rds")
[17:45:19.803]                     save_rds(obj, file)
[17:45:19.803]                   }
[17:45:19.803]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.803]                   {
[17:45:19.803]                     inherits <- base::inherits
[17:45:19.803]                     invokeRestart <- base::invokeRestart
[17:45:19.803]                     is.null <- base::is.null
[17:45:19.803]                     muffled <- FALSE
[17:45:19.803]                     if (inherits(cond, "message")) {
[17:45:19.803]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.803]                       if (muffled) 
[17:45:19.803]                         invokeRestart("muffleMessage")
[17:45:19.803]                     }
[17:45:19.803]                     else if (inherits(cond, "warning")) {
[17:45:19.803]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.803]                       if (muffled) 
[17:45:19.803]                         invokeRestart("muffleWarning")
[17:45:19.803]                     }
[17:45:19.803]                     else if (inherits(cond, "condition")) {
[17:45:19.803]                       if (!is.null(pattern)) {
[17:45:19.803]                         computeRestarts <- base::computeRestarts
[17:45:19.803]                         grepl <- base::grepl
[17:45:19.803]                         restarts <- computeRestarts(cond)
[17:45:19.803]                         for (restart in restarts) {
[17:45:19.803]                           name <- restart$name
[17:45:19.803]                           if (is.null(name)) 
[17:45:19.803]                             next
[17:45:19.803]                           if (!grepl(pattern, name)) 
[17:45:19.803]                             next
[17:45:19.803]                           invokeRestart(restart)
[17:45:19.803]                           muffled <- TRUE
[17:45:19.803]                           break
[17:45:19.803]                         }
[17:45:19.803]                       }
[17:45:19.803]                     }
[17:45:19.803]                     invisible(muffled)
[17:45:19.803]                   }
[17:45:19.803]                   muffleCondition(cond)
[17:45:19.803]                 })
[17:45:19.803]             }))
[17:45:19.803]             future::FutureResult(value = ...future.value$value, 
[17:45:19.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.803]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.803]                     ...future.globalenv.names))
[17:45:19.803]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.803]         }, condition = base::local({
[17:45:19.803]             c <- base::c
[17:45:19.803]             inherits <- base::inherits
[17:45:19.803]             invokeRestart <- base::invokeRestart
[17:45:19.803]             length <- base::length
[17:45:19.803]             list <- base::list
[17:45:19.803]             seq.int <- base::seq.int
[17:45:19.803]             signalCondition <- base::signalCondition
[17:45:19.803]             sys.calls <- base::sys.calls
[17:45:19.803]             `[[` <- base::`[[`
[17:45:19.803]             `+` <- base::`+`
[17:45:19.803]             `<<-` <- base::`<<-`
[17:45:19.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.803]                   3L)]
[17:45:19.803]             }
[17:45:19.803]             function(cond) {
[17:45:19.803]                 is_error <- inherits(cond, "error")
[17:45:19.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.803]                   NULL)
[17:45:19.803]                 if (is_error) {
[17:45:19.803]                   sessionInformation <- function() {
[17:45:19.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.803]                       search = base::search(), system = base::Sys.info())
[17:45:19.803]                   }
[17:45:19.803]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.803]                     cond$call), session = sessionInformation(), 
[17:45:19.803]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.803]                   signalCondition(cond)
[17:45:19.803]                 }
[17:45:19.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.803]                 "immediateCondition"))) {
[17:45:19.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.803]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.803]                   if (TRUE && !signal) {
[17:45:19.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.803]                     {
[17:45:19.803]                       inherits <- base::inherits
[17:45:19.803]                       invokeRestart <- base::invokeRestart
[17:45:19.803]                       is.null <- base::is.null
[17:45:19.803]                       muffled <- FALSE
[17:45:19.803]                       if (inherits(cond, "message")) {
[17:45:19.803]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.803]                         if (muffled) 
[17:45:19.803]                           invokeRestart("muffleMessage")
[17:45:19.803]                       }
[17:45:19.803]                       else if (inherits(cond, "warning")) {
[17:45:19.803]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.803]                         if (muffled) 
[17:45:19.803]                           invokeRestart("muffleWarning")
[17:45:19.803]                       }
[17:45:19.803]                       else if (inherits(cond, "condition")) {
[17:45:19.803]                         if (!is.null(pattern)) {
[17:45:19.803]                           computeRestarts <- base::computeRestarts
[17:45:19.803]                           grepl <- base::grepl
[17:45:19.803]                           restarts <- computeRestarts(cond)
[17:45:19.803]                           for (restart in restarts) {
[17:45:19.803]                             name <- restart$name
[17:45:19.803]                             if (is.null(name)) 
[17:45:19.803]                               next
[17:45:19.803]                             if (!grepl(pattern, name)) 
[17:45:19.803]                               next
[17:45:19.803]                             invokeRestart(restart)
[17:45:19.803]                             muffled <- TRUE
[17:45:19.803]                             break
[17:45:19.803]                           }
[17:45:19.803]                         }
[17:45:19.803]                       }
[17:45:19.803]                       invisible(muffled)
[17:45:19.803]                     }
[17:45:19.803]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.803]                   }
[17:45:19.803]                 }
[17:45:19.803]                 else {
[17:45:19.803]                   if (TRUE) {
[17:45:19.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.803]                     {
[17:45:19.803]                       inherits <- base::inherits
[17:45:19.803]                       invokeRestart <- base::invokeRestart
[17:45:19.803]                       is.null <- base::is.null
[17:45:19.803]                       muffled <- FALSE
[17:45:19.803]                       if (inherits(cond, "message")) {
[17:45:19.803]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.803]                         if (muffled) 
[17:45:19.803]                           invokeRestart("muffleMessage")
[17:45:19.803]                       }
[17:45:19.803]                       else if (inherits(cond, "warning")) {
[17:45:19.803]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.803]                         if (muffled) 
[17:45:19.803]                           invokeRestart("muffleWarning")
[17:45:19.803]                       }
[17:45:19.803]                       else if (inherits(cond, "condition")) {
[17:45:19.803]                         if (!is.null(pattern)) {
[17:45:19.803]                           computeRestarts <- base::computeRestarts
[17:45:19.803]                           grepl <- base::grepl
[17:45:19.803]                           restarts <- computeRestarts(cond)
[17:45:19.803]                           for (restart in restarts) {
[17:45:19.803]                             name <- restart$name
[17:45:19.803]                             if (is.null(name)) 
[17:45:19.803]                               next
[17:45:19.803]                             if (!grepl(pattern, name)) 
[17:45:19.803]                               next
[17:45:19.803]                             invokeRestart(restart)
[17:45:19.803]                             muffled <- TRUE
[17:45:19.803]                             break
[17:45:19.803]                           }
[17:45:19.803]                         }
[17:45:19.803]                       }
[17:45:19.803]                       invisible(muffled)
[17:45:19.803]                     }
[17:45:19.803]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.803]                   }
[17:45:19.803]                 }
[17:45:19.803]             }
[17:45:19.803]         }))
[17:45:19.803]     }, error = function(ex) {
[17:45:19.803]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.803]                 ...future.rng), started = ...future.startTime, 
[17:45:19.803]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.803]             version = "1.8"), class = "FutureResult")
[17:45:19.803]     }, finally = {
[17:45:19.803]         if (!identical(...future.workdir, getwd())) 
[17:45:19.803]             setwd(...future.workdir)
[17:45:19.803]         {
[17:45:19.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.803]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.803]             }
[17:45:19.803]             base::options(...future.oldOptions)
[17:45:19.803]             if (.Platform$OS.type == "windows") {
[17:45:19.803]                 old_names <- names(...future.oldEnvVars)
[17:45:19.803]                 envs <- base::Sys.getenv()
[17:45:19.803]                 names <- names(envs)
[17:45:19.803]                 common <- intersect(names, old_names)
[17:45:19.803]                 added <- setdiff(names, old_names)
[17:45:19.803]                 removed <- setdiff(old_names, names)
[17:45:19.803]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.803]                   envs[common]]
[17:45:19.803]                 NAMES <- toupper(changed)
[17:45:19.803]                 args <- list()
[17:45:19.803]                 for (kk in seq_along(NAMES)) {
[17:45:19.803]                   name <- changed[[kk]]
[17:45:19.803]                   NAME <- NAMES[[kk]]
[17:45:19.803]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.803]                     next
[17:45:19.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.803]                 }
[17:45:19.803]                 NAMES <- toupper(added)
[17:45:19.803]                 for (kk in seq_along(NAMES)) {
[17:45:19.803]                   name <- added[[kk]]
[17:45:19.803]                   NAME <- NAMES[[kk]]
[17:45:19.803]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.803]                     next
[17:45:19.803]                   args[[name]] <- ""
[17:45:19.803]                 }
[17:45:19.803]                 NAMES <- toupper(removed)
[17:45:19.803]                 for (kk in seq_along(NAMES)) {
[17:45:19.803]                   name <- removed[[kk]]
[17:45:19.803]                   NAME <- NAMES[[kk]]
[17:45:19.803]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.803]                     next
[17:45:19.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.803]                 }
[17:45:19.803]                 if (length(args) > 0) 
[17:45:19.803]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.803]             }
[17:45:19.803]             else {
[17:45:19.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.803]             }
[17:45:19.803]             {
[17:45:19.803]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.803]                   0L) {
[17:45:19.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.803]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.803]                   base::options(opts)
[17:45:19.803]                 }
[17:45:19.803]                 {
[17:45:19.803]                   {
[17:45:19.803]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.803]                     NULL
[17:45:19.803]                   }
[17:45:19.803]                   options(future.plan = NULL)
[17:45:19.803]                   if (is.na(NA_character_)) 
[17:45:19.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.803]                     .init = FALSE)
[17:45:19.803]                 }
[17:45:19.803]             }
[17:45:19.803]         }
[17:45:19.803]     })
[17:45:19.803]     if (TRUE) {
[17:45:19.803]         base::sink(type = "output", split = FALSE)
[17:45:19.803]         if (TRUE) {
[17:45:19.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.803]         }
[17:45:19.803]         else {
[17:45:19.803]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.803]         }
[17:45:19.803]         base::close(...future.stdout)
[17:45:19.803]         ...future.stdout <- NULL
[17:45:19.803]     }
[17:45:19.803]     ...future.result$conditions <- ...future.conditions
[17:45:19.803]     ...future.result$finished <- base::Sys.time()
[17:45:19.803]     ...future.result
[17:45:19.803] }
[17:45:19.807] assign_globals() ...
[17:45:19.807] List of 5
[17:45:19.807]  $ ...future.FUN            :function (x, y)  
[17:45:19.807]  $ future.call.arguments    :List of 1
[17:45:19.807]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.807]  $ ...future.elements_ii    :List of 2
[17:45:19.807]   ..$ C: num 70
[17:45:19.807]   ..$ D: num 80
[17:45:19.807]  $ ...future.seeds_ii       : NULL
[17:45:19.807]  $ ...future.globals.maxSize: NULL
[17:45:19.807]  - attr(*, "where")=List of 5
[17:45:19.807]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.807]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.807]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.807]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.807]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.807]  - attr(*, "resolved")= logi FALSE
[17:45:19.807]  - attr(*, "total_size")= num 4264
[17:45:19.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.807]  - attr(*, "already-done")= logi TRUE
[17:45:19.820] - reassign environment for ‘...future.FUN’
[17:45:19.820] - copied ‘...future.FUN’ to environment
[17:45:19.821] - copied ‘future.call.arguments’ to environment
[17:45:19.821] - copied ‘...future.elements_ii’ to environment
[17:45:19.821] - copied ‘...future.seeds_ii’ to environment
[17:45:19.821] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.821] assign_globals() ... done
[17:45:19.821] requestCore(): workers = 2
[17:45:19.824] MulticoreFuture started
[17:45:19.824] - Launch lazy future ... done
[17:45:19.825] run() for ‘MulticoreFuture’ ... done
[17:45:19.825] plan(): Setting new future strategy stack:
[17:45:19.825] Created future:
[17:45:19.825] List of future strategies:
[17:45:19.825] 1. sequential:
[17:45:19.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.825]    - tweaked: FALSE
[17:45:19.825]    - call: NULL
[17:45:19.827] plan(): nbrOfWorkers() = 1
[17:45:19.829] plan(): Setting new future strategy stack:
[17:45:19.829] List of future strategies:
[17:45:19.829] 1. multicore:
[17:45:19.829]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.829]    - tweaked: FALSE
[17:45:19.829]    - call: plan(strategy)
[17:45:19.835] plan(): nbrOfWorkers() = 2
[17:45:19.825] MulticoreFuture:
[17:45:19.825] Label: ‘future_sapply-2’
[17:45:19.825] Expression:
[17:45:19.825] {
[17:45:19.825]     do.call(function(...) {
[17:45:19.825]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.825]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.825]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.825]             on.exit(options(oopts), add = TRUE)
[17:45:19.825]         }
[17:45:19.825]         {
[17:45:19.825]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.825]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.825]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.825]             })
[17:45:19.825]         }
[17:45:19.825]     }, args = future.call.arguments)
[17:45:19.825] }
[17:45:19.825] Lazy evaluation: FALSE
[17:45:19.825] Asynchronous evaluation: TRUE
[17:45:19.825] Local evaluation: TRUE
[17:45:19.825] Environment: R_GlobalEnv
[17:45:19.825] Capture standard output: TRUE
[17:45:19.825] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.825] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:19.825] Packages: <none>
[17:45:19.825] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.825] Resolved: TRUE
[17:45:19.825] Value: <not collected>
[17:45:19.825] Conditions captured: <none>
[17:45:19.825] Early signaling: FALSE
[17:45:19.825] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.825] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.836] Chunk #2 of 2 ... DONE
[17:45:19.836] Launching 2 futures (chunks) ... DONE
[17:45:19.836] Resolving 2 futures (chunks) ...
[17:45:19.837] resolve() on list ...
[17:45:19.837]  recursive: 0
[17:45:19.837]  length: 2
[17:45:19.837] 
[17:45:19.837] Future #1
[17:45:19.838] result() for MulticoreFuture ...
[17:45:19.838] result() for MulticoreFuture ...
[17:45:19.839] result() for MulticoreFuture ... done
[17:45:19.839] result() for MulticoreFuture ... done
[17:45:19.839] result() for MulticoreFuture ...
[17:45:19.839] result() for MulticoreFuture ... done
[17:45:19.839] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.840] - nx: 2
[17:45:19.840] - relay: TRUE
[17:45:19.840] - stdout: TRUE
[17:45:19.840] - signal: TRUE
[17:45:19.840] - resignal: FALSE
[17:45:19.840] - force: TRUE
[17:45:19.840] - relayed: [n=2] FALSE, FALSE
[17:45:19.840] - queued futures: [n=2] FALSE, FALSE
[17:45:19.841]  - until=1
[17:45:19.841]  - relaying element #1
[17:45:19.841] result() for MulticoreFuture ...
[17:45:19.841] result() for MulticoreFuture ... done
[17:45:19.841] result() for MulticoreFuture ...
[17:45:19.841] result() for MulticoreFuture ... done
[17:45:19.842] result() for MulticoreFuture ...
[17:45:19.842] result() for MulticoreFuture ... done
[17:45:19.842] result() for MulticoreFuture ...
[17:45:19.842] result() for MulticoreFuture ... done
[17:45:19.842] - relayed: [n=2] TRUE, FALSE
[17:45:19.842] - queued futures: [n=2] TRUE, FALSE
[17:45:19.842] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.843]  length: 1 (resolved future 1)
[17:45:19.843] Future #2
[17:45:19.843] result() for MulticoreFuture ...
[17:45:19.844] result() for MulticoreFuture ...
[17:45:19.844] result() for MulticoreFuture ... done
[17:45:19.844] result() for MulticoreFuture ... done
[17:45:19.844] result() for MulticoreFuture ...
[17:45:19.844] result() for MulticoreFuture ... done
[17:45:19.845] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.845] - nx: 2
[17:45:19.845] - relay: TRUE
[17:45:19.845] - stdout: TRUE
[17:45:19.845] - signal: TRUE
[17:45:19.845] - resignal: FALSE
[17:45:19.845] - force: TRUE
[17:45:19.845] - relayed: [n=2] TRUE, FALSE
[17:45:19.846] - queued futures: [n=2] TRUE, FALSE
[17:45:19.846]  - until=2
[17:45:19.846]  - relaying element #2
[17:45:19.846] result() for MulticoreFuture ...
[17:45:19.846] result() for MulticoreFuture ... done
[17:45:19.846] result() for MulticoreFuture ...
[17:45:19.846] result() for MulticoreFuture ... done
[17:45:19.846] result() for MulticoreFuture ...
[17:45:19.847] result() for MulticoreFuture ... done
[17:45:19.847] result() for MulticoreFuture ...
[17:45:19.847] result() for MulticoreFuture ... done
[17:45:19.847] - relayed: [n=2] TRUE, TRUE
[17:45:19.847] - queued futures: [n=2] TRUE, TRUE
[17:45:19.847] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.847]  length: 0 (resolved future 2)
[17:45:19.847] Relaying remaining futures
[17:45:19.848] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.848] - nx: 2
[17:45:19.848] - relay: TRUE
[17:45:19.848] - stdout: TRUE
[17:45:19.848] - signal: TRUE
[17:45:19.848] - resignal: FALSE
[17:45:19.848] - force: TRUE
[17:45:19.848] - relayed: [n=2] TRUE, TRUE
[17:45:19.848] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.848] - relayed: [n=2] TRUE, TRUE
[17:45:19.849] - queued futures: [n=2] TRUE, TRUE
[17:45:19.849] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.849] resolve() on list ... DONE
[17:45:19.849] result() for MulticoreFuture ...
[17:45:19.849] result() for MulticoreFuture ... done
[17:45:19.849] result() for MulticoreFuture ...
[17:45:19.849] result() for MulticoreFuture ... done
[17:45:19.849] result() for MulticoreFuture ...
[17:45:19.850] result() for MulticoreFuture ... done
[17:45:19.850] result() for MulticoreFuture ...
[17:45:19.850] result() for MulticoreFuture ... done
[17:45:19.850]  - Number of value chunks collected: 2
[17:45:19.850] Resolving 2 futures (chunks) ... DONE
[17:45:19.850] Reducing values from 2 chunks ...
[17:45:19.850]  - Number of values collected after concatenation: 4
[17:45:19.850]  - Number of values expected: 4
[17:45:19.850] Reducing values from 2 chunks ... DONE
[17:45:19.851] future_lapply() ... DONE
[17:45:19.851] future_lapply() ...
[17:45:19.861] Number of chunks: 2
[17:45:19.861] getGlobalsAndPackagesXApply() ...
[17:45:19.861]  - future.globals: TRUE
[17:45:19.861] getGlobalsAndPackages() ...
[17:45:19.862] Searching for globals...
[17:45:19.867] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:45:19.867] Searching for globals ... DONE
[17:45:19.867] Resolving globals: FALSE
[17:45:19.868] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:45:19.868] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:19.868] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.869] - packages: [1] ‘future.apply’
[17:45:19.869] getGlobalsAndPackages() ... DONE
[17:45:19.869]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:19.869]  - needed namespaces: [n=1] ‘future.apply’
[17:45:19.869] Finding globals ... DONE
[17:45:19.869]  - use_args: TRUE
[17:45:19.869]  - Getting '...' globals ...
[17:45:19.869] resolve() on list ...
[17:45:19.870]  recursive: 0
[17:45:19.870]  length: 1
[17:45:19.870]  elements: ‘...’
[17:45:19.870]  length: 0 (resolved future 1)
[17:45:19.870] resolve() on list ... DONE
[17:45:19.870]    - '...' content: [n=1] ‘y’
[17:45:19.870] List of 1
[17:45:19.870]  $ ...:List of 1
[17:45:19.870]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.870]  - attr(*, "where")=List of 1
[17:45:19.870]   ..$ ...:<environment: 0x5561f53b2dc0> 
[17:45:19.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.870]  - attr(*, "resolved")= logi TRUE
[17:45:19.870]  - attr(*, "total_size")= num NA
[17:45:19.873]  - Getting '...' globals ... DONE
[17:45:19.873] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:19.874] List of 8
[17:45:19.874]  $ ...future.FUN:function (x, ...)  
[17:45:19.874]  $ x_FUN        :function (x, y)  
[17:45:19.874]  $ times        : int 15
[17:45:19.874]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.874]  $ stop_if_not  :function (...)  
[17:45:19.874]  $ dim          : int [1:2] 3 5
[17:45:19.874]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:19.874]  $ ...          :List of 1
[17:45:19.874]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.874]  - attr(*, "where")=List of 8
[17:45:19.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:19.874]   ..$ ...          :<environment: 0x5561f53b2dc0> 
[17:45:19.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.874]  - attr(*, "resolved")= logi FALSE
[17:45:19.874]  - attr(*, "total_size")= num 98600
[17:45:19.882] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:19.882] getGlobalsAndPackagesXApply() ... DONE
[17:45:19.882] Number of futures (= number of chunks): 2
[17:45:19.882] Launching 2 futures (chunks) ...
[17:45:19.882] Chunk #1 of 2 ...
[17:45:19.882]  - Finding globals in 'X' for chunk #1 ...
[17:45:19.883] getGlobalsAndPackages() ...
[17:45:19.883] Searching for globals...
[17:45:19.883] 
[17:45:19.883] Searching for globals ... DONE
[17:45:19.883] - globals: [0] <none>
[17:45:19.883] getGlobalsAndPackages() ... DONE
[17:45:19.883]    + additional globals found: [n=0] 
[17:45:19.883]    + additional namespaces needed: [n=0] 
[17:45:19.884]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:19.884]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.884]  - seeds: <none>
[17:45:19.884]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.884] getGlobalsAndPackages() ...
[17:45:19.884] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.884] Resolving globals: FALSE
[17:45:19.884] Tweak future expression to call with '...' arguments ...
[17:45:19.885] {
[17:45:19.885]     do.call(function(...) {
[17:45:19.885]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.885]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.885]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.885]             on.exit(options(oopts), add = TRUE)
[17:45:19.885]         }
[17:45:19.885]         {
[17:45:19.885]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.885]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.885]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.885]             })
[17:45:19.885]         }
[17:45:19.885]     }, args = future.call.arguments)
[17:45:19.885] }
[17:45:19.885] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.885] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.886] - packages: [1] ‘future.apply’
[17:45:19.886] getGlobalsAndPackages() ... DONE
[17:45:19.886] run() for ‘Future’ ...
[17:45:19.886] - state: ‘created’
[17:45:19.886] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.890] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.890]   - Field: ‘label’
[17:45:19.891]   - Field: ‘local’
[17:45:19.891]   - Field: ‘owner’
[17:45:19.891]   - Field: ‘envir’
[17:45:19.891]   - Field: ‘workers’
[17:45:19.891]   - Field: ‘packages’
[17:45:19.891]   - Field: ‘gc’
[17:45:19.891]   - Field: ‘job’
[17:45:19.891]   - Field: ‘conditions’
[17:45:19.891]   - Field: ‘expr’
[17:45:19.892]   - Field: ‘uuid’
[17:45:19.892]   - Field: ‘seed’
[17:45:19.892]   - Field: ‘version’
[17:45:19.892]   - Field: ‘result’
[17:45:19.892]   - Field: ‘asynchronous’
[17:45:19.892]   - Field: ‘calls’
[17:45:19.892]   - Field: ‘globals’
[17:45:19.892]   - Field: ‘stdout’
[17:45:19.892]   - Field: ‘earlySignal’
[17:45:19.892]   - Field: ‘lazy’
[17:45:19.892]   - Field: ‘state’
[17:45:19.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.893] - Launch lazy future ...
[17:45:19.893] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:19.893] Packages needed by future strategies (n = 0): <none>
[17:45:19.894] {
[17:45:19.894]     {
[17:45:19.894]         {
[17:45:19.894]             ...future.startTime <- base::Sys.time()
[17:45:19.894]             {
[17:45:19.894]                 {
[17:45:19.894]                   {
[17:45:19.894]                     {
[17:45:19.894]                       {
[17:45:19.894]                         base::local({
[17:45:19.894]                           has_future <- base::requireNamespace("future", 
[17:45:19.894]                             quietly = TRUE)
[17:45:19.894]                           if (has_future) {
[17:45:19.894]                             ns <- base::getNamespace("future")
[17:45:19.894]                             version <- ns[[".package"]][["version"]]
[17:45:19.894]                             if (is.null(version)) 
[17:45:19.894]                               version <- utils::packageVersion("future")
[17:45:19.894]                           }
[17:45:19.894]                           else {
[17:45:19.894]                             version <- NULL
[17:45:19.894]                           }
[17:45:19.894]                           if (!has_future || version < "1.8.0") {
[17:45:19.894]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.894]                               "", base::R.version$version.string), 
[17:45:19.894]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.894]                                 base::R.version$platform, 8 * 
[17:45:19.894]                                   base::.Machine$sizeof.pointer), 
[17:45:19.894]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.894]                                 "release", "version")], collapse = " "), 
[17:45:19.894]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.894]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.894]                               info)
[17:45:19.894]                             info <- base::paste(info, collapse = "; ")
[17:45:19.894]                             if (!has_future) {
[17:45:19.894]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.894]                                 info)
[17:45:19.894]                             }
[17:45:19.894]                             else {
[17:45:19.894]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.894]                                 info, version)
[17:45:19.894]                             }
[17:45:19.894]                             base::stop(msg)
[17:45:19.894]                           }
[17:45:19.894]                         })
[17:45:19.894]                       }
[17:45:19.894]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.894]                       base::options(mc.cores = 1L)
[17:45:19.894]                     }
[17:45:19.894]                     base::local({
[17:45:19.894]                       for (pkg in "future.apply") {
[17:45:19.894]                         base::loadNamespace(pkg)
[17:45:19.894]                         base::library(pkg, character.only = TRUE)
[17:45:19.894]                       }
[17:45:19.894]                     })
[17:45:19.894]                   }
[17:45:19.894]                   ...future.strategy.old <- future::plan("list")
[17:45:19.894]                   options(future.plan = NULL)
[17:45:19.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.894]                 }
[17:45:19.894]                 ...future.workdir <- getwd()
[17:45:19.894]             }
[17:45:19.894]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.894]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.894]         }
[17:45:19.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.894]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.894]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.894]             base::names(...future.oldOptions))
[17:45:19.894]     }
[17:45:19.894]     if (FALSE) {
[17:45:19.894]     }
[17:45:19.894]     else {
[17:45:19.894]         if (TRUE) {
[17:45:19.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.894]                 open = "w")
[17:45:19.894]         }
[17:45:19.894]         else {
[17:45:19.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.894]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.894]         }
[17:45:19.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.894]             base::sink(type = "output", split = FALSE)
[17:45:19.894]             base::close(...future.stdout)
[17:45:19.894]         }, add = TRUE)
[17:45:19.894]     }
[17:45:19.894]     ...future.frame <- base::sys.nframe()
[17:45:19.894]     ...future.conditions <- base::list()
[17:45:19.894]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.894]     if (FALSE) {
[17:45:19.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.894]     }
[17:45:19.894]     ...future.result <- base::tryCatch({
[17:45:19.894]         base::withCallingHandlers({
[17:45:19.894]             ...future.value <- base::withVisible(base::local({
[17:45:19.894]                 withCallingHandlers({
[17:45:19.894]                   {
[17:45:19.894]                     do.call(function(...) {
[17:45:19.894]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.894]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.894]                         ...future.globals.maxSize)) {
[17:45:19.894]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.894]                         on.exit(options(oopts), add = TRUE)
[17:45:19.894]                       }
[17:45:19.894]                       {
[17:45:19.894]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.894]                           FUN = function(jj) {
[17:45:19.894]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.894]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.894]                           })
[17:45:19.894]                       }
[17:45:19.894]                     }, args = future.call.arguments)
[17:45:19.894]                   }
[17:45:19.894]                 }, immediateCondition = function(cond) {
[17:45:19.894]                   save_rds <- function (object, pathname, ...) 
[17:45:19.894]                   {
[17:45:19.894]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.894]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.894]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.894]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.894]                         fi_tmp[["mtime"]])
[17:45:19.894]                     }
[17:45:19.894]                     tryCatch({
[17:45:19.894]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.894]                     }, error = function(ex) {
[17:45:19.894]                       msg <- conditionMessage(ex)
[17:45:19.894]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.894]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.894]                         fi_tmp[["mtime"]], msg)
[17:45:19.894]                       ex$message <- msg
[17:45:19.894]                       stop(ex)
[17:45:19.894]                     })
[17:45:19.894]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.894]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.894]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.894]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.894]                       fi <- file.info(pathname)
[17:45:19.894]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.894]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.894]                         fi[["size"]], fi[["mtime"]])
[17:45:19.894]                       stop(msg)
[17:45:19.894]                     }
[17:45:19.894]                     invisible(pathname)
[17:45:19.894]                   }
[17:45:19.894]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.894]                     rootPath = tempdir()) 
[17:45:19.894]                   {
[17:45:19.894]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.894]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.894]                       tmpdir = path, fileext = ".rds")
[17:45:19.894]                     save_rds(obj, file)
[17:45:19.894]                   }
[17:45:19.894]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.894]                   {
[17:45:19.894]                     inherits <- base::inherits
[17:45:19.894]                     invokeRestart <- base::invokeRestart
[17:45:19.894]                     is.null <- base::is.null
[17:45:19.894]                     muffled <- FALSE
[17:45:19.894]                     if (inherits(cond, "message")) {
[17:45:19.894]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.894]                       if (muffled) 
[17:45:19.894]                         invokeRestart("muffleMessage")
[17:45:19.894]                     }
[17:45:19.894]                     else if (inherits(cond, "warning")) {
[17:45:19.894]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.894]                       if (muffled) 
[17:45:19.894]                         invokeRestart("muffleWarning")
[17:45:19.894]                     }
[17:45:19.894]                     else if (inherits(cond, "condition")) {
[17:45:19.894]                       if (!is.null(pattern)) {
[17:45:19.894]                         computeRestarts <- base::computeRestarts
[17:45:19.894]                         grepl <- base::grepl
[17:45:19.894]                         restarts <- computeRestarts(cond)
[17:45:19.894]                         for (restart in restarts) {
[17:45:19.894]                           name <- restart$name
[17:45:19.894]                           if (is.null(name)) 
[17:45:19.894]                             next
[17:45:19.894]                           if (!grepl(pattern, name)) 
[17:45:19.894]                             next
[17:45:19.894]                           invokeRestart(restart)
[17:45:19.894]                           muffled <- TRUE
[17:45:19.894]                           break
[17:45:19.894]                         }
[17:45:19.894]                       }
[17:45:19.894]                     }
[17:45:19.894]                     invisible(muffled)
[17:45:19.894]                   }
[17:45:19.894]                   muffleCondition(cond)
[17:45:19.894]                 })
[17:45:19.894]             }))
[17:45:19.894]             future::FutureResult(value = ...future.value$value, 
[17:45:19.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.894]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.894]                     ...future.globalenv.names))
[17:45:19.894]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.894]         }, condition = base::local({
[17:45:19.894]             c <- base::c
[17:45:19.894]             inherits <- base::inherits
[17:45:19.894]             invokeRestart <- base::invokeRestart
[17:45:19.894]             length <- base::length
[17:45:19.894]             list <- base::list
[17:45:19.894]             seq.int <- base::seq.int
[17:45:19.894]             signalCondition <- base::signalCondition
[17:45:19.894]             sys.calls <- base::sys.calls
[17:45:19.894]             `[[` <- base::`[[`
[17:45:19.894]             `+` <- base::`+`
[17:45:19.894]             `<<-` <- base::`<<-`
[17:45:19.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.894]                   3L)]
[17:45:19.894]             }
[17:45:19.894]             function(cond) {
[17:45:19.894]                 is_error <- inherits(cond, "error")
[17:45:19.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.894]                   NULL)
[17:45:19.894]                 if (is_error) {
[17:45:19.894]                   sessionInformation <- function() {
[17:45:19.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.894]                       search = base::search(), system = base::Sys.info())
[17:45:19.894]                   }
[17:45:19.894]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.894]                     cond$call), session = sessionInformation(), 
[17:45:19.894]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.894]                   signalCondition(cond)
[17:45:19.894]                 }
[17:45:19.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.894]                 "immediateCondition"))) {
[17:45:19.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.894]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.894]                   if (TRUE && !signal) {
[17:45:19.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.894]                     {
[17:45:19.894]                       inherits <- base::inherits
[17:45:19.894]                       invokeRestart <- base::invokeRestart
[17:45:19.894]                       is.null <- base::is.null
[17:45:19.894]                       muffled <- FALSE
[17:45:19.894]                       if (inherits(cond, "message")) {
[17:45:19.894]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.894]                         if (muffled) 
[17:45:19.894]                           invokeRestart("muffleMessage")
[17:45:19.894]                       }
[17:45:19.894]                       else if (inherits(cond, "warning")) {
[17:45:19.894]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.894]                         if (muffled) 
[17:45:19.894]                           invokeRestart("muffleWarning")
[17:45:19.894]                       }
[17:45:19.894]                       else if (inherits(cond, "condition")) {
[17:45:19.894]                         if (!is.null(pattern)) {
[17:45:19.894]                           computeRestarts <- base::computeRestarts
[17:45:19.894]                           grepl <- base::grepl
[17:45:19.894]                           restarts <- computeRestarts(cond)
[17:45:19.894]                           for (restart in restarts) {
[17:45:19.894]                             name <- restart$name
[17:45:19.894]                             if (is.null(name)) 
[17:45:19.894]                               next
[17:45:19.894]                             if (!grepl(pattern, name)) 
[17:45:19.894]                               next
[17:45:19.894]                             invokeRestart(restart)
[17:45:19.894]                             muffled <- TRUE
[17:45:19.894]                             break
[17:45:19.894]                           }
[17:45:19.894]                         }
[17:45:19.894]                       }
[17:45:19.894]                       invisible(muffled)
[17:45:19.894]                     }
[17:45:19.894]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.894]                   }
[17:45:19.894]                 }
[17:45:19.894]                 else {
[17:45:19.894]                   if (TRUE) {
[17:45:19.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.894]                     {
[17:45:19.894]                       inherits <- base::inherits
[17:45:19.894]                       invokeRestart <- base::invokeRestart
[17:45:19.894]                       is.null <- base::is.null
[17:45:19.894]                       muffled <- FALSE
[17:45:19.894]                       if (inherits(cond, "message")) {
[17:45:19.894]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.894]                         if (muffled) 
[17:45:19.894]                           invokeRestart("muffleMessage")
[17:45:19.894]                       }
[17:45:19.894]                       else if (inherits(cond, "warning")) {
[17:45:19.894]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.894]                         if (muffled) 
[17:45:19.894]                           invokeRestart("muffleWarning")
[17:45:19.894]                       }
[17:45:19.894]                       else if (inherits(cond, "condition")) {
[17:45:19.894]                         if (!is.null(pattern)) {
[17:45:19.894]                           computeRestarts <- base::computeRestarts
[17:45:19.894]                           grepl <- base::grepl
[17:45:19.894]                           restarts <- computeRestarts(cond)
[17:45:19.894]                           for (restart in restarts) {
[17:45:19.894]                             name <- restart$name
[17:45:19.894]                             if (is.null(name)) 
[17:45:19.894]                               next
[17:45:19.894]                             if (!grepl(pattern, name)) 
[17:45:19.894]                               next
[17:45:19.894]                             invokeRestart(restart)
[17:45:19.894]                             muffled <- TRUE
[17:45:19.894]                             break
[17:45:19.894]                           }
[17:45:19.894]                         }
[17:45:19.894]                       }
[17:45:19.894]                       invisible(muffled)
[17:45:19.894]                     }
[17:45:19.894]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.894]                   }
[17:45:19.894]                 }
[17:45:19.894]             }
[17:45:19.894]         }))
[17:45:19.894]     }, error = function(ex) {
[17:45:19.894]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.894]                 ...future.rng), started = ...future.startTime, 
[17:45:19.894]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.894]             version = "1.8"), class = "FutureResult")
[17:45:19.894]     }, finally = {
[17:45:19.894]         if (!identical(...future.workdir, getwd())) 
[17:45:19.894]             setwd(...future.workdir)
[17:45:19.894]         {
[17:45:19.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.894]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.894]             }
[17:45:19.894]             base::options(...future.oldOptions)
[17:45:19.894]             if (.Platform$OS.type == "windows") {
[17:45:19.894]                 old_names <- names(...future.oldEnvVars)
[17:45:19.894]                 envs <- base::Sys.getenv()
[17:45:19.894]                 names <- names(envs)
[17:45:19.894]                 common <- intersect(names, old_names)
[17:45:19.894]                 added <- setdiff(names, old_names)
[17:45:19.894]                 removed <- setdiff(old_names, names)
[17:45:19.894]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.894]                   envs[common]]
[17:45:19.894]                 NAMES <- toupper(changed)
[17:45:19.894]                 args <- list()
[17:45:19.894]                 for (kk in seq_along(NAMES)) {
[17:45:19.894]                   name <- changed[[kk]]
[17:45:19.894]                   NAME <- NAMES[[kk]]
[17:45:19.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.894]                     next
[17:45:19.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.894]                 }
[17:45:19.894]                 NAMES <- toupper(added)
[17:45:19.894]                 for (kk in seq_along(NAMES)) {
[17:45:19.894]                   name <- added[[kk]]
[17:45:19.894]                   NAME <- NAMES[[kk]]
[17:45:19.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.894]                     next
[17:45:19.894]                   args[[name]] <- ""
[17:45:19.894]                 }
[17:45:19.894]                 NAMES <- toupper(removed)
[17:45:19.894]                 for (kk in seq_along(NAMES)) {
[17:45:19.894]                   name <- removed[[kk]]
[17:45:19.894]                   NAME <- NAMES[[kk]]
[17:45:19.894]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.894]                     next
[17:45:19.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.894]                 }
[17:45:19.894]                 if (length(args) > 0) 
[17:45:19.894]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.894]             }
[17:45:19.894]             else {
[17:45:19.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.894]             }
[17:45:19.894]             {
[17:45:19.894]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.894]                   0L) {
[17:45:19.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.894]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.894]                   base::options(opts)
[17:45:19.894]                 }
[17:45:19.894]                 {
[17:45:19.894]                   {
[17:45:19.894]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.894]                     NULL
[17:45:19.894]                   }
[17:45:19.894]                   options(future.plan = NULL)
[17:45:19.894]                   if (is.na(NA_character_)) 
[17:45:19.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.894]                     .init = FALSE)
[17:45:19.894]                 }
[17:45:19.894]             }
[17:45:19.894]         }
[17:45:19.894]     })
[17:45:19.894]     if (TRUE) {
[17:45:19.894]         base::sink(type = "output", split = FALSE)
[17:45:19.894]         if (TRUE) {
[17:45:19.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.894]         }
[17:45:19.894]         else {
[17:45:19.894]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.894]         }
[17:45:19.894]         base::close(...future.stdout)
[17:45:19.894]         ...future.stdout <- NULL
[17:45:19.894]     }
[17:45:19.894]     ...future.result$conditions <- ...future.conditions
[17:45:19.894]     ...future.result$finished <- base::Sys.time()
[17:45:19.894]     ...future.result
[17:45:19.894] }
[17:45:19.896] assign_globals() ...
[17:45:19.896] List of 11
[17:45:19.896]  $ ...future.FUN            :function (x, ...)  
[17:45:19.896]  $ x_FUN                    :function (x, y)  
[17:45:19.896]  $ times                    : int 15
[17:45:19.896]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.896]  $ stop_if_not              :function (...)  
[17:45:19.896]  $ dim                      : int [1:2] 3 5
[17:45:19.896]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.896]  $ future.call.arguments    :List of 1
[17:45:19.896]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.896]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.896]  $ ...future.elements_ii    :List of 2
[17:45:19.896]   ..$ A: num 50
[17:45:19.896]   ..$ B: num 60
[17:45:19.896]  $ ...future.seeds_ii       : NULL
[17:45:19.896]  $ ...future.globals.maxSize: NULL
[17:45:19.896]  - attr(*, "where")=List of 11
[17:45:19.896]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.896]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.896]  - attr(*, "resolved")= logi FALSE
[17:45:19.896]  - attr(*, "total_size")= num 98600
[17:45:19.896]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.896]  - attr(*, "already-done")= logi TRUE
[17:45:19.907] - copied ‘...future.FUN’ to environment
[17:45:19.907] - reassign environment for ‘x_FUN’
[17:45:19.907] - copied ‘x_FUN’ to environment
[17:45:19.907] - copied ‘times’ to environment
[17:45:19.907] - copied ‘stopf’ to environment
[17:45:19.907] - copied ‘stop_if_not’ to environment
[17:45:19.907] - copied ‘dim’ to environment
[17:45:19.908] - copied ‘valid_types’ to environment
[17:45:19.908] - copied ‘future.call.arguments’ to environment
[17:45:19.908] - copied ‘...future.elements_ii’ to environment
[17:45:19.908] - copied ‘...future.seeds_ii’ to environment
[17:45:19.908] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.908] assign_globals() ... done
[17:45:19.908] requestCore(): workers = 2
[17:45:19.911] MulticoreFuture started
[17:45:19.911] - Launch lazy future ... done
[17:45:19.912] run() for ‘MulticoreFuture’ ... done
[17:45:19.913] Created future:
[17:45:19.913] plan(): Setting new future strategy stack:
[17:45:19.913] List of future strategies:
[17:45:19.913] 1. sequential:
[17:45:19.913]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.913]    - tweaked: FALSE
[17:45:19.913]    - call: NULL
[17:45:19.915] plan(): nbrOfWorkers() = 1
[17:45:19.918] plan(): Setting new future strategy stack:
[17:45:19.918] List of future strategies:
[17:45:19.918] 1. multicore:
[17:45:19.918]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.918]    - tweaked: FALSE
[17:45:19.918]    - call: plan(strategy)
[17:45:19.924] plan(): nbrOfWorkers() = 2
[17:45:19.913] MulticoreFuture:
[17:45:19.913] Label: ‘future_vapply-1’
[17:45:19.913] Expression:
[17:45:19.913] {
[17:45:19.913]     do.call(function(...) {
[17:45:19.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.913]             on.exit(options(oopts), add = TRUE)
[17:45:19.913]         }
[17:45:19.913]         {
[17:45:19.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.913]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.913]             })
[17:45:19.913]         }
[17:45:19.913]     }, args = future.call.arguments)
[17:45:19.913] }
[17:45:19.913] Lazy evaluation: FALSE
[17:45:19.913] Asynchronous evaluation: TRUE
[17:45:19.913] Local evaluation: TRUE
[17:45:19.913] Environment: R_GlobalEnv
[17:45:19.913] Capture standard output: TRUE
[17:45:19.913] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.913] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.913] Packages: 1 packages (‘future.apply’)
[17:45:19.913] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.913] Resolved: TRUE
[17:45:19.913] Value: <not collected>
[17:45:19.913] Conditions captured: <none>
[17:45:19.913] Early signaling: FALSE
[17:45:19.913] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.913] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.925] Chunk #1 of 2 ... DONE
[17:45:19.926] Chunk #2 of 2 ...
[17:45:19.926]  - Finding globals in 'X' for chunk #2 ...
[17:45:19.926] getGlobalsAndPackages() ...
[17:45:19.926] Searching for globals...
[17:45:19.927] 
[17:45:19.927] Searching for globals ... DONE
[17:45:19.927] - globals: [0] <none>
[17:45:19.928] getGlobalsAndPackages() ... DONE
[17:45:19.928]    + additional globals found: [n=0] 
[17:45:19.928]    + additional namespaces needed: [n=0] 
[17:45:19.928]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:19.928]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:19.928]  - seeds: <none>
[17:45:19.928]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.929] getGlobalsAndPackages() ...
[17:45:19.929] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.929] Resolving globals: FALSE
[17:45:19.929] Tweak future expression to call with '...' arguments ...
[17:45:19.929] {
[17:45:19.929]     do.call(function(...) {
[17:45:19.929]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.929]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.929]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.929]             on.exit(options(oopts), add = TRUE)
[17:45:19.929]         }
[17:45:19.929]         {
[17:45:19.929]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.929]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.929]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.929]             })
[17:45:19.929]         }
[17:45:19.929]     }, args = future.call.arguments)
[17:45:19.929] }
[17:45:19.930] Tweak future expression to call with '...' arguments ... DONE
[17:45:19.931] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:19.931] - packages: [1] ‘future.apply’
[17:45:19.931] getGlobalsAndPackages() ... DONE
[17:45:19.932] run() for ‘Future’ ...
[17:45:19.932] - state: ‘created’
[17:45:19.932] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:19.936] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:19.937]   - Field: ‘label’
[17:45:19.937]   - Field: ‘local’
[17:45:19.937]   - Field: ‘owner’
[17:45:19.937]   - Field: ‘envir’
[17:45:19.937]   - Field: ‘workers’
[17:45:19.937]   - Field: ‘packages’
[17:45:19.937]   - Field: ‘gc’
[17:45:19.938]   - Field: ‘job’
[17:45:19.938]   - Field: ‘conditions’
[17:45:19.938]   - Field: ‘expr’
[17:45:19.938]   - Field: ‘uuid’
[17:45:19.938]   - Field: ‘seed’
[17:45:19.938]   - Field: ‘version’
[17:45:19.938]   - Field: ‘result’
[17:45:19.938]   - Field: ‘asynchronous’
[17:45:19.939]   - Field: ‘calls’
[17:45:19.939]   - Field: ‘globals’
[17:45:19.939]   - Field: ‘stdout’
[17:45:19.939]   - Field: ‘earlySignal’
[17:45:19.939]   - Field: ‘lazy’
[17:45:19.939]   - Field: ‘state’
[17:45:19.939] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:19.940] - Launch lazy future ...
[17:45:19.940] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:19.940] Packages needed by future strategies (n = 0): <none>
[17:45:19.941] {
[17:45:19.941]     {
[17:45:19.941]         {
[17:45:19.941]             ...future.startTime <- base::Sys.time()
[17:45:19.941]             {
[17:45:19.941]                 {
[17:45:19.941]                   {
[17:45:19.941]                     {
[17:45:19.941]                       {
[17:45:19.941]                         base::local({
[17:45:19.941]                           has_future <- base::requireNamespace("future", 
[17:45:19.941]                             quietly = TRUE)
[17:45:19.941]                           if (has_future) {
[17:45:19.941]                             ns <- base::getNamespace("future")
[17:45:19.941]                             version <- ns[[".package"]][["version"]]
[17:45:19.941]                             if (is.null(version)) 
[17:45:19.941]                               version <- utils::packageVersion("future")
[17:45:19.941]                           }
[17:45:19.941]                           else {
[17:45:19.941]                             version <- NULL
[17:45:19.941]                           }
[17:45:19.941]                           if (!has_future || version < "1.8.0") {
[17:45:19.941]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:19.941]                               "", base::R.version$version.string), 
[17:45:19.941]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:19.941]                                 base::R.version$platform, 8 * 
[17:45:19.941]                                   base::.Machine$sizeof.pointer), 
[17:45:19.941]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:19.941]                                 "release", "version")], collapse = " "), 
[17:45:19.941]                               hostname = base::Sys.info()[["nodename"]])
[17:45:19.941]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:19.941]                               info)
[17:45:19.941]                             info <- base::paste(info, collapse = "; ")
[17:45:19.941]                             if (!has_future) {
[17:45:19.941]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:19.941]                                 info)
[17:45:19.941]                             }
[17:45:19.941]                             else {
[17:45:19.941]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:19.941]                                 info, version)
[17:45:19.941]                             }
[17:45:19.941]                             base::stop(msg)
[17:45:19.941]                           }
[17:45:19.941]                         })
[17:45:19.941]                       }
[17:45:19.941]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:19.941]                       base::options(mc.cores = 1L)
[17:45:19.941]                     }
[17:45:19.941]                     base::local({
[17:45:19.941]                       for (pkg in "future.apply") {
[17:45:19.941]                         base::loadNamespace(pkg)
[17:45:19.941]                         base::library(pkg, character.only = TRUE)
[17:45:19.941]                       }
[17:45:19.941]                     })
[17:45:19.941]                   }
[17:45:19.941]                   ...future.strategy.old <- future::plan("list")
[17:45:19.941]                   options(future.plan = NULL)
[17:45:19.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:19.941]                 }
[17:45:19.941]                 ...future.workdir <- getwd()
[17:45:19.941]             }
[17:45:19.941]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:19.941]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:19.941]         }
[17:45:19.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:19.941]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:19.941]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:19.941]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:19.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:19.941]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:19.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:19.941]             base::names(...future.oldOptions))
[17:45:19.941]     }
[17:45:19.941]     if (FALSE) {
[17:45:19.941]     }
[17:45:19.941]     else {
[17:45:19.941]         if (TRUE) {
[17:45:19.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:19.941]                 open = "w")
[17:45:19.941]         }
[17:45:19.941]         else {
[17:45:19.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:19.941]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:19.941]         }
[17:45:19.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:19.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:19.941]             base::sink(type = "output", split = FALSE)
[17:45:19.941]             base::close(...future.stdout)
[17:45:19.941]         }, add = TRUE)
[17:45:19.941]     }
[17:45:19.941]     ...future.frame <- base::sys.nframe()
[17:45:19.941]     ...future.conditions <- base::list()
[17:45:19.941]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:19.941]     if (FALSE) {
[17:45:19.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:19.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:19.941]     }
[17:45:19.941]     ...future.result <- base::tryCatch({
[17:45:19.941]         base::withCallingHandlers({
[17:45:19.941]             ...future.value <- base::withVisible(base::local({
[17:45:19.941]                 withCallingHandlers({
[17:45:19.941]                   {
[17:45:19.941]                     do.call(function(...) {
[17:45:19.941]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.941]                       if (!identical(...future.globals.maxSize.org, 
[17:45:19.941]                         ...future.globals.maxSize)) {
[17:45:19.941]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.941]                         on.exit(options(oopts), add = TRUE)
[17:45:19.941]                       }
[17:45:19.941]                       {
[17:45:19.941]                         lapply(seq_along(...future.elements_ii), 
[17:45:19.941]                           FUN = function(jj) {
[17:45:19.941]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.941]                             ...future.FUN(...future.X_jj, ...)
[17:45:19.941]                           })
[17:45:19.941]                       }
[17:45:19.941]                     }, args = future.call.arguments)
[17:45:19.941]                   }
[17:45:19.941]                 }, immediateCondition = function(cond) {
[17:45:19.941]                   save_rds <- function (object, pathname, ...) 
[17:45:19.941]                   {
[17:45:19.941]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:19.941]                     if (file_test("-f", pathname_tmp)) {
[17:45:19.941]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.941]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:19.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.941]                         fi_tmp[["mtime"]])
[17:45:19.941]                     }
[17:45:19.941]                     tryCatch({
[17:45:19.941]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:19.941]                     }, error = function(ex) {
[17:45:19.941]                       msg <- conditionMessage(ex)
[17:45:19.941]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.941]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:19.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.941]                         fi_tmp[["mtime"]], msg)
[17:45:19.941]                       ex$message <- msg
[17:45:19.941]                       stop(ex)
[17:45:19.941]                     })
[17:45:19.941]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:19.941]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:19.941]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:19.941]                       fi_tmp <- file.info(pathname_tmp)
[17:45:19.941]                       fi <- file.info(pathname)
[17:45:19.941]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:19.941]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:19.941]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:19.941]                         fi[["size"]], fi[["mtime"]])
[17:45:19.941]                       stop(msg)
[17:45:19.941]                     }
[17:45:19.941]                     invisible(pathname)
[17:45:19.941]                   }
[17:45:19.941]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:19.941]                     rootPath = tempdir()) 
[17:45:19.941]                   {
[17:45:19.941]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:19.941]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:19.941]                       tmpdir = path, fileext = ".rds")
[17:45:19.941]                     save_rds(obj, file)
[17:45:19.941]                   }
[17:45:19.941]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:19.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.941]                   {
[17:45:19.941]                     inherits <- base::inherits
[17:45:19.941]                     invokeRestart <- base::invokeRestart
[17:45:19.941]                     is.null <- base::is.null
[17:45:19.941]                     muffled <- FALSE
[17:45:19.941]                     if (inherits(cond, "message")) {
[17:45:19.941]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:19.941]                       if (muffled) 
[17:45:19.941]                         invokeRestart("muffleMessage")
[17:45:19.941]                     }
[17:45:19.941]                     else if (inherits(cond, "warning")) {
[17:45:19.941]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:19.941]                       if (muffled) 
[17:45:19.941]                         invokeRestart("muffleWarning")
[17:45:19.941]                     }
[17:45:19.941]                     else if (inherits(cond, "condition")) {
[17:45:19.941]                       if (!is.null(pattern)) {
[17:45:19.941]                         computeRestarts <- base::computeRestarts
[17:45:19.941]                         grepl <- base::grepl
[17:45:19.941]                         restarts <- computeRestarts(cond)
[17:45:19.941]                         for (restart in restarts) {
[17:45:19.941]                           name <- restart$name
[17:45:19.941]                           if (is.null(name)) 
[17:45:19.941]                             next
[17:45:19.941]                           if (!grepl(pattern, name)) 
[17:45:19.941]                             next
[17:45:19.941]                           invokeRestart(restart)
[17:45:19.941]                           muffled <- TRUE
[17:45:19.941]                           break
[17:45:19.941]                         }
[17:45:19.941]                       }
[17:45:19.941]                     }
[17:45:19.941]                     invisible(muffled)
[17:45:19.941]                   }
[17:45:19.941]                   muffleCondition(cond)
[17:45:19.941]                 })
[17:45:19.941]             }))
[17:45:19.941]             future::FutureResult(value = ...future.value$value, 
[17:45:19.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.941]                   ...future.rng), globalenv = if (FALSE) 
[17:45:19.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:19.941]                     ...future.globalenv.names))
[17:45:19.941]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:19.941]         }, condition = base::local({
[17:45:19.941]             c <- base::c
[17:45:19.941]             inherits <- base::inherits
[17:45:19.941]             invokeRestart <- base::invokeRestart
[17:45:19.941]             length <- base::length
[17:45:19.941]             list <- base::list
[17:45:19.941]             seq.int <- base::seq.int
[17:45:19.941]             signalCondition <- base::signalCondition
[17:45:19.941]             sys.calls <- base::sys.calls
[17:45:19.941]             `[[` <- base::`[[`
[17:45:19.941]             `+` <- base::`+`
[17:45:19.941]             `<<-` <- base::`<<-`
[17:45:19.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:19.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:19.941]                   3L)]
[17:45:19.941]             }
[17:45:19.941]             function(cond) {
[17:45:19.941]                 is_error <- inherits(cond, "error")
[17:45:19.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:19.941]                   NULL)
[17:45:19.941]                 if (is_error) {
[17:45:19.941]                   sessionInformation <- function() {
[17:45:19.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:19.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:19.941]                       search = base::search(), system = base::Sys.info())
[17:45:19.941]                   }
[17:45:19.941]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:19.941]                     cond$call), session = sessionInformation(), 
[17:45:19.941]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:19.941]                   signalCondition(cond)
[17:45:19.941]                 }
[17:45:19.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:19.941]                 "immediateCondition"))) {
[17:45:19.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:19.941]                   ...future.conditions[[length(...future.conditions) + 
[17:45:19.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:19.941]                   if (TRUE && !signal) {
[17:45:19.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.941]                     {
[17:45:19.941]                       inherits <- base::inherits
[17:45:19.941]                       invokeRestart <- base::invokeRestart
[17:45:19.941]                       is.null <- base::is.null
[17:45:19.941]                       muffled <- FALSE
[17:45:19.941]                       if (inherits(cond, "message")) {
[17:45:19.941]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.941]                         if (muffled) 
[17:45:19.941]                           invokeRestart("muffleMessage")
[17:45:19.941]                       }
[17:45:19.941]                       else if (inherits(cond, "warning")) {
[17:45:19.941]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.941]                         if (muffled) 
[17:45:19.941]                           invokeRestart("muffleWarning")
[17:45:19.941]                       }
[17:45:19.941]                       else if (inherits(cond, "condition")) {
[17:45:19.941]                         if (!is.null(pattern)) {
[17:45:19.941]                           computeRestarts <- base::computeRestarts
[17:45:19.941]                           grepl <- base::grepl
[17:45:19.941]                           restarts <- computeRestarts(cond)
[17:45:19.941]                           for (restart in restarts) {
[17:45:19.941]                             name <- restart$name
[17:45:19.941]                             if (is.null(name)) 
[17:45:19.941]                               next
[17:45:19.941]                             if (!grepl(pattern, name)) 
[17:45:19.941]                               next
[17:45:19.941]                             invokeRestart(restart)
[17:45:19.941]                             muffled <- TRUE
[17:45:19.941]                             break
[17:45:19.941]                           }
[17:45:19.941]                         }
[17:45:19.941]                       }
[17:45:19.941]                       invisible(muffled)
[17:45:19.941]                     }
[17:45:19.941]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.941]                   }
[17:45:19.941]                 }
[17:45:19.941]                 else {
[17:45:19.941]                   if (TRUE) {
[17:45:19.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:19.941]                     {
[17:45:19.941]                       inherits <- base::inherits
[17:45:19.941]                       invokeRestart <- base::invokeRestart
[17:45:19.941]                       is.null <- base::is.null
[17:45:19.941]                       muffled <- FALSE
[17:45:19.941]                       if (inherits(cond, "message")) {
[17:45:19.941]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:19.941]                         if (muffled) 
[17:45:19.941]                           invokeRestart("muffleMessage")
[17:45:19.941]                       }
[17:45:19.941]                       else if (inherits(cond, "warning")) {
[17:45:19.941]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:19.941]                         if (muffled) 
[17:45:19.941]                           invokeRestart("muffleWarning")
[17:45:19.941]                       }
[17:45:19.941]                       else if (inherits(cond, "condition")) {
[17:45:19.941]                         if (!is.null(pattern)) {
[17:45:19.941]                           computeRestarts <- base::computeRestarts
[17:45:19.941]                           grepl <- base::grepl
[17:45:19.941]                           restarts <- computeRestarts(cond)
[17:45:19.941]                           for (restart in restarts) {
[17:45:19.941]                             name <- restart$name
[17:45:19.941]                             if (is.null(name)) 
[17:45:19.941]                               next
[17:45:19.941]                             if (!grepl(pattern, name)) 
[17:45:19.941]                               next
[17:45:19.941]                             invokeRestart(restart)
[17:45:19.941]                             muffled <- TRUE
[17:45:19.941]                             break
[17:45:19.941]                           }
[17:45:19.941]                         }
[17:45:19.941]                       }
[17:45:19.941]                       invisible(muffled)
[17:45:19.941]                     }
[17:45:19.941]                     muffleCondition(cond, pattern = "^muffle")
[17:45:19.941]                   }
[17:45:19.941]                 }
[17:45:19.941]             }
[17:45:19.941]         }))
[17:45:19.941]     }, error = function(ex) {
[17:45:19.941]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:19.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:19.941]                 ...future.rng), started = ...future.startTime, 
[17:45:19.941]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:19.941]             version = "1.8"), class = "FutureResult")
[17:45:19.941]     }, finally = {
[17:45:19.941]         if (!identical(...future.workdir, getwd())) 
[17:45:19.941]             setwd(...future.workdir)
[17:45:19.941]         {
[17:45:19.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:19.941]                 ...future.oldOptions$nwarnings <- NULL
[17:45:19.941]             }
[17:45:19.941]             base::options(...future.oldOptions)
[17:45:19.941]             if (.Platform$OS.type == "windows") {
[17:45:19.941]                 old_names <- names(...future.oldEnvVars)
[17:45:19.941]                 envs <- base::Sys.getenv()
[17:45:19.941]                 names <- names(envs)
[17:45:19.941]                 common <- intersect(names, old_names)
[17:45:19.941]                 added <- setdiff(names, old_names)
[17:45:19.941]                 removed <- setdiff(old_names, names)
[17:45:19.941]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:19.941]                   envs[common]]
[17:45:19.941]                 NAMES <- toupper(changed)
[17:45:19.941]                 args <- list()
[17:45:19.941]                 for (kk in seq_along(NAMES)) {
[17:45:19.941]                   name <- changed[[kk]]
[17:45:19.941]                   NAME <- NAMES[[kk]]
[17:45:19.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.941]                     next
[17:45:19.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.941]                 }
[17:45:19.941]                 NAMES <- toupper(added)
[17:45:19.941]                 for (kk in seq_along(NAMES)) {
[17:45:19.941]                   name <- added[[kk]]
[17:45:19.941]                   NAME <- NAMES[[kk]]
[17:45:19.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.941]                     next
[17:45:19.941]                   args[[name]] <- ""
[17:45:19.941]                 }
[17:45:19.941]                 NAMES <- toupper(removed)
[17:45:19.941]                 for (kk in seq_along(NAMES)) {
[17:45:19.941]                   name <- removed[[kk]]
[17:45:19.941]                   NAME <- NAMES[[kk]]
[17:45:19.941]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:19.941]                     next
[17:45:19.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:19.941]                 }
[17:45:19.941]                 if (length(args) > 0) 
[17:45:19.941]                   base::do.call(base::Sys.setenv, args = args)
[17:45:19.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:19.941]             }
[17:45:19.941]             else {
[17:45:19.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:19.941]             }
[17:45:19.941]             {
[17:45:19.941]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:19.941]                   0L) {
[17:45:19.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:19.941]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:19.941]                   base::options(opts)
[17:45:19.941]                 }
[17:45:19.941]                 {
[17:45:19.941]                   {
[17:45:19.941]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:19.941]                     NULL
[17:45:19.941]                   }
[17:45:19.941]                   options(future.plan = NULL)
[17:45:19.941]                   if (is.na(NA_character_)) 
[17:45:19.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:19.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:19.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:19.941]                     .init = FALSE)
[17:45:19.941]                 }
[17:45:19.941]             }
[17:45:19.941]         }
[17:45:19.941]     })
[17:45:19.941]     if (TRUE) {
[17:45:19.941]         base::sink(type = "output", split = FALSE)
[17:45:19.941]         if (TRUE) {
[17:45:19.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:19.941]         }
[17:45:19.941]         else {
[17:45:19.941]             ...future.result["stdout"] <- base::list(NULL)
[17:45:19.941]         }
[17:45:19.941]         base::close(...future.stdout)
[17:45:19.941]         ...future.stdout <- NULL
[17:45:19.941]     }
[17:45:19.941]     ...future.result$conditions <- ...future.conditions
[17:45:19.941]     ...future.result$finished <- base::Sys.time()
[17:45:19.941]     ...future.result
[17:45:19.941] }
[17:45:19.944] assign_globals() ...
[17:45:19.945] List of 11
[17:45:19.945]  $ ...future.FUN            :function (x, ...)  
[17:45:19.945]  $ x_FUN                    :function (x, y)  
[17:45:19.945]  $ times                    : int 15
[17:45:19.945]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:19.945]  $ stop_if_not              :function (...)  
[17:45:19.945]  $ dim                      : int [1:2] 3 5
[17:45:19.945]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:19.945]  $ future.call.arguments    :List of 1
[17:45:19.945]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:19.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:19.945]  $ ...future.elements_ii    :List of 2
[17:45:19.945]   ..$ C: num 70
[17:45:19.945]   ..$ D: num 80
[17:45:19.945]  $ ...future.seeds_ii       : NULL
[17:45:19.945]  $ ...future.globals.maxSize: NULL
[17:45:19.945]  - attr(*, "where")=List of 11
[17:45:19.945]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:19.945]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:19.945]  - attr(*, "resolved")= logi FALSE
[17:45:19.945]  - attr(*, "total_size")= num 98600
[17:45:19.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:19.945]  - attr(*, "already-done")= logi TRUE
[17:45:19.960] - copied ‘...future.FUN’ to environment
[17:45:19.960] - reassign environment for ‘x_FUN’
[17:45:19.960] - copied ‘x_FUN’ to environment
[17:45:19.960] - copied ‘times’ to environment
[17:45:19.961] - copied ‘stopf’ to environment
[17:45:19.961] - copied ‘stop_if_not’ to environment
[17:45:19.961] - copied ‘dim’ to environment
[17:45:19.961] - copied ‘valid_types’ to environment
[17:45:19.961] - copied ‘future.call.arguments’ to environment
[17:45:19.961] - copied ‘...future.elements_ii’ to environment
[17:45:19.961] - copied ‘...future.seeds_ii’ to environment
[17:45:19.961] - copied ‘...future.globals.maxSize’ to environment
[17:45:19.962] assign_globals() ... done
[17:45:19.962] requestCore(): workers = 2
[17:45:19.964] MulticoreFuture started
[17:45:19.965] - Launch lazy future ... done
[17:45:19.966] run() for ‘MulticoreFuture’ ... done
[17:45:19.966] Created future:
[17:45:19.966] plan(): Setting new future strategy stack:
[17:45:19.967] List of future strategies:
[17:45:19.967] 1. sequential:
[17:45:19.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:19.967]    - tweaked: FALSE
[17:45:19.967]    - call: NULL
[17:45:19.969] plan(): nbrOfWorkers() = 1
[17:45:19.972] plan(): Setting new future strategy stack:
[17:45:19.972] List of future strategies:
[17:45:19.972] 1. multicore:
[17:45:19.972]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:19.972]    - tweaked: FALSE
[17:45:19.972]    - call: plan(strategy)
[17:45:19.978] plan(): nbrOfWorkers() = 2
[17:45:19.967] MulticoreFuture:
[17:45:19.967] Label: ‘future_vapply-2’
[17:45:19.967] Expression:
[17:45:19.967] {
[17:45:19.967]     do.call(function(...) {
[17:45:19.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:19.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:19.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:19.967]             on.exit(options(oopts), add = TRUE)
[17:45:19.967]         }
[17:45:19.967]         {
[17:45:19.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:19.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:19.967]                 ...future.FUN(...future.X_jj, ...)
[17:45:19.967]             })
[17:45:19.967]         }
[17:45:19.967]     }, args = future.call.arguments)
[17:45:19.967] }
[17:45:19.967] Lazy evaluation: FALSE
[17:45:19.967] Asynchronous evaluation: TRUE
[17:45:19.967] Local evaluation: TRUE
[17:45:19.967] Environment: R_GlobalEnv
[17:45:19.967] Capture standard output: TRUE
[17:45:19.967] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:19.967] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:19.967] Packages: 1 packages (‘future.apply’)
[17:45:19.967] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:19.967] Resolved: TRUE
[17:45:19.967] Value: <not collected>
[17:45:19.967] Conditions captured: <none>
[17:45:19.967] Early signaling: FALSE
[17:45:19.967] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:19.967] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:19.979] Chunk #2 of 2 ... DONE
[17:45:19.979] Launching 2 futures (chunks) ... DONE
[17:45:19.980] Resolving 2 futures (chunks) ...
[17:45:19.980] resolve() on list ...
[17:45:19.980]  recursive: 0
[17:45:19.980]  length: 2
[17:45:19.980] 
[17:45:19.981] Future #1
[17:45:19.981] result() for MulticoreFuture ...
[17:45:19.982] result() for MulticoreFuture ...
[17:45:19.982] result() for MulticoreFuture ... done
[17:45:19.982] result() for MulticoreFuture ... done
[17:45:19.982] result() for MulticoreFuture ...
[17:45:19.983] result() for MulticoreFuture ... done
[17:45:19.983] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:19.983] - nx: 2
[17:45:19.983] - relay: TRUE
[17:45:19.984] - stdout: TRUE
[17:45:19.984] - signal: TRUE
[17:45:19.984] - resignal: FALSE
[17:45:19.984] - force: TRUE
[17:45:19.984] - relayed: [n=2] FALSE, FALSE
[17:45:19.984] - queued futures: [n=2] FALSE, FALSE
[17:45:19.985]  - until=1
[17:45:19.985]  - relaying element #1
[17:45:19.985] result() for MulticoreFuture ...
[17:45:19.985] result() for MulticoreFuture ... done
[17:45:19.985] result() for MulticoreFuture ...
[17:45:19.986] result() for MulticoreFuture ... done
[17:45:19.986] result() for MulticoreFuture ...
[17:45:19.986] result() for MulticoreFuture ... done
[17:45:19.986] result() for MulticoreFuture ...
[17:45:19.986] result() for MulticoreFuture ... done
[17:45:19.987] - relayed: [n=2] TRUE, FALSE
[17:45:19.987] - queued futures: [n=2] TRUE, FALSE
[17:45:19.987] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:19.987]  length: 1 (resolved future 1)
[17:45:19.987] Future #2
[17:45:19.988] result() for MulticoreFuture ...
[17:45:19.988] result() for MulticoreFuture ...
[17:45:19.988] result() for MulticoreFuture ... done
[17:45:19.989] result() for MulticoreFuture ... done
[17:45:19.989] result() for MulticoreFuture ...
[17:45:19.989] result() for MulticoreFuture ... done
[17:45:19.989] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:19.989] - nx: 2
[17:45:19.989] - relay: TRUE
[17:45:19.989] - stdout: TRUE
[17:45:19.989] - signal: TRUE
[17:45:19.989] - resignal: FALSE
[17:45:19.990] - force: TRUE
[17:45:19.990] - relayed: [n=2] TRUE, FALSE
[17:45:19.990] - queued futures: [n=2] TRUE, FALSE
[17:45:19.990]  - until=2
[17:45:19.990]  - relaying element #2
[17:45:19.990] result() for MulticoreFuture ...
[17:45:19.990] result() for MulticoreFuture ... done
[17:45:19.990] result() for MulticoreFuture ...
[17:45:19.990] result() for MulticoreFuture ... done
[17:45:19.991] result() for MulticoreFuture ...
[17:45:19.991] result() for MulticoreFuture ... done
[17:45:19.991] result() for MulticoreFuture ...
[17:45:19.991] result() for MulticoreFuture ... done
[17:45:19.991] - relayed: [n=2] TRUE, TRUE
[17:45:19.991] - queued futures: [n=2] TRUE, TRUE
[17:45:19.991] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:19.991]  length: 0 (resolved future 2)
[17:45:19.992] Relaying remaining futures
[17:45:19.992] signalConditionsASAP(NULL, pos=0) ...
[17:45:19.992] - nx: 2
[17:45:19.992] - relay: TRUE
[17:45:19.992] - stdout: TRUE
[17:45:19.992] - signal: TRUE
[17:45:19.992] - resignal: FALSE
[17:45:19.992] - force: TRUE
[17:45:19.992] - relayed: [n=2] TRUE, TRUE
[17:45:19.992] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:19.993] - relayed: [n=2] TRUE, TRUE
[17:45:19.993] - queued futures: [n=2] TRUE, TRUE
[17:45:19.993] signalConditionsASAP(NULL, pos=0) ... done
[17:45:19.993] resolve() on list ... DONE
[17:45:19.993] result() for MulticoreFuture ...
[17:45:19.993] result() for MulticoreFuture ... done
[17:45:19.993] result() for MulticoreFuture ...
[17:45:19.993] result() for MulticoreFuture ... done
[17:45:19.993] result() for MulticoreFuture ...
[17:45:19.994] result() for MulticoreFuture ... done
[17:45:19.994] result() for MulticoreFuture ...
[17:45:19.994] result() for MulticoreFuture ... done
[17:45:19.994]  - Number of value chunks collected: 2
[17:45:19.994] Resolving 2 futures (chunks) ... DONE
[17:45:19.994] Reducing values from 2 chunks ...
[17:45:19.994]  - Number of values collected after concatenation: 4
[17:45:19.994]  - Number of values expected: 4
[17:45:19.994] Reducing values from 2 chunks ... DONE
[17:45:19.995] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:45:19.997] future_lapply() ...
[17:45:20.005] Number of chunks: 2
[17:45:20.005] getGlobalsAndPackagesXApply() ...
[17:45:20.006]  - future.globals: TRUE
[17:45:20.006] getGlobalsAndPackages() ...
[17:45:20.006] Searching for globals...
[17:45:20.010] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:20.010] Searching for globals ... DONE
[17:45:20.010] Resolving globals: FALSE
[17:45:20.011] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:45:20.012] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:20.012] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:20.012] - packages: [1] ‘future.apply’
[17:45:20.012] getGlobalsAndPackages() ... DONE
[17:45:20.012]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:20.012]  - needed namespaces: [n=1] ‘future.apply’
[17:45:20.012] Finding globals ... DONE
[17:45:20.013]  - use_args: TRUE
[17:45:20.013]  - Getting '...' globals ...
[17:45:20.013] resolve() on list ...
[17:45:20.013]  recursive: 0
[17:45:20.013]  length: 1
[17:45:20.013]  elements: ‘...’
[17:45:20.013]  length: 0 (resolved future 1)
[17:45:20.013] resolve() on list ... DONE
[17:45:20.014]    - '...' content: [n=0] 
[17:45:20.014] List of 1
[17:45:20.014]  $ ...: list()
[17:45:20.014]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.014]  - attr(*, "where")=List of 1
[17:45:20.014]   ..$ ...:<environment: 0x5561f5371f70> 
[17:45:20.014]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.014]  - attr(*, "resolved")= logi TRUE
[17:45:20.014]  - attr(*, "total_size")= num NA
[17:45:20.016]  - Getting '...' globals ... DONE
[17:45:20.016] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:20.017] List of 8
[17:45:20.017]  $ ...future.FUN:function (x, ...)  
[17:45:20.017]  $ x_FUN        :function (x)  
[17:45:20.017]  $ times        : int 1
[17:45:20.017]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.017]  $ stop_if_not  :function (...)  
[17:45:20.017]  $ dim          : NULL
[17:45:20.017]  $ valid_types  : chr "logical"
[17:45:20.017]  $ ...          : list()
[17:45:20.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.017]  - attr(*, "where")=List of 8
[17:45:20.017]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:20.017]   ..$ ...          :<environment: 0x5561f5371f70> 
[17:45:20.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.017]  - attr(*, "resolved")= logi FALSE
[17:45:20.017]  - attr(*, "total_size")= num 94200
[17:45:20.022] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:20.022] getGlobalsAndPackagesXApply() ... DONE
[17:45:20.022] Number of futures (= number of chunks): 2
[17:45:20.022] Launching 2 futures (chunks) ...
[17:45:20.022] Chunk #1 of 2 ...
[17:45:20.023]  - Finding globals in 'X' for chunk #1 ...
[17:45:20.023] getGlobalsAndPackages() ...
[17:45:20.023] Searching for globals...
[17:45:20.023] 
[17:45:20.023] Searching for globals ... DONE
[17:45:20.023] - globals: [0] <none>
[17:45:20.023] getGlobalsAndPackages() ... DONE
[17:45:20.023]    + additional globals found: [n=0] 
[17:45:20.024]    + additional namespaces needed: [n=0] 
[17:45:20.024]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:20.024]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:20.024]  - seeds: <none>
[17:45:20.024]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.024] getGlobalsAndPackages() ...
[17:45:20.024] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.024] Resolving globals: FALSE
[17:45:20.024] Tweak future expression to call with '...' arguments ...
[17:45:20.027] {
[17:45:20.027]     do.call(function(...) {
[17:45:20.027]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.027]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.027]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.027]             on.exit(options(oopts), add = TRUE)
[17:45:20.027]         }
[17:45:20.027]         {
[17:45:20.027]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.027]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.027]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.027]             })
[17:45:20.027]         }
[17:45:20.027]     }, args = future.call.arguments)
[17:45:20.027] }
[17:45:20.027] Tweak future expression to call with '...' arguments ... DONE
[17:45:20.027] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.028] - packages: [1] ‘future.apply’
[17:45:20.028] getGlobalsAndPackages() ... DONE
[17:45:20.028] run() for ‘Future’ ...
[17:45:20.028] - state: ‘created’
[17:45:20.028] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:20.033] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.033] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:20.033]   - Field: ‘label’
[17:45:20.033]   - Field: ‘local’
[17:45:20.033]   - Field: ‘owner’
[17:45:20.034]   - Field: ‘envir’
[17:45:20.034]   - Field: ‘workers’
[17:45:20.034]   - Field: ‘packages’
[17:45:20.034]   - Field: ‘gc’
[17:45:20.034]   - Field: ‘job’
[17:45:20.034]   - Field: ‘conditions’
[17:45:20.034]   - Field: ‘expr’
[17:45:20.034]   - Field: ‘uuid’
[17:45:20.035]   - Field: ‘seed’
[17:45:20.035]   - Field: ‘version’
[17:45:20.035]   - Field: ‘result’
[17:45:20.035]   - Field: ‘asynchronous’
[17:45:20.035]   - Field: ‘calls’
[17:45:20.035]   - Field: ‘globals’
[17:45:20.035]   - Field: ‘stdout’
[17:45:20.035]   - Field: ‘earlySignal’
[17:45:20.036]   - Field: ‘lazy’
[17:45:20.036]   - Field: ‘state’
[17:45:20.036] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:20.036] - Launch lazy future ...
[17:45:20.036] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:20.036] Packages needed by future strategies (n = 0): <none>
[17:45:20.037] {
[17:45:20.037]     {
[17:45:20.037]         {
[17:45:20.037]             ...future.startTime <- base::Sys.time()
[17:45:20.037]             {
[17:45:20.037]                 {
[17:45:20.037]                   {
[17:45:20.037]                     {
[17:45:20.037]                       {
[17:45:20.037]                         base::local({
[17:45:20.037]                           has_future <- base::requireNamespace("future", 
[17:45:20.037]                             quietly = TRUE)
[17:45:20.037]                           if (has_future) {
[17:45:20.037]                             ns <- base::getNamespace("future")
[17:45:20.037]                             version <- ns[[".package"]][["version"]]
[17:45:20.037]                             if (is.null(version)) 
[17:45:20.037]                               version <- utils::packageVersion("future")
[17:45:20.037]                           }
[17:45:20.037]                           else {
[17:45:20.037]                             version <- NULL
[17:45:20.037]                           }
[17:45:20.037]                           if (!has_future || version < "1.8.0") {
[17:45:20.037]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.037]                               "", base::R.version$version.string), 
[17:45:20.037]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:20.037]                                 base::R.version$platform, 8 * 
[17:45:20.037]                                   base::.Machine$sizeof.pointer), 
[17:45:20.037]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.037]                                 "release", "version")], collapse = " "), 
[17:45:20.037]                               hostname = base::Sys.info()[["nodename"]])
[17:45:20.037]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.037]                               info)
[17:45:20.037]                             info <- base::paste(info, collapse = "; ")
[17:45:20.037]                             if (!has_future) {
[17:45:20.037]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.037]                                 info)
[17:45:20.037]                             }
[17:45:20.037]                             else {
[17:45:20.037]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.037]                                 info, version)
[17:45:20.037]                             }
[17:45:20.037]                             base::stop(msg)
[17:45:20.037]                           }
[17:45:20.037]                         })
[17:45:20.037]                       }
[17:45:20.037]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.037]                       base::options(mc.cores = 1L)
[17:45:20.037]                     }
[17:45:20.037]                     base::local({
[17:45:20.037]                       for (pkg in "future.apply") {
[17:45:20.037]                         base::loadNamespace(pkg)
[17:45:20.037]                         base::library(pkg, character.only = TRUE)
[17:45:20.037]                       }
[17:45:20.037]                     })
[17:45:20.037]                   }
[17:45:20.037]                   ...future.strategy.old <- future::plan("list")
[17:45:20.037]                   options(future.plan = NULL)
[17:45:20.037]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.037]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.037]                 }
[17:45:20.037]                 ...future.workdir <- getwd()
[17:45:20.037]             }
[17:45:20.037]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.037]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.037]         }
[17:45:20.037]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.037]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:20.037]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.037]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.037]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.037]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.037]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.037]             base::names(...future.oldOptions))
[17:45:20.037]     }
[17:45:20.037]     if (FALSE) {
[17:45:20.037]     }
[17:45:20.037]     else {
[17:45:20.037]         if (TRUE) {
[17:45:20.037]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.037]                 open = "w")
[17:45:20.037]         }
[17:45:20.037]         else {
[17:45:20.037]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.037]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.037]         }
[17:45:20.037]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.037]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.037]             base::sink(type = "output", split = FALSE)
[17:45:20.037]             base::close(...future.stdout)
[17:45:20.037]         }, add = TRUE)
[17:45:20.037]     }
[17:45:20.037]     ...future.frame <- base::sys.nframe()
[17:45:20.037]     ...future.conditions <- base::list()
[17:45:20.037]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.037]     if (FALSE) {
[17:45:20.037]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.037]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.037]     }
[17:45:20.037]     ...future.result <- base::tryCatch({
[17:45:20.037]         base::withCallingHandlers({
[17:45:20.037]             ...future.value <- base::withVisible(base::local({
[17:45:20.037]                 withCallingHandlers({
[17:45:20.037]                   {
[17:45:20.037]                     do.call(function(...) {
[17:45:20.037]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.037]                       if (!identical(...future.globals.maxSize.org, 
[17:45:20.037]                         ...future.globals.maxSize)) {
[17:45:20.037]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.037]                         on.exit(options(oopts), add = TRUE)
[17:45:20.037]                       }
[17:45:20.037]                       {
[17:45:20.037]                         lapply(seq_along(...future.elements_ii), 
[17:45:20.037]                           FUN = function(jj) {
[17:45:20.037]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.037]                             ...future.FUN(...future.X_jj, ...)
[17:45:20.037]                           })
[17:45:20.037]                       }
[17:45:20.037]                     }, args = future.call.arguments)
[17:45:20.037]                   }
[17:45:20.037]                 }, immediateCondition = function(cond) {
[17:45:20.037]                   save_rds <- function (object, pathname, ...) 
[17:45:20.037]                   {
[17:45:20.037]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:20.037]                     if (file_test("-f", pathname_tmp)) {
[17:45:20.037]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.037]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:20.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.037]                         fi_tmp[["mtime"]])
[17:45:20.037]                     }
[17:45:20.037]                     tryCatch({
[17:45:20.037]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:20.037]                     }, error = function(ex) {
[17:45:20.037]                       msg <- conditionMessage(ex)
[17:45:20.037]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.037]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:20.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.037]                         fi_tmp[["mtime"]], msg)
[17:45:20.037]                       ex$message <- msg
[17:45:20.037]                       stop(ex)
[17:45:20.037]                     })
[17:45:20.037]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:20.037]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:20.037]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:20.037]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.037]                       fi <- file.info(pathname)
[17:45:20.037]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:20.037]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.037]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:20.037]                         fi[["size"]], fi[["mtime"]])
[17:45:20.037]                       stop(msg)
[17:45:20.037]                     }
[17:45:20.037]                     invisible(pathname)
[17:45:20.037]                   }
[17:45:20.037]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:20.037]                     rootPath = tempdir()) 
[17:45:20.037]                   {
[17:45:20.037]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:20.037]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:20.037]                       tmpdir = path, fileext = ".rds")
[17:45:20.037]                     save_rds(obj, file)
[17:45:20.037]                   }
[17:45:20.037]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:20.037]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.037]                   {
[17:45:20.037]                     inherits <- base::inherits
[17:45:20.037]                     invokeRestart <- base::invokeRestart
[17:45:20.037]                     is.null <- base::is.null
[17:45:20.037]                     muffled <- FALSE
[17:45:20.037]                     if (inherits(cond, "message")) {
[17:45:20.037]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.037]                       if (muffled) 
[17:45:20.037]                         invokeRestart("muffleMessage")
[17:45:20.037]                     }
[17:45:20.037]                     else if (inherits(cond, "warning")) {
[17:45:20.037]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.037]                       if (muffled) 
[17:45:20.037]                         invokeRestart("muffleWarning")
[17:45:20.037]                     }
[17:45:20.037]                     else if (inherits(cond, "condition")) {
[17:45:20.037]                       if (!is.null(pattern)) {
[17:45:20.037]                         computeRestarts <- base::computeRestarts
[17:45:20.037]                         grepl <- base::grepl
[17:45:20.037]                         restarts <- computeRestarts(cond)
[17:45:20.037]                         for (restart in restarts) {
[17:45:20.037]                           name <- restart$name
[17:45:20.037]                           if (is.null(name)) 
[17:45:20.037]                             next
[17:45:20.037]                           if (!grepl(pattern, name)) 
[17:45:20.037]                             next
[17:45:20.037]                           invokeRestart(restart)
[17:45:20.037]                           muffled <- TRUE
[17:45:20.037]                           break
[17:45:20.037]                         }
[17:45:20.037]                       }
[17:45:20.037]                     }
[17:45:20.037]                     invisible(muffled)
[17:45:20.037]                   }
[17:45:20.037]                   muffleCondition(cond)
[17:45:20.037]                 })
[17:45:20.037]             }))
[17:45:20.037]             future::FutureResult(value = ...future.value$value, 
[17:45:20.037]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.037]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.037]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.037]                     ...future.globalenv.names))
[17:45:20.037]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.037]         }, condition = base::local({
[17:45:20.037]             c <- base::c
[17:45:20.037]             inherits <- base::inherits
[17:45:20.037]             invokeRestart <- base::invokeRestart
[17:45:20.037]             length <- base::length
[17:45:20.037]             list <- base::list
[17:45:20.037]             seq.int <- base::seq.int
[17:45:20.037]             signalCondition <- base::signalCondition
[17:45:20.037]             sys.calls <- base::sys.calls
[17:45:20.037]             `[[` <- base::`[[`
[17:45:20.037]             `+` <- base::`+`
[17:45:20.037]             `<<-` <- base::`<<-`
[17:45:20.037]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.037]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.037]                   3L)]
[17:45:20.037]             }
[17:45:20.037]             function(cond) {
[17:45:20.037]                 is_error <- inherits(cond, "error")
[17:45:20.037]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.037]                   NULL)
[17:45:20.037]                 if (is_error) {
[17:45:20.037]                   sessionInformation <- function() {
[17:45:20.037]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.037]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.037]                       search = base::search(), system = base::Sys.info())
[17:45:20.037]                   }
[17:45:20.037]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.037]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.037]                     cond$call), session = sessionInformation(), 
[17:45:20.037]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.037]                   signalCondition(cond)
[17:45:20.037]                 }
[17:45:20.037]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.037]                 "immediateCondition"))) {
[17:45:20.037]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.037]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.037]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.037]                   if (TRUE && !signal) {
[17:45:20.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.037]                     {
[17:45:20.037]                       inherits <- base::inherits
[17:45:20.037]                       invokeRestart <- base::invokeRestart
[17:45:20.037]                       is.null <- base::is.null
[17:45:20.037]                       muffled <- FALSE
[17:45:20.037]                       if (inherits(cond, "message")) {
[17:45:20.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.037]                         if (muffled) 
[17:45:20.037]                           invokeRestart("muffleMessage")
[17:45:20.037]                       }
[17:45:20.037]                       else if (inherits(cond, "warning")) {
[17:45:20.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.037]                         if (muffled) 
[17:45:20.037]                           invokeRestart("muffleWarning")
[17:45:20.037]                       }
[17:45:20.037]                       else if (inherits(cond, "condition")) {
[17:45:20.037]                         if (!is.null(pattern)) {
[17:45:20.037]                           computeRestarts <- base::computeRestarts
[17:45:20.037]                           grepl <- base::grepl
[17:45:20.037]                           restarts <- computeRestarts(cond)
[17:45:20.037]                           for (restart in restarts) {
[17:45:20.037]                             name <- restart$name
[17:45:20.037]                             if (is.null(name)) 
[17:45:20.037]                               next
[17:45:20.037]                             if (!grepl(pattern, name)) 
[17:45:20.037]                               next
[17:45:20.037]                             invokeRestart(restart)
[17:45:20.037]                             muffled <- TRUE
[17:45:20.037]                             break
[17:45:20.037]                           }
[17:45:20.037]                         }
[17:45:20.037]                       }
[17:45:20.037]                       invisible(muffled)
[17:45:20.037]                     }
[17:45:20.037]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.037]                   }
[17:45:20.037]                 }
[17:45:20.037]                 else {
[17:45:20.037]                   if (TRUE) {
[17:45:20.037]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.037]                     {
[17:45:20.037]                       inherits <- base::inherits
[17:45:20.037]                       invokeRestart <- base::invokeRestart
[17:45:20.037]                       is.null <- base::is.null
[17:45:20.037]                       muffled <- FALSE
[17:45:20.037]                       if (inherits(cond, "message")) {
[17:45:20.037]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.037]                         if (muffled) 
[17:45:20.037]                           invokeRestart("muffleMessage")
[17:45:20.037]                       }
[17:45:20.037]                       else if (inherits(cond, "warning")) {
[17:45:20.037]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.037]                         if (muffled) 
[17:45:20.037]                           invokeRestart("muffleWarning")
[17:45:20.037]                       }
[17:45:20.037]                       else if (inherits(cond, "condition")) {
[17:45:20.037]                         if (!is.null(pattern)) {
[17:45:20.037]                           computeRestarts <- base::computeRestarts
[17:45:20.037]                           grepl <- base::grepl
[17:45:20.037]                           restarts <- computeRestarts(cond)
[17:45:20.037]                           for (restart in restarts) {
[17:45:20.037]                             name <- restart$name
[17:45:20.037]                             if (is.null(name)) 
[17:45:20.037]                               next
[17:45:20.037]                             if (!grepl(pattern, name)) 
[17:45:20.037]                               next
[17:45:20.037]                             invokeRestart(restart)
[17:45:20.037]                             muffled <- TRUE
[17:45:20.037]                             break
[17:45:20.037]                           }
[17:45:20.037]                         }
[17:45:20.037]                       }
[17:45:20.037]                       invisible(muffled)
[17:45:20.037]                     }
[17:45:20.037]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.037]                   }
[17:45:20.037]                 }
[17:45:20.037]             }
[17:45:20.037]         }))
[17:45:20.037]     }, error = function(ex) {
[17:45:20.037]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.037]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.037]                 ...future.rng), started = ...future.startTime, 
[17:45:20.037]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.037]             version = "1.8"), class = "FutureResult")
[17:45:20.037]     }, finally = {
[17:45:20.037]         if (!identical(...future.workdir, getwd())) 
[17:45:20.037]             setwd(...future.workdir)
[17:45:20.037]         {
[17:45:20.037]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.037]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.037]             }
[17:45:20.037]             base::options(...future.oldOptions)
[17:45:20.037]             if (.Platform$OS.type == "windows") {
[17:45:20.037]                 old_names <- names(...future.oldEnvVars)
[17:45:20.037]                 envs <- base::Sys.getenv()
[17:45:20.037]                 names <- names(envs)
[17:45:20.037]                 common <- intersect(names, old_names)
[17:45:20.037]                 added <- setdiff(names, old_names)
[17:45:20.037]                 removed <- setdiff(old_names, names)
[17:45:20.037]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.037]                   envs[common]]
[17:45:20.037]                 NAMES <- toupper(changed)
[17:45:20.037]                 args <- list()
[17:45:20.037]                 for (kk in seq_along(NAMES)) {
[17:45:20.037]                   name <- changed[[kk]]
[17:45:20.037]                   NAME <- NAMES[[kk]]
[17:45:20.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.037]                     next
[17:45:20.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.037]                 }
[17:45:20.037]                 NAMES <- toupper(added)
[17:45:20.037]                 for (kk in seq_along(NAMES)) {
[17:45:20.037]                   name <- added[[kk]]
[17:45:20.037]                   NAME <- NAMES[[kk]]
[17:45:20.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.037]                     next
[17:45:20.037]                   args[[name]] <- ""
[17:45:20.037]                 }
[17:45:20.037]                 NAMES <- toupper(removed)
[17:45:20.037]                 for (kk in seq_along(NAMES)) {
[17:45:20.037]                   name <- removed[[kk]]
[17:45:20.037]                   NAME <- NAMES[[kk]]
[17:45:20.037]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.037]                     next
[17:45:20.037]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.037]                 }
[17:45:20.037]                 if (length(args) > 0) 
[17:45:20.037]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.037]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.037]             }
[17:45:20.037]             else {
[17:45:20.037]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.037]             }
[17:45:20.037]             {
[17:45:20.037]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.037]                   0L) {
[17:45:20.037]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.037]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.037]                   base::options(opts)
[17:45:20.037]                 }
[17:45:20.037]                 {
[17:45:20.037]                   {
[17:45:20.037]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.037]                     NULL
[17:45:20.037]                   }
[17:45:20.037]                   options(future.plan = NULL)
[17:45:20.037]                   if (is.na(NA_character_)) 
[17:45:20.037]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.037]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.037]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.037]                     .init = FALSE)
[17:45:20.037]                 }
[17:45:20.037]             }
[17:45:20.037]         }
[17:45:20.037]     })
[17:45:20.037]     if (TRUE) {
[17:45:20.037]         base::sink(type = "output", split = FALSE)
[17:45:20.037]         if (TRUE) {
[17:45:20.037]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.037]         }
[17:45:20.037]         else {
[17:45:20.037]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.037]         }
[17:45:20.037]         base::close(...future.stdout)
[17:45:20.037]         ...future.stdout <- NULL
[17:45:20.037]     }
[17:45:20.037]     ...future.result$conditions <- ...future.conditions
[17:45:20.037]     ...future.result$finished <- base::Sys.time()
[17:45:20.037]     ...future.result
[17:45:20.037] }
[17:45:20.040] assign_globals() ...
[17:45:20.040] List of 11
[17:45:20.040]  $ ...future.FUN            :function (x, ...)  
[17:45:20.040]  $ x_FUN                    :function (x)  
[17:45:20.040]  $ times                    : int 1
[17:45:20.040]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.040]  $ stop_if_not              :function (...)  
[17:45:20.040]  $ dim                      : NULL
[17:45:20.040]  $ valid_types              : chr "logical"
[17:45:20.040]  $ future.call.arguments    : list()
[17:45:20.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.040]  $ ...future.elements_ii    :List of 6
[17:45:20.040]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[17:45:20.040]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[17:45:20.040]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[17:45:20.040]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[17:45:20.040]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[17:45:20.040]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[17:45:20.040]  $ ...future.seeds_ii       : NULL
[17:45:20.040]  $ ...future.globals.maxSize: NULL
[17:45:20.040]  - attr(*, "where")=List of 11
[17:45:20.040]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:20.040]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:20.040]  - attr(*, "resolved")= logi FALSE
[17:45:20.040]  - attr(*, "total_size")= num 94200
[17:45:20.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.040]  - attr(*, "already-done")= logi TRUE
[17:45:20.049] - copied ‘...future.FUN’ to environment
[17:45:20.049] - copied ‘x_FUN’ to environment
[17:45:20.049] - copied ‘times’ to environment
[17:45:20.049] - copied ‘stopf’ to environment
[17:45:20.049] - copied ‘stop_if_not’ to environment
[17:45:20.049] - copied ‘dim’ to environment
[17:45:20.050] - copied ‘valid_types’ to environment
[17:45:20.050] - copied ‘future.call.arguments’ to environment
[17:45:20.050] - copied ‘...future.elements_ii’ to environment
[17:45:20.050] - copied ‘...future.seeds_ii’ to environment
[17:45:20.050] - copied ‘...future.globals.maxSize’ to environment
[17:45:20.050] assign_globals() ... done
[17:45:20.050] requestCore(): workers = 2
[17:45:20.052] MulticoreFuture started
[17:45:20.053] - Launch lazy future ... done
[17:45:20.053] run() for ‘MulticoreFuture’ ... done
[17:45:20.053] Created future:
[17:45:20.054] plan(): Setting new future strategy stack:
[17:45:20.054] List of future strategies:
[17:45:20.054] 1. sequential:
[17:45:20.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.054]    - tweaked: FALSE
[17:45:20.054]    - call: NULL
[17:45:20.055] plan(): nbrOfWorkers() = 1
[17:45:20.057] plan(): Setting new future strategy stack:
[17:45:20.057] List of future strategies:
[17:45:20.057] 1. multicore:
[17:45:20.057]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:20.057]    - tweaked: FALSE
[17:45:20.057]    - call: plan(strategy)
[17:45:20.053] MulticoreFuture:
[17:45:20.053] Label: ‘future_vapply-1’
[17:45:20.053] Expression:
[17:45:20.053] {
[17:45:20.053]     do.call(function(...) {
[17:45:20.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.053]             on.exit(options(oopts), add = TRUE)
[17:45:20.053]         }
[17:45:20.053]         {
[17:45:20.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.053]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.053]             })
[17:45:20.053]         }
[17:45:20.053]     }, args = future.call.arguments)
[17:45:20.053] }
[17:45:20.053] Lazy evaluation: FALSE
[17:45:20.053] Asynchronous evaluation: TRUE
[17:45:20.053] Local evaluation: TRUE
[17:45:20.053] Environment: R_GlobalEnv
[17:45:20.053] Capture standard output: TRUE
[17:45:20.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:20.053] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:20.053] Packages: 1 packages (‘future.apply’)
[17:45:20.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:20.053] Resolved: FALSE
[17:45:20.053] Value: <not collected>
[17:45:20.053] Conditions captured: <none>
[17:45:20.053] Early signaling: FALSE
[17:45:20.053] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:20.053] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.067] Chunk #1 of 2 ... DONE
[17:45:20.067] Chunk #2 of 2 ...
[17:45:20.067]  - Finding globals in 'X' for chunk #2 ...
[17:45:20.070] plan(): nbrOfWorkers() = 2
[17:45:20.070] getGlobalsAndPackages() ...
[17:45:20.070] Searching for globals...
[17:45:20.071] 
[17:45:20.071] Searching for globals ... DONE
[17:45:20.072] - globals: [0] <none>
[17:45:20.072] getGlobalsAndPackages() ... DONE
[17:45:20.072]    + additional globals found: [n=0] 
[17:45:20.072]    + additional namespaces needed: [n=0] 
[17:45:20.073]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:20.073]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:20.073]  - seeds: <none>
[17:45:20.073]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.074] getGlobalsAndPackages() ...
[17:45:20.074] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.074] Resolving globals: FALSE
[17:45:20.074] Tweak future expression to call with '...' arguments ...
[17:45:20.075] {
[17:45:20.075]     do.call(function(...) {
[17:45:20.075]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.075]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.075]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.075]             on.exit(options(oopts), add = TRUE)
[17:45:20.075]         }
[17:45:20.075]         {
[17:45:20.075]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.075]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.075]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.075]             })
[17:45:20.075]         }
[17:45:20.075]     }, args = future.call.arguments)
[17:45:20.075] }
[17:45:20.075] Tweak future expression to call with '...' arguments ... DONE
[17:45:20.076] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.077] - packages: [1] ‘future.apply’
[17:45:20.077] getGlobalsAndPackages() ... DONE
[17:45:20.078] run() for ‘Future’ ...
[17:45:20.078] - state: ‘created’
[17:45:20.078] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:20.084] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.084] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:20.085]   - Field: ‘label’
[17:45:20.085]   - Field: ‘local’
[17:45:20.085]   - Field: ‘owner’
[17:45:20.085]   - Field: ‘envir’
[17:45:20.085]   - Field: ‘workers’
[17:45:20.086]   - Field: ‘packages’
[17:45:20.086]   - Field: ‘gc’
[17:45:20.086]   - Field: ‘job’
[17:45:20.086]   - Field: ‘conditions’
[17:45:20.086]   - Field: ‘expr’
[17:45:20.086]   - Field: ‘uuid’
[17:45:20.087]   - Field: ‘seed’
[17:45:20.087]   - Field: ‘version’
[17:45:20.087]   - Field: ‘result’
[17:45:20.087]   - Field: ‘asynchronous’
[17:45:20.087]   - Field: ‘calls’
[17:45:20.088]   - Field: ‘globals’
[17:45:20.088]   - Field: ‘stdout’
[17:45:20.088]   - Field: ‘earlySignal’
[17:45:20.088]   - Field: ‘lazy’
[17:45:20.088]   - Field: ‘state’
[17:45:20.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:20.088] - Launch lazy future ...
[17:45:20.089] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:20.089] Packages needed by future strategies (n = 0): <none>
[17:45:20.090] {
[17:45:20.090]     {
[17:45:20.090]         {
[17:45:20.090]             ...future.startTime <- base::Sys.time()
[17:45:20.090]             {
[17:45:20.090]                 {
[17:45:20.090]                   {
[17:45:20.090]                     {
[17:45:20.090]                       {
[17:45:20.090]                         base::local({
[17:45:20.090]                           has_future <- base::requireNamespace("future", 
[17:45:20.090]                             quietly = TRUE)
[17:45:20.090]                           if (has_future) {
[17:45:20.090]                             ns <- base::getNamespace("future")
[17:45:20.090]                             version <- ns[[".package"]][["version"]]
[17:45:20.090]                             if (is.null(version)) 
[17:45:20.090]                               version <- utils::packageVersion("future")
[17:45:20.090]                           }
[17:45:20.090]                           else {
[17:45:20.090]                             version <- NULL
[17:45:20.090]                           }
[17:45:20.090]                           if (!has_future || version < "1.8.0") {
[17:45:20.090]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.090]                               "", base::R.version$version.string), 
[17:45:20.090]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:20.090]                                 base::R.version$platform, 8 * 
[17:45:20.090]                                   base::.Machine$sizeof.pointer), 
[17:45:20.090]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.090]                                 "release", "version")], collapse = " "), 
[17:45:20.090]                               hostname = base::Sys.info()[["nodename"]])
[17:45:20.090]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.090]                               info)
[17:45:20.090]                             info <- base::paste(info, collapse = "; ")
[17:45:20.090]                             if (!has_future) {
[17:45:20.090]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.090]                                 info)
[17:45:20.090]                             }
[17:45:20.090]                             else {
[17:45:20.090]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.090]                                 info, version)
[17:45:20.090]                             }
[17:45:20.090]                             base::stop(msg)
[17:45:20.090]                           }
[17:45:20.090]                         })
[17:45:20.090]                       }
[17:45:20.090]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.090]                       base::options(mc.cores = 1L)
[17:45:20.090]                     }
[17:45:20.090]                     base::local({
[17:45:20.090]                       for (pkg in "future.apply") {
[17:45:20.090]                         base::loadNamespace(pkg)
[17:45:20.090]                         base::library(pkg, character.only = TRUE)
[17:45:20.090]                       }
[17:45:20.090]                     })
[17:45:20.090]                   }
[17:45:20.090]                   ...future.strategy.old <- future::plan("list")
[17:45:20.090]                   options(future.plan = NULL)
[17:45:20.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.090]                 }
[17:45:20.090]                 ...future.workdir <- getwd()
[17:45:20.090]             }
[17:45:20.090]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.090]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.090]         }
[17:45:20.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.090]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:20.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.090]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.090]             base::names(...future.oldOptions))
[17:45:20.090]     }
[17:45:20.090]     if (FALSE) {
[17:45:20.090]     }
[17:45:20.090]     else {
[17:45:20.090]         if (TRUE) {
[17:45:20.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.090]                 open = "w")
[17:45:20.090]         }
[17:45:20.090]         else {
[17:45:20.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.090]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.090]         }
[17:45:20.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.090]             base::sink(type = "output", split = FALSE)
[17:45:20.090]             base::close(...future.stdout)
[17:45:20.090]         }, add = TRUE)
[17:45:20.090]     }
[17:45:20.090]     ...future.frame <- base::sys.nframe()
[17:45:20.090]     ...future.conditions <- base::list()
[17:45:20.090]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.090]     if (FALSE) {
[17:45:20.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.090]     }
[17:45:20.090]     ...future.result <- base::tryCatch({
[17:45:20.090]         base::withCallingHandlers({
[17:45:20.090]             ...future.value <- base::withVisible(base::local({
[17:45:20.090]                 withCallingHandlers({
[17:45:20.090]                   {
[17:45:20.090]                     do.call(function(...) {
[17:45:20.090]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.090]                       if (!identical(...future.globals.maxSize.org, 
[17:45:20.090]                         ...future.globals.maxSize)) {
[17:45:20.090]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.090]                         on.exit(options(oopts), add = TRUE)
[17:45:20.090]                       }
[17:45:20.090]                       {
[17:45:20.090]                         lapply(seq_along(...future.elements_ii), 
[17:45:20.090]                           FUN = function(jj) {
[17:45:20.090]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.090]                             ...future.FUN(...future.X_jj, ...)
[17:45:20.090]                           })
[17:45:20.090]                       }
[17:45:20.090]                     }, args = future.call.arguments)
[17:45:20.090]                   }
[17:45:20.090]                 }, immediateCondition = function(cond) {
[17:45:20.090]                   save_rds <- function (object, pathname, ...) 
[17:45:20.090]                   {
[17:45:20.090]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:20.090]                     if (file_test("-f", pathname_tmp)) {
[17:45:20.090]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.090]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:20.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.090]                         fi_tmp[["mtime"]])
[17:45:20.090]                     }
[17:45:20.090]                     tryCatch({
[17:45:20.090]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:20.090]                     }, error = function(ex) {
[17:45:20.090]                       msg <- conditionMessage(ex)
[17:45:20.090]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.090]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:20.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.090]                         fi_tmp[["mtime"]], msg)
[17:45:20.090]                       ex$message <- msg
[17:45:20.090]                       stop(ex)
[17:45:20.090]                     })
[17:45:20.090]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:20.090]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:20.090]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:20.090]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.090]                       fi <- file.info(pathname)
[17:45:20.090]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:20.090]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.090]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:20.090]                         fi[["size"]], fi[["mtime"]])
[17:45:20.090]                       stop(msg)
[17:45:20.090]                     }
[17:45:20.090]                     invisible(pathname)
[17:45:20.090]                   }
[17:45:20.090]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:20.090]                     rootPath = tempdir()) 
[17:45:20.090]                   {
[17:45:20.090]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:20.090]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:20.090]                       tmpdir = path, fileext = ".rds")
[17:45:20.090]                     save_rds(obj, file)
[17:45:20.090]                   }
[17:45:20.090]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:20.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.090]                   {
[17:45:20.090]                     inherits <- base::inherits
[17:45:20.090]                     invokeRestart <- base::invokeRestart
[17:45:20.090]                     is.null <- base::is.null
[17:45:20.090]                     muffled <- FALSE
[17:45:20.090]                     if (inherits(cond, "message")) {
[17:45:20.090]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.090]                       if (muffled) 
[17:45:20.090]                         invokeRestart("muffleMessage")
[17:45:20.090]                     }
[17:45:20.090]                     else if (inherits(cond, "warning")) {
[17:45:20.090]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.090]                       if (muffled) 
[17:45:20.090]                         invokeRestart("muffleWarning")
[17:45:20.090]                     }
[17:45:20.090]                     else if (inherits(cond, "condition")) {
[17:45:20.090]                       if (!is.null(pattern)) {
[17:45:20.090]                         computeRestarts <- base::computeRestarts
[17:45:20.090]                         grepl <- base::grepl
[17:45:20.090]                         restarts <- computeRestarts(cond)
[17:45:20.090]                         for (restart in restarts) {
[17:45:20.090]                           name <- restart$name
[17:45:20.090]                           if (is.null(name)) 
[17:45:20.090]                             next
[17:45:20.090]                           if (!grepl(pattern, name)) 
[17:45:20.090]                             next
[17:45:20.090]                           invokeRestart(restart)
[17:45:20.090]                           muffled <- TRUE
[17:45:20.090]                           break
[17:45:20.090]                         }
[17:45:20.090]                       }
[17:45:20.090]                     }
[17:45:20.090]                     invisible(muffled)
[17:45:20.090]                   }
[17:45:20.090]                   muffleCondition(cond)
[17:45:20.090]                 })
[17:45:20.090]             }))
[17:45:20.090]             future::FutureResult(value = ...future.value$value, 
[17:45:20.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.090]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.090]                     ...future.globalenv.names))
[17:45:20.090]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.090]         }, condition = base::local({
[17:45:20.090]             c <- base::c
[17:45:20.090]             inherits <- base::inherits
[17:45:20.090]             invokeRestart <- base::invokeRestart
[17:45:20.090]             length <- base::length
[17:45:20.090]             list <- base::list
[17:45:20.090]             seq.int <- base::seq.int
[17:45:20.090]             signalCondition <- base::signalCondition
[17:45:20.090]             sys.calls <- base::sys.calls
[17:45:20.090]             `[[` <- base::`[[`
[17:45:20.090]             `+` <- base::`+`
[17:45:20.090]             `<<-` <- base::`<<-`
[17:45:20.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.090]                   3L)]
[17:45:20.090]             }
[17:45:20.090]             function(cond) {
[17:45:20.090]                 is_error <- inherits(cond, "error")
[17:45:20.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.090]                   NULL)
[17:45:20.090]                 if (is_error) {
[17:45:20.090]                   sessionInformation <- function() {
[17:45:20.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.090]                       search = base::search(), system = base::Sys.info())
[17:45:20.090]                   }
[17:45:20.090]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.090]                     cond$call), session = sessionInformation(), 
[17:45:20.090]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.090]                   signalCondition(cond)
[17:45:20.090]                 }
[17:45:20.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.090]                 "immediateCondition"))) {
[17:45:20.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.090]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.090]                   if (TRUE && !signal) {
[17:45:20.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.090]                     {
[17:45:20.090]                       inherits <- base::inherits
[17:45:20.090]                       invokeRestart <- base::invokeRestart
[17:45:20.090]                       is.null <- base::is.null
[17:45:20.090]                       muffled <- FALSE
[17:45:20.090]                       if (inherits(cond, "message")) {
[17:45:20.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.090]                         if (muffled) 
[17:45:20.090]                           invokeRestart("muffleMessage")
[17:45:20.090]                       }
[17:45:20.090]                       else if (inherits(cond, "warning")) {
[17:45:20.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.090]                         if (muffled) 
[17:45:20.090]                           invokeRestart("muffleWarning")
[17:45:20.090]                       }
[17:45:20.090]                       else if (inherits(cond, "condition")) {
[17:45:20.090]                         if (!is.null(pattern)) {
[17:45:20.090]                           computeRestarts <- base::computeRestarts
[17:45:20.090]                           grepl <- base::grepl
[17:45:20.090]                           restarts <- computeRestarts(cond)
[17:45:20.090]                           for (restart in restarts) {
[17:45:20.090]                             name <- restart$name
[17:45:20.090]                             if (is.null(name)) 
[17:45:20.090]                               next
[17:45:20.090]                             if (!grepl(pattern, name)) 
[17:45:20.090]                               next
[17:45:20.090]                             invokeRestart(restart)
[17:45:20.090]                             muffled <- TRUE
[17:45:20.090]                             break
[17:45:20.090]                           }
[17:45:20.090]                         }
[17:45:20.090]                       }
[17:45:20.090]                       invisible(muffled)
[17:45:20.090]                     }
[17:45:20.090]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.090]                   }
[17:45:20.090]                 }
[17:45:20.090]                 else {
[17:45:20.090]                   if (TRUE) {
[17:45:20.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.090]                     {
[17:45:20.090]                       inherits <- base::inherits
[17:45:20.090]                       invokeRestart <- base::invokeRestart
[17:45:20.090]                       is.null <- base::is.null
[17:45:20.090]                       muffled <- FALSE
[17:45:20.090]                       if (inherits(cond, "message")) {
[17:45:20.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.090]                         if (muffled) 
[17:45:20.090]                           invokeRestart("muffleMessage")
[17:45:20.090]                       }
[17:45:20.090]                       else if (inherits(cond, "warning")) {
[17:45:20.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.090]                         if (muffled) 
[17:45:20.090]                           invokeRestart("muffleWarning")
[17:45:20.090]                       }
[17:45:20.090]                       else if (inherits(cond, "condition")) {
[17:45:20.090]                         if (!is.null(pattern)) {
[17:45:20.090]                           computeRestarts <- base::computeRestarts
[17:45:20.090]                           grepl <- base::grepl
[17:45:20.090]                           restarts <- computeRestarts(cond)
[17:45:20.090]                           for (restart in restarts) {
[17:45:20.090]                             name <- restart$name
[17:45:20.090]                             if (is.null(name)) 
[17:45:20.090]                               next
[17:45:20.090]                             if (!grepl(pattern, name)) 
[17:45:20.090]                               next
[17:45:20.090]                             invokeRestart(restart)
[17:45:20.090]                             muffled <- TRUE
[17:45:20.090]                             break
[17:45:20.090]                           }
[17:45:20.090]                         }
[17:45:20.090]                       }
[17:45:20.090]                       invisible(muffled)
[17:45:20.090]                     }
[17:45:20.090]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.090]                   }
[17:45:20.090]                 }
[17:45:20.090]             }
[17:45:20.090]         }))
[17:45:20.090]     }, error = function(ex) {
[17:45:20.090]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.090]                 ...future.rng), started = ...future.startTime, 
[17:45:20.090]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.090]             version = "1.8"), class = "FutureResult")
[17:45:20.090]     }, finally = {
[17:45:20.090]         if (!identical(...future.workdir, getwd())) 
[17:45:20.090]             setwd(...future.workdir)
[17:45:20.090]         {
[17:45:20.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.090]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.090]             }
[17:45:20.090]             base::options(...future.oldOptions)
[17:45:20.090]             if (.Platform$OS.type == "windows") {
[17:45:20.090]                 old_names <- names(...future.oldEnvVars)
[17:45:20.090]                 envs <- base::Sys.getenv()
[17:45:20.090]                 names <- names(envs)
[17:45:20.090]                 common <- intersect(names, old_names)
[17:45:20.090]                 added <- setdiff(names, old_names)
[17:45:20.090]                 removed <- setdiff(old_names, names)
[17:45:20.090]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.090]                   envs[common]]
[17:45:20.090]                 NAMES <- toupper(changed)
[17:45:20.090]                 args <- list()
[17:45:20.090]                 for (kk in seq_along(NAMES)) {
[17:45:20.090]                   name <- changed[[kk]]
[17:45:20.090]                   NAME <- NAMES[[kk]]
[17:45:20.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.090]                     next
[17:45:20.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.090]                 }
[17:45:20.090]                 NAMES <- toupper(added)
[17:45:20.090]                 for (kk in seq_along(NAMES)) {
[17:45:20.090]                   name <- added[[kk]]
[17:45:20.090]                   NAME <- NAMES[[kk]]
[17:45:20.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.090]                     next
[17:45:20.090]                   args[[name]] <- ""
[17:45:20.090]                 }
[17:45:20.090]                 NAMES <- toupper(removed)
[17:45:20.090]                 for (kk in seq_along(NAMES)) {
[17:45:20.090]                   name <- removed[[kk]]
[17:45:20.090]                   NAME <- NAMES[[kk]]
[17:45:20.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.090]                     next
[17:45:20.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.090]                 }
[17:45:20.090]                 if (length(args) > 0) 
[17:45:20.090]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.090]             }
[17:45:20.090]             else {
[17:45:20.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.090]             }
[17:45:20.090]             {
[17:45:20.090]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.090]                   0L) {
[17:45:20.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.090]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.090]                   base::options(opts)
[17:45:20.090]                 }
[17:45:20.090]                 {
[17:45:20.090]                   {
[17:45:20.090]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.090]                     NULL
[17:45:20.090]                   }
[17:45:20.090]                   options(future.plan = NULL)
[17:45:20.090]                   if (is.na(NA_character_)) 
[17:45:20.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.090]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.090]                     .init = FALSE)
[17:45:20.090]                 }
[17:45:20.090]             }
[17:45:20.090]         }
[17:45:20.090]     })
[17:45:20.090]     if (TRUE) {
[17:45:20.090]         base::sink(type = "output", split = FALSE)
[17:45:20.090]         if (TRUE) {
[17:45:20.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.090]         }
[17:45:20.090]         else {
[17:45:20.090]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.090]         }
[17:45:20.090]         base::close(...future.stdout)
[17:45:20.090]         ...future.stdout <- NULL
[17:45:20.090]     }
[17:45:20.090]     ...future.result$conditions <- ...future.conditions
[17:45:20.090]     ...future.result$finished <- base::Sys.time()
[17:45:20.090]     ...future.result
[17:45:20.090] }
[17:45:20.093] assign_globals() ...
[17:45:20.093] List of 11
[17:45:20.093]  $ ...future.FUN            :function (x, ...)  
[17:45:20.093]  $ x_FUN                    :function (x)  
[17:45:20.093]  $ times                    : int 1
[17:45:20.093]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.093]  $ stop_if_not              :function (...)  
[17:45:20.093]  $ dim                      : NULL
[17:45:20.093]  $ valid_types              : chr "logical"
[17:45:20.093]  $ future.call.arguments    : list()
[17:45:20.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.093]  $ ...future.elements_ii    :List of 5
[17:45:20.093]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[17:45:20.093]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[17:45:20.093]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[17:45:20.093]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[17:45:20.093]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[17:45:20.093]  $ ...future.seeds_ii       : NULL
[17:45:20.093]  $ ...future.globals.maxSize: NULL
[17:45:20.093]  - attr(*, "where")=List of 11
[17:45:20.093]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:20.093]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:20.093]  - attr(*, "resolved")= logi FALSE
[17:45:20.093]  - attr(*, "total_size")= num 94200
[17:45:20.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.093]  - attr(*, "already-done")= logi TRUE
[17:45:20.103] - copied ‘...future.FUN’ to environment
[17:45:20.103] - copied ‘x_FUN’ to environment
[17:45:20.103] - copied ‘times’ to environment
[17:45:20.103] - copied ‘stopf’ to environment
[17:45:20.103] - copied ‘stop_if_not’ to environment
[17:45:20.103] - copied ‘dim’ to environment
[17:45:20.104] - copied ‘valid_types’ to environment
[17:45:20.104] - copied ‘future.call.arguments’ to environment
[17:45:20.104] - copied ‘...future.elements_ii’ to environment
[17:45:20.104] - copied ‘...future.seeds_ii’ to environment
[17:45:20.104] - copied ‘...future.globals.maxSize’ to environment
[17:45:20.104] assign_globals() ... done
[17:45:20.104] requestCore(): workers = 2
[17:45:20.106] MulticoreFuture started
[17:45:20.107] - Launch lazy future ... done
[17:45:20.112] run() for ‘MulticoreFuture’ ... done
[17:45:20.112] Created future:
[17:45:20.112] plan(): Setting new future strategy stack:
[17:45:20.113] List of future strategies:
[17:45:20.113] 1. sequential:
[17:45:20.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.113]    - tweaked: FALSE
[17:45:20.113]    - call: NULL
[17:45:20.114] plan(): nbrOfWorkers() = 1
[17:45:20.117] plan(): Setting new future strategy stack:
[17:45:20.117] List of future strategies:
[17:45:20.117] 1. multicore:
[17:45:20.117]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:20.117]    - tweaked: FALSE
[17:45:20.117]    - call: plan(strategy)
[17:45:20.123] plan(): nbrOfWorkers() = 2
[17:45:20.112] MulticoreFuture:
[17:45:20.112] Label: ‘future_vapply-2’
[17:45:20.112] Expression:
[17:45:20.112] {
[17:45:20.112]     do.call(function(...) {
[17:45:20.112]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.112]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.112]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.112]             on.exit(options(oopts), add = TRUE)
[17:45:20.112]         }
[17:45:20.112]         {
[17:45:20.112]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.112]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.112]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.112]             })
[17:45:20.112]         }
[17:45:20.112]     }, args = future.call.arguments)
[17:45:20.112] }
[17:45:20.112] Lazy evaluation: FALSE
[17:45:20.112] Asynchronous evaluation: TRUE
[17:45:20.112] Local evaluation: TRUE
[17:45:20.112] Environment: R_GlobalEnv
[17:45:20.112] Capture standard output: TRUE
[17:45:20.112] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:20.112] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:20.112] Packages: 1 packages (‘future.apply’)
[17:45:20.112] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:20.112] Resolved: TRUE
[17:45:20.112] Value: <not collected>
[17:45:20.112] Conditions captured: <none>
[17:45:20.112] Early signaling: FALSE
[17:45:20.112] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:20.112] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.125] Chunk #2 of 2 ... DONE
[17:45:20.125] Launching 2 futures (chunks) ... DONE
[17:45:20.125] Resolving 2 futures (chunks) ...
[17:45:20.125] resolve() on list ...
[17:45:20.125]  recursive: 0
[17:45:20.126]  length: 2
[17:45:20.126] 
[17:45:20.126] Future #1
[17:45:20.126] result() for MulticoreFuture ...
[17:45:20.127] result() for MulticoreFuture ...
[17:45:20.128] result() for MulticoreFuture ... done
[17:45:20.128] result() for MulticoreFuture ... done
[17:45:20.128] result() for MulticoreFuture ...
[17:45:20.128] result() for MulticoreFuture ... done
[17:45:20.128] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:20.129] - nx: 2
[17:45:20.129] - relay: TRUE
[17:45:20.129] - stdout: TRUE
[17:45:20.129] - signal: TRUE
[17:45:20.129] - resignal: FALSE
[17:45:20.130] - force: TRUE
[17:45:20.130] - relayed: [n=2] FALSE, FALSE
[17:45:20.130] - queued futures: [n=2] FALSE, FALSE
[17:45:20.130]  - until=1
[17:45:20.131]  - relaying element #1
[17:45:20.131] result() for MulticoreFuture ...
[17:45:20.131] result() for MulticoreFuture ... done
[17:45:20.131] result() for MulticoreFuture ...
[17:45:20.131] result() for MulticoreFuture ... done
[17:45:20.132] result() for MulticoreFuture ...
[17:45:20.132] result() for MulticoreFuture ... done
[17:45:20.132] result() for MulticoreFuture ...
[17:45:20.132] result() for MulticoreFuture ... done
[17:45:20.132] - relayed: [n=2] TRUE, FALSE
[17:45:20.133] - queued futures: [n=2] TRUE, FALSE
[17:45:20.133] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:20.133]  length: 1 (resolved future 1)
[17:45:20.134] Future #2
[17:45:20.134] result() for MulticoreFuture ...
[17:45:20.135] result() for MulticoreFuture ...
[17:45:20.135] result() for MulticoreFuture ... done
[17:45:20.135] result() for MulticoreFuture ... done
[17:45:20.135] result() for MulticoreFuture ...
[17:45:20.136] result() for MulticoreFuture ... done
[17:45:20.136] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:20.136] - nx: 2
[17:45:20.136] - relay: TRUE
[17:45:20.136] - stdout: TRUE
[17:45:20.136] - signal: TRUE
[17:45:20.137] - resignal: FALSE
[17:45:20.137] - force: TRUE
[17:45:20.137] - relayed: [n=2] TRUE, FALSE
[17:45:20.137] - queued futures: [n=2] TRUE, FALSE
[17:45:20.137]  - until=2
[17:45:20.137]  - relaying element #2
[17:45:20.138] result() for MulticoreFuture ...
[17:45:20.138] result() for MulticoreFuture ... done
[17:45:20.138] result() for MulticoreFuture ...
[17:45:20.138] result() for MulticoreFuture ... done
[17:45:20.138] result() for MulticoreFuture ...
[17:45:20.138] result() for MulticoreFuture ... done
[17:45:20.138] result() for MulticoreFuture ...
[17:45:20.139] result() for MulticoreFuture ... done
[17:45:20.139] - relayed: [n=2] TRUE, TRUE
[17:45:20.139] - queued futures: [n=2] TRUE, TRUE
[17:45:20.139] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:20.139]  length: 0 (resolved future 2)
[17:45:20.139] Relaying remaining futures
[17:45:20.139] signalConditionsASAP(NULL, pos=0) ...
[17:45:20.139] - nx: 2
[17:45:20.139] - relay: TRUE
[17:45:20.140] - stdout: TRUE
[17:45:20.140] - signal: TRUE
[17:45:20.140] - resignal: FALSE
[17:45:20.140] - force: TRUE
[17:45:20.140] - relayed: [n=2] TRUE, TRUE
[17:45:20.140] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:20.140] - relayed: [n=2] TRUE, TRUE
[17:45:20.140] - queued futures: [n=2] TRUE, TRUE
[17:45:20.140] signalConditionsASAP(NULL, pos=0) ... done
[17:45:20.140] resolve() on list ... DONE
[17:45:20.141] result() for MulticoreFuture ...
[17:45:20.141] result() for MulticoreFuture ... done
[17:45:20.141] result() for MulticoreFuture ...
[17:45:20.141] result() for MulticoreFuture ... done
[17:45:20.141] result() for MulticoreFuture ...
[17:45:20.141] result() for MulticoreFuture ... done
[17:45:20.141] result() for MulticoreFuture ...
[17:45:20.141] result() for MulticoreFuture ... done
[17:45:20.141]  - Number of value chunks collected: 2
[17:45:20.142] Resolving 2 futures (chunks) ... DONE
[17:45:20.142] Reducing values from 2 chunks ...
[17:45:20.142]  - Number of values collected after concatenation: 11
[17:45:20.142]  - Number of values expected: 11
[17:45:20.142] Reducing values from 2 chunks ... DONE
[17:45:20.142] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:45:20.143] future_lapply() ...
[17:45:20.149] Number of chunks: 2
[17:45:20.149] getGlobalsAndPackagesXApply() ...
[17:45:20.149]  - future.globals: TRUE
[17:45:20.149] getGlobalsAndPackages() ...
[17:45:20.149] Searching for globals...
[17:45:20.153] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:20.153] Searching for globals ... DONE
[17:45:20.153] Resolving globals: FALSE
[17:45:20.156] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:45:20.157] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:20.157] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:20.157] - packages: [1] ‘future.apply’
[17:45:20.157] getGlobalsAndPackages() ... DONE
[17:45:20.157]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:20.157]  - needed namespaces: [n=1] ‘future.apply’
[17:45:20.158] Finding globals ... DONE
[17:45:20.158]  - use_args: TRUE
[17:45:20.158]  - Getting '...' globals ...
[17:45:20.158] resolve() on list ...
[17:45:20.158]  recursive: 0
[17:45:20.158]  length: 1
[17:45:20.159]  elements: ‘...’
[17:45:20.159]  length: 0 (resolved future 1)
[17:45:20.159] resolve() on list ... DONE
[17:45:20.159]    - '...' content: [n=0] 
[17:45:20.159] List of 1
[17:45:20.159]  $ ...: list()
[17:45:20.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.159]  - attr(*, "where")=List of 1
[17:45:20.159]   ..$ ...:<environment: 0x5561f3bbce40> 
[17:45:20.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.159]  - attr(*, "resolved")= logi TRUE
[17:45:20.159]  - attr(*, "total_size")= num NA
[17:45:20.162]  - Getting '...' globals ... DONE
[17:45:20.162] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:20.163] List of 8
[17:45:20.163]  $ ...future.FUN:function (x, ...)  
[17:45:20.163]  $ x_FUN        :function (x)  
[17:45:20.163]  $ times        : int 1
[17:45:20.163]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.163]  $ stop_if_not  :function (...)  
[17:45:20.163]  $ dim          : NULL
[17:45:20.163]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:20.163]  $ ...          : list()
[17:45:20.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.163]  - attr(*, "where")=List of 8
[17:45:20.163]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:20.163]   ..$ ...          :<environment: 0x5561f3bbce40> 
[17:45:20.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.163]  - attr(*, "resolved")= logi FALSE
[17:45:20.163]  - attr(*, "total_size")= num 94264
[17:45:20.168] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:20.168] getGlobalsAndPackagesXApply() ... DONE
[17:45:20.168] Number of futures (= number of chunks): 2
[17:45:20.169] Launching 2 futures (chunks) ...
[17:45:20.169] Chunk #1 of 2 ...
[17:45:20.169]  - Finding globals in 'X' for chunk #1 ...
[17:45:20.169] getGlobalsAndPackages() ...
[17:45:20.169] Searching for globals...
[17:45:20.169] 
[17:45:20.169] Searching for globals ... DONE
[17:45:20.169] - globals: [0] <none>
[17:45:20.169] getGlobalsAndPackages() ... DONE
[17:45:20.170]    + additional globals found: [n=0] 
[17:45:20.170]    + additional namespaces needed: [n=0] 
[17:45:20.170]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:20.170]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:20.170]  - seeds: <none>
[17:45:20.170]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.170] getGlobalsAndPackages() ...
[17:45:20.170] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.170] Resolving globals: FALSE
[17:45:20.170] Tweak future expression to call with '...' arguments ...
[17:45:20.171] {
[17:45:20.171]     do.call(function(...) {
[17:45:20.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.171]             on.exit(options(oopts), add = TRUE)
[17:45:20.171]         }
[17:45:20.171]         {
[17:45:20.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.171]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.171]             })
[17:45:20.171]         }
[17:45:20.171]     }, args = future.call.arguments)
[17:45:20.171] }
[17:45:20.171] Tweak future expression to call with '...' arguments ... DONE
[17:45:20.171] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.172] - packages: [1] ‘future.apply’
[17:45:20.172] getGlobalsAndPackages() ... DONE
[17:45:20.172] run() for ‘Future’ ...
[17:45:20.172] - state: ‘created’
[17:45:20.172] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:20.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:20.176]   - Field: ‘label’
[17:45:20.176]   - Field: ‘local’
[17:45:20.177]   - Field: ‘owner’
[17:45:20.177]   - Field: ‘envir’
[17:45:20.177]   - Field: ‘workers’
[17:45:20.177]   - Field: ‘packages’
[17:45:20.177]   - Field: ‘gc’
[17:45:20.177]   - Field: ‘job’
[17:45:20.177]   - Field: ‘conditions’
[17:45:20.177]   - Field: ‘expr’
[17:45:20.177]   - Field: ‘uuid’
[17:45:20.177]   - Field: ‘seed’
[17:45:20.177]   - Field: ‘version’
[17:45:20.178]   - Field: ‘result’
[17:45:20.178]   - Field: ‘asynchronous’
[17:45:20.178]   - Field: ‘calls’
[17:45:20.178]   - Field: ‘globals’
[17:45:20.178]   - Field: ‘stdout’
[17:45:20.178]   - Field: ‘earlySignal’
[17:45:20.178]   - Field: ‘lazy’
[17:45:20.178]   - Field: ‘state’
[17:45:20.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:20.181] - Launch lazy future ...
[17:45:20.181] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:20.181] Packages needed by future strategies (n = 0): <none>
[17:45:20.182] {
[17:45:20.182]     {
[17:45:20.182]         {
[17:45:20.182]             ...future.startTime <- base::Sys.time()
[17:45:20.182]             {
[17:45:20.182]                 {
[17:45:20.182]                   {
[17:45:20.182]                     {
[17:45:20.182]                       {
[17:45:20.182]                         base::local({
[17:45:20.182]                           has_future <- base::requireNamespace("future", 
[17:45:20.182]                             quietly = TRUE)
[17:45:20.182]                           if (has_future) {
[17:45:20.182]                             ns <- base::getNamespace("future")
[17:45:20.182]                             version <- ns[[".package"]][["version"]]
[17:45:20.182]                             if (is.null(version)) 
[17:45:20.182]                               version <- utils::packageVersion("future")
[17:45:20.182]                           }
[17:45:20.182]                           else {
[17:45:20.182]                             version <- NULL
[17:45:20.182]                           }
[17:45:20.182]                           if (!has_future || version < "1.8.0") {
[17:45:20.182]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.182]                               "", base::R.version$version.string), 
[17:45:20.182]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:20.182]                                 base::R.version$platform, 8 * 
[17:45:20.182]                                   base::.Machine$sizeof.pointer), 
[17:45:20.182]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.182]                                 "release", "version")], collapse = " "), 
[17:45:20.182]                               hostname = base::Sys.info()[["nodename"]])
[17:45:20.182]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.182]                               info)
[17:45:20.182]                             info <- base::paste(info, collapse = "; ")
[17:45:20.182]                             if (!has_future) {
[17:45:20.182]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.182]                                 info)
[17:45:20.182]                             }
[17:45:20.182]                             else {
[17:45:20.182]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.182]                                 info, version)
[17:45:20.182]                             }
[17:45:20.182]                             base::stop(msg)
[17:45:20.182]                           }
[17:45:20.182]                         })
[17:45:20.182]                       }
[17:45:20.182]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.182]                       base::options(mc.cores = 1L)
[17:45:20.182]                     }
[17:45:20.182]                     base::local({
[17:45:20.182]                       for (pkg in "future.apply") {
[17:45:20.182]                         base::loadNamespace(pkg)
[17:45:20.182]                         base::library(pkg, character.only = TRUE)
[17:45:20.182]                       }
[17:45:20.182]                     })
[17:45:20.182]                   }
[17:45:20.182]                   ...future.strategy.old <- future::plan("list")
[17:45:20.182]                   options(future.plan = NULL)
[17:45:20.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.182]                 }
[17:45:20.182]                 ...future.workdir <- getwd()
[17:45:20.182]             }
[17:45:20.182]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.182]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.182]         }
[17:45:20.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.182]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:20.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.182]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.182]             base::names(...future.oldOptions))
[17:45:20.182]     }
[17:45:20.182]     if (FALSE) {
[17:45:20.182]     }
[17:45:20.182]     else {
[17:45:20.182]         if (TRUE) {
[17:45:20.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.182]                 open = "w")
[17:45:20.182]         }
[17:45:20.182]         else {
[17:45:20.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.182]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.182]         }
[17:45:20.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.182]             base::sink(type = "output", split = FALSE)
[17:45:20.182]             base::close(...future.stdout)
[17:45:20.182]         }, add = TRUE)
[17:45:20.182]     }
[17:45:20.182]     ...future.frame <- base::sys.nframe()
[17:45:20.182]     ...future.conditions <- base::list()
[17:45:20.182]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.182]     if (FALSE) {
[17:45:20.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.182]     }
[17:45:20.182]     ...future.result <- base::tryCatch({
[17:45:20.182]         base::withCallingHandlers({
[17:45:20.182]             ...future.value <- base::withVisible(base::local({
[17:45:20.182]                 withCallingHandlers({
[17:45:20.182]                   {
[17:45:20.182]                     do.call(function(...) {
[17:45:20.182]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.182]                       if (!identical(...future.globals.maxSize.org, 
[17:45:20.182]                         ...future.globals.maxSize)) {
[17:45:20.182]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.182]                         on.exit(options(oopts), add = TRUE)
[17:45:20.182]                       }
[17:45:20.182]                       {
[17:45:20.182]                         lapply(seq_along(...future.elements_ii), 
[17:45:20.182]                           FUN = function(jj) {
[17:45:20.182]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.182]                             ...future.FUN(...future.X_jj, ...)
[17:45:20.182]                           })
[17:45:20.182]                       }
[17:45:20.182]                     }, args = future.call.arguments)
[17:45:20.182]                   }
[17:45:20.182]                 }, immediateCondition = function(cond) {
[17:45:20.182]                   save_rds <- function (object, pathname, ...) 
[17:45:20.182]                   {
[17:45:20.182]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:20.182]                     if (file_test("-f", pathname_tmp)) {
[17:45:20.182]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.182]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:20.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.182]                         fi_tmp[["mtime"]])
[17:45:20.182]                     }
[17:45:20.182]                     tryCatch({
[17:45:20.182]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:20.182]                     }, error = function(ex) {
[17:45:20.182]                       msg <- conditionMessage(ex)
[17:45:20.182]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.182]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:20.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.182]                         fi_tmp[["mtime"]], msg)
[17:45:20.182]                       ex$message <- msg
[17:45:20.182]                       stop(ex)
[17:45:20.182]                     })
[17:45:20.182]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:20.182]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:20.182]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:20.182]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.182]                       fi <- file.info(pathname)
[17:45:20.182]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:20.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.182]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:20.182]                         fi[["size"]], fi[["mtime"]])
[17:45:20.182]                       stop(msg)
[17:45:20.182]                     }
[17:45:20.182]                     invisible(pathname)
[17:45:20.182]                   }
[17:45:20.182]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:20.182]                     rootPath = tempdir()) 
[17:45:20.182]                   {
[17:45:20.182]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:20.182]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:20.182]                       tmpdir = path, fileext = ".rds")
[17:45:20.182]                     save_rds(obj, file)
[17:45:20.182]                   }
[17:45:20.182]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:20.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.182]                   {
[17:45:20.182]                     inherits <- base::inherits
[17:45:20.182]                     invokeRestart <- base::invokeRestart
[17:45:20.182]                     is.null <- base::is.null
[17:45:20.182]                     muffled <- FALSE
[17:45:20.182]                     if (inherits(cond, "message")) {
[17:45:20.182]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.182]                       if (muffled) 
[17:45:20.182]                         invokeRestart("muffleMessage")
[17:45:20.182]                     }
[17:45:20.182]                     else if (inherits(cond, "warning")) {
[17:45:20.182]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.182]                       if (muffled) 
[17:45:20.182]                         invokeRestart("muffleWarning")
[17:45:20.182]                     }
[17:45:20.182]                     else if (inherits(cond, "condition")) {
[17:45:20.182]                       if (!is.null(pattern)) {
[17:45:20.182]                         computeRestarts <- base::computeRestarts
[17:45:20.182]                         grepl <- base::grepl
[17:45:20.182]                         restarts <- computeRestarts(cond)
[17:45:20.182]                         for (restart in restarts) {
[17:45:20.182]                           name <- restart$name
[17:45:20.182]                           if (is.null(name)) 
[17:45:20.182]                             next
[17:45:20.182]                           if (!grepl(pattern, name)) 
[17:45:20.182]                             next
[17:45:20.182]                           invokeRestart(restart)
[17:45:20.182]                           muffled <- TRUE
[17:45:20.182]                           break
[17:45:20.182]                         }
[17:45:20.182]                       }
[17:45:20.182]                     }
[17:45:20.182]                     invisible(muffled)
[17:45:20.182]                   }
[17:45:20.182]                   muffleCondition(cond)
[17:45:20.182]                 })
[17:45:20.182]             }))
[17:45:20.182]             future::FutureResult(value = ...future.value$value, 
[17:45:20.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.182]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.182]                     ...future.globalenv.names))
[17:45:20.182]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.182]         }, condition = base::local({
[17:45:20.182]             c <- base::c
[17:45:20.182]             inherits <- base::inherits
[17:45:20.182]             invokeRestart <- base::invokeRestart
[17:45:20.182]             length <- base::length
[17:45:20.182]             list <- base::list
[17:45:20.182]             seq.int <- base::seq.int
[17:45:20.182]             signalCondition <- base::signalCondition
[17:45:20.182]             sys.calls <- base::sys.calls
[17:45:20.182]             `[[` <- base::`[[`
[17:45:20.182]             `+` <- base::`+`
[17:45:20.182]             `<<-` <- base::`<<-`
[17:45:20.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.182]                   3L)]
[17:45:20.182]             }
[17:45:20.182]             function(cond) {
[17:45:20.182]                 is_error <- inherits(cond, "error")
[17:45:20.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.182]                   NULL)
[17:45:20.182]                 if (is_error) {
[17:45:20.182]                   sessionInformation <- function() {
[17:45:20.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.182]                       search = base::search(), system = base::Sys.info())
[17:45:20.182]                   }
[17:45:20.182]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.182]                     cond$call), session = sessionInformation(), 
[17:45:20.182]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.182]                   signalCondition(cond)
[17:45:20.182]                 }
[17:45:20.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.182]                 "immediateCondition"))) {
[17:45:20.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.182]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.182]                   if (TRUE && !signal) {
[17:45:20.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.182]                     {
[17:45:20.182]                       inherits <- base::inherits
[17:45:20.182]                       invokeRestart <- base::invokeRestart
[17:45:20.182]                       is.null <- base::is.null
[17:45:20.182]                       muffled <- FALSE
[17:45:20.182]                       if (inherits(cond, "message")) {
[17:45:20.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.182]                         if (muffled) 
[17:45:20.182]                           invokeRestart("muffleMessage")
[17:45:20.182]                       }
[17:45:20.182]                       else if (inherits(cond, "warning")) {
[17:45:20.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.182]                         if (muffled) 
[17:45:20.182]                           invokeRestart("muffleWarning")
[17:45:20.182]                       }
[17:45:20.182]                       else if (inherits(cond, "condition")) {
[17:45:20.182]                         if (!is.null(pattern)) {
[17:45:20.182]                           computeRestarts <- base::computeRestarts
[17:45:20.182]                           grepl <- base::grepl
[17:45:20.182]                           restarts <- computeRestarts(cond)
[17:45:20.182]                           for (restart in restarts) {
[17:45:20.182]                             name <- restart$name
[17:45:20.182]                             if (is.null(name)) 
[17:45:20.182]                               next
[17:45:20.182]                             if (!grepl(pattern, name)) 
[17:45:20.182]                               next
[17:45:20.182]                             invokeRestart(restart)
[17:45:20.182]                             muffled <- TRUE
[17:45:20.182]                             break
[17:45:20.182]                           }
[17:45:20.182]                         }
[17:45:20.182]                       }
[17:45:20.182]                       invisible(muffled)
[17:45:20.182]                     }
[17:45:20.182]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.182]                   }
[17:45:20.182]                 }
[17:45:20.182]                 else {
[17:45:20.182]                   if (TRUE) {
[17:45:20.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.182]                     {
[17:45:20.182]                       inherits <- base::inherits
[17:45:20.182]                       invokeRestart <- base::invokeRestart
[17:45:20.182]                       is.null <- base::is.null
[17:45:20.182]                       muffled <- FALSE
[17:45:20.182]                       if (inherits(cond, "message")) {
[17:45:20.182]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.182]                         if (muffled) 
[17:45:20.182]                           invokeRestart("muffleMessage")
[17:45:20.182]                       }
[17:45:20.182]                       else if (inherits(cond, "warning")) {
[17:45:20.182]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.182]                         if (muffled) 
[17:45:20.182]                           invokeRestart("muffleWarning")
[17:45:20.182]                       }
[17:45:20.182]                       else if (inherits(cond, "condition")) {
[17:45:20.182]                         if (!is.null(pattern)) {
[17:45:20.182]                           computeRestarts <- base::computeRestarts
[17:45:20.182]                           grepl <- base::grepl
[17:45:20.182]                           restarts <- computeRestarts(cond)
[17:45:20.182]                           for (restart in restarts) {
[17:45:20.182]                             name <- restart$name
[17:45:20.182]                             if (is.null(name)) 
[17:45:20.182]                               next
[17:45:20.182]                             if (!grepl(pattern, name)) 
[17:45:20.182]                               next
[17:45:20.182]                             invokeRestart(restart)
[17:45:20.182]                             muffled <- TRUE
[17:45:20.182]                             break
[17:45:20.182]                           }
[17:45:20.182]                         }
[17:45:20.182]                       }
[17:45:20.182]                       invisible(muffled)
[17:45:20.182]                     }
[17:45:20.182]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.182]                   }
[17:45:20.182]                 }
[17:45:20.182]             }
[17:45:20.182]         }))
[17:45:20.182]     }, error = function(ex) {
[17:45:20.182]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.182]                 ...future.rng), started = ...future.startTime, 
[17:45:20.182]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.182]             version = "1.8"), class = "FutureResult")
[17:45:20.182]     }, finally = {
[17:45:20.182]         if (!identical(...future.workdir, getwd())) 
[17:45:20.182]             setwd(...future.workdir)
[17:45:20.182]         {
[17:45:20.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.182]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.182]             }
[17:45:20.182]             base::options(...future.oldOptions)
[17:45:20.182]             if (.Platform$OS.type == "windows") {
[17:45:20.182]                 old_names <- names(...future.oldEnvVars)
[17:45:20.182]                 envs <- base::Sys.getenv()
[17:45:20.182]                 names <- names(envs)
[17:45:20.182]                 common <- intersect(names, old_names)
[17:45:20.182]                 added <- setdiff(names, old_names)
[17:45:20.182]                 removed <- setdiff(old_names, names)
[17:45:20.182]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.182]                   envs[common]]
[17:45:20.182]                 NAMES <- toupper(changed)
[17:45:20.182]                 args <- list()
[17:45:20.182]                 for (kk in seq_along(NAMES)) {
[17:45:20.182]                   name <- changed[[kk]]
[17:45:20.182]                   NAME <- NAMES[[kk]]
[17:45:20.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.182]                     next
[17:45:20.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.182]                 }
[17:45:20.182]                 NAMES <- toupper(added)
[17:45:20.182]                 for (kk in seq_along(NAMES)) {
[17:45:20.182]                   name <- added[[kk]]
[17:45:20.182]                   NAME <- NAMES[[kk]]
[17:45:20.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.182]                     next
[17:45:20.182]                   args[[name]] <- ""
[17:45:20.182]                 }
[17:45:20.182]                 NAMES <- toupper(removed)
[17:45:20.182]                 for (kk in seq_along(NAMES)) {
[17:45:20.182]                   name <- removed[[kk]]
[17:45:20.182]                   NAME <- NAMES[[kk]]
[17:45:20.182]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.182]                     next
[17:45:20.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.182]                 }
[17:45:20.182]                 if (length(args) > 0) 
[17:45:20.182]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.182]             }
[17:45:20.182]             else {
[17:45:20.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.182]             }
[17:45:20.182]             {
[17:45:20.182]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.182]                   0L) {
[17:45:20.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.182]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.182]                   base::options(opts)
[17:45:20.182]                 }
[17:45:20.182]                 {
[17:45:20.182]                   {
[17:45:20.182]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.182]                     NULL
[17:45:20.182]                   }
[17:45:20.182]                   options(future.plan = NULL)
[17:45:20.182]                   if (is.na(NA_character_)) 
[17:45:20.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.182]                     .init = FALSE)
[17:45:20.182]                 }
[17:45:20.182]             }
[17:45:20.182]         }
[17:45:20.182]     })
[17:45:20.182]     if (TRUE) {
[17:45:20.182]         base::sink(type = "output", split = FALSE)
[17:45:20.182]         if (TRUE) {
[17:45:20.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.182]         }
[17:45:20.182]         else {
[17:45:20.182]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.182]         }
[17:45:20.182]         base::close(...future.stdout)
[17:45:20.182]         ...future.stdout <- NULL
[17:45:20.182]     }
[17:45:20.182]     ...future.result$conditions <- ...future.conditions
[17:45:20.182]     ...future.result$finished <- base::Sys.time()
[17:45:20.182]     ...future.result
[17:45:20.182] }
[17:45:20.184] assign_globals() ...
[17:45:20.184] List of 11
[17:45:20.184]  $ ...future.FUN            :function (x, ...)  
[17:45:20.184]  $ x_FUN                    :function (x)  
[17:45:20.184]  $ times                    : int 1
[17:45:20.184]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.184]  $ stop_if_not              :function (...)  
[17:45:20.184]  $ dim                      : NULL
[17:45:20.184]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:20.184]  $ future.call.arguments    : list()
[17:45:20.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.184]  $ ...future.elements_ii    :List of 1
[17:45:20.184]   ..$ a: num 1
[17:45:20.184]  $ ...future.seeds_ii       : NULL
[17:45:20.184]  $ ...future.globals.maxSize: NULL
[17:45:20.184]  - attr(*, "where")=List of 11
[17:45:20.184]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:20.184]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:20.184]  - attr(*, "resolved")= logi FALSE
[17:45:20.184]  - attr(*, "total_size")= num 94264
[17:45:20.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.184]  - attr(*, "already-done")= logi TRUE
[17:45:20.193] - copied ‘...future.FUN’ to environment
[17:45:20.193] - copied ‘x_FUN’ to environment
[17:45:20.193] - copied ‘times’ to environment
[17:45:20.193] - copied ‘stopf’ to environment
[17:45:20.193] - copied ‘stop_if_not’ to environment
[17:45:20.193] - copied ‘dim’ to environment
[17:45:20.193] - copied ‘valid_types’ to environment
[17:45:20.193] - copied ‘future.call.arguments’ to environment
[17:45:20.194] - copied ‘...future.elements_ii’ to environment
[17:45:20.194] - copied ‘...future.seeds_ii’ to environment
[17:45:20.194] - copied ‘...future.globals.maxSize’ to environment
[17:45:20.194] assign_globals() ... done
[17:45:20.194] requestCore(): workers = 2
[17:45:20.196] MulticoreFuture started
[17:45:20.197] - Launch lazy future ... done
[17:45:20.197] run() for ‘MulticoreFuture’ ... done
[17:45:20.197] Created future:
[17:45:20.198] plan(): Setting new future strategy stack:
[17:45:20.198] List of future strategies:
[17:45:20.198] 1. sequential:
[17:45:20.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.198]    - tweaked: FALSE
[17:45:20.198]    - call: NULL
[17:45:20.199] plan(): nbrOfWorkers() = 1
[17:45:20.201] plan(): Setting new future strategy stack:
[17:45:20.201] List of future strategies:
[17:45:20.201] 1. multicore:
[17:45:20.201]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:20.201]    - tweaked: FALSE
[17:45:20.201]    - call: plan(strategy)
[17:45:20.206] plan(): nbrOfWorkers() = 2
[17:45:20.197] MulticoreFuture:
[17:45:20.197] Label: ‘future_vapply-1’
[17:45:20.197] Expression:
[17:45:20.197] {
[17:45:20.197]     do.call(function(...) {
[17:45:20.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.197]             on.exit(options(oopts), add = TRUE)
[17:45:20.197]         }
[17:45:20.197]         {
[17:45:20.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.197]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.197]             })
[17:45:20.197]         }
[17:45:20.197]     }, args = future.call.arguments)
[17:45:20.197] }
[17:45:20.197] Lazy evaluation: FALSE
[17:45:20.197] Asynchronous evaluation: TRUE
[17:45:20.197] Local evaluation: TRUE
[17:45:20.197] Environment: R_GlobalEnv
[17:45:20.197] Capture standard output: TRUE
[17:45:20.197] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:20.197] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:20.197] Packages: 1 packages (‘future.apply’)
[17:45:20.197] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:20.197] Resolved: TRUE
[17:45:20.197] Value: <not collected>
[17:45:20.197] Conditions captured: <none>
[17:45:20.197] Early signaling: FALSE
[17:45:20.197] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:20.197] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.207] Chunk #1 of 2 ... DONE
[17:45:20.208] Chunk #2 of 2 ...
[17:45:20.208]  - Finding globals in 'X' for chunk #2 ...
[17:45:20.208] getGlobalsAndPackages() ...
[17:45:20.208] Searching for globals...
[17:45:20.209] 
[17:45:20.209] Searching for globals ... DONE
[17:45:20.209] - globals: [0] <none>
[17:45:20.209] getGlobalsAndPackages() ... DONE
[17:45:20.209]    + additional globals found: [n=0] 
[17:45:20.209]    + additional namespaces needed: [n=0] 
[17:45:20.209]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:20.209]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:20.210]  - seeds: <none>
[17:45:20.210]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.210] getGlobalsAndPackages() ...
[17:45:20.210] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.210] Resolving globals: FALSE
[17:45:20.210] Tweak future expression to call with '...' arguments ...
[17:45:20.211] {
[17:45:20.211]     do.call(function(...) {
[17:45:20.211]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.211]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.211]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.211]             on.exit(options(oopts), add = TRUE)
[17:45:20.211]         }
[17:45:20.211]         {
[17:45:20.211]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.211]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.211]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.211]             })
[17:45:20.211]         }
[17:45:20.211]     }, args = future.call.arguments)
[17:45:20.211] }
[17:45:20.211] Tweak future expression to call with '...' arguments ... DONE
[17:45:20.212] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.212] - packages: [1] ‘future.apply’
[17:45:20.212] getGlobalsAndPackages() ... DONE
[17:45:20.213] run() for ‘Future’ ...
[17:45:20.213] - state: ‘created’
[17:45:20.213] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:20.218] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:20.218]   - Field: ‘label’
[17:45:20.219]   - Field: ‘local’
[17:45:20.219]   - Field: ‘owner’
[17:45:20.219]   - Field: ‘envir’
[17:45:20.219]   - Field: ‘workers’
[17:45:20.219]   - Field: ‘packages’
[17:45:20.219]   - Field: ‘gc’
[17:45:20.219]   - Field: ‘job’
[17:45:20.220]   - Field: ‘conditions’
[17:45:20.220]   - Field: ‘expr’
[17:45:20.220]   - Field: ‘uuid’
[17:45:20.220]   - Field: ‘seed’
[17:45:20.220]   - Field: ‘version’
[17:45:20.220]   - Field: ‘result’
[17:45:20.220]   - Field: ‘asynchronous’
[17:45:20.221]   - Field: ‘calls’
[17:45:20.221]   - Field: ‘globals’
[17:45:20.221]   - Field: ‘stdout’
[17:45:20.221]   - Field: ‘earlySignal’
[17:45:20.225]   - Field: ‘lazy’
[17:45:20.225]   - Field: ‘state’
[17:45:20.225] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:20.226] - Launch lazy future ...
[17:45:20.227] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:20.227] Packages needed by future strategies (n = 0): <none>
[17:45:20.228] {
[17:45:20.228]     {
[17:45:20.228]         {
[17:45:20.228]             ...future.startTime <- base::Sys.time()
[17:45:20.228]             {
[17:45:20.228]                 {
[17:45:20.228]                   {
[17:45:20.228]                     {
[17:45:20.228]                       {
[17:45:20.228]                         base::local({
[17:45:20.228]                           has_future <- base::requireNamespace("future", 
[17:45:20.228]                             quietly = TRUE)
[17:45:20.228]                           if (has_future) {
[17:45:20.228]                             ns <- base::getNamespace("future")
[17:45:20.228]                             version <- ns[[".package"]][["version"]]
[17:45:20.228]                             if (is.null(version)) 
[17:45:20.228]                               version <- utils::packageVersion("future")
[17:45:20.228]                           }
[17:45:20.228]                           else {
[17:45:20.228]                             version <- NULL
[17:45:20.228]                           }
[17:45:20.228]                           if (!has_future || version < "1.8.0") {
[17:45:20.228]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.228]                               "", base::R.version$version.string), 
[17:45:20.228]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:20.228]                                 base::R.version$platform, 8 * 
[17:45:20.228]                                   base::.Machine$sizeof.pointer), 
[17:45:20.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.228]                                 "release", "version")], collapse = " "), 
[17:45:20.228]                               hostname = base::Sys.info()[["nodename"]])
[17:45:20.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.228]                               info)
[17:45:20.228]                             info <- base::paste(info, collapse = "; ")
[17:45:20.228]                             if (!has_future) {
[17:45:20.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.228]                                 info)
[17:45:20.228]                             }
[17:45:20.228]                             else {
[17:45:20.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.228]                                 info, version)
[17:45:20.228]                             }
[17:45:20.228]                             base::stop(msg)
[17:45:20.228]                           }
[17:45:20.228]                         })
[17:45:20.228]                       }
[17:45:20.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.228]                       base::options(mc.cores = 1L)
[17:45:20.228]                     }
[17:45:20.228]                     base::local({
[17:45:20.228]                       for (pkg in "future.apply") {
[17:45:20.228]                         base::loadNamespace(pkg)
[17:45:20.228]                         base::library(pkg, character.only = TRUE)
[17:45:20.228]                       }
[17:45:20.228]                     })
[17:45:20.228]                   }
[17:45:20.228]                   ...future.strategy.old <- future::plan("list")
[17:45:20.228]                   options(future.plan = NULL)
[17:45:20.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.228]                 }
[17:45:20.228]                 ...future.workdir <- getwd()
[17:45:20.228]             }
[17:45:20.228]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.228]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.228]         }
[17:45:20.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.228]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:20.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.228]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.228]             base::names(...future.oldOptions))
[17:45:20.228]     }
[17:45:20.228]     if (FALSE) {
[17:45:20.228]     }
[17:45:20.228]     else {
[17:45:20.228]         if (TRUE) {
[17:45:20.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.228]                 open = "w")
[17:45:20.228]         }
[17:45:20.228]         else {
[17:45:20.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.228]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.228]         }
[17:45:20.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.228]             base::sink(type = "output", split = FALSE)
[17:45:20.228]             base::close(...future.stdout)
[17:45:20.228]         }, add = TRUE)
[17:45:20.228]     }
[17:45:20.228]     ...future.frame <- base::sys.nframe()
[17:45:20.228]     ...future.conditions <- base::list()
[17:45:20.228]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.228]     if (FALSE) {
[17:45:20.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.228]     }
[17:45:20.228]     ...future.result <- base::tryCatch({
[17:45:20.228]         base::withCallingHandlers({
[17:45:20.228]             ...future.value <- base::withVisible(base::local({
[17:45:20.228]                 withCallingHandlers({
[17:45:20.228]                   {
[17:45:20.228]                     do.call(function(...) {
[17:45:20.228]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.228]                       if (!identical(...future.globals.maxSize.org, 
[17:45:20.228]                         ...future.globals.maxSize)) {
[17:45:20.228]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.228]                         on.exit(options(oopts), add = TRUE)
[17:45:20.228]                       }
[17:45:20.228]                       {
[17:45:20.228]                         lapply(seq_along(...future.elements_ii), 
[17:45:20.228]                           FUN = function(jj) {
[17:45:20.228]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.228]                             ...future.FUN(...future.X_jj, ...)
[17:45:20.228]                           })
[17:45:20.228]                       }
[17:45:20.228]                     }, args = future.call.arguments)
[17:45:20.228]                   }
[17:45:20.228]                 }, immediateCondition = function(cond) {
[17:45:20.228]                   save_rds <- function (object, pathname, ...) 
[17:45:20.228]                   {
[17:45:20.228]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:20.228]                     if (file_test("-f", pathname_tmp)) {
[17:45:20.228]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.228]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:20.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.228]                         fi_tmp[["mtime"]])
[17:45:20.228]                     }
[17:45:20.228]                     tryCatch({
[17:45:20.228]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:20.228]                     }, error = function(ex) {
[17:45:20.228]                       msg <- conditionMessage(ex)
[17:45:20.228]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.228]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:20.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.228]                         fi_tmp[["mtime"]], msg)
[17:45:20.228]                       ex$message <- msg
[17:45:20.228]                       stop(ex)
[17:45:20.228]                     })
[17:45:20.228]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:20.228]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:20.228]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:20.228]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.228]                       fi <- file.info(pathname)
[17:45:20.228]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:20.228]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.228]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:20.228]                         fi[["size"]], fi[["mtime"]])
[17:45:20.228]                       stop(msg)
[17:45:20.228]                     }
[17:45:20.228]                     invisible(pathname)
[17:45:20.228]                   }
[17:45:20.228]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:20.228]                     rootPath = tempdir()) 
[17:45:20.228]                   {
[17:45:20.228]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:20.228]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:20.228]                       tmpdir = path, fileext = ".rds")
[17:45:20.228]                     save_rds(obj, file)
[17:45:20.228]                   }
[17:45:20.228]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:20.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.228]                   {
[17:45:20.228]                     inherits <- base::inherits
[17:45:20.228]                     invokeRestart <- base::invokeRestart
[17:45:20.228]                     is.null <- base::is.null
[17:45:20.228]                     muffled <- FALSE
[17:45:20.228]                     if (inherits(cond, "message")) {
[17:45:20.228]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.228]                       if (muffled) 
[17:45:20.228]                         invokeRestart("muffleMessage")
[17:45:20.228]                     }
[17:45:20.228]                     else if (inherits(cond, "warning")) {
[17:45:20.228]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.228]                       if (muffled) 
[17:45:20.228]                         invokeRestart("muffleWarning")
[17:45:20.228]                     }
[17:45:20.228]                     else if (inherits(cond, "condition")) {
[17:45:20.228]                       if (!is.null(pattern)) {
[17:45:20.228]                         computeRestarts <- base::computeRestarts
[17:45:20.228]                         grepl <- base::grepl
[17:45:20.228]                         restarts <- computeRestarts(cond)
[17:45:20.228]                         for (restart in restarts) {
[17:45:20.228]                           name <- restart$name
[17:45:20.228]                           if (is.null(name)) 
[17:45:20.228]                             next
[17:45:20.228]                           if (!grepl(pattern, name)) 
[17:45:20.228]                             next
[17:45:20.228]                           invokeRestart(restart)
[17:45:20.228]                           muffled <- TRUE
[17:45:20.228]                           break
[17:45:20.228]                         }
[17:45:20.228]                       }
[17:45:20.228]                     }
[17:45:20.228]                     invisible(muffled)
[17:45:20.228]                   }
[17:45:20.228]                   muffleCondition(cond)
[17:45:20.228]                 })
[17:45:20.228]             }))
[17:45:20.228]             future::FutureResult(value = ...future.value$value, 
[17:45:20.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.228]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.228]                     ...future.globalenv.names))
[17:45:20.228]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.228]         }, condition = base::local({
[17:45:20.228]             c <- base::c
[17:45:20.228]             inherits <- base::inherits
[17:45:20.228]             invokeRestart <- base::invokeRestart
[17:45:20.228]             length <- base::length
[17:45:20.228]             list <- base::list
[17:45:20.228]             seq.int <- base::seq.int
[17:45:20.228]             signalCondition <- base::signalCondition
[17:45:20.228]             sys.calls <- base::sys.calls
[17:45:20.228]             `[[` <- base::`[[`
[17:45:20.228]             `+` <- base::`+`
[17:45:20.228]             `<<-` <- base::`<<-`
[17:45:20.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.228]                   3L)]
[17:45:20.228]             }
[17:45:20.228]             function(cond) {
[17:45:20.228]                 is_error <- inherits(cond, "error")
[17:45:20.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.228]                   NULL)
[17:45:20.228]                 if (is_error) {
[17:45:20.228]                   sessionInformation <- function() {
[17:45:20.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.228]                       search = base::search(), system = base::Sys.info())
[17:45:20.228]                   }
[17:45:20.228]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.228]                     cond$call), session = sessionInformation(), 
[17:45:20.228]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.228]                   signalCondition(cond)
[17:45:20.228]                 }
[17:45:20.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.228]                 "immediateCondition"))) {
[17:45:20.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.228]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.228]                   if (TRUE && !signal) {
[17:45:20.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.228]                     {
[17:45:20.228]                       inherits <- base::inherits
[17:45:20.228]                       invokeRestart <- base::invokeRestart
[17:45:20.228]                       is.null <- base::is.null
[17:45:20.228]                       muffled <- FALSE
[17:45:20.228]                       if (inherits(cond, "message")) {
[17:45:20.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.228]                         if (muffled) 
[17:45:20.228]                           invokeRestart("muffleMessage")
[17:45:20.228]                       }
[17:45:20.228]                       else if (inherits(cond, "warning")) {
[17:45:20.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.228]                         if (muffled) 
[17:45:20.228]                           invokeRestart("muffleWarning")
[17:45:20.228]                       }
[17:45:20.228]                       else if (inherits(cond, "condition")) {
[17:45:20.228]                         if (!is.null(pattern)) {
[17:45:20.228]                           computeRestarts <- base::computeRestarts
[17:45:20.228]                           grepl <- base::grepl
[17:45:20.228]                           restarts <- computeRestarts(cond)
[17:45:20.228]                           for (restart in restarts) {
[17:45:20.228]                             name <- restart$name
[17:45:20.228]                             if (is.null(name)) 
[17:45:20.228]                               next
[17:45:20.228]                             if (!grepl(pattern, name)) 
[17:45:20.228]                               next
[17:45:20.228]                             invokeRestart(restart)
[17:45:20.228]                             muffled <- TRUE
[17:45:20.228]                             break
[17:45:20.228]                           }
[17:45:20.228]                         }
[17:45:20.228]                       }
[17:45:20.228]                       invisible(muffled)
[17:45:20.228]                     }
[17:45:20.228]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.228]                   }
[17:45:20.228]                 }
[17:45:20.228]                 else {
[17:45:20.228]                   if (TRUE) {
[17:45:20.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.228]                     {
[17:45:20.228]                       inherits <- base::inherits
[17:45:20.228]                       invokeRestart <- base::invokeRestart
[17:45:20.228]                       is.null <- base::is.null
[17:45:20.228]                       muffled <- FALSE
[17:45:20.228]                       if (inherits(cond, "message")) {
[17:45:20.228]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.228]                         if (muffled) 
[17:45:20.228]                           invokeRestart("muffleMessage")
[17:45:20.228]                       }
[17:45:20.228]                       else if (inherits(cond, "warning")) {
[17:45:20.228]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.228]                         if (muffled) 
[17:45:20.228]                           invokeRestart("muffleWarning")
[17:45:20.228]                       }
[17:45:20.228]                       else if (inherits(cond, "condition")) {
[17:45:20.228]                         if (!is.null(pattern)) {
[17:45:20.228]                           computeRestarts <- base::computeRestarts
[17:45:20.228]                           grepl <- base::grepl
[17:45:20.228]                           restarts <- computeRestarts(cond)
[17:45:20.228]                           for (restart in restarts) {
[17:45:20.228]                             name <- restart$name
[17:45:20.228]                             if (is.null(name)) 
[17:45:20.228]                               next
[17:45:20.228]                             if (!grepl(pattern, name)) 
[17:45:20.228]                               next
[17:45:20.228]                             invokeRestart(restart)
[17:45:20.228]                             muffled <- TRUE
[17:45:20.228]                             break
[17:45:20.228]                           }
[17:45:20.228]                         }
[17:45:20.228]                       }
[17:45:20.228]                       invisible(muffled)
[17:45:20.228]                     }
[17:45:20.228]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.228]                   }
[17:45:20.228]                 }
[17:45:20.228]             }
[17:45:20.228]         }))
[17:45:20.228]     }, error = function(ex) {
[17:45:20.228]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.228]                 ...future.rng), started = ...future.startTime, 
[17:45:20.228]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.228]             version = "1.8"), class = "FutureResult")
[17:45:20.228]     }, finally = {
[17:45:20.228]         if (!identical(...future.workdir, getwd())) 
[17:45:20.228]             setwd(...future.workdir)
[17:45:20.228]         {
[17:45:20.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.228]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.228]             }
[17:45:20.228]             base::options(...future.oldOptions)
[17:45:20.228]             if (.Platform$OS.type == "windows") {
[17:45:20.228]                 old_names <- names(...future.oldEnvVars)
[17:45:20.228]                 envs <- base::Sys.getenv()
[17:45:20.228]                 names <- names(envs)
[17:45:20.228]                 common <- intersect(names, old_names)
[17:45:20.228]                 added <- setdiff(names, old_names)
[17:45:20.228]                 removed <- setdiff(old_names, names)
[17:45:20.228]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.228]                   envs[common]]
[17:45:20.228]                 NAMES <- toupper(changed)
[17:45:20.228]                 args <- list()
[17:45:20.228]                 for (kk in seq_along(NAMES)) {
[17:45:20.228]                   name <- changed[[kk]]
[17:45:20.228]                   NAME <- NAMES[[kk]]
[17:45:20.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.228]                     next
[17:45:20.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.228]                 }
[17:45:20.228]                 NAMES <- toupper(added)
[17:45:20.228]                 for (kk in seq_along(NAMES)) {
[17:45:20.228]                   name <- added[[kk]]
[17:45:20.228]                   NAME <- NAMES[[kk]]
[17:45:20.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.228]                     next
[17:45:20.228]                   args[[name]] <- ""
[17:45:20.228]                 }
[17:45:20.228]                 NAMES <- toupper(removed)
[17:45:20.228]                 for (kk in seq_along(NAMES)) {
[17:45:20.228]                   name <- removed[[kk]]
[17:45:20.228]                   NAME <- NAMES[[kk]]
[17:45:20.228]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.228]                     next
[17:45:20.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.228]                 }
[17:45:20.228]                 if (length(args) > 0) 
[17:45:20.228]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.228]             }
[17:45:20.228]             else {
[17:45:20.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.228]             }
[17:45:20.228]             {
[17:45:20.228]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.228]                   0L) {
[17:45:20.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.228]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.228]                   base::options(opts)
[17:45:20.228]                 }
[17:45:20.228]                 {
[17:45:20.228]                   {
[17:45:20.228]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.228]                     NULL
[17:45:20.228]                   }
[17:45:20.228]                   options(future.plan = NULL)
[17:45:20.228]                   if (is.na(NA_character_)) 
[17:45:20.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.228]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.228]                     .init = FALSE)
[17:45:20.228]                 }
[17:45:20.228]             }
[17:45:20.228]         }
[17:45:20.228]     })
[17:45:20.228]     if (TRUE) {
[17:45:20.228]         base::sink(type = "output", split = FALSE)
[17:45:20.228]         if (TRUE) {
[17:45:20.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.228]         }
[17:45:20.228]         else {
[17:45:20.228]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.228]         }
[17:45:20.228]         base::close(...future.stdout)
[17:45:20.228]         ...future.stdout <- NULL
[17:45:20.228]     }
[17:45:20.228]     ...future.result$conditions <- ...future.conditions
[17:45:20.228]     ...future.result$finished <- base::Sys.time()
[17:45:20.228]     ...future.result
[17:45:20.228] }
[17:45:20.231] assign_globals() ...
[17:45:20.232] List of 11
[17:45:20.232]  $ ...future.FUN            :function (x, ...)  
[17:45:20.232]  $ x_FUN                    :function (x)  
[17:45:20.232]  $ times                    : int 1
[17:45:20.232]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.232]  $ stop_if_not              :function (...)  
[17:45:20.232]  $ dim                      : NULL
[17:45:20.232]  $ valid_types              : chr [1:2] "logical" "integer"
[17:45:20.232]  $ future.call.arguments    : list()
[17:45:20.232]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.232]  $ ...future.elements_ii    :List of 2
[17:45:20.232]   ..$ b: num 2
[17:45:20.232]   ..$ c: num 3
[17:45:20.232]  $ ...future.seeds_ii       : NULL
[17:45:20.232]  $ ...future.globals.maxSize: NULL
[17:45:20.232]  - attr(*, "where")=List of 11
[17:45:20.232]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:20.232]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:20.232]  - attr(*, "resolved")= logi FALSE
[17:45:20.232]  - attr(*, "total_size")= num 94264
[17:45:20.232]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.232]  - attr(*, "already-done")= logi TRUE
[17:45:20.244] - copied ‘...future.FUN’ to environment
[17:45:20.245] - copied ‘x_FUN’ to environment
[17:45:20.245] - copied ‘times’ to environment
[17:45:20.245] - copied ‘stopf’ to environment
[17:45:20.245] - copied ‘stop_if_not’ to environment
[17:45:20.245] - copied ‘dim’ to environment
[17:45:20.245] - copied ‘valid_types’ to environment
[17:45:20.245] - copied ‘future.call.arguments’ to environment
[17:45:20.245] - copied ‘...future.elements_ii’ to environment
[17:45:20.245] - copied ‘...future.seeds_ii’ to environment
[17:45:20.246] - copied ‘...future.globals.maxSize’ to environment
[17:45:20.246] assign_globals() ... done
[17:45:20.246] requestCore(): workers = 2
[17:45:20.248] MulticoreFuture started
[17:45:20.249] - Launch lazy future ... done
[17:45:20.249] run() for ‘MulticoreFuture’ ... done
[17:45:20.249] Created future:
[17:45:20.250] plan(): Setting new future strategy stack:
[17:45:20.250] List of future strategies:
[17:45:20.250] 1. sequential:
[17:45:20.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.250]    - tweaked: FALSE
[17:45:20.250]    - call: NULL
[17:45:20.251] plan(): nbrOfWorkers() = 1
[17:45:20.253] plan(): Setting new future strategy stack:
[17:45:20.253] List of future strategies:
[17:45:20.253] 1. multicore:
[17:45:20.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:20.253]    - tweaked: FALSE
[17:45:20.253]    - call: plan(strategy)
[17:45:20.258] plan(): nbrOfWorkers() = 2
[17:45:20.249] MulticoreFuture:
[17:45:20.249] Label: ‘future_vapply-2’
[17:45:20.249] Expression:
[17:45:20.249] {
[17:45:20.249]     do.call(function(...) {
[17:45:20.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.249]             on.exit(options(oopts), add = TRUE)
[17:45:20.249]         }
[17:45:20.249]         {
[17:45:20.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.249]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.249]             })
[17:45:20.249]         }
[17:45:20.249]     }, args = future.call.arguments)
[17:45:20.249] }
[17:45:20.249] Lazy evaluation: FALSE
[17:45:20.249] Asynchronous evaluation: TRUE
[17:45:20.249] Local evaluation: TRUE
[17:45:20.249] Environment: R_GlobalEnv
[17:45:20.249] Capture standard output: TRUE
[17:45:20.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:20.249] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:20.249] Packages: 1 packages (‘future.apply’)
[17:45:20.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:20.249] Resolved: TRUE
[17:45:20.249] Value: <not collected>
[17:45:20.249] Conditions captured: <none>
[17:45:20.249] Early signaling: FALSE
[17:45:20.249] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:20.249] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.259] Chunk #2 of 2 ... DONE
[17:45:20.259] Launching 2 futures (chunks) ... DONE
[17:45:20.260] Resolving 2 futures (chunks) ...
[17:45:20.260] resolve() on list ...
[17:45:20.260]  recursive: 0
[17:45:20.260]  length: 2
[17:45:20.260] 
[17:45:20.260] Future #1
[17:45:20.261] result() for MulticoreFuture ...
[17:45:20.262] result() for MulticoreFuture ...
[17:45:20.262] result() for MulticoreFuture ... done
[17:45:20.262] result() for MulticoreFuture ... done
[17:45:20.262] result() for MulticoreFuture ...
[17:45:20.262] result() for MulticoreFuture ... done
[17:45:20.262] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:20.262] - nx: 2
[17:45:20.263] - relay: TRUE
[17:45:20.263] - stdout: TRUE
[17:45:20.263] - signal: TRUE
[17:45:20.263] - resignal: FALSE
[17:45:20.263] - force: TRUE
[17:45:20.263] - relayed: [n=2] FALSE, FALSE
[17:45:20.263] - queued futures: [n=2] FALSE, FALSE
[17:45:20.264]  - until=1
[17:45:20.264]  - relaying element #1
[17:45:20.264] result() for MulticoreFuture ...
[17:45:20.264] result() for MulticoreFuture ... done
[17:45:20.264] result() for MulticoreFuture ...
[17:45:20.264] result() for MulticoreFuture ... done
[17:45:20.265] result() for MulticoreFuture ...
[17:45:20.265] result() for MulticoreFuture ... done
[17:45:20.265] result() for MulticoreFuture ...
[17:45:20.265] result() for MulticoreFuture ... done
[17:45:20.265] - relayed: [n=2] TRUE, FALSE
[17:45:20.265] - queued futures: [n=2] TRUE, FALSE
[17:45:20.266] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:20.266]  length: 1 (resolved future 1)
[17:45:20.266] Future #2
[17:45:20.266] result() for MulticoreFuture ...
[17:45:20.267] result() for MulticoreFuture ...
[17:45:20.267] result() for MulticoreFuture ... done
[17:45:20.267] result() for MulticoreFuture ... done
[17:45:20.268] result() for MulticoreFuture ...
[17:45:20.268] result() for MulticoreFuture ... done
[17:45:20.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[17:45:20.268] - nx: 2
[17:45:20.268] - relay: TRUE
[17:45:20.268] - stdout: TRUE
[17:45:20.268] - signal: TRUE
[17:45:20.268] - resignal: FALSE
[17:45:20.269] - force: TRUE
[17:45:20.269] - relayed: [n=2] TRUE, FALSE
[17:45:20.269] - queued futures: [n=2] TRUE, FALSE
[17:45:20.269]  - until=2
[17:45:20.269]  - relaying element #2
[17:45:20.272] result() for MulticoreFuture ...
[17:45:20.272] result() for MulticoreFuture ... done
[17:45:20.272] result() for MulticoreFuture ...
[17:45:20.273] result() for MulticoreFuture ... done
[17:45:20.273] result() for MulticoreFuture ...
[17:45:20.273] result() for MulticoreFuture ... done
[17:45:20.273] result() for MulticoreFuture ...
[17:45:20.273] result() for MulticoreFuture ... done
[17:45:20.274] - relayed: [n=2] TRUE, TRUE
[17:45:20.274] - queued futures: [n=2] TRUE, TRUE
[17:45:20.274] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[17:45:20.274]  length: 0 (resolved future 2)
[17:45:20.274] Relaying remaining futures
[17:45:20.274] signalConditionsASAP(NULL, pos=0) ...
[17:45:20.275] - nx: 2
[17:45:20.275] - relay: TRUE
[17:45:20.275] - stdout: TRUE
[17:45:20.275] - signal: TRUE
[17:45:20.275] - resignal: FALSE
[17:45:20.275] - force: TRUE
[17:45:20.275] - relayed: [n=2] TRUE, TRUE
[17:45:20.276] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:20.276] - relayed: [n=2] TRUE, TRUE
[17:45:20.276] - queued futures: [n=2] TRUE, TRUE
[17:45:20.276] signalConditionsASAP(NULL, pos=0) ... done
[17:45:20.276] resolve() on list ... DONE
[17:45:20.276] result() for MulticoreFuture ...
[17:45:20.277] result() for MulticoreFuture ... done
[17:45:20.277] result() for MulticoreFuture ...
[17:45:20.277] result() for MulticoreFuture ... done
[17:45:20.277] result() for MulticoreFuture ...
[17:45:20.277] result() for MulticoreFuture ... done
[17:45:20.277] result() for MulticoreFuture ...
[17:45:20.277] result() for MulticoreFuture ... done
[17:45:20.278]  - Number of value chunks collected: 2
[17:45:20.278] Resolving 2 futures (chunks) ... DONE
[17:45:20.278] Reducing values from 2 chunks ...
[17:45:20.278]  - Number of values collected after concatenation: 3
[17:45:20.278]  - Number of values expected: 3
[17:45:20.278] Reducing values from 2 chunks ... DONE
[17:45:20.278] future_lapply() ... DONE
- exceptions ...
[17:45:20.279] future_lapply() ...
[17:45:20.286] Number of chunks: 2
[17:45:20.286] getGlobalsAndPackagesXApply() ...
[17:45:20.286]  - future.globals: TRUE
[17:45:20.286] getGlobalsAndPackages() ...
[17:45:20.287] Searching for globals...
[17:45:20.290] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:20.291] Searching for globals ... DONE
[17:45:20.291] Resolving globals: FALSE
[17:45:20.292] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:45:20.292] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:20.292] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:20.292] - packages: [1] ‘future.apply’
[17:45:20.292] getGlobalsAndPackages() ... DONE
[17:45:20.293]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:20.293]  - needed namespaces: [n=1] ‘future.apply’
[17:45:20.293] Finding globals ... DONE
[17:45:20.293]  - use_args: TRUE
[17:45:20.293]  - Getting '...' globals ...
[17:45:20.293] resolve() on list ...
[17:45:20.293]  recursive: 0
[17:45:20.293]  length: 1
[17:45:20.294]  elements: ‘...’
[17:45:20.294]  length: 0 (resolved future 1)
[17:45:20.294] resolve() on list ... DONE
[17:45:20.294]    - '...' content: [n=0] 
[17:45:20.294] List of 1
[17:45:20.294]  $ ...: list()
[17:45:20.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.294]  - attr(*, "where")=List of 1
[17:45:20.294]   ..$ ...:<environment: 0x5561f5527a20> 
[17:45:20.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.294]  - attr(*, "resolved")= logi TRUE
[17:45:20.294]  - attr(*, "total_size")= num NA
[17:45:20.297]  - Getting '...' globals ... DONE
[17:45:20.297] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:20.297] List of 8
[17:45:20.297]  $ ...future.FUN:function (x, ...)  
[17:45:20.297]  $ x_FUN        :function (x)  
[17:45:20.297]  $ times        : int 2
[17:45:20.297]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.297]  $ stop_if_not  :function (...)  
[17:45:20.297]  $ dim          : NULL
[17:45:20.297]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:20.297]  $ ...          : list()
[17:45:20.297]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.297]  - attr(*, "where")=List of 8
[17:45:20.297]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:20.297]   ..$ ...          :<environment: 0x5561f5527a20> 
[17:45:20.297]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.297]  - attr(*, "resolved")= logi FALSE
[17:45:20.297]  - attr(*, "total_size")= num 95128
[17:45:20.306] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:20.306] getGlobalsAndPackagesXApply() ... DONE
[17:45:20.306] Number of futures (= number of chunks): 2
[17:45:20.306] Launching 2 futures (chunks) ...
[17:45:20.306] Chunk #1 of 2 ...
[17:45:20.306]  - Finding globals in 'X' for chunk #1 ...
[17:45:20.307] getGlobalsAndPackages() ...
[17:45:20.307] Searching for globals...
[17:45:20.307] 
[17:45:20.307] Searching for globals ... DONE
[17:45:20.307] - globals: [0] <none>
[17:45:20.307] getGlobalsAndPackages() ... DONE
[17:45:20.307]    + additional globals found: [n=0] 
[17:45:20.308]    + additional namespaces needed: [n=0] 
[17:45:20.308]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:20.308]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:20.308]  - seeds: <none>
[17:45:20.308]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.308] getGlobalsAndPackages() ...
[17:45:20.308] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.308] Resolving globals: FALSE
[17:45:20.308] Tweak future expression to call with '...' arguments ...
[17:45:20.309] {
[17:45:20.309]     do.call(function(...) {
[17:45:20.309]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.309]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.309]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.309]             on.exit(options(oopts), add = TRUE)
[17:45:20.309]         }
[17:45:20.309]         {
[17:45:20.309]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.309]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.309]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.309]             })
[17:45:20.309]         }
[17:45:20.309]     }, args = future.call.arguments)
[17:45:20.309] }
[17:45:20.309] Tweak future expression to call with '...' arguments ... DONE
[17:45:20.309] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.309] - packages: [1] ‘future.apply’
[17:45:20.310] getGlobalsAndPackages() ... DONE
[17:45:20.310] run() for ‘Future’ ...
[17:45:20.310] - state: ‘created’
[17:45:20.310] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:20.314] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:20.315]   - Field: ‘label’
[17:45:20.315]   - Field: ‘local’
[17:45:20.315]   - Field: ‘owner’
[17:45:20.315]   - Field: ‘envir’
[17:45:20.315]   - Field: ‘workers’
[17:45:20.315]   - Field: ‘packages’
[17:45:20.315]   - Field: ‘gc’
[17:45:20.315]   - Field: ‘job’
[17:45:20.316]   - Field: ‘conditions’
[17:45:20.316]   - Field: ‘expr’
[17:45:20.316]   - Field: ‘uuid’
[17:45:20.316]   - Field: ‘seed’
[17:45:20.316]   - Field: ‘version’
[17:45:20.316]   - Field: ‘result’
[17:45:20.316]   - Field: ‘asynchronous’
[17:45:20.316]   - Field: ‘calls’
[17:45:20.316]   - Field: ‘globals’
[17:45:20.316]   - Field: ‘stdout’
[17:45:20.316]   - Field: ‘earlySignal’
[17:45:20.317]   - Field: ‘lazy’
[17:45:20.317]   - Field: ‘state’
[17:45:20.317] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:20.317] - Launch lazy future ...
[17:45:20.317] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:20.317] Packages needed by future strategies (n = 0): <none>
[17:45:20.318] {
[17:45:20.318]     {
[17:45:20.318]         {
[17:45:20.318]             ...future.startTime <- base::Sys.time()
[17:45:20.318]             {
[17:45:20.318]                 {
[17:45:20.318]                   {
[17:45:20.318]                     {
[17:45:20.318]                       {
[17:45:20.318]                         base::local({
[17:45:20.318]                           has_future <- base::requireNamespace("future", 
[17:45:20.318]                             quietly = TRUE)
[17:45:20.318]                           if (has_future) {
[17:45:20.318]                             ns <- base::getNamespace("future")
[17:45:20.318]                             version <- ns[[".package"]][["version"]]
[17:45:20.318]                             if (is.null(version)) 
[17:45:20.318]                               version <- utils::packageVersion("future")
[17:45:20.318]                           }
[17:45:20.318]                           else {
[17:45:20.318]                             version <- NULL
[17:45:20.318]                           }
[17:45:20.318]                           if (!has_future || version < "1.8.0") {
[17:45:20.318]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.318]                               "", base::R.version$version.string), 
[17:45:20.318]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:20.318]                                 base::R.version$platform, 8 * 
[17:45:20.318]                                   base::.Machine$sizeof.pointer), 
[17:45:20.318]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.318]                                 "release", "version")], collapse = " "), 
[17:45:20.318]                               hostname = base::Sys.info()[["nodename"]])
[17:45:20.318]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.318]                               info)
[17:45:20.318]                             info <- base::paste(info, collapse = "; ")
[17:45:20.318]                             if (!has_future) {
[17:45:20.318]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.318]                                 info)
[17:45:20.318]                             }
[17:45:20.318]                             else {
[17:45:20.318]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.318]                                 info, version)
[17:45:20.318]                             }
[17:45:20.318]                             base::stop(msg)
[17:45:20.318]                           }
[17:45:20.318]                         })
[17:45:20.318]                       }
[17:45:20.318]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.318]                       base::options(mc.cores = 1L)
[17:45:20.318]                     }
[17:45:20.318]                     base::local({
[17:45:20.318]                       for (pkg in "future.apply") {
[17:45:20.318]                         base::loadNamespace(pkg)
[17:45:20.318]                         base::library(pkg, character.only = TRUE)
[17:45:20.318]                       }
[17:45:20.318]                     })
[17:45:20.318]                   }
[17:45:20.318]                   ...future.strategy.old <- future::plan("list")
[17:45:20.318]                   options(future.plan = NULL)
[17:45:20.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.318]                 }
[17:45:20.318]                 ...future.workdir <- getwd()
[17:45:20.318]             }
[17:45:20.318]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.318]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.318]         }
[17:45:20.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.318]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:20.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.318]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.318]             base::names(...future.oldOptions))
[17:45:20.318]     }
[17:45:20.318]     if (FALSE) {
[17:45:20.318]     }
[17:45:20.318]     else {
[17:45:20.318]         if (TRUE) {
[17:45:20.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.318]                 open = "w")
[17:45:20.318]         }
[17:45:20.318]         else {
[17:45:20.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.318]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.318]         }
[17:45:20.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.318]             base::sink(type = "output", split = FALSE)
[17:45:20.318]             base::close(...future.stdout)
[17:45:20.318]         }, add = TRUE)
[17:45:20.318]     }
[17:45:20.318]     ...future.frame <- base::sys.nframe()
[17:45:20.318]     ...future.conditions <- base::list()
[17:45:20.318]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.318]     if (FALSE) {
[17:45:20.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.318]     }
[17:45:20.318]     ...future.result <- base::tryCatch({
[17:45:20.318]         base::withCallingHandlers({
[17:45:20.318]             ...future.value <- base::withVisible(base::local({
[17:45:20.318]                 withCallingHandlers({
[17:45:20.318]                   {
[17:45:20.318]                     do.call(function(...) {
[17:45:20.318]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.318]                       if (!identical(...future.globals.maxSize.org, 
[17:45:20.318]                         ...future.globals.maxSize)) {
[17:45:20.318]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.318]                         on.exit(options(oopts), add = TRUE)
[17:45:20.318]                       }
[17:45:20.318]                       {
[17:45:20.318]                         lapply(seq_along(...future.elements_ii), 
[17:45:20.318]                           FUN = function(jj) {
[17:45:20.318]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.318]                             ...future.FUN(...future.X_jj, ...)
[17:45:20.318]                           })
[17:45:20.318]                       }
[17:45:20.318]                     }, args = future.call.arguments)
[17:45:20.318]                   }
[17:45:20.318]                 }, immediateCondition = function(cond) {
[17:45:20.318]                   save_rds <- function (object, pathname, ...) 
[17:45:20.318]                   {
[17:45:20.318]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:20.318]                     if (file_test("-f", pathname_tmp)) {
[17:45:20.318]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.318]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:20.318]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.318]                         fi_tmp[["mtime"]])
[17:45:20.318]                     }
[17:45:20.318]                     tryCatch({
[17:45:20.318]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:20.318]                     }, error = function(ex) {
[17:45:20.318]                       msg <- conditionMessage(ex)
[17:45:20.318]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.318]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:20.318]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.318]                         fi_tmp[["mtime"]], msg)
[17:45:20.318]                       ex$message <- msg
[17:45:20.318]                       stop(ex)
[17:45:20.318]                     })
[17:45:20.318]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:20.318]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:20.318]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:20.318]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.318]                       fi <- file.info(pathname)
[17:45:20.318]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:20.318]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.318]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:20.318]                         fi[["size"]], fi[["mtime"]])
[17:45:20.318]                       stop(msg)
[17:45:20.318]                     }
[17:45:20.318]                     invisible(pathname)
[17:45:20.318]                   }
[17:45:20.318]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:20.318]                     rootPath = tempdir()) 
[17:45:20.318]                   {
[17:45:20.318]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:20.318]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:20.318]                       tmpdir = path, fileext = ".rds")
[17:45:20.318]                     save_rds(obj, file)
[17:45:20.318]                   }
[17:45:20.318]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:20.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.318]                   {
[17:45:20.318]                     inherits <- base::inherits
[17:45:20.318]                     invokeRestart <- base::invokeRestart
[17:45:20.318]                     is.null <- base::is.null
[17:45:20.318]                     muffled <- FALSE
[17:45:20.318]                     if (inherits(cond, "message")) {
[17:45:20.318]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.318]                       if (muffled) 
[17:45:20.318]                         invokeRestart("muffleMessage")
[17:45:20.318]                     }
[17:45:20.318]                     else if (inherits(cond, "warning")) {
[17:45:20.318]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.318]                       if (muffled) 
[17:45:20.318]                         invokeRestart("muffleWarning")
[17:45:20.318]                     }
[17:45:20.318]                     else if (inherits(cond, "condition")) {
[17:45:20.318]                       if (!is.null(pattern)) {
[17:45:20.318]                         computeRestarts <- base::computeRestarts
[17:45:20.318]                         grepl <- base::grepl
[17:45:20.318]                         restarts <- computeRestarts(cond)
[17:45:20.318]                         for (restart in restarts) {
[17:45:20.318]                           name <- restart$name
[17:45:20.318]                           if (is.null(name)) 
[17:45:20.318]                             next
[17:45:20.318]                           if (!grepl(pattern, name)) 
[17:45:20.318]                             next
[17:45:20.318]                           invokeRestart(restart)
[17:45:20.318]                           muffled <- TRUE
[17:45:20.318]                           break
[17:45:20.318]                         }
[17:45:20.318]                       }
[17:45:20.318]                     }
[17:45:20.318]                     invisible(muffled)
[17:45:20.318]                   }
[17:45:20.318]                   muffleCondition(cond)
[17:45:20.318]                 })
[17:45:20.318]             }))
[17:45:20.318]             future::FutureResult(value = ...future.value$value, 
[17:45:20.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.318]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.318]                     ...future.globalenv.names))
[17:45:20.318]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.318]         }, condition = base::local({
[17:45:20.318]             c <- base::c
[17:45:20.318]             inherits <- base::inherits
[17:45:20.318]             invokeRestart <- base::invokeRestart
[17:45:20.318]             length <- base::length
[17:45:20.318]             list <- base::list
[17:45:20.318]             seq.int <- base::seq.int
[17:45:20.318]             signalCondition <- base::signalCondition
[17:45:20.318]             sys.calls <- base::sys.calls
[17:45:20.318]             `[[` <- base::`[[`
[17:45:20.318]             `+` <- base::`+`
[17:45:20.318]             `<<-` <- base::`<<-`
[17:45:20.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.318]                   3L)]
[17:45:20.318]             }
[17:45:20.318]             function(cond) {
[17:45:20.318]                 is_error <- inherits(cond, "error")
[17:45:20.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.318]                   NULL)
[17:45:20.318]                 if (is_error) {
[17:45:20.318]                   sessionInformation <- function() {
[17:45:20.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.318]                       search = base::search(), system = base::Sys.info())
[17:45:20.318]                   }
[17:45:20.318]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.318]                     cond$call), session = sessionInformation(), 
[17:45:20.318]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.318]                   signalCondition(cond)
[17:45:20.318]                 }
[17:45:20.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.318]                 "immediateCondition"))) {
[17:45:20.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.318]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.318]                   if (TRUE && !signal) {
[17:45:20.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.318]                     {
[17:45:20.318]                       inherits <- base::inherits
[17:45:20.318]                       invokeRestart <- base::invokeRestart
[17:45:20.318]                       is.null <- base::is.null
[17:45:20.318]                       muffled <- FALSE
[17:45:20.318]                       if (inherits(cond, "message")) {
[17:45:20.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.318]                         if (muffled) 
[17:45:20.318]                           invokeRestart("muffleMessage")
[17:45:20.318]                       }
[17:45:20.318]                       else if (inherits(cond, "warning")) {
[17:45:20.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.318]                         if (muffled) 
[17:45:20.318]                           invokeRestart("muffleWarning")
[17:45:20.318]                       }
[17:45:20.318]                       else if (inherits(cond, "condition")) {
[17:45:20.318]                         if (!is.null(pattern)) {
[17:45:20.318]                           computeRestarts <- base::computeRestarts
[17:45:20.318]                           grepl <- base::grepl
[17:45:20.318]                           restarts <- computeRestarts(cond)
[17:45:20.318]                           for (restart in restarts) {
[17:45:20.318]                             name <- restart$name
[17:45:20.318]                             if (is.null(name)) 
[17:45:20.318]                               next
[17:45:20.318]                             if (!grepl(pattern, name)) 
[17:45:20.318]                               next
[17:45:20.318]                             invokeRestart(restart)
[17:45:20.318]                             muffled <- TRUE
[17:45:20.318]                             break
[17:45:20.318]                           }
[17:45:20.318]                         }
[17:45:20.318]                       }
[17:45:20.318]                       invisible(muffled)
[17:45:20.318]                     }
[17:45:20.318]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.318]                   }
[17:45:20.318]                 }
[17:45:20.318]                 else {
[17:45:20.318]                   if (TRUE) {
[17:45:20.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.318]                     {
[17:45:20.318]                       inherits <- base::inherits
[17:45:20.318]                       invokeRestart <- base::invokeRestart
[17:45:20.318]                       is.null <- base::is.null
[17:45:20.318]                       muffled <- FALSE
[17:45:20.318]                       if (inherits(cond, "message")) {
[17:45:20.318]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.318]                         if (muffled) 
[17:45:20.318]                           invokeRestart("muffleMessage")
[17:45:20.318]                       }
[17:45:20.318]                       else if (inherits(cond, "warning")) {
[17:45:20.318]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.318]                         if (muffled) 
[17:45:20.318]                           invokeRestart("muffleWarning")
[17:45:20.318]                       }
[17:45:20.318]                       else if (inherits(cond, "condition")) {
[17:45:20.318]                         if (!is.null(pattern)) {
[17:45:20.318]                           computeRestarts <- base::computeRestarts
[17:45:20.318]                           grepl <- base::grepl
[17:45:20.318]                           restarts <- computeRestarts(cond)
[17:45:20.318]                           for (restart in restarts) {
[17:45:20.318]                             name <- restart$name
[17:45:20.318]                             if (is.null(name)) 
[17:45:20.318]                               next
[17:45:20.318]                             if (!grepl(pattern, name)) 
[17:45:20.318]                               next
[17:45:20.318]                             invokeRestart(restart)
[17:45:20.318]                             muffled <- TRUE
[17:45:20.318]                             break
[17:45:20.318]                           }
[17:45:20.318]                         }
[17:45:20.318]                       }
[17:45:20.318]                       invisible(muffled)
[17:45:20.318]                     }
[17:45:20.318]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.318]                   }
[17:45:20.318]                 }
[17:45:20.318]             }
[17:45:20.318]         }))
[17:45:20.318]     }, error = function(ex) {
[17:45:20.318]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.318]                 ...future.rng), started = ...future.startTime, 
[17:45:20.318]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.318]             version = "1.8"), class = "FutureResult")
[17:45:20.318]     }, finally = {
[17:45:20.318]         if (!identical(...future.workdir, getwd())) 
[17:45:20.318]             setwd(...future.workdir)
[17:45:20.318]         {
[17:45:20.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.318]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.318]             }
[17:45:20.318]             base::options(...future.oldOptions)
[17:45:20.318]             if (.Platform$OS.type == "windows") {
[17:45:20.318]                 old_names <- names(...future.oldEnvVars)
[17:45:20.318]                 envs <- base::Sys.getenv()
[17:45:20.318]                 names <- names(envs)
[17:45:20.318]                 common <- intersect(names, old_names)
[17:45:20.318]                 added <- setdiff(names, old_names)
[17:45:20.318]                 removed <- setdiff(old_names, names)
[17:45:20.318]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.318]                   envs[common]]
[17:45:20.318]                 NAMES <- toupper(changed)
[17:45:20.318]                 args <- list()
[17:45:20.318]                 for (kk in seq_along(NAMES)) {
[17:45:20.318]                   name <- changed[[kk]]
[17:45:20.318]                   NAME <- NAMES[[kk]]
[17:45:20.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.318]                     next
[17:45:20.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.318]                 }
[17:45:20.318]                 NAMES <- toupper(added)
[17:45:20.318]                 for (kk in seq_along(NAMES)) {
[17:45:20.318]                   name <- added[[kk]]
[17:45:20.318]                   NAME <- NAMES[[kk]]
[17:45:20.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.318]                     next
[17:45:20.318]                   args[[name]] <- ""
[17:45:20.318]                 }
[17:45:20.318]                 NAMES <- toupper(removed)
[17:45:20.318]                 for (kk in seq_along(NAMES)) {
[17:45:20.318]                   name <- removed[[kk]]
[17:45:20.318]                   NAME <- NAMES[[kk]]
[17:45:20.318]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.318]                     next
[17:45:20.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.318]                 }
[17:45:20.318]                 if (length(args) > 0) 
[17:45:20.318]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.318]             }
[17:45:20.318]             else {
[17:45:20.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.318]             }
[17:45:20.318]             {
[17:45:20.318]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.318]                   0L) {
[17:45:20.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.318]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.318]                   base::options(opts)
[17:45:20.318]                 }
[17:45:20.318]                 {
[17:45:20.318]                   {
[17:45:20.318]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.318]                     NULL
[17:45:20.318]                   }
[17:45:20.318]                   options(future.plan = NULL)
[17:45:20.318]                   if (is.na(NA_character_)) 
[17:45:20.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.318]                     .init = FALSE)
[17:45:20.318]                 }
[17:45:20.318]             }
[17:45:20.318]         }
[17:45:20.318]     })
[17:45:20.318]     if (TRUE) {
[17:45:20.318]         base::sink(type = "output", split = FALSE)
[17:45:20.318]         if (TRUE) {
[17:45:20.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.318]         }
[17:45:20.318]         else {
[17:45:20.318]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.318]         }
[17:45:20.318]         base::close(...future.stdout)
[17:45:20.318]         ...future.stdout <- NULL
[17:45:20.318]     }
[17:45:20.318]     ...future.result$conditions <- ...future.conditions
[17:45:20.318]     ...future.result$finished <- base::Sys.time()
[17:45:20.318]     ...future.result
[17:45:20.318] }
[17:45:20.320] assign_globals() ...
[17:45:20.320] List of 11
[17:45:20.320]  $ ...future.FUN            :function (x, ...)  
[17:45:20.320]  $ x_FUN                    :function (x)  
[17:45:20.320]  $ times                    : int 2
[17:45:20.320]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.320]  $ stop_if_not              :function (...)  
[17:45:20.320]  $ dim                      : NULL
[17:45:20.320]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:20.320]  $ future.call.arguments    : list()
[17:45:20.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.320]  $ ...future.elements_ii    :List of 1
[17:45:20.320]   ..$ : int 1
[17:45:20.320]  $ ...future.seeds_ii       : NULL
[17:45:20.320]  $ ...future.globals.maxSize: NULL
[17:45:20.320]  - attr(*, "where")=List of 11
[17:45:20.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:20.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:20.320]  - attr(*, "resolved")= logi FALSE
[17:45:20.320]  - attr(*, "total_size")= num 95128
[17:45:20.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.320]  - attr(*, "already-done")= logi TRUE
[17:45:20.330] - copied ‘...future.FUN’ to environment
[17:45:20.331] - copied ‘x_FUN’ to environment
[17:45:20.331] - copied ‘times’ to environment
[17:45:20.331] - copied ‘stopf’ to environment
[17:45:20.331] - copied ‘stop_if_not’ to environment
[17:45:20.331] - copied ‘dim’ to environment
[17:45:20.331] - copied ‘valid_types’ to environment
[17:45:20.331] - copied ‘future.call.arguments’ to environment
[17:45:20.331] - copied ‘...future.elements_ii’ to environment
[17:45:20.332] - copied ‘...future.seeds_ii’ to environment
[17:45:20.332] - copied ‘...future.globals.maxSize’ to environment
[17:45:20.332] assign_globals() ... done
[17:45:20.332] requestCore(): workers = 2
[17:45:20.334] MulticoreFuture started
[17:45:20.335] - Launch lazy future ... done
[17:45:20.336] run() for ‘MulticoreFuture’ ... done
[17:45:20.336] Created future:
[17:45:20.337] plan(): Setting new future strategy stack:
[17:45:20.337] List of future strategies:
[17:45:20.337] 1. sequential:
[17:45:20.337]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.337]    - tweaked: FALSE
[17:45:20.337]    - call: NULL
[17:45:20.339] plan(): nbrOfWorkers() = 1
[17:45:20.342] plan(): Setting new future strategy stack:
[17:45:20.342] List of future strategies:
[17:45:20.342] 1. multicore:
[17:45:20.342]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:20.342]    - tweaked: FALSE
[17:45:20.342]    - call: plan(strategy)
[17:45:20.347] plan(): nbrOfWorkers() = 2
[17:45:20.337] MulticoreFuture:
[17:45:20.337] Label: ‘future_vapply-1’
[17:45:20.337] Expression:
[17:45:20.337] {
[17:45:20.337]     do.call(function(...) {
[17:45:20.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.337]             on.exit(options(oopts), add = TRUE)
[17:45:20.337]         }
[17:45:20.337]         {
[17:45:20.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.337]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.337]             })
[17:45:20.337]         }
[17:45:20.337]     }, args = future.call.arguments)
[17:45:20.337] }
[17:45:20.337] Lazy evaluation: FALSE
[17:45:20.337] Asynchronous evaluation: TRUE
[17:45:20.337] Local evaluation: TRUE
[17:45:20.337] Environment: R_GlobalEnv
[17:45:20.337] Capture standard output: TRUE
[17:45:20.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:20.337] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:20.337] Packages: 1 packages (‘future.apply’)
[17:45:20.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:20.337] Resolved: FALSE
[17:45:20.337] Value: <not collected>
[17:45:20.337] Conditions captured: <none>
[17:45:20.337] Early signaling: FALSE
[17:45:20.337] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:20.337] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.352] Chunk #1 of 2 ... DONE
[17:45:20.352] Chunk #2 of 2 ...
[17:45:20.352]  - Finding globals in 'X' for chunk #2 ...
[17:45:20.352] getGlobalsAndPackages() ...
[17:45:20.352] Searching for globals...
[17:45:20.353] 
[17:45:20.353] Searching for globals ... DONE
[17:45:20.353] - globals: [0] <none>
[17:45:20.353] getGlobalsAndPackages() ... DONE
[17:45:20.353]    + additional globals found: [n=0] 
[17:45:20.353]    + additional namespaces needed: [n=0] 
[17:45:20.354]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:20.354]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:20.354]  - seeds: <none>
[17:45:20.354]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.354] getGlobalsAndPackages() ...
[17:45:20.354] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.355] Resolving globals: FALSE
[17:45:20.355] Tweak future expression to call with '...' arguments ...
[17:45:20.355] {
[17:45:20.355]     do.call(function(...) {
[17:45:20.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.355]             on.exit(options(oopts), add = TRUE)
[17:45:20.355]         }
[17:45:20.355]         {
[17:45:20.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.355]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.355]             })
[17:45:20.355]         }
[17:45:20.355]     }, args = future.call.arguments)
[17:45:20.355] }
[17:45:20.355] Tweak future expression to call with '...' arguments ... DONE
[17:45:20.356] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:20.356] - packages: [1] ‘future.apply’
[17:45:20.356] getGlobalsAndPackages() ... DONE
[17:45:20.357] run() for ‘Future’ ...
[17:45:20.357] - state: ‘created’
[17:45:20.357] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[17:45:20.361] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[17:45:20.362]   - Field: ‘label’
[17:45:20.362]   - Field: ‘local’
[17:45:20.362]   - Field: ‘owner’
[17:45:20.362]   - Field: ‘envir’
[17:45:20.362]   - Field: ‘workers’
[17:45:20.362]   - Field: ‘packages’
[17:45:20.363]   - Field: ‘gc’
[17:45:20.363]   - Field: ‘job’
[17:45:20.363]   - Field: ‘conditions’
[17:45:20.363]   - Field: ‘expr’
[17:45:20.363]   - Field: ‘uuid’
[17:45:20.363]   - Field: ‘seed’
[17:45:20.363]   - Field: ‘version’
[17:45:20.364]   - Field: ‘result’
[17:45:20.364]   - Field: ‘asynchronous’
[17:45:20.364]   - Field: ‘calls’
[17:45:20.364]   - Field: ‘globals’
[17:45:20.364]   - Field: ‘stdout’
[17:45:20.364]   - Field: ‘earlySignal’
[17:45:20.364]   - Field: ‘lazy’
[17:45:20.365]   - Field: ‘state’
[17:45:20.365] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[17:45:20.365] - Launch lazy future ...
[17:45:20.365] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:20.365] Packages needed by future strategies (n = 0): <none>
[17:45:20.366] {
[17:45:20.366]     {
[17:45:20.366]         {
[17:45:20.366]             ...future.startTime <- base::Sys.time()
[17:45:20.366]             {
[17:45:20.366]                 {
[17:45:20.366]                   {
[17:45:20.366]                     {
[17:45:20.366]                       {
[17:45:20.366]                         base::local({
[17:45:20.366]                           has_future <- base::requireNamespace("future", 
[17:45:20.366]                             quietly = TRUE)
[17:45:20.366]                           if (has_future) {
[17:45:20.366]                             ns <- base::getNamespace("future")
[17:45:20.366]                             version <- ns[[".package"]][["version"]]
[17:45:20.366]                             if (is.null(version)) 
[17:45:20.366]                               version <- utils::packageVersion("future")
[17:45:20.366]                           }
[17:45:20.366]                           else {
[17:45:20.366]                             version <- NULL
[17:45:20.366]                           }
[17:45:20.366]                           if (!has_future || version < "1.8.0") {
[17:45:20.366]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.366]                               "", base::R.version$version.string), 
[17:45:20.366]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:20.366]                                 base::R.version$platform, 8 * 
[17:45:20.366]                                   base::.Machine$sizeof.pointer), 
[17:45:20.366]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.366]                                 "release", "version")], collapse = " "), 
[17:45:20.366]                               hostname = base::Sys.info()[["nodename"]])
[17:45:20.366]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.366]                               info)
[17:45:20.366]                             info <- base::paste(info, collapse = "; ")
[17:45:20.366]                             if (!has_future) {
[17:45:20.366]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.366]                                 info)
[17:45:20.366]                             }
[17:45:20.366]                             else {
[17:45:20.366]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.366]                                 info, version)
[17:45:20.366]                             }
[17:45:20.366]                             base::stop(msg)
[17:45:20.366]                           }
[17:45:20.366]                         })
[17:45:20.366]                       }
[17:45:20.366]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.366]                       base::options(mc.cores = 1L)
[17:45:20.366]                     }
[17:45:20.366]                     base::local({
[17:45:20.366]                       for (pkg in "future.apply") {
[17:45:20.366]                         base::loadNamespace(pkg)
[17:45:20.366]                         base::library(pkg, character.only = TRUE)
[17:45:20.366]                       }
[17:45:20.366]                     })
[17:45:20.366]                   }
[17:45:20.366]                   ...future.strategy.old <- future::plan("list")
[17:45:20.366]                   options(future.plan = NULL)
[17:45:20.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.366]                 }
[17:45:20.366]                 ...future.workdir <- getwd()
[17:45:20.366]             }
[17:45:20.366]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.366]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.366]         }
[17:45:20.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.366]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:20.366]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.366]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.366]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.366]             base::names(...future.oldOptions))
[17:45:20.366]     }
[17:45:20.366]     if (FALSE) {
[17:45:20.366]     }
[17:45:20.366]     else {
[17:45:20.366]         if (TRUE) {
[17:45:20.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.366]                 open = "w")
[17:45:20.366]         }
[17:45:20.366]         else {
[17:45:20.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.366]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.366]         }
[17:45:20.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.366]             base::sink(type = "output", split = FALSE)
[17:45:20.366]             base::close(...future.stdout)
[17:45:20.366]         }, add = TRUE)
[17:45:20.366]     }
[17:45:20.366]     ...future.frame <- base::sys.nframe()
[17:45:20.366]     ...future.conditions <- base::list()
[17:45:20.366]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.366]     if (FALSE) {
[17:45:20.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.366]     }
[17:45:20.366]     ...future.result <- base::tryCatch({
[17:45:20.366]         base::withCallingHandlers({
[17:45:20.366]             ...future.value <- base::withVisible(base::local({
[17:45:20.366]                 withCallingHandlers({
[17:45:20.366]                   {
[17:45:20.366]                     do.call(function(...) {
[17:45:20.366]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.366]                       if (!identical(...future.globals.maxSize.org, 
[17:45:20.366]                         ...future.globals.maxSize)) {
[17:45:20.366]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.366]                         on.exit(options(oopts), add = TRUE)
[17:45:20.366]                       }
[17:45:20.366]                       {
[17:45:20.366]                         lapply(seq_along(...future.elements_ii), 
[17:45:20.366]                           FUN = function(jj) {
[17:45:20.366]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.366]                             ...future.FUN(...future.X_jj, ...)
[17:45:20.366]                           })
[17:45:20.366]                       }
[17:45:20.366]                     }, args = future.call.arguments)
[17:45:20.366]                   }
[17:45:20.366]                 }, immediateCondition = function(cond) {
[17:45:20.366]                   save_rds <- function (object, pathname, ...) 
[17:45:20.366]                   {
[17:45:20.366]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[17:45:20.366]                     if (file_test("-f", pathname_tmp)) {
[17:45:20.366]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.366]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[17:45:20.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.366]                         fi_tmp[["mtime"]])
[17:45:20.366]                     }
[17:45:20.366]                     tryCatch({
[17:45:20.366]                       saveRDS(object, file = pathname_tmp, ...)
[17:45:20.366]                     }, error = function(ex) {
[17:45:20.366]                       msg <- conditionMessage(ex)
[17:45:20.366]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.366]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[17:45:20.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.366]                         fi_tmp[["mtime"]], msg)
[17:45:20.366]                       ex$message <- msg
[17:45:20.366]                       stop(ex)
[17:45:20.366]                     })
[17:45:20.366]                     stopifnot(file_test("-f", pathname_tmp))
[17:45:20.366]                     res <- file.rename(from = pathname_tmp, to = pathname)
[17:45:20.366]                     if (!res || file_test("-f", pathname_tmp)) {
[17:45:20.366]                       fi_tmp <- file.info(pathname_tmp)
[17:45:20.366]                       fi <- file.info(pathname)
[17:45:20.366]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[17:45:20.366]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[17:45:20.366]                         fi_tmp[["mtime"]], sQuote(pathname), 
[17:45:20.366]                         fi[["size"]], fi[["mtime"]])
[17:45:20.366]                       stop(msg)
[17:45:20.366]                     }
[17:45:20.366]                     invisible(pathname)
[17:45:20.366]                   }
[17:45:20.366]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[17:45:20.366]                     rootPath = tempdir()) 
[17:45:20.366]                   {
[17:45:20.366]                     obj <- list(time = Sys.time(), condition = cond)
[17:45:20.366]                     file <- tempfile(pattern = class(cond)[1], 
[17:45:20.366]                       tmpdir = path, fileext = ".rds")
[17:45:20.366]                     save_rds(obj, file)
[17:45:20.366]                   }
[17:45:20.366]                   saveImmediateCondition(cond, path = "/tmp/Rtmphtewk5/.future/immediateConditions")
[17:45:20.366]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.366]                   {
[17:45:20.366]                     inherits <- base::inherits
[17:45:20.366]                     invokeRestart <- base::invokeRestart
[17:45:20.366]                     is.null <- base::is.null
[17:45:20.366]                     muffled <- FALSE
[17:45:20.366]                     if (inherits(cond, "message")) {
[17:45:20.366]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.366]                       if (muffled) 
[17:45:20.366]                         invokeRestart("muffleMessage")
[17:45:20.366]                     }
[17:45:20.366]                     else if (inherits(cond, "warning")) {
[17:45:20.366]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.366]                       if (muffled) 
[17:45:20.366]                         invokeRestart("muffleWarning")
[17:45:20.366]                     }
[17:45:20.366]                     else if (inherits(cond, "condition")) {
[17:45:20.366]                       if (!is.null(pattern)) {
[17:45:20.366]                         computeRestarts <- base::computeRestarts
[17:45:20.366]                         grepl <- base::grepl
[17:45:20.366]                         restarts <- computeRestarts(cond)
[17:45:20.366]                         for (restart in restarts) {
[17:45:20.366]                           name <- restart$name
[17:45:20.366]                           if (is.null(name)) 
[17:45:20.366]                             next
[17:45:20.366]                           if (!grepl(pattern, name)) 
[17:45:20.366]                             next
[17:45:20.366]                           invokeRestart(restart)
[17:45:20.366]                           muffled <- TRUE
[17:45:20.366]                           break
[17:45:20.366]                         }
[17:45:20.366]                       }
[17:45:20.366]                     }
[17:45:20.366]                     invisible(muffled)
[17:45:20.366]                   }
[17:45:20.366]                   muffleCondition(cond)
[17:45:20.366]                 })
[17:45:20.366]             }))
[17:45:20.366]             future::FutureResult(value = ...future.value$value, 
[17:45:20.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.366]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.366]                     ...future.globalenv.names))
[17:45:20.366]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.366]         }, condition = base::local({
[17:45:20.366]             c <- base::c
[17:45:20.366]             inherits <- base::inherits
[17:45:20.366]             invokeRestart <- base::invokeRestart
[17:45:20.366]             length <- base::length
[17:45:20.366]             list <- base::list
[17:45:20.366]             seq.int <- base::seq.int
[17:45:20.366]             signalCondition <- base::signalCondition
[17:45:20.366]             sys.calls <- base::sys.calls
[17:45:20.366]             `[[` <- base::`[[`
[17:45:20.366]             `+` <- base::`+`
[17:45:20.366]             `<<-` <- base::`<<-`
[17:45:20.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.366]                   3L)]
[17:45:20.366]             }
[17:45:20.366]             function(cond) {
[17:45:20.366]                 is_error <- inherits(cond, "error")
[17:45:20.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.366]                   NULL)
[17:45:20.366]                 if (is_error) {
[17:45:20.366]                   sessionInformation <- function() {
[17:45:20.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.366]                       search = base::search(), system = base::Sys.info())
[17:45:20.366]                   }
[17:45:20.366]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.366]                     cond$call), session = sessionInformation(), 
[17:45:20.366]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.366]                   signalCondition(cond)
[17:45:20.366]                 }
[17:45:20.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.366]                 "immediateCondition"))) {
[17:45:20.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.366]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.366]                   if (TRUE && !signal) {
[17:45:20.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.366]                     {
[17:45:20.366]                       inherits <- base::inherits
[17:45:20.366]                       invokeRestart <- base::invokeRestart
[17:45:20.366]                       is.null <- base::is.null
[17:45:20.366]                       muffled <- FALSE
[17:45:20.366]                       if (inherits(cond, "message")) {
[17:45:20.366]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.366]                         if (muffled) 
[17:45:20.366]                           invokeRestart("muffleMessage")
[17:45:20.366]                       }
[17:45:20.366]                       else if (inherits(cond, "warning")) {
[17:45:20.366]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.366]                         if (muffled) 
[17:45:20.366]                           invokeRestart("muffleWarning")
[17:45:20.366]                       }
[17:45:20.366]                       else if (inherits(cond, "condition")) {
[17:45:20.366]                         if (!is.null(pattern)) {
[17:45:20.366]                           computeRestarts <- base::computeRestarts
[17:45:20.366]                           grepl <- base::grepl
[17:45:20.366]                           restarts <- computeRestarts(cond)
[17:45:20.366]                           for (restart in restarts) {
[17:45:20.366]                             name <- restart$name
[17:45:20.366]                             if (is.null(name)) 
[17:45:20.366]                               next
[17:45:20.366]                             if (!grepl(pattern, name)) 
[17:45:20.366]                               next
[17:45:20.366]                             invokeRestart(restart)
[17:45:20.366]                             muffled <- TRUE
[17:45:20.366]                             break
[17:45:20.366]                           }
[17:45:20.366]                         }
[17:45:20.366]                       }
[17:45:20.366]                       invisible(muffled)
[17:45:20.366]                     }
[17:45:20.366]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.366]                   }
[17:45:20.366]                 }
[17:45:20.366]                 else {
[17:45:20.366]                   if (TRUE) {
[17:45:20.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.366]                     {
[17:45:20.366]                       inherits <- base::inherits
[17:45:20.366]                       invokeRestart <- base::invokeRestart
[17:45:20.366]                       is.null <- base::is.null
[17:45:20.366]                       muffled <- FALSE
[17:45:20.366]                       if (inherits(cond, "message")) {
[17:45:20.366]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.366]                         if (muffled) 
[17:45:20.366]                           invokeRestart("muffleMessage")
[17:45:20.366]                       }
[17:45:20.366]                       else if (inherits(cond, "warning")) {
[17:45:20.366]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.366]                         if (muffled) 
[17:45:20.366]                           invokeRestart("muffleWarning")
[17:45:20.366]                       }
[17:45:20.366]                       else if (inherits(cond, "condition")) {
[17:45:20.366]                         if (!is.null(pattern)) {
[17:45:20.366]                           computeRestarts <- base::computeRestarts
[17:45:20.366]                           grepl <- base::grepl
[17:45:20.366]                           restarts <- computeRestarts(cond)
[17:45:20.366]                           for (restart in restarts) {
[17:45:20.366]                             name <- restart$name
[17:45:20.366]                             if (is.null(name)) 
[17:45:20.366]                               next
[17:45:20.366]                             if (!grepl(pattern, name)) 
[17:45:20.366]                               next
[17:45:20.366]                             invokeRestart(restart)
[17:45:20.366]                             muffled <- TRUE
[17:45:20.366]                             break
[17:45:20.366]                           }
[17:45:20.366]                         }
[17:45:20.366]                       }
[17:45:20.366]                       invisible(muffled)
[17:45:20.366]                     }
[17:45:20.366]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.366]                   }
[17:45:20.366]                 }
[17:45:20.366]             }
[17:45:20.366]         }))
[17:45:20.366]     }, error = function(ex) {
[17:45:20.366]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.366]                 ...future.rng), started = ...future.startTime, 
[17:45:20.366]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.366]             version = "1.8"), class = "FutureResult")
[17:45:20.366]     }, finally = {
[17:45:20.366]         if (!identical(...future.workdir, getwd())) 
[17:45:20.366]             setwd(...future.workdir)
[17:45:20.366]         {
[17:45:20.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.366]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.366]             }
[17:45:20.366]             base::options(...future.oldOptions)
[17:45:20.366]             if (.Platform$OS.type == "windows") {
[17:45:20.366]                 old_names <- names(...future.oldEnvVars)
[17:45:20.366]                 envs <- base::Sys.getenv()
[17:45:20.366]                 names <- names(envs)
[17:45:20.366]                 common <- intersect(names, old_names)
[17:45:20.366]                 added <- setdiff(names, old_names)
[17:45:20.366]                 removed <- setdiff(old_names, names)
[17:45:20.366]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.366]                   envs[common]]
[17:45:20.366]                 NAMES <- toupper(changed)
[17:45:20.366]                 args <- list()
[17:45:20.366]                 for (kk in seq_along(NAMES)) {
[17:45:20.366]                   name <- changed[[kk]]
[17:45:20.366]                   NAME <- NAMES[[kk]]
[17:45:20.366]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.366]                     next
[17:45:20.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.366]                 }
[17:45:20.366]                 NAMES <- toupper(added)
[17:45:20.366]                 for (kk in seq_along(NAMES)) {
[17:45:20.366]                   name <- added[[kk]]
[17:45:20.366]                   NAME <- NAMES[[kk]]
[17:45:20.366]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.366]                     next
[17:45:20.366]                   args[[name]] <- ""
[17:45:20.366]                 }
[17:45:20.366]                 NAMES <- toupper(removed)
[17:45:20.366]                 for (kk in seq_along(NAMES)) {
[17:45:20.366]                   name <- removed[[kk]]
[17:45:20.366]                   NAME <- NAMES[[kk]]
[17:45:20.366]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.366]                     next
[17:45:20.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.366]                 }
[17:45:20.366]                 if (length(args) > 0) 
[17:45:20.366]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.366]             }
[17:45:20.366]             else {
[17:45:20.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.366]             }
[17:45:20.366]             {
[17:45:20.366]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.366]                   0L) {
[17:45:20.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.366]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.366]                   base::options(opts)
[17:45:20.366]                 }
[17:45:20.366]                 {
[17:45:20.366]                   {
[17:45:20.366]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.366]                     NULL
[17:45:20.366]                   }
[17:45:20.366]                   options(future.plan = NULL)
[17:45:20.366]                   if (is.na(NA_character_)) 
[17:45:20.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.366]                     .init = FALSE)
[17:45:20.366]                 }
[17:45:20.366]             }
[17:45:20.366]         }
[17:45:20.366]     })
[17:45:20.366]     if (TRUE) {
[17:45:20.366]         base::sink(type = "output", split = FALSE)
[17:45:20.366]         if (TRUE) {
[17:45:20.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.366]         }
[17:45:20.366]         else {
[17:45:20.366]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.366]         }
[17:45:20.366]         base::close(...future.stdout)
[17:45:20.366]         ...future.stdout <- NULL
[17:45:20.366]     }
[17:45:20.366]     ...future.result$conditions <- ...future.conditions
[17:45:20.366]     ...future.result$finished <- base::Sys.time()
[17:45:20.366]     ...future.result
[17:45:20.366] }
[17:45:20.370] assign_globals() ...
[17:45:20.370] List of 11
[17:45:20.370]  $ ...future.FUN            :function (x, ...)  
[17:45:20.370]  $ x_FUN                    :function (x)  
[17:45:20.370]  $ times                    : int 2
[17:45:20.370]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:20.370]  $ stop_if_not              :function (...)  
[17:45:20.370]  $ dim                      : NULL
[17:45:20.370]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[17:45:20.370]  $ future.call.arguments    : list()
[17:45:20.370]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:20.370]  $ ...future.elements_ii    :List of 2
[17:45:20.370]   ..$ : int 2
[17:45:20.370]   ..$ : int 3
[17:45:20.370]  $ ...future.seeds_ii       : NULL
[17:45:20.370]  $ ...future.globals.maxSize: NULL
[17:45:20.370]  - attr(*, "where")=List of 11
[17:45:20.370]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ times                    :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ stopf                    :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ dim                      :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ valid_types              :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[17:45:20.370]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[17:45:20.370]  - attr(*, "resolved")= logi FALSE
[17:45:20.370]  - attr(*, "total_size")= num 95128
[17:45:20.370]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:20.370]  - attr(*, "already-done")= logi TRUE
[17:45:20.383] - copied ‘...future.FUN’ to environment
[17:45:20.384] - copied ‘x_FUN’ to environment
[17:45:20.384] - copied ‘times’ to environment
[17:45:20.384] - copied ‘stopf’ to environment
[17:45:20.384] - copied ‘stop_if_not’ to environment
[17:45:20.384] - copied ‘dim’ to environment
[17:45:20.384] - copied ‘valid_types’ to environment
[17:45:20.384] - copied ‘future.call.arguments’ to environment
[17:45:20.385] - copied ‘...future.elements_ii’ to environment
[17:45:20.385] - copied ‘...future.seeds_ii’ to environment
[17:45:20.385] - copied ‘...future.globals.maxSize’ to environment
[17:45:20.385] assign_globals() ... done
[17:45:20.385] requestCore(): workers = 2
[17:45:20.388] MulticoreFuture started
[17:45:20.388] - Launch lazy future ... done
[17:45:20.389] run() for ‘MulticoreFuture’ ... done
[17:45:20.390] Created future:
[17:45:20.390] plan(): Setting new future strategy stack:
[17:45:20.390] List of future strategies:
[17:45:20.390] 1. sequential:
[17:45:20.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.390]    - tweaked: FALSE
[17:45:20.390]    - call: NULL
[17:45:20.391] plan(): nbrOfWorkers() = 1
[17:45:20.394] plan(): Setting new future strategy stack:
[17:45:20.394] List of future strategies:
[17:45:20.394] 1. multicore:
[17:45:20.394]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[17:45:20.394]    - tweaked: FALSE
[17:45:20.394]    - call: plan(strategy)
[17:45:20.399] plan(): nbrOfWorkers() = 2
[17:45:20.390] MulticoreFuture:
[17:45:20.390] Label: ‘future_vapply-2’
[17:45:20.390] Expression:
[17:45:20.390] {
[17:45:20.390]     do.call(function(...) {
[17:45:20.390]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:20.390]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:20.390]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:20.390]             on.exit(options(oopts), add = TRUE)
[17:45:20.390]         }
[17:45:20.390]         {
[17:45:20.390]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:20.390]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:20.390]                 ...future.FUN(...future.X_jj, ...)
[17:45:20.390]             })
[17:45:20.390]         }
[17:45:20.390]     }, args = future.call.arguments)
[17:45:20.390] }
[17:45:20.390] Lazy evaluation: FALSE
[17:45:20.390] Asynchronous evaluation: TRUE
[17:45:20.390] Local evaluation: TRUE
[17:45:20.390] Environment: R_GlobalEnv
[17:45:20.390] Capture standard output: TRUE
[17:45:20.390] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:20.390] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:20.390] Packages: 1 packages (‘future.apply’)
[17:45:20.390] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:20.390] Resolved: FALSE
[17:45:20.390] Value: <not collected>
[17:45:20.390] Conditions captured: <none>
[17:45:20.390] Early signaling: FALSE
[17:45:20.390] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:20.390] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:20.403] Chunk #2 of 2 ... DONE
[17:45:20.403] Launching 2 futures (chunks) ... DONE
[17:45:20.404] Resolving 2 futures (chunks) ...
[17:45:20.404] resolve() on list ...
[17:45:20.404]  recursive: 0
[17:45:20.404]  length: 2
[17:45:20.404] 
[17:45:20.405] Future #1
[17:45:20.405] result() for MulticoreFuture ...
[17:45:20.411] result() for MulticoreFuture ...
[17:45:20.412] result() for MulticoreFuture ... done
[17:45:20.412] signalConditions() ...
[17:45:20.412]  - include = ‘immediateCondition’
[17:45:20.412]  - exclude = 
[17:45:20.412]  - resignal = FALSE
[17:45:20.412]  - Number of conditions: 1
[17:45:20.412] signalConditions() ... done
[17:45:20.413] result() for MulticoreFuture ... done
[17:45:20.413] result() for MulticoreFuture ...
[17:45:20.413] result() for MulticoreFuture ... done
[17:45:20.413] signalConditions() ...
[17:45:20.413]  - include = ‘immediateCondition’
[17:45:20.413]  - exclude = 
[17:45:20.413]  - resignal = FALSE
[17:45:20.414]  - Number of conditions: 1
[17:45:20.414] signalConditions() ... done
[17:45:20.414] signalConditionsASAP(MulticoreFuture, pos=1) ...
[17:45:20.414] - nx: 2
[17:45:20.414] - relay: TRUE
[17:45:20.414] - stdout: TRUE
[17:45:20.414] - signal: TRUE
[17:45:20.415] - resignal: FALSE
[17:45:20.415] - force: TRUE
[17:45:20.415] - relayed: [n=2] FALSE, FALSE
[17:45:20.415] - queued futures: [n=2] FALSE, FALSE
[17:45:20.415]  - until=1
[17:45:20.415]  - relaying element #1
[17:45:20.415] result() for MulticoreFuture ...
[17:45:20.416] result() for MulticoreFuture ... done
[17:45:20.416] result() for MulticoreFuture ...
[17:45:20.416] result() for MulticoreFuture ... done
[17:45:20.416] signalConditions() ...
[17:45:20.416]  - include = ‘immediateCondition’
[17:45:20.416]  - exclude = 
[17:45:20.416]  - resignal = FALSE
[17:45:20.417]  - Number of conditions: 1
[17:45:20.417] signalConditions() ... done
[17:45:20.417] result() for MulticoreFuture ...
[17:45:20.417] result() for MulticoreFuture ... done
[17:45:20.417] signalConditions() ...
[17:45:20.417]  - include = ‘immediateCondition’
[17:45:20.417]  - exclude = 
[17:45:20.418]  - resignal = FALSE
[17:45:20.418]  - Number of conditions: 1
[17:45:20.418] signalConditions() ... done
[17:45:20.418] result() for MulticoreFuture ...
[17:45:20.418] result() for MulticoreFuture ... done
[17:45:20.418] signalConditions() ...
[17:45:20.418]  - include = ‘condition’
[17:45:20.418]  - exclude = ‘immediateCondition’
[17:45:20.419]  - resignal = TRUE
[17:45:20.419]  - Number of conditions: 1
[17:45:20.419]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:45:20.419] signalConditions() ... done
[17:45:20.422] - relayed: [n=2] FALSE, FALSE
[17:45:20.423] - queued futures: [n=2] TRUE, FALSE
[17:45:20.423] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[17:45:20.423] plan(): Setting new future strategy stack:
[17:45:20.424] List of future strategies:
[17:45:20.424] 1. sequential:
[17:45:20.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:20.424]    - tweaked: FALSE
[17:45:20.424]    - call: plan(sequential)
[17:45:20.425] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[17:45:20.425] plan(): Setting new future strategy stack:
[17:45:20.425] List of future strategies:
[17:45:20.425] 1. multisession:
[17:45:20.425]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:20.425]    - tweaked: FALSE
[17:45:20.425]    - call: plan(strategy)
[17:45:20.426] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[17:45:20.426] multisession:
[17:45:20.426] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[17:45:20.426] - tweaked: FALSE
[17:45:20.426] - call: plan(strategy)
[17:45:20.434] getGlobalsAndPackages() ...
[17:45:20.434] Not searching for globals
[17:45:20.434] - globals: [0] <none>
[17:45:20.434] getGlobalsAndPackages() ... DONE
[17:45:20.435] [local output] makeClusterPSOCK() ...
[17:45:20.490] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[17:45:20.492] [local output] Base port: 11945
[17:45:20.492] [local output] Getting setup options for 2 cluster nodes ...
[17:45:20.492] [local output]  - Node 1 of 2 ...
[17:45:20.493] [local output] localMachine=TRUE => revtunnel=FALSE

[17:45:20.493] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmphtewk5/worker.rank=1.parallelly.parent=36649.8f2969f06c05.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmphtewk5/worker.rank=1.parallelly.parent=36649.8f2969f06c05.pid")'’
[17:45:20.680] - Possible to infer worker's PID: TRUE
[17:45:20.681] [local output] Rscript port: 11945

[17:45:20.681] [local output]  - Node 2 of 2 ...
[17:45:20.682] [local output] localMachine=TRUE => revtunnel=FALSE

[17:45:20.682] [local output] Rscript port: 11945

[17:45:20.682] [local output] Getting setup options for 2 cluster nodes ... done
[17:45:20.683] [local output]  - Parallel setup requested for some PSOCK nodes
[17:45:20.683] [local output] Setting up PSOCK nodes in parallel
[17:45:20.683] List of 36
[17:45:20.683]  $ worker          : chr "localhost"
[17:45:20.683]   ..- attr(*, "localhost")= logi TRUE
[17:45:20.683]  $ master          : chr "localhost"
[17:45:20.683]  $ port            : int 11945
[17:45:20.683]  $ connectTimeout  : num 120
[17:45:20.683]  $ timeout         : num 2592000
[17:45:20.683]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[17:45:20.683]  $ homogeneous     : logi TRUE
[17:45:20.683]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[17:45:20.683]  $ rscript_envs    : NULL
[17:45:20.683]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:45:20.683]  $ rscript_startup : NULL
[17:45:20.683]  $ rscript_sh      : chr "sh"
[17:45:20.683]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:45:20.683]  $ methods         : logi TRUE
[17:45:20.683]  $ socketOptions   : chr "no-delay"
[17:45:20.683]  $ useXDR          : logi FALSE
[17:45:20.683]  $ outfile         : chr "/dev/null"
[17:45:20.683]  $ renice          : int NA
[17:45:20.683]  $ rshcmd          : NULL
[17:45:20.683]  $ user            : chr(0) 
[17:45:20.683]  $ revtunnel       : logi FALSE
[17:45:20.683]  $ rshlogfile      : NULL
[17:45:20.683]  $ rshopts         : chr(0) 
[17:45:20.683]  $ rank            : int 1
[17:45:20.683]  $ manual          : logi FALSE
[17:45:20.683]  $ dryrun          : logi FALSE
[17:45:20.683]  $ quiet           : logi FALSE
[17:45:20.683]  $ setup_strategy  : chr "parallel"
[17:45:20.683]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:45:20.683]  $ pidfile         : chr "/tmp/Rtmphtewk5/worker.rank=1.parallelly.parent=36649.8f2969f06c05.pid"
[17:45:20.683]  $ rshcmd_label    : NULL
[17:45:20.683]  $ rsh_call        : NULL
[17:45:20.683]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[17:45:20.683]  $ localMachine    : logi TRUE
[17:45:20.683]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[17:45:20.683]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[17:45:20.683]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[17:45:20.683]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[17:45:20.683]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[17:45:20.683]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[17:45:20.683]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[17:45:20.683]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[17:45:20.683]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[17:45:20.683]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[17:45:20.683]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[17:45:20.683]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[17:45:20.683]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[17:45:20.683]  $ arguments       :List of 28
[17:45:20.683]   ..$ worker          : chr "localhost"
[17:45:20.683]   ..$ master          : NULL
[17:45:20.683]   ..$ port            : int 11945
[17:45:20.683]   ..$ connectTimeout  : num 120
[17:45:20.683]   ..$ timeout         : num 2592000
[17:45:20.683]   ..$ rscript         : NULL
[17:45:20.683]   ..$ homogeneous     : NULL
[17:45:20.683]   ..$ rscript_args    : NULL
[17:45:20.683]   ..$ rscript_envs    : NULL
[17:45:20.683]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[17:45:20.683]   ..$ rscript_startup : NULL
[17:45:20.683]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[17:45:20.683]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[17:45:20.683]   ..$ methods         : logi TRUE
[17:45:20.683]   ..$ socketOptions   : chr "no-delay"
[17:45:20.683]   ..$ useXDR          : logi FALSE
[17:45:20.683]   ..$ outfile         : chr "/dev/null"
[17:45:20.683]   ..$ renice          : int NA
[17:45:20.683]   ..$ rshcmd          : NULL
[17:45:20.683]   ..$ user            : NULL
[17:45:20.683]   ..$ revtunnel       : logi NA
[17:45:20.683]   ..$ rshlogfile      : NULL
[17:45:20.683]   ..$ rshopts         : NULL
[17:45:20.683]   ..$ rank            : int 1
[17:45:20.683]   ..$ manual          : logi FALSE
[17:45:20.683]   ..$ dryrun          : logi FALSE
[17:45:20.683]   ..$ quiet           : logi FALSE
[17:45:20.683]   ..$ setup_strategy  : chr "parallel"
[17:45:20.683]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[17:45:20.701] [local output] System call to launch all workers:
[17:45:20.701] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmphtewk5/worker.rank=1.parallelly.parent=36649.8f2969f06c05.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11945 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[17:45:20.701] [local output] Starting PSOCK main server
[17:45:20.707] [local output] Workers launched
[17:45:20.707] [local output] Waiting for workers to connect back
[17:45:20.708]  - [local output] 0 workers out of 2 ready
[17:45:20.959]  - [local output] 0 workers out of 2 ready
[17:45:20.959]  - [local output] 1 workers out of 2 ready
[17:45:20.973]  - [local output] 1 workers out of 2 ready
[17:45:20.974]  - [local output] 2 workers out of 2 ready
[17:45:20.974] [local output] Launching of workers completed
[17:45:20.974] [local output] Collecting session information from workers
[17:45:20.975] [local output]  - Worker #1 of 2
[17:45:20.976] [local output]  - Worker #2 of 2
[17:45:20.976] [local output] makeClusterPSOCK() ... done
[17:45:20.988] Packages needed by the future expression (n = 0): <none>
[17:45:20.988] Packages needed by future strategies (n = 0): <none>
[17:45:20.988] {
[17:45:20.988]     {
[17:45:20.988]         {
[17:45:20.988]             ...future.startTime <- base::Sys.time()
[17:45:20.988]             {
[17:45:20.988]                 {
[17:45:20.988]                   {
[17:45:20.988]                     {
[17:45:20.988]                       base::local({
[17:45:20.988]                         has_future <- base::requireNamespace("future", 
[17:45:20.988]                           quietly = TRUE)
[17:45:20.988]                         if (has_future) {
[17:45:20.988]                           ns <- base::getNamespace("future")
[17:45:20.988]                           version <- ns[[".package"]][["version"]]
[17:45:20.988]                           if (is.null(version)) 
[17:45:20.988]                             version <- utils::packageVersion("future")
[17:45:20.988]                         }
[17:45:20.988]                         else {
[17:45:20.988]                           version <- NULL
[17:45:20.988]                         }
[17:45:20.988]                         if (!has_future || version < "1.8.0") {
[17:45:20.988]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:20.988]                             "", base::R.version$version.string), 
[17:45:20.988]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:20.988]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:20.988]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:20.988]                               "release", "version")], collapse = " "), 
[17:45:20.988]                             hostname = base::Sys.info()[["nodename"]])
[17:45:20.988]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:20.988]                             info)
[17:45:20.988]                           info <- base::paste(info, collapse = "; ")
[17:45:20.988]                           if (!has_future) {
[17:45:20.988]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:20.988]                               info)
[17:45:20.988]                           }
[17:45:20.988]                           else {
[17:45:20.988]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:20.988]                               info, version)
[17:45:20.988]                           }
[17:45:20.988]                           base::stop(msg)
[17:45:20.988]                         }
[17:45:20.988]                       })
[17:45:20.988]                     }
[17:45:20.988]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:20.988]                     base::options(mc.cores = 1L)
[17:45:20.988]                   }
[17:45:20.988]                   ...future.strategy.old <- future::plan("list")
[17:45:20.988]                   options(future.plan = NULL)
[17:45:20.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:20.988]                 }
[17:45:20.988]                 ...future.workdir <- getwd()
[17:45:20.988]             }
[17:45:20.988]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:20.988]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:20.988]         }
[17:45:20.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:20.988]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[17:45:20.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:20.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:20.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:20.988]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:20.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:20.988]             base::names(...future.oldOptions))
[17:45:20.988]     }
[17:45:20.988]     if (FALSE) {
[17:45:20.988]     }
[17:45:20.988]     else {
[17:45:20.988]         if (TRUE) {
[17:45:20.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:20.988]                 open = "w")
[17:45:20.988]         }
[17:45:20.988]         else {
[17:45:20.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:20.988]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:20.988]         }
[17:45:20.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:20.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:20.988]             base::sink(type = "output", split = FALSE)
[17:45:20.988]             base::close(...future.stdout)
[17:45:20.988]         }, add = TRUE)
[17:45:20.988]     }
[17:45:20.988]     ...future.frame <- base::sys.nframe()
[17:45:20.988]     ...future.conditions <- base::list()
[17:45:20.988]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:20.988]     if (FALSE) {
[17:45:20.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:20.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:20.988]     }
[17:45:20.988]     ...future.result <- base::tryCatch({
[17:45:20.988]         base::withCallingHandlers({
[17:45:20.988]             ...future.value <- base::withVisible(base::local({
[17:45:20.988]                 ...future.makeSendCondition <- base::local({
[17:45:20.988]                   sendCondition <- NULL
[17:45:20.988]                   function(frame = 1L) {
[17:45:20.988]                     if (is.function(sendCondition)) 
[17:45:20.988]                       return(sendCondition)
[17:45:20.988]                     ns <- getNamespace("parallel")
[17:45:20.988]                     if (exists("sendData", mode = "function", 
[17:45:20.988]                       envir = ns)) {
[17:45:20.988]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:20.988]                         envir = ns)
[17:45:20.988]                       envir <- sys.frame(frame)
[17:45:20.988]                       master <- NULL
[17:45:20.988]                       while (!identical(envir, .GlobalEnv) && 
[17:45:20.988]                         !identical(envir, emptyenv())) {
[17:45:20.988]                         if (exists("master", mode = "list", envir = envir, 
[17:45:20.988]                           inherits = FALSE)) {
[17:45:20.988]                           master <- get("master", mode = "list", 
[17:45:20.988]                             envir = envir, inherits = FALSE)
[17:45:20.988]                           if (inherits(master, c("SOCKnode", 
[17:45:20.988]                             "SOCK0node"))) {
[17:45:20.988]                             sendCondition <<- function(cond) {
[17:45:20.988]                               data <- list(type = "VALUE", value = cond, 
[17:45:20.988]                                 success = TRUE)
[17:45:20.988]                               parallel_sendData(master, data)
[17:45:20.988]                             }
[17:45:20.988]                             return(sendCondition)
[17:45:20.988]                           }
[17:45:20.988]                         }
[17:45:20.988]                         frame <- frame + 1L
[17:45:20.988]                         envir <- sys.frame(frame)
[17:45:20.988]                       }
[17:45:20.988]                     }
[17:45:20.988]                     sendCondition <<- function(cond) NULL
[17:45:20.988]                   }
[17:45:20.988]                 })
[17:45:20.988]                 withCallingHandlers({
[17:45:20.988]                   NA
[17:45:20.988]                 }, immediateCondition = function(cond) {
[17:45:20.988]                   sendCondition <- ...future.makeSendCondition()
[17:45:20.988]                   sendCondition(cond)
[17:45:20.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.988]                   {
[17:45:20.988]                     inherits <- base::inherits
[17:45:20.988]                     invokeRestart <- base::invokeRestart
[17:45:20.988]                     is.null <- base::is.null
[17:45:20.988]                     muffled <- FALSE
[17:45:20.988]                     if (inherits(cond, "message")) {
[17:45:20.988]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:20.988]                       if (muffled) 
[17:45:20.988]                         invokeRestart("muffleMessage")
[17:45:20.988]                     }
[17:45:20.988]                     else if (inherits(cond, "warning")) {
[17:45:20.988]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:20.988]                       if (muffled) 
[17:45:20.988]                         invokeRestart("muffleWarning")
[17:45:20.988]                     }
[17:45:20.988]                     else if (inherits(cond, "condition")) {
[17:45:20.988]                       if (!is.null(pattern)) {
[17:45:20.988]                         computeRestarts <- base::computeRestarts
[17:45:20.988]                         grepl <- base::grepl
[17:45:20.988]                         restarts <- computeRestarts(cond)
[17:45:20.988]                         for (restart in restarts) {
[17:45:20.988]                           name <- restart$name
[17:45:20.988]                           if (is.null(name)) 
[17:45:20.988]                             next
[17:45:20.988]                           if (!grepl(pattern, name)) 
[17:45:20.988]                             next
[17:45:20.988]                           invokeRestart(restart)
[17:45:20.988]                           muffled <- TRUE
[17:45:20.988]                           break
[17:45:20.988]                         }
[17:45:20.988]                       }
[17:45:20.988]                     }
[17:45:20.988]                     invisible(muffled)
[17:45:20.988]                   }
[17:45:20.988]                   muffleCondition(cond)
[17:45:20.988]                 })
[17:45:20.988]             }))
[17:45:20.988]             future::FutureResult(value = ...future.value$value, 
[17:45:20.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.988]                   ...future.rng), globalenv = if (FALSE) 
[17:45:20.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:20.988]                     ...future.globalenv.names))
[17:45:20.988]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:20.988]         }, condition = base::local({
[17:45:20.988]             c <- base::c
[17:45:20.988]             inherits <- base::inherits
[17:45:20.988]             invokeRestart <- base::invokeRestart
[17:45:20.988]             length <- base::length
[17:45:20.988]             list <- base::list
[17:45:20.988]             seq.int <- base::seq.int
[17:45:20.988]             signalCondition <- base::signalCondition
[17:45:20.988]             sys.calls <- base::sys.calls
[17:45:20.988]             `[[` <- base::`[[`
[17:45:20.988]             `+` <- base::`+`
[17:45:20.988]             `<<-` <- base::`<<-`
[17:45:20.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:20.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:20.988]                   3L)]
[17:45:20.988]             }
[17:45:20.988]             function(cond) {
[17:45:20.988]                 is_error <- inherits(cond, "error")
[17:45:20.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:20.988]                   NULL)
[17:45:20.988]                 if (is_error) {
[17:45:20.988]                   sessionInformation <- function() {
[17:45:20.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:20.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:20.988]                       search = base::search(), system = base::Sys.info())
[17:45:20.988]                   }
[17:45:20.988]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:20.988]                     cond$call), session = sessionInformation(), 
[17:45:20.988]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:20.988]                   signalCondition(cond)
[17:45:20.988]                 }
[17:45:20.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:20.988]                 "immediateCondition"))) {
[17:45:20.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:20.988]                   ...future.conditions[[length(...future.conditions) + 
[17:45:20.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:20.988]                   if (TRUE && !signal) {
[17:45:20.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.988]                     {
[17:45:20.988]                       inherits <- base::inherits
[17:45:20.988]                       invokeRestart <- base::invokeRestart
[17:45:20.988]                       is.null <- base::is.null
[17:45:20.988]                       muffled <- FALSE
[17:45:20.988]                       if (inherits(cond, "message")) {
[17:45:20.988]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.988]                         if (muffled) 
[17:45:20.988]                           invokeRestart("muffleMessage")
[17:45:20.988]                       }
[17:45:20.988]                       else if (inherits(cond, "warning")) {
[17:45:20.988]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.988]                         if (muffled) 
[17:45:20.988]                           invokeRestart("muffleWarning")
[17:45:20.988]                       }
[17:45:20.988]                       else if (inherits(cond, "condition")) {
[17:45:20.988]                         if (!is.null(pattern)) {
[17:45:20.988]                           computeRestarts <- base::computeRestarts
[17:45:20.988]                           grepl <- base::grepl
[17:45:20.988]                           restarts <- computeRestarts(cond)
[17:45:20.988]                           for (restart in restarts) {
[17:45:20.988]                             name <- restart$name
[17:45:20.988]                             if (is.null(name)) 
[17:45:20.988]                               next
[17:45:20.988]                             if (!grepl(pattern, name)) 
[17:45:20.988]                               next
[17:45:20.988]                             invokeRestart(restart)
[17:45:20.988]                             muffled <- TRUE
[17:45:20.988]                             break
[17:45:20.988]                           }
[17:45:20.988]                         }
[17:45:20.988]                       }
[17:45:20.988]                       invisible(muffled)
[17:45:20.988]                     }
[17:45:20.988]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.988]                   }
[17:45:20.988]                 }
[17:45:20.988]                 else {
[17:45:20.988]                   if (TRUE) {
[17:45:20.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:20.988]                     {
[17:45:20.988]                       inherits <- base::inherits
[17:45:20.988]                       invokeRestart <- base::invokeRestart
[17:45:20.988]                       is.null <- base::is.null
[17:45:20.988]                       muffled <- FALSE
[17:45:20.988]                       if (inherits(cond, "message")) {
[17:45:20.988]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:20.988]                         if (muffled) 
[17:45:20.988]                           invokeRestart("muffleMessage")
[17:45:20.988]                       }
[17:45:20.988]                       else if (inherits(cond, "warning")) {
[17:45:20.988]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:20.988]                         if (muffled) 
[17:45:20.988]                           invokeRestart("muffleWarning")
[17:45:20.988]                       }
[17:45:20.988]                       else if (inherits(cond, "condition")) {
[17:45:20.988]                         if (!is.null(pattern)) {
[17:45:20.988]                           computeRestarts <- base::computeRestarts
[17:45:20.988]                           grepl <- base::grepl
[17:45:20.988]                           restarts <- computeRestarts(cond)
[17:45:20.988]                           for (restart in restarts) {
[17:45:20.988]                             name <- restart$name
[17:45:20.988]                             if (is.null(name)) 
[17:45:20.988]                               next
[17:45:20.988]                             if (!grepl(pattern, name)) 
[17:45:20.988]                               next
[17:45:20.988]                             invokeRestart(restart)
[17:45:20.988]                             muffled <- TRUE
[17:45:20.988]                             break
[17:45:20.988]                           }
[17:45:20.988]                         }
[17:45:20.988]                       }
[17:45:20.988]                       invisible(muffled)
[17:45:20.988]                     }
[17:45:20.988]                     muffleCondition(cond, pattern = "^muffle")
[17:45:20.988]                   }
[17:45:20.988]                 }
[17:45:20.988]             }
[17:45:20.988]         }))
[17:45:20.988]     }, error = function(ex) {
[17:45:20.988]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:20.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:20.988]                 ...future.rng), started = ...future.startTime, 
[17:45:20.988]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:20.988]             version = "1.8"), class = "FutureResult")
[17:45:20.988]     }, finally = {
[17:45:20.988]         if (!identical(...future.workdir, getwd())) 
[17:45:20.988]             setwd(...future.workdir)
[17:45:20.988]         {
[17:45:20.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:20.988]                 ...future.oldOptions$nwarnings <- NULL
[17:45:20.988]             }
[17:45:20.988]             base::options(...future.oldOptions)
[17:45:20.988]             if (.Platform$OS.type == "windows") {
[17:45:20.988]                 old_names <- names(...future.oldEnvVars)
[17:45:20.988]                 envs <- base::Sys.getenv()
[17:45:20.988]                 names <- names(envs)
[17:45:20.988]                 common <- intersect(names, old_names)
[17:45:20.988]                 added <- setdiff(names, old_names)
[17:45:20.988]                 removed <- setdiff(old_names, names)
[17:45:20.988]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:20.988]                   envs[common]]
[17:45:20.988]                 NAMES <- toupper(changed)
[17:45:20.988]                 args <- list()
[17:45:20.988]                 for (kk in seq_along(NAMES)) {
[17:45:20.988]                   name <- changed[[kk]]
[17:45:20.988]                   NAME <- NAMES[[kk]]
[17:45:20.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.988]                     next
[17:45:20.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.988]                 }
[17:45:20.988]                 NAMES <- toupper(added)
[17:45:20.988]                 for (kk in seq_along(NAMES)) {
[17:45:20.988]                   name <- added[[kk]]
[17:45:20.988]                   NAME <- NAMES[[kk]]
[17:45:20.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.988]                     next
[17:45:20.988]                   args[[name]] <- ""
[17:45:20.988]                 }
[17:45:20.988]                 NAMES <- toupper(removed)
[17:45:20.988]                 for (kk in seq_along(NAMES)) {
[17:45:20.988]                   name <- removed[[kk]]
[17:45:20.988]                   NAME <- NAMES[[kk]]
[17:45:20.988]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:20.988]                     next
[17:45:20.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:20.988]                 }
[17:45:20.988]                 if (length(args) > 0) 
[17:45:20.988]                   base::do.call(base::Sys.setenv, args = args)
[17:45:20.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:20.988]             }
[17:45:20.988]             else {
[17:45:20.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:20.988]             }
[17:45:20.988]             {
[17:45:20.988]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:20.988]                   0L) {
[17:45:20.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:20.988]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:20.988]                   base::options(opts)
[17:45:20.988]                 }
[17:45:20.988]                 {
[17:45:20.988]                   {
[17:45:20.988]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:20.988]                     NULL
[17:45:20.988]                   }
[17:45:20.988]                   options(future.plan = NULL)
[17:45:20.988]                   if (is.na(NA_character_)) 
[17:45:20.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:20.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:20.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:20.988]                     .init = FALSE)
[17:45:20.988]                 }
[17:45:20.988]             }
[17:45:20.988]         }
[17:45:20.988]     })
[17:45:20.988]     if (TRUE) {
[17:45:20.988]         base::sink(type = "output", split = FALSE)
[17:45:20.988]         if (TRUE) {
[17:45:20.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:20.988]         }
[17:45:20.988]         else {
[17:45:20.988]             ...future.result["stdout"] <- base::list(NULL)
[17:45:20.988]         }
[17:45:20.988]         base::close(...future.stdout)
[17:45:20.988]         ...future.stdout <- NULL
[17:45:20.988]     }
[17:45:20.988]     ...future.result$conditions <- ...future.conditions
[17:45:20.988]     ...future.result$finished <- base::Sys.time()
[17:45:20.988]     ...future.result
[17:45:20.988] }
[17:45:21.041] MultisessionFuture started
[17:45:21.041] result() for ClusterFuture ...
[17:45:21.042] receiveMessageFromWorker() for ClusterFuture ...
[17:45:21.042] - Validating connection of MultisessionFuture
[17:45:21.074] - received message: FutureResult
[17:45:21.074] - Received FutureResult
[17:45:21.074] - Erased future from FutureRegistry
[17:45:21.074] result() for ClusterFuture ...
[17:45:21.074] - result already collected: FutureResult
[17:45:21.075] result() for ClusterFuture ... done
[17:45:21.075] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:21.075] result() for ClusterFuture ... done
[17:45:21.075] result() for ClusterFuture ...
[17:45:21.075] - result already collected: FutureResult
[17:45:21.075] result() for ClusterFuture ... done
[17:45:21.075] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[17:45:21.080] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[17:45:21.083] future_lapply() ...
[17:45:21.089] Number of chunks: 2
[17:45:21.089] getGlobalsAndPackagesXApply() ...
[17:45:21.089]  - future.globals: TRUE
[17:45:21.089] getGlobalsAndPackages() ...
[17:45:21.089] Searching for globals...
[17:45:21.093] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:21.093] Searching for globals ... DONE
[17:45:21.093] Resolving globals: FALSE
[17:45:21.094] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[17:45:21.095] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:21.095] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:21.095] - packages: [1] ‘future.apply’
[17:45:21.095] getGlobalsAndPackages() ... DONE
[17:45:21.095]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:21.095]  - needed namespaces: [n=1] ‘future.apply’
[17:45:21.095] Finding globals ... DONE
[17:45:21.096]  - use_args: TRUE
[17:45:21.096]  - Getting '...' globals ...
[17:45:21.096] resolve() on list ...
[17:45:21.096]  recursive: 0
[17:45:21.096]  length: 1
[17:45:21.096]  elements: ‘...’
[17:45:21.097]  length: 0 (resolved future 1)
[17:45:21.097] resolve() on list ... DONE
[17:45:21.097]    - '...' content: [n=0] 
[17:45:21.097] List of 1
[17:45:21.097]  $ ...: list()
[17:45:21.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:21.097]  - attr(*, "where")=List of 1
[17:45:21.097]   ..$ ...:<environment: 0x5561f6c9cfa0> 
[17:45:21.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:21.097]  - attr(*, "resolved")= logi TRUE
[17:45:21.097]  - attr(*, "total_size")= num NA
[17:45:21.100]  - Getting '...' globals ... DONE
[17:45:21.100] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:21.100] List of 8
[17:45:21.100]  $ ...future.FUN:function (x, ...)  
[17:45:21.100]  $ x_FUN        :function (x)  
[17:45:21.100]  $ times        : int 1
[17:45:21.100]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:21.100]  $ stop_if_not  :function (...)  
[17:45:21.100]  $ dim          : NULL
[17:45:21.100]  $ valid_types  : chr "character"
[17:45:21.100]  $ ...          : list()
[17:45:21.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:21.100]  - attr(*, "where")=List of 8
[17:45:21.100]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:21.100]   ..$ ...          :<environment: 0x5561f6c9cfa0> 
[17:45:21.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:21.100]  - attr(*, "resolved")= logi FALSE
[17:45:21.100]  - attr(*, "total_size")= num 94208
[17:45:21.107] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:21.107] getGlobalsAndPackagesXApply() ... DONE
[17:45:21.107] Number of futures (= number of chunks): 2
[17:45:21.107] Launching 2 futures (chunks) ...
[17:45:21.107] Chunk #1 of 2 ...
[17:45:21.108]  - Finding globals in 'X' for chunk #1 ...
[17:45:21.108] getGlobalsAndPackages() ...
[17:45:21.108] Searching for globals...
[17:45:21.108] 
[17:45:21.108] Searching for globals ... DONE
[17:45:21.108] - globals: [0] <none>
[17:45:21.109] getGlobalsAndPackages() ... DONE
[17:45:21.109]    + additional globals found: [n=0] 
[17:45:21.109]    + additional namespaces needed: [n=0] 
[17:45:21.109]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:21.109]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:21.109]  - seeds: <none>
[17:45:21.109]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.109] getGlobalsAndPackages() ...
[17:45:21.109] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.110] Resolving globals: FALSE
[17:45:21.110] Tweak future expression to call with '...' arguments ...
[17:45:21.110] {
[17:45:21.110]     do.call(function(...) {
[17:45:21.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.110]             on.exit(options(oopts), add = TRUE)
[17:45:21.110]         }
[17:45:21.110]         {
[17:45:21.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.110]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.110]             })
[17:45:21.110]         }
[17:45:21.110]     }, args = future.call.arguments)
[17:45:21.110] }
[17:45:21.110] Tweak future expression to call with '...' arguments ... DONE
[17:45:21.111] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.111] - packages: [1] ‘future.apply’
[17:45:21.111] getGlobalsAndPackages() ... DONE
[17:45:21.111] run() for ‘Future’ ...
[17:45:21.112] - state: ‘created’
[17:45:21.112] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:21.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:21.126]   - Field: ‘node’
[17:45:21.127]   - Field: ‘label’
[17:45:21.127]   - Field: ‘local’
[17:45:21.127]   - Field: ‘owner’
[17:45:21.127]   - Field: ‘envir’
[17:45:21.127]   - Field: ‘workers’
[17:45:21.127]   - Field: ‘packages’
[17:45:21.127]   - Field: ‘gc’
[17:45:21.127]   - Field: ‘conditions’
[17:45:21.127]   - Field: ‘persistent’
[17:45:21.127]   - Field: ‘expr’
[17:45:21.128]   - Field: ‘uuid’
[17:45:21.128]   - Field: ‘seed’
[17:45:21.128]   - Field: ‘version’
[17:45:21.128]   - Field: ‘result’
[17:45:21.128]   - Field: ‘asynchronous’
[17:45:21.128]   - Field: ‘calls’
[17:45:21.128]   - Field: ‘globals’
[17:45:21.128]   - Field: ‘stdout’
[17:45:21.128]   - Field: ‘earlySignal’
[17:45:21.129]   - Field: ‘lazy’
[17:45:21.129]   - Field: ‘state’
[17:45:21.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:21.129] - Launch lazy future ...
[17:45:21.129] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:21.129] Packages needed by future strategies (n = 0): <none>
[17:45:21.130] {
[17:45:21.130]     {
[17:45:21.130]         {
[17:45:21.130]             ...future.startTime <- base::Sys.time()
[17:45:21.130]             {
[17:45:21.130]                 {
[17:45:21.130]                   {
[17:45:21.130]                     {
[17:45:21.130]                       {
[17:45:21.130]                         base::local({
[17:45:21.130]                           has_future <- base::requireNamespace("future", 
[17:45:21.130]                             quietly = TRUE)
[17:45:21.130]                           if (has_future) {
[17:45:21.130]                             ns <- base::getNamespace("future")
[17:45:21.130]                             version <- ns[[".package"]][["version"]]
[17:45:21.130]                             if (is.null(version)) 
[17:45:21.130]                               version <- utils::packageVersion("future")
[17:45:21.130]                           }
[17:45:21.130]                           else {
[17:45:21.130]                             version <- NULL
[17:45:21.130]                           }
[17:45:21.130]                           if (!has_future || version < "1.8.0") {
[17:45:21.130]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:21.130]                               "", base::R.version$version.string), 
[17:45:21.130]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:21.130]                                 base::R.version$platform, 8 * 
[17:45:21.130]                                   base::.Machine$sizeof.pointer), 
[17:45:21.130]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:21.130]                                 "release", "version")], collapse = " "), 
[17:45:21.130]                               hostname = base::Sys.info()[["nodename"]])
[17:45:21.130]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:21.130]                               info)
[17:45:21.130]                             info <- base::paste(info, collapse = "; ")
[17:45:21.130]                             if (!has_future) {
[17:45:21.130]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:21.130]                                 info)
[17:45:21.130]                             }
[17:45:21.130]                             else {
[17:45:21.130]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:21.130]                                 info, version)
[17:45:21.130]                             }
[17:45:21.130]                             base::stop(msg)
[17:45:21.130]                           }
[17:45:21.130]                         })
[17:45:21.130]                       }
[17:45:21.130]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:21.130]                       base::options(mc.cores = 1L)
[17:45:21.130]                     }
[17:45:21.130]                     base::local({
[17:45:21.130]                       for (pkg in "future.apply") {
[17:45:21.130]                         base::loadNamespace(pkg)
[17:45:21.130]                         base::library(pkg, character.only = TRUE)
[17:45:21.130]                       }
[17:45:21.130]                     })
[17:45:21.130]                   }
[17:45:21.130]                   ...future.strategy.old <- future::plan("list")
[17:45:21.130]                   options(future.plan = NULL)
[17:45:21.130]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.130]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:21.130]                 }
[17:45:21.130]                 ...future.workdir <- getwd()
[17:45:21.130]             }
[17:45:21.130]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:21.130]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:21.130]         }
[17:45:21.130]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:21.130]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:21.130]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:21.130]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:21.130]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:21.130]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:21.130]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:21.130]             base::names(...future.oldOptions))
[17:45:21.130]     }
[17:45:21.130]     if (FALSE) {
[17:45:21.130]     }
[17:45:21.130]     else {
[17:45:21.130]         if (TRUE) {
[17:45:21.130]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:21.130]                 open = "w")
[17:45:21.130]         }
[17:45:21.130]         else {
[17:45:21.130]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:21.130]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:21.130]         }
[17:45:21.130]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:21.130]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:21.130]             base::sink(type = "output", split = FALSE)
[17:45:21.130]             base::close(...future.stdout)
[17:45:21.130]         }, add = TRUE)
[17:45:21.130]     }
[17:45:21.130]     ...future.frame <- base::sys.nframe()
[17:45:21.130]     ...future.conditions <- base::list()
[17:45:21.130]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:21.130]     if (FALSE) {
[17:45:21.130]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:21.130]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:21.130]     }
[17:45:21.130]     ...future.result <- base::tryCatch({
[17:45:21.130]         base::withCallingHandlers({
[17:45:21.130]             ...future.value <- base::withVisible(base::local({
[17:45:21.130]                 ...future.makeSendCondition <- base::local({
[17:45:21.130]                   sendCondition <- NULL
[17:45:21.130]                   function(frame = 1L) {
[17:45:21.130]                     if (is.function(sendCondition)) 
[17:45:21.130]                       return(sendCondition)
[17:45:21.130]                     ns <- getNamespace("parallel")
[17:45:21.130]                     if (exists("sendData", mode = "function", 
[17:45:21.130]                       envir = ns)) {
[17:45:21.130]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:21.130]                         envir = ns)
[17:45:21.130]                       envir <- sys.frame(frame)
[17:45:21.130]                       master <- NULL
[17:45:21.130]                       while (!identical(envir, .GlobalEnv) && 
[17:45:21.130]                         !identical(envir, emptyenv())) {
[17:45:21.130]                         if (exists("master", mode = "list", envir = envir, 
[17:45:21.130]                           inherits = FALSE)) {
[17:45:21.130]                           master <- get("master", mode = "list", 
[17:45:21.130]                             envir = envir, inherits = FALSE)
[17:45:21.130]                           if (inherits(master, c("SOCKnode", 
[17:45:21.130]                             "SOCK0node"))) {
[17:45:21.130]                             sendCondition <<- function(cond) {
[17:45:21.130]                               data <- list(type = "VALUE", value = cond, 
[17:45:21.130]                                 success = TRUE)
[17:45:21.130]                               parallel_sendData(master, data)
[17:45:21.130]                             }
[17:45:21.130]                             return(sendCondition)
[17:45:21.130]                           }
[17:45:21.130]                         }
[17:45:21.130]                         frame <- frame + 1L
[17:45:21.130]                         envir <- sys.frame(frame)
[17:45:21.130]                       }
[17:45:21.130]                     }
[17:45:21.130]                     sendCondition <<- function(cond) NULL
[17:45:21.130]                   }
[17:45:21.130]                 })
[17:45:21.130]                 withCallingHandlers({
[17:45:21.130]                   {
[17:45:21.130]                     do.call(function(...) {
[17:45:21.130]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.130]                       if (!identical(...future.globals.maxSize.org, 
[17:45:21.130]                         ...future.globals.maxSize)) {
[17:45:21.130]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.130]                         on.exit(options(oopts), add = TRUE)
[17:45:21.130]                       }
[17:45:21.130]                       {
[17:45:21.130]                         lapply(seq_along(...future.elements_ii), 
[17:45:21.130]                           FUN = function(jj) {
[17:45:21.130]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.130]                             ...future.FUN(...future.X_jj, ...)
[17:45:21.130]                           })
[17:45:21.130]                       }
[17:45:21.130]                     }, args = future.call.arguments)
[17:45:21.130]                   }
[17:45:21.130]                 }, immediateCondition = function(cond) {
[17:45:21.130]                   sendCondition <- ...future.makeSendCondition()
[17:45:21.130]                   sendCondition(cond)
[17:45:21.130]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.130]                   {
[17:45:21.130]                     inherits <- base::inherits
[17:45:21.130]                     invokeRestart <- base::invokeRestart
[17:45:21.130]                     is.null <- base::is.null
[17:45:21.130]                     muffled <- FALSE
[17:45:21.130]                     if (inherits(cond, "message")) {
[17:45:21.130]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:21.130]                       if (muffled) 
[17:45:21.130]                         invokeRestart("muffleMessage")
[17:45:21.130]                     }
[17:45:21.130]                     else if (inherits(cond, "warning")) {
[17:45:21.130]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:21.130]                       if (muffled) 
[17:45:21.130]                         invokeRestart("muffleWarning")
[17:45:21.130]                     }
[17:45:21.130]                     else if (inherits(cond, "condition")) {
[17:45:21.130]                       if (!is.null(pattern)) {
[17:45:21.130]                         computeRestarts <- base::computeRestarts
[17:45:21.130]                         grepl <- base::grepl
[17:45:21.130]                         restarts <- computeRestarts(cond)
[17:45:21.130]                         for (restart in restarts) {
[17:45:21.130]                           name <- restart$name
[17:45:21.130]                           if (is.null(name)) 
[17:45:21.130]                             next
[17:45:21.130]                           if (!grepl(pattern, name)) 
[17:45:21.130]                             next
[17:45:21.130]                           invokeRestart(restart)
[17:45:21.130]                           muffled <- TRUE
[17:45:21.130]                           break
[17:45:21.130]                         }
[17:45:21.130]                       }
[17:45:21.130]                     }
[17:45:21.130]                     invisible(muffled)
[17:45:21.130]                   }
[17:45:21.130]                   muffleCondition(cond)
[17:45:21.130]                 })
[17:45:21.130]             }))
[17:45:21.130]             future::FutureResult(value = ...future.value$value, 
[17:45:21.130]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.130]                   ...future.rng), globalenv = if (FALSE) 
[17:45:21.130]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:21.130]                     ...future.globalenv.names))
[17:45:21.130]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:21.130]         }, condition = base::local({
[17:45:21.130]             c <- base::c
[17:45:21.130]             inherits <- base::inherits
[17:45:21.130]             invokeRestart <- base::invokeRestart
[17:45:21.130]             length <- base::length
[17:45:21.130]             list <- base::list
[17:45:21.130]             seq.int <- base::seq.int
[17:45:21.130]             signalCondition <- base::signalCondition
[17:45:21.130]             sys.calls <- base::sys.calls
[17:45:21.130]             `[[` <- base::`[[`
[17:45:21.130]             `+` <- base::`+`
[17:45:21.130]             `<<-` <- base::`<<-`
[17:45:21.130]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:21.130]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:21.130]                   3L)]
[17:45:21.130]             }
[17:45:21.130]             function(cond) {
[17:45:21.130]                 is_error <- inherits(cond, "error")
[17:45:21.130]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:21.130]                   NULL)
[17:45:21.130]                 if (is_error) {
[17:45:21.130]                   sessionInformation <- function() {
[17:45:21.130]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:21.130]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:21.130]                       search = base::search(), system = base::Sys.info())
[17:45:21.130]                   }
[17:45:21.130]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.130]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:21.130]                     cond$call), session = sessionInformation(), 
[17:45:21.130]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:21.130]                   signalCondition(cond)
[17:45:21.130]                 }
[17:45:21.130]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:21.130]                 "immediateCondition"))) {
[17:45:21.130]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:21.130]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.130]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:21.130]                   if (TRUE && !signal) {
[17:45:21.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.130]                     {
[17:45:21.130]                       inherits <- base::inherits
[17:45:21.130]                       invokeRestart <- base::invokeRestart
[17:45:21.130]                       is.null <- base::is.null
[17:45:21.130]                       muffled <- FALSE
[17:45:21.130]                       if (inherits(cond, "message")) {
[17:45:21.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.130]                         if (muffled) 
[17:45:21.130]                           invokeRestart("muffleMessage")
[17:45:21.130]                       }
[17:45:21.130]                       else if (inherits(cond, "warning")) {
[17:45:21.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.130]                         if (muffled) 
[17:45:21.130]                           invokeRestart("muffleWarning")
[17:45:21.130]                       }
[17:45:21.130]                       else if (inherits(cond, "condition")) {
[17:45:21.130]                         if (!is.null(pattern)) {
[17:45:21.130]                           computeRestarts <- base::computeRestarts
[17:45:21.130]                           grepl <- base::grepl
[17:45:21.130]                           restarts <- computeRestarts(cond)
[17:45:21.130]                           for (restart in restarts) {
[17:45:21.130]                             name <- restart$name
[17:45:21.130]                             if (is.null(name)) 
[17:45:21.130]                               next
[17:45:21.130]                             if (!grepl(pattern, name)) 
[17:45:21.130]                               next
[17:45:21.130]                             invokeRestart(restart)
[17:45:21.130]                             muffled <- TRUE
[17:45:21.130]                             break
[17:45:21.130]                           }
[17:45:21.130]                         }
[17:45:21.130]                       }
[17:45:21.130]                       invisible(muffled)
[17:45:21.130]                     }
[17:45:21.130]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.130]                   }
[17:45:21.130]                 }
[17:45:21.130]                 else {
[17:45:21.130]                   if (TRUE) {
[17:45:21.130]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.130]                     {
[17:45:21.130]                       inherits <- base::inherits
[17:45:21.130]                       invokeRestart <- base::invokeRestart
[17:45:21.130]                       is.null <- base::is.null
[17:45:21.130]                       muffled <- FALSE
[17:45:21.130]                       if (inherits(cond, "message")) {
[17:45:21.130]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.130]                         if (muffled) 
[17:45:21.130]                           invokeRestart("muffleMessage")
[17:45:21.130]                       }
[17:45:21.130]                       else if (inherits(cond, "warning")) {
[17:45:21.130]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.130]                         if (muffled) 
[17:45:21.130]                           invokeRestart("muffleWarning")
[17:45:21.130]                       }
[17:45:21.130]                       else if (inherits(cond, "condition")) {
[17:45:21.130]                         if (!is.null(pattern)) {
[17:45:21.130]                           computeRestarts <- base::computeRestarts
[17:45:21.130]                           grepl <- base::grepl
[17:45:21.130]                           restarts <- computeRestarts(cond)
[17:45:21.130]                           for (restart in restarts) {
[17:45:21.130]                             name <- restart$name
[17:45:21.130]                             if (is.null(name)) 
[17:45:21.130]                               next
[17:45:21.130]                             if (!grepl(pattern, name)) 
[17:45:21.130]                               next
[17:45:21.130]                             invokeRestart(restart)
[17:45:21.130]                             muffled <- TRUE
[17:45:21.130]                             break
[17:45:21.130]                           }
[17:45:21.130]                         }
[17:45:21.130]                       }
[17:45:21.130]                       invisible(muffled)
[17:45:21.130]                     }
[17:45:21.130]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.130]                   }
[17:45:21.130]                 }
[17:45:21.130]             }
[17:45:21.130]         }))
[17:45:21.130]     }, error = function(ex) {
[17:45:21.130]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:21.130]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.130]                 ...future.rng), started = ...future.startTime, 
[17:45:21.130]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:21.130]             version = "1.8"), class = "FutureResult")
[17:45:21.130]     }, finally = {
[17:45:21.130]         if (!identical(...future.workdir, getwd())) 
[17:45:21.130]             setwd(...future.workdir)
[17:45:21.130]         {
[17:45:21.130]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:21.130]                 ...future.oldOptions$nwarnings <- NULL
[17:45:21.130]             }
[17:45:21.130]             base::options(...future.oldOptions)
[17:45:21.130]             if (.Platform$OS.type == "windows") {
[17:45:21.130]                 old_names <- names(...future.oldEnvVars)
[17:45:21.130]                 envs <- base::Sys.getenv()
[17:45:21.130]                 names <- names(envs)
[17:45:21.130]                 common <- intersect(names, old_names)
[17:45:21.130]                 added <- setdiff(names, old_names)
[17:45:21.130]                 removed <- setdiff(old_names, names)
[17:45:21.130]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:21.130]                   envs[common]]
[17:45:21.130]                 NAMES <- toupper(changed)
[17:45:21.130]                 args <- list()
[17:45:21.130]                 for (kk in seq_along(NAMES)) {
[17:45:21.130]                   name <- changed[[kk]]
[17:45:21.130]                   NAME <- NAMES[[kk]]
[17:45:21.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.130]                     next
[17:45:21.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.130]                 }
[17:45:21.130]                 NAMES <- toupper(added)
[17:45:21.130]                 for (kk in seq_along(NAMES)) {
[17:45:21.130]                   name <- added[[kk]]
[17:45:21.130]                   NAME <- NAMES[[kk]]
[17:45:21.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.130]                     next
[17:45:21.130]                   args[[name]] <- ""
[17:45:21.130]                 }
[17:45:21.130]                 NAMES <- toupper(removed)
[17:45:21.130]                 for (kk in seq_along(NAMES)) {
[17:45:21.130]                   name <- removed[[kk]]
[17:45:21.130]                   NAME <- NAMES[[kk]]
[17:45:21.130]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.130]                     next
[17:45:21.130]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.130]                 }
[17:45:21.130]                 if (length(args) > 0) 
[17:45:21.130]                   base::do.call(base::Sys.setenv, args = args)
[17:45:21.130]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:21.130]             }
[17:45:21.130]             else {
[17:45:21.130]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:21.130]             }
[17:45:21.130]             {
[17:45:21.130]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:21.130]                   0L) {
[17:45:21.130]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:21.130]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:21.130]                   base::options(opts)
[17:45:21.130]                 }
[17:45:21.130]                 {
[17:45:21.130]                   {
[17:45:21.130]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:21.130]                     NULL
[17:45:21.130]                   }
[17:45:21.130]                   options(future.plan = NULL)
[17:45:21.130]                   if (is.na(NA_character_)) 
[17:45:21.130]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.130]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:21.130]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:21.130]                     .init = FALSE)
[17:45:21.130]                 }
[17:45:21.130]             }
[17:45:21.130]         }
[17:45:21.130]     })
[17:45:21.130]     if (TRUE) {
[17:45:21.130]         base::sink(type = "output", split = FALSE)
[17:45:21.130]         if (TRUE) {
[17:45:21.130]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:21.130]         }
[17:45:21.130]         else {
[17:45:21.130]             ...future.result["stdout"] <- base::list(NULL)
[17:45:21.130]         }
[17:45:21.130]         base::close(...future.stdout)
[17:45:21.130]         ...future.stdout <- NULL
[17:45:21.130]     }
[17:45:21.130]     ...future.result$conditions <- ...future.conditions
[17:45:21.130]     ...future.result$finished <- base::Sys.time()
[17:45:21.130]     ...future.result
[17:45:21.130] }
[17:45:21.133] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[17:45:21.133] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:21.176] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:21.176] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:45:21.176] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:45:21.177] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:21.177] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:21.177] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:21.220] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:21.220] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:21.264] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:21.264] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:21.264] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.264] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[17:45:21.265] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[17:45:21.265] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:21.265] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.266] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:45:21.266] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:45:21.266] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:21.266] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.267] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:21.267] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.267] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[17:45:21.268] MultisessionFuture started
[17:45:21.268] - Launch lazy future ... done
[17:45:21.268] run() for ‘MultisessionFuture’ ... done
[17:45:21.268] Created future:
[17:45:21.268] MultisessionFuture:
[17:45:21.268] Label: ‘future_vapply-1’
[17:45:21.268] Expression:
[17:45:21.268] {
[17:45:21.268]     do.call(function(...) {
[17:45:21.268]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.268]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.268]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.268]             on.exit(options(oopts), add = TRUE)
[17:45:21.268]         }
[17:45:21.268]         {
[17:45:21.268]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.268]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.268]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.268]             })
[17:45:21.268]         }
[17:45:21.268]     }, args = future.call.arguments)
[17:45:21.268] }
[17:45:21.268] Lazy evaluation: FALSE
[17:45:21.268] Asynchronous evaluation: TRUE
[17:45:21.268] Local evaluation: TRUE
[17:45:21.268] Environment: R_GlobalEnv
[17:45:21.268] Capture standard output: TRUE
[17:45:21.268] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:21.268] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:21.268] Packages: 1 packages (‘future.apply’)
[17:45:21.268] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:21.268] Resolved: FALSE
[17:45:21.268] Value: <not collected>
[17:45:21.268] Conditions captured: <none>
[17:45:21.268] Early signaling: FALSE
[17:45:21.268] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:21.268] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.280] Chunk #1 of 2 ... DONE
[17:45:21.281] Chunk #2 of 2 ...
[17:45:21.281]  - Finding globals in 'X' for chunk #2 ...
[17:45:21.281] getGlobalsAndPackages() ...
[17:45:21.281] Searching for globals...
[17:45:21.281] 
[17:45:21.282] Searching for globals ... DONE
[17:45:21.282] - globals: [0] <none>
[17:45:21.282] getGlobalsAndPackages() ... DONE
[17:45:21.282]    + additional globals found: [n=0] 
[17:45:21.282]    + additional namespaces needed: [n=0] 
[17:45:21.282]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:21.282]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:21.282]  - seeds: <none>
[17:45:21.282]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.283] getGlobalsAndPackages() ...
[17:45:21.283] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.283] Resolving globals: FALSE
[17:45:21.283] Tweak future expression to call with '...' arguments ...
[17:45:21.283] {
[17:45:21.283]     do.call(function(...) {
[17:45:21.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.283]             on.exit(options(oopts), add = TRUE)
[17:45:21.283]         }
[17:45:21.283]         {
[17:45:21.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.283]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.283]             })
[17:45:21.283]         }
[17:45:21.283]     }, args = future.call.arguments)
[17:45:21.283] }
[17:45:21.283] Tweak future expression to call with '...' arguments ... DONE
[17:45:21.284] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.284] - packages: [1] ‘future.apply’
[17:45:21.284] getGlobalsAndPackages() ... DONE
[17:45:21.285] run() for ‘Future’ ...
[17:45:21.285] - state: ‘created’
[17:45:21.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:21.302] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.302] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:21.302]   - Field: ‘node’
[17:45:21.302]   - Field: ‘label’
[17:45:21.303]   - Field: ‘local’
[17:45:21.303]   - Field: ‘owner’
[17:45:21.303]   - Field: ‘envir’
[17:45:21.303]   - Field: ‘workers’
[17:45:21.303]   - Field: ‘packages’
[17:45:21.303]   - Field: ‘gc’
[17:45:21.303]   - Field: ‘conditions’
[17:45:21.303]   - Field: ‘persistent’
[17:45:21.303]   - Field: ‘expr’
[17:45:21.304]   - Field: ‘uuid’
[17:45:21.304]   - Field: ‘seed’
[17:45:21.304]   - Field: ‘version’
[17:45:21.304]   - Field: ‘result’
[17:45:21.304]   - Field: ‘asynchronous’
[17:45:21.304]   - Field: ‘calls’
[17:45:21.304]   - Field: ‘globals’
[17:45:21.304]   - Field: ‘stdout’
[17:45:21.304]   - Field: ‘earlySignal’
[17:45:21.305]   - Field: ‘lazy’
[17:45:21.305]   - Field: ‘state’
[17:45:21.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:21.305] - Launch lazy future ...
[17:45:21.305] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:21.305] Packages needed by future strategies (n = 0): <none>
[17:45:21.306] {
[17:45:21.306]     {
[17:45:21.306]         {
[17:45:21.306]             ...future.startTime <- base::Sys.time()
[17:45:21.306]             {
[17:45:21.306]                 {
[17:45:21.306]                   {
[17:45:21.306]                     {
[17:45:21.306]                       {
[17:45:21.306]                         base::local({
[17:45:21.306]                           has_future <- base::requireNamespace("future", 
[17:45:21.306]                             quietly = TRUE)
[17:45:21.306]                           if (has_future) {
[17:45:21.306]                             ns <- base::getNamespace("future")
[17:45:21.306]                             version <- ns[[".package"]][["version"]]
[17:45:21.306]                             if (is.null(version)) 
[17:45:21.306]                               version <- utils::packageVersion("future")
[17:45:21.306]                           }
[17:45:21.306]                           else {
[17:45:21.306]                             version <- NULL
[17:45:21.306]                           }
[17:45:21.306]                           if (!has_future || version < "1.8.0") {
[17:45:21.306]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:21.306]                               "", base::R.version$version.string), 
[17:45:21.306]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:21.306]                                 base::R.version$platform, 8 * 
[17:45:21.306]                                   base::.Machine$sizeof.pointer), 
[17:45:21.306]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:21.306]                                 "release", "version")], collapse = " "), 
[17:45:21.306]                               hostname = base::Sys.info()[["nodename"]])
[17:45:21.306]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:21.306]                               info)
[17:45:21.306]                             info <- base::paste(info, collapse = "; ")
[17:45:21.306]                             if (!has_future) {
[17:45:21.306]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:21.306]                                 info)
[17:45:21.306]                             }
[17:45:21.306]                             else {
[17:45:21.306]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:21.306]                                 info, version)
[17:45:21.306]                             }
[17:45:21.306]                             base::stop(msg)
[17:45:21.306]                           }
[17:45:21.306]                         })
[17:45:21.306]                       }
[17:45:21.306]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:21.306]                       base::options(mc.cores = 1L)
[17:45:21.306]                     }
[17:45:21.306]                     base::local({
[17:45:21.306]                       for (pkg in "future.apply") {
[17:45:21.306]                         base::loadNamespace(pkg)
[17:45:21.306]                         base::library(pkg, character.only = TRUE)
[17:45:21.306]                       }
[17:45:21.306]                     })
[17:45:21.306]                   }
[17:45:21.306]                   ...future.strategy.old <- future::plan("list")
[17:45:21.306]                   options(future.plan = NULL)
[17:45:21.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:21.306]                 }
[17:45:21.306]                 ...future.workdir <- getwd()
[17:45:21.306]             }
[17:45:21.306]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:21.306]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:21.306]         }
[17:45:21.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:21.306]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:21.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:21.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:21.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:21.306]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:21.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:21.306]             base::names(...future.oldOptions))
[17:45:21.306]     }
[17:45:21.306]     if (FALSE) {
[17:45:21.306]     }
[17:45:21.306]     else {
[17:45:21.306]         if (TRUE) {
[17:45:21.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:21.306]                 open = "w")
[17:45:21.306]         }
[17:45:21.306]         else {
[17:45:21.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:21.306]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:21.306]         }
[17:45:21.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:21.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:21.306]             base::sink(type = "output", split = FALSE)
[17:45:21.306]             base::close(...future.stdout)
[17:45:21.306]         }, add = TRUE)
[17:45:21.306]     }
[17:45:21.306]     ...future.frame <- base::sys.nframe()
[17:45:21.306]     ...future.conditions <- base::list()
[17:45:21.306]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:21.306]     if (FALSE) {
[17:45:21.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:21.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:21.306]     }
[17:45:21.306]     ...future.result <- base::tryCatch({
[17:45:21.306]         base::withCallingHandlers({
[17:45:21.306]             ...future.value <- base::withVisible(base::local({
[17:45:21.306]                 ...future.makeSendCondition <- base::local({
[17:45:21.306]                   sendCondition <- NULL
[17:45:21.306]                   function(frame = 1L) {
[17:45:21.306]                     if (is.function(sendCondition)) 
[17:45:21.306]                       return(sendCondition)
[17:45:21.306]                     ns <- getNamespace("parallel")
[17:45:21.306]                     if (exists("sendData", mode = "function", 
[17:45:21.306]                       envir = ns)) {
[17:45:21.306]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:21.306]                         envir = ns)
[17:45:21.306]                       envir <- sys.frame(frame)
[17:45:21.306]                       master <- NULL
[17:45:21.306]                       while (!identical(envir, .GlobalEnv) && 
[17:45:21.306]                         !identical(envir, emptyenv())) {
[17:45:21.306]                         if (exists("master", mode = "list", envir = envir, 
[17:45:21.306]                           inherits = FALSE)) {
[17:45:21.306]                           master <- get("master", mode = "list", 
[17:45:21.306]                             envir = envir, inherits = FALSE)
[17:45:21.306]                           if (inherits(master, c("SOCKnode", 
[17:45:21.306]                             "SOCK0node"))) {
[17:45:21.306]                             sendCondition <<- function(cond) {
[17:45:21.306]                               data <- list(type = "VALUE", value = cond, 
[17:45:21.306]                                 success = TRUE)
[17:45:21.306]                               parallel_sendData(master, data)
[17:45:21.306]                             }
[17:45:21.306]                             return(sendCondition)
[17:45:21.306]                           }
[17:45:21.306]                         }
[17:45:21.306]                         frame <- frame + 1L
[17:45:21.306]                         envir <- sys.frame(frame)
[17:45:21.306]                       }
[17:45:21.306]                     }
[17:45:21.306]                     sendCondition <<- function(cond) NULL
[17:45:21.306]                   }
[17:45:21.306]                 })
[17:45:21.306]                 withCallingHandlers({
[17:45:21.306]                   {
[17:45:21.306]                     do.call(function(...) {
[17:45:21.306]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.306]                       if (!identical(...future.globals.maxSize.org, 
[17:45:21.306]                         ...future.globals.maxSize)) {
[17:45:21.306]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.306]                         on.exit(options(oopts), add = TRUE)
[17:45:21.306]                       }
[17:45:21.306]                       {
[17:45:21.306]                         lapply(seq_along(...future.elements_ii), 
[17:45:21.306]                           FUN = function(jj) {
[17:45:21.306]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.306]                             ...future.FUN(...future.X_jj, ...)
[17:45:21.306]                           })
[17:45:21.306]                       }
[17:45:21.306]                     }, args = future.call.arguments)
[17:45:21.306]                   }
[17:45:21.306]                 }, immediateCondition = function(cond) {
[17:45:21.306]                   sendCondition <- ...future.makeSendCondition()
[17:45:21.306]                   sendCondition(cond)
[17:45:21.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.306]                   {
[17:45:21.306]                     inherits <- base::inherits
[17:45:21.306]                     invokeRestart <- base::invokeRestart
[17:45:21.306]                     is.null <- base::is.null
[17:45:21.306]                     muffled <- FALSE
[17:45:21.306]                     if (inherits(cond, "message")) {
[17:45:21.306]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:21.306]                       if (muffled) 
[17:45:21.306]                         invokeRestart("muffleMessage")
[17:45:21.306]                     }
[17:45:21.306]                     else if (inherits(cond, "warning")) {
[17:45:21.306]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:21.306]                       if (muffled) 
[17:45:21.306]                         invokeRestart("muffleWarning")
[17:45:21.306]                     }
[17:45:21.306]                     else if (inherits(cond, "condition")) {
[17:45:21.306]                       if (!is.null(pattern)) {
[17:45:21.306]                         computeRestarts <- base::computeRestarts
[17:45:21.306]                         grepl <- base::grepl
[17:45:21.306]                         restarts <- computeRestarts(cond)
[17:45:21.306]                         for (restart in restarts) {
[17:45:21.306]                           name <- restart$name
[17:45:21.306]                           if (is.null(name)) 
[17:45:21.306]                             next
[17:45:21.306]                           if (!grepl(pattern, name)) 
[17:45:21.306]                             next
[17:45:21.306]                           invokeRestart(restart)
[17:45:21.306]                           muffled <- TRUE
[17:45:21.306]                           break
[17:45:21.306]                         }
[17:45:21.306]                       }
[17:45:21.306]                     }
[17:45:21.306]                     invisible(muffled)
[17:45:21.306]                   }
[17:45:21.306]                   muffleCondition(cond)
[17:45:21.306]                 })
[17:45:21.306]             }))
[17:45:21.306]             future::FutureResult(value = ...future.value$value, 
[17:45:21.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.306]                   ...future.rng), globalenv = if (FALSE) 
[17:45:21.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:21.306]                     ...future.globalenv.names))
[17:45:21.306]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:21.306]         }, condition = base::local({
[17:45:21.306]             c <- base::c
[17:45:21.306]             inherits <- base::inherits
[17:45:21.306]             invokeRestart <- base::invokeRestart
[17:45:21.306]             length <- base::length
[17:45:21.306]             list <- base::list
[17:45:21.306]             seq.int <- base::seq.int
[17:45:21.306]             signalCondition <- base::signalCondition
[17:45:21.306]             sys.calls <- base::sys.calls
[17:45:21.306]             `[[` <- base::`[[`
[17:45:21.306]             `+` <- base::`+`
[17:45:21.306]             `<<-` <- base::`<<-`
[17:45:21.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:21.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:21.306]                   3L)]
[17:45:21.306]             }
[17:45:21.306]             function(cond) {
[17:45:21.306]                 is_error <- inherits(cond, "error")
[17:45:21.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:21.306]                   NULL)
[17:45:21.306]                 if (is_error) {
[17:45:21.306]                   sessionInformation <- function() {
[17:45:21.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:21.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:21.306]                       search = base::search(), system = base::Sys.info())
[17:45:21.306]                   }
[17:45:21.306]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:21.306]                     cond$call), session = sessionInformation(), 
[17:45:21.306]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:21.306]                   signalCondition(cond)
[17:45:21.306]                 }
[17:45:21.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:21.306]                 "immediateCondition"))) {
[17:45:21.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:21.306]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:21.306]                   if (TRUE && !signal) {
[17:45:21.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.306]                     {
[17:45:21.306]                       inherits <- base::inherits
[17:45:21.306]                       invokeRestart <- base::invokeRestart
[17:45:21.306]                       is.null <- base::is.null
[17:45:21.306]                       muffled <- FALSE
[17:45:21.306]                       if (inherits(cond, "message")) {
[17:45:21.306]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.306]                         if (muffled) 
[17:45:21.306]                           invokeRestart("muffleMessage")
[17:45:21.306]                       }
[17:45:21.306]                       else if (inherits(cond, "warning")) {
[17:45:21.306]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.306]                         if (muffled) 
[17:45:21.306]                           invokeRestart("muffleWarning")
[17:45:21.306]                       }
[17:45:21.306]                       else if (inherits(cond, "condition")) {
[17:45:21.306]                         if (!is.null(pattern)) {
[17:45:21.306]                           computeRestarts <- base::computeRestarts
[17:45:21.306]                           grepl <- base::grepl
[17:45:21.306]                           restarts <- computeRestarts(cond)
[17:45:21.306]                           for (restart in restarts) {
[17:45:21.306]                             name <- restart$name
[17:45:21.306]                             if (is.null(name)) 
[17:45:21.306]                               next
[17:45:21.306]                             if (!grepl(pattern, name)) 
[17:45:21.306]                               next
[17:45:21.306]                             invokeRestart(restart)
[17:45:21.306]                             muffled <- TRUE
[17:45:21.306]                             break
[17:45:21.306]                           }
[17:45:21.306]                         }
[17:45:21.306]                       }
[17:45:21.306]                       invisible(muffled)
[17:45:21.306]                     }
[17:45:21.306]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.306]                   }
[17:45:21.306]                 }
[17:45:21.306]                 else {
[17:45:21.306]                   if (TRUE) {
[17:45:21.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.306]                     {
[17:45:21.306]                       inherits <- base::inherits
[17:45:21.306]                       invokeRestart <- base::invokeRestart
[17:45:21.306]                       is.null <- base::is.null
[17:45:21.306]                       muffled <- FALSE
[17:45:21.306]                       if (inherits(cond, "message")) {
[17:45:21.306]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.306]                         if (muffled) 
[17:45:21.306]                           invokeRestart("muffleMessage")
[17:45:21.306]                       }
[17:45:21.306]                       else if (inherits(cond, "warning")) {
[17:45:21.306]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.306]                         if (muffled) 
[17:45:21.306]                           invokeRestart("muffleWarning")
[17:45:21.306]                       }
[17:45:21.306]                       else if (inherits(cond, "condition")) {
[17:45:21.306]                         if (!is.null(pattern)) {
[17:45:21.306]                           computeRestarts <- base::computeRestarts
[17:45:21.306]                           grepl <- base::grepl
[17:45:21.306]                           restarts <- computeRestarts(cond)
[17:45:21.306]                           for (restart in restarts) {
[17:45:21.306]                             name <- restart$name
[17:45:21.306]                             if (is.null(name)) 
[17:45:21.306]                               next
[17:45:21.306]                             if (!grepl(pattern, name)) 
[17:45:21.306]                               next
[17:45:21.306]                             invokeRestart(restart)
[17:45:21.306]                             muffled <- TRUE
[17:45:21.306]                             break
[17:45:21.306]                           }
[17:45:21.306]                         }
[17:45:21.306]                       }
[17:45:21.306]                       invisible(muffled)
[17:45:21.306]                     }
[17:45:21.306]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.306]                   }
[17:45:21.306]                 }
[17:45:21.306]             }
[17:45:21.306]         }))
[17:45:21.306]     }, error = function(ex) {
[17:45:21.306]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:21.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.306]                 ...future.rng), started = ...future.startTime, 
[17:45:21.306]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:21.306]             version = "1.8"), class = "FutureResult")
[17:45:21.306]     }, finally = {
[17:45:21.306]         if (!identical(...future.workdir, getwd())) 
[17:45:21.306]             setwd(...future.workdir)
[17:45:21.306]         {
[17:45:21.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:21.306]                 ...future.oldOptions$nwarnings <- NULL
[17:45:21.306]             }
[17:45:21.306]             base::options(...future.oldOptions)
[17:45:21.306]             if (.Platform$OS.type == "windows") {
[17:45:21.306]                 old_names <- names(...future.oldEnvVars)
[17:45:21.306]                 envs <- base::Sys.getenv()
[17:45:21.306]                 names <- names(envs)
[17:45:21.306]                 common <- intersect(names, old_names)
[17:45:21.306]                 added <- setdiff(names, old_names)
[17:45:21.306]                 removed <- setdiff(old_names, names)
[17:45:21.306]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:21.306]                   envs[common]]
[17:45:21.306]                 NAMES <- toupper(changed)
[17:45:21.306]                 args <- list()
[17:45:21.306]                 for (kk in seq_along(NAMES)) {
[17:45:21.306]                   name <- changed[[kk]]
[17:45:21.306]                   NAME <- NAMES[[kk]]
[17:45:21.306]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.306]                     next
[17:45:21.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.306]                 }
[17:45:21.306]                 NAMES <- toupper(added)
[17:45:21.306]                 for (kk in seq_along(NAMES)) {
[17:45:21.306]                   name <- added[[kk]]
[17:45:21.306]                   NAME <- NAMES[[kk]]
[17:45:21.306]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.306]                     next
[17:45:21.306]                   args[[name]] <- ""
[17:45:21.306]                 }
[17:45:21.306]                 NAMES <- toupper(removed)
[17:45:21.306]                 for (kk in seq_along(NAMES)) {
[17:45:21.306]                   name <- removed[[kk]]
[17:45:21.306]                   NAME <- NAMES[[kk]]
[17:45:21.306]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.306]                     next
[17:45:21.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.306]                 }
[17:45:21.306]                 if (length(args) > 0) 
[17:45:21.306]                   base::do.call(base::Sys.setenv, args = args)
[17:45:21.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:21.306]             }
[17:45:21.306]             else {
[17:45:21.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:21.306]             }
[17:45:21.306]             {
[17:45:21.306]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:21.306]                   0L) {
[17:45:21.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:21.306]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:21.306]                   base::options(opts)
[17:45:21.306]                 }
[17:45:21.306]                 {
[17:45:21.306]                   {
[17:45:21.306]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:21.306]                     NULL
[17:45:21.306]                   }
[17:45:21.306]                   options(future.plan = NULL)
[17:45:21.306]                   if (is.na(NA_character_)) 
[17:45:21.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:21.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:21.306]                     .init = FALSE)
[17:45:21.306]                 }
[17:45:21.306]             }
[17:45:21.306]         }
[17:45:21.306]     })
[17:45:21.306]     if (TRUE) {
[17:45:21.306]         base::sink(type = "output", split = FALSE)
[17:45:21.306]         if (TRUE) {
[17:45:21.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:21.306]         }
[17:45:21.306]         else {
[17:45:21.306]             ...future.result["stdout"] <- base::list(NULL)
[17:45:21.306]         }
[17:45:21.306]         base::close(...future.stdout)
[17:45:21.306]         ...future.stdout <- NULL
[17:45:21.306]     }
[17:45:21.306]     ...future.result$conditions <- ...future.conditions
[17:45:21.306]     ...future.result$finished <- base::Sys.time()
[17:45:21.306]     ...future.result
[17:45:21.306] }
[17:45:21.362] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[17:45:21.362] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:21.366] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:21.366] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:45:21.367] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:45:21.367] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:21.367] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:21.368] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:21.412] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:21.412] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:21.456] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:21.456] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:21.456] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.456] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[17:45:21.457] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[17:45:21.457] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:21.457] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.458] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[17:45:21.458] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[17:45:21.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:21.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.459] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:21.459] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.459] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[17:45:21.460] MultisessionFuture started
[17:45:21.460] - Launch lazy future ... done
[17:45:21.460] run() for ‘MultisessionFuture’ ... done
[17:45:21.462] Created future:
[17:45:21.462] MultisessionFuture:
[17:45:21.462] Label: ‘future_vapply-2’
[17:45:21.462] Expression:
[17:45:21.462] {
[17:45:21.462]     do.call(function(...) {
[17:45:21.462]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.462]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.462]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.462]             on.exit(options(oopts), add = TRUE)
[17:45:21.462]         }
[17:45:21.462]         {
[17:45:21.462]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.462]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.462]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.462]             })
[17:45:21.462]         }
[17:45:21.462]     }, args = future.call.arguments)
[17:45:21.462] }
[17:45:21.462] Lazy evaluation: FALSE
[17:45:21.462] Asynchronous evaluation: TRUE
[17:45:21.462] Local evaluation: TRUE
[17:45:21.462] Environment: R_GlobalEnv
[17:45:21.462] Capture standard output: TRUE
[17:45:21.462] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:21.462] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:21.462] Packages: 1 packages (‘future.apply’)
[17:45:21.462] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:21.462] Resolved: FALSE
[17:45:21.462] Value: <not collected>
[17:45:21.462] Conditions captured: <none>
[17:45:21.462] Early signaling: FALSE
[17:45:21.462] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:21.462] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.474] Chunk #2 of 2 ... DONE
[17:45:21.474] Launching 2 futures (chunks) ... DONE
[17:45:21.474] Resolving 2 futures (chunks) ...
[17:45:21.474] resolve() on list ...
[17:45:21.474]  recursive: 0
[17:45:21.475]  length: 2
[17:45:21.475] 
[17:45:21.475] receiveMessageFromWorker() for ClusterFuture ...
[17:45:21.475] - Validating connection of MultisessionFuture
[17:45:21.475] - received message: FutureResult
[17:45:21.475] - Received FutureResult
[17:45:21.476] - Erased future from FutureRegistry
[17:45:21.476] result() for ClusterFuture ...
[17:45:21.476] - result already collected: FutureResult
[17:45:21.476] result() for ClusterFuture ... done
[17:45:21.476] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:21.476] Future #1
[17:45:21.476] result() for ClusterFuture ...
[17:45:21.476] - result already collected: FutureResult
[17:45:21.476] result() for ClusterFuture ... done
[17:45:21.476] result() for ClusterFuture ...
[17:45:21.476] - result already collected: FutureResult
[17:45:21.476] result() for ClusterFuture ... done
[17:45:21.477] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:21.477] - nx: 2
[17:45:21.477] - relay: TRUE
[17:45:21.477] - stdout: TRUE
[17:45:21.477] - signal: TRUE
[17:45:21.477] - resignal: FALSE
[17:45:21.477] - force: TRUE
[17:45:21.477] - relayed: [n=2] FALSE, FALSE
[17:45:21.477] - queued futures: [n=2] FALSE, FALSE
[17:45:21.477]  - until=1
[17:45:21.477]  - relaying element #1
[17:45:21.478] result() for ClusterFuture ...
[17:45:21.478] - result already collected: FutureResult
[17:45:21.478] result() for ClusterFuture ... done
[17:45:21.478] result() for ClusterFuture ...
[17:45:21.478] - result already collected: FutureResult
[17:45:21.478] result() for ClusterFuture ... done
[17:45:21.478] result() for ClusterFuture ...
[17:45:21.478] - result already collected: FutureResult
[17:45:21.478] result() for ClusterFuture ... done
[17:45:21.478] result() for ClusterFuture ...
[17:45:21.478] - result already collected: FutureResult
[17:45:21.478] result() for ClusterFuture ... done
[17:45:21.479] - relayed: [n=2] TRUE, FALSE
[17:45:21.479] - queued futures: [n=2] TRUE, FALSE
[17:45:21.479] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:21.479]  length: 1 (resolved future 1)
[17:45:21.546] receiveMessageFromWorker() for ClusterFuture ...
[17:45:21.546] - Validating connection of MultisessionFuture
[17:45:21.546] - received message: FutureResult
[17:45:21.546] - Received FutureResult
[17:45:21.546] - Erased future from FutureRegistry
[17:45:21.547] result() for ClusterFuture ...
[17:45:21.547] - result already collected: FutureResult
[17:45:21.547] result() for ClusterFuture ... done
[17:45:21.547] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:21.547] Future #2
[17:45:21.547] result() for ClusterFuture ...
[17:45:21.547] - result already collected: FutureResult
[17:45:21.547] result() for ClusterFuture ... done
[17:45:21.547] result() for ClusterFuture ...
[17:45:21.547] - result already collected: FutureResult
[17:45:21.547] result() for ClusterFuture ... done
[17:45:21.548] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:21.548] - nx: 2
[17:45:21.548] - relay: TRUE
[17:45:21.548] - stdout: TRUE
[17:45:21.548] - signal: TRUE
[17:45:21.548] - resignal: FALSE
[17:45:21.548] - force: TRUE
[17:45:21.548] - relayed: [n=2] TRUE, FALSE
[17:45:21.548] - queued futures: [n=2] TRUE, FALSE
[17:45:21.548]  - until=2
[17:45:21.548]  - relaying element #2
[17:45:21.548] result() for ClusterFuture ...
[17:45:21.549] - result already collected: FutureResult
[17:45:21.549] result() for ClusterFuture ... done
[17:45:21.549] result() for ClusterFuture ...
[17:45:21.549] - result already collected: FutureResult
[17:45:21.549] result() for ClusterFuture ... done
[17:45:21.549] result() for ClusterFuture ...
[17:45:21.549] - result already collected: FutureResult
[17:45:21.549] result() for ClusterFuture ... done
[17:45:21.549] result() for ClusterFuture ...
[17:45:21.549] - result already collected: FutureResult
[17:45:21.549] result() for ClusterFuture ... done
[17:45:21.549] - relayed: [n=2] TRUE, TRUE
[17:45:21.550] - queued futures: [n=2] TRUE, TRUE
[17:45:21.550] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:21.550]  length: 0 (resolved future 2)
[17:45:21.550] Relaying remaining futures
[17:45:21.550] signalConditionsASAP(NULL, pos=0) ...
[17:45:21.550] - nx: 2
[17:45:21.550] - relay: TRUE
[17:45:21.550] - stdout: TRUE
[17:45:21.550] - signal: TRUE
[17:45:21.550] - resignal: FALSE
[17:45:21.550] - force: TRUE
[17:45:21.550] - relayed: [n=2] TRUE, TRUE
[17:45:21.551] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:21.551] - relayed: [n=2] TRUE, TRUE
[17:45:21.551] - queued futures: [n=2] TRUE, TRUE
[17:45:21.551] signalConditionsASAP(NULL, pos=0) ... done
[17:45:21.551] resolve() on list ... DONE
[17:45:21.551] result() for ClusterFuture ...
[17:45:21.551] - result already collected: FutureResult
[17:45:21.551] result() for ClusterFuture ... done
[17:45:21.551] result() for ClusterFuture ...
[17:45:21.551] - result already collected: FutureResult
[17:45:21.552] result() for ClusterFuture ... done
[17:45:21.552] result() for ClusterFuture ...
[17:45:21.552] - result already collected: FutureResult
[17:45:21.552] result() for ClusterFuture ... done
[17:45:21.552] result() for ClusterFuture ...
[17:45:21.552] - result already collected: FutureResult
[17:45:21.552] result() for ClusterFuture ... done
[17:45:21.552]  - Number of value chunks collected: 2
[17:45:21.552] Resolving 2 futures (chunks) ... DONE
[17:45:21.552] Reducing values from 2 chunks ...
[17:45:21.552]  - Number of values collected after concatenation: 2
[17:45:21.553]  - Number of values expected: 2
[17:45:21.553] Reducing values from 2 chunks ... DONE
[17:45:21.553] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[17:45:21.554] future_lapply() ...
[17:45:21.559] Number of chunks: 2
[17:45:21.559] getGlobalsAndPackagesXApply() ...
[17:45:21.559]  - future.globals: TRUE
[17:45:21.559] getGlobalsAndPackages() ...
[17:45:21.560] Searching for globals...
[17:45:21.563] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[17:45:21.563] Searching for globals ... DONE
[17:45:21.563] Resolving globals: FALSE
[17:45:21.564] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[17:45:21.565] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:21.565] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:21.565] - packages: [1] ‘future.apply’
[17:45:21.565] getGlobalsAndPackages() ... DONE
[17:45:21.565]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:21.565]  - needed namespaces: [n=1] ‘future.apply’
[17:45:21.565] Finding globals ... DONE
[17:45:21.565]  - use_args: TRUE
[17:45:21.565]  - Getting '...' globals ...
[17:45:21.566] resolve() on list ...
[17:45:21.566]  recursive: 0
[17:45:21.566]  length: 1
[17:45:21.566]  elements: ‘...’
[17:45:21.566]  length: 0 (resolved future 1)
[17:45:21.566] resolve() on list ... DONE
[17:45:21.566]    - '...' content: [n=0] 
[17:45:21.566] List of 1
[17:45:21.566]  $ ...: list()
[17:45:21.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:21.566]  - attr(*, "where")=List of 1
[17:45:21.566]   ..$ ...:<environment: 0x5561f4c486e8> 
[17:45:21.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:21.566]  - attr(*, "resolved")= logi TRUE
[17:45:21.566]  - attr(*, "total_size")= num NA
[17:45:21.569]  - Getting '...' globals ... DONE
[17:45:21.569] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:21.569] List of 8
[17:45:21.569]  $ ...future.FUN:function (x, ...)  
[17:45:21.569]  $ x_FUN        :function (x)  
[17:45:21.569]  $ times        : int 0
[17:45:21.569]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:21.569]  $ stop_if_not  :function (...)  
[17:45:21.569]  $ dim          : NULL
[17:45:21.569]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:21.569]  $ ...          : list()
[17:45:21.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:21.569]  - attr(*, "where")=List of 8
[17:45:21.569]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:21.569]   ..$ ...          :<environment: 0x5561f4c486e8> 
[17:45:21.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:21.569]  - attr(*, "resolved")= logi FALSE
[17:45:21.569]  - attr(*, "total_size")= num 95472
[17:45:21.574] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:21.574] getGlobalsAndPackagesXApply() ... DONE
[17:45:21.575] Number of futures (= number of chunks): 2
[17:45:21.575] Launching 2 futures (chunks) ...
[17:45:21.575] Chunk #1 of 2 ...
[17:45:21.575]  - Finding globals in 'X' for chunk #1 ...
[17:45:21.575] getGlobalsAndPackages() ...
[17:45:21.575] Searching for globals...
[17:45:21.575] 
[17:45:21.576] Searching for globals ... DONE
[17:45:21.576] - globals: [0] <none>
[17:45:21.576] getGlobalsAndPackages() ... DONE
[17:45:21.576]    + additional globals found: [n=0] 
[17:45:21.576]    + additional namespaces needed: [n=0] 
[17:45:21.576]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:21.576]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:21.576]  - seeds: <none>
[17:45:21.576]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.576] getGlobalsAndPackages() ...
[17:45:21.576] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.577] Resolving globals: FALSE
[17:45:21.577] Tweak future expression to call with '...' arguments ...
[17:45:21.577] {
[17:45:21.577]     do.call(function(...) {
[17:45:21.577]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.577]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.577]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.577]             on.exit(options(oopts), add = TRUE)
[17:45:21.577]         }
[17:45:21.577]         {
[17:45:21.577]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.577]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.577]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.577]             })
[17:45:21.577]         }
[17:45:21.577]     }, args = future.call.arguments)
[17:45:21.577] }
[17:45:21.577] Tweak future expression to call with '...' arguments ... DONE
[17:45:21.578] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.578] - packages: [1] ‘future.apply’
[17:45:21.578] getGlobalsAndPackages() ... DONE
[17:45:21.578] run() for ‘Future’ ...
[17:45:21.578] - state: ‘created’
[17:45:21.578] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:21.592] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:21.592]   - Field: ‘node’
[17:45:21.592]   - Field: ‘label’
[17:45:21.593]   - Field: ‘local’
[17:45:21.593]   - Field: ‘owner’
[17:45:21.593]   - Field: ‘envir’
[17:45:21.593]   - Field: ‘workers’
[17:45:21.593]   - Field: ‘packages’
[17:45:21.593]   - Field: ‘gc’
[17:45:21.593]   - Field: ‘conditions’
[17:45:21.593]   - Field: ‘persistent’
[17:45:21.593]   - Field: ‘expr’
[17:45:21.593]   - Field: ‘uuid’
[17:45:21.593]   - Field: ‘seed’
[17:45:21.594]   - Field: ‘version’
[17:45:21.594]   - Field: ‘result’
[17:45:21.594]   - Field: ‘asynchronous’
[17:45:21.594]   - Field: ‘calls’
[17:45:21.594]   - Field: ‘globals’
[17:45:21.594]   - Field: ‘stdout’
[17:45:21.594]   - Field: ‘earlySignal’
[17:45:21.594]   - Field: ‘lazy’
[17:45:21.594]   - Field: ‘state’
[17:45:21.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:21.594] - Launch lazy future ...
[17:45:21.595] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:21.595] Packages needed by future strategies (n = 0): <none>
[17:45:21.595] {
[17:45:21.595]     {
[17:45:21.595]         {
[17:45:21.595]             ...future.startTime <- base::Sys.time()
[17:45:21.595]             {
[17:45:21.595]                 {
[17:45:21.595]                   {
[17:45:21.595]                     {
[17:45:21.595]                       {
[17:45:21.595]                         base::local({
[17:45:21.595]                           has_future <- base::requireNamespace("future", 
[17:45:21.595]                             quietly = TRUE)
[17:45:21.595]                           if (has_future) {
[17:45:21.595]                             ns <- base::getNamespace("future")
[17:45:21.595]                             version <- ns[[".package"]][["version"]]
[17:45:21.595]                             if (is.null(version)) 
[17:45:21.595]                               version <- utils::packageVersion("future")
[17:45:21.595]                           }
[17:45:21.595]                           else {
[17:45:21.595]                             version <- NULL
[17:45:21.595]                           }
[17:45:21.595]                           if (!has_future || version < "1.8.0") {
[17:45:21.595]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:21.595]                               "", base::R.version$version.string), 
[17:45:21.595]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:21.595]                                 base::R.version$platform, 8 * 
[17:45:21.595]                                   base::.Machine$sizeof.pointer), 
[17:45:21.595]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:21.595]                                 "release", "version")], collapse = " "), 
[17:45:21.595]                               hostname = base::Sys.info()[["nodename"]])
[17:45:21.595]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:21.595]                               info)
[17:45:21.595]                             info <- base::paste(info, collapse = "; ")
[17:45:21.595]                             if (!has_future) {
[17:45:21.595]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:21.595]                                 info)
[17:45:21.595]                             }
[17:45:21.595]                             else {
[17:45:21.595]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:21.595]                                 info, version)
[17:45:21.595]                             }
[17:45:21.595]                             base::stop(msg)
[17:45:21.595]                           }
[17:45:21.595]                         })
[17:45:21.595]                       }
[17:45:21.595]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:21.595]                       base::options(mc.cores = 1L)
[17:45:21.595]                     }
[17:45:21.595]                     base::local({
[17:45:21.595]                       for (pkg in "future.apply") {
[17:45:21.595]                         base::loadNamespace(pkg)
[17:45:21.595]                         base::library(pkg, character.only = TRUE)
[17:45:21.595]                       }
[17:45:21.595]                     })
[17:45:21.595]                   }
[17:45:21.595]                   ...future.strategy.old <- future::plan("list")
[17:45:21.595]                   options(future.plan = NULL)
[17:45:21.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:21.595]                 }
[17:45:21.595]                 ...future.workdir <- getwd()
[17:45:21.595]             }
[17:45:21.595]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:21.595]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:21.595]         }
[17:45:21.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:21.595]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:21.595]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:21.595]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:21.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:21.595]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:21.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:21.595]             base::names(...future.oldOptions))
[17:45:21.595]     }
[17:45:21.595]     if (FALSE) {
[17:45:21.595]     }
[17:45:21.595]     else {
[17:45:21.595]         if (TRUE) {
[17:45:21.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:21.595]                 open = "w")
[17:45:21.595]         }
[17:45:21.595]         else {
[17:45:21.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:21.595]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:21.595]         }
[17:45:21.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:21.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:21.595]             base::sink(type = "output", split = FALSE)
[17:45:21.595]             base::close(...future.stdout)
[17:45:21.595]         }, add = TRUE)
[17:45:21.595]     }
[17:45:21.595]     ...future.frame <- base::sys.nframe()
[17:45:21.595]     ...future.conditions <- base::list()
[17:45:21.595]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:21.595]     if (FALSE) {
[17:45:21.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:21.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:21.595]     }
[17:45:21.595]     ...future.result <- base::tryCatch({
[17:45:21.595]         base::withCallingHandlers({
[17:45:21.595]             ...future.value <- base::withVisible(base::local({
[17:45:21.595]                 ...future.makeSendCondition <- base::local({
[17:45:21.595]                   sendCondition <- NULL
[17:45:21.595]                   function(frame = 1L) {
[17:45:21.595]                     if (is.function(sendCondition)) 
[17:45:21.595]                       return(sendCondition)
[17:45:21.595]                     ns <- getNamespace("parallel")
[17:45:21.595]                     if (exists("sendData", mode = "function", 
[17:45:21.595]                       envir = ns)) {
[17:45:21.595]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:21.595]                         envir = ns)
[17:45:21.595]                       envir <- sys.frame(frame)
[17:45:21.595]                       master <- NULL
[17:45:21.595]                       while (!identical(envir, .GlobalEnv) && 
[17:45:21.595]                         !identical(envir, emptyenv())) {
[17:45:21.595]                         if (exists("master", mode = "list", envir = envir, 
[17:45:21.595]                           inherits = FALSE)) {
[17:45:21.595]                           master <- get("master", mode = "list", 
[17:45:21.595]                             envir = envir, inherits = FALSE)
[17:45:21.595]                           if (inherits(master, c("SOCKnode", 
[17:45:21.595]                             "SOCK0node"))) {
[17:45:21.595]                             sendCondition <<- function(cond) {
[17:45:21.595]                               data <- list(type = "VALUE", value = cond, 
[17:45:21.595]                                 success = TRUE)
[17:45:21.595]                               parallel_sendData(master, data)
[17:45:21.595]                             }
[17:45:21.595]                             return(sendCondition)
[17:45:21.595]                           }
[17:45:21.595]                         }
[17:45:21.595]                         frame <- frame + 1L
[17:45:21.595]                         envir <- sys.frame(frame)
[17:45:21.595]                       }
[17:45:21.595]                     }
[17:45:21.595]                     sendCondition <<- function(cond) NULL
[17:45:21.595]                   }
[17:45:21.595]                 })
[17:45:21.595]                 withCallingHandlers({
[17:45:21.595]                   {
[17:45:21.595]                     do.call(function(...) {
[17:45:21.595]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.595]                       if (!identical(...future.globals.maxSize.org, 
[17:45:21.595]                         ...future.globals.maxSize)) {
[17:45:21.595]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.595]                         on.exit(options(oopts), add = TRUE)
[17:45:21.595]                       }
[17:45:21.595]                       {
[17:45:21.595]                         lapply(seq_along(...future.elements_ii), 
[17:45:21.595]                           FUN = function(jj) {
[17:45:21.595]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.595]                             ...future.FUN(...future.X_jj, ...)
[17:45:21.595]                           })
[17:45:21.595]                       }
[17:45:21.595]                     }, args = future.call.arguments)
[17:45:21.595]                   }
[17:45:21.595]                 }, immediateCondition = function(cond) {
[17:45:21.595]                   sendCondition <- ...future.makeSendCondition()
[17:45:21.595]                   sendCondition(cond)
[17:45:21.595]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.595]                   {
[17:45:21.595]                     inherits <- base::inherits
[17:45:21.595]                     invokeRestart <- base::invokeRestart
[17:45:21.595]                     is.null <- base::is.null
[17:45:21.595]                     muffled <- FALSE
[17:45:21.595]                     if (inherits(cond, "message")) {
[17:45:21.595]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:21.595]                       if (muffled) 
[17:45:21.595]                         invokeRestart("muffleMessage")
[17:45:21.595]                     }
[17:45:21.595]                     else if (inherits(cond, "warning")) {
[17:45:21.595]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:21.595]                       if (muffled) 
[17:45:21.595]                         invokeRestart("muffleWarning")
[17:45:21.595]                     }
[17:45:21.595]                     else if (inherits(cond, "condition")) {
[17:45:21.595]                       if (!is.null(pattern)) {
[17:45:21.595]                         computeRestarts <- base::computeRestarts
[17:45:21.595]                         grepl <- base::grepl
[17:45:21.595]                         restarts <- computeRestarts(cond)
[17:45:21.595]                         for (restart in restarts) {
[17:45:21.595]                           name <- restart$name
[17:45:21.595]                           if (is.null(name)) 
[17:45:21.595]                             next
[17:45:21.595]                           if (!grepl(pattern, name)) 
[17:45:21.595]                             next
[17:45:21.595]                           invokeRestart(restart)
[17:45:21.595]                           muffled <- TRUE
[17:45:21.595]                           break
[17:45:21.595]                         }
[17:45:21.595]                       }
[17:45:21.595]                     }
[17:45:21.595]                     invisible(muffled)
[17:45:21.595]                   }
[17:45:21.595]                   muffleCondition(cond)
[17:45:21.595]                 })
[17:45:21.595]             }))
[17:45:21.595]             future::FutureResult(value = ...future.value$value, 
[17:45:21.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.595]                   ...future.rng), globalenv = if (FALSE) 
[17:45:21.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:21.595]                     ...future.globalenv.names))
[17:45:21.595]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:21.595]         }, condition = base::local({
[17:45:21.595]             c <- base::c
[17:45:21.595]             inherits <- base::inherits
[17:45:21.595]             invokeRestart <- base::invokeRestart
[17:45:21.595]             length <- base::length
[17:45:21.595]             list <- base::list
[17:45:21.595]             seq.int <- base::seq.int
[17:45:21.595]             signalCondition <- base::signalCondition
[17:45:21.595]             sys.calls <- base::sys.calls
[17:45:21.595]             `[[` <- base::`[[`
[17:45:21.595]             `+` <- base::`+`
[17:45:21.595]             `<<-` <- base::`<<-`
[17:45:21.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:21.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:21.595]                   3L)]
[17:45:21.595]             }
[17:45:21.595]             function(cond) {
[17:45:21.595]                 is_error <- inherits(cond, "error")
[17:45:21.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:21.595]                   NULL)
[17:45:21.595]                 if (is_error) {
[17:45:21.595]                   sessionInformation <- function() {
[17:45:21.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:21.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:21.595]                       search = base::search(), system = base::Sys.info())
[17:45:21.595]                   }
[17:45:21.595]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:21.595]                     cond$call), session = sessionInformation(), 
[17:45:21.595]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:21.595]                   signalCondition(cond)
[17:45:21.595]                 }
[17:45:21.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:21.595]                 "immediateCondition"))) {
[17:45:21.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:21.595]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:21.595]                   if (TRUE && !signal) {
[17:45:21.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.595]                     {
[17:45:21.595]                       inherits <- base::inherits
[17:45:21.595]                       invokeRestart <- base::invokeRestart
[17:45:21.595]                       is.null <- base::is.null
[17:45:21.595]                       muffled <- FALSE
[17:45:21.595]                       if (inherits(cond, "message")) {
[17:45:21.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.595]                         if (muffled) 
[17:45:21.595]                           invokeRestart("muffleMessage")
[17:45:21.595]                       }
[17:45:21.595]                       else if (inherits(cond, "warning")) {
[17:45:21.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.595]                         if (muffled) 
[17:45:21.595]                           invokeRestart("muffleWarning")
[17:45:21.595]                       }
[17:45:21.595]                       else if (inherits(cond, "condition")) {
[17:45:21.595]                         if (!is.null(pattern)) {
[17:45:21.595]                           computeRestarts <- base::computeRestarts
[17:45:21.595]                           grepl <- base::grepl
[17:45:21.595]                           restarts <- computeRestarts(cond)
[17:45:21.595]                           for (restart in restarts) {
[17:45:21.595]                             name <- restart$name
[17:45:21.595]                             if (is.null(name)) 
[17:45:21.595]                               next
[17:45:21.595]                             if (!grepl(pattern, name)) 
[17:45:21.595]                               next
[17:45:21.595]                             invokeRestart(restart)
[17:45:21.595]                             muffled <- TRUE
[17:45:21.595]                             break
[17:45:21.595]                           }
[17:45:21.595]                         }
[17:45:21.595]                       }
[17:45:21.595]                       invisible(muffled)
[17:45:21.595]                     }
[17:45:21.595]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.595]                   }
[17:45:21.595]                 }
[17:45:21.595]                 else {
[17:45:21.595]                   if (TRUE) {
[17:45:21.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.595]                     {
[17:45:21.595]                       inherits <- base::inherits
[17:45:21.595]                       invokeRestart <- base::invokeRestart
[17:45:21.595]                       is.null <- base::is.null
[17:45:21.595]                       muffled <- FALSE
[17:45:21.595]                       if (inherits(cond, "message")) {
[17:45:21.595]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.595]                         if (muffled) 
[17:45:21.595]                           invokeRestart("muffleMessage")
[17:45:21.595]                       }
[17:45:21.595]                       else if (inherits(cond, "warning")) {
[17:45:21.595]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.595]                         if (muffled) 
[17:45:21.595]                           invokeRestart("muffleWarning")
[17:45:21.595]                       }
[17:45:21.595]                       else if (inherits(cond, "condition")) {
[17:45:21.595]                         if (!is.null(pattern)) {
[17:45:21.595]                           computeRestarts <- base::computeRestarts
[17:45:21.595]                           grepl <- base::grepl
[17:45:21.595]                           restarts <- computeRestarts(cond)
[17:45:21.595]                           for (restart in restarts) {
[17:45:21.595]                             name <- restart$name
[17:45:21.595]                             if (is.null(name)) 
[17:45:21.595]                               next
[17:45:21.595]                             if (!grepl(pattern, name)) 
[17:45:21.595]                               next
[17:45:21.595]                             invokeRestart(restart)
[17:45:21.595]                             muffled <- TRUE
[17:45:21.595]                             break
[17:45:21.595]                           }
[17:45:21.595]                         }
[17:45:21.595]                       }
[17:45:21.595]                       invisible(muffled)
[17:45:21.595]                     }
[17:45:21.595]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.595]                   }
[17:45:21.595]                 }
[17:45:21.595]             }
[17:45:21.595]         }))
[17:45:21.595]     }, error = function(ex) {
[17:45:21.595]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:21.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.595]                 ...future.rng), started = ...future.startTime, 
[17:45:21.595]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:21.595]             version = "1.8"), class = "FutureResult")
[17:45:21.595]     }, finally = {
[17:45:21.595]         if (!identical(...future.workdir, getwd())) 
[17:45:21.595]             setwd(...future.workdir)
[17:45:21.595]         {
[17:45:21.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:21.595]                 ...future.oldOptions$nwarnings <- NULL
[17:45:21.595]             }
[17:45:21.595]             base::options(...future.oldOptions)
[17:45:21.595]             if (.Platform$OS.type == "windows") {
[17:45:21.595]                 old_names <- names(...future.oldEnvVars)
[17:45:21.595]                 envs <- base::Sys.getenv()
[17:45:21.595]                 names <- names(envs)
[17:45:21.595]                 common <- intersect(names, old_names)
[17:45:21.595]                 added <- setdiff(names, old_names)
[17:45:21.595]                 removed <- setdiff(old_names, names)
[17:45:21.595]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:21.595]                   envs[common]]
[17:45:21.595]                 NAMES <- toupper(changed)
[17:45:21.595]                 args <- list()
[17:45:21.595]                 for (kk in seq_along(NAMES)) {
[17:45:21.595]                   name <- changed[[kk]]
[17:45:21.595]                   NAME <- NAMES[[kk]]
[17:45:21.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.595]                     next
[17:45:21.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.595]                 }
[17:45:21.595]                 NAMES <- toupper(added)
[17:45:21.595]                 for (kk in seq_along(NAMES)) {
[17:45:21.595]                   name <- added[[kk]]
[17:45:21.595]                   NAME <- NAMES[[kk]]
[17:45:21.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.595]                     next
[17:45:21.595]                   args[[name]] <- ""
[17:45:21.595]                 }
[17:45:21.595]                 NAMES <- toupper(removed)
[17:45:21.595]                 for (kk in seq_along(NAMES)) {
[17:45:21.595]                   name <- removed[[kk]]
[17:45:21.595]                   NAME <- NAMES[[kk]]
[17:45:21.595]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.595]                     next
[17:45:21.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.595]                 }
[17:45:21.595]                 if (length(args) > 0) 
[17:45:21.595]                   base::do.call(base::Sys.setenv, args = args)
[17:45:21.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:21.595]             }
[17:45:21.595]             else {
[17:45:21.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:21.595]             }
[17:45:21.595]             {
[17:45:21.595]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:21.595]                   0L) {
[17:45:21.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:21.595]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:21.595]                   base::options(opts)
[17:45:21.595]                 }
[17:45:21.595]                 {
[17:45:21.595]                   {
[17:45:21.595]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:21.595]                     NULL
[17:45:21.595]                   }
[17:45:21.595]                   options(future.plan = NULL)
[17:45:21.595]                   if (is.na(NA_character_)) 
[17:45:21.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:21.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:21.595]                     .init = FALSE)
[17:45:21.595]                 }
[17:45:21.595]             }
[17:45:21.595]         }
[17:45:21.595]     })
[17:45:21.595]     if (TRUE) {
[17:45:21.595]         base::sink(type = "output", split = FALSE)
[17:45:21.595]         if (TRUE) {
[17:45:21.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:21.595]         }
[17:45:21.595]         else {
[17:45:21.595]             ...future.result["stdout"] <- base::list(NULL)
[17:45:21.595]         }
[17:45:21.595]         base::close(...future.stdout)
[17:45:21.595]         ...future.stdout <- NULL
[17:45:21.595]     }
[17:45:21.595]     ...future.result$conditions <- ...future.conditions
[17:45:21.595]     ...future.result$finished <- base::Sys.time()
[17:45:21.595]     ...future.result
[17:45:21.595] }
[17:45:21.598] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[17:45:21.598] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:21.640] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:21.640] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:45:21.640] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:45:21.640] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:21.641] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:21.641] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:21.684] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:21.684] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:21.728] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:21.728] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:21.728] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.728] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:21.728] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:21.729] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:21.729] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.729] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:21.729] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:21.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:21.730] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:21.730] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:21.730] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[17:45:21.731] MultisessionFuture started
[17:45:21.731] - Launch lazy future ... done
[17:45:21.731] run() for ‘MultisessionFuture’ ... done
[17:45:21.731] Created future:
[17:45:21.731] MultisessionFuture:
[17:45:21.731] Label: ‘future_vapply-1’
[17:45:21.731] Expression:
[17:45:21.731] {
[17:45:21.731]     do.call(function(...) {
[17:45:21.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.731]             on.exit(options(oopts), add = TRUE)
[17:45:21.731]         }
[17:45:21.731]         {
[17:45:21.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.731]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.731]             })
[17:45:21.731]         }
[17:45:21.731]     }, args = future.call.arguments)
[17:45:21.731] }
[17:45:21.731] Lazy evaluation: FALSE
[17:45:21.731] Asynchronous evaluation: TRUE
[17:45:21.731] Local evaluation: TRUE
[17:45:21.731] Environment: R_GlobalEnv
[17:45:21.731] Capture standard output: TRUE
[17:45:21.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:21.731] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:21.731] Packages: 1 packages (‘future.apply’)
[17:45:21.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:21.731] Resolved: FALSE
[17:45:21.731] Value: <not collected>
[17:45:21.731] Conditions captured: <none>
[17:45:21.731] Early signaling: FALSE
[17:45:21.731] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:21.731] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.743] Chunk #1 of 2 ... DONE
[17:45:21.743] Chunk #2 of 2 ...
[17:45:21.743]  - Finding globals in 'X' for chunk #2 ...
[17:45:21.744] getGlobalsAndPackages() ...
[17:45:21.744] Searching for globals...
[17:45:21.744] 
[17:45:21.744] Searching for globals ... DONE
[17:45:21.744] - globals: [0] <none>
[17:45:21.744] getGlobalsAndPackages() ... DONE
[17:45:21.744]    + additional globals found: [n=0] 
[17:45:21.744]    + additional namespaces needed: [n=0] 
[17:45:21.745]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:21.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:21.745]  - seeds: <none>
[17:45:21.745]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.745] getGlobalsAndPackages() ...
[17:45:21.745] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.745] Resolving globals: FALSE
[17:45:21.745] Tweak future expression to call with '...' arguments ...
[17:45:21.745] {
[17:45:21.745]     do.call(function(...) {
[17:45:21.745]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.745]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.745]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.745]             on.exit(options(oopts), add = TRUE)
[17:45:21.745]         }
[17:45:21.745]         {
[17:45:21.745]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.745]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.745]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.745]             })
[17:45:21.745]         }
[17:45:21.745]     }, args = future.call.arguments)
[17:45:21.745] }
[17:45:21.746] Tweak future expression to call with '...' arguments ... DONE
[17:45:21.746] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.746] - packages: [1] ‘future.apply’
[17:45:21.746] getGlobalsAndPackages() ... DONE
[17:45:21.747] run() for ‘Future’ ...
[17:45:21.747] - state: ‘created’
[17:45:21.747] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:21.761] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:21.761]   - Field: ‘node’
[17:45:21.761]   - Field: ‘label’
[17:45:21.761]   - Field: ‘local’
[17:45:21.761]   - Field: ‘owner’
[17:45:21.761]   - Field: ‘envir’
[17:45:21.761]   - Field: ‘workers’
[17:45:21.762]   - Field: ‘packages’
[17:45:21.762]   - Field: ‘gc’
[17:45:21.762]   - Field: ‘conditions’
[17:45:21.762]   - Field: ‘persistent’
[17:45:21.762]   - Field: ‘expr’
[17:45:21.762]   - Field: ‘uuid’
[17:45:21.762]   - Field: ‘seed’
[17:45:21.762]   - Field: ‘version’
[17:45:21.762]   - Field: ‘result’
[17:45:21.762]   - Field: ‘asynchronous’
[17:45:21.762]   - Field: ‘calls’
[17:45:21.763]   - Field: ‘globals’
[17:45:21.763]   - Field: ‘stdout’
[17:45:21.763]   - Field: ‘earlySignal’
[17:45:21.763]   - Field: ‘lazy’
[17:45:21.763]   - Field: ‘state’
[17:45:21.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:21.763] - Launch lazy future ...
[17:45:21.763] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:21.763] Packages needed by future strategies (n = 0): <none>
[17:45:21.764] {
[17:45:21.764]     {
[17:45:21.764]         {
[17:45:21.764]             ...future.startTime <- base::Sys.time()
[17:45:21.764]             {
[17:45:21.764]                 {
[17:45:21.764]                   {
[17:45:21.764]                     {
[17:45:21.764]                       {
[17:45:21.764]                         base::local({
[17:45:21.764]                           has_future <- base::requireNamespace("future", 
[17:45:21.764]                             quietly = TRUE)
[17:45:21.764]                           if (has_future) {
[17:45:21.764]                             ns <- base::getNamespace("future")
[17:45:21.764]                             version <- ns[[".package"]][["version"]]
[17:45:21.764]                             if (is.null(version)) 
[17:45:21.764]                               version <- utils::packageVersion("future")
[17:45:21.764]                           }
[17:45:21.764]                           else {
[17:45:21.764]                             version <- NULL
[17:45:21.764]                           }
[17:45:21.764]                           if (!has_future || version < "1.8.0") {
[17:45:21.764]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:21.764]                               "", base::R.version$version.string), 
[17:45:21.764]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:21.764]                                 base::R.version$platform, 8 * 
[17:45:21.764]                                   base::.Machine$sizeof.pointer), 
[17:45:21.764]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:21.764]                                 "release", "version")], collapse = " "), 
[17:45:21.764]                               hostname = base::Sys.info()[["nodename"]])
[17:45:21.764]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:21.764]                               info)
[17:45:21.764]                             info <- base::paste(info, collapse = "; ")
[17:45:21.764]                             if (!has_future) {
[17:45:21.764]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:21.764]                                 info)
[17:45:21.764]                             }
[17:45:21.764]                             else {
[17:45:21.764]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:21.764]                                 info, version)
[17:45:21.764]                             }
[17:45:21.764]                             base::stop(msg)
[17:45:21.764]                           }
[17:45:21.764]                         })
[17:45:21.764]                       }
[17:45:21.764]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:21.764]                       base::options(mc.cores = 1L)
[17:45:21.764]                     }
[17:45:21.764]                     base::local({
[17:45:21.764]                       for (pkg in "future.apply") {
[17:45:21.764]                         base::loadNamespace(pkg)
[17:45:21.764]                         base::library(pkg, character.only = TRUE)
[17:45:21.764]                       }
[17:45:21.764]                     })
[17:45:21.764]                   }
[17:45:21.764]                   ...future.strategy.old <- future::plan("list")
[17:45:21.764]                   options(future.plan = NULL)
[17:45:21.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:21.764]                 }
[17:45:21.764]                 ...future.workdir <- getwd()
[17:45:21.764]             }
[17:45:21.764]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:21.764]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:21.764]         }
[17:45:21.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:21.764]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:21.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:21.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:21.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:21.764]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:21.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:21.764]             base::names(...future.oldOptions))
[17:45:21.764]     }
[17:45:21.764]     if (FALSE) {
[17:45:21.764]     }
[17:45:21.764]     else {
[17:45:21.764]         if (TRUE) {
[17:45:21.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:21.764]                 open = "w")
[17:45:21.764]         }
[17:45:21.764]         else {
[17:45:21.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:21.764]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:21.764]         }
[17:45:21.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:21.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:21.764]             base::sink(type = "output", split = FALSE)
[17:45:21.764]             base::close(...future.stdout)
[17:45:21.764]         }, add = TRUE)
[17:45:21.764]     }
[17:45:21.764]     ...future.frame <- base::sys.nframe()
[17:45:21.764]     ...future.conditions <- base::list()
[17:45:21.764]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:21.764]     if (FALSE) {
[17:45:21.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:21.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:21.764]     }
[17:45:21.764]     ...future.result <- base::tryCatch({
[17:45:21.764]         base::withCallingHandlers({
[17:45:21.764]             ...future.value <- base::withVisible(base::local({
[17:45:21.764]                 ...future.makeSendCondition <- base::local({
[17:45:21.764]                   sendCondition <- NULL
[17:45:21.764]                   function(frame = 1L) {
[17:45:21.764]                     if (is.function(sendCondition)) 
[17:45:21.764]                       return(sendCondition)
[17:45:21.764]                     ns <- getNamespace("parallel")
[17:45:21.764]                     if (exists("sendData", mode = "function", 
[17:45:21.764]                       envir = ns)) {
[17:45:21.764]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:21.764]                         envir = ns)
[17:45:21.764]                       envir <- sys.frame(frame)
[17:45:21.764]                       master <- NULL
[17:45:21.764]                       while (!identical(envir, .GlobalEnv) && 
[17:45:21.764]                         !identical(envir, emptyenv())) {
[17:45:21.764]                         if (exists("master", mode = "list", envir = envir, 
[17:45:21.764]                           inherits = FALSE)) {
[17:45:21.764]                           master <- get("master", mode = "list", 
[17:45:21.764]                             envir = envir, inherits = FALSE)
[17:45:21.764]                           if (inherits(master, c("SOCKnode", 
[17:45:21.764]                             "SOCK0node"))) {
[17:45:21.764]                             sendCondition <<- function(cond) {
[17:45:21.764]                               data <- list(type = "VALUE", value = cond, 
[17:45:21.764]                                 success = TRUE)
[17:45:21.764]                               parallel_sendData(master, data)
[17:45:21.764]                             }
[17:45:21.764]                             return(sendCondition)
[17:45:21.764]                           }
[17:45:21.764]                         }
[17:45:21.764]                         frame <- frame + 1L
[17:45:21.764]                         envir <- sys.frame(frame)
[17:45:21.764]                       }
[17:45:21.764]                     }
[17:45:21.764]                     sendCondition <<- function(cond) NULL
[17:45:21.764]                   }
[17:45:21.764]                 })
[17:45:21.764]                 withCallingHandlers({
[17:45:21.764]                   {
[17:45:21.764]                     do.call(function(...) {
[17:45:21.764]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.764]                       if (!identical(...future.globals.maxSize.org, 
[17:45:21.764]                         ...future.globals.maxSize)) {
[17:45:21.764]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.764]                         on.exit(options(oopts), add = TRUE)
[17:45:21.764]                       }
[17:45:21.764]                       {
[17:45:21.764]                         lapply(seq_along(...future.elements_ii), 
[17:45:21.764]                           FUN = function(jj) {
[17:45:21.764]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.764]                             ...future.FUN(...future.X_jj, ...)
[17:45:21.764]                           })
[17:45:21.764]                       }
[17:45:21.764]                     }, args = future.call.arguments)
[17:45:21.764]                   }
[17:45:21.764]                 }, immediateCondition = function(cond) {
[17:45:21.764]                   sendCondition <- ...future.makeSendCondition()
[17:45:21.764]                   sendCondition(cond)
[17:45:21.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.764]                   {
[17:45:21.764]                     inherits <- base::inherits
[17:45:21.764]                     invokeRestart <- base::invokeRestart
[17:45:21.764]                     is.null <- base::is.null
[17:45:21.764]                     muffled <- FALSE
[17:45:21.764]                     if (inherits(cond, "message")) {
[17:45:21.764]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:21.764]                       if (muffled) 
[17:45:21.764]                         invokeRestart("muffleMessage")
[17:45:21.764]                     }
[17:45:21.764]                     else if (inherits(cond, "warning")) {
[17:45:21.764]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:21.764]                       if (muffled) 
[17:45:21.764]                         invokeRestart("muffleWarning")
[17:45:21.764]                     }
[17:45:21.764]                     else if (inherits(cond, "condition")) {
[17:45:21.764]                       if (!is.null(pattern)) {
[17:45:21.764]                         computeRestarts <- base::computeRestarts
[17:45:21.764]                         grepl <- base::grepl
[17:45:21.764]                         restarts <- computeRestarts(cond)
[17:45:21.764]                         for (restart in restarts) {
[17:45:21.764]                           name <- restart$name
[17:45:21.764]                           if (is.null(name)) 
[17:45:21.764]                             next
[17:45:21.764]                           if (!grepl(pattern, name)) 
[17:45:21.764]                             next
[17:45:21.764]                           invokeRestart(restart)
[17:45:21.764]                           muffled <- TRUE
[17:45:21.764]                           break
[17:45:21.764]                         }
[17:45:21.764]                       }
[17:45:21.764]                     }
[17:45:21.764]                     invisible(muffled)
[17:45:21.764]                   }
[17:45:21.764]                   muffleCondition(cond)
[17:45:21.764]                 })
[17:45:21.764]             }))
[17:45:21.764]             future::FutureResult(value = ...future.value$value, 
[17:45:21.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.764]                   ...future.rng), globalenv = if (FALSE) 
[17:45:21.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:21.764]                     ...future.globalenv.names))
[17:45:21.764]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:21.764]         }, condition = base::local({
[17:45:21.764]             c <- base::c
[17:45:21.764]             inherits <- base::inherits
[17:45:21.764]             invokeRestart <- base::invokeRestart
[17:45:21.764]             length <- base::length
[17:45:21.764]             list <- base::list
[17:45:21.764]             seq.int <- base::seq.int
[17:45:21.764]             signalCondition <- base::signalCondition
[17:45:21.764]             sys.calls <- base::sys.calls
[17:45:21.764]             `[[` <- base::`[[`
[17:45:21.764]             `+` <- base::`+`
[17:45:21.764]             `<<-` <- base::`<<-`
[17:45:21.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:21.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:21.764]                   3L)]
[17:45:21.764]             }
[17:45:21.764]             function(cond) {
[17:45:21.764]                 is_error <- inherits(cond, "error")
[17:45:21.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:21.764]                   NULL)
[17:45:21.764]                 if (is_error) {
[17:45:21.764]                   sessionInformation <- function() {
[17:45:21.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:21.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:21.764]                       search = base::search(), system = base::Sys.info())
[17:45:21.764]                   }
[17:45:21.764]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:21.764]                     cond$call), session = sessionInformation(), 
[17:45:21.764]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:21.764]                   signalCondition(cond)
[17:45:21.764]                 }
[17:45:21.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:21.764]                 "immediateCondition"))) {
[17:45:21.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:21.764]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:21.764]                   if (TRUE && !signal) {
[17:45:21.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.764]                     {
[17:45:21.764]                       inherits <- base::inherits
[17:45:21.764]                       invokeRestart <- base::invokeRestart
[17:45:21.764]                       is.null <- base::is.null
[17:45:21.764]                       muffled <- FALSE
[17:45:21.764]                       if (inherits(cond, "message")) {
[17:45:21.764]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.764]                         if (muffled) 
[17:45:21.764]                           invokeRestart("muffleMessage")
[17:45:21.764]                       }
[17:45:21.764]                       else if (inherits(cond, "warning")) {
[17:45:21.764]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.764]                         if (muffled) 
[17:45:21.764]                           invokeRestart("muffleWarning")
[17:45:21.764]                       }
[17:45:21.764]                       else if (inherits(cond, "condition")) {
[17:45:21.764]                         if (!is.null(pattern)) {
[17:45:21.764]                           computeRestarts <- base::computeRestarts
[17:45:21.764]                           grepl <- base::grepl
[17:45:21.764]                           restarts <- computeRestarts(cond)
[17:45:21.764]                           for (restart in restarts) {
[17:45:21.764]                             name <- restart$name
[17:45:21.764]                             if (is.null(name)) 
[17:45:21.764]                               next
[17:45:21.764]                             if (!grepl(pattern, name)) 
[17:45:21.764]                               next
[17:45:21.764]                             invokeRestart(restart)
[17:45:21.764]                             muffled <- TRUE
[17:45:21.764]                             break
[17:45:21.764]                           }
[17:45:21.764]                         }
[17:45:21.764]                       }
[17:45:21.764]                       invisible(muffled)
[17:45:21.764]                     }
[17:45:21.764]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.764]                   }
[17:45:21.764]                 }
[17:45:21.764]                 else {
[17:45:21.764]                   if (TRUE) {
[17:45:21.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.764]                     {
[17:45:21.764]                       inherits <- base::inherits
[17:45:21.764]                       invokeRestart <- base::invokeRestart
[17:45:21.764]                       is.null <- base::is.null
[17:45:21.764]                       muffled <- FALSE
[17:45:21.764]                       if (inherits(cond, "message")) {
[17:45:21.764]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.764]                         if (muffled) 
[17:45:21.764]                           invokeRestart("muffleMessage")
[17:45:21.764]                       }
[17:45:21.764]                       else if (inherits(cond, "warning")) {
[17:45:21.764]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.764]                         if (muffled) 
[17:45:21.764]                           invokeRestart("muffleWarning")
[17:45:21.764]                       }
[17:45:21.764]                       else if (inherits(cond, "condition")) {
[17:45:21.764]                         if (!is.null(pattern)) {
[17:45:21.764]                           computeRestarts <- base::computeRestarts
[17:45:21.764]                           grepl <- base::grepl
[17:45:21.764]                           restarts <- computeRestarts(cond)
[17:45:21.764]                           for (restart in restarts) {
[17:45:21.764]                             name <- restart$name
[17:45:21.764]                             if (is.null(name)) 
[17:45:21.764]                               next
[17:45:21.764]                             if (!grepl(pattern, name)) 
[17:45:21.764]                               next
[17:45:21.764]                             invokeRestart(restart)
[17:45:21.764]                             muffled <- TRUE
[17:45:21.764]                             break
[17:45:21.764]                           }
[17:45:21.764]                         }
[17:45:21.764]                       }
[17:45:21.764]                       invisible(muffled)
[17:45:21.764]                     }
[17:45:21.764]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.764]                   }
[17:45:21.764]                 }
[17:45:21.764]             }
[17:45:21.764]         }))
[17:45:21.764]     }, error = function(ex) {
[17:45:21.764]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:21.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.764]                 ...future.rng), started = ...future.startTime, 
[17:45:21.764]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:21.764]             version = "1.8"), class = "FutureResult")
[17:45:21.764]     }, finally = {
[17:45:21.764]         if (!identical(...future.workdir, getwd())) 
[17:45:21.764]             setwd(...future.workdir)
[17:45:21.764]         {
[17:45:21.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:21.764]                 ...future.oldOptions$nwarnings <- NULL
[17:45:21.764]             }
[17:45:21.764]             base::options(...future.oldOptions)
[17:45:21.764]             if (.Platform$OS.type == "windows") {
[17:45:21.764]                 old_names <- names(...future.oldEnvVars)
[17:45:21.764]                 envs <- base::Sys.getenv()
[17:45:21.764]                 names <- names(envs)
[17:45:21.764]                 common <- intersect(names, old_names)
[17:45:21.764]                 added <- setdiff(names, old_names)
[17:45:21.764]                 removed <- setdiff(old_names, names)
[17:45:21.764]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:21.764]                   envs[common]]
[17:45:21.764]                 NAMES <- toupper(changed)
[17:45:21.764]                 args <- list()
[17:45:21.764]                 for (kk in seq_along(NAMES)) {
[17:45:21.764]                   name <- changed[[kk]]
[17:45:21.764]                   NAME <- NAMES[[kk]]
[17:45:21.764]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.764]                     next
[17:45:21.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.764]                 }
[17:45:21.764]                 NAMES <- toupper(added)
[17:45:21.764]                 for (kk in seq_along(NAMES)) {
[17:45:21.764]                   name <- added[[kk]]
[17:45:21.764]                   NAME <- NAMES[[kk]]
[17:45:21.764]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.764]                     next
[17:45:21.764]                   args[[name]] <- ""
[17:45:21.764]                 }
[17:45:21.764]                 NAMES <- toupper(removed)
[17:45:21.764]                 for (kk in seq_along(NAMES)) {
[17:45:21.764]                   name <- removed[[kk]]
[17:45:21.764]                   NAME <- NAMES[[kk]]
[17:45:21.764]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.764]                     next
[17:45:21.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.764]                 }
[17:45:21.764]                 if (length(args) > 0) 
[17:45:21.764]                   base::do.call(base::Sys.setenv, args = args)
[17:45:21.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:21.764]             }
[17:45:21.764]             else {
[17:45:21.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:21.764]             }
[17:45:21.764]             {
[17:45:21.764]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:21.764]                   0L) {
[17:45:21.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:21.764]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:21.764]                   base::options(opts)
[17:45:21.764]                 }
[17:45:21.764]                 {
[17:45:21.764]                   {
[17:45:21.764]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:21.764]                     NULL
[17:45:21.764]                   }
[17:45:21.764]                   options(future.plan = NULL)
[17:45:21.764]                   if (is.na(NA_character_)) 
[17:45:21.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:21.764]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:21.764]                     .init = FALSE)
[17:45:21.764]                 }
[17:45:21.764]             }
[17:45:21.764]         }
[17:45:21.764]     })
[17:45:21.764]     if (TRUE) {
[17:45:21.764]         base::sink(type = "output", split = FALSE)
[17:45:21.764]         if (TRUE) {
[17:45:21.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:21.764]         }
[17:45:21.764]         else {
[17:45:21.764]             ...future.result["stdout"] <- base::list(NULL)
[17:45:21.764]         }
[17:45:21.764]         base::close(...future.stdout)
[17:45:21.764]         ...future.stdout <- NULL
[17:45:21.764]     }
[17:45:21.764]     ...future.result$conditions <- ...future.conditions
[17:45:21.764]     ...future.result$finished <- base::Sys.time()
[17:45:21.764]     ...future.result
[17:45:21.764] }
[17:45:21.767] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[17:45:21.767] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:21.808] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:21.808] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:45:21.808] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:45:21.808] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:21.809] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:21.809] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:21.852] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:21.852] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:21.896] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:21.896] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:21.896] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.896] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:45:21.897] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:45:21.897] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:21.897] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.897] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:45:21.898] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:45:21.898] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:21.898] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.898] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:21.899] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:21.899] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[17:45:21.899] MultisessionFuture started
[17:45:21.900] - Launch lazy future ... done
[17:45:21.900] run() for ‘MultisessionFuture’ ... done
[17:45:21.900] Created future:
[17:45:21.901] receiveMessageFromWorker() for ClusterFuture ...
[17:45:21.901] - Validating connection of MultisessionFuture
[17:45:21.902] - received message: FutureResult
[17:45:21.902] - Received FutureResult
[17:45:21.902] - Erased future from FutureRegistry
[17:45:21.902] result() for ClusterFuture ...
[17:45:21.902] - result already collected: FutureResult
[17:45:21.902] result() for ClusterFuture ... done
[17:45:21.902] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:21.900] MultisessionFuture:
[17:45:21.900] Label: ‘future_vapply-2’
[17:45:21.900] Expression:
[17:45:21.900] {
[17:45:21.900]     do.call(function(...) {
[17:45:21.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.900]             on.exit(options(oopts), add = TRUE)
[17:45:21.900]         }
[17:45:21.900]         {
[17:45:21.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.900]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.900]             })
[17:45:21.900]         }
[17:45:21.900]     }, args = future.call.arguments)
[17:45:21.900] }
[17:45:21.900] Lazy evaluation: FALSE
[17:45:21.900] Asynchronous evaluation: TRUE
[17:45:21.900] Local evaluation: TRUE
[17:45:21.900] Environment: R_GlobalEnv
[17:45:21.900] Capture standard output: TRUE
[17:45:21.900] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:21.900] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:21.900] Packages: 1 packages (‘future.apply’)
[17:45:21.900] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:21.900] Resolved: TRUE
[17:45:21.900] Value: <not collected>
[17:45:21.900] Conditions captured: <none>
[17:45:21.900] Early signaling: FALSE
[17:45:21.900] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:21.900] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.902] Chunk #2 of 2 ... DONE
[17:45:21.903] Launching 2 futures (chunks) ... DONE
[17:45:21.903] Resolving 2 futures (chunks) ...
[17:45:21.903] resolve() on list ...
[17:45:21.903]  recursive: 0
[17:45:21.903]  length: 2
[17:45:21.903] 
[17:45:21.903] receiveMessageFromWorker() for ClusterFuture ...
[17:45:21.904] - Validating connection of MultisessionFuture
[17:45:21.904] - received message: FutureResult
[17:45:21.904] - Received FutureResult
[17:45:21.904] - Erased future from FutureRegistry
[17:45:21.904] result() for ClusterFuture ...
[17:45:21.904] - result already collected: FutureResult
[17:45:21.904] result() for ClusterFuture ... done
[17:45:21.904] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:21.904] Future #1
[17:45:21.905] result() for ClusterFuture ...
[17:45:21.905] - result already collected: FutureResult
[17:45:21.905] result() for ClusterFuture ... done
[17:45:21.905] result() for ClusterFuture ...
[17:45:21.905] - result already collected: FutureResult
[17:45:21.905] result() for ClusterFuture ... done
[17:45:21.905] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:21.905] - nx: 2
[17:45:21.905] - relay: TRUE
[17:45:21.905] - stdout: TRUE
[17:45:21.905] - signal: TRUE
[17:45:21.905] - resignal: FALSE
[17:45:21.906] - force: TRUE
[17:45:21.906] - relayed: [n=2] FALSE, FALSE
[17:45:21.906] - queued futures: [n=2] FALSE, FALSE
[17:45:21.906]  - until=1
[17:45:21.906]  - relaying element #1
[17:45:21.906] result() for ClusterFuture ...
[17:45:21.906] - result already collected: FutureResult
[17:45:21.906] result() for ClusterFuture ... done
[17:45:21.906] result() for ClusterFuture ...
[17:45:21.906] - result already collected: FutureResult
[17:45:21.906] result() for ClusterFuture ... done
[17:45:21.907] result() for ClusterFuture ...
[17:45:21.907] - result already collected: FutureResult
[17:45:21.907] result() for ClusterFuture ... done
[17:45:21.907] result() for ClusterFuture ...
[17:45:21.907] - result already collected: FutureResult
[17:45:21.907] result() for ClusterFuture ... done
[17:45:21.907] - relayed: [n=2] TRUE, FALSE
[17:45:21.907] - queued futures: [n=2] TRUE, FALSE
[17:45:21.907] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:21.907]  length: 1 (resolved future 1)
[17:45:21.907] Future #2
[17:45:21.907] result() for ClusterFuture ...
[17:45:21.908] - result already collected: FutureResult
[17:45:21.908] result() for ClusterFuture ... done
[17:45:21.908] result() for ClusterFuture ...
[17:45:21.908] - result already collected: FutureResult
[17:45:21.908] result() for ClusterFuture ... done
[17:45:21.908] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:21.908] - nx: 2
[17:45:21.908] - relay: TRUE
[17:45:21.908] - stdout: TRUE
[17:45:21.908] - signal: TRUE
[17:45:21.908] - resignal: FALSE
[17:45:21.908] - force: TRUE
[17:45:21.909] - relayed: [n=2] TRUE, FALSE
[17:45:21.909] - queued futures: [n=2] TRUE, FALSE
[17:45:21.909]  - until=2
[17:45:21.909]  - relaying element #2
[17:45:21.909] result() for ClusterFuture ...
[17:45:21.909] - result already collected: FutureResult
[17:45:21.909] result() for ClusterFuture ... done
[17:45:21.909] result() for ClusterFuture ...
[17:45:21.909] - result already collected: FutureResult
[17:45:21.909] result() for ClusterFuture ... done
[17:45:21.909] result() for ClusterFuture ...
[17:45:21.910] - result already collected: FutureResult
[17:45:21.910] result() for ClusterFuture ... done
[17:45:21.910] result() for ClusterFuture ...
[17:45:21.910] - result already collected: FutureResult
[17:45:21.910] result() for ClusterFuture ... done
[17:45:21.910] - relayed: [n=2] TRUE, TRUE
[17:45:21.910] - queued futures: [n=2] TRUE, TRUE
[17:45:21.910] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:21.910]  length: 0 (resolved future 2)
[17:45:21.910] Relaying remaining futures
[17:45:21.910] signalConditionsASAP(NULL, pos=0) ...
[17:45:21.910] - nx: 2
[17:45:21.910] - relay: TRUE
[17:45:21.911] - stdout: TRUE
[17:45:21.911] - signal: TRUE
[17:45:21.911] - resignal: FALSE
[17:45:21.911] - force: TRUE
[17:45:21.911] - relayed: [n=2] TRUE, TRUE
[17:45:21.911] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:21.911] - relayed: [n=2] TRUE, TRUE
[17:45:21.911] - queued futures: [n=2] TRUE, TRUE
[17:45:21.911] signalConditionsASAP(NULL, pos=0) ... done
[17:45:21.911] resolve() on list ... DONE
[17:45:21.911] result() for ClusterFuture ...
[17:45:21.912] - result already collected: FutureResult
[17:45:21.912] result() for ClusterFuture ... done
[17:45:21.912] result() for ClusterFuture ...
[17:45:21.912] - result already collected: FutureResult
[17:45:21.912] result() for ClusterFuture ... done
[17:45:21.912] result() for ClusterFuture ...
[17:45:21.912] - result already collected: FutureResult
[17:45:21.912] result() for ClusterFuture ... done
[17:45:21.912] result() for ClusterFuture ...
[17:45:21.912] - result already collected: FutureResult
[17:45:21.912] result() for ClusterFuture ... done
[17:45:21.912]  - Number of value chunks collected: 2
[17:45:21.913] Resolving 2 futures (chunks) ... DONE
[17:45:21.913] Reducing values from 2 chunks ...
[17:45:21.913]  - Number of values collected after concatenation: 10
[17:45:21.913]  - Number of values expected: 10
[17:45:21.913] Reducing values from 2 chunks ... DONE
[17:45:21.913] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[17:45:21.914] future_lapply() ...
[17:45:21.919] Number of chunks: 2
[17:45:21.919] getGlobalsAndPackagesXApply() ...
[17:45:21.919]  - future.globals: TRUE
[17:45:21.919] getGlobalsAndPackages() ...
[17:45:21.920] Searching for globals...
[17:45:21.925] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[17:45:21.925] Searching for globals ... DONE
[17:45:21.925] Resolving globals: FALSE
[17:45:21.926] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[17:45:21.926] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:21.927] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:21.927] - packages: [1] ‘future.apply’
[17:45:21.927] getGlobalsAndPackages() ... DONE
[17:45:21.927]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:21.927]  - needed namespaces: [n=1] ‘future.apply’
[17:45:21.927] Finding globals ... DONE
[17:45:21.927]  - use_args: TRUE
[17:45:21.927]  - Getting '...' globals ...
[17:45:21.928] resolve() on list ...
[17:45:21.928]  recursive: 0
[17:45:21.928]  length: 1
[17:45:21.928]  elements: ‘...’
[17:45:21.928]  length: 0 (resolved future 1)
[17:45:21.928] resolve() on list ... DONE
[17:45:21.928]    - '...' content: [n=0] 
[17:45:21.928] List of 1
[17:45:21.928]  $ ...: list()
[17:45:21.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:21.928]  - attr(*, "where")=List of 1
[17:45:21.928]   ..$ ...:<environment: 0x5561f81b1538> 
[17:45:21.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:21.928]  - attr(*, "resolved")= logi TRUE
[17:45:21.928]  - attr(*, "total_size")= num NA
[17:45:21.931]  - Getting '...' globals ... DONE
[17:45:21.931] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:21.931] List of 8
[17:45:21.931]  $ ...future.FUN:function (x, ...)  
[17:45:21.931]  $ x_FUN        :function (x)  
[17:45:21.931]  $ times        : int 0
[17:45:21.931]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:21.931]  $ stop_if_not  :function (...)  
[17:45:21.931]  $ dim          : NULL
[17:45:21.931]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:21.931]  $ ...          : list()
[17:45:21.931]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:21.931]  - attr(*, "where")=List of 8
[17:45:21.931]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:21.931]   ..$ ...          :<environment: 0x5561f81b1538> 
[17:45:21.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:21.931]  - attr(*, "resolved")= logi FALSE
[17:45:21.931]  - attr(*, "total_size")= num 95400
[17:45:21.936] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:21.936] getGlobalsAndPackagesXApply() ... DONE
[17:45:21.936] Number of futures (= number of chunks): 2
[17:45:21.937] Launching 2 futures (chunks) ...
[17:45:21.937] Chunk #1 of 2 ...
[17:45:21.937]  - Finding globals in 'X' for chunk #1 ...
[17:45:21.937] getGlobalsAndPackages() ...
[17:45:21.937] Searching for globals...
[17:45:21.937] 
[17:45:21.937] Searching for globals ... DONE
[17:45:21.937] - globals: [0] <none>
[17:45:21.938] getGlobalsAndPackages() ... DONE
[17:45:21.938]    + additional globals found: [n=0] 
[17:45:21.938]    + additional namespaces needed: [n=0] 
[17:45:21.938]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:21.938]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:21.938]  - seeds: <none>
[17:45:21.938]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.938] getGlobalsAndPackages() ...
[17:45:21.938] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.938] Resolving globals: FALSE
[17:45:21.938] Tweak future expression to call with '...' arguments ...
[17:45:21.939] {
[17:45:21.939]     do.call(function(...) {
[17:45:21.939]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.939]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:21.939]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.939]             on.exit(options(oopts), add = TRUE)
[17:45:21.939]         }
[17:45:21.939]         {
[17:45:21.939]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:21.939]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.939]                 ...future.FUN(...future.X_jj, ...)
[17:45:21.939]             })
[17:45:21.939]         }
[17:45:21.939]     }, args = future.call.arguments)
[17:45:21.939] }
[17:45:21.939] Tweak future expression to call with '...' arguments ... DONE
[17:45:21.939] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:21.940] - packages: [1] ‘future.apply’
[17:45:21.940] getGlobalsAndPackages() ... DONE
[17:45:21.940] run() for ‘Future’ ...
[17:45:21.940] - state: ‘created’
[17:45:21.940] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:21.954] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:21.954] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:21.955]   - Field: ‘node’
[17:45:21.955]   - Field: ‘label’
[17:45:21.955]   - Field: ‘local’
[17:45:21.955]   - Field: ‘owner’
[17:45:21.955]   - Field: ‘envir’
[17:45:21.955]   - Field: ‘workers’
[17:45:21.955]   - Field: ‘packages’
[17:45:21.955]   - Field: ‘gc’
[17:45:21.955]   - Field: ‘conditions’
[17:45:21.955]   - Field: ‘persistent’
[17:45:21.956]   - Field: ‘expr’
[17:45:21.956]   - Field: ‘uuid’
[17:45:21.956]   - Field: ‘seed’
[17:45:21.956]   - Field: ‘version’
[17:45:21.956]   - Field: ‘result’
[17:45:21.956]   - Field: ‘asynchronous’
[17:45:21.956]   - Field: ‘calls’
[17:45:21.956]   - Field: ‘globals’
[17:45:21.956]   - Field: ‘stdout’
[17:45:21.956]   - Field: ‘earlySignal’
[17:45:21.956]   - Field: ‘lazy’
[17:45:21.956]   - Field: ‘state’
[17:45:21.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:21.957] - Launch lazy future ...
[17:45:21.957] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:21.957] Packages needed by future strategies (n = 0): <none>
[17:45:21.958] {
[17:45:21.958]     {
[17:45:21.958]         {
[17:45:21.958]             ...future.startTime <- base::Sys.time()
[17:45:21.958]             {
[17:45:21.958]                 {
[17:45:21.958]                   {
[17:45:21.958]                     {
[17:45:21.958]                       {
[17:45:21.958]                         base::local({
[17:45:21.958]                           has_future <- base::requireNamespace("future", 
[17:45:21.958]                             quietly = TRUE)
[17:45:21.958]                           if (has_future) {
[17:45:21.958]                             ns <- base::getNamespace("future")
[17:45:21.958]                             version <- ns[[".package"]][["version"]]
[17:45:21.958]                             if (is.null(version)) 
[17:45:21.958]                               version <- utils::packageVersion("future")
[17:45:21.958]                           }
[17:45:21.958]                           else {
[17:45:21.958]                             version <- NULL
[17:45:21.958]                           }
[17:45:21.958]                           if (!has_future || version < "1.8.0") {
[17:45:21.958]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:21.958]                               "", base::R.version$version.string), 
[17:45:21.958]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:21.958]                                 base::R.version$platform, 8 * 
[17:45:21.958]                                   base::.Machine$sizeof.pointer), 
[17:45:21.958]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:21.958]                                 "release", "version")], collapse = " "), 
[17:45:21.958]                               hostname = base::Sys.info()[["nodename"]])
[17:45:21.958]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:21.958]                               info)
[17:45:21.958]                             info <- base::paste(info, collapse = "; ")
[17:45:21.958]                             if (!has_future) {
[17:45:21.958]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:21.958]                                 info)
[17:45:21.958]                             }
[17:45:21.958]                             else {
[17:45:21.958]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:21.958]                                 info, version)
[17:45:21.958]                             }
[17:45:21.958]                             base::stop(msg)
[17:45:21.958]                           }
[17:45:21.958]                         })
[17:45:21.958]                       }
[17:45:21.958]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:21.958]                       base::options(mc.cores = 1L)
[17:45:21.958]                     }
[17:45:21.958]                     base::local({
[17:45:21.958]                       for (pkg in "future.apply") {
[17:45:21.958]                         base::loadNamespace(pkg)
[17:45:21.958]                         base::library(pkg, character.only = TRUE)
[17:45:21.958]                       }
[17:45:21.958]                     })
[17:45:21.958]                   }
[17:45:21.958]                   ...future.strategy.old <- future::plan("list")
[17:45:21.958]                   options(future.plan = NULL)
[17:45:21.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:21.958]                 }
[17:45:21.958]                 ...future.workdir <- getwd()
[17:45:21.958]             }
[17:45:21.958]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:21.958]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:21.958]         }
[17:45:21.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:21.958]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:21.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:21.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:21.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:21.958]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:21.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:21.958]             base::names(...future.oldOptions))
[17:45:21.958]     }
[17:45:21.958]     if (FALSE) {
[17:45:21.958]     }
[17:45:21.958]     else {
[17:45:21.958]         if (TRUE) {
[17:45:21.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:21.958]                 open = "w")
[17:45:21.958]         }
[17:45:21.958]         else {
[17:45:21.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:21.958]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:21.958]         }
[17:45:21.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:21.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:21.958]             base::sink(type = "output", split = FALSE)
[17:45:21.958]             base::close(...future.stdout)
[17:45:21.958]         }, add = TRUE)
[17:45:21.958]     }
[17:45:21.958]     ...future.frame <- base::sys.nframe()
[17:45:21.958]     ...future.conditions <- base::list()
[17:45:21.958]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:21.958]     if (FALSE) {
[17:45:21.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:21.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:21.958]     }
[17:45:21.958]     ...future.result <- base::tryCatch({
[17:45:21.958]         base::withCallingHandlers({
[17:45:21.958]             ...future.value <- base::withVisible(base::local({
[17:45:21.958]                 ...future.makeSendCondition <- base::local({
[17:45:21.958]                   sendCondition <- NULL
[17:45:21.958]                   function(frame = 1L) {
[17:45:21.958]                     if (is.function(sendCondition)) 
[17:45:21.958]                       return(sendCondition)
[17:45:21.958]                     ns <- getNamespace("parallel")
[17:45:21.958]                     if (exists("sendData", mode = "function", 
[17:45:21.958]                       envir = ns)) {
[17:45:21.958]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:21.958]                         envir = ns)
[17:45:21.958]                       envir <- sys.frame(frame)
[17:45:21.958]                       master <- NULL
[17:45:21.958]                       while (!identical(envir, .GlobalEnv) && 
[17:45:21.958]                         !identical(envir, emptyenv())) {
[17:45:21.958]                         if (exists("master", mode = "list", envir = envir, 
[17:45:21.958]                           inherits = FALSE)) {
[17:45:21.958]                           master <- get("master", mode = "list", 
[17:45:21.958]                             envir = envir, inherits = FALSE)
[17:45:21.958]                           if (inherits(master, c("SOCKnode", 
[17:45:21.958]                             "SOCK0node"))) {
[17:45:21.958]                             sendCondition <<- function(cond) {
[17:45:21.958]                               data <- list(type = "VALUE", value = cond, 
[17:45:21.958]                                 success = TRUE)
[17:45:21.958]                               parallel_sendData(master, data)
[17:45:21.958]                             }
[17:45:21.958]                             return(sendCondition)
[17:45:21.958]                           }
[17:45:21.958]                         }
[17:45:21.958]                         frame <- frame + 1L
[17:45:21.958]                         envir <- sys.frame(frame)
[17:45:21.958]                       }
[17:45:21.958]                     }
[17:45:21.958]                     sendCondition <<- function(cond) NULL
[17:45:21.958]                   }
[17:45:21.958]                 })
[17:45:21.958]                 withCallingHandlers({
[17:45:21.958]                   {
[17:45:21.958]                     do.call(function(...) {
[17:45:21.958]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:21.958]                       if (!identical(...future.globals.maxSize.org, 
[17:45:21.958]                         ...future.globals.maxSize)) {
[17:45:21.958]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:21.958]                         on.exit(options(oopts), add = TRUE)
[17:45:21.958]                       }
[17:45:21.958]                       {
[17:45:21.958]                         lapply(seq_along(...future.elements_ii), 
[17:45:21.958]                           FUN = function(jj) {
[17:45:21.958]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:21.958]                             ...future.FUN(...future.X_jj, ...)
[17:45:21.958]                           })
[17:45:21.958]                       }
[17:45:21.958]                     }, args = future.call.arguments)
[17:45:21.958]                   }
[17:45:21.958]                 }, immediateCondition = function(cond) {
[17:45:21.958]                   sendCondition <- ...future.makeSendCondition()
[17:45:21.958]                   sendCondition(cond)
[17:45:21.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.958]                   {
[17:45:21.958]                     inherits <- base::inherits
[17:45:21.958]                     invokeRestart <- base::invokeRestart
[17:45:21.958]                     is.null <- base::is.null
[17:45:21.958]                     muffled <- FALSE
[17:45:21.958]                     if (inherits(cond, "message")) {
[17:45:21.958]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:21.958]                       if (muffled) 
[17:45:21.958]                         invokeRestart("muffleMessage")
[17:45:21.958]                     }
[17:45:21.958]                     else if (inherits(cond, "warning")) {
[17:45:21.958]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:21.958]                       if (muffled) 
[17:45:21.958]                         invokeRestart("muffleWarning")
[17:45:21.958]                     }
[17:45:21.958]                     else if (inherits(cond, "condition")) {
[17:45:21.958]                       if (!is.null(pattern)) {
[17:45:21.958]                         computeRestarts <- base::computeRestarts
[17:45:21.958]                         grepl <- base::grepl
[17:45:21.958]                         restarts <- computeRestarts(cond)
[17:45:21.958]                         for (restart in restarts) {
[17:45:21.958]                           name <- restart$name
[17:45:21.958]                           if (is.null(name)) 
[17:45:21.958]                             next
[17:45:21.958]                           if (!grepl(pattern, name)) 
[17:45:21.958]                             next
[17:45:21.958]                           invokeRestart(restart)
[17:45:21.958]                           muffled <- TRUE
[17:45:21.958]                           break
[17:45:21.958]                         }
[17:45:21.958]                       }
[17:45:21.958]                     }
[17:45:21.958]                     invisible(muffled)
[17:45:21.958]                   }
[17:45:21.958]                   muffleCondition(cond)
[17:45:21.958]                 })
[17:45:21.958]             }))
[17:45:21.958]             future::FutureResult(value = ...future.value$value, 
[17:45:21.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.958]                   ...future.rng), globalenv = if (FALSE) 
[17:45:21.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:21.958]                     ...future.globalenv.names))
[17:45:21.958]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:21.958]         }, condition = base::local({
[17:45:21.958]             c <- base::c
[17:45:21.958]             inherits <- base::inherits
[17:45:21.958]             invokeRestart <- base::invokeRestart
[17:45:21.958]             length <- base::length
[17:45:21.958]             list <- base::list
[17:45:21.958]             seq.int <- base::seq.int
[17:45:21.958]             signalCondition <- base::signalCondition
[17:45:21.958]             sys.calls <- base::sys.calls
[17:45:21.958]             `[[` <- base::`[[`
[17:45:21.958]             `+` <- base::`+`
[17:45:21.958]             `<<-` <- base::`<<-`
[17:45:21.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:21.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:21.958]                   3L)]
[17:45:21.958]             }
[17:45:21.958]             function(cond) {
[17:45:21.958]                 is_error <- inherits(cond, "error")
[17:45:21.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:21.958]                   NULL)
[17:45:21.958]                 if (is_error) {
[17:45:21.958]                   sessionInformation <- function() {
[17:45:21.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:21.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:21.958]                       search = base::search(), system = base::Sys.info())
[17:45:21.958]                   }
[17:45:21.958]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:21.958]                     cond$call), session = sessionInformation(), 
[17:45:21.958]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:21.958]                   signalCondition(cond)
[17:45:21.958]                 }
[17:45:21.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:21.958]                 "immediateCondition"))) {
[17:45:21.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:21.958]                   ...future.conditions[[length(...future.conditions) + 
[17:45:21.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:21.958]                   if (TRUE && !signal) {
[17:45:21.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.958]                     {
[17:45:21.958]                       inherits <- base::inherits
[17:45:21.958]                       invokeRestart <- base::invokeRestart
[17:45:21.958]                       is.null <- base::is.null
[17:45:21.958]                       muffled <- FALSE
[17:45:21.958]                       if (inherits(cond, "message")) {
[17:45:21.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.958]                         if (muffled) 
[17:45:21.958]                           invokeRestart("muffleMessage")
[17:45:21.958]                       }
[17:45:21.958]                       else if (inherits(cond, "warning")) {
[17:45:21.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.958]                         if (muffled) 
[17:45:21.958]                           invokeRestart("muffleWarning")
[17:45:21.958]                       }
[17:45:21.958]                       else if (inherits(cond, "condition")) {
[17:45:21.958]                         if (!is.null(pattern)) {
[17:45:21.958]                           computeRestarts <- base::computeRestarts
[17:45:21.958]                           grepl <- base::grepl
[17:45:21.958]                           restarts <- computeRestarts(cond)
[17:45:21.958]                           for (restart in restarts) {
[17:45:21.958]                             name <- restart$name
[17:45:21.958]                             if (is.null(name)) 
[17:45:21.958]                               next
[17:45:21.958]                             if (!grepl(pattern, name)) 
[17:45:21.958]                               next
[17:45:21.958]                             invokeRestart(restart)
[17:45:21.958]                             muffled <- TRUE
[17:45:21.958]                             break
[17:45:21.958]                           }
[17:45:21.958]                         }
[17:45:21.958]                       }
[17:45:21.958]                       invisible(muffled)
[17:45:21.958]                     }
[17:45:21.958]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.958]                   }
[17:45:21.958]                 }
[17:45:21.958]                 else {
[17:45:21.958]                   if (TRUE) {
[17:45:21.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:21.958]                     {
[17:45:21.958]                       inherits <- base::inherits
[17:45:21.958]                       invokeRestart <- base::invokeRestart
[17:45:21.958]                       is.null <- base::is.null
[17:45:21.958]                       muffled <- FALSE
[17:45:21.958]                       if (inherits(cond, "message")) {
[17:45:21.958]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:21.958]                         if (muffled) 
[17:45:21.958]                           invokeRestart("muffleMessage")
[17:45:21.958]                       }
[17:45:21.958]                       else if (inherits(cond, "warning")) {
[17:45:21.958]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:21.958]                         if (muffled) 
[17:45:21.958]                           invokeRestart("muffleWarning")
[17:45:21.958]                       }
[17:45:21.958]                       else if (inherits(cond, "condition")) {
[17:45:21.958]                         if (!is.null(pattern)) {
[17:45:21.958]                           computeRestarts <- base::computeRestarts
[17:45:21.958]                           grepl <- base::grepl
[17:45:21.958]                           restarts <- computeRestarts(cond)
[17:45:21.958]                           for (restart in restarts) {
[17:45:21.958]                             name <- restart$name
[17:45:21.958]                             if (is.null(name)) 
[17:45:21.958]                               next
[17:45:21.958]                             if (!grepl(pattern, name)) 
[17:45:21.958]                               next
[17:45:21.958]                             invokeRestart(restart)
[17:45:21.958]                             muffled <- TRUE
[17:45:21.958]                             break
[17:45:21.958]                           }
[17:45:21.958]                         }
[17:45:21.958]                       }
[17:45:21.958]                       invisible(muffled)
[17:45:21.958]                     }
[17:45:21.958]                     muffleCondition(cond, pattern = "^muffle")
[17:45:21.958]                   }
[17:45:21.958]                 }
[17:45:21.958]             }
[17:45:21.958]         }))
[17:45:21.958]     }, error = function(ex) {
[17:45:21.958]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:21.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:21.958]                 ...future.rng), started = ...future.startTime, 
[17:45:21.958]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:21.958]             version = "1.8"), class = "FutureResult")
[17:45:21.958]     }, finally = {
[17:45:21.958]         if (!identical(...future.workdir, getwd())) 
[17:45:21.958]             setwd(...future.workdir)
[17:45:21.958]         {
[17:45:21.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:21.958]                 ...future.oldOptions$nwarnings <- NULL
[17:45:21.958]             }
[17:45:21.958]             base::options(...future.oldOptions)
[17:45:21.958]             if (.Platform$OS.type == "windows") {
[17:45:21.958]                 old_names <- names(...future.oldEnvVars)
[17:45:21.958]                 envs <- base::Sys.getenv()
[17:45:21.958]                 names <- names(envs)
[17:45:21.958]                 common <- intersect(names, old_names)
[17:45:21.958]                 added <- setdiff(names, old_names)
[17:45:21.958]                 removed <- setdiff(old_names, names)
[17:45:21.958]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:21.958]                   envs[common]]
[17:45:21.958]                 NAMES <- toupper(changed)
[17:45:21.958]                 args <- list()
[17:45:21.958]                 for (kk in seq_along(NAMES)) {
[17:45:21.958]                   name <- changed[[kk]]
[17:45:21.958]                   NAME <- NAMES[[kk]]
[17:45:21.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.958]                     next
[17:45:21.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.958]                 }
[17:45:21.958]                 NAMES <- toupper(added)
[17:45:21.958]                 for (kk in seq_along(NAMES)) {
[17:45:21.958]                   name <- added[[kk]]
[17:45:21.958]                   NAME <- NAMES[[kk]]
[17:45:21.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.958]                     next
[17:45:21.958]                   args[[name]] <- ""
[17:45:21.958]                 }
[17:45:21.958]                 NAMES <- toupper(removed)
[17:45:21.958]                 for (kk in seq_along(NAMES)) {
[17:45:21.958]                   name <- removed[[kk]]
[17:45:21.958]                   NAME <- NAMES[[kk]]
[17:45:21.958]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:21.958]                     next
[17:45:21.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:21.958]                 }
[17:45:21.958]                 if (length(args) > 0) 
[17:45:21.958]                   base::do.call(base::Sys.setenv, args = args)
[17:45:21.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:21.958]             }
[17:45:21.958]             else {
[17:45:21.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:21.958]             }
[17:45:21.958]             {
[17:45:21.958]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:21.958]                   0L) {
[17:45:21.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:21.958]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:21.958]                   base::options(opts)
[17:45:21.958]                 }
[17:45:21.958]                 {
[17:45:21.958]                   {
[17:45:21.958]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:21.958]                     NULL
[17:45:21.958]                   }
[17:45:21.958]                   options(future.plan = NULL)
[17:45:21.958]                   if (is.na(NA_character_)) 
[17:45:21.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:21.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:21.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:21.958]                     .init = FALSE)
[17:45:21.958]                 }
[17:45:21.958]             }
[17:45:21.958]         }
[17:45:21.958]     })
[17:45:21.958]     if (TRUE) {
[17:45:21.958]         base::sink(type = "output", split = FALSE)
[17:45:21.958]         if (TRUE) {
[17:45:21.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:21.958]         }
[17:45:21.958]         else {
[17:45:21.958]             ...future.result["stdout"] <- base::list(NULL)
[17:45:21.958]         }
[17:45:21.958]         base::close(...future.stdout)
[17:45:21.958]         ...future.stdout <- NULL
[17:45:21.958]     }
[17:45:21.958]     ...future.result$conditions <- ...future.conditions
[17:45:21.958]     ...future.result$finished <- base::Sys.time()
[17:45:21.958]     ...future.result
[17:45:21.958] }
[17:45:21.960] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[17:45:21.961] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:22.004] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:22.004] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[17:45:22.004] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[17:45:22.005] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:22.005] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:22.005] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:22.048] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:22.048] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:22.092] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:22.092] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:22.092] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.092] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:45:22.093] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:45:22.093] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:22.094] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.094] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:22.094] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:22.094] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:22.095] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.095] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:22.095] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.095] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[17:45:22.096] MultisessionFuture started
[17:45:22.096] - Launch lazy future ... done
[17:45:22.096] run() for ‘MultisessionFuture’ ... done
[17:45:22.096] Created future:
[17:45:22.096] MultisessionFuture:
[17:45:22.096] Label: ‘future_vapply-1’
[17:45:22.096] Expression:
[17:45:22.096] {
[17:45:22.096]     do.call(function(...) {
[17:45:22.096]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.096]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.096]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.096]             on.exit(options(oopts), add = TRUE)
[17:45:22.096]         }
[17:45:22.096]         {
[17:45:22.096]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.096]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.096]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.096]             })
[17:45:22.096]         }
[17:45:22.096]     }, args = future.call.arguments)
[17:45:22.096] }
[17:45:22.096] Lazy evaluation: FALSE
[17:45:22.096] Asynchronous evaluation: TRUE
[17:45:22.096] Local evaluation: TRUE
[17:45:22.096] Environment: R_GlobalEnv
[17:45:22.096] Capture standard output: TRUE
[17:45:22.096] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:22.096] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:22.096] Packages: 1 packages (‘future.apply’)
[17:45:22.096] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:22.096] Resolved: FALSE
[17:45:22.096] Value: <not collected>
[17:45:22.096] Conditions captured: <none>
[17:45:22.096] Early signaling: FALSE
[17:45:22.096] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:22.096] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.108] Chunk #1 of 2 ... DONE
[17:45:22.108] Chunk #2 of 2 ...
[17:45:22.108]  - Finding globals in 'X' for chunk #2 ...
[17:45:22.108] getGlobalsAndPackages() ...
[17:45:22.108] Searching for globals...
[17:45:22.109] 
[17:45:22.109] Searching for globals ... DONE
[17:45:22.109] - globals: [0] <none>
[17:45:22.109] getGlobalsAndPackages() ... DONE
[17:45:22.109]    + additional globals found: [n=0] 
[17:45:22.109]    + additional namespaces needed: [n=0] 
[17:45:22.109]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:22.109]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:22.109]  - seeds: <none>
[17:45:22.109]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.109] getGlobalsAndPackages() ...
[17:45:22.110] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.110] Resolving globals: FALSE
[17:45:22.110] Tweak future expression to call with '...' arguments ...
[17:45:22.110] {
[17:45:22.110]     do.call(function(...) {
[17:45:22.110]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.110]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.110]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.110]             on.exit(options(oopts), add = TRUE)
[17:45:22.110]         }
[17:45:22.110]         {
[17:45:22.110]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.110]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.110]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.110]             })
[17:45:22.110]         }
[17:45:22.110]     }, args = future.call.arguments)
[17:45:22.110] }
[17:45:22.110] Tweak future expression to call with '...' arguments ... DONE
[17:45:22.111] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.111] - packages: [1] ‘future.apply’
[17:45:22.111] getGlobalsAndPackages() ... DONE
[17:45:22.111] run() for ‘Future’ ...
[17:45:22.111] - state: ‘created’
[17:45:22.111] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:22.126] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:22.126]   - Field: ‘node’
[17:45:22.126]   - Field: ‘label’
[17:45:22.126]   - Field: ‘local’
[17:45:22.126]   - Field: ‘owner’
[17:45:22.126]   - Field: ‘envir’
[17:45:22.126]   - Field: ‘workers’
[17:45:22.126]   - Field: ‘packages’
[17:45:22.126]   - Field: ‘gc’
[17:45:22.127]   - Field: ‘conditions’
[17:45:22.127]   - Field: ‘persistent’
[17:45:22.127]   - Field: ‘expr’
[17:45:22.127]   - Field: ‘uuid’
[17:45:22.127]   - Field: ‘seed’
[17:45:22.127]   - Field: ‘version’
[17:45:22.127]   - Field: ‘result’
[17:45:22.127]   - Field: ‘asynchronous’
[17:45:22.127]   - Field: ‘calls’
[17:45:22.127]   - Field: ‘globals’
[17:45:22.127]   - Field: ‘stdout’
[17:45:22.127]   - Field: ‘earlySignal’
[17:45:22.128]   - Field: ‘lazy’
[17:45:22.128]   - Field: ‘state’
[17:45:22.128] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:22.128] - Launch lazy future ...
[17:45:22.128] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:22.128] Packages needed by future strategies (n = 0): <none>
[17:45:22.129] {
[17:45:22.129]     {
[17:45:22.129]         {
[17:45:22.129]             ...future.startTime <- base::Sys.time()
[17:45:22.129]             {
[17:45:22.129]                 {
[17:45:22.129]                   {
[17:45:22.129]                     {
[17:45:22.129]                       {
[17:45:22.129]                         base::local({
[17:45:22.129]                           has_future <- base::requireNamespace("future", 
[17:45:22.129]                             quietly = TRUE)
[17:45:22.129]                           if (has_future) {
[17:45:22.129]                             ns <- base::getNamespace("future")
[17:45:22.129]                             version <- ns[[".package"]][["version"]]
[17:45:22.129]                             if (is.null(version)) 
[17:45:22.129]                               version <- utils::packageVersion("future")
[17:45:22.129]                           }
[17:45:22.129]                           else {
[17:45:22.129]                             version <- NULL
[17:45:22.129]                           }
[17:45:22.129]                           if (!has_future || version < "1.8.0") {
[17:45:22.129]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:22.129]                               "", base::R.version$version.string), 
[17:45:22.129]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:22.129]                                 base::R.version$platform, 8 * 
[17:45:22.129]                                   base::.Machine$sizeof.pointer), 
[17:45:22.129]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:22.129]                                 "release", "version")], collapse = " "), 
[17:45:22.129]                               hostname = base::Sys.info()[["nodename"]])
[17:45:22.129]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:22.129]                               info)
[17:45:22.129]                             info <- base::paste(info, collapse = "; ")
[17:45:22.129]                             if (!has_future) {
[17:45:22.129]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:22.129]                                 info)
[17:45:22.129]                             }
[17:45:22.129]                             else {
[17:45:22.129]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:22.129]                                 info, version)
[17:45:22.129]                             }
[17:45:22.129]                             base::stop(msg)
[17:45:22.129]                           }
[17:45:22.129]                         })
[17:45:22.129]                       }
[17:45:22.129]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:22.129]                       base::options(mc.cores = 1L)
[17:45:22.129]                     }
[17:45:22.129]                     base::local({
[17:45:22.129]                       for (pkg in "future.apply") {
[17:45:22.129]                         base::loadNamespace(pkg)
[17:45:22.129]                         base::library(pkg, character.only = TRUE)
[17:45:22.129]                       }
[17:45:22.129]                     })
[17:45:22.129]                   }
[17:45:22.129]                   ...future.strategy.old <- future::plan("list")
[17:45:22.129]                   options(future.plan = NULL)
[17:45:22.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:22.129]                 }
[17:45:22.129]                 ...future.workdir <- getwd()
[17:45:22.129]             }
[17:45:22.129]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:22.129]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:22.129]         }
[17:45:22.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:22.129]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:22.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:22.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:22.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:22.129]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:22.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:22.129]             base::names(...future.oldOptions))
[17:45:22.129]     }
[17:45:22.129]     if (FALSE) {
[17:45:22.129]     }
[17:45:22.129]     else {
[17:45:22.129]         if (TRUE) {
[17:45:22.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:22.129]                 open = "w")
[17:45:22.129]         }
[17:45:22.129]         else {
[17:45:22.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:22.129]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:22.129]         }
[17:45:22.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:22.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:22.129]             base::sink(type = "output", split = FALSE)
[17:45:22.129]             base::close(...future.stdout)
[17:45:22.129]         }, add = TRUE)
[17:45:22.129]     }
[17:45:22.129]     ...future.frame <- base::sys.nframe()
[17:45:22.129]     ...future.conditions <- base::list()
[17:45:22.129]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:22.129]     if (FALSE) {
[17:45:22.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:22.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:22.129]     }
[17:45:22.129]     ...future.result <- base::tryCatch({
[17:45:22.129]         base::withCallingHandlers({
[17:45:22.129]             ...future.value <- base::withVisible(base::local({
[17:45:22.129]                 ...future.makeSendCondition <- base::local({
[17:45:22.129]                   sendCondition <- NULL
[17:45:22.129]                   function(frame = 1L) {
[17:45:22.129]                     if (is.function(sendCondition)) 
[17:45:22.129]                       return(sendCondition)
[17:45:22.129]                     ns <- getNamespace("parallel")
[17:45:22.129]                     if (exists("sendData", mode = "function", 
[17:45:22.129]                       envir = ns)) {
[17:45:22.129]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:22.129]                         envir = ns)
[17:45:22.129]                       envir <- sys.frame(frame)
[17:45:22.129]                       master <- NULL
[17:45:22.129]                       while (!identical(envir, .GlobalEnv) && 
[17:45:22.129]                         !identical(envir, emptyenv())) {
[17:45:22.129]                         if (exists("master", mode = "list", envir = envir, 
[17:45:22.129]                           inherits = FALSE)) {
[17:45:22.129]                           master <- get("master", mode = "list", 
[17:45:22.129]                             envir = envir, inherits = FALSE)
[17:45:22.129]                           if (inherits(master, c("SOCKnode", 
[17:45:22.129]                             "SOCK0node"))) {
[17:45:22.129]                             sendCondition <<- function(cond) {
[17:45:22.129]                               data <- list(type = "VALUE", value = cond, 
[17:45:22.129]                                 success = TRUE)
[17:45:22.129]                               parallel_sendData(master, data)
[17:45:22.129]                             }
[17:45:22.129]                             return(sendCondition)
[17:45:22.129]                           }
[17:45:22.129]                         }
[17:45:22.129]                         frame <- frame + 1L
[17:45:22.129]                         envir <- sys.frame(frame)
[17:45:22.129]                       }
[17:45:22.129]                     }
[17:45:22.129]                     sendCondition <<- function(cond) NULL
[17:45:22.129]                   }
[17:45:22.129]                 })
[17:45:22.129]                 withCallingHandlers({
[17:45:22.129]                   {
[17:45:22.129]                     do.call(function(...) {
[17:45:22.129]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.129]                       if (!identical(...future.globals.maxSize.org, 
[17:45:22.129]                         ...future.globals.maxSize)) {
[17:45:22.129]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.129]                         on.exit(options(oopts), add = TRUE)
[17:45:22.129]                       }
[17:45:22.129]                       {
[17:45:22.129]                         lapply(seq_along(...future.elements_ii), 
[17:45:22.129]                           FUN = function(jj) {
[17:45:22.129]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.129]                             ...future.FUN(...future.X_jj, ...)
[17:45:22.129]                           })
[17:45:22.129]                       }
[17:45:22.129]                     }, args = future.call.arguments)
[17:45:22.129]                   }
[17:45:22.129]                 }, immediateCondition = function(cond) {
[17:45:22.129]                   sendCondition <- ...future.makeSendCondition()
[17:45:22.129]                   sendCondition(cond)
[17:45:22.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.129]                   {
[17:45:22.129]                     inherits <- base::inherits
[17:45:22.129]                     invokeRestart <- base::invokeRestart
[17:45:22.129]                     is.null <- base::is.null
[17:45:22.129]                     muffled <- FALSE
[17:45:22.129]                     if (inherits(cond, "message")) {
[17:45:22.129]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:22.129]                       if (muffled) 
[17:45:22.129]                         invokeRestart("muffleMessage")
[17:45:22.129]                     }
[17:45:22.129]                     else if (inherits(cond, "warning")) {
[17:45:22.129]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:22.129]                       if (muffled) 
[17:45:22.129]                         invokeRestart("muffleWarning")
[17:45:22.129]                     }
[17:45:22.129]                     else if (inherits(cond, "condition")) {
[17:45:22.129]                       if (!is.null(pattern)) {
[17:45:22.129]                         computeRestarts <- base::computeRestarts
[17:45:22.129]                         grepl <- base::grepl
[17:45:22.129]                         restarts <- computeRestarts(cond)
[17:45:22.129]                         for (restart in restarts) {
[17:45:22.129]                           name <- restart$name
[17:45:22.129]                           if (is.null(name)) 
[17:45:22.129]                             next
[17:45:22.129]                           if (!grepl(pattern, name)) 
[17:45:22.129]                             next
[17:45:22.129]                           invokeRestart(restart)
[17:45:22.129]                           muffled <- TRUE
[17:45:22.129]                           break
[17:45:22.129]                         }
[17:45:22.129]                       }
[17:45:22.129]                     }
[17:45:22.129]                     invisible(muffled)
[17:45:22.129]                   }
[17:45:22.129]                   muffleCondition(cond)
[17:45:22.129]                 })
[17:45:22.129]             }))
[17:45:22.129]             future::FutureResult(value = ...future.value$value, 
[17:45:22.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.129]                   ...future.rng), globalenv = if (FALSE) 
[17:45:22.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:22.129]                     ...future.globalenv.names))
[17:45:22.129]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:22.129]         }, condition = base::local({
[17:45:22.129]             c <- base::c
[17:45:22.129]             inherits <- base::inherits
[17:45:22.129]             invokeRestart <- base::invokeRestart
[17:45:22.129]             length <- base::length
[17:45:22.129]             list <- base::list
[17:45:22.129]             seq.int <- base::seq.int
[17:45:22.129]             signalCondition <- base::signalCondition
[17:45:22.129]             sys.calls <- base::sys.calls
[17:45:22.129]             `[[` <- base::`[[`
[17:45:22.129]             `+` <- base::`+`
[17:45:22.129]             `<<-` <- base::`<<-`
[17:45:22.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:22.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:22.129]                   3L)]
[17:45:22.129]             }
[17:45:22.129]             function(cond) {
[17:45:22.129]                 is_error <- inherits(cond, "error")
[17:45:22.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:22.129]                   NULL)
[17:45:22.129]                 if (is_error) {
[17:45:22.129]                   sessionInformation <- function() {
[17:45:22.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:22.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:22.129]                       search = base::search(), system = base::Sys.info())
[17:45:22.129]                   }
[17:45:22.129]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:22.129]                     cond$call), session = sessionInformation(), 
[17:45:22.129]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:22.129]                   signalCondition(cond)
[17:45:22.129]                 }
[17:45:22.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:22.129]                 "immediateCondition"))) {
[17:45:22.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:22.129]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:22.129]                   if (TRUE && !signal) {
[17:45:22.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.129]                     {
[17:45:22.129]                       inherits <- base::inherits
[17:45:22.129]                       invokeRestart <- base::invokeRestart
[17:45:22.129]                       is.null <- base::is.null
[17:45:22.129]                       muffled <- FALSE
[17:45:22.129]                       if (inherits(cond, "message")) {
[17:45:22.129]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.129]                         if (muffled) 
[17:45:22.129]                           invokeRestart("muffleMessage")
[17:45:22.129]                       }
[17:45:22.129]                       else if (inherits(cond, "warning")) {
[17:45:22.129]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.129]                         if (muffled) 
[17:45:22.129]                           invokeRestart("muffleWarning")
[17:45:22.129]                       }
[17:45:22.129]                       else if (inherits(cond, "condition")) {
[17:45:22.129]                         if (!is.null(pattern)) {
[17:45:22.129]                           computeRestarts <- base::computeRestarts
[17:45:22.129]                           grepl <- base::grepl
[17:45:22.129]                           restarts <- computeRestarts(cond)
[17:45:22.129]                           for (restart in restarts) {
[17:45:22.129]                             name <- restart$name
[17:45:22.129]                             if (is.null(name)) 
[17:45:22.129]                               next
[17:45:22.129]                             if (!grepl(pattern, name)) 
[17:45:22.129]                               next
[17:45:22.129]                             invokeRestart(restart)
[17:45:22.129]                             muffled <- TRUE
[17:45:22.129]                             break
[17:45:22.129]                           }
[17:45:22.129]                         }
[17:45:22.129]                       }
[17:45:22.129]                       invisible(muffled)
[17:45:22.129]                     }
[17:45:22.129]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.129]                   }
[17:45:22.129]                 }
[17:45:22.129]                 else {
[17:45:22.129]                   if (TRUE) {
[17:45:22.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.129]                     {
[17:45:22.129]                       inherits <- base::inherits
[17:45:22.129]                       invokeRestart <- base::invokeRestart
[17:45:22.129]                       is.null <- base::is.null
[17:45:22.129]                       muffled <- FALSE
[17:45:22.129]                       if (inherits(cond, "message")) {
[17:45:22.129]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.129]                         if (muffled) 
[17:45:22.129]                           invokeRestart("muffleMessage")
[17:45:22.129]                       }
[17:45:22.129]                       else if (inherits(cond, "warning")) {
[17:45:22.129]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.129]                         if (muffled) 
[17:45:22.129]                           invokeRestart("muffleWarning")
[17:45:22.129]                       }
[17:45:22.129]                       else if (inherits(cond, "condition")) {
[17:45:22.129]                         if (!is.null(pattern)) {
[17:45:22.129]                           computeRestarts <- base::computeRestarts
[17:45:22.129]                           grepl <- base::grepl
[17:45:22.129]                           restarts <- computeRestarts(cond)
[17:45:22.129]                           for (restart in restarts) {
[17:45:22.129]                             name <- restart$name
[17:45:22.129]                             if (is.null(name)) 
[17:45:22.129]                               next
[17:45:22.129]                             if (!grepl(pattern, name)) 
[17:45:22.129]                               next
[17:45:22.129]                             invokeRestart(restart)
[17:45:22.129]                             muffled <- TRUE
[17:45:22.129]                             break
[17:45:22.129]                           }
[17:45:22.129]                         }
[17:45:22.129]                       }
[17:45:22.129]                       invisible(muffled)
[17:45:22.129]                     }
[17:45:22.129]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.129]                   }
[17:45:22.129]                 }
[17:45:22.129]             }
[17:45:22.129]         }))
[17:45:22.129]     }, error = function(ex) {
[17:45:22.129]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:22.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.129]                 ...future.rng), started = ...future.startTime, 
[17:45:22.129]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:22.129]             version = "1.8"), class = "FutureResult")
[17:45:22.129]     }, finally = {
[17:45:22.129]         if (!identical(...future.workdir, getwd())) 
[17:45:22.129]             setwd(...future.workdir)
[17:45:22.129]         {
[17:45:22.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:22.129]                 ...future.oldOptions$nwarnings <- NULL
[17:45:22.129]             }
[17:45:22.129]             base::options(...future.oldOptions)
[17:45:22.129]             if (.Platform$OS.type == "windows") {
[17:45:22.129]                 old_names <- names(...future.oldEnvVars)
[17:45:22.129]                 envs <- base::Sys.getenv()
[17:45:22.129]                 names <- names(envs)
[17:45:22.129]                 common <- intersect(names, old_names)
[17:45:22.129]                 added <- setdiff(names, old_names)
[17:45:22.129]                 removed <- setdiff(old_names, names)
[17:45:22.129]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:22.129]                   envs[common]]
[17:45:22.129]                 NAMES <- toupper(changed)
[17:45:22.129]                 args <- list()
[17:45:22.129]                 for (kk in seq_along(NAMES)) {
[17:45:22.129]                   name <- changed[[kk]]
[17:45:22.129]                   NAME <- NAMES[[kk]]
[17:45:22.129]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.129]                     next
[17:45:22.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.129]                 }
[17:45:22.129]                 NAMES <- toupper(added)
[17:45:22.129]                 for (kk in seq_along(NAMES)) {
[17:45:22.129]                   name <- added[[kk]]
[17:45:22.129]                   NAME <- NAMES[[kk]]
[17:45:22.129]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.129]                     next
[17:45:22.129]                   args[[name]] <- ""
[17:45:22.129]                 }
[17:45:22.129]                 NAMES <- toupper(removed)
[17:45:22.129]                 for (kk in seq_along(NAMES)) {
[17:45:22.129]                   name <- removed[[kk]]
[17:45:22.129]                   NAME <- NAMES[[kk]]
[17:45:22.129]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.129]                     next
[17:45:22.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.129]                 }
[17:45:22.129]                 if (length(args) > 0) 
[17:45:22.129]                   base::do.call(base::Sys.setenv, args = args)
[17:45:22.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:22.129]             }
[17:45:22.129]             else {
[17:45:22.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:22.129]             }
[17:45:22.129]             {
[17:45:22.129]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:22.129]                   0L) {
[17:45:22.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:22.129]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:22.129]                   base::options(opts)
[17:45:22.129]                 }
[17:45:22.129]                 {
[17:45:22.129]                   {
[17:45:22.129]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:22.129]                     NULL
[17:45:22.129]                   }
[17:45:22.129]                   options(future.plan = NULL)
[17:45:22.129]                   if (is.na(NA_character_)) 
[17:45:22.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:22.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:22.129]                     .init = FALSE)
[17:45:22.129]                 }
[17:45:22.129]             }
[17:45:22.129]         }
[17:45:22.129]     })
[17:45:22.129]     if (TRUE) {
[17:45:22.129]         base::sink(type = "output", split = FALSE)
[17:45:22.129]         if (TRUE) {
[17:45:22.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:22.129]         }
[17:45:22.129]         else {
[17:45:22.129]             ...future.result["stdout"] <- base::list(NULL)
[17:45:22.129]         }
[17:45:22.129]         base::close(...future.stdout)
[17:45:22.129]         ...future.stdout <- NULL
[17:45:22.129]     }
[17:45:22.129]     ...future.result$conditions <- ...future.conditions
[17:45:22.129]     ...future.result$finished <- base::Sys.time()
[17:45:22.129]     ...future.result
[17:45:22.129] }
[17:45:22.131] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[17:45:22.132] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:22.176] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:22.176] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[17:45:22.176] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[17:45:22.176] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:22.177] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:22.177] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:22.220] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:22.220] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:22.264] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:22.264] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:22.264] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:22.265] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[17:45:22.265] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[17:45:22.265] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:22.266] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:22.266] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:45:22.266] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:45:22.266] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:22.267] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:22.267] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:22.267] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:22.267] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[17:45:22.268] MultisessionFuture started
[17:45:22.268] - Launch lazy future ... done
[17:45:22.268] run() for ‘MultisessionFuture’ ... done
[17:45:22.268] Created future:
[17:45:22.269] MultisessionFuture:
[17:45:22.269] Label: ‘future_vapply-2’
[17:45:22.269] Expression:
[17:45:22.269] {
[17:45:22.269]     do.call(function(...) {
[17:45:22.269]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.269]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.269]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.269]             on.exit(options(oopts), add = TRUE)
[17:45:22.269]         }
[17:45:22.269]         {
[17:45:22.269]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.269]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.269]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.269]             })
[17:45:22.269]         }
[17:45:22.269]     }, args = future.call.arguments)
[17:45:22.269] }
[17:45:22.269] Lazy evaluation: FALSE
[17:45:22.269] Asynchronous evaluation: TRUE
[17:45:22.269] Local evaluation: TRUE
[17:45:22.269] Environment: R_GlobalEnv
[17:45:22.269] Capture standard output: TRUE
[17:45:22.269] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:22.269] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:22.269] Packages: 1 packages (‘future.apply’)
[17:45:22.269] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:22.269] Resolved: FALSE
[17:45:22.269] Value: <not collected>
[17:45:22.269] Conditions captured: <none>
[17:45:22.269] Early signaling: FALSE
[17:45:22.269] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:22.269] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.280] Chunk #2 of 2 ... DONE
[17:45:22.280] Launching 2 futures (chunks) ... DONE
[17:45:22.281] Resolving 2 futures (chunks) ...
[17:45:22.281] resolve() on list ...
[17:45:22.281]  recursive: 0
[17:45:22.281]  length: 2
[17:45:22.281] 
[17:45:22.282] receiveMessageFromWorker() for ClusterFuture ...
[17:45:22.282] - Validating connection of MultisessionFuture
[17:45:22.282] - received message: FutureResult
[17:45:22.282] - Received FutureResult
[17:45:22.282] - Erased future from FutureRegistry
[17:45:22.282] result() for ClusterFuture ...
[17:45:22.282] - result already collected: FutureResult
[17:45:22.282] result() for ClusterFuture ... done
[17:45:22.282] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:22.282] Future #1
[17:45:22.283] result() for ClusterFuture ...
[17:45:22.283] - result already collected: FutureResult
[17:45:22.283] result() for ClusterFuture ... done
[17:45:22.283] result() for ClusterFuture ...
[17:45:22.283] - result already collected: FutureResult
[17:45:22.283] result() for ClusterFuture ... done
[17:45:22.283] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:22.283] - nx: 2
[17:45:22.283] - relay: TRUE
[17:45:22.283] - stdout: TRUE
[17:45:22.283] - signal: TRUE
[17:45:22.284] - resignal: FALSE
[17:45:22.284] - force: TRUE
[17:45:22.284] - relayed: [n=2] FALSE, FALSE
[17:45:22.284] - queued futures: [n=2] FALSE, FALSE
[17:45:22.284]  - until=1
[17:45:22.284]  - relaying element #1
[17:45:22.284] result() for ClusterFuture ...
[17:45:22.284] - result already collected: FutureResult
[17:45:22.284] result() for ClusterFuture ... done
[17:45:22.284] result() for ClusterFuture ...
[17:45:22.284] - result already collected: FutureResult
[17:45:22.284] result() for ClusterFuture ... done
[17:45:22.285] result() for ClusterFuture ...
[17:45:22.285] - result already collected: FutureResult
[17:45:22.285] result() for ClusterFuture ... done
[17:45:22.285] result() for ClusterFuture ...
[17:45:22.285] - result already collected: FutureResult
[17:45:22.285] result() for ClusterFuture ... done
[17:45:22.285] - relayed: [n=2] TRUE, FALSE
[17:45:22.285] - queued futures: [n=2] TRUE, FALSE
[17:45:22.285] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:22.285]  length: 1 (resolved future 1)
[17:45:22.313] receiveMessageFromWorker() for ClusterFuture ...
[17:45:22.313] - Validating connection of MultisessionFuture
[17:45:22.313] - received message: FutureResult
[17:45:22.314] - Received FutureResult
[17:45:22.314] - Erased future from FutureRegistry
[17:45:22.314] result() for ClusterFuture ...
[17:45:22.314] - result already collected: FutureResult
[17:45:22.314] result() for ClusterFuture ... done
[17:45:22.314] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:22.314] Future #2
[17:45:22.314] result() for ClusterFuture ...
[17:45:22.314] - result already collected: FutureResult
[17:45:22.314] result() for ClusterFuture ... done
[17:45:22.314] result() for ClusterFuture ...
[17:45:22.315] - result already collected: FutureResult
[17:45:22.315] result() for ClusterFuture ... done
[17:45:22.315] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:22.315] - nx: 2
[17:45:22.315] - relay: TRUE
[17:45:22.315] - stdout: TRUE
[17:45:22.315] - signal: TRUE
[17:45:22.315] - resignal: FALSE
[17:45:22.315] - force: TRUE
[17:45:22.315] - relayed: [n=2] TRUE, FALSE
[17:45:22.315] - queued futures: [n=2] TRUE, FALSE
[17:45:22.315]  - until=2
[17:45:22.316]  - relaying element #2
[17:45:22.316] result() for ClusterFuture ...
[17:45:22.316] - result already collected: FutureResult
[17:45:22.316] result() for ClusterFuture ... done
[17:45:22.316] result() for ClusterFuture ...
[17:45:22.316] - result already collected: FutureResult
[17:45:22.316] result() for ClusterFuture ... done
[17:45:22.316] result() for ClusterFuture ...
[17:45:22.316] - result already collected: FutureResult
[17:45:22.316] result() for ClusterFuture ... done
[17:45:22.316] result() for ClusterFuture ...
[17:45:22.317] - result already collected: FutureResult
[17:45:22.317] result() for ClusterFuture ... done
[17:45:22.317] - relayed: [n=2] TRUE, TRUE
[17:45:22.317] - queued futures: [n=2] TRUE, TRUE
[17:45:22.317] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:22.317]  length: 0 (resolved future 2)
[17:45:22.317] Relaying remaining futures
[17:45:22.317] signalConditionsASAP(NULL, pos=0) ...
[17:45:22.317] - nx: 2
[17:45:22.317] - relay: TRUE
[17:45:22.317] - stdout: TRUE
[17:45:22.317] - signal: TRUE
[17:45:22.318] - resignal: FALSE
[17:45:22.318] - force: TRUE
[17:45:22.318] - relayed: [n=2] TRUE, TRUE
[17:45:22.318] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:22.318] - relayed: [n=2] TRUE, TRUE
[17:45:22.318] - queued futures: [n=2] TRUE, TRUE
[17:45:22.318] signalConditionsASAP(NULL, pos=0) ... done
[17:45:22.318] resolve() on list ... DONE
[17:45:22.318] result() for ClusterFuture ...
[17:45:22.318] - result already collected: FutureResult
[17:45:22.318] result() for ClusterFuture ... done
[17:45:22.318] result() for ClusterFuture ...
[17:45:22.319] - result already collected: FutureResult
[17:45:22.319] result() for ClusterFuture ... done
[17:45:22.319] result() for ClusterFuture ...
[17:45:22.319] - result already collected: FutureResult
[17:45:22.319] result() for ClusterFuture ... done
[17:45:22.319] result() for ClusterFuture ...
[17:45:22.319] - result already collected: FutureResult
[17:45:22.319] result() for ClusterFuture ... done
[17:45:22.319]  - Number of value chunks collected: 2
[17:45:22.319] Resolving 2 futures (chunks) ... DONE
[17:45:22.319] Reducing values from 2 chunks ...
[17:45:22.320]  - Number of values collected after concatenation: 10
[17:45:22.320]  - Number of values expected: 10
[17:45:22.320] Reducing values from 2 chunks ... DONE
[17:45:22.320] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[17:45:22.321] future_lapply() ...
[17:45:22.326] Number of chunks: 2
[17:45:22.326] getGlobalsAndPackagesXApply() ...
[17:45:22.326]  - future.globals: TRUE
[17:45:22.327] getGlobalsAndPackages() ...
[17:45:22.327] Searching for globals...
[17:45:22.329] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:22.330] Searching for globals ... DONE
[17:45:22.330] Resolving globals: FALSE
[17:45:22.331] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[17:45:22.331] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:22.331] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:22.331] - packages: [1] ‘future.apply’
[17:45:22.331] getGlobalsAndPackages() ... DONE
[17:45:22.331]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:22.332]  - needed namespaces: [n=1] ‘future.apply’
[17:45:22.332] Finding globals ... DONE
[17:45:22.332]  - use_args: TRUE
[17:45:22.332]  - Getting '...' globals ...
[17:45:22.332] resolve() on list ...
[17:45:22.332]  recursive: 0
[17:45:22.332]  length: 1
[17:45:22.332]  elements: ‘...’
[17:45:22.332]  length: 0 (resolved future 1)
[17:45:22.333] resolve() on list ... DONE
[17:45:22.333]    - '...' content: [n=0] 
[17:45:22.333] List of 1
[17:45:22.333]  $ ...: list()
[17:45:22.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:22.333]  - attr(*, "where")=List of 1
[17:45:22.333]   ..$ ...:<environment: 0x5561f77be300> 
[17:45:22.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:22.333]  - attr(*, "resolved")= logi TRUE
[17:45:22.333]  - attr(*, "total_size")= num NA
[17:45:22.335]  - Getting '...' globals ... DONE
[17:45:22.335] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:22.335] List of 8
[17:45:22.335]  $ ...future.FUN:function (x, ...)  
[17:45:22.335]  $ x_FUN        :function (x)  
[17:45:22.335]  $ times        : int 1
[17:45:22.335]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:22.335]  $ stop_if_not  :function (...)  
[17:45:22.335]  $ dim          : NULL
[17:45:22.335]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:22.335]  $ ...          : list()
[17:45:22.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:22.335]  - attr(*, "where")=List of 8
[17:45:22.335]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:22.335]   ..$ ...          :<environment: 0x5561f77be300> 
[17:45:22.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:22.335]  - attr(*, "resolved")= logi FALSE
[17:45:22.335]  - attr(*, "total_size")= num 94336
[17:45:22.340] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:22.341] getGlobalsAndPackagesXApply() ... DONE
[17:45:22.341] Number of futures (= number of chunks): 2
[17:45:22.341] Launching 2 futures (chunks) ...
[17:45:22.341] Chunk #1 of 2 ...
[17:45:22.341]  - Finding globals in 'X' for chunk #1 ...
[17:45:22.341] getGlobalsAndPackages() ...
[17:45:22.341] Searching for globals...
[17:45:22.341] 
[17:45:22.342] Searching for globals ... DONE
[17:45:22.342] - globals: [0] <none>
[17:45:22.342] getGlobalsAndPackages() ... DONE
[17:45:22.342]    + additional globals found: [n=0] 
[17:45:22.342]    + additional namespaces needed: [n=0] 
[17:45:22.342]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:22.342]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:22.342]  - seeds: <none>
[17:45:22.342]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.342] getGlobalsAndPackages() ...
[17:45:22.342] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.343] Resolving globals: FALSE
[17:45:22.343] Tweak future expression to call with '...' arguments ...
[17:45:22.343] {
[17:45:22.343]     do.call(function(...) {
[17:45:22.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.343]             on.exit(options(oopts), add = TRUE)
[17:45:22.343]         }
[17:45:22.343]         {
[17:45:22.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.343]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.343]             })
[17:45:22.343]         }
[17:45:22.343]     }, args = future.call.arguments)
[17:45:22.343] }
[17:45:22.343] Tweak future expression to call with '...' arguments ... DONE
[17:45:22.345] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.346] - packages: [1] ‘future.apply’
[17:45:22.346] getGlobalsAndPackages() ... DONE
[17:45:22.346] run() for ‘Future’ ...
[17:45:22.346] - state: ‘created’
[17:45:22.346] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:22.361] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:22.361]   - Field: ‘node’
[17:45:22.361]   - Field: ‘label’
[17:45:22.361]   - Field: ‘local’
[17:45:22.361]   - Field: ‘owner’
[17:45:22.361]   - Field: ‘envir’
[17:45:22.361]   - Field: ‘workers’
[17:45:22.362]   - Field: ‘packages’
[17:45:22.362]   - Field: ‘gc’
[17:45:22.362]   - Field: ‘conditions’
[17:45:22.362]   - Field: ‘persistent’
[17:45:22.362]   - Field: ‘expr’
[17:45:22.362]   - Field: ‘uuid’
[17:45:22.362]   - Field: ‘seed’
[17:45:22.362]   - Field: ‘version’
[17:45:22.362]   - Field: ‘result’
[17:45:22.362]   - Field: ‘asynchronous’
[17:45:22.362]   - Field: ‘calls’
[17:45:22.362]   - Field: ‘globals’
[17:45:22.363]   - Field: ‘stdout’
[17:45:22.363]   - Field: ‘earlySignal’
[17:45:22.363]   - Field: ‘lazy’
[17:45:22.363]   - Field: ‘state’
[17:45:22.363] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:22.363] - Launch lazy future ...
[17:45:22.363] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:22.363] Packages needed by future strategies (n = 0): <none>
[17:45:22.364] {
[17:45:22.364]     {
[17:45:22.364]         {
[17:45:22.364]             ...future.startTime <- base::Sys.time()
[17:45:22.364]             {
[17:45:22.364]                 {
[17:45:22.364]                   {
[17:45:22.364]                     {
[17:45:22.364]                       {
[17:45:22.364]                         base::local({
[17:45:22.364]                           has_future <- base::requireNamespace("future", 
[17:45:22.364]                             quietly = TRUE)
[17:45:22.364]                           if (has_future) {
[17:45:22.364]                             ns <- base::getNamespace("future")
[17:45:22.364]                             version <- ns[[".package"]][["version"]]
[17:45:22.364]                             if (is.null(version)) 
[17:45:22.364]                               version <- utils::packageVersion("future")
[17:45:22.364]                           }
[17:45:22.364]                           else {
[17:45:22.364]                             version <- NULL
[17:45:22.364]                           }
[17:45:22.364]                           if (!has_future || version < "1.8.0") {
[17:45:22.364]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:22.364]                               "", base::R.version$version.string), 
[17:45:22.364]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:22.364]                                 base::R.version$platform, 8 * 
[17:45:22.364]                                   base::.Machine$sizeof.pointer), 
[17:45:22.364]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:22.364]                                 "release", "version")], collapse = " "), 
[17:45:22.364]                               hostname = base::Sys.info()[["nodename"]])
[17:45:22.364]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:22.364]                               info)
[17:45:22.364]                             info <- base::paste(info, collapse = "; ")
[17:45:22.364]                             if (!has_future) {
[17:45:22.364]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:22.364]                                 info)
[17:45:22.364]                             }
[17:45:22.364]                             else {
[17:45:22.364]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:22.364]                                 info, version)
[17:45:22.364]                             }
[17:45:22.364]                             base::stop(msg)
[17:45:22.364]                           }
[17:45:22.364]                         })
[17:45:22.364]                       }
[17:45:22.364]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:22.364]                       base::options(mc.cores = 1L)
[17:45:22.364]                     }
[17:45:22.364]                     base::local({
[17:45:22.364]                       for (pkg in "future.apply") {
[17:45:22.364]                         base::loadNamespace(pkg)
[17:45:22.364]                         base::library(pkg, character.only = TRUE)
[17:45:22.364]                       }
[17:45:22.364]                     })
[17:45:22.364]                   }
[17:45:22.364]                   ...future.strategy.old <- future::plan("list")
[17:45:22.364]                   options(future.plan = NULL)
[17:45:22.364]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.364]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:22.364]                 }
[17:45:22.364]                 ...future.workdir <- getwd()
[17:45:22.364]             }
[17:45:22.364]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:22.364]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:22.364]         }
[17:45:22.364]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:22.364]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:22.364]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:22.364]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:22.364]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:22.364]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:22.364]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:22.364]             base::names(...future.oldOptions))
[17:45:22.364]     }
[17:45:22.364]     if (FALSE) {
[17:45:22.364]     }
[17:45:22.364]     else {
[17:45:22.364]         if (TRUE) {
[17:45:22.364]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:22.364]                 open = "w")
[17:45:22.364]         }
[17:45:22.364]         else {
[17:45:22.364]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:22.364]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:22.364]         }
[17:45:22.364]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:22.364]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:22.364]             base::sink(type = "output", split = FALSE)
[17:45:22.364]             base::close(...future.stdout)
[17:45:22.364]         }, add = TRUE)
[17:45:22.364]     }
[17:45:22.364]     ...future.frame <- base::sys.nframe()
[17:45:22.364]     ...future.conditions <- base::list()
[17:45:22.364]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:22.364]     if (FALSE) {
[17:45:22.364]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:22.364]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:22.364]     }
[17:45:22.364]     ...future.result <- base::tryCatch({
[17:45:22.364]         base::withCallingHandlers({
[17:45:22.364]             ...future.value <- base::withVisible(base::local({
[17:45:22.364]                 ...future.makeSendCondition <- base::local({
[17:45:22.364]                   sendCondition <- NULL
[17:45:22.364]                   function(frame = 1L) {
[17:45:22.364]                     if (is.function(sendCondition)) 
[17:45:22.364]                       return(sendCondition)
[17:45:22.364]                     ns <- getNamespace("parallel")
[17:45:22.364]                     if (exists("sendData", mode = "function", 
[17:45:22.364]                       envir = ns)) {
[17:45:22.364]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:22.364]                         envir = ns)
[17:45:22.364]                       envir <- sys.frame(frame)
[17:45:22.364]                       master <- NULL
[17:45:22.364]                       while (!identical(envir, .GlobalEnv) && 
[17:45:22.364]                         !identical(envir, emptyenv())) {
[17:45:22.364]                         if (exists("master", mode = "list", envir = envir, 
[17:45:22.364]                           inherits = FALSE)) {
[17:45:22.364]                           master <- get("master", mode = "list", 
[17:45:22.364]                             envir = envir, inherits = FALSE)
[17:45:22.364]                           if (inherits(master, c("SOCKnode", 
[17:45:22.364]                             "SOCK0node"))) {
[17:45:22.364]                             sendCondition <<- function(cond) {
[17:45:22.364]                               data <- list(type = "VALUE", value = cond, 
[17:45:22.364]                                 success = TRUE)
[17:45:22.364]                               parallel_sendData(master, data)
[17:45:22.364]                             }
[17:45:22.364]                             return(sendCondition)
[17:45:22.364]                           }
[17:45:22.364]                         }
[17:45:22.364]                         frame <- frame + 1L
[17:45:22.364]                         envir <- sys.frame(frame)
[17:45:22.364]                       }
[17:45:22.364]                     }
[17:45:22.364]                     sendCondition <<- function(cond) NULL
[17:45:22.364]                   }
[17:45:22.364]                 })
[17:45:22.364]                 withCallingHandlers({
[17:45:22.364]                   {
[17:45:22.364]                     do.call(function(...) {
[17:45:22.364]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.364]                       if (!identical(...future.globals.maxSize.org, 
[17:45:22.364]                         ...future.globals.maxSize)) {
[17:45:22.364]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.364]                         on.exit(options(oopts), add = TRUE)
[17:45:22.364]                       }
[17:45:22.364]                       {
[17:45:22.364]                         lapply(seq_along(...future.elements_ii), 
[17:45:22.364]                           FUN = function(jj) {
[17:45:22.364]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.364]                             ...future.FUN(...future.X_jj, ...)
[17:45:22.364]                           })
[17:45:22.364]                       }
[17:45:22.364]                     }, args = future.call.arguments)
[17:45:22.364]                   }
[17:45:22.364]                 }, immediateCondition = function(cond) {
[17:45:22.364]                   sendCondition <- ...future.makeSendCondition()
[17:45:22.364]                   sendCondition(cond)
[17:45:22.364]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.364]                   {
[17:45:22.364]                     inherits <- base::inherits
[17:45:22.364]                     invokeRestart <- base::invokeRestart
[17:45:22.364]                     is.null <- base::is.null
[17:45:22.364]                     muffled <- FALSE
[17:45:22.364]                     if (inherits(cond, "message")) {
[17:45:22.364]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:22.364]                       if (muffled) 
[17:45:22.364]                         invokeRestart("muffleMessage")
[17:45:22.364]                     }
[17:45:22.364]                     else if (inherits(cond, "warning")) {
[17:45:22.364]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:22.364]                       if (muffled) 
[17:45:22.364]                         invokeRestart("muffleWarning")
[17:45:22.364]                     }
[17:45:22.364]                     else if (inherits(cond, "condition")) {
[17:45:22.364]                       if (!is.null(pattern)) {
[17:45:22.364]                         computeRestarts <- base::computeRestarts
[17:45:22.364]                         grepl <- base::grepl
[17:45:22.364]                         restarts <- computeRestarts(cond)
[17:45:22.364]                         for (restart in restarts) {
[17:45:22.364]                           name <- restart$name
[17:45:22.364]                           if (is.null(name)) 
[17:45:22.364]                             next
[17:45:22.364]                           if (!grepl(pattern, name)) 
[17:45:22.364]                             next
[17:45:22.364]                           invokeRestart(restart)
[17:45:22.364]                           muffled <- TRUE
[17:45:22.364]                           break
[17:45:22.364]                         }
[17:45:22.364]                       }
[17:45:22.364]                     }
[17:45:22.364]                     invisible(muffled)
[17:45:22.364]                   }
[17:45:22.364]                   muffleCondition(cond)
[17:45:22.364]                 })
[17:45:22.364]             }))
[17:45:22.364]             future::FutureResult(value = ...future.value$value, 
[17:45:22.364]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.364]                   ...future.rng), globalenv = if (FALSE) 
[17:45:22.364]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:22.364]                     ...future.globalenv.names))
[17:45:22.364]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:22.364]         }, condition = base::local({
[17:45:22.364]             c <- base::c
[17:45:22.364]             inherits <- base::inherits
[17:45:22.364]             invokeRestart <- base::invokeRestart
[17:45:22.364]             length <- base::length
[17:45:22.364]             list <- base::list
[17:45:22.364]             seq.int <- base::seq.int
[17:45:22.364]             signalCondition <- base::signalCondition
[17:45:22.364]             sys.calls <- base::sys.calls
[17:45:22.364]             `[[` <- base::`[[`
[17:45:22.364]             `+` <- base::`+`
[17:45:22.364]             `<<-` <- base::`<<-`
[17:45:22.364]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:22.364]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:22.364]                   3L)]
[17:45:22.364]             }
[17:45:22.364]             function(cond) {
[17:45:22.364]                 is_error <- inherits(cond, "error")
[17:45:22.364]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:22.364]                   NULL)
[17:45:22.364]                 if (is_error) {
[17:45:22.364]                   sessionInformation <- function() {
[17:45:22.364]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:22.364]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:22.364]                       search = base::search(), system = base::Sys.info())
[17:45:22.364]                   }
[17:45:22.364]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.364]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:22.364]                     cond$call), session = sessionInformation(), 
[17:45:22.364]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:22.364]                   signalCondition(cond)
[17:45:22.364]                 }
[17:45:22.364]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:22.364]                 "immediateCondition"))) {
[17:45:22.364]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:22.364]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.364]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:22.364]                   if (TRUE && !signal) {
[17:45:22.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.364]                     {
[17:45:22.364]                       inherits <- base::inherits
[17:45:22.364]                       invokeRestart <- base::invokeRestart
[17:45:22.364]                       is.null <- base::is.null
[17:45:22.364]                       muffled <- FALSE
[17:45:22.364]                       if (inherits(cond, "message")) {
[17:45:22.364]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.364]                         if (muffled) 
[17:45:22.364]                           invokeRestart("muffleMessage")
[17:45:22.364]                       }
[17:45:22.364]                       else if (inherits(cond, "warning")) {
[17:45:22.364]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.364]                         if (muffled) 
[17:45:22.364]                           invokeRestart("muffleWarning")
[17:45:22.364]                       }
[17:45:22.364]                       else if (inherits(cond, "condition")) {
[17:45:22.364]                         if (!is.null(pattern)) {
[17:45:22.364]                           computeRestarts <- base::computeRestarts
[17:45:22.364]                           grepl <- base::grepl
[17:45:22.364]                           restarts <- computeRestarts(cond)
[17:45:22.364]                           for (restart in restarts) {
[17:45:22.364]                             name <- restart$name
[17:45:22.364]                             if (is.null(name)) 
[17:45:22.364]                               next
[17:45:22.364]                             if (!grepl(pattern, name)) 
[17:45:22.364]                               next
[17:45:22.364]                             invokeRestart(restart)
[17:45:22.364]                             muffled <- TRUE
[17:45:22.364]                             break
[17:45:22.364]                           }
[17:45:22.364]                         }
[17:45:22.364]                       }
[17:45:22.364]                       invisible(muffled)
[17:45:22.364]                     }
[17:45:22.364]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.364]                   }
[17:45:22.364]                 }
[17:45:22.364]                 else {
[17:45:22.364]                   if (TRUE) {
[17:45:22.364]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.364]                     {
[17:45:22.364]                       inherits <- base::inherits
[17:45:22.364]                       invokeRestart <- base::invokeRestart
[17:45:22.364]                       is.null <- base::is.null
[17:45:22.364]                       muffled <- FALSE
[17:45:22.364]                       if (inherits(cond, "message")) {
[17:45:22.364]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.364]                         if (muffled) 
[17:45:22.364]                           invokeRestart("muffleMessage")
[17:45:22.364]                       }
[17:45:22.364]                       else if (inherits(cond, "warning")) {
[17:45:22.364]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.364]                         if (muffled) 
[17:45:22.364]                           invokeRestart("muffleWarning")
[17:45:22.364]                       }
[17:45:22.364]                       else if (inherits(cond, "condition")) {
[17:45:22.364]                         if (!is.null(pattern)) {
[17:45:22.364]                           computeRestarts <- base::computeRestarts
[17:45:22.364]                           grepl <- base::grepl
[17:45:22.364]                           restarts <- computeRestarts(cond)
[17:45:22.364]                           for (restart in restarts) {
[17:45:22.364]                             name <- restart$name
[17:45:22.364]                             if (is.null(name)) 
[17:45:22.364]                               next
[17:45:22.364]                             if (!grepl(pattern, name)) 
[17:45:22.364]                               next
[17:45:22.364]                             invokeRestart(restart)
[17:45:22.364]                             muffled <- TRUE
[17:45:22.364]                             break
[17:45:22.364]                           }
[17:45:22.364]                         }
[17:45:22.364]                       }
[17:45:22.364]                       invisible(muffled)
[17:45:22.364]                     }
[17:45:22.364]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.364]                   }
[17:45:22.364]                 }
[17:45:22.364]             }
[17:45:22.364]         }))
[17:45:22.364]     }, error = function(ex) {
[17:45:22.364]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:22.364]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.364]                 ...future.rng), started = ...future.startTime, 
[17:45:22.364]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:22.364]             version = "1.8"), class = "FutureResult")
[17:45:22.364]     }, finally = {
[17:45:22.364]         if (!identical(...future.workdir, getwd())) 
[17:45:22.364]             setwd(...future.workdir)
[17:45:22.364]         {
[17:45:22.364]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:22.364]                 ...future.oldOptions$nwarnings <- NULL
[17:45:22.364]             }
[17:45:22.364]             base::options(...future.oldOptions)
[17:45:22.364]             if (.Platform$OS.type == "windows") {
[17:45:22.364]                 old_names <- names(...future.oldEnvVars)
[17:45:22.364]                 envs <- base::Sys.getenv()
[17:45:22.364]                 names <- names(envs)
[17:45:22.364]                 common <- intersect(names, old_names)
[17:45:22.364]                 added <- setdiff(names, old_names)
[17:45:22.364]                 removed <- setdiff(old_names, names)
[17:45:22.364]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:22.364]                   envs[common]]
[17:45:22.364]                 NAMES <- toupper(changed)
[17:45:22.364]                 args <- list()
[17:45:22.364]                 for (kk in seq_along(NAMES)) {
[17:45:22.364]                   name <- changed[[kk]]
[17:45:22.364]                   NAME <- NAMES[[kk]]
[17:45:22.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.364]                     next
[17:45:22.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.364]                 }
[17:45:22.364]                 NAMES <- toupper(added)
[17:45:22.364]                 for (kk in seq_along(NAMES)) {
[17:45:22.364]                   name <- added[[kk]]
[17:45:22.364]                   NAME <- NAMES[[kk]]
[17:45:22.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.364]                     next
[17:45:22.364]                   args[[name]] <- ""
[17:45:22.364]                 }
[17:45:22.364]                 NAMES <- toupper(removed)
[17:45:22.364]                 for (kk in seq_along(NAMES)) {
[17:45:22.364]                   name <- removed[[kk]]
[17:45:22.364]                   NAME <- NAMES[[kk]]
[17:45:22.364]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.364]                     next
[17:45:22.364]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.364]                 }
[17:45:22.364]                 if (length(args) > 0) 
[17:45:22.364]                   base::do.call(base::Sys.setenv, args = args)
[17:45:22.364]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:22.364]             }
[17:45:22.364]             else {
[17:45:22.364]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:22.364]             }
[17:45:22.364]             {
[17:45:22.364]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:22.364]                   0L) {
[17:45:22.364]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:22.364]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:22.364]                   base::options(opts)
[17:45:22.364]                 }
[17:45:22.364]                 {
[17:45:22.364]                   {
[17:45:22.364]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:22.364]                     NULL
[17:45:22.364]                   }
[17:45:22.364]                   options(future.plan = NULL)
[17:45:22.364]                   if (is.na(NA_character_)) 
[17:45:22.364]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.364]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:22.364]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:22.364]                     .init = FALSE)
[17:45:22.364]                 }
[17:45:22.364]             }
[17:45:22.364]         }
[17:45:22.364]     })
[17:45:22.364]     if (TRUE) {
[17:45:22.364]         base::sink(type = "output", split = FALSE)
[17:45:22.364]         if (TRUE) {
[17:45:22.364]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:22.364]         }
[17:45:22.364]         else {
[17:45:22.364]             ...future.result["stdout"] <- base::list(NULL)
[17:45:22.364]         }
[17:45:22.364]         base::close(...future.stdout)
[17:45:22.364]         ...future.stdout <- NULL
[17:45:22.364]     }
[17:45:22.364]     ...future.result$conditions <- ...future.conditions
[17:45:22.364]     ...future.result$finished <- base::Sys.time()
[17:45:22.364]     ...future.result
[17:45:22.364] }
[17:45:22.367] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[17:45:22.367] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:22.408] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:22.408] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:45:22.408] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:45:22.408] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:22.409] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:22.409] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:22.452] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:22.452] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:22.496] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:22.496] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:22.496] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.497] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:22.497] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:22.497] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:22.498] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.498] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:22.498] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:22.498] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:22.499] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.499] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:22.499] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.499] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[17:45:22.500] MultisessionFuture started
[17:45:22.500] - Launch lazy future ... done
[17:45:22.500] run() for ‘MultisessionFuture’ ... done
[17:45:22.500] Created future:
[17:45:22.501] receiveMessageFromWorker() for ClusterFuture ...
[17:45:22.502] - Validating connection of MultisessionFuture
[17:45:22.502] - received message: FutureResult
[17:45:22.502] - Received FutureResult
[17:45:22.502] - Erased future from FutureRegistry
[17:45:22.502] result() for ClusterFuture ...
[17:45:22.502] - result already collected: FutureResult
[17:45:22.502] result() for ClusterFuture ... done
[17:45:22.502] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:22.500] MultisessionFuture:
[17:45:22.500] Label: ‘future_vapply-1’
[17:45:22.500] Expression:
[17:45:22.500] {
[17:45:22.500]     do.call(function(...) {
[17:45:22.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.500]             on.exit(options(oopts), add = TRUE)
[17:45:22.500]         }
[17:45:22.500]         {
[17:45:22.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.500]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.500]             })
[17:45:22.500]         }
[17:45:22.500]     }, args = future.call.arguments)
[17:45:22.500] }
[17:45:22.500] Lazy evaluation: FALSE
[17:45:22.500] Asynchronous evaluation: TRUE
[17:45:22.500] Local evaluation: TRUE
[17:45:22.500] Environment: R_GlobalEnv
[17:45:22.500] Capture standard output: TRUE
[17:45:22.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:22.500] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:22.500] Packages: 1 packages (‘future.apply’)
[17:45:22.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:22.500] Resolved: TRUE
[17:45:22.500] Value: <not collected>
[17:45:22.500] Conditions captured: <none>
[17:45:22.500] Early signaling: FALSE
[17:45:22.500] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:22.500] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.503] Chunk #1 of 2 ... DONE
[17:45:22.503] Chunk #2 of 2 ...
[17:45:22.503]  - Finding globals in 'X' for chunk #2 ...
[17:45:22.503] getGlobalsAndPackages() ...
[17:45:22.503] Searching for globals...
[17:45:22.503] 
[17:45:22.503] Searching for globals ... DONE
[17:45:22.504] - globals: [0] <none>
[17:45:22.504] getGlobalsAndPackages() ... DONE
[17:45:22.504]    + additional globals found: [n=0] 
[17:45:22.504]    + additional namespaces needed: [n=0] 
[17:45:22.504]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:22.504]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:22.504]  - seeds: <none>
[17:45:22.504]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.504] getGlobalsAndPackages() ...
[17:45:22.504] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.505] Resolving globals: FALSE
[17:45:22.505] Tweak future expression to call with '...' arguments ...
[17:45:22.505] {
[17:45:22.505]     do.call(function(...) {
[17:45:22.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.505]             on.exit(options(oopts), add = TRUE)
[17:45:22.505]         }
[17:45:22.505]         {
[17:45:22.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.505]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.505]             })
[17:45:22.505]         }
[17:45:22.505]     }, args = future.call.arguments)
[17:45:22.505] }
[17:45:22.505] Tweak future expression to call with '...' arguments ... DONE
[17:45:22.505] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.506] - packages: [1] ‘future.apply’
[17:45:22.506] getGlobalsAndPackages() ... DONE
[17:45:22.506] run() for ‘Future’ ...
[17:45:22.506] - state: ‘created’
[17:45:22.506] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:22.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.521] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:22.522]   - Field: ‘node’
[17:45:22.522]   - Field: ‘label’
[17:45:22.522]   - Field: ‘local’
[17:45:22.522]   - Field: ‘owner’
[17:45:22.522]   - Field: ‘envir’
[17:45:22.522]   - Field: ‘workers’
[17:45:22.522]   - Field: ‘packages’
[17:45:22.522]   - Field: ‘gc’
[17:45:22.522]   - Field: ‘conditions’
[17:45:22.522]   - Field: ‘persistent’
[17:45:22.522]   - Field: ‘expr’
[17:45:22.523]   - Field: ‘uuid’
[17:45:22.523]   - Field: ‘seed’
[17:45:22.523]   - Field: ‘version’
[17:45:22.523]   - Field: ‘result’
[17:45:22.523]   - Field: ‘asynchronous’
[17:45:22.523]   - Field: ‘calls’
[17:45:22.523]   - Field: ‘globals’
[17:45:22.523]   - Field: ‘stdout’
[17:45:22.523]   - Field: ‘earlySignal’
[17:45:22.523]   - Field: ‘lazy’
[17:45:22.523]   - Field: ‘state’
[17:45:22.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:22.524] - Launch lazy future ...
[17:45:22.524] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:22.524] Packages needed by future strategies (n = 0): <none>
[17:45:22.525] {
[17:45:22.525]     {
[17:45:22.525]         {
[17:45:22.525]             ...future.startTime <- base::Sys.time()
[17:45:22.525]             {
[17:45:22.525]                 {
[17:45:22.525]                   {
[17:45:22.525]                     {
[17:45:22.525]                       {
[17:45:22.525]                         base::local({
[17:45:22.525]                           has_future <- base::requireNamespace("future", 
[17:45:22.525]                             quietly = TRUE)
[17:45:22.525]                           if (has_future) {
[17:45:22.525]                             ns <- base::getNamespace("future")
[17:45:22.525]                             version <- ns[[".package"]][["version"]]
[17:45:22.525]                             if (is.null(version)) 
[17:45:22.525]                               version <- utils::packageVersion("future")
[17:45:22.525]                           }
[17:45:22.525]                           else {
[17:45:22.525]                             version <- NULL
[17:45:22.525]                           }
[17:45:22.525]                           if (!has_future || version < "1.8.0") {
[17:45:22.525]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:22.525]                               "", base::R.version$version.string), 
[17:45:22.525]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:22.525]                                 base::R.version$platform, 8 * 
[17:45:22.525]                                   base::.Machine$sizeof.pointer), 
[17:45:22.525]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:22.525]                                 "release", "version")], collapse = " "), 
[17:45:22.525]                               hostname = base::Sys.info()[["nodename"]])
[17:45:22.525]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:22.525]                               info)
[17:45:22.525]                             info <- base::paste(info, collapse = "; ")
[17:45:22.525]                             if (!has_future) {
[17:45:22.525]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:22.525]                                 info)
[17:45:22.525]                             }
[17:45:22.525]                             else {
[17:45:22.525]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:22.525]                                 info, version)
[17:45:22.525]                             }
[17:45:22.525]                             base::stop(msg)
[17:45:22.525]                           }
[17:45:22.525]                         })
[17:45:22.525]                       }
[17:45:22.525]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:22.525]                       base::options(mc.cores = 1L)
[17:45:22.525]                     }
[17:45:22.525]                     base::local({
[17:45:22.525]                       for (pkg in "future.apply") {
[17:45:22.525]                         base::loadNamespace(pkg)
[17:45:22.525]                         base::library(pkg, character.only = TRUE)
[17:45:22.525]                       }
[17:45:22.525]                     })
[17:45:22.525]                   }
[17:45:22.525]                   ...future.strategy.old <- future::plan("list")
[17:45:22.525]                   options(future.plan = NULL)
[17:45:22.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:22.525]                 }
[17:45:22.525]                 ...future.workdir <- getwd()
[17:45:22.525]             }
[17:45:22.525]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:22.525]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:22.525]         }
[17:45:22.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:22.525]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:22.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:22.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:22.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:22.525]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:22.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:22.525]             base::names(...future.oldOptions))
[17:45:22.525]     }
[17:45:22.525]     if (FALSE) {
[17:45:22.525]     }
[17:45:22.525]     else {
[17:45:22.525]         if (TRUE) {
[17:45:22.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:22.525]                 open = "w")
[17:45:22.525]         }
[17:45:22.525]         else {
[17:45:22.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:22.525]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:22.525]         }
[17:45:22.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:22.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:22.525]             base::sink(type = "output", split = FALSE)
[17:45:22.525]             base::close(...future.stdout)
[17:45:22.525]         }, add = TRUE)
[17:45:22.525]     }
[17:45:22.525]     ...future.frame <- base::sys.nframe()
[17:45:22.525]     ...future.conditions <- base::list()
[17:45:22.525]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:22.525]     if (FALSE) {
[17:45:22.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:22.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:22.525]     }
[17:45:22.525]     ...future.result <- base::tryCatch({
[17:45:22.525]         base::withCallingHandlers({
[17:45:22.525]             ...future.value <- base::withVisible(base::local({
[17:45:22.525]                 ...future.makeSendCondition <- base::local({
[17:45:22.525]                   sendCondition <- NULL
[17:45:22.525]                   function(frame = 1L) {
[17:45:22.525]                     if (is.function(sendCondition)) 
[17:45:22.525]                       return(sendCondition)
[17:45:22.525]                     ns <- getNamespace("parallel")
[17:45:22.525]                     if (exists("sendData", mode = "function", 
[17:45:22.525]                       envir = ns)) {
[17:45:22.525]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:22.525]                         envir = ns)
[17:45:22.525]                       envir <- sys.frame(frame)
[17:45:22.525]                       master <- NULL
[17:45:22.525]                       while (!identical(envir, .GlobalEnv) && 
[17:45:22.525]                         !identical(envir, emptyenv())) {
[17:45:22.525]                         if (exists("master", mode = "list", envir = envir, 
[17:45:22.525]                           inherits = FALSE)) {
[17:45:22.525]                           master <- get("master", mode = "list", 
[17:45:22.525]                             envir = envir, inherits = FALSE)
[17:45:22.525]                           if (inherits(master, c("SOCKnode", 
[17:45:22.525]                             "SOCK0node"))) {
[17:45:22.525]                             sendCondition <<- function(cond) {
[17:45:22.525]                               data <- list(type = "VALUE", value = cond, 
[17:45:22.525]                                 success = TRUE)
[17:45:22.525]                               parallel_sendData(master, data)
[17:45:22.525]                             }
[17:45:22.525]                             return(sendCondition)
[17:45:22.525]                           }
[17:45:22.525]                         }
[17:45:22.525]                         frame <- frame + 1L
[17:45:22.525]                         envir <- sys.frame(frame)
[17:45:22.525]                       }
[17:45:22.525]                     }
[17:45:22.525]                     sendCondition <<- function(cond) NULL
[17:45:22.525]                   }
[17:45:22.525]                 })
[17:45:22.525]                 withCallingHandlers({
[17:45:22.525]                   {
[17:45:22.525]                     do.call(function(...) {
[17:45:22.525]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.525]                       if (!identical(...future.globals.maxSize.org, 
[17:45:22.525]                         ...future.globals.maxSize)) {
[17:45:22.525]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.525]                         on.exit(options(oopts), add = TRUE)
[17:45:22.525]                       }
[17:45:22.525]                       {
[17:45:22.525]                         lapply(seq_along(...future.elements_ii), 
[17:45:22.525]                           FUN = function(jj) {
[17:45:22.525]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.525]                             ...future.FUN(...future.X_jj, ...)
[17:45:22.525]                           })
[17:45:22.525]                       }
[17:45:22.525]                     }, args = future.call.arguments)
[17:45:22.525]                   }
[17:45:22.525]                 }, immediateCondition = function(cond) {
[17:45:22.525]                   sendCondition <- ...future.makeSendCondition()
[17:45:22.525]                   sendCondition(cond)
[17:45:22.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.525]                   {
[17:45:22.525]                     inherits <- base::inherits
[17:45:22.525]                     invokeRestart <- base::invokeRestart
[17:45:22.525]                     is.null <- base::is.null
[17:45:22.525]                     muffled <- FALSE
[17:45:22.525]                     if (inherits(cond, "message")) {
[17:45:22.525]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:22.525]                       if (muffled) 
[17:45:22.525]                         invokeRestart("muffleMessage")
[17:45:22.525]                     }
[17:45:22.525]                     else if (inherits(cond, "warning")) {
[17:45:22.525]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:22.525]                       if (muffled) 
[17:45:22.525]                         invokeRestart("muffleWarning")
[17:45:22.525]                     }
[17:45:22.525]                     else if (inherits(cond, "condition")) {
[17:45:22.525]                       if (!is.null(pattern)) {
[17:45:22.525]                         computeRestarts <- base::computeRestarts
[17:45:22.525]                         grepl <- base::grepl
[17:45:22.525]                         restarts <- computeRestarts(cond)
[17:45:22.525]                         for (restart in restarts) {
[17:45:22.525]                           name <- restart$name
[17:45:22.525]                           if (is.null(name)) 
[17:45:22.525]                             next
[17:45:22.525]                           if (!grepl(pattern, name)) 
[17:45:22.525]                             next
[17:45:22.525]                           invokeRestart(restart)
[17:45:22.525]                           muffled <- TRUE
[17:45:22.525]                           break
[17:45:22.525]                         }
[17:45:22.525]                       }
[17:45:22.525]                     }
[17:45:22.525]                     invisible(muffled)
[17:45:22.525]                   }
[17:45:22.525]                   muffleCondition(cond)
[17:45:22.525]                 })
[17:45:22.525]             }))
[17:45:22.525]             future::FutureResult(value = ...future.value$value, 
[17:45:22.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.525]                   ...future.rng), globalenv = if (FALSE) 
[17:45:22.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:22.525]                     ...future.globalenv.names))
[17:45:22.525]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:22.525]         }, condition = base::local({
[17:45:22.525]             c <- base::c
[17:45:22.525]             inherits <- base::inherits
[17:45:22.525]             invokeRestart <- base::invokeRestart
[17:45:22.525]             length <- base::length
[17:45:22.525]             list <- base::list
[17:45:22.525]             seq.int <- base::seq.int
[17:45:22.525]             signalCondition <- base::signalCondition
[17:45:22.525]             sys.calls <- base::sys.calls
[17:45:22.525]             `[[` <- base::`[[`
[17:45:22.525]             `+` <- base::`+`
[17:45:22.525]             `<<-` <- base::`<<-`
[17:45:22.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:22.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:22.525]                   3L)]
[17:45:22.525]             }
[17:45:22.525]             function(cond) {
[17:45:22.525]                 is_error <- inherits(cond, "error")
[17:45:22.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:22.525]                   NULL)
[17:45:22.525]                 if (is_error) {
[17:45:22.525]                   sessionInformation <- function() {
[17:45:22.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:22.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:22.525]                       search = base::search(), system = base::Sys.info())
[17:45:22.525]                   }
[17:45:22.525]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:22.525]                     cond$call), session = sessionInformation(), 
[17:45:22.525]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:22.525]                   signalCondition(cond)
[17:45:22.525]                 }
[17:45:22.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:22.525]                 "immediateCondition"))) {
[17:45:22.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:22.525]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:22.525]                   if (TRUE && !signal) {
[17:45:22.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.525]                     {
[17:45:22.525]                       inherits <- base::inherits
[17:45:22.525]                       invokeRestart <- base::invokeRestart
[17:45:22.525]                       is.null <- base::is.null
[17:45:22.525]                       muffled <- FALSE
[17:45:22.525]                       if (inherits(cond, "message")) {
[17:45:22.525]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.525]                         if (muffled) 
[17:45:22.525]                           invokeRestart("muffleMessage")
[17:45:22.525]                       }
[17:45:22.525]                       else if (inherits(cond, "warning")) {
[17:45:22.525]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.525]                         if (muffled) 
[17:45:22.525]                           invokeRestart("muffleWarning")
[17:45:22.525]                       }
[17:45:22.525]                       else if (inherits(cond, "condition")) {
[17:45:22.525]                         if (!is.null(pattern)) {
[17:45:22.525]                           computeRestarts <- base::computeRestarts
[17:45:22.525]                           grepl <- base::grepl
[17:45:22.525]                           restarts <- computeRestarts(cond)
[17:45:22.525]                           for (restart in restarts) {
[17:45:22.525]                             name <- restart$name
[17:45:22.525]                             if (is.null(name)) 
[17:45:22.525]                               next
[17:45:22.525]                             if (!grepl(pattern, name)) 
[17:45:22.525]                               next
[17:45:22.525]                             invokeRestart(restart)
[17:45:22.525]                             muffled <- TRUE
[17:45:22.525]                             break
[17:45:22.525]                           }
[17:45:22.525]                         }
[17:45:22.525]                       }
[17:45:22.525]                       invisible(muffled)
[17:45:22.525]                     }
[17:45:22.525]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.525]                   }
[17:45:22.525]                 }
[17:45:22.525]                 else {
[17:45:22.525]                   if (TRUE) {
[17:45:22.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.525]                     {
[17:45:22.525]                       inherits <- base::inherits
[17:45:22.525]                       invokeRestart <- base::invokeRestart
[17:45:22.525]                       is.null <- base::is.null
[17:45:22.525]                       muffled <- FALSE
[17:45:22.525]                       if (inherits(cond, "message")) {
[17:45:22.525]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.525]                         if (muffled) 
[17:45:22.525]                           invokeRestart("muffleMessage")
[17:45:22.525]                       }
[17:45:22.525]                       else if (inherits(cond, "warning")) {
[17:45:22.525]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.525]                         if (muffled) 
[17:45:22.525]                           invokeRestart("muffleWarning")
[17:45:22.525]                       }
[17:45:22.525]                       else if (inherits(cond, "condition")) {
[17:45:22.525]                         if (!is.null(pattern)) {
[17:45:22.525]                           computeRestarts <- base::computeRestarts
[17:45:22.525]                           grepl <- base::grepl
[17:45:22.525]                           restarts <- computeRestarts(cond)
[17:45:22.525]                           for (restart in restarts) {
[17:45:22.525]                             name <- restart$name
[17:45:22.525]                             if (is.null(name)) 
[17:45:22.525]                               next
[17:45:22.525]                             if (!grepl(pattern, name)) 
[17:45:22.525]                               next
[17:45:22.525]                             invokeRestart(restart)
[17:45:22.525]                             muffled <- TRUE
[17:45:22.525]                             break
[17:45:22.525]                           }
[17:45:22.525]                         }
[17:45:22.525]                       }
[17:45:22.525]                       invisible(muffled)
[17:45:22.525]                     }
[17:45:22.525]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.525]                   }
[17:45:22.525]                 }
[17:45:22.525]             }
[17:45:22.525]         }))
[17:45:22.525]     }, error = function(ex) {
[17:45:22.525]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:22.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.525]                 ...future.rng), started = ...future.startTime, 
[17:45:22.525]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:22.525]             version = "1.8"), class = "FutureResult")
[17:45:22.525]     }, finally = {
[17:45:22.525]         if (!identical(...future.workdir, getwd())) 
[17:45:22.525]             setwd(...future.workdir)
[17:45:22.525]         {
[17:45:22.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:22.525]                 ...future.oldOptions$nwarnings <- NULL
[17:45:22.525]             }
[17:45:22.525]             base::options(...future.oldOptions)
[17:45:22.525]             if (.Platform$OS.type == "windows") {
[17:45:22.525]                 old_names <- names(...future.oldEnvVars)
[17:45:22.525]                 envs <- base::Sys.getenv()
[17:45:22.525]                 names <- names(envs)
[17:45:22.525]                 common <- intersect(names, old_names)
[17:45:22.525]                 added <- setdiff(names, old_names)
[17:45:22.525]                 removed <- setdiff(old_names, names)
[17:45:22.525]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:22.525]                   envs[common]]
[17:45:22.525]                 NAMES <- toupper(changed)
[17:45:22.525]                 args <- list()
[17:45:22.525]                 for (kk in seq_along(NAMES)) {
[17:45:22.525]                   name <- changed[[kk]]
[17:45:22.525]                   NAME <- NAMES[[kk]]
[17:45:22.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.525]                     next
[17:45:22.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.525]                 }
[17:45:22.525]                 NAMES <- toupper(added)
[17:45:22.525]                 for (kk in seq_along(NAMES)) {
[17:45:22.525]                   name <- added[[kk]]
[17:45:22.525]                   NAME <- NAMES[[kk]]
[17:45:22.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.525]                     next
[17:45:22.525]                   args[[name]] <- ""
[17:45:22.525]                 }
[17:45:22.525]                 NAMES <- toupper(removed)
[17:45:22.525]                 for (kk in seq_along(NAMES)) {
[17:45:22.525]                   name <- removed[[kk]]
[17:45:22.525]                   NAME <- NAMES[[kk]]
[17:45:22.525]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.525]                     next
[17:45:22.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.525]                 }
[17:45:22.525]                 if (length(args) > 0) 
[17:45:22.525]                   base::do.call(base::Sys.setenv, args = args)
[17:45:22.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:22.525]             }
[17:45:22.525]             else {
[17:45:22.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:22.525]             }
[17:45:22.525]             {
[17:45:22.525]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:22.525]                   0L) {
[17:45:22.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:22.525]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:22.525]                   base::options(opts)
[17:45:22.525]                 }
[17:45:22.525]                 {
[17:45:22.525]                   {
[17:45:22.525]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:22.525]                     NULL
[17:45:22.525]                   }
[17:45:22.525]                   options(future.plan = NULL)
[17:45:22.525]                   if (is.na(NA_character_)) 
[17:45:22.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:22.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:22.525]                     .init = FALSE)
[17:45:22.525]                 }
[17:45:22.525]             }
[17:45:22.525]         }
[17:45:22.525]     })
[17:45:22.525]     if (TRUE) {
[17:45:22.525]         base::sink(type = "output", split = FALSE)
[17:45:22.525]         if (TRUE) {
[17:45:22.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:22.525]         }
[17:45:22.525]         else {
[17:45:22.525]             ...future.result["stdout"] <- base::list(NULL)
[17:45:22.525]         }
[17:45:22.525]         base::close(...future.stdout)
[17:45:22.525]         ...future.stdout <- NULL
[17:45:22.525]     }
[17:45:22.525]     ...future.result$conditions <- ...future.conditions
[17:45:22.525]     ...future.result$finished <- base::Sys.time()
[17:45:22.525]     ...future.result
[17:45:22.525] }
[17:45:22.527] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[17:45:22.527] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:22.572] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:22.572] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:45:22.573] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:45:22.573] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:22.573] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:22.573] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:22.616] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:22.616] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:22.660] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:22.660] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:22.660] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.660] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:22.661] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:22.661] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:22.661] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.662] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:22.662] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:22.662] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:22.662] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.663] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:22.663] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.663] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[17:45:22.664] MultisessionFuture started
[17:45:22.664] - Launch lazy future ... done
[17:45:22.664] run() for ‘MultisessionFuture’ ... done
[17:45:22.664] Created future:
[17:45:22.664] MultisessionFuture:
[17:45:22.664] Label: ‘future_vapply-2’
[17:45:22.664] Expression:
[17:45:22.664] {
[17:45:22.664]     do.call(function(...) {
[17:45:22.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.664]             on.exit(options(oopts), add = TRUE)
[17:45:22.664]         }
[17:45:22.664]         {
[17:45:22.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.664]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.664]             })
[17:45:22.664]         }
[17:45:22.664]     }, args = future.call.arguments)
[17:45:22.664] }
[17:45:22.664] Lazy evaluation: FALSE
[17:45:22.664] Asynchronous evaluation: TRUE
[17:45:22.664] Local evaluation: TRUE
[17:45:22.664] Environment: R_GlobalEnv
[17:45:22.664] Capture standard output: TRUE
[17:45:22.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:22.664] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:22.664] Packages: 1 packages (‘future.apply’)
[17:45:22.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:22.664] Resolved: FALSE
[17:45:22.664] Value: <not collected>
[17:45:22.664] Conditions captured: <none>
[17:45:22.664] Early signaling: FALSE
[17:45:22.664] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:22.664] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.676] Chunk #2 of 2 ... DONE
[17:45:22.676] Launching 2 futures (chunks) ... DONE
[17:45:22.676] Resolving 2 futures (chunks) ...
[17:45:22.676] resolve() on list ...
[17:45:22.676]  recursive: 0
[17:45:22.677]  length: 2
[17:45:22.677] 
[17:45:22.677] Future #1
[17:45:22.677] result() for ClusterFuture ...
[17:45:22.677] - result already collected: FutureResult
[17:45:22.677] result() for ClusterFuture ... done
[17:45:22.677] result() for ClusterFuture ...
[17:45:22.677] - result already collected: FutureResult
[17:45:22.677] result() for ClusterFuture ... done
[17:45:22.677] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:22.677] - nx: 2
[17:45:22.678] - relay: TRUE
[17:45:22.678] - stdout: TRUE
[17:45:22.678] - signal: TRUE
[17:45:22.678] - resignal: FALSE
[17:45:22.678] - force: TRUE
[17:45:22.678] - relayed: [n=2] FALSE, FALSE
[17:45:22.678] - queued futures: [n=2] FALSE, FALSE
[17:45:22.678]  - until=1
[17:45:22.678]  - relaying element #1
[17:45:22.678] result() for ClusterFuture ...
[17:45:22.678] - result already collected: FutureResult
[17:45:22.678] result() for ClusterFuture ... done
[17:45:22.679] result() for ClusterFuture ...
[17:45:22.679] - result already collected: FutureResult
[17:45:22.679] result() for ClusterFuture ... done
[17:45:22.679] result() for ClusterFuture ...
[17:45:22.679] - result already collected: FutureResult
[17:45:22.679] result() for ClusterFuture ... done
[17:45:22.679] result() for ClusterFuture ...
[17:45:22.679] - result already collected: FutureResult
[17:45:22.679] result() for ClusterFuture ... done
[17:45:22.679] - relayed: [n=2] TRUE, FALSE
[17:45:22.679] - queued futures: [n=2] TRUE, FALSE
[17:45:22.680] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:22.680]  length: 1 (resolved future 1)
[17:45:22.709] receiveMessageFromWorker() for ClusterFuture ...
[17:45:22.709] - Validating connection of MultisessionFuture
[17:45:22.709] - received message: FutureResult
[17:45:22.709] - Received FutureResult
[17:45:22.710] - Erased future from FutureRegistry
[17:45:22.710] result() for ClusterFuture ...
[17:45:22.710] - result already collected: FutureResult
[17:45:22.710] result() for ClusterFuture ... done
[17:45:22.710] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:22.710] Future #2
[17:45:22.710] result() for ClusterFuture ...
[17:45:22.710] - result already collected: FutureResult
[17:45:22.710] result() for ClusterFuture ... done
[17:45:22.710] result() for ClusterFuture ...
[17:45:22.710] - result already collected: FutureResult
[17:45:22.710] result() for ClusterFuture ... done
[17:45:22.711] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:22.711] - nx: 2
[17:45:22.711] - relay: TRUE
[17:45:22.711] - stdout: TRUE
[17:45:22.711] - signal: TRUE
[17:45:22.711] - resignal: FALSE
[17:45:22.711] - force: TRUE
[17:45:22.711] - relayed: [n=2] TRUE, FALSE
[17:45:22.711] - queued futures: [n=2] TRUE, FALSE
[17:45:22.711]  - until=2
[17:45:22.711]  - relaying element #2
[17:45:22.712] result() for ClusterFuture ...
[17:45:22.712] - result already collected: FutureResult
[17:45:22.712] result() for ClusterFuture ... done
[17:45:22.712] result() for ClusterFuture ...
[17:45:22.712] - result already collected: FutureResult
[17:45:22.712] result() for ClusterFuture ... done
[17:45:22.712] result() for ClusterFuture ...
[17:45:22.712] - result already collected: FutureResult
[17:45:22.712] result() for ClusterFuture ... done
[17:45:22.712] result() for ClusterFuture ...
[17:45:22.712] - result already collected: FutureResult
[17:45:22.712] result() for ClusterFuture ... done
[17:45:22.713] - relayed: [n=2] TRUE, TRUE
[17:45:22.713] - queued futures: [n=2] TRUE, TRUE
[17:45:22.713] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:22.713]  length: 0 (resolved future 2)
[17:45:22.713] Relaying remaining futures
[17:45:22.713] signalConditionsASAP(NULL, pos=0) ...
[17:45:22.713] - nx: 2
[17:45:22.713] - relay: TRUE
[17:45:22.713] - stdout: TRUE
[17:45:22.713] - signal: TRUE
[17:45:22.713] - resignal: FALSE
[17:45:22.713] - force: TRUE
[17:45:22.714] - relayed: [n=2] TRUE, TRUE
[17:45:22.714] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:22.714] - relayed: [n=2] TRUE, TRUE
[17:45:22.714] - queued futures: [n=2] TRUE, TRUE
[17:45:22.714] signalConditionsASAP(NULL, pos=0) ... done
[17:45:22.714] resolve() on list ... DONE
[17:45:22.714] result() for ClusterFuture ...
[17:45:22.714] - result already collected: FutureResult
[17:45:22.714] result() for ClusterFuture ... done
[17:45:22.714] result() for ClusterFuture ...
[17:45:22.714] - result already collected: FutureResult
[17:45:22.715] result() for ClusterFuture ... done
[17:45:22.715] result() for ClusterFuture ...
[17:45:22.715] - result already collected: FutureResult
[17:45:22.715] result() for ClusterFuture ... done
[17:45:22.715] result() for ClusterFuture ...
[17:45:22.715] - result already collected: FutureResult
[17:45:22.715] result() for ClusterFuture ... done
[17:45:22.715]  - Number of value chunks collected: 2
[17:45:22.715] Resolving 2 futures (chunks) ... DONE
[17:45:22.715] Reducing values from 2 chunks ...
[17:45:22.715]  - Number of values collected after concatenation: 10
[17:45:22.716]  - Number of values expected: 10
[17:45:22.716] Reducing values from 2 chunks ... DONE
[17:45:22.716] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[17:45:22.717] future_lapply() ...
[17:45:22.722] Number of chunks: 2
[17:45:22.722] getGlobalsAndPackagesXApply() ...
[17:45:22.723]  - future.globals: TRUE
[17:45:22.723] getGlobalsAndPackages() ...
[17:45:22.723] Searching for globals...
[17:45:22.726] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[17:45:22.727] Searching for globals ... DONE
[17:45:22.727] Resolving globals: FALSE
[17:45:22.728] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[17:45:22.728] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:22.728] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:22.728] - packages: [1] ‘future.apply’
[17:45:22.728] getGlobalsAndPackages() ... DONE
[17:45:22.728]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:22.729]  - needed namespaces: [n=1] ‘future.apply’
[17:45:22.729] Finding globals ... DONE
[17:45:22.729]  - use_args: TRUE
[17:45:22.729]  - Getting '...' globals ...
[17:45:22.729] resolve() on list ...
[17:45:22.729]  recursive: 0
[17:45:22.729]  length: 1
[17:45:22.729]  elements: ‘...’
[17:45:22.730]  length: 0 (resolved future 1)
[17:45:22.730] resolve() on list ... DONE
[17:45:22.730]    - '...' content: [n=0] 
[17:45:22.730] List of 1
[17:45:22.730]  $ ...: list()
[17:45:22.730]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:22.730]  - attr(*, "where")=List of 1
[17:45:22.730]   ..$ ...:<environment: 0x5561f6ef4ff8> 
[17:45:22.730]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:22.730]  - attr(*, "resolved")= logi TRUE
[17:45:22.730]  - attr(*, "total_size")= num NA
[17:45:22.732]  - Getting '...' globals ... DONE
[17:45:22.733] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:22.733] List of 8
[17:45:22.733]  $ ...future.FUN:function (x, ...)  
[17:45:22.733]  $ x_FUN        :function (x)  
[17:45:22.733]  $ times        : int 2
[17:45:22.733]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:22.733]  $ stop_if_not  :function (...)  
[17:45:22.733]  $ dim          : NULL
[17:45:22.733]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:22.733]  $ ...          : list()
[17:45:22.733]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:22.733]  - attr(*, "where")=List of 8
[17:45:22.733]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:22.733]   ..$ ...          :<environment: 0x5561f6ef4ff8> 
[17:45:22.733]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:22.733]  - attr(*, "resolved")= logi FALSE
[17:45:22.733]  - attr(*, "total_size")= num 96456
[17:45:22.738] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:22.738] getGlobalsAndPackagesXApply() ... DONE
[17:45:22.738] Number of futures (= number of chunks): 2
[17:45:22.738] Launching 2 futures (chunks) ...
[17:45:22.738] Chunk #1 of 2 ...
[17:45:22.739]  - Finding globals in 'X' for chunk #1 ...
[17:45:22.739] getGlobalsAndPackages() ...
[17:45:22.739] Searching for globals...
[17:45:22.739] 
[17:45:22.739] Searching for globals ... DONE
[17:45:22.739] - globals: [0] <none>
[17:45:22.739] getGlobalsAndPackages() ... DONE
[17:45:22.739]    + additional globals found: [n=0] 
[17:45:22.739]    + additional namespaces needed: [n=0] 
[17:45:22.740]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:22.740]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:22.740]  - seeds: <none>
[17:45:22.740]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.740] getGlobalsAndPackages() ...
[17:45:22.740] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.740] Resolving globals: FALSE
[17:45:22.740] Tweak future expression to call with '...' arguments ...
[17:45:22.740] {
[17:45:22.740]     do.call(function(...) {
[17:45:22.740]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.740]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.740]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.740]             on.exit(options(oopts), add = TRUE)
[17:45:22.740]         }
[17:45:22.740]         {
[17:45:22.740]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.740]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.740]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.740]             })
[17:45:22.740]         }
[17:45:22.740]     }, args = future.call.arguments)
[17:45:22.740] }
[17:45:22.741] Tweak future expression to call with '...' arguments ... DONE
[17:45:22.741] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.741] - packages: [1] ‘future.apply’
[17:45:22.741] getGlobalsAndPackages() ... DONE
[17:45:22.742] run() for ‘Future’ ...
[17:45:22.742] - state: ‘created’
[17:45:22.742] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:22.756] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.756] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:22.756]   - Field: ‘node’
[17:45:22.756]   - Field: ‘label’
[17:45:22.756]   - Field: ‘local’
[17:45:22.756]   - Field: ‘owner’
[17:45:22.756]   - Field: ‘envir’
[17:45:22.757]   - Field: ‘workers’
[17:45:22.757]   - Field: ‘packages’
[17:45:22.757]   - Field: ‘gc’
[17:45:22.757]   - Field: ‘conditions’
[17:45:22.757]   - Field: ‘persistent’
[17:45:22.757]   - Field: ‘expr’
[17:45:22.757]   - Field: ‘uuid’
[17:45:22.757]   - Field: ‘seed’
[17:45:22.757]   - Field: ‘version’
[17:45:22.757]   - Field: ‘result’
[17:45:22.757]   - Field: ‘asynchronous’
[17:45:22.758]   - Field: ‘calls’
[17:45:22.758]   - Field: ‘globals’
[17:45:22.758]   - Field: ‘stdout’
[17:45:22.758]   - Field: ‘earlySignal’
[17:45:22.758]   - Field: ‘lazy’
[17:45:22.758]   - Field: ‘state’
[17:45:22.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:22.758] - Launch lazy future ...
[17:45:22.758] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:22.759] Packages needed by future strategies (n = 0): <none>
[17:45:22.759] {
[17:45:22.759]     {
[17:45:22.759]         {
[17:45:22.759]             ...future.startTime <- base::Sys.time()
[17:45:22.759]             {
[17:45:22.759]                 {
[17:45:22.759]                   {
[17:45:22.759]                     {
[17:45:22.759]                       {
[17:45:22.759]                         base::local({
[17:45:22.759]                           has_future <- base::requireNamespace("future", 
[17:45:22.759]                             quietly = TRUE)
[17:45:22.759]                           if (has_future) {
[17:45:22.759]                             ns <- base::getNamespace("future")
[17:45:22.759]                             version <- ns[[".package"]][["version"]]
[17:45:22.759]                             if (is.null(version)) 
[17:45:22.759]                               version <- utils::packageVersion("future")
[17:45:22.759]                           }
[17:45:22.759]                           else {
[17:45:22.759]                             version <- NULL
[17:45:22.759]                           }
[17:45:22.759]                           if (!has_future || version < "1.8.0") {
[17:45:22.759]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:22.759]                               "", base::R.version$version.string), 
[17:45:22.759]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:22.759]                                 base::R.version$platform, 8 * 
[17:45:22.759]                                   base::.Machine$sizeof.pointer), 
[17:45:22.759]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:22.759]                                 "release", "version")], collapse = " "), 
[17:45:22.759]                               hostname = base::Sys.info()[["nodename"]])
[17:45:22.759]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:22.759]                               info)
[17:45:22.759]                             info <- base::paste(info, collapse = "; ")
[17:45:22.759]                             if (!has_future) {
[17:45:22.759]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:22.759]                                 info)
[17:45:22.759]                             }
[17:45:22.759]                             else {
[17:45:22.759]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:22.759]                                 info, version)
[17:45:22.759]                             }
[17:45:22.759]                             base::stop(msg)
[17:45:22.759]                           }
[17:45:22.759]                         })
[17:45:22.759]                       }
[17:45:22.759]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:22.759]                       base::options(mc.cores = 1L)
[17:45:22.759]                     }
[17:45:22.759]                     base::local({
[17:45:22.759]                       for (pkg in "future.apply") {
[17:45:22.759]                         base::loadNamespace(pkg)
[17:45:22.759]                         base::library(pkg, character.only = TRUE)
[17:45:22.759]                       }
[17:45:22.759]                     })
[17:45:22.759]                   }
[17:45:22.759]                   ...future.strategy.old <- future::plan("list")
[17:45:22.759]                   options(future.plan = NULL)
[17:45:22.759]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.759]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:22.759]                 }
[17:45:22.759]                 ...future.workdir <- getwd()
[17:45:22.759]             }
[17:45:22.759]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:22.759]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:22.759]         }
[17:45:22.759]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:22.759]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:22.759]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:22.759]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:22.759]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:22.759]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:22.759]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:22.759]             base::names(...future.oldOptions))
[17:45:22.759]     }
[17:45:22.759]     if (FALSE) {
[17:45:22.759]     }
[17:45:22.759]     else {
[17:45:22.759]         if (TRUE) {
[17:45:22.759]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:22.759]                 open = "w")
[17:45:22.759]         }
[17:45:22.759]         else {
[17:45:22.759]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:22.759]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:22.759]         }
[17:45:22.759]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:22.759]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:22.759]             base::sink(type = "output", split = FALSE)
[17:45:22.759]             base::close(...future.stdout)
[17:45:22.759]         }, add = TRUE)
[17:45:22.759]     }
[17:45:22.759]     ...future.frame <- base::sys.nframe()
[17:45:22.759]     ...future.conditions <- base::list()
[17:45:22.759]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:22.759]     if (FALSE) {
[17:45:22.759]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:22.759]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:22.759]     }
[17:45:22.759]     ...future.result <- base::tryCatch({
[17:45:22.759]         base::withCallingHandlers({
[17:45:22.759]             ...future.value <- base::withVisible(base::local({
[17:45:22.759]                 ...future.makeSendCondition <- base::local({
[17:45:22.759]                   sendCondition <- NULL
[17:45:22.759]                   function(frame = 1L) {
[17:45:22.759]                     if (is.function(sendCondition)) 
[17:45:22.759]                       return(sendCondition)
[17:45:22.759]                     ns <- getNamespace("parallel")
[17:45:22.759]                     if (exists("sendData", mode = "function", 
[17:45:22.759]                       envir = ns)) {
[17:45:22.759]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:22.759]                         envir = ns)
[17:45:22.759]                       envir <- sys.frame(frame)
[17:45:22.759]                       master <- NULL
[17:45:22.759]                       while (!identical(envir, .GlobalEnv) && 
[17:45:22.759]                         !identical(envir, emptyenv())) {
[17:45:22.759]                         if (exists("master", mode = "list", envir = envir, 
[17:45:22.759]                           inherits = FALSE)) {
[17:45:22.759]                           master <- get("master", mode = "list", 
[17:45:22.759]                             envir = envir, inherits = FALSE)
[17:45:22.759]                           if (inherits(master, c("SOCKnode", 
[17:45:22.759]                             "SOCK0node"))) {
[17:45:22.759]                             sendCondition <<- function(cond) {
[17:45:22.759]                               data <- list(type = "VALUE", value = cond, 
[17:45:22.759]                                 success = TRUE)
[17:45:22.759]                               parallel_sendData(master, data)
[17:45:22.759]                             }
[17:45:22.759]                             return(sendCondition)
[17:45:22.759]                           }
[17:45:22.759]                         }
[17:45:22.759]                         frame <- frame + 1L
[17:45:22.759]                         envir <- sys.frame(frame)
[17:45:22.759]                       }
[17:45:22.759]                     }
[17:45:22.759]                     sendCondition <<- function(cond) NULL
[17:45:22.759]                   }
[17:45:22.759]                 })
[17:45:22.759]                 withCallingHandlers({
[17:45:22.759]                   {
[17:45:22.759]                     do.call(function(...) {
[17:45:22.759]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.759]                       if (!identical(...future.globals.maxSize.org, 
[17:45:22.759]                         ...future.globals.maxSize)) {
[17:45:22.759]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.759]                         on.exit(options(oopts), add = TRUE)
[17:45:22.759]                       }
[17:45:22.759]                       {
[17:45:22.759]                         lapply(seq_along(...future.elements_ii), 
[17:45:22.759]                           FUN = function(jj) {
[17:45:22.759]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.759]                             ...future.FUN(...future.X_jj, ...)
[17:45:22.759]                           })
[17:45:22.759]                       }
[17:45:22.759]                     }, args = future.call.arguments)
[17:45:22.759]                   }
[17:45:22.759]                 }, immediateCondition = function(cond) {
[17:45:22.759]                   sendCondition <- ...future.makeSendCondition()
[17:45:22.759]                   sendCondition(cond)
[17:45:22.759]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.759]                   {
[17:45:22.759]                     inherits <- base::inherits
[17:45:22.759]                     invokeRestart <- base::invokeRestart
[17:45:22.759]                     is.null <- base::is.null
[17:45:22.759]                     muffled <- FALSE
[17:45:22.759]                     if (inherits(cond, "message")) {
[17:45:22.759]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:22.759]                       if (muffled) 
[17:45:22.759]                         invokeRestart("muffleMessage")
[17:45:22.759]                     }
[17:45:22.759]                     else if (inherits(cond, "warning")) {
[17:45:22.759]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:22.759]                       if (muffled) 
[17:45:22.759]                         invokeRestart("muffleWarning")
[17:45:22.759]                     }
[17:45:22.759]                     else if (inherits(cond, "condition")) {
[17:45:22.759]                       if (!is.null(pattern)) {
[17:45:22.759]                         computeRestarts <- base::computeRestarts
[17:45:22.759]                         grepl <- base::grepl
[17:45:22.759]                         restarts <- computeRestarts(cond)
[17:45:22.759]                         for (restart in restarts) {
[17:45:22.759]                           name <- restart$name
[17:45:22.759]                           if (is.null(name)) 
[17:45:22.759]                             next
[17:45:22.759]                           if (!grepl(pattern, name)) 
[17:45:22.759]                             next
[17:45:22.759]                           invokeRestart(restart)
[17:45:22.759]                           muffled <- TRUE
[17:45:22.759]                           break
[17:45:22.759]                         }
[17:45:22.759]                       }
[17:45:22.759]                     }
[17:45:22.759]                     invisible(muffled)
[17:45:22.759]                   }
[17:45:22.759]                   muffleCondition(cond)
[17:45:22.759]                 })
[17:45:22.759]             }))
[17:45:22.759]             future::FutureResult(value = ...future.value$value, 
[17:45:22.759]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.759]                   ...future.rng), globalenv = if (FALSE) 
[17:45:22.759]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:22.759]                     ...future.globalenv.names))
[17:45:22.759]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:22.759]         }, condition = base::local({
[17:45:22.759]             c <- base::c
[17:45:22.759]             inherits <- base::inherits
[17:45:22.759]             invokeRestart <- base::invokeRestart
[17:45:22.759]             length <- base::length
[17:45:22.759]             list <- base::list
[17:45:22.759]             seq.int <- base::seq.int
[17:45:22.759]             signalCondition <- base::signalCondition
[17:45:22.759]             sys.calls <- base::sys.calls
[17:45:22.759]             `[[` <- base::`[[`
[17:45:22.759]             `+` <- base::`+`
[17:45:22.759]             `<<-` <- base::`<<-`
[17:45:22.759]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:22.759]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:22.759]                   3L)]
[17:45:22.759]             }
[17:45:22.759]             function(cond) {
[17:45:22.759]                 is_error <- inherits(cond, "error")
[17:45:22.759]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:22.759]                   NULL)
[17:45:22.759]                 if (is_error) {
[17:45:22.759]                   sessionInformation <- function() {
[17:45:22.759]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:22.759]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:22.759]                       search = base::search(), system = base::Sys.info())
[17:45:22.759]                   }
[17:45:22.759]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.759]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:22.759]                     cond$call), session = sessionInformation(), 
[17:45:22.759]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:22.759]                   signalCondition(cond)
[17:45:22.759]                 }
[17:45:22.759]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:22.759]                 "immediateCondition"))) {
[17:45:22.759]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:22.759]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.759]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:22.759]                   if (TRUE && !signal) {
[17:45:22.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.759]                     {
[17:45:22.759]                       inherits <- base::inherits
[17:45:22.759]                       invokeRestart <- base::invokeRestart
[17:45:22.759]                       is.null <- base::is.null
[17:45:22.759]                       muffled <- FALSE
[17:45:22.759]                       if (inherits(cond, "message")) {
[17:45:22.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.759]                         if (muffled) 
[17:45:22.759]                           invokeRestart("muffleMessage")
[17:45:22.759]                       }
[17:45:22.759]                       else if (inherits(cond, "warning")) {
[17:45:22.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.759]                         if (muffled) 
[17:45:22.759]                           invokeRestart("muffleWarning")
[17:45:22.759]                       }
[17:45:22.759]                       else if (inherits(cond, "condition")) {
[17:45:22.759]                         if (!is.null(pattern)) {
[17:45:22.759]                           computeRestarts <- base::computeRestarts
[17:45:22.759]                           grepl <- base::grepl
[17:45:22.759]                           restarts <- computeRestarts(cond)
[17:45:22.759]                           for (restart in restarts) {
[17:45:22.759]                             name <- restart$name
[17:45:22.759]                             if (is.null(name)) 
[17:45:22.759]                               next
[17:45:22.759]                             if (!grepl(pattern, name)) 
[17:45:22.759]                               next
[17:45:22.759]                             invokeRestart(restart)
[17:45:22.759]                             muffled <- TRUE
[17:45:22.759]                             break
[17:45:22.759]                           }
[17:45:22.759]                         }
[17:45:22.759]                       }
[17:45:22.759]                       invisible(muffled)
[17:45:22.759]                     }
[17:45:22.759]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.759]                   }
[17:45:22.759]                 }
[17:45:22.759]                 else {
[17:45:22.759]                   if (TRUE) {
[17:45:22.759]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.759]                     {
[17:45:22.759]                       inherits <- base::inherits
[17:45:22.759]                       invokeRestart <- base::invokeRestart
[17:45:22.759]                       is.null <- base::is.null
[17:45:22.759]                       muffled <- FALSE
[17:45:22.759]                       if (inherits(cond, "message")) {
[17:45:22.759]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.759]                         if (muffled) 
[17:45:22.759]                           invokeRestart("muffleMessage")
[17:45:22.759]                       }
[17:45:22.759]                       else if (inherits(cond, "warning")) {
[17:45:22.759]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.759]                         if (muffled) 
[17:45:22.759]                           invokeRestart("muffleWarning")
[17:45:22.759]                       }
[17:45:22.759]                       else if (inherits(cond, "condition")) {
[17:45:22.759]                         if (!is.null(pattern)) {
[17:45:22.759]                           computeRestarts <- base::computeRestarts
[17:45:22.759]                           grepl <- base::grepl
[17:45:22.759]                           restarts <- computeRestarts(cond)
[17:45:22.759]                           for (restart in restarts) {
[17:45:22.759]                             name <- restart$name
[17:45:22.759]                             if (is.null(name)) 
[17:45:22.759]                               next
[17:45:22.759]                             if (!grepl(pattern, name)) 
[17:45:22.759]                               next
[17:45:22.759]                             invokeRestart(restart)
[17:45:22.759]                             muffled <- TRUE
[17:45:22.759]                             break
[17:45:22.759]                           }
[17:45:22.759]                         }
[17:45:22.759]                       }
[17:45:22.759]                       invisible(muffled)
[17:45:22.759]                     }
[17:45:22.759]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.759]                   }
[17:45:22.759]                 }
[17:45:22.759]             }
[17:45:22.759]         }))
[17:45:22.759]     }, error = function(ex) {
[17:45:22.759]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:22.759]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.759]                 ...future.rng), started = ...future.startTime, 
[17:45:22.759]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:22.759]             version = "1.8"), class = "FutureResult")
[17:45:22.759]     }, finally = {
[17:45:22.759]         if (!identical(...future.workdir, getwd())) 
[17:45:22.759]             setwd(...future.workdir)
[17:45:22.759]         {
[17:45:22.759]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:22.759]                 ...future.oldOptions$nwarnings <- NULL
[17:45:22.759]             }
[17:45:22.759]             base::options(...future.oldOptions)
[17:45:22.759]             if (.Platform$OS.type == "windows") {
[17:45:22.759]                 old_names <- names(...future.oldEnvVars)
[17:45:22.759]                 envs <- base::Sys.getenv()
[17:45:22.759]                 names <- names(envs)
[17:45:22.759]                 common <- intersect(names, old_names)
[17:45:22.759]                 added <- setdiff(names, old_names)
[17:45:22.759]                 removed <- setdiff(old_names, names)
[17:45:22.759]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:22.759]                   envs[common]]
[17:45:22.759]                 NAMES <- toupper(changed)
[17:45:22.759]                 args <- list()
[17:45:22.759]                 for (kk in seq_along(NAMES)) {
[17:45:22.759]                   name <- changed[[kk]]
[17:45:22.759]                   NAME <- NAMES[[kk]]
[17:45:22.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.759]                     next
[17:45:22.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.759]                 }
[17:45:22.759]                 NAMES <- toupper(added)
[17:45:22.759]                 for (kk in seq_along(NAMES)) {
[17:45:22.759]                   name <- added[[kk]]
[17:45:22.759]                   NAME <- NAMES[[kk]]
[17:45:22.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.759]                     next
[17:45:22.759]                   args[[name]] <- ""
[17:45:22.759]                 }
[17:45:22.759]                 NAMES <- toupper(removed)
[17:45:22.759]                 for (kk in seq_along(NAMES)) {
[17:45:22.759]                   name <- removed[[kk]]
[17:45:22.759]                   NAME <- NAMES[[kk]]
[17:45:22.759]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.759]                     next
[17:45:22.759]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.759]                 }
[17:45:22.759]                 if (length(args) > 0) 
[17:45:22.759]                   base::do.call(base::Sys.setenv, args = args)
[17:45:22.759]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:22.759]             }
[17:45:22.759]             else {
[17:45:22.759]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:22.759]             }
[17:45:22.759]             {
[17:45:22.759]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:22.759]                   0L) {
[17:45:22.759]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:22.759]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:22.759]                   base::options(opts)
[17:45:22.759]                 }
[17:45:22.759]                 {
[17:45:22.759]                   {
[17:45:22.759]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:22.759]                     NULL
[17:45:22.759]                   }
[17:45:22.759]                   options(future.plan = NULL)
[17:45:22.759]                   if (is.na(NA_character_)) 
[17:45:22.759]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.759]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:22.759]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:22.759]                     .init = FALSE)
[17:45:22.759]                 }
[17:45:22.759]             }
[17:45:22.759]         }
[17:45:22.759]     })
[17:45:22.759]     if (TRUE) {
[17:45:22.759]         base::sink(type = "output", split = FALSE)
[17:45:22.759]         if (TRUE) {
[17:45:22.759]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:22.759]         }
[17:45:22.759]         else {
[17:45:22.759]             ...future.result["stdout"] <- base::list(NULL)
[17:45:22.759]         }
[17:45:22.759]         base::close(...future.stdout)
[17:45:22.759]         ...future.stdout <- NULL
[17:45:22.759]     }
[17:45:22.759]     ...future.result$conditions <- ...future.conditions
[17:45:22.759]     ...future.result$finished <- base::Sys.time()
[17:45:22.759]     ...future.result
[17:45:22.759] }
[17:45:22.762] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[17:45:22.762] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:22.804] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:22.804] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[17:45:22.804] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[17:45:22.804] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:22.805] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:22.805] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:22.848] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:22.848] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:22.892] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:22.892] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:22.892] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.892] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:22.893] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:22.893] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:22.893] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.893] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:22.894] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:22.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:22.894] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.895] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:22.895] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:22.895] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[17:45:22.896] MultisessionFuture started
[17:45:22.896] - Launch lazy future ... done
[17:45:22.896] run() for ‘MultisessionFuture’ ... done
[17:45:22.896] Created future:
[17:45:22.896] MultisessionFuture:
[17:45:22.896] Label: ‘future_vapply-1’
[17:45:22.896] Expression:
[17:45:22.896] {
[17:45:22.896]     do.call(function(...) {
[17:45:22.896]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.896]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.896]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.896]             on.exit(options(oopts), add = TRUE)
[17:45:22.896]         }
[17:45:22.896]         {
[17:45:22.896]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.896]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.896]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.896]             })
[17:45:22.896]         }
[17:45:22.896]     }, args = future.call.arguments)
[17:45:22.896] }
[17:45:22.896] Lazy evaluation: FALSE
[17:45:22.896] Asynchronous evaluation: TRUE
[17:45:22.896] Local evaluation: TRUE
[17:45:22.896] Environment: R_GlobalEnv
[17:45:22.896] Capture standard output: TRUE
[17:45:22.896] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:22.896] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:22.896] Packages: 1 packages (‘future.apply’)
[17:45:22.896] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:22.896] Resolved: FALSE
[17:45:22.896] Value: <not collected>
[17:45:22.896] Conditions captured: <none>
[17:45:22.896] Early signaling: FALSE
[17:45:22.896] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:22.896] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.908] Chunk #1 of 2 ... DONE
[17:45:22.908] Chunk #2 of 2 ...
[17:45:22.908]  - Finding globals in 'X' for chunk #2 ...
[17:45:22.908] getGlobalsAndPackages() ...
[17:45:22.908] Searching for globals...
[17:45:22.908] 
[17:45:22.909] Searching for globals ... DONE
[17:45:22.909] - globals: [0] <none>
[17:45:22.909] getGlobalsAndPackages() ... DONE
[17:45:22.909]    + additional globals found: [n=0] 
[17:45:22.909]    + additional namespaces needed: [n=0] 
[17:45:22.909]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:22.909]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:22.909]  - seeds: <none>
[17:45:22.909]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.909] getGlobalsAndPackages() ...
[17:45:22.909] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.910] Resolving globals: FALSE
[17:45:22.910] Tweak future expression to call with '...' arguments ...
[17:45:22.910] {
[17:45:22.910]     do.call(function(...) {
[17:45:22.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:22.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.910]             on.exit(options(oopts), add = TRUE)
[17:45:22.910]         }
[17:45:22.910]         {
[17:45:22.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:22.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.910]                 ...future.FUN(...future.X_jj, ...)
[17:45:22.910]             })
[17:45:22.910]         }
[17:45:22.910]     }, args = future.call.arguments)
[17:45:22.910] }
[17:45:22.910] Tweak future expression to call with '...' arguments ... DONE
[17:45:22.911] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:22.911] - packages: [1] ‘future.apply’
[17:45:22.911] getGlobalsAndPackages() ... DONE
[17:45:22.911] run() for ‘Future’ ...
[17:45:22.911] - state: ‘created’
[17:45:22.911] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:22.928] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:22.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:22.928]   - Field: ‘node’
[17:45:22.928]   - Field: ‘label’
[17:45:22.928]   - Field: ‘local’
[17:45:22.928]   - Field: ‘owner’
[17:45:22.928]   - Field: ‘envir’
[17:45:22.928]   - Field: ‘workers’
[17:45:22.929]   - Field: ‘packages’
[17:45:22.929]   - Field: ‘gc’
[17:45:22.929]   - Field: ‘conditions’
[17:45:22.929]   - Field: ‘persistent’
[17:45:22.929]   - Field: ‘expr’
[17:45:22.929]   - Field: ‘uuid’
[17:45:22.929]   - Field: ‘seed’
[17:45:22.929]   - Field: ‘version’
[17:45:22.929]   - Field: ‘result’
[17:45:22.929]   - Field: ‘asynchronous’
[17:45:22.929]   - Field: ‘calls’
[17:45:22.929]   - Field: ‘globals’
[17:45:22.930]   - Field: ‘stdout’
[17:45:22.930]   - Field: ‘earlySignal’
[17:45:22.930]   - Field: ‘lazy’
[17:45:22.930]   - Field: ‘state’
[17:45:22.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:22.930] - Launch lazy future ...
[17:45:22.930] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:22.930] Packages needed by future strategies (n = 0): <none>
[17:45:22.931] {
[17:45:22.931]     {
[17:45:22.931]         {
[17:45:22.931]             ...future.startTime <- base::Sys.time()
[17:45:22.931]             {
[17:45:22.931]                 {
[17:45:22.931]                   {
[17:45:22.931]                     {
[17:45:22.931]                       {
[17:45:22.931]                         base::local({
[17:45:22.931]                           has_future <- base::requireNamespace("future", 
[17:45:22.931]                             quietly = TRUE)
[17:45:22.931]                           if (has_future) {
[17:45:22.931]                             ns <- base::getNamespace("future")
[17:45:22.931]                             version <- ns[[".package"]][["version"]]
[17:45:22.931]                             if (is.null(version)) 
[17:45:22.931]                               version <- utils::packageVersion("future")
[17:45:22.931]                           }
[17:45:22.931]                           else {
[17:45:22.931]                             version <- NULL
[17:45:22.931]                           }
[17:45:22.931]                           if (!has_future || version < "1.8.0") {
[17:45:22.931]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:22.931]                               "", base::R.version$version.string), 
[17:45:22.931]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:22.931]                                 base::R.version$platform, 8 * 
[17:45:22.931]                                   base::.Machine$sizeof.pointer), 
[17:45:22.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:22.931]                                 "release", "version")], collapse = " "), 
[17:45:22.931]                               hostname = base::Sys.info()[["nodename"]])
[17:45:22.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:22.931]                               info)
[17:45:22.931]                             info <- base::paste(info, collapse = "; ")
[17:45:22.931]                             if (!has_future) {
[17:45:22.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:22.931]                                 info)
[17:45:22.931]                             }
[17:45:22.931]                             else {
[17:45:22.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:22.931]                                 info, version)
[17:45:22.931]                             }
[17:45:22.931]                             base::stop(msg)
[17:45:22.931]                           }
[17:45:22.931]                         })
[17:45:22.931]                       }
[17:45:22.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:22.931]                       base::options(mc.cores = 1L)
[17:45:22.931]                     }
[17:45:22.931]                     base::local({
[17:45:22.931]                       for (pkg in "future.apply") {
[17:45:22.931]                         base::loadNamespace(pkg)
[17:45:22.931]                         base::library(pkg, character.only = TRUE)
[17:45:22.931]                       }
[17:45:22.931]                     })
[17:45:22.931]                   }
[17:45:22.931]                   ...future.strategy.old <- future::plan("list")
[17:45:22.931]                   options(future.plan = NULL)
[17:45:22.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:22.931]                 }
[17:45:22.931]                 ...future.workdir <- getwd()
[17:45:22.931]             }
[17:45:22.931]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:22.931]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:22.931]         }
[17:45:22.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:22.931]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:22.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:22.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:22.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:22.931]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:22.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:22.931]             base::names(...future.oldOptions))
[17:45:22.931]     }
[17:45:22.931]     if (FALSE) {
[17:45:22.931]     }
[17:45:22.931]     else {
[17:45:22.931]         if (TRUE) {
[17:45:22.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:22.931]                 open = "w")
[17:45:22.931]         }
[17:45:22.931]         else {
[17:45:22.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:22.931]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:22.931]         }
[17:45:22.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:22.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:22.931]             base::sink(type = "output", split = FALSE)
[17:45:22.931]             base::close(...future.stdout)
[17:45:22.931]         }, add = TRUE)
[17:45:22.931]     }
[17:45:22.931]     ...future.frame <- base::sys.nframe()
[17:45:22.931]     ...future.conditions <- base::list()
[17:45:22.931]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:22.931]     if (FALSE) {
[17:45:22.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:22.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:22.931]     }
[17:45:22.931]     ...future.result <- base::tryCatch({
[17:45:22.931]         base::withCallingHandlers({
[17:45:22.931]             ...future.value <- base::withVisible(base::local({
[17:45:22.931]                 ...future.makeSendCondition <- base::local({
[17:45:22.931]                   sendCondition <- NULL
[17:45:22.931]                   function(frame = 1L) {
[17:45:22.931]                     if (is.function(sendCondition)) 
[17:45:22.931]                       return(sendCondition)
[17:45:22.931]                     ns <- getNamespace("parallel")
[17:45:22.931]                     if (exists("sendData", mode = "function", 
[17:45:22.931]                       envir = ns)) {
[17:45:22.931]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:22.931]                         envir = ns)
[17:45:22.931]                       envir <- sys.frame(frame)
[17:45:22.931]                       master <- NULL
[17:45:22.931]                       while (!identical(envir, .GlobalEnv) && 
[17:45:22.931]                         !identical(envir, emptyenv())) {
[17:45:22.931]                         if (exists("master", mode = "list", envir = envir, 
[17:45:22.931]                           inherits = FALSE)) {
[17:45:22.931]                           master <- get("master", mode = "list", 
[17:45:22.931]                             envir = envir, inherits = FALSE)
[17:45:22.931]                           if (inherits(master, c("SOCKnode", 
[17:45:22.931]                             "SOCK0node"))) {
[17:45:22.931]                             sendCondition <<- function(cond) {
[17:45:22.931]                               data <- list(type = "VALUE", value = cond, 
[17:45:22.931]                                 success = TRUE)
[17:45:22.931]                               parallel_sendData(master, data)
[17:45:22.931]                             }
[17:45:22.931]                             return(sendCondition)
[17:45:22.931]                           }
[17:45:22.931]                         }
[17:45:22.931]                         frame <- frame + 1L
[17:45:22.931]                         envir <- sys.frame(frame)
[17:45:22.931]                       }
[17:45:22.931]                     }
[17:45:22.931]                     sendCondition <<- function(cond) NULL
[17:45:22.931]                   }
[17:45:22.931]                 })
[17:45:22.931]                 withCallingHandlers({
[17:45:22.931]                   {
[17:45:22.931]                     do.call(function(...) {
[17:45:22.931]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:22.931]                       if (!identical(...future.globals.maxSize.org, 
[17:45:22.931]                         ...future.globals.maxSize)) {
[17:45:22.931]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:22.931]                         on.exit(options(oopts), add = TRUE)
[17:45:22.931]                       }
[17:45:22.931]                       {
[17:45:22.931]                         lapply(seq_along(...future.elements_ii), 
[17:45:22.931]                           FUN = function(jj) {
[17:45:22.931]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:22.931]                             ...future.FUN(...future.X_jj, ...)
[17:45:22.931]                           })
[17:45:22.931]                       }
[17:45:22.931]                     }, args = future.call.arguments)
[17:45:22.931]                   }
[17:45:22.931]                 }, immediateCondition = function(cond) {
[17:45:22.931]                   sendCondition <- ...future.makeSendCondition()
[17:45:22.931]                   sendCondition(cond)
[17:45:22.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.931]                   {
[17:45:22.931]                     inherits <- base::inherits
[17:45:22.931]                     invokeRestart <- base::invokeRestart
[17:45:22.931]                     is.null <- base::is.null
[17:45:22.931]                     muffled <- FALSE
[17:45:22.931]                     if (inherits(cond, "message")) {
[17:45:22.931]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:22.931]                       if (muffled) 
[17:45:22.931]                         invokeRestart("muffleMessage")
[17:45:22.931]                     }
[17:45:22.931]                     else if (inherits(cond, "warning")) {
[17:45:22.931]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:22.931]                       if (muffled) 
[17:45:22.931]                         invokeRestart("muffleWarning")
[17:45:22.931]                     }
[17:45:22.931]                     else if (inherits(cond, "condition")) {
[17:45:22.931]                       if (!is.null(pattern)) {
[17:45:22.931]                         computeRestarts <- base::computeRestarts
[17:45:22.931]                         grepl <- base::grepl
[17:45:22.931]                         restarts <- computeRestarts(cond)
[17:45:22.931]                         for (restart in restarts) {
[17:45:22.931]                           name <- restart$name
[17:45:22.931]                           if (is.null(name)) 
[17:45:22.931]                             next
[17:45:22.931]                           if (!grepl(pattern, name)) 
[17:45:22.931]                             next
[17:45:22.931]                           invokeRestart(restart)
[17:45:22.931]                           muffled <- TRUE
[17:45:22.931]                           break
[17:45:22.931]                         }
[17:45:22.931]                       }
[17:45:22.931]                     }
[17:45:22.931]                     invisible(muffled)
[17:45:22.931]                   }
[17:45:22.931]                   muffleCondition(cond)
[17:45:22.931]                 })
[17:45:22.931]             }))
[17:45:22.931]             future::FutureResult(value = ...future.value$value, 
[17:45:22.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.931]                   ...future.rng), globalenv = if (FALSE) 
[17:45:22.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:22.931]                     ...future.globalenv.names))
[17:45:22.931]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:22.931]         }, condition = base::local({
[17:45:22.931]             c <- base::c
[17:45:22.931]             inherits <- base::inherits
[17:45:22.931]             invokeRestart <- base::invokeRestart
[17:45:22.931]             length <- base::length
[17:45:22.931]             list <- base::list
[17:45:22.931]             seq.int <- base::seq.int
[17:45:22.931]             signalCondition <- base::signalCondition
[17:45:22.931]             sys.calls <- base::sys.calls
[17:45:22.931]             `[[` <- base::`[[`
[17:45:22.931]             `+` <- base::`+`
[17:45:22.931]             `<<-` <- base::`<<-`
[17:45:22.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:22.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:22.931]                   3L)]
[17:45:22.931]             }
[17:45:22.931]             function(cond) {
[17:45:22.931]                 is_error <- inherits(cond, "error")
[17:45:22.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:22.931]                   NULL)
[17:45:22.931]                 if (is_error) {
[17:45:22.931]                   sessionInformation <- function() {
[17:45:22.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:22.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:22.931]                       search = base::search(), system = base::Sys.info())
[17:45:22.931]                   }
[17:45:22.931]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:22.931]                     cond$call), session = sessionInformation(), 
[17:45:22.931]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:22.931]                   signalCondition(cond)
[17:45:22.931]                 }
[17:45:22.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:22.931]                 "immediateCondition"))) {
[17:45:22.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:22.931]                   ...future.conditions[[length(...future.conditions) + 
[17:45:22.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:22.931]                   if (TRUE && !signal) {
[17:45:22.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.931]                     {
[17:45:22.931]                       inherits <- base::inherits
[17:45:22.931]                       invokeRestart <- base::invokeRestart
[17:45:22.931]                       is.null <- base::is.null
[17:45:22.931]                       muffled <- FALSE
[17:45:22.931]                       if (inherits(cond, "message")) {
[17:45:22.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.931]                         if (muffled) 
[17:45:22.931]                           invokeRestart("muffleMessage")
[17:45:22.931]                       }
[17:45:22.931]                       else if (inherits(cond, "warning")) {
[17:45:22.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.931]                         if (muffled) 
[17:45:22.931]                           invokeRestart("muffleWarning")
[17:45:22.931]                       }
[17:45:22.931]                       else if (inherits(cond, "condition")) {
[17:45:22.931]                         if (!is.null(pattern)) {
[17:45:22.931]                           computeRestarts <- base::computeRestarts
[17:45:22.931]                           grepl <- base::grepl
[17:45:22.931]                           restarts <- computeRestarts(cond)
[17:45:22.931]                           for (restart in restarts) {
[17:45:22.931]                             name <- restart$name
[17:45:22.931]                             if (is.null(name)) 
[17:45:22.931]                               next
[17:45:22.931]                             if (!grepl(pattern, name)) 
[17:45:22.931]                               next
[17:45:22.931]                             invokeRestart(restart)
[17:45:22.931]                             muffled <- TRUE
[17:45:22.931]                             break
[17:45:22.931]                           }
[17:45:22.931]                         }
[17:45:22.931]                       }
[17:45:22.931]                       invisible(muffled)
[17:45:22.931]                     }
[17:45:22.931]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.931]                   }
[17:45:22.931]                 }
[17:45:22.931]                 else {
[17:45:22.931]                   if (TRUE) {
[17:45:22.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:22.931]                     {
[17:45:22.931]                       inherits <- base::inherits
[17:45:22.931]                       invokeRestart <- base::invokeRestart
[17:45:22.931]                       is.null <- base::is.null
[17:45:22.931]                       muffled <- FALSE
[17:45:22.931]                       if (inherits(cond, "message")) {
[17:45:22.931]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:22.931]                         if (muffled) 
[17:45:22.931]                           invokeRestart("muffleMessage")
[17:45:22.931]                       }
[17:45:22.931]                       else if (inherits(cond, "warning")) {
[17:45:22.931]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:22.931]                         if (muffled) 
[17:45:22.931]                           invokeRestart("muffleWarning")
[17:45:22.931]                       }
[17:45:22.931]                       else if (inherits(cond, "condition")) {
[17:45:22.931]                         if (!is.null(pattern)) {
[17:45:22.931]                           computeRestarts <- base::computeRestarts
[17:45:22.931]                           grepl <- base::grepl
[17:45:22.931]                           restarts <- computeRestarts(cond)
[17:45:22.931]                           for (restart in restarts) {
[17:45:22.931]                             name <- restart$name
[17:45:22.931]                             if (is.null(name)) 
[17:45:22.931]                               next
[17:45:22.931]                             if (!grepl(pattern, name)) 
[17:45:22.931]                               next
[17:45:22.931]                             invokeRestart(restart)
[17:45:22.931]                             muffled <- TRUE
[17:45:22.931]                             break
[17:45:22.931]                           }
[17:45:22.931]                         }
[17:45:22.931]                       }
[17:45:22.931]                       invisible(muffled)
[17:45:22.931]                     }
[17:45:22.931]                     muffleCondition(cond, pattern = "^muffle")
[17:45:22.931]                   }
[17:45:22.931]                 }
[17:45:22.931]             }
[17:45:22.931]         }))
[17:45:22.931]     }, error = function(ex) {
[17:45:22.931]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:22.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:22.931]                 ...future.rng), started = ...future.startTime, 
[17:45:22.931]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:22.931]             version = "1.8"), class = "FutureResult")
[17:45:22.931]     }, finally = {
[17:45:22.931]         if (!identical(...future.workdir, getwd())) 
[17:45:22.931]             setwd(...future.workdir)
[17:45:22.931]         {
[17:45:22.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:22.931]                 ...future.oldOptions$nwarnings <- NULL
[17:45:22.931]             }
[17:45:22.931]             base::options(...future.oldOptions)
[17:45:22.931]             if (.Platform$OS.type == "windows") {
[17:45:22.931]                 old_names <- names(...future.oldEnvVars)
[17:45:22.931]                 envs <- base::Sys.getenv()
[17:45:22.931]                 names <- names(envs)
[17:45:22.931]                 common <- intersect(names, old_names)
[17:45:22.931]                 added <- setdiff(names, old_names)
[17:45:22.931]                 removed <- setdiff(old_names, names)
[17:45:22.931]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:22.931]                   envs[common]]
[17:45:22.931]                 NAMES <- toupper(changed)
[17:45:22.931]                 args <- list()
[17:45:22.931]                 for (kk in seq_along(NAMES)) {
[17:45:22.931]                   name <- changed[[kk]]
[17:45:22.931]                   NAME <- NAMES[[kk]]
[17:45:22.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.931]                     next
[17:45:22.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.931]                 }
[17:45:22.931]                 NAMES <- toupper(added)
[17:45:22.931]                 for (kk in seq_along(NAMES)) {
[17:45:22.931]                   name <- added[[kk]]
[17:45:22.931]                   NAME <- NAMES[[kk]]
[17:45:22.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.931]                     next
[17:45:22.931]                   args[[name]] <- ""
[17:45:22.931]                 }
[17:45:22.931]                 NAMES <- toupper(removed)
[17:45:22.931]                 for (kk in seq_along(NAMES)) {
[17:45:22.931]                   name <- removed[[kk]]
[17:45:22.931]                   NAME <- NAMES[[kk]]
[17:45:22.931]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:22.931]                     next
[17:45:22.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:22.931]                 }
[17:45:22.931]                 if (length(args) > 0) 
[17:45:22.931]                   base::do.call(base::Sys.setenv, args = args)
[17:45:22.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:22.931]             }
[17:45:22.931]             else {
[17:45:22.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:22.931]             }
[17:45:22.931]             {
[17:45:22.931]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:22.931]                   0L) {
[17:45:22.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:22.931]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:22.931]                   base::options(opts)
[17:45:22.931]                 }
[17:45:22.931]                 {
[17:45:22.931]                   {
[17:45:22.931]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:22.931]                     NULL
[17:45:22.931]                   }
[17:45:22.931]                   options(future.plan = NULL)
[17:45:22.931]                   if (is.na(NA_character_)) 
[17:45:22.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:22.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:22.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:22.931]                     .init = FALSE)
[17:45:22.931]                 }
[17:45:22.931]             }
[17:45:22.931]         }
[17:45:22.931]     })
[17:45:22.931]     if (TRUE) {
[17:45:22.931]         base::sink(type = "output", split = FALSE)
[17:45:22.931]         if (TRUE) {
[17:45:22.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:22.931]         }
[17:45:22.931]         else {
[17:45:22.931]             ...future.result["stdout"] <- base::list(NULL)
[17:45:22.931]         }
[17:45:22.931]         base::close(...future.stdout)
[17:45:22.931]         ...future.stdout <- NULL
[17:45:22.931]     }
[17:45:22.931]     ...future.result$conditions <- ...future.conditions
[17:45:22.931]     ...future.result$finished <- base::Sys.time()
[17:45:22.931]     ...future.result
[17:45:22.931] }
[17:45:22.934] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[17:45:22.934] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:22.976] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:22.976] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[17:45:22.976] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[17:45:22.976] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:22.977] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:22.977] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:23.020] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:23.020] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:23.064] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:23.064] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:23.065] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:23.065] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:45:23.065] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:45:23.065] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:23.066] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:23.066] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:45:23.066] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:45:23.066] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:23.067] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:23.067] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:23.067] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:23.067] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[17:45:23.068] MultisessionFuture started
[17:45:23.068] - Launch lazy future ... done
[17:45:23.068] run() for ‘MultisessionFuture’ ... done
[17:45:23.068] Created future:
[17:45:23.068] MultisessionFuture:
[17:45:23.068] Label: ‘future_vapply-2’
[17:45:23.068] Expression:
[17:45:23.068] {
[17:45:23.068]     do.call(function(...) {
[17:45:23.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.068]             on.exit(options(oopts), add = TRUE)
[17:45:23.068]         }
[17:45:23.068]         {
[17:45:23.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.068]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.068]             })
[17:45:23.068]         }
[17:45:23.068]     }, args = future.call.arguments)
[17:45:23.068] }
[17:45:23.068] Lazy evaluation: FALSE
[17:45:23.068] Asynchronous evaluation: TRUE
[17:45:23.068] Local evaluation: TRUE
[17:45:23.068] Environment: R_GlobalEnv
[17:45:23.068] Capture standard output: TRUE
[17:45:23.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:23.068] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:23.068] Packages: 1 packages (‘future.apply’)
[17:45:23.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:23.068] Resolved: FALSE
[17:45:23.068] Value: <not collected>
[17:45:23.068] Conditions captured: <none>
[17:45:23.068] Early signaling: FALSE
[17:45:23.068] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:23.068] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.080] Chunk #2 of 2 ... DONE
[17:45:23.080] Launching 2 futures (chunks) ... DONE
[17:45:23.080] Resolving 2 futures (chunks) ...
[17:45:23.080] resolve() on list ...
[17:45:23.080]  recursive: 0
[17:45:23.081]  length: 2
[17:45:23.081] 
[17:45:23.081] receiveMessageFromWorker() for ClusterFuture ...
[17:45:23.081] - Validating connection of MultisessionFuture
[17:45:23.081] - received message: FutureResult
[17:45:23.081] - Received FutureResult
[17:45:23.082] - Erased future from FutureRegistry
[17:45:23.082] result() for ClusterFuture ...
[17:45:23.082] - result already collected: FutureResult
[17:45:23.082] result() for ClusterFuture ... done
[17:45:23.082] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:23.082] Future #1
[17:45:23.082] result() for ClusterFuture ...
[17:45:23.082] - result already collected: FutureResult
[17:45:23.082] result() for ClusterFuture ... done
[17:45:23.082] result() for ClusterFuture ...
[17:45:23.082] - result already collected: FutureResult
[17:45:23.082] result() for ClusterFuture ... done
[17:45:23.083] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:23.083] - nx: 2
[17:45:23.083] - relay: TRUE
[17:45:23.083] - stdout: TRUE
[17:45:23.083] - signal: TRUE
[17:45:23.083] - resignal: FALSE
[17:45:23.083] - force: TRUE
[17:45:23.083] - relayed: [n=2] FALSE, FALSE
[17:45:23.083] - queued futures: [n=2] FALSE, FALSE
[17:45:23.083]  - until=1
[17:45:23.083]  - relaying element #1
[17:45:23.084] result() for ClusterFuture ...
[17:45:23.084] - result already collected: FutureResult
[17:45:23.084] result() for ClusterFuture ... done
[17:45:23.084] result() for ClusterFuture ...
[17:45:23.084] - result already collected: FutureResult
[17:45:23.084] result() for ClusterFuture ... done
[17:45:23.084] result() for ClusterFuture ...
[17:45:23.084] - result already collected: FutureResult
[17:45:23.084] result() for ClusterFuture ... done
[17:45:23.084] result() for ClusterFuture ...
[17:45:23.084] - result already collected: FutureResult
[17:45:23.085] result() for ClusterFuture ... done
[17:45:23.085] - relayed: [n=2] TRUE, FALSE
[17:45:23.085] - queued futures: [n=2] TRUE, FALSE
[17:45:23.085] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:23.085]  length: 1 (resolved future 1)
[17:45:23.113] receiveMessageFromWorker() for ClusterFuture ...
[17:45:23.113] - Validating connection of MultisessionFuture
[17:45:23.113] - received message: FutureResult
[17:45:23.114] - Received FutureResult
[17:45:23.114] - Erased future from FutureRegistry
[17:45:23.114] result() for ClusterFuture ...
[17:45:23.114] - result already collected: FutureResult
[17:45:23.114] result() for ClusterFuture ... done
[17:45:23.114] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:23.114] Future #2
[17:45:23.114] result() for ClusterFuture ...
[17:45:23.114] - result already collected: FutureResult
[17:45:23.114] result() for ClusterFuture ... done
[17:45:23.114] result() for ClusterFuture ...
[17:45:23.115] - result already collected: FutureResult
[17:45:23.115] result() for ClusterFuture ... done
[17:45:23.115] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:23.115] - nx: 2
[17:45:23.115] - relay: TRUE
[17:45:23.115] - stdout: TRUE
[17:45:23.115] - signal: TRUE
[17:45:23.115] - resignal: FALSE
[17:45:23.115] - force: TRUE
[17:45:23.115] - relayed: [n=2] TRUE, FALSE
[17:45:23.115] - queued futures: [n=2] TRUE, FALSE
[17:45:23.116]  - until=2
[17:45:23.116]  - relaying element #2
[17:45:23.116] result() for ClusterFuture ...
[17:45:23.116] - result already collected: FutureResult
[17:45:23.116] result() for ClusterFuture ... done
[17:45:23.116] result() for ClusterFuture ...
[17:45:23.116] - result already collected: FutureResult
[17:45:23.116] result() for ClusterFuture ... done
[17:45:23.116] result() for ClusterFuture ...
[17:45:23.116] - result already collected: FutureResult
[17:45:23.117] result() for ClusterFuture ... done
[17:45:23.117] result() for ClusterFuture ...
[17:45:23.117] - result already collected: FutureResult
[17:45:23.117] result() for ClusterFuture ... done
[17:45:23.117] - relayed: [n=2] TRUE, TRUE
[17:45:23.117] - queued futures: [n=2] TRUE, TRUE
[17:45:23.117] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:23.117]  length: 0 (resolved future 2)
[17:45:23.117] Relaying remaining futures
[17:45:23.117] signalConditionsASAP(NULL, pos=0) ...
[17:45:23.117] - nx: 2
[17:45:23.117] - relay: TRUE
[17:45:23.118] - stdout: TRUE
[17:45:23.118] - signal: TRUE
[17:45:23.118] - resignal: FALSE
[17:45:23.118] - force: TRUE
[17:45:23.118] - relayed: [n=2] TRUE, TRUE
[17:45:23.118] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:23.118] - relayed: [n=2] TRUE, TRUE
[17:45:23.118] - queued futures: [n=2] TRUE, TRUE
[17:45:23.118] signalConditionsASAP(NULL, pos=0) ... done
[17:45:23.118] resolve() on list ... DONE
[17:45:23.118] result() for ClusterFuture ...
[17:45:23.119] - result already collected: FutureResult
[17:45:23.119] result() for ClusterFuture ... done
[17:45:23.119] result() for ClusterFuture ...
[17:45:23.119] - result already collected: FutureResult
[17:45:23.119] result() for ClusterFuture ... done
[17:45:23.119] result() for ClusterFuture ...
[17:45:23.119] - result already collected: FutureResult
[17:45:23.119] result() for ClusterFuture ... done
[17:45:23.119] result() for ClusterFuture ...
[17:45:23.119] - result already collected: FutureResult
[17:45:23.119] result() for ClusterFuture ... done
[17:45:23.120]  - Number of value chunks collected: 2
[17:45:23.120] Resolving 2 futures (chunks) ... DONE
[17:45:23.120] Reducing values from 2 chunks ...
[17:45:23.120]  - Number of values collected after concatenation: 10
[17:45:23.120]  - Number of values expected: 10
[17:45:23.120] Reducing values from 2 chunks ... DONE
[17:45:23.120] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:45:23.121] future_lapply() ...
[17:45:23.126] Number of chunks: 2
[17:45:23.126] getGlobalsAndPackagesXApply() ...
[17:45:23.127]  - future.globals: TRUE
[17:45:23.127] getGlobalsAndPackages() ...
[17:45:23.127] Searching for globals...
[17:45:23.130] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:45:23.130] Searching for globals ... DONE
[17:45:23.130] Resolving globals: FALSE
[17:45:23.131] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[17:45:23.132] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:23.132] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:23.132] - packages: [1] ‘future.apply’
[17:45:23.132] getGlobalsAndPackages() ... DONE
[17:45:23.132]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:23.132]  - needed namespaces: [n=1] ‘future.apply’
[17:45:23.132] Finding globals ... DONE
[17:45:23.132]  - use_args: TRUE
[17:45:23.132]  - Getting '...' globals ...
[17:45:23.133] resolve() on list ...
[17:45:23.133]  recursive: 0
[17:45:23.133]  length: 1
[17:45:23.133]  elements: ‘...’
[17:45:23.133]  length: 0 (resolved future 1)
[17:45:23.133] resolve() on list ... DONE
[17:45:23.133]    - '...' content: [n=0] 
[17:45:23.133] List of 1
[17:45:23.133]  $ ...: list()
[17:45:23.133]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:23.133]  - attr(*, "where")=List of 1
[17:45:23.133]   ..$ ...:<environment: 0x5561f63bc8e8> 
[17:45:23.133]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:23.133]  - attr(*, "resolved")= logi TRUE
[17:45:23.133]  - attr(*, "total_size")= num NA
[17:45:23.136]  - Getting '...' globals ... DONE
[17:45:23.136] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:23.136] List of 8
[17:45:23.136]  $ ...future.FUN:function (x, ...)  
[17:45:23.136]  $ x_FUN        :function (x)  
[17:45:23.136]  $ times        : int 4
[17:45:23.136]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:23.136]  $ stop_if_not  :function (...)  
[17:45:23.136]  $ dim          : int [1:2] 2 2
[17:45:23.136]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:23.136]  $ ...          : list()
[17:45:23.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:23.136]  - attr(*, "where")=List of 8
[17:45:23.136]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:23.136]   ..$ ...          :<environment: 0x5561f63bc8e8> 
[17:45:23.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:23.136]  - attr(*, "resolved")= logi FALSE
[17:45:23.136]  - attr(*, "total_size")= num 97232
[17:45:23.141] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:23.142] getGlobalsAndPackagesXApply() ... DONE
[17:45:23.142] Number of futures (= number of chunks): 2
[17:45:23.142] Launching 2 futures (chunks) ...
[17:45:23.142] Chunk #1 of 2 ...
[17:45:23.142]  - Finding globals in 'X' for chunk #1 ...
[17:45:23.142] getGlobalsAndPackages() ...
[17:45:23.142] Searching for globals...
[17:45:23.142] 
[17:45:23.143] Searching for globals ... DONE
[17:45:23.143] - globals: [0] <none>
[17:45:23.143] getGlobalsAndPackages() ... DONE
[17:45:23.143]    + additional globals found: [n=0] 
[17:45:23.143]    + additional namespaces needed: [n=0] 
[17:45:23.143]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:23.143]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:23.143]  - seeds: <none>
[17:45:23.143]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.143] getGlobalsAndPackages() ...
[17:45:23.143] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.144] Resolving globals: FALSE
[17:45:23.144] Tweak future expression to call with '...' arguments ...
[17:45:23.144] {
[17:45:23.144]     do.call(function(...) {
[17:45:23.144]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.144]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.144]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.144]             on.exit(options(oopts), add = TRUE)
[17:45:23.144]         }
[17:45:23.144]         {
[17:45:23.144]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.144]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.144]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.144]             })
[17:45:23.144]         }
[17:45:23.144]     }, args = future.call.arguments)
[17:45:23.144] }
[17:45:23.144] Tweak future expression to call with '...' arguments ... DONE
[17:45:23.145] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.145] - packages: [1] ‘future.apply’
[17:45:23.145] getGlobalsAndPackages() ... DONE
[17:45:23.145] run() for ‘Future’ ...
[17:45:23.145] - state: ‘created’
[17:45:23.145] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:23.159] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:23.160]   - Field: ‘node’
[17:45:23.160]   - Field: ‘label’
[17:45:23.160]   - Field: ‘local’
[17:45:23.160]   - Field: ‘owner’
[17:45:23.160]   - Field: ‘envir’
[17:45:23.160]   - Field: ‘workers’
[17:45:23.160]   - Field: ‘packages’
[17:45:23.160]   - Field: ‘gc’
[17:45:23.160]   - Field: ‘conditions’
[17:45:23.160]   - Field: ‘persistent’
[17:45:23.160]   - Field: ‘expr’
[17:45:23.161]   - Field: ‘uuid’
[17:45:23.161]   - Field: ‘seed’
[17:45:23.161]   - Field: ‘version’
[17:45:23.161]   - Field: ‘result’
[17:45:23.161]   - Field: ‘asynchronous’
[17:45:23.161]   - Field: ‘calls’
[17:45:23.161]   - Field: ‘globals’
[17:45:23.161]   - Field: ‘stdout’
[17:45:23.161]   - Field: ‘earlySignal’
[17:45:23.161]   - Field: ‘lazy’
[17:45:23.161]   - Field: ‘state’
[17:45:23.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:23.162] - Launch lazy future ...
[17:45:23.162] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:23.162] Packages needed by future strategies (n = 0): <none>
[17:45:23.162] {
[17:45:23.162]     {
[17:45:23.162]         {
[17:45:23.162]             ...future.startTime <- base::Sys.time()
[17:45:23.162]             {
[17:45:23.162]                 {
[17:45:23.162]                   {
[17:45:23.162]                     {
[17:45:23.162]                       {
[17:45:23.162]                         base::local({
[17:45:23.162]                           has_future <- base::requireNamespace("future", 
[17:45:23.162]                             quietly = TRUE)
[17:45:23.162]                           if (has_future) {
[17:45:23.162]                             ns <- base::getNamespace("future")
[17:45:23.162]                             version <- ns[[".package"]][["version"]]
[17:45:23.162]                             if (is.null(version)) 
[17:45:23.162]                               version <- utils::packageVersion("future")
[17:45:23.162]                           }
[17:45:23.162]                           else {
[17:45:23.162]                             version <- NULL
[17:45:23.162]                           }
[17:45:23.162]                           if (!has_future || version < "1.8.0") {
[17:45:23.162]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:23.162]                               "", base::R.version$version.string), 
[17:45:23.162]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:23.162]                                 base::R.version$platform, 8 * 
[17:45:23.162]                                   base::.Machine$sizeof.pointer), 
[17:45:23.162]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:23.162]                                 "release", "version")], collapse = " "), 
[17:45:23.162]                               hostname = base::Sys.info()[["nodename"]])
[17:45:23.162]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:23.162]                               info)
[17:45:23.162]                             info <- base::paste(info, collapse = "; ")
[17:45:23.162]                             if (!has_future) {
[17:45:23.162]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:23.162]                                 info)
[17:45:23.162]                             }
[17:45:23.162]                             else {
[17:45:23.162]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:23.162]                                 info, version)
[17:45:23.162]                             }
[17:45:23.162]                             base::stop(msg)
[17:45:23.162]                           }
[17:45:23.162]                         })
[17:45:23.162]                       }
[17:45:23.162]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:23.162]                       base::options(mc.cores = 1L)
[17:45:23.162]                     }
[17:45:23.162]                     base::local({
[17:45:23.162]                       for (pkg in "future.apply") {
[17:45:23.162]                         base::loadNamespace(pkg)
[17:45:23.162]                         base::library(pkg, character.only = TRUE)
[17:45:23.162]                       }
[17:45:23.162]                     })
[17:45:23.162]                   }
[17:45:23.162]                   ...future.strategy.old <- future::plan("list")
[17:45:23.162]                   options(future.plan = NULL)
[17:45:23.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.162]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:23.162]                 }
[17:45:23.162]                 ...future.workdir <- getwd()
[17:45:23.162]             }
[17:45:23.162]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:23.162]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:23.162]         }
[17:45:23.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:23.162]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:23.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:23.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:23.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:23.162]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:23.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:23.162]             base::names(...future.oldOptions))
[17:45:23.162]     }
[17:45:23.162]     if (FALSE) {
[17:45:23.162]     }
[17:45:23.162]     else {
[17:45:23.162]         if (TRUE) {
[17:45:23.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:23.162]                 open = "w")
[17:45:23.162]         }
[17:45:23.162]         else {
[17:45:23.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:23.162]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:23.162]         }
[17:45:23.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:23.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:23.162]             base::sink(type = "output", split = FALSE)
[17:45:23.162]             base::close(...future.stdout)
[17:45:23.162]         }, add = TRUE)
[17:45:23.162]     }
[17:45:23.162]     ...future.frame <- base::sys.nframe()
[17:45:23.162]     ...future.conditions <- base::list()
[17:45:23.162]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:23.162]     if (FALSE) {
[17:45:23.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:23.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:23.162]     }
[17:45:23.162]     ...future.result <- base::tryCatch({
[17:45:23.162]         base::withCallingHandlers({
[17:45:23.162]             ...future.value <- base::withVisible(base::local({
[17:45:23.162]                 ...future.makeSendCondition <- base::local({
[17:45:23.162]                   sendCondition <- NULL
[17:45:23.162]                   function(frame = 1L) {
[17:45:23.162]                     if (is.function(sendCondition)) 
[17:45:23.162]                       return(sendCondition)
[17:45:23.162]                     ns <- getNamespace("parallel")
[17:45:23.162]                     if (exists("sendData", mode = "function", 
[17:45:23.162]                       envir = ns)) {
[17:45:23.162]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:23.162]                         envir = ns)
[17:45:23.162]                       envir <- sys.frame(frame)
[17:45:23.162]                       master <- NULL
[17:45:23.162]                       while (!identical(envir, .GlobalEnv) && 
[17:45:23.162]                         !identical(envir, emptyenv())) {
[17:45:23.162]                         if (exists("master", mode = "list", envir = envir, 
[17:45:23.162]                           inherits = FALSE)) {
[17:45:23.162]                           master <- get("master", mode = "list", 
[17:45:23.162]                             envir = envir, inherits = FALSE)
[17:45:23.162]                           if (inherits(master, c("SOCKnode", 
[17:45:23.162]                             "SOCK0node"))) {
[17:45:23.162]                             sendCondition <<- function(cond) {
[17:45:23.162]                               data <- list(type = "VALUE", value = cond, 
[17:45:23.162]                                 success = TRUE)
[17:45:23.162]                               parallel_sendData(master, data)
[17:45:23.162]                             }
[17:45:23.162]                             return(sendCondition)
[17:45:23.162]                           }
[17:45:23.162]                         }
[17:45:23.162]                         frame <- frame + 1L
[17:45:23.162]                         envir <- sys.frame(frame)
[17:45:23.162]                       }
[17:45:23.162]                     }
[17:45:23.162]                     sendCondition <<- function(cond) NULL
[17:45:23.162]                   }
[17:45:23.162]                 })
[17:45:23.162]                 withCallingHandlers({
[17:45:23.162]                   {
[17:45:23.162]                     do.call(function(...) {
[17:45:23.162]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.162]                       if (!identical(...future.globals.maxSize.org, 
[17:45:23.162]                         ...future.globals.maxSize)) {
[17:45:23.162]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.162]                         on.exit(options(oopts), add = TRUE)
[17:45:23.162]                       }
[17:45:23.162]                       {
[17:45:23.162]                         lapply(seq_along(...future.elements_ii), 
[17:45:23.162]                           FUN = function(jj) {
[17:45:23.162]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.162]                             ...future.FUN(...future.X_jj, ...)
[17:45:23.162]                           })
[17:45:23.162]                       }
[17:45:23.162]                     }, args = future.call.arguments)
[17:45:23.162]                   }
[17:45:23.162]                 }, immediateCondition = function(cond) {
[17:45:23.162]                   sendCondition <- ...future.makeSendCondition()
[17:45:23.162]                   sendCondition(cond)
[17:45:23.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.162]                   {
[17:45:23.162]                     inherits <- base::inherits
[17:45:23.162]                     invokeRestart <- base::invokeRestart
[17:45:23.162]                     is.null <- base::is.null
[17:45:23.162]                     muffled <- FALSE
[17:45:23.162]                     if (inherits(cond, "message")) {
[17:45:23.162]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:23.162]                       if (muffled) 
[17:45:23.162]                         invokeRestart("muffleMessage")
[17:45:23.162]                     }
[17:45:23.162]                     else if (inherits(cond, "warning")) {
[17:45:23.162]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:23.162]                       if (muffled) 
[17:45:23.162]                         invokeRestart("muffleWarning")
[17:45:23.162]                     }
[17:45:23.162]                     else if (inherits(cond, "condition")) {
[17:45:23.162]                       if (!is.null(pattern)) {
[17:45:23.162]                         computeRestarts <- base::computeRestarts
[17:45:23.162]                         grepl <- base::grepl
[17:45:23.162]                         restarts <- computeRestarts(cond)
[17:45:23.162]                         for (restart in restarts) {
[17:45:23.162]                           name <- restart$name
[17:45:23.162]                           if (is.null(name)) 
[17:45:23.162]                             next
[17:45:23.162]                           if (!grepl(pattern, name)) 
[17:45:23.162]                             next
[17:45:23.162]                           invokeRestart(restart)
[17:45:23.162]                           muffled <- TRUE
[17:45:23.162]                           break
[17:45:23.162]                         }
[17:45:23.162]                       }
[17:45:23.162]                     }
[17:45:23.162]                     invisible(muffled)
[17:45:23.162]                   }
[17:45:23.162]                   muffleCondition(cond)
[17:45:23.162]                 })
[17:45:23.162]             }))
[17:45:23.162]             future::FutureResult(value = ...future.value$value, 
[17:45:23.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.162]                   ...future.rng), globalenv = if (FALSE) 
[17:45:23.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:23.162]                     ...future.globalenv.names))
[17:45:23.162]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:23.162]         }, condition = base::local({
[17:45:23.162]             c <- base::c
[17:45:23.162]             inherits <- base::inherits
[17:45:23.162]             invokeRestart <- base::invokeRestart
[17:45:23.162]             length <- base::length
[17:45:23.162]             list <- base::list
[17:45:23.162]             seq.int <- base::seq.int
[17:45:23.162]             signalCondition <- base::signalCondition
[17:45:23.162]             sys.calls <- base::sys.calls
[17:45:23.162]             `[[` <- base::`[[`
[17:45:23.162]             `+` <- base::`+`
[17:45:23.162]             `<<-` <- base::`<<-`
[17:45:23.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:23.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:23.162]                   3L)]
[17:45:23.162]             }
[17:45:23.162]             function(cond) {
[17:45:23.162]                 is_error <- inherits(cond, "error")
[17:45:23.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:23.162]                   NULL)
[17:45:23.162]                 if (is_error) {
[17:45:23.162]                   sessionInformation <- function() {
[17:45:23.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:23.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:23.162]                       search = base::search(), system = base::Sys.info())
[17:45:23.162]                   }
[17:45:23.162]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:23.162]                     cond$call), session = sessionInformation(), 
[17:45:23.162]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:23.162]                   signalCondition(cond)
[17:45:23.162]                 }
[17:45:23.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:23.162]                 "immediateCondition"))) {
[17:45:23.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:23.162]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:23.162]                   if (TRUE && !signal) {
[17:45:23.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.162]                     {
[17:45:23.162]                       inherits <- base::inherits
[17:45:23.162]                       invokeRestart <- base::invokeRestart
[17:45:23.162]                       is.null <- base::is.null
[17:45:23.162]                       muffled <- FALSE
[17:45:23.162]                       if (inherits(cond, "message")) {
[17:45:23.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.162]                         if (muffled) 
[17:45:23.162]                           invokeRestart("muffleMessage")
[17:45:23.162]                       }
[17:45:23.162]                       else if (inherits(cond, "warning")) {
[17:45:23.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.162]                         if (muffled) 
[17:45:23.162]                           invokeRestart("muffleWarning")
[17:45:23.162]                       }
[17:45:23.162]                       else if (inherits(cond, "condition")) {
[17:45:23.162]                         if (!is.null(pattern)) {
[17:45:23.162]                           computeRestarts <- base::computeRestarts
[17:45:23.162]                           grepl <- base::grepl
[17:45:23.162]                           restarts <- computeRestarts(cond)
[17:45:23.162]                           for (restart in restarts) {
[17:45:23.162]                             name <- restart$name
[17:45:23.162]                             if (is.null(name)) 
[17:45:23.162]                               next
[17:45:23.162]                             if (!grepl(pattern, name)) 
[17:45:23.162]                               next
[17:45:23.162]                             invokeRestart(restart)
[17:45:23.162]                             muffled <- TRUE
[17:45:23.162]                             break
[17:45:23.162]                           }
[17:45:23.162]                         }
[17:45:23.162]                       }
[17:45:23.162]                       invisible(muffled)
[17:45:23.162]                     }
[17:45:23.162]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.162]                   }
[17:45:23.162]                 }
[17:45:23.162]                 else {
[17:45:23.162]                   if (TRUE) {
[17:45:23.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.162]                     {
[17:45:23.162]                       inherits <- base::inherits
[17:45:23.162]                       invokeRestart <- base::invokeRestart
[17:45:23.162]                       is.null <- base::is.null
[17:45:23.162]                       muffled <- FALSE
[17:45:23.162]                       if (inherits(cond, "message")) {
[17:45:23.162]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.162]                         if (muffled) 
[17:45:23.162]                           invokeRestart("muffleMessage")
[17:45:23.162]                       }
[17:45:23.162]                       else if (inherits(cond, "warning")) {
[17:45:23.162]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.162]                         if (muffled) 
[17:45:23.162]                           invokeRestart("muffleWarning")
[17:45:23.162]                       }
[17:45:23.162]                       else if (inherits(cond, "condition")) {
[17:45:23.162]                         if (!is.null(pattern)) {
[17:45:23.162]                           computeRestarts <- base::computeRestarts
[17:45:23.162]                           grepl <- base::grepl
[17:45:23.162]                           restarts <- computeRestarts(cond)
[17:45:23.162]                           for (restart in restarts) {
[17:45:23.162]                             name <- restart$name
[17:45:23.162]                             if (is.null(name)) 
[17:45:23.162]                               next
[17:45:23.162]                             if (!grepl(pattern, name)) 
[17:45:23.162]                               next
[17:45:23.162]                             invokeRestart(restart)
[17:45:23.162]                             muffled <- TRUE
[17:45:23.162]                             break
[17:45:23.162]                           }
[17:45:23.162]                         }
[17:45:23.162]                       }
[17:45:23.162]                       invisible(muffled)
[17:45:23.162]                     }
[17:45:23.162]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.162]                   }
[17:45:23.162]                 }
[17:45:23.162]             }
[17:45:23.162]         }))
[17:45:23.162]     }, error = function(ex) {
[17:45:23.162]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:23.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.162]                 ...future.rng), started = ...future.startTime, 
[17:45:23.162]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:23.162]             version = "1.8"), class = "FutureResult")
[17:45:23.162]     }, finally = {
[17:45:23.162]         if (!identical(...future.workdir, getwd())) 
[17:45:23.162]             setwd(...future.workdir)
[17:45:23.162]         {
[17:45:23.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:23.162]                 ...future.oldOptions$nwarnings <- NULL
[17:45:23.162]             }
[17:45:23.162]             base::options(...future.oldOptions)
[17:45:23.162]             if (.Platform$OS.type == "windows") {
[17:45:23.162]                 old_names <- names(...future.oldEnvVars)
[17:45:23.162]                 envs <- base::Sys.getenv()
[17:45:23.162]                 names <- names(envs)
[17:45:23.162]                 common <- intersect(names, old_names)
[17:45:23.162]                 added <- setdiff(names, old_names)
[17:45:23.162]                 removed <- setdiff(old_names, names)
[17:45:23.162]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:23.162]                   envs[common]]
[17:45:23.162]                 NAMES <- toupper(changed)
[17:45:23.162]                 args <- list()
[17:45:23.162]                 for (kk in seq_along(NAMES)) {
[17:45:23.162]                   name <- changed[[kk]]
[17:45:23.162]                   NAME <- NAMES[[kk]]
[17:45:23.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.162]                     next
[17:45:23.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.162]                 }
[17:45:23.162]                 NAMES <- toupper(added)
[17:45:23.162]                 for (kk in seq_along(NAMES)) {
[17:45:23.162]                   name <- added[[kk]]
[17:45:23.162]                   NAME <- NAMES[[kk]]
[17:45:23.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.162]                     next
[17:45:23.162]                   args[[name]] <- ""
[17:45:23.162]                 }
[17:45:23.162]                 NAMES <- toupper(removed)
[17:45:23.162]                 for (kk in seq_along(NAMES)) {
[17:45:23.162]                   name <- removed[[kk]]
[17:45:23.162]                   NAME <- NAMES[[kk]]
[17:45:23.162]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.162]                     next
[17:45:23.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.162]                 }
[17:45:23.162]                 if (length(args) > 0) 
[17:45:23.162]                   base::do.call(base::Sys.setenv, args = args)
[17:45:23.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:23.162]             }
[17:45:23.162]             else {
[17:45:23.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:23.162]             }
[17:45:23.162]             {
[17:45:23.162]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:23.162]                   0L) {
[17:45:23.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:23.162]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:23.162]                   base::options(opts)
[17:45:23.162]                 }
[17:45:23.162]                 {
[17:45:23.162]                   {
[17:45:23.162]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:23.162]                     NULL
[17:45:23.162]                   }
[17:45:23.162]                   options(future.plan = NULL)
[17:45:23.162]                   if (is.na(NA_character_)) 
[17:45:23.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:23.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:23.162]                     .init = FALSE)
[17:45:23.162]                 }
[17:45:23.162]             }
[17:45:23.162]         }
[17:45:23.162]     })
[17:45:23.162]     if (TRUE) {
[17:45:23.162]         base::sink(type = "output", split = FALSE)
[17:45:23.162]         if (TRUE) {
[17:45:23.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:23.162]         }
[17:45:23.162]         else {
[17:45:23.162]             ...future.result["stdout"] <- base::list(NULL)
[17:45:23.162]         }
[17:45:23.162]         base::close(...future.stdout)
[17:45:23.162]         ...future.stdout <- NULL
[17:45:23.162]     }
[17:45:23.162]     ...future.result$conditions <- ...future.conditions
[17:45:23.162]     ...future.result$finished <- base::Sys.time()
[17:45:23.162]     ...future.result
[17:45:23.162] }
[17:45:23.165] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[17:45:23.165] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:23.208] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:23.208] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:45:23.208] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:45:23.208] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:23.209] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.209] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:23.252] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:23.252] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:23.296] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:23.296] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:45:23.296] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.296] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:45:23.297] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:45:23.297] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:23.298] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.298] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:23.298] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:23.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:23.298] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.299] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:23.299] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.299] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[17:45:23.300] MultisessionFuture started
[17:45:23.300] - Launch lazy future ... done
[17:45:23.300] run() for ‘MultisessionFuture’ ... done
[17:45:23.300] Created future:
[17:45:23.301] receiveMessageFromWorker() for ClusterFuture ...
[17:45:23.302] - Validating connection of MultisessionFuture
[17:45:23.302] - received message: FutureResult
[17:45:23.302] - Received FutureResult
[17:45:23.302] - Erased future from FutureRegistry
[17:45:23.302] result() for ClusterFuture ...
[17:45:23.302] - result already collected: FutureResult
[17:45:23.302] result() for ClusterFuture ... done
[17:45:23.302] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:23.300] MultisessionFuture:
[17:45:23.300] Label: ‘future_vapply-1’
[17:45:23.300] Expression:
[17:45:23.300] {
[17:45:23.300]     do.call(function(...) {
[17:45:23.300]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.300]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.300]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.300]             on.exit(options(oopts), add = TRUE)
[17:45:23.300]         }
[17:45:23.300]         {
[17:45:23.300]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.300]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.300]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.300]             })
[17:45:23.300]         }
[17:45:23.300]     }, args = future.call.arguments)
[17:45:23.300] }
[17:45:23.300] Lazy evaluation: FALSE
[17:45:23.300] Asynchronous evaluation: TRUE
[17:45:23.300] Local evaluation: TRUE
[17:45:23.300] Environment: R_GlobalEnv
[17:45:23.300] Capture standard output: TRUE
[17:45:23.300] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:23.300] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:23.300] Packages: 1 packages (‘future.apply’)
[17:45:23.300] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:23.300] Resolved: TRUE
[17:45:23.300] Value: <not collected>
[17:45:23.300] Conditions captured: <none>
[17:45:23.300] Early signaling: FALSE
[17:45:23.300] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:23.300] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.303] Chunk #1 of 2 ... DONE
[17:45:23.303] Chunk #2 of 2 ...
[17:45:23.303]  - Finding globals in 'X' for chunk #2 ...
[17:45:23.303] getGlobalsAndPackages() ...
[17:45:23.303] Searching for globals...
[17:45:23.303] 
[17:45:23.303] Searching for globals ... DONE
[17:45:23.304] - globals: [0] <none>
[17:45:23.304] getGlobalsAndPackages() ... DONE
[17:45:23.304]    + additional globals found: [n=0] 
[17:45:23.304]    + additional namespaces needed: [n=0] 
[17:45:23.304]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:23.304]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:23.304]  - seeds: <none>
[17:45:23.304]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.304] getGlobalsAndPackages() ...
[17:45:23.304] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.304] Resolving globals: FALSE
[17:45:23.305] Tweak future expression to call with '...' arguments ...
[17:45:23.305] {
[17:45:23.305]     do.call(function(...) {
[17:45:23.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.305]             on.exit(options(oopts), add = TRUE)
[17:45:23.305]         }
[17:45:23.305]         {
[17:45:23.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.305]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.305]             })
[17:45:23.305]         }
[17:45:23.305]     }, args = future.call.arguments)
[17:45:23.305] }
[17:45:23.305] Tweak future expression to call with '...' arguments ... DONE
[17:45:23.305] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.306] - packages: [1] ‘future.apply’
[17:45:23.306] getGlobalsAndPackages() ... DONE
[17:45:23.306] run() for ‘Future’ ...
[17:45:23.306] - state: ‘created’
[17:45:23.306] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:23.320] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:23.321]   - Field: ‘node’
[17:45:23.321]   - Field: ‘label’
[17:45:23.321]   - Field: ‘local’
[17:45:23.321]   - Field: ‘owner’
[17:45:23.321]   - Field: ‘envir’
[17:45:23.321]   - Field: ‘workers’
[17:45:23.321]   - Field: ‘packages’
[17:45:23.321]   - Field: ‘gc’
[17:45:23.321]   - Field: ‘conditions’
[17:45:23.322]   - Field: ‘persistent’
[17:45:23.322]   - Field: ‘expr’
[17:45:23.322]   - Field: ‘uuid’
[17:45:23.322]   - Field: ‘seed’
[17:45:23.322]   - Field: ‘version’
[17:45:23.322]   - Field: ‘result’
[17:45:23.322]   - Field: ‘asynchronous’
[17:45:23.322]   - Field: ‘calls’
[17:45:23.322]   - Field: ‘globals’
[17:45:23.322]   - Field: ‘stdout’
[17:45:23.322]   - Field: ‘earlySignal’
[17:45:23.322]   - Field: ‘lazy’
[17:45:23.323]   - Field: ‘state’
[17:45:23.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:23.323] - Launch lazy future ...
[17:45:23.323] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:23.323] Packages needed by future strategies (n = 0): <none>
[17:45:23.324] {
[17:45:23.324]     {
[17:45:23.324]         {
[17:45:23.324]             ...future.startTime <- base::Sys.time()
[17:45:23.324]             {
[17:45:23.324]                 {
[17:45:23.324]                   {
[17:45:23.324]                     {
[17:45:23.324]                       {
[17:45:23.324]                         base::local({
[17:45:23.324]                           has_future <- base::requireNamespace("future", 
[17:45:23.324]                             quietly = TRUE)
[17:45:23.324]                           if (has_future) {
[17:45:23.324]                             ns <- base::getNamespace("future")
[17:45:23.324]                             version <- ns[[".package"]][["version"]]
[17:45:23.324]                             if (is.null(version)) 
[17:45:23.324]                               version <- utils::packageVersion("future")
[17:45:23.324]                           }
[17:45:23.324]                           else {
[17:45:23.324]                             version <- NULL
[17:45:23.324]                           }
[17:45:23.324]                           if (!has_future || version < "1.8.0") {
[17:45:23.324]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:23.324]                               "", base::R.version$version.string), 
[17:45:23.324]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:23.324]                                 base::R.version$platform, 8 * 
[17:45:23.324]                                   base::.Machine$sizeof.pointer), 
[17:45:23.324]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:23.324]                                 "release", "version")], collapse = " "), 
[17:45:23.324]                               hostname = base::Sys.info()[["nodename"]])
[17:45:23.324]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:23.324]                               info)
[17:45:23.324]                             info <- base::paste(info, collapse = "; ")
[17:45:23.324]                             if (!has_future) {
[17:45:23.324]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:23.324]                                 info)
[17:45:23.324]                             }
[17:45:23.324]                             else {
[17:45:23.324]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:23.324]                                 info, version)
[17:45:23.324]                             }
[17:45:23.324]                             base::stop(msg)
[17:45:23.324]                           }
[17:45:23.324]                         })
[17:45:23.324]                       }
[17:45:23.324]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:23.324]                       base::options(mc.cores = 1L)
[17:45:23.324]                     }
[17:45:23.324]                     base::local({
[17:45:23.324]                       for (pkg in "future.apply") {
[17:45:23.324]                         base::loadNamespace(pkg)
[17:45:23.324]                         base::library(pkg, character.only = TRUE)
[17:45:23.324]                       }
[17:45:23.324]                     })
[17:45:23.324]                   }
[17:45:23.324]                   ...future.strategy.old <- future::plan("list")
[17:45:23.324]                   options(future.plan = NULL)
[17:45:23.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:23.324]                 }
[17:45:23.324]                 ...future.workdir <- getwd()
[17:45:23.324]             }
[17:45:23.324]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:23.324]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:23.324]         }
[17:45:23.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:23.324]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:23.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:23.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:23.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:23.324]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:23.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:23.324]             base::names(...future.oldOptions))
[17:45:23.324]     }
[17:45:23.324]     if (FALSE) {
[17:45:23.324]     }
[17:45:23.324]     else {
[17:45:23.324]         if (TRUE) {
[17:45:23.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:23.324]                 open = "w")
[17:45:23.324]         }
[17:45:23.324]         else {
[17:45:23.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:23.324]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:23.324]         }
[17:45:23.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:23.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:23.324]             base::sink(type = "output", split = FALSE)
[17:45:23.324]             base::close(...future.stdout)
[17:45:23.324]         }, add = TRUE)
[17:45:23.324]     }
[17:45:23.324]     ...future.frame <- base::sys.nframe()
[17:45:23.324]     ...future.conditions <- base::list()
[17:45:23.324]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:23.324]     if (FALSE) {
[17:45:23.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:23.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:23.324]     }
[17:45:23.324]     ...future.result <- base::tryCatch({
[17:45:23.324]         base::withCallingHandlers({
[17:45:23.324]             ...future.value <- base::withVisible(base::local({
[17:45:23.324]                 ...future.makeSendCondition <- base::local({
[17:45:23.324]                   sendCondition <- NULL
[17:45:23.324]                   function(frame = 1L) {
[17:45:23.324]                     if (is.function(sendCondition)) 
[17:45:23.324]                       return(sendCondition)
[17:45:23.324]                     ns <- getNamespace("parallel")
[17:45:23.324]                     if (exists("sendData", mode = "function", 
[17:45:23.324]                       envir = ns)) {
[17:45:23.324]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:23.324]                         envir = ns)
[17:45:23.324]                       envir <- sys.frame(frame)
[17:45:23.324]                       master <- NULL
[17:45:23.324]                       while (!identical(envir, .GlobalEnv) && 
[17:45:23.324]                         !identical(envir, emptyenv())) {
[17:45:23.324]                         if (exists("master", mode = "list", envir = envir, 
[17:45:23.324]                           inherits = FALSE)) {
[17:45:23.324]                           master <- get("master", mode = "list", 
[17:45:23.324]                             envir = envir, inherits = FALSE)
[17:45:23.324]                           if (inherits(master, c("SOCKnode", 
[17:45:23.324]                             "SOCK0node"))) {
[17:45:23.324]                             sendCondition <<- function(cond) {
[17:45:23.324]                               data <- list(type = "VALUE", value = cond, 
[17:45:23.324]                                 success = TRUE)
[17:45:23.324]                               parallel_sendData(master, data)
[17:45:23.324]                             }
[17:45:23.324]                             return(sendCondition)
[17:45:23.324]                           }
[17:45:23.324]                         }
[17:45:23.324]                         frame <- frame + 1L
[17:45:23.324]                         envir <- sys.frame(frame)
[17:45:23.324]                       }
[17:45:23.324]                     }
[17:45:23.324]                     sendCondition <<- function(cond) NULL
[17:45:23.324]                   }
[17:45:23.324]                 })
[17:45:23.324]                 withCallingHandlers({
[17:45:23.324]                   {
[17:45:23.324]                     do.call(function(...) {
[17:45:23.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.324]                       if (!identical(...future.globals.maxSize.org, 
[17:45:23.324]                         ...future.globals.maxSize)) {
[17:45:23.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.324]                         on.exit(options(oopts), add = TRUE)
[17:45:23.324]                       }
[17:45:23.324]                       {
[17:45:23.324]                         lapply(seq_along(...future.elements_ii), 
[17:45:23.324]                           FUN = function(jj) {
[17:45:23.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.324]                             ...future.FUN(...future.X_jj, ...)
[17:45:23.324]                           })
[17:45:23.324]                       }
[17:45:23.324]                     }, args = future.call.arguments)
[17:45:23.324]                   }
[17:45:23.324]                 }, immediateCondition = function(cond) {
[17:45:23.324]                   sendCondition <- ...future.makeSendCondition()
[17:45:23.324]                   sendCondition(cond)
[17:45:23.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.324]                   {
[17:45:23.324]                     inherits <- base::inherits
[17:45:23.324]                     invokeRestart <- base::invokeRestart
[17:45:23.324]                     is.null <- base::is.null
[17:45:23.324]                     muffled <- FALSE
[17:45:23.324]                     if (inherits(cond, "message")) {
[17:45:23.324]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:23.324]                       if (muffled) 
[17:45:23.324]                         invokeRestart("muffleMessage")
[17:45:23.324]                     }
[17:45:23.324]                     else if (inherits(cond, "warning")) {
[17:45:23.324]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:23.324]                       if (muffled) 
[17:45:23.324]                         invokeRestart("muffleWarning")
[17:45:23.324]                     }
[17:45:23.324]                     else if (inherits(cond, "condition")) {
[17:45:23.324]                       if (!is.null(pattern)) {
[17:45:23.324]                         computeRestarts <- base::computeRestarts
[17:45:23.324]                         grepl <- base::grepl
[17:45:23.324]                         restarts <- computeRestarts(cond)
[17:45:23.324]                         for (restart in restarts) {
[17:45:23.324]                           name <- restart$name
[17:45:23.324]                           if (is.null(name)) 
[17:45:23.324]                             next
[17:45:23.324]                           if (!grepl(pattern, name)) 
[17:45:23.324]                             next
[17:45:23.324]                           invokeRestart(restart)
[17:45:23.324]                           muffled <- TRUE
[17:45:23.324]                           break
[17:45:23.324]                         }
[17:45:23.324]                       }
[17:45:23.324]                     }
[17:45:23.324]                     invisible(muffled)
[17:45:23.324]                   }
[17:45:23.324]                   muffleCondition(cond)
[17:45:23.324]                 })
[17:45:23.324]             }))
[17:45:23.324]             future::FutureResult(value = ...future.value$value, 
[17:45:23.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.324]                   ...future.rng), globalenv = if (FALSE) 
[17:45:23.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:23.324]                     ...future.globalenv.names))
[17:45:23.324]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:23.324]         }, condition = base::local({
[17:45:23.324]             c <- base::c
[17:45:23.324]             inherits <- base::inherits
[17:45:23.324]             invokeRestart <- base::invokeRestart
[17:45:23.324]             length <- base::length
[17:45:23.324]             list <- base::list
[17:45:23.324]             seq.int <- base::seq.int
[17:45:23.324]             signalCondition <- base::signalCondition
[17:45:23.324]             sys.calls <- base::sys.calls
[17:45:23.324]             `[[` <- base::`[[`
[17:45:23.324]             `+` <- base::`+`
[17:45:23.324]             `<<-` <- base::`<<-`
[17:45:23.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:23.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:23.324]                   3L)]
[17:45:23.324]             }
[17:45:23.324]             function(cond) {
[17:45:23.324]                 is_error <- inherits(cond, "error")
[17:45:23.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:23.324]                   NULL)
[17:45:23.324]                 if (is_error) {
[17:45:23.324]                   sessionInformation <- function() {
[17:45:23.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:23.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:23.324]                       search = base::search(), system = base::Sys.info())
[17:45:23.324]                   }
[17:45:23.324]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:23.324]                     cond$call), session = sessionInformation(), 
[17:45:23.324]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:23.324]                   signalCondition(cond)
[17:45:23.324]                 }
[17:45:23.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:23.324]                 "immediateCondition"))) {
[17:45:23.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:23.324]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:23.324]                   if (TRUE && !signal) {
[17:45:23.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.324]                     {
[17:45:23.324]                       inherits <- base::inherits
[17:45:23.324]                       invokeRestart <- base::invokeRestart
[17:45:23.324]                       is.null <- base::is.null
[17:45:23.324]                       muffled <- FALSE
[17:45:23.324]                       if (inherits(cond, "message")) {
[17:45:23.324]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.324]                         if (muffled) 
[17:45:23.324]                           invokeRestart("muffleMessage")
[17:45:23.324]                       }
[17:45:23.324]                       else if (inherits(cond, "warning")) {
[17:45:23.324]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.324]                         if (muffled) 
[17:45:23.324]                           invokeRestart("muffleWarning")
[17:45:23.324]                       }
[17:45:23.324]                       else if (inherits(cond, "condition")) {
[17:45:23.324]                         if (!is.null(pattern)) {
[17:45:23.324]                           computeRestarts <- base::computeRestarts
[17:45:23.324]                           grepl <- base::grepl
[17:45:23.324]                           restarts <- computeRestarts(cond)
[17:45:23.324]                           for (restart in restarts) {
[17:45:23.324]                             name <- restart$name
[17:45:23.324]                             if (is.null(name)) 
[17:45:23.324]                               next
[17:45:23.324]                             if (!grepl(pattern, name)) 
[17:45:23.324]                               next
[17:45:23.324]                             invokeRestart(restart)
[17:45:23.324]                             muffled <- TRUE
[17:45:23.324]                             break
[17:45:23.324]                           }
[17:45:23.324]                         }
[17:45:23.324]                       }
[17:45:23.324]                       invisible(muffled)
[17:45:23.324]                     }
[17:45:23.324]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.324]                   }
[17:45:23.324]                 }
[17:45:23.324]                 else {
[17:45:23.324]                   if (TRUE) {
[17:45:23.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.324]                     {
[17:45:23.324]                       inherits <- base::inherits
[17:45:23.324]                       invokeRestart <- base::invokeRestart
[17:45:23.324]                       is.null <- base::is.null
[17:45:23.324]                       muffled <- FALSE
[17:45:23.324]                       if (inherits(cond, "message")) {
[17:45:23.324]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.324]                         if (muffled) 
[17:45:23.324]                           invokeRestart("muffleMessage")
[17:45:23.324]                       }
[17:45:23.324]                       else if (inherits(cond, "warning")) {
[17:45:23.324]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.324]                         if (muffled) 
[17:45:23.324]                           invokeRestart("muffleWarning")
[17:45:23.324]                       }
[17:45:23.324]                       else if (inherits(cond, "condition")) {
[17:45:23.324]                         if (!is.null(pattern)) {
[17:45:23.324]                           computeRestarts <- base::computeRestarts
[17:45:23.324]                           grepl <- base::grepl
[17:45:23.324]                           restarts <- computeRestarts(cond)
[17:45:23.324]                           for (restart in restarts) {
[17:45:23.324]                             name <- restart$name
[17:45:23.324]                             if (is.null(name)) 
[17:45:23.324]                               next
[17:45:23.324]                             if (!grepl(pattern, name)) 
[17:45:23.324]                               next
[17:45:23.324]                             invokeRestart(restart)
[17:45:23.324]                             muffled <- TRUE
[17:45:23.324]                             break
[17:45:23.324]                           }
[17:45:23.324]                         }
[17:45:23.324]                       }
[17:45:23.324]                       invisible(muffled)
[17:45:23.324]                     }
[17:45:23.324]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.324]                   }
[17:45:23.324]                 }
[17:45:23.324]             }
[17:45:23.324]         }))
[17:45:23.324]     }, error = function(ex) {
[17:45:23.324]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:23.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.324]                 ...future.rng), started = ...future.startTime, 
[17:45:23.324]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:23.324]             version = "1.8"), class = "FutureResult")
[17:45:23.324]     }, finally = {
[17:45:23.324]         if (!identical(...future.workdir, getwd())) 
[17:45:23.324]             setwd(...future.workdir)
[17:45:23.324]         {
[17:45:23.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:23.324]                 ...future.oldOptions$nwarnings <- NULL
[17:45:23.324]             }
[17:45:23.324]             base::options(...future.oldOptions)
[17:45:23.324]             if (.Platform$OS.type == "windows") {
[17:45:23.324]                 old_names <- names(...future.oldEnvVars)
[17:45:23.324]                 envs <- base::Sys.getenv()
[17:45:23.324]                 names <- names(envs)
[17:45:23.324]                 common <- intersect(names, old_names)
[17:45:23.324]                 added <- setdiff(names, old_names)
[17:45:23.324]                 removed <- setdiff(old_names, names)
[17:45:23.324]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:23.324]                   envs[common]]
[17:45:23.324]                 NAMES <- toupper(changed)
[17:45:23.324]                 args <- list()
[17:45:23.324]                 for (kk in seq_along(NAMES)) {
[17:45:23.324]                   name <- changed[[kk]]
[17:45:23.324]                   NAME <- NAMES[[kk]]
[17:45:23.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.324]                     next
[17:45:23.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.324]                 }
[17:45:23.324]                 NAMES <- toupper(added)
[17:45:23.324]                 for (kk in seq_along(NAMES)) {
[17:45:23.324]                   name <- added[[kk]]
[17:45:23.324]                   NAME <- NAMES[[kk]]
[17:45:23.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.324]                     next
[17:45:23.324]                   args[[name]] <- ""
[17:45:23.324]                 }
[17:45:23.324]                 NAMES <- toupper(removed)
[17:45:23.324]                 for (kk in seq_along(NAMES)) {
[17:45:23.324]                   name <- removed[[kk]]
[17:45:23.324]                   NAME <- NAMES[[kk]]
[17:45:23.324]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.324]                     next
[17:45:23.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.324]                 }
[17:45:23.324]                 if (length(args) > 0) 
[17:45:23.324]                   base::do.call(base::Sys.setenv, args = args)
[17:45:23.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:23.324]             }
[17:45:23.324]             else {
[17:45:23.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:23.324]             }
[17:45:23.324]             {
[17:45:23.324]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:23.324]                   0L) {
[17:45:23.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:23.324]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:23.324]                   base::options(opts)
[17:45:23.324]                 }
[17:45:23.324]                 {
[17:45:23.324]                   {
[17:45:23.324]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:23.324]                     NULL
[17:45:23.324]                   }
[17:45:23.324]                   options(future.plan = NULL)
[17:45:23.324]                   if (is.na(NA_character_)) 
[17:45:23.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:23.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:23.324]                     .init = FALSE)
[17:45:23.324]                 }
[17:45:23.324]             }
[17:45:23.324]         }
[17:45:23.324]     })
[17:45:23.324]     if (TRUE) {
[17:45:23.324]         base::sink(type = "output", split = FALSE)
[17:45:23.324]         if (TRUE) {
[17:45:23.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:23.324]         }
[17:45:23.324]         else {
[17:45:23.324]             ...future.result["stdout"] <- base::list(NULL)
[17:45:23.324]         }
[17:45:23.324]         base::close(...future.stdout)
[17:45:23.324]         ...future.stdout <- NULL
[17:45:23.324]     }
[17:45:23.324]     ...future.result$conditions <- ...future.conditions
[17:45:23.324]     ...future.result$finished <- base::Sys.time()
[17:45:23.324]     ...future.result
[17:45:23.324] }
[17:45:23.326] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[17:45:23.326] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:23.368] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:23.368] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:45:23.368] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:45:23.368] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:23.369] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.369] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:23.412] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:23.412] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:23.456] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:23.456] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:45:23.456] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.456] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:45:23.457] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:45:23.457] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:23.457] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.458] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:23.458] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:23.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:23.458] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.458] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:23.459] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.459] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[17:45:23.459] MultisessionFuture started
[17:45:23.460] - Launch lazy future ... done
[17:45:23.460] run() for ‘MultisessionFuture’ ... done
[17:45:23.460] Created future:
[17:45:23.461] receiveMessageFromWorker() for ClusterFuture ...
[17:45:23.461] - Validating connection of MultisessionFuture
[17:45:23.462] - received message: FutureResult
[17:45:23.462] - Received FutureResult
[17:45:23.462] - Erased future from FutureRegistry
[17:45:23.462] result() for ClusterFuture ...
[17:45:23.462] - result already collected: FutureResult
[17:45:23.462] result() for ClusterFuture ... done
[17:45:23.462] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:23.460] MultisessionFuture:
[17:45:23.460] Label: ‘future_vapply-2’
[17:45:23.460] Expression:
[17:45:23.460] {
[17:45:23.460]     do.call(function(...) {
[17:45:23.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.460]             on.exit(options(oopts), add = TRUE)
[17:45:23.460]         }
[17:45:23.460]         {
[17:45:23.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.460]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.460]             })
[17:45:23.460]         }
[17:45:23.460]     }, args = future.call.arguments)
[17:45:23.460] }
[17:45:23.460] Lazy evaluation: FALSE
[17:45:23.460] Asynchronous evaluation: TRUE
[17:45:23.460] Local evaluation: TRUE
[17:45:23.460] Environment: R_GlobalEnv
[17:45:23.460] Capture standard output: TRUE
[17:45:23.460] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:23.460] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:23.460] Packages: 1 packages (‘future.apply’)
[17:45:23.460] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:23.460] Resolved: TRUE
[17:45:23.460] Value: <not collected>
[17:45:23.460] Conditions captured: <none>
[17:45:23.460] Early signaling: FALSE
[17:45:23.460] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:23.460] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.462] Chunk #2 of 2 ... DONE
[17:45:23.463] Launching 2 futures (chunks) ... DONE
[17:45:23.463] Resolving 2 futures (chunks) ...
[17:45:23.463] resolve() on list ...
[17:45:23.463]  recursive: 0
[17:45:23.463]  length: 2
[17:45:23.463] 
[17:45:23.463] Future #1
[17:45:23.463] result() for ClusterFuture ...
[17:45:23.463] - result already collected: FutureResult
[17:45:23.463] result() for ClusterFuture ... done
[17:45:23.463] result() for ClusterFuture ...
[17:45:23.464] - result already collected: FutureResult
[17:45:23.464] result() for ClusterFuture ... done
[17:45:23.464] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:23.464] - nx: 2
[17:45:23.464] - relay: TRUE
[17:45:23.464] - stdout: TRUE
[17:45:23.464] - signal: TRUE
[17:45:23.464] - resignal: FALSE
[17:45:23.464] - force: TRUE
[17:45:23.464] - relayed: [n=2] FALSE, FALSE
[17:45:23.464] - queued futures: [n=2] FALSE, FALSE
[17:45:23.465]  - until=1
[17:45:23.465]  - relaying element #1
[17:45:23.465] result() for ClusterFuture ...
[17:45:23.465] - result already collected: FutureResult
[17:45:23.465] result() for ClusterFuture ... done
[17:45:23.465] result() for ClusterFuture ...
[17:45:23.465] - result already collected: FutureResult
[17:45:23.465] result() for ClusterFuture ... done
[17:45:23.465] result() for ClusterFuture ...
[17:45:23.465] - result already collected: FutureResult
[17:45:23.465] result() for ClusterFuture ... done
[17:45:23.465] result() for ClusterFuture ...
[17:45:23.466] - result already collected: FutureResult
[17:45:23.466] result() for ClusterFuture ... done
[17:45:23.466] - relayed: [n=2] TRUE, FALSE
[17:45:23.466] - queued futures: [n=2] TRUE, FALSE
[17:45:23.466] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:23.466]  length: 1 (resolved future 1)
[17:45:23.466] Future #2
[17:45:23.466] result() for ClusterFuture ...
[17:45:23.466] - result already collected: FutureResult
[17:45:23.466] result() for ClusterFuture ... done
[17:45:23.466] result() for ClusterFuture ...
[17:45:23.467] - result already collected: FutureResult
[17:45:23.467] result() for ClusterFuture ... done
[17:45:23.467] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:23.467] - nx: 2
[17:45:23.467] - relay: TRUE
[17:45:23.467] - stdout: TRUE
[17:45:23.467] - signal: TRUE
[17:45:23.467] - resignal: FALSE
[17:45:23.467] - force: TRUE
[17:45:23.467] - relayed: [n=2] TRUE, FALSE
[17:45:23.467] - queued futures: [n=2] TRUE, FALSE
[17:45:23.470]  - until=2
[17:45:23.470]  - relaying element #2
[17:45:23.470] result() for ClusterFuture ...
[17:45:23.470] - result already collected: FutureResult
[17:45:23.471] result() for ClusterFuture ... done
[17:45:23.471] result() for ClusterFuture ...
[17:45:23.471] - result already collected: FutureResult
[17:45:23.471] result() for ClusterFuture ... done
[17:45:23.471] result() for ClusterFuture ...
[17:45:23.471] - result already collected: FutureResult
[17:45:23.471] result() for ClusterFuture ... done
[17:45:23.471] result() for ClusterFuture ...
[17:45:23.471] - result already collected: FutureResult
[17:45:23.471] result() for ClusterFuture ... done
[17:45:23.471] - relayed: [n=2] TRUE, TRUE
[17:45:23.472] - queued futures: [n=2] TRUE, TRUE
[17:45:23.472] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:23.472]  length: 0 (resolved future 2)
[17:45:23.472] Relaying remaining futures
[17:45:23.472] signalConditionsASAP(NULL, pos=0) ...
[17:45:23.472] - nx: 2
[17:45:23.472] - relay: TRUE
[17:45:23.472] - stdout: TRUE
[17:45:23.472] - signal: TRUE
[17:45:23.472] - resignal: FALSE
[17:45:23.472] - force: TRUE
[17:45:23.472] - relayed: [n=2] TRUE, TRUE
[17:45:23.473] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:23.473] - relayed: [n=2] TRUE, TRUE
[17:45:23.473] - queued futures: [n=2] TRUE, TRUE
[17:45:23.473] signalConditionsASAP(NULL, pos=0) ... done
[17:45:23.473] resolve() on list ... DONE
[17:45:23.473] result() for ClusterFuture ...
[17:45:23.473] - result already collected: FutureResult
[17:45:23.473] result() for ClusterFuture ... done
[17:45:23.473] result() for ClusterFuture ...
[17:45:23.473] - result already collected: FutureResult
[17:45:23.473] result() for ClusterFuture ... done
[17:45:23.474] result() for ClusterFuture ...
[17:45:23.474] - result already collected: FutureResult
[17:45:23.474] result() for ClusterFuture ... done
[17:45:23.474] result() for ClusterFuture ...
[17:45:23.474] - result already collected: FutureResult
[17:45:23.474] result() for ClusterFuture ... done
[17:45:23.474]  - Number of value chunks collected: 2
[17:45:23.474] Resolving 2 futures (chunks) ... DONE
[17:45:23.474] Reducing values from 2 chunks ...
[17:45:23.474]  - Number of values collected after concatenation: 10
[17:45:23.474]  - Number of values expected: 10
[17:45:23.474] Reducing values from 2 chunks ... DONE
[17:45:23.475] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[17:45:23.476] future_lapply() ...
[17:45:23.481] Number of chunks: 2
[17:45:23.481] getGlobalsAndPackagesXApply() ...
[17:45:23.481]  - future.globals: TRUE
[17:45:23.481] getGlobalsAndPackages() ...
[17:45:23.481] Searching for globals...
[17:45:23.485] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[17:45:23.485] Searching for globals ... DONE
[17:45:23.485] Resolving globals: FALSE
[17:45:23.486] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[17:45:23.486] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:23.486] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:23.487] - packages: [1] ‘future.apply’
[17:45:23.487] getGlobalsAndPackages() ... DONE
[17:45:23.487]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:23.487]  - needed namespaces: [n=1] ‘future.apply’
[17:45:23.487] Finding globals ... DONE
[17:45:23.487]  - use_args: TRUE
[17:45:23.487]  - Getting '...' globals ...
[17:45:23.487] resolve() on list ...
[17:45:23.488]  recursive: 0
[17:45:23.488]  length: 1
[17:45:23.488]  elements: ‘...’
[17:45:23.488]  length: 0 (resolved future 1)
[17:45:23.488] resolve() on list ... DONE
[17:45:23.488]    - '...' content: [n=0] 
[17:45:23.488] List of 1
[17:45:23.488]  $ ...: list()
[17:45:23.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:23.488]  - attr(*, "where")=List of 1
[17:45:23.488]   ..$ ...:<environment: 0x5561f5691f48> 
[17:45:23.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:23.488]  - attr(*, "resolved")= logi TRUE
[17:45:23.488]  - attr(*, "total_size")= num NA
[17:45:23.491]  - Getting '...' globals ... DONE
[17:45:23.491] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:23.491] List of 8
[17:45:23.491]  $ ...future.FUN:function (x, ...)  
[17:45:23.491]  $ x_FUN        :function (x)  
[17:45:23.491]  $ times        : int 4
[17:45:23.491]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:23.491]  $ stop_if_not  :function (...)  
[17:45:23.491]  $ dim          : int [1:2] 2 2
[17:45:23.491]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:23.491]  $ ...          : list()
[17:45:23.491]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:23.491]  - attr(*, "where")=List of 8
[17:45:23.491]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:23.491]   ..$ ...          :<environment: 0x5561f5691f48> 
[17:45:23.491]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:23.491]  - attr(*, "resolved")= logi FALSE
[17:45:23.491]  - attr(*, "total_size")= num 97304
[17:45:23.496] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:23.496] getGlobalsAndPackagesXApply() ... DONE
[17:45:23.497] Number of futures (= number of chunks): 2
[17:45:23.497] Launching 2 futures (chunks) ...
[17:45:23.497] Chunk #1 of 2 ...
[17:45:23.497]  - Finding globals in 'X' for chunk #1 ...
[17:45:23.497] getGlobalsAndPackages() ...
[17:45:23.497] Searching for globals...
[17:45:23.497] 
[17:45:23.497] Searching for globals ... DONE
[17:45:23.498] - globals: [0] <none>
[17:45:23.498] getGlobalsAndPackages() ... DONE
[17:45:23.498]    + additional globals found: [n=0] 
[17:45:23.498]    + additional namespaces needed: [n=0] 
[17:45:23.498]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:23.498]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:23.498]  - seeds: <none>
[17:45:23.498]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.498] getGlobalsAndPackages() ...
[17:45:23.498] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.499] Resolving globals: FALSE
[17:45:23.499] Tweak future expression to call with '...' arguments ...
[17:45:23.499] {
[17:45:23.499]     do.call(function(...) {
[17:45:23.499]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.499]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.499]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.499]             on.exit(options(oopts), add = TRUE)
[17:45:23.499]         }
[17:45:23.499]         {
[17:45:23.499]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.499]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.499]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.499]             })
[17:45:23.499]         }
[17:45:23.499]     }, args = future.call.arguments)
[17:45:23.499] }
[17:45:23.499] Tweak future expression to call with '...' arguments ... DONE
[17:45:23.499] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.500] - packages: [1] ‘future.apply’
[17:45:23.500] getGlobalsAndPackages() ... DONE
[17:45:23.500] run() for ‘Future’ ...
[17:45:23.500] - state: ‘created’
[17:45:23.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:23.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:23.514]   - Field: ‘node’
[17:45:23.514]   - Field: ‘label’
[17:45:23.514]   - Field: ‘local’
[17:45:23.514]   - Field: ‘owner’
[17:45:23.515]   - Field: ‘envir’
[17:45:23.515]   - Field: ‘workers’
[17:45:23.515]   - Field: ‘packages’
[17:45:23.515]   - Field: ‘gc’
[17:45:23.515]   - Field: ‘conditions’
[17:45:23.515]   - Field: ‘persistent’
[17:45:23.515]   - Field: ‘expr’
[17:45:23.515]   - Field: ‘uuid’
[17:45:23.515]   - Field: ‘seed’
[17:45:23.515]   - Field: ‘version’
[17:45:23.516]   - Field: ‘result’
[17:45:23.516]   - Field: ‘asynchronous’
[17:45:23.516]   - Field: ‘calls’
[17:45:23.516]   - Field: ‘globals’
[17:45:23.516]   - Field: ‘stdout’
[17:45:23.516]   - Field: ‘earlySignal’
[17:45:23.516]   - Field: ‘lazy’
[17:45:23.516]   - Field: ‘state’
[17:45:23.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:23.516] - Launch lazy future ...
[17:45:23.517] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:23.517] Packages needed by future strategies (n = 0): <none>
[17:45:23.517] {
[17:45:23.517]     {
[17:45:23.517]         {
[17:45:23.517]             ...future.startTime <- base::Sys.time()
[17:45:23.517]             {
[17:45:23.517]                 {
[17:45:23.517]                   {
[17:45:23.517]                     {
[17:45:23.517]                       {
[17:45:23.517]                         base::local({
[17:45:23.517]                           has_future <- base::requireNamespace("future", 
[17:45:23.517]                             quietly = TRUE)
[17:45:23.517]                           if (has_future) {
[17:45:23.517]                             ns <- base::getNamespace("future")
[17:45:23.517]                             version <- ns[[".package"]][["version"]]
[17:45:23.517]                             if (is.null(version)) 
[17:45:23.517]                               version <- utils::packageVersion("future")
[17:45:23.517]                           }
[17:45:23.517]                           else {
[17:45:23.517]                             version <- NULL
[17:45:23.517]                           }
[17:45:23.517]                           if (!has_future || version < "1.8.0") {
[17:45:23.517]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:23.517]                               "", base::R.version$version.string), 
[17:45:23.517]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:23.517]                                 base::R.version$platform, 8 * 
[17:45:23.517]                                   base::.Machine$sizeof.pointer), 
[17:45:23.517]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:23.517]                                 "release", "version")], collapse = " "), 
[17:45:23.517]                               hostname = base::Sys.info()[["nodename"]])
[17:45:23.517]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:23.517]                               info)
[17:45:23.517]                             info <- base::paste(info, collapse = "; ")
[17:45:23.517]                             if (!has_future) {
[17:45:23.517]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:23.517]                                 info)
[17:45:23.517]                             }
[17:45:23.517]                             else {
[17:45:23.517]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:23.517]                                 info, version)
[17:45:23.517]                             }
[17:45:23.517]                             base::stop(msg)
[17:45:23.517]                           }
[17:45:23.517]                         })
[17:45:23.517]                       }
[17:45:23.517]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:23.517]                       base::options(mc.cores = 1L)
[17:45:23.517]                     }
[17:45:23.517]                     base::local({
[17:45:23.517]                       for (pkg in "future.apply") {
[17:45:23.517]                         base::loadNamespace(pkg)
[17:45:23.517]                         base::library(pkg, character.only = TRUE)
[17:45:23.517]                       }
[17:45:23.517]                     })
[17:45:23.517]                   }
[17:45:23.517]                   ...future.strategy.old <- future::plan("list")
[17:45:23.517]                   options(future.plan = NULL)
[17:45:23.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:23.517]                 }
[17:45:23.517]                 ...future.workdir <- getwd()
[17:45:23.517]             }
[17:45:23.517]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:23.517]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:23.517]         }
[17:45:23.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:23.517]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:23.517]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:23.517]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:23.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:23.517]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:23.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:23.517]             base::names(...future.oldOptions))
[17:45:23.517]     }
[17:45:23.517]     if (FALSE) {
[17:45:23.517]     }
[17:45:23.517]     else {
[17:45:23.517]         if (TRUE) {
[17:45:23.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:23.517]                 open = "w")
[17:45:23.517]         }
[17:45:23.517]         else {
[17:45:23.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:23.517]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:23.517]         }
[17:45:23.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:23.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:23.517]             base::sink(type = "output", split = FALSE)
[17:45:23.517]             base::close(...future.stdout)
[17:45:23.517]         }, add = TRUE)
[17:45:23.517]     }
[17:45:23.517]     ...future.frame <- base::sys.nframe()
[17:45:23.517]     ...future.conditions <- base::list()
[17:45:23.517]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:23.517]     if (FALSE) {
[17:45:23.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:23.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:23.517]     }
[17:45:23.517]     ...future.result <- base::tryCatch({
[17:45:23.517]         base::withCallingHandlers({
[17:45:23.517]             ...future.value <- base::withVisible(base::local({
[17:45:23.517]                 ...future.makeSendCondition <- base::local({
[17:45:23.517]                   sendCondition <- NULL
[17:45:23.517]                   function(frame = 1L) {
[17:45:23.517]                     if (is.function(sendCondition)) 
[17:45:23.517]                       return(sendCondition)
[17:45:23.517]                     ns <- getNamespace("parallel")
[17:45:23.517]                     if (exists("sendData", mode = "function", 
[17:45:23.517]                       envir = ns)) {
[17:45:23.517]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:23.517]                         envir = ns)
[17:45:23.517]                       envir <- sys.frame(frame)
[17:45:23.517]                       master <- NULL
[17:45:23.517]                       while (!identical(envir, .GlobalEnv) && 
[17:45:23.517]                         !identical(envir, emptyenv())) {
[17:45:23.517]                         if (exists("master", mode = "list", envir = envir, 
[17:45:23.517]                           inherits = FALSE)) {
[17:45:23.517]                           master <- get("master", mode = "list", 
[17:45:23.517]                             envir = envir, inherits = FALSE)
[17:45:23.517]                           if (inherits(master, c("SOCKnode", 
[17:45:23.517]                             "SOCK0node"))) {
[17:45:23.517]                             sendCondition <<- function(cond) {
[17:45:23.517]                               data <- list(type = "VALUE", value = cond, 
[17:45:23.517]                                 success = TRUE)
[17:45:23.517]                               parallel_sendData(master, data)
[17:45:23.517]                             }
[17:45:23.517]                             return(sendCondition)
[17:45:23.517]                           }
[17:45:23.517]                         }
[17:45:23.517]                         frame <- frame + 1L
[17:45:23.517]                         envir <- sys.frame(frame)
[17:45:23.517]                       }
[17:45:23.517]                     }
[17:45:23.517]                     sendCondition <<- function(cond) NULL
[17:45:23.517]                   }
[17:45:23.517]                 })
[17:45:23.517]                 withCallingHandlers({
[17:45:23.517]                   {
[17:45:23.517]                     do.call(function(...) {
[17:45:23.517]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.517]                       if (!identical(...future.globals.maxSize.org, 
[17:45:23.517]                         ...future.globals.maxSize)) {
[17:45:23.517]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.517]                         on.exit(options(oopts), add = TRUE)
[17:45:23.517]                       }
[17:45:23.517]                       {
[17:45:23.517]                         lapply(seq_along(...future.elements_ii), 
[17:45:23.517]                           FUN = function(jj) {
[17:45:23.517]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.517]                             ...future.FUN(...future.X_jj, ...)
[17:45:23.517]                           })
[17:45:23.517]                       }
[17:45:23.517]                     }, args = future.call.arguments)
[17:45:23.517]                   }
[17:45:23.517]                 }, immediateCondition = function(cond) {
[17:45:23.517]                   sendCondition <- ...future.makeSendCondition()
[17:45:23.517]                   sendCondition(cond)
[17:45:23.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.517]                   {
[17:45:23.517]                     inherits <- base::inherits
[17:45:23.517]                     invokeRestart <- base::invokeRestart
[17:45:23.517]                     is.null <- base::is.null
[17:45:23.517]                     muffled <- FALSE
[17:45:23.517]                     if (inherits(cond, "message")) {
[17:45:23.517]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:23.517]                       if (muffled) 
[17:45:23.517]                         invokeRestart("muffleMessage")
[17:45:23.517]                     }
[17:45:23.517]                     else if (inherits(cond, "warning")) {
[17:45:23.517]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:23.517]                       if (muffled) 
[17:45:23.517]                         invokeRestart("muffleWarning")
[17:45:23.517]                     }
[17:45:23.517]                     else if (inherits(cond, "condition")) {
[17:45:23.517]                       if (!is.null(pattern)) {
[17:45:23.517]                         computeRestarts <- base::computeRestarts
[17:45:23.517]                         grepl <- base::grepl
[17:45:23.517]                         restarts <- computeRestarts(cond)
[17:45:23.517]                         for (restart in restarts) {
[17:45:23.517]                           name <- restart$name
[17:45:23.517]                           if (is.null(name)) 
[17:45:23.517]                             next
[17:45:23.517]                           if (!grepl(pattern, name)) 
[17:45:23.517]                             next
[17:45:23.517]                           invokeRestart(restart)
[17:45:23.517]                           muffled <- TRUE
[17:45:23.517]                           break
[17:45:23.517]                         }
[17:45:23.517]                       }
[17:45:23.517]                     }
[17:45:23.517]                     invisible(muffled)
[17:45:23.517]                   }
[17:45:23.517]                   muffleCondition(cond)
[17:45:23.517]                 })
[17:45:23.517]             }))
[17:45:23.517]             future::FutureResult(value = ...future.value$value, 
[17:45:23.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.517]                   ...future.rng), globalenv = if (FALSE) 
[17:45:23.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:23.517]                     ...future.globalenv.names))
[17:45:23.517]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:23.517]         }, condition = base::local({
[17:45:23.517]             c <- base::c
[17:45:23.517]             inherits <- base::inherits
[17:45:23.517]             invokeRestart <- base::invokeRestart
[17:45:23.517]             length <- base::length
[17:45:23.517]             list <- base::list
[17:45:23.517]             seq.int <- base::seq.int
[17:45:23.517]             signalCondition <- base::signalCondition
[17:45:23.517]             sys.calls <- base::sys.calls
[17:45:23.517]             `[[` <- base::`[[`
[17:45:23.517]             `+` <- base::`+`
[17:45:23.517]             `<<-` <- base::`<<-`
[17:45:23.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:23.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:23.517]                   3L)]
[17:45:23.517]             }
[17:45:23.517]             function(cond) {
[17:45:23.517]                 is_error <- inherits(cond, "error")
[17:45:23.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:23.517]                   NULL)
[17:45:23.517]                 if (is_error) {
[17:45:23.517]                   sessionInformation <- function() {
[17:45:23.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:23.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:23.517]                       search = base::search(), system = base::Sys.info())
[17:45:23.517]                   }
[17:45:23.517]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:23.517]                     cond$call), session = sessionInformation(), 
[17:45:23.517]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:23.517]                   signalCondition(cond)
[17:45:23.517]                 }
[17:45:23.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:23.517]                 "immediateCondition"))) {
[17:45:23.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:23.517]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:23.517]                   if (TRUE && !signal) {
[17:45:23.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.517]                     {
[17:45:23.517]                       inherits <- base::inherits
[17:45:23.517]                       invokeRestart <- base::invokeRestart
[17:45:23.517]                       is.null <- base::is.null
[17:45:23.517]                       muffled <- FALSE
[17:45:23.517]                       if (inherits(cond, "message")) {
[17:45:23.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.517]                         if (muffled) 
[17:45:23.517]                           invokeRestart("muffleMessage")
[17:45:23.517]                       }
[17:45:23.517]                       else if (inherits(cond, "warning")) {
[17:45:23.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.517]                         if (muffled) 
[17:45:23.517]                           invokeRestart("muffleWarning")
[17:45:23.517]                       }
[17:45:23.517]                       else if (inherits(cond, "condition")) {
[17:45:23.517]                         if (!is.null(pattern)) {
[17:45:23.517]                           computeRestarts <- base::computeRestarts
[17:45:23.517]                           grepl <- base::grepl
[17:45:23.517]                           restarts <- computeRestarts(cond)
[17:45:23.517]                           for (restart in restarts) {
[17:45:23.517]                             name <- restart$name
[17:45:23.517]                             if (is.null(name)) 
[17:45:23.517]                               next
[17:45:23.517]                             if (!grepl(pattern, name)) 
[17:45:23.517]                               next
[17:45:23.517]                             invokeRestart(restart)
[17:45:23.517]                             muffled <- TRUE
[17:45:23.517]                             break
[17:45:23.517]                           }
[17:45:23.517]                         }
[17:45:23.517]                       }
[17:45:23.517]                       invisible(muffled)
[17:45:23.517]                     }
[17:45:23.517]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.517]                   }
[17:45:23.517]                 }
[17:45:23.517]                 else {
[17:45:23.517]                   if (TRUE) {
[17:45:23.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.517]                     {
[17:45:23.517]                       inherits <- base::inherits
[17:45:23.517]                       invokeRestart <- base::invokeRestart
[17:45:23.517]                       is.null <- base::is.null
[17:45:23.517]                       muffled <- FALSE
[17:45:23.517]                       if (inherits(cond, "message")) {
[17:45:23.517]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.517]                         if (muffled) 
[17:45:23.517]                           invokeRestart("muffleMessage")
[17:45:23.517]                       }
[17:45:23.517]                       else if (inherits(cond, "warning")) {
[17:45:23.517]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.517]                         if (muffled) 
[17:45:23.517]                           invokeRestart("muffleWarning")
[17:45:23.517]                       }
[17:45:23.517]                       else if (inherits(cond, "condition")) {
[17:45:23.517]                         if (!is.null(pattern)) {
[17:45:23.517]                           computeRestarts <- base::computeRestarts
[17:45:23.517]                           grepl <- base::grepl
[17:45:23.517]                           restarts <- computeRestarts(cond)
[17:45:23.517]                           for (restart in restarts) {
[17:45:23.517]                             name <- restart$name
[17:45:23.517]                             if (is.null(name)) 
[17:45:23.517]                               next
[17:45:23.517]                             if (!grepl(pattern, name)) 
[17:45:23.517]                               next
[17:45:23.517]                             invokeRestart(restart)
[17:45:23.517]                             muffled <- TRUE
[17:45:23.517]                             break
[17:45:23.517]                           }
[17:45:23.517]                         }
[17:45:23.517]                       }
[17:45:23.517]                       invisible(muffled)
[17:45:23.517]                     }
[17:45:23.517]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.517]                   }
[17:45:23.517]                 }
[17:45:23.517]             }
[17:45:23.517]         }))
[17:45:23.517]     }, error = function(ex) {
[17:45:23.517]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:23.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.517]                 ...future.rng), started = ...future.startTime, 
[17:45:23.517]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:23.517]             version = "1.8"), class = "FutureResult")
[17:45:23.517]     }, finally = {
[17:45:23.517]         if (!identical(...future.workdir, getwd())) 
[17:45:23.517]             setwd(...future.workdir)
[17:45:23.517]         {
[17:45:23.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:23.517]                 ...future.oldOptions$nwarnings <- NULL
[17:45:23.517]             }
[17:45:23.517]             base::options(...future.oldOptions)
[17:45:23.517]             if (.Platform$OS.type == "windows") {
[17:45:23.517]                 old_names <- names(...future.oldEnvVars)
[17:45:23.517]                 envs <- base::Sys.getenv()
[17:45:23.517]                 names <- names(envs)
[17:45:23.517]                 common <- intersect(names, old_names)
[17:45:23.517]                 added <- setdiff(names, old_names)
[17:45:23.517]                 removed <- setdiff(old_names, names)
[17:45:23.517]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:23.517]                   envs[common]]
[17:45:23.517]                 NAMES <- toupper(changed)
[17:45:23.517]                 args <- list()
[17:45:23.517]                 for (kk in seq_along(NAMES)) {
[17:45:23.517]                   name <- changed[[kk]]
[17:45:23.517]                   NAME <- NAMES[[kk]]
[17:45:23.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.517]                     next
[17:45:23.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.517]                 }
[17:45:23.517]                 NAMES <- toupper(added)
[17:45:23.517]                 for (kk in seq_along(NAMES)) {
[17:45:23.517]                   name <- added[[kk]]
[17:45:23.517]                   NAME <- NAMES[[kk]]
[17:45:23.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.517]                     next
[17:45:23.517]                   args[[name]] <- ""
[17:45:23.517]                 }
[17:45:23.517]                 NAMES <- toupper(removed)
[17:45:23.517]                 for (kk in seq_along(NAMES)) {
[17:45:23.517]                   name <- removed[[kk]]
[17:45:23.517]                   NAME <- NAMES[[kk]]
[17:45:23.517]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.517]                     next
[17:45:23.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.517]                 }
[17:45:23.517]                 if (length(args) > 0) 
[17:45:23.517]                   base::do.call(base::Sys.setenv, args = args)
[17:45:23.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:23.517]             }
[17:45:23.517]             else {
[17:45:23.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:23.517]             }
[17:45:23.517]             {
[17:45:23.517]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:23.517]                   0L) {
[17:45:23.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:23.517]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:23.517]                   base::options(opts)
[17:45:23.517]                 }
[17:45:23.517]                 {
[17:45:23.517]                   {
[17:45:23.517]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:23.517]                     NULL
[17:45:23.517]                   }
[17:45:23.517]                   options(future.plan = NULL)
[17:45:23.517]                   if (is.na(NA_character_)) 
[17:45:23.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:23.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:23.517]                     .init = FALSE)
[17:45:23.517]                 }
[17:45:23.517]             }
[17:45:23.517]         }
[17:45:23.517]     })
[17:45:23.517]     if (TRUE) {
[17:45:23.517]         base::sink(type = "output", split = FALSE)
[17:45:23.517]         if (TRUE) {
[17:45:23.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:23.517]         }
[17:45:23.517]         else {
[17:45:23.517]             ...future.result["stdout"] <- base::list(NULL)
[17:45:23.517]         }
[17:45:23.517]         base::close(...future.stdout)
[17:45:23.517]         ...future.stdout <- NULL
[17:45:23.517]     }
[17:45:23.517]     ...future.result$conditions <- ...future.conditions
[17:45:23.517]     ...future.result$finished <- base::Sys.time()
[17:45:23.517]     ...future.result
[17:45:23.517] }
[17:45:23.520] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[17:45:23.520] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:23.564] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:23.564] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:45:23.564] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:45:23.564] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:23.565] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.565] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:23.608] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:23.608] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:23.652] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:23.652] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:45:23.652] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.652] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:23.653] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:23.653] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:23.653] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.654] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:23.654] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:23.654] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:23.654] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.655] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:23.655] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.655] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[17:45:23.656] MultisessionFuture started
[17:45:23.656] - Launch lazy future ... done
[17:45:23.656] run() for ‘MultisessionFuture’ ... done
[17:45:23.656] Created future:
[17:45:23.657] receiveMessageFromWorker() for ClusterFuture ...
[17:45:23.658] - Validating connection of MultisessionFuture
[17:45:23.658] - received message: FutureResult
[17:45:23.658] - Received FutureResult
[17:45:23.658] - Erased future from FutureRegistry
[17:45:23.658] result() for ClusterFuture ...
[17:45:23.658] - result already collected: FutureResult
[17:45:23.658] result() for ClusterFuture ... done
[17:45:23.658] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:23.656] MultisessionFuture:
[17:45:23.656] Label: ‘future_vapply-1’
[17:45:23.656] Expression:
[17:45:23.656] {
[17:45:23.656]     do.call(function(...) {
[17:45:23.656]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.656]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.656]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.656]             on.exit(options(oopts), add = TRUE)
[17:45:23.656]         }
[17:45:23.656]         {
[17:45:23.656]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.656]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.656]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.656]             })
[17:45:23.656]         }
[17:45:23.656]     }, args = future.call.arguments)
[17:45:23.656] }
[17:45:23.656] Lazy evaluation: FALSE
[17:45:23.656] Asynchronous evaluation: TRUE
[17:45:23.656] Local evaluation: TRUE
[17:45:23.656] Environment: R_GlobalEnv
[17:45:23.656] Capture standard output: TRUE
[17:45:23.656] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:23.656] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:23.656] Packages: 1 packages (‘future.apply’)
[17:45:23.656] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:23.656] Resolved: TRUE
[17:45:23.656] Value: <not collected>
[17:45:23.656] Conditions captured: <none>
[17:45:23.656] Early signaling: FALSE
[17:45:23.656] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:23.656] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.659] Chunk #1 of 2 ... DONE
[17:45:23.659] Chunk #2 of 2 ...
[17:45:23.659]  - Finding globals in 'X' for chunk #2 ...
[17:45:23.659] getGlobalsAndPackages() ...
[17:45:23.659] Searching for globals...
[17:45:23.659] 
[17:45:23.659] Searching for globals ... DONE
[17:45:23.659] - globals: [0] <none>
[17:45:23.660] getGlobalsAndPackages() ... DONE
[17:45:23.660]    + additional globals found: [n=0] 
[17:45:23.660]    + additional namespaces needed: [n=0] 
[17:45:23.660]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:23.660]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:23.660]  - seeds: <none>
[17:45:23.660]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.660] getGlobalsAndPackages() ...
[17:45:23.660] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.660] Resolving globals: FALSE
[17:45:23.661] Tweak future expression to call with '...' arguments ...
[17:45:23.661] {
[17:45:23.661]     do.call(function(...) {
[17:45:23.661]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.661]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.661]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.661]             on.exit(options(oopts), add = TRUE)
[17:45:23.661]         }
[17:45:23.661]         {
[17:45:23.661]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.661]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.661]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.661]             })
[17:45:23.661]         }
[17:45:23.661]     }, args = future.call.arguments)
[17:45:23.661] }
[17:45:23.661] Tweak future expression to call with '...' arguments ... DONE
[17:45:23.661] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.662] - packages: [1] ‘future.apply’
[17:45:23.662] getGlobalsAndPackages() ... DONE
[17:45:23.662] run() for ‘Future’ ...
[17:45:23.662] - state: ‘created’
[17:45:23.662] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:23.676] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:23.677]   - Field: ‘node’
[17:45:23.677]   - Field: ‘label’
[17:45:23.677]   - Field: ‘local’
[17:45:23.677]   - Field: ‘owner’
[17:45:23.677]   - Field: ‘envir’
[17:45:23.677]   - Field: ‘workers’
[17:45:23.677]   - Field: ‘packages’
[17:45:23.677]   - Field: ‘gc’
[17:45:23.677]   - Field: ‘conditions’
[17:45:23.677]   - Field: ‘persistent’
[17:45:23.678]   - Field: ‘expr’
[17:45:23.678]   - Field: ‘uuid’
[17:45:23.678]   - Field: ‘seed’
[17:45:23.678]   - Field: ‘version’
[17:45:23.678]   - Field: ‘result’
[17:45:23.678]   - Field: ‘asynchronous’
[17:45:23.678]   - Field: ‘calls’
[17:45:23.678]   - Field: ‘globals’
[17:45:23.678]   - Field: ‘stdout’
[17:45:23.678]   - Field: ‘earlySignal’
[17:45:23.678]   - Field: ‘lazy’
[17:45:23.679]   - Field: ‘state’
[17:45:23.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:23.679] - Launch lazy future ...
[17:45:23.679] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:23.679] Packages needed by future strategies (n = 0): <none>
[17:45:23.680] {
[17:45:23.680]     {
[17:45:23.680]         {
[17:45:23.680]             ...future.startTime <- base::Sys.time()
[17:45:23.680]             {
[17:45:23.680]                 {
[17:45:23.680]                   {
[17:45:23.680]                     {
[17:45:23.680]                       {
[17:45:23.680]                         base::local({
[17:45:23.680]                           has_future <- base::requireNamespace("future", 
[17:45:23.680]                             quietly = TRUE)
[17:45:23.680]                           if (has_future) {
[17:45:23.680]                             ns <- base::getNamespace("future")
[17:45:23.680]                             version <- ns[[".package"]][["version"]]
[17:45:23.680]                             if (is.null(version)) 
[17:45:23.680]                               version <- utils::packageVersion("future")
[17:45:23.680]                           }
[17:45:23.680]                           else {
[17:45:23.680]                             version <- NULL
[17:45:23.680]                           }
[17:45:23.680]                           if (!has_future || version < "1.8.0") {
[17:45:23.680]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:23.680]                               "", base::R.version$version.string), 
[17:45:23.680]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:23.680]                                 base::R.version$platform, 8 * 
[17:45:23.680]                                   base::.Machine$sizeof.pointer), 
[17:45:23.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:23.680]                                 "release", "version")], collapse = " "), 
[17:45:23.680]                               hostname = base::Sys.info()[["nodename"]])
[17:45:23.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:23.680]                               info)
[17:45:23.680]                             info <- base::paste(info, collapse = "; ")
[17:45:23.680]                             if (!has_future) {
[17:45:23.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:23.680]                                 info)
[17:45:23.680]                             }
[17:45:23.680]                             else {
[17:45:23.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:23.680]                                 info, version)
[17:45:23.680]                             }
[17:45:23.680]                             base::stop(msg)
[17:45:23.680]                           }
[17:45:23.680]                         })
[17:45:23.680]                       }
[17:45:23.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:23.680]                       base::options(mc.cores = 1L)
[17:45:23.680]                     }
[17:45:23.680]                     base::local({
[17:45:23.680]                       for (pkg in "future.apply") {
[17:45:23.680]                         base::loadNamespace(pkg)
[17:45:23.680]                         base::library(pkg, character.only = TRUE)
[17:45:23.680]                       }
[17:45:23.680]                     })
[17:45:23.680]                   }
[17:45:23.680]                   ...future.strategy.old <- future::plan("list")
[17:45:23.680]                   options(future.plan = NULL)
[17:45:23.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:23.680]                 }
[17:45:23.680]                 ...future.workdir <- getwd()
[17:45:23.680]             }
[17:45:23.680]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:23.680]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:23.680]         }
[17:45:23.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:23.680]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:23.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:23.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:23.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:23.680]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:23.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:23.680]             base::names(...future.oldOptions))
[17:45:23.680]     }
[17:45:23.680]     if (FALSE) {
[17:45:23.680]     }
[17:45:23.680]     else {
[17:45:23.680]         if (TRUE) {
[17:45:23.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:23.680]                 open = "w")
[17:45:23.680]         }
[17:45:23.680]         else {
[17:45:23.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:23.680]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:23.680]         }
[17:45:23.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:23.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:23.680]             base::sink(type = "output", split = FALSE)
[17:45:23.680]             base::close(...future.stdout)
[17:45:23.680]         }, add = TRUE)
[17:45:23.680]     }
[17:45:23.680]     ...future.frame <- base::sys.nframe()
[17:45:23.680]     ...future.conditions <- base::list()
[17:45:23.680]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:23.680]     if (FALSE) {
[17:45:23.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:23.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:23.680]     }
[17:45:23.680]     ...future.result <- base::tryCatch({
[17:45:23.680]         base::withCallingHandlers({
[17:45:23.680]             ...future.value <- base::withVisible(base::local({
[17:45:23.680]                 ...future.makeSendCondition <- base::local({
[17:45:23.680]                   sendCondition <- NULL
[17:45:23.680]                   function(frame = 1L) {
[17:45:23.680]                     if (is.function(sendCondition)) 
[17:45:23.680]                       return(sendCondition)
[17:45:23.680]                     ns <- getNamespace("parallel")
[17:45:23.680]                     if (exists("sendData", mode = "function", 
[17:45:23.680]                       envir = ns)) {
[17:45:23.680]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:23.680]                         envir = ns)
[17:45:23.680]                       envir <- sys.frame(frame)
[17:45:23.680]                       master <- NULL
[17:45:23.680]                       while (!identical(envir, .GlobalEnv) && 
[17:45:23.680]                         !identical(envir, emptyenv())) {
[17:45:23.680]                         if (exists("master", mode = "list", envir = envir, 
[17:45:23.680]                           inherits = FALSE)) {
[17:45:23.680]                           master <- get("master", mode = "list", 
[17:45:23.680]                             envir = envir, inherits = FALSE)
[17:45:23.680]                           if (inherits(master, c("SOCKnode", 
[17:45:23.680]                             "SOCK0node"))) {
[17:45:23.680]                             sendCondition <<- function(cond) {
[17:45:23.680]                               data <- list(type = "VALUE", value = cond, 
[17:45:23.680]                                 success = TRUE)
[17:45:23.680]                               parallel_sendData(master, data)
[17:45:23.680]                             }
[17:45:23.680]                             return(sendCondition)
[17:45:23.680]                           }
[17:45:23.680]                         }
[17:45:23.680]                         frame <- frame + 1L
[17:45:23.680]                         envir <- sys.frame(frame)
[17:45:23.680]                       }
[17:45:23.680]                     }
[17:45:23.680]                     sendCondition <<- function(cond) NULL
[17:45:23.680]                   }
[17:45:23.680]                 })
[17:45:23.680]                 withCallingHandlers({
[17:45:23.680]                   {
[17:45:23.680]                     do.call(function(...) {
[17:45:23.680]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.680]                       if (!identical(...future.globals.maxSize.org, 
[17:45:23.680]                         ...future.globals.maxSize)) {
[17:45:23.680]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.680]                         on.exit(options(oopts), add = TRUE)
[17:45:23.680]                       }
[17:45:23.680]                       {
[17:45:23.680]                         lapply(seq_along(...future.elements_ii), 
[17:45:23.680]                           FUN = function(jj) {
[17:45:23.680]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.680]                             ...future.FUN(...future.X_jj, ...)
[17:45:23.680]                           })
[17:45:23.680]                       }
[17:45:23.680]                     }, args = future.call.arguments)
[17:45:23.680]                   }
[17:45:23.680]                 }, immediateCondition = function(cond) {
[17:45:23.680]                   sendCondition <- ...future.makeSendCondition()
[17:45:23.680]                   sendCondition(cond)
[17:45:23.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.680]                   {
[17:45:23.680]                     inherits <- base::inherits
[17:45:23.680]                     invokeRestart <- base::invokeRestart
[17:45:23.680]                     is.null <- base::is.null
[17:45:23.680]                     muffled <- FALSE
[17:45:23.680]                     if (inherits(cond, "message")) {
[17:45:23.680]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:23.680]                       if (muffled) 
[17:45:23.680]                         invokeRestart("muffleMessage")
[17:45:23.680]                     }
[17:45:23.680]                     else if (inherits(cond, "warning")) {
[17:45:23.680]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:23.680]                       if (muffled) 
[17:45:23.680]                         invokeRestart("muffleWarning")
[17:45:23.680]                     }
[17:45:23.680]                     else if (inherits(cond, "condition")) {
[17:45:23.680]                       if (!is.null(pattern)) {
[17:45:23.680]                         computeRestarts <- base::computeRestarts
[17:45:23.680]                         grepl <- base::grepl
[17:45:23.680]                         restarts <- computeRestarts(cond)
[17:45:23.680]                         for (restart in restarts) {
[17:45:23.680]                           name <- restart$name
[17:45:23.680]                           if (is.null(name)) 
[17:45:23.680]                             next
[17:45:23.680]                           if (!grepl(pattern, name)) 
[17:45:23.680]                             next
[17:45:23.680]                           invokeRestart(restart)
[17:45:23.680]                           muffled <- TRUE
[17:45:23.680]                           break
[17:45:23.680]                         }
[17:45:23.680]                       }
[17:45:23.680]                     }
[17:45:23.680]                     invisible(muffled)
[17:45:23.680]                   }
[17:45:23.680]                   muffleCondition(cond)
[17:45:23.680]                 })
[17:45:23.680]             }))
[17:45:23.680]             future::FutureResult(value = ...future.value$value, 
[17:45:23.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.680]                   ...future.rng), globalenv = if (FALSE) 
[17:45:23.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:23.680]                     ...future.globalenv.names))
[17:45:23.680]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:23.680]         }, condition = base::local({
[17:45:23.680]             c <- base::c
[17:45:23.680]             inherits <- base::inherits
[17:45:23.680]             invokeRestart <- base::invokeRestart
[17:45:23.680]             length <- base::length
[17:45:23.680]             list <- base::list
[17:45:23.680]             seq.int <- base::seq.int
[17:45:23.680]             signalCondition <- base::signalCondition
[17:45:23.680]             sys.calls <- base::sys.calls
[17:45:23.680]             `[[` <- base::`[[`
[17:45:23.680]             `+` <- base::`+`
[17:45:23.680]             `<<-` <- base::`<<-`
[17:45:23.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:23.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:23.680]                   3L)]
[17:45:23.680]             }
[17:45:23.680]             function(cond) {
[17:45:23.680]                 is_error <- inherits(cond, "error")
[17:45:23.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:23.680]                   NULL)
[17:45:23.680]                 if (is_error) {
[17:45:23.680]                   sessionInformation <- function() {
[17:45:23.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:23.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:23.680]                       search = base::search(), system = base::Sys.info())
[17:45:23.680]                   }
[17:45:23.680]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:23.680]                     cond$call), session = sessionInformation(), 
[17:45:23.680]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:23.680]                   signalCondition(cond)
[17:45:23.680]                 }
[17:45:23.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:23.680]                 "immediateCondition"))) {
[17:45:23.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:23.680]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:23.680]                   if (TRUE && !signal) {
[17:45:23.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.680]                     {
[17:45:23.680]                       inherits <- base::inherits
[17:45:23.680]                       invokeRestart <- base::invokeRestart
[17:45:23.680]                       is.null <- base::is.null
[17:45:23.680]                       muffled <- FALSE
[17:45:23.680]                       if (inherits(cond, "message")) {
[17:45:23.680]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.680]                         if (muffled) 
[17:45:23.680]                           invokeRestart("muffleMessage")
[17:45:23.680]                       }
[17:45:23.680]                       else if (inherits(cond, "warning")) {
[17:45:23.680]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.680]                         if (muffled) 
[17:45:23.680]                           invokeRestart("muffleWarning")
[17:45:23.680]                       }
[17:45:23.680]                       else if (inherits(cond, "condition")) {
[17:45:23.680]                         if (!is.null(pattern)) {
[17:45:23.680]                           computeRestarts <- base::computeRestarts
[17:45:23.680]                           grepl <- base::grepl
[17:45:23.680]                           restarts <- computeRestarts(cond)
[17:45:23.680]                           for (restart in restarts) {
[17:45:23.680]                             name <- restart$name
[17:45:23.680]                             if (is.null(name)) 
[17:45:23.680]                               next
[17:45:23.680]                             if (!grepl(pattern, name)) 
[17:45:23.680]                               next
[17:45:23.680]                             invokeRestart(restart)
[17:45:23.680]                             muffled <- TRUE
[17:45:23.680]                             break
[17:45:23.680]                           }
[17:45:23.680]                         }
[17:45:23.680]                       }
[17:45:23.680]                       invisible(muffled)
[17:45:23.680]                     }
[17:45:23.680]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.680]                   }
[17:45:23.680]                 }
[17:45:23.680]                 else {
[17:45:23.680]                   if (TRUE) {
[17:45:23.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.680]                     {
[17:45:23.680]                       inherits <- base::inherits
[17:45:23.680]                       invokeRestart <- base::invokeRestart
[17:45:23.680]                       is.null <- base::is.null
[17:45:23.680]                       muffled <- FALSE
[17:45:23.680]                       if (inherits(cond, "message")) {
[17:45:23.680]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.680]                         if (muffled) 
[17:45:23.680]                           invokeRestart("muffleMessage")
[17:45:23.680]                       }
[17:45:23.680]                       else if (inherits(cond, "warning")) {
[17:45:23.680]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.680]                         if (muffled) 
[17:45:23.680]                           invokeRestart("muffleWarning")
[17:45:23.680]                       }
[17:45:23.680]                       else if (inherits(cond, "condition")) {
[17:45:23.680]                         if (!is.null(pattern)) {
[17:45:23.680]                           computeRestarts <- base::computeRestarts
[17:45:23.680]                           grepl <- base::grepl
[17:45:23.680]                           restarts <- computeRestarts(cond)
[17:45:23.680]                           for (restart in restarts) {
[17:45:23.680]                             name <- restart$name
[17:45:23.680]                             if (is.null(name)) 
[17:45:23.680]                               next
[17:45:23.680]                             if (!grepl(pattern, name)) 
[17:45:23.680]                               next
[17:45:23.680]                             invokeRestart(restart)
[17:45:23.680]                             muffled <- TRUE
[17:45:23.680]                             break
[17:45:23.680]                           }
[17:45:23.680]                         }
[17:45:23.680]                       }
[17:45:23.680]                       invisible(muffled)
[17:45:23.680]                     }
[17:45:23.680]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.680]                   }
[17:45:23.680]                 }
[17:45:23.680]             }
[17:45:23.680]         }))
[17:45:23.680]     }, error = function(ex) {
[17:45:23.680]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:23.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.680]                 ...future.rng), started = ...future.startTime, 
[17:45:23.680]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:23.680]             version = "1.8"), class = "FutureResult")
[17:45:23.680]     }, finally = {
[17:45:23.680]         if (!identical(...future.workdir, getwd())) 
[17:45:23.680]             setwd(...future.workdir)
[17:45:23.680]         {
[17:45:23.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:23.680]                 ...future.oldOptions$nwarnings <- NULL
[17:45:23.680]             }
[17:45:23.680]             base::options(...future.oldOptions)
[17:45:23.680]             if (.Platform$OS.type == "windows") {
[17:45:23.680]                 old_names <- names(...future.oldEnvVars)
[17:45:23.680]                 envs <- base::Sys.getenv()
[17:45:23.680]                 names <- names(envs)
[17:45:23.680]                 common <- intersect(names, old_names)
[17:45:23.680]                 added <- setdiff(names, old_names)
[17:45:23.680]                 removed <- setdiff(old_names, names)
[17:45:23.680]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:23.680]                   envs[common]]
[17:45:23.680]                 NAMES <- toupper(changed)
[17:45:23.680]                 args <- list()
[17:45:23.680]                 for (kk in seq_along(NAMES)) {
[17:45:23.680]                   name <- changed[[kk]]
[17:45:23.680]                   NAME <- NAMES[[kk]]
[17:45:23.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.680]                     next
[17:45:23.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.680]                 }
[17:45:23.680]                 NAMES <- toupper(added)
[17:45:23.680]                 for (kk in seq_along(NAMES)) {
[17:45:23.680]                   name <- added[[kk]]
[17:45:23.680]                   NAME <- NAMES[[kk]]
[17:45:23.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.680]                     next
[17:45:23.680]                   args[[name]] <- ""
[17:45:23.680]                 }
[17:45:23.680]                 NAMES <- toupper(removed)
[17:45:23.680]                 for (kk in seq_along(NAMES)) {
[17:45:23.680]                   name <- removed[[kk]]
[17:45:23.680]                   NAME <- NAMES[[kk]]
[17:45:23.680]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.680]                     next
[17:45:23.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.680]                 }
[17:45:23.680]                 if (length(args) > 0) 
[17:45:23.680]                   base::do.call(base::Sys.setenv, args = args)
[17:45:23.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:23.680]             }
[17:45:23.680]             else {
[17:45:23.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:23.680]             }
[17:45:23.680]             {
[17:45:23.680]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:23.680]                   0L) {
[17:45:23.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:23.680]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:23.680]                   base::options(opts)
[17:45:23.680]                 }
[17:45:23.680]                 {
[17:45:23.680]                   {
[17:45:23.680]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:23.680]                     NULL
[17:45:23.680]                   }
[17:45:23.680]                   options(future.plan = NULL)
[17:45:23.680]                   if (is.na(NA_character_)) 
[17:45:23.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:23.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:23.680]                     .init = FALSE)
[17:45:23.680]                 }
[17:45:23.680]             }
[17:45:23.680]         }
[17:45:23.680]     })
[17:45:23.680]     if (TRUE) {
[17:45:23.680]         base::sink(type = "output", split = FALSE)
[17:45:23.680]         if (TRUE) {
[17:45:23.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:23.680]         }
[17:45:23.680]         else {
[17:45:23.680]             ...future.result["stdout"] <- base::list(NULL)
[17:45:23.680]         }
[17:45:23.680]         base::close(...future.stdout)
[17:45:23.680]         ...future.stdout <- NULL
[17:45:23.680]     }
[17:45:23.680]     ...future.result$conditions <- ...future.conditions
[17:45:23.680]     ...future.result$finished <- base::Sys.time()
[17:45:23.680]     ...future.result
[17:45:23.680] }
[17:45:23.682] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[17:45:23.682] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:23.724] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:23.724] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[17:45:23.724] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[17:45:23.724] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:23.725] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.725] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:23.768] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:23.768] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:23.812] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:23.812] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:45:23.812] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.812] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:23.813] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:23.813] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:23.813] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.813] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:23.814] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:23.814] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:23.814] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.814] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:23.815] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:23.815] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[17:45:23.815] MultisessionFuture started
[17:45:23.815] - Launch lazy future ... done
[17:45:23.815] run() for ‘MultisessionFuture’ ... done
[17:45:23.816] Created future:
[17:45:23.817] receiveMessageFromWorker() for ClusterFuture ...
[17:45:23.817] - Validating connection of MultisessionFuture
[17:45:23.817] - received message: FutureResult
[17:45:23.817] - Received FutureResult
[17:45:23.817] - Erased future from FutureRegistry
[17:45:23.818] result() for ClusterFuture ...
[17:45:23.818] - result already collected: FutureResult
[17:45:23.818] result() for ClusterFuture ... done
[17:45:23.818] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:23.816] MultisessionFuture:
[17:45:23.816] Label: ‘future_vapply-2’
[17:45:23.816] Expression:
[17:45:23.816] {
[17:45:23.816]     do.call(function(...) {
[17:45:23.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.816]             on.exit(options(oopts), add = TRUE)
[17:45:23.816]         }
[17:45:23.816]         {
[17:45:23.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.816]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.816]             })
[17:45:23.816]         }
[17:45:23.816]     }, args = future.call.arguments)
[17:45:23.816] }
[17:45:23.816] Lazy evaluation: FALSE
[17:45:23.816] Asynchronous evaluation: TRUE
[17:45:23.816] Local evaluation: TRUE
[17:45:23.816] Environment: R_GlobalEnv
[17:45:23.816] Capture standard output: TRUE
[17:45:23.816] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:23.816] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:23.816] Packages: 1 packages (‘future.apply’)
[17:45:23.816] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:23.816] Resolved: TRUE
[17:45:23.816] Value: <not collected>
[17:45:23.816] Conditions captured: <none>
[17:45:23.816] Early signaling: FALSE
[17:45:23.816] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:23.816] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.818] Chunk #2 of 2 ... DONE
[17:45:23.818] Launching 2 futures (chunks) ... DONE
[17:45:23.818] Resolving 2 futures (chunks) ...
[17:45:23.818] resolve() on list ...
[17:45:23.818]  recursive: 0
[17:45:23.819]  length: 2
[17:45:23.819] 
[17:45:23.819] Future #1
[17:45:23.819] result() for ClusterFuture ...
[17:45:23.819] - result already collected: FutureResult
[17:45:23.819] result() for ClusterFuture ... done
[17:45:23.819] result() for ClusterFuture ...
[17:45:23.819] - result already collected: FutureResult
[17:45:23.819] result() for ClusterFuture ... done
[17:45:23.819] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:23.819] - nx: 2
[17:45:23.820] - relay: TRUE
[17:45:23.820] - stdout: TRUE
[17:45:23.820] - signal: TRUE
[17:45:23.820] - resignal: FALSE
[17:45:23.820] - force: TRUE
[17:45:23.820] - relayed: [n=2] FALSE, FALSE
[17:45:23.820] - queued futures: [n=2] FALSE, FALSE
[17:45:23.820]  - until=1
[17:45:23.820]  - relaying element #1
[17:45:23.820] result() for ClusterFuture ...
[17:45:23.820] - result already collected: FutureResult
[17:45:23.820] result() for ClusterFuture ... done
[17:45:23.821] result() for ClusterFuture ...
[17:45:23.821] - result already collected: FutureResult
[17:45:23.821] result() for ClusterFuture ... done
[17:45:23.821] result() for ClusterFuture ...
[17:45:23.821] - result already collected: FutureResult
[17:45:23.821] result() for ClusterFuture ... done
[17:45:23.821] result() for ClusterFuture ...
[17:45:23.821] - result already collected: FutureResult
[17:45:23.821] result() for ClusterFuture ... done
[17:45:23.821] - relayed: [n=2] TRUE, FALSE
[17:45:23.821] - queued futures: [n=2] TRUE, FALSE
[17:45:23.821] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:23.822]  length: 1 (resolved future 1)
[17:45:23.822] Future #2
[17:45:23.822] result() for ClusterFuture ...
[17:45:23.822] - result already collected: FutureResult
[17:45:23.822] result() for ClusterFuture ... done
[17:45:23.822] result() for ClusterFuture ...
[17:45:23.822] - result already collected: FutureResult
[17:45:23.822] result() for ClusterFuture ... done
[17:45:23.822] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:23.822] - nx: 2
[17:45:23.822] - relay: TRUE
[17:45:23.823] - stdout: TRUE
[17:45:23.823] - signal: TRUE
[17:45:23.823] - resignal: FALSE
[17:45:23.823] - force: TRUE
[17:45:23.823] - relayed: [n=2] TRUE, FALSE
[17:45:23.823] - queued futures: [n=2] TRUE, FALSE
[17:45:23.823]  - until=2
[17:45:23.823]  - relaying element #2
[17:45:23.823] result() for ClusterFuture ...
[17:45:23.823] - result already collected: FutureResult
[17:45:23.823] result() for ClusterFuture ... done
[17:45:23.823] result() for ClusterFuture ...
[17:45:23.824] - result already collected: FutureResult
[17:45:23.824] result() for ClusterFuture ... done
[17:45:23.824] result() for ClusterFuture ...
[17:45:23.824] - result already collected: FutureResult
[17:45:23.824] result() for ClusterFuture ... done
[17:45:23.824] result() for ClusterFuture ...
[17:45:23.824] - result already collected: FutureResult
[17:45:23.824] result() for ClusterFuture ... done
[17:45:23.824] - relayed: [n=2] TRUE, TRUE
[17:45:23.824] - queued futures: [n=2] TRUE, TRUE
[17:45:23.824] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:23.825]  length: 0 (resolved future 2)
[17:45:23.825] Relaying remaining futures
[17:45:23.825] signalConditionsASAP(NULL, pos=0) ...
[17:45:23.825] - nx: 2
[17:45:23.825] - relay: TRUE
[17:45:23.825] - stdout: TRUE
[17:45:23.825] - signal: TRUE
[17:45:23.825] - resignal: FALSE
[17:45:23.825] - force: TRUE
[17:45:23.825] - relayed: [n=2] TRUE, TRUE
[17:45:23.825] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:23.825] - relayed: [n=2] TRUE, TRUE
[17:45:23.826] - queued futures: [n=2] TRUE, TRUE
[17:45:23.826] signalConditionsASAP(NULL, pos=0) ... done
[17:45:23.826] resolve() on list ... DONE
[17:45:23.826] result() for ClusterFuture ...
[17:45:23.826] - result already collected: FutureResult
[17:45:23.826] result() for ClusterFuture ... done
[17:45:23.826] result() for ClusterFuture ...
[17:45:23.826] - result already collected: FutureResult
[17:45:23.826] result() for ClusterFuture ... done
[17:45:23.826] result() for ClusterFuture ...
[17:45:23.826] - result already collected: FutureResult
[17:45:23.827] result() for ClusterFuture ... done
[17:45:23.827] result() for ClusterFuture ...
[17:45:23.827] - result already collected: FutureResult
[17:45:23.827] result() for ClusterFuture ... done
[17:45:23.827]  - Number of value chunks collected: 2
[17:45:23.827] Resolving 2 futures (chunks) ... DONE
[17:45:23.827] Reducing values from 2 chunks ...
[17:45:23.827]  - Number of values collected after concatenation: 10
[17:45:23.827]  - Number of values expected: 10
[17:45:23.827] Reducing values from 2 chunks ... DONE
[17:45:23.827] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[17:45:23.829] future_lapply() ...
[17:45:23.835] Number of chunks: 2
[17:45:23.835] getGlobalsAndPackagesXApply() ...
[17:45:23.835]  - future.globals: TRUE
[17:45:23.835] getGlobalsAndPackages() ...
[17:45:23.835] Searching for globals...
[17:45:23.839] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[17:45:23.839] Searching for globals ... DONE
[17:45:23.839] Resolving globals: FALSE
[17:45:23.840] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[17:45:23.840] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:23.840] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:23.840] - packages: [1] ‘future.apply’
[17:45:23.841] getGlobalsAndPackages() ... DONE
[17:45:23.841]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:23.841]  - needed namespaces: [n=1] ‘future.apply’
[17:45:23.841] Finding globals ... DONE
[17:45:23.841]  - use_args: TRUE
[17:45:23.841]  - Getting '...' globals ...
[17:45:23.843] resolve() on list ...
[17:45:23.843]  recursive: 0
[17:45:23.843]  length: 1
[17:45:23.844]  elements: ‘...’
[17:45:23.844]  length: 0 (resolved future 1)
[17:45:23.844] resolve() on list ... DONE
[17:45:23.844]    - '...' content: [n=0] 
[17:45:23.844] List of 1
[17:45:23.844]  $ ...: list()
[17:45:23.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:23.844]  - attr(*, "where")=List of 1
[17:45:23.844]   ..$ ...:<environment: 0x5561f7da23b0> 
[17:45:23.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:23.844]  - attr(*, "resolved")= logi TRUE
[17:45:23.844]  - attr(*, "total_size")= num NA
[17:45:23.846]  - Getting '...' globals ... DONE
[17:45:23.846] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:23.847] List of 8
[17:45:23.847]  $ ...future.FUN:function (x, ...)  
[17:45:23.847]  $ x_FUN        :function (x)  
[17:45:23.847]  $ times        : int 4
[17:45:23.847]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:23.847]  $ stop_if_not  :function (...)  
[17:45:23.847]  $ dim          : int [1:2] 2 2
[17:45:23.847]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:23.847]  $ ...          : list()
[17:45:23.847]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:23.847]  - attr(*, "where")=List of 8
[17:45:23.847]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:23.847]   ..$ ...          :<environment: 0x5561f7da23b0> 
[17:45:23.847]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:23.847]  - attr(*, "resolved")= logi FALSE
[17:45:23.847]  - attr(*, "total_size")= num 105552
[17:45:23.852] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:23.852] getGlobalsAndPackagesXApply() ... DONE
[17:45:23.852] Number of futures (= number of chunks): 2
[17:45:23.852] Launching 2 futures (chunks) ...
[17:45:23.852] Chunk #1 of 2 ...
[17:45:23.852]  - Finding globals in 'X' for chunk #1 ...
[17:45:23.852] getGlobalsAndPackages() ...
[17:45:23.852] Searching for globals...
[17:45:23.853] 
[17:45:23.853] Searching for globals ... DONE
[17:45:23.853] - globals: [0] <none>
[17:45:23.853] getGlobalsAndPackages() ... DONE
[17:45:23.853]    + additional globals found: [n=0] 
[17:45:23.853]    + additional namespaces needed: [n=0] 
[17:45:23.853]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:23.853]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:23.853]  - seeds: <none>
[17:45:23.853]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.854] getGlobalsAndPackages() ...
[17:45:23.854] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.854] Resolving globals: FALSE
[17:45:23.854] Tweak future expression to call with '...' arguments ...
[17:45:23.854] {
[17:45:23.854]     do.call(function(...) {
[17:45:23.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:23.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.854]             on.exit(options(oopts), add = TRUE)
[17:45:23.854]         }
[17:45:23.854]         {
[17:45:23.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:23.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.854]                 ...future.FUN(...future.X_jj, ...)
[17:45:23.854]             })
[17:45:23.854]         }
[17:45:23.854]     }, args = future.call.arguments)
[17:45:23.854] }
[17:45:23.854] Tweak future expression to call with '...' arguments ... DONE
[17:45:23.855] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:23.855] - packages: [1] ‘future.apply’
[17:45:23.855] getGlobalsAndPackages() ... DONE
[17:45:23.855] run() for ‘Future’ ...
[17:45:23.855] - state: ‘created’
[17:45:23.856] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:23.870] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:23.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:23.870]   - Field: ‘node’
[17:45:23.870]   - Field: ‘label’
[17:45:23.870]   - Field: ‘local’
[17:45:23.870]   - Field: ‘owner’
[17:45:23.870]   - Field: ‘envir’
[17:45:23.870]   - Field: ‘workers’
[17:45:23.871]   - Field: ‘packages’
[17:45:23.871]   - Field: ‘gc’
[17:45:23.871]   - Field: ‘conditions’
[17:45:23.871]   - Field: ‘persistent’
[17:45:23.871]   - Field: ‘expr’
[17:45:23.871]   - Field: ‘uuid’
[17:45:23.871]   - Field: ‘seed’
[17:45:23.871]   - Field: ‘version’
[17:45:23.871]   - Field: ‘result’
[17:45:23.871]   - Field: ‘asynchronous’
[17:45:23.871]   - Field: ‘calls’
[17:45:23.872]   - Field: ‘globals’
[17:45:23.872]   - Field: ‘stdout’
[17:45:23.872]   - Field: ‘earlySignal’
[17:45:23.872]   - Field: ‘lazy’
[17:45:23.872]   - Field: ‘state’
[17:45:23.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:23.872] - Launch lazy future ...
[17:45:23.872] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:23.872] Packages needed by future strategies (n = 0): <none>
[17:45:23.873] {
[17:45:23.873]     {
[17:45:23.873]         {
[17:45:23.873]             ...future.startTime <- base::Sys.time()
[17:45:23.873]             {
[17:45:23.873]                 {
[17:45:23.873]                   {
[17:45:23.873]                     {
[17:45:23.873]                       {
[17:45:23.873]                         base::local({
[17:45:23.873]                           has_future <- base::requireNamespace("future", 
[17:45:23.873]                             quietly = TRUE)
[17:45:23.873]                           if (has_future) {
[17:45:23.873]                             ns <- base::getNamespace("future")
[17:45:23.873]                             version <- ns[[".package"]][["version"]]
[17:45:23.873]                             if (is.null(version)) 
[17:45:23.873]                               version <- utils::packageVersion("future")
[17:45:23.873]                           }
[17:45:23.873]                           else {
[17:45:23.873]                             version <- NULL
[17:45:23.873]                           }
[17:45:23.873]                           if (!has_future || version < "1.8.0") {
[17:45:23.873]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:23.873]                               "", base::R.version$version.string), 
[17:45:23.873]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:23.873]                                 base::R.version$platform, 8 * 
[17:45:23.873]                                   base::.Machine$sizeof.pointer), 
[17:45:23.873]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:23.873]                                 "release", "version")], collapse = " "), 
[17:45:23.873]                               hostname = base::Sys.info()[["nodename"]])
[17:45:23.873]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:23.873]                               info)
[17:45:23.873]                             info <- base::paste(info, collapse = "; ")
[17:45:23.873]                             if (!has_future) {
[17:45:23.873]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:23.873]                                 info)
[17:45:23.873]                             }
[17:45:23.873]                             else {
[17:45:23.873]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:23.873]                                 info, version)
[17:45:23.873]                             }
[17:45:23.873]                             base::stop(msg)
[17:45:23.873]                           }
[17:45:23.873]                         })
[17:45:23.873]                       }
[17:45:23.873]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:23.873]                       base::options(mc.cores = 1L)
[17:45:23.873]                     }
[17:45:23.873]                     base::local({
[17:45:23.873]                       for (pkg in "future.apply") {
[17:45:23.873]                         base::loadNamespace(pkg)
[17:45:23.873]                         base::library(pkg, character.only = TRUE)
[17:45:23.873]                       }
[17:45:23.873]                     })
[17:45:23.873]                   }
[17:45:23.873]                   ...future.strategy.old <- future::plan("list")
[17:45:23.873]                   options(future.plan = NULL)
[17:45:23.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:23.873]                 }
[17:45:23.873]                 ...future.workdir <- getwd()
[17:45:23.873]             }
[17:45:23.873]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:23.873]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:23.873]         }
[17:45:23.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:23.873]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:23.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:23.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:23.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:23.873]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:23.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:23.873]             base::names(...future.oldOptions))
[17:45:23.873]     }
[17:45:23.873]     if (FALSE) {
[17:45:23.873]     }
[17:45:23.873]     else {
[17:45:23.873]         if (TRUE) {
[17:45:23.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:23.873]                 open = "w")
[17:45:23.873]         }
[17:45:23.873]         else {
[17:45:23.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:23.873]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:23.873]         }
[17:45:23.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:23.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:23.873]             base::sink(type = "output", split = FALSE)
[17:45:23.873]             base::close(...future.stdout)
[17:45:23.873]         }, add = TRUE)
[17:45:23.873]     }
[17:45:23.873]     ...future.frame <- base::sys.nframe()
[17:45:23.873]     ...future.conditions <- base::list()
[17:45:23.873]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:23.873]     if (FALSE) {
[17:45:23.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:23.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:23.873]     }
[17:45:23.873]     ...future.result <- base::tryCatch({
[17:45:23.873]         base::withCallingHandlers({
[17:45:23.873]             ...future.value <- base::withVisible(base::local({
[17:45:23.873]                 ...future.makeSendCondition <- base::local({
[17:45:23.873]                   sendCondition <- NULL
[17:45:23.873]                   function(frame = 1L) {
[17:45:23.873]                     if (is.function(sendCondition)) 
[17:45:23.873]                       return(sendCondition)
[17:45:23.873]                     ns <- getNamespace("parallel")
[17:45:23.873]                     if (exists("sendData", mode = "function", 
[17:45:23.873]                       envir = ns)) {
[17:45:23.873]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:23.873]                         envir = ns)
[17:45:23.873]                       envir <- sys.frame(frame)
[17:45:23.873]                       master <- NULL
[17:45:23.873]                       while (!identical(envir, .GlobalEnv) && 
[17:45:23.873]                         !identical(envir, emptyenv())) {
[17:45:23.873]                         if (exists("master", mode = "list", envir = envir, 
[17:45:23.873]                           inherits = FALSE)) {
[17:45:23.873]                           master <- get("master", mode = "list", 
[17:45:23.873]                             envir = envir, inherits = FALSE)
[17:45:23.873]                           if (inherits(master, c("SOCKnode", 
[17:45:23.873]                             "SOCK0node"))) {
[17:45:23.873]                             sendCondition <<- function(cond) {
[17:45:23.873]                               data <- list(type = "VALUE", value = cond, 
[17:45:23.873]                                 success = TRUE)
[17:45:23.873]                               parallel_sendData(master, data)
[17:45:23.873]                             }
[17:45:23.873]                             return(sendCondition)
[17:45:23.873]                           }
[17:45:23.873]                         }
[17:45:23.873]                         frame <- frame + 1L
[17:45:23.873]                         envir <- sys.frame(frame)
[17:45:23.873]                       }
[17:45:23.873]                     }
[17:45:23.873]                     sendCondition <<- function(cond) NULL
[17:45:23.873]                   }
[17:45:23.873]                 })
[17:45:23.873]                 withCallingHandlers({
[17:45:23.873]                   {
[17:45:23.873]                     do.call(function(...) {
[17:45:23.873]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:23.873]                       if (!identical(...future.globals.maxSize.org, 
[17:45:23.873]                         ...future.globals.maxSize)) {
[17:45:23.873]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:23.873]                         on.exit(options(oopts), add = TRUE)
[17:45:23.873]                       }
[17:45:23.873]                       {
[17:45:23.873]                         lapply(seq_along(...future.elements_ii), 
[17:45:23.873]                           FUN = function(jj) {
[17:45:23.873]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:23.873]                             ...future.FUN(...future.X_jj, ...)
[17:45:23.873]                           })
[17:45:23.873]                       }
[17:45:23.873]                     }, args = future.call.arguments)
[17:45:23.873]                   }
[17:45:23.873]                 }, immediateCondition = function(cond) {
[17:45:23.873]                   sendCondition <- ...future.makeSendCondition()
[17:45:23.873]                   sendCondition(cond)
[17:45:23.873]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.873]                   {
[17:45:23.873]                     inherits <- base::inherits
[17:45:23.873]                     invokeRestart <- base::invokeRestart
[17:45:23.873]                     is.null <- base::is.null
[17:45:23.873]                     muffled <- FALSE
[17:45:23.873]                     if (inherits(cond, "message")) {
[17:45:23.873]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:23.873]                       if (muffled) 
[17:45:23.873]                         invokeRestart("muffleMessage")
[17:45:23.873]                     }
[17:45:23.873]                     else if (inherits(cond, "warning")) {
[17:45:23.873]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:23.873]                       if (muffled) 
[17:45:23.873]                         invokeRestart("muffleWarning")
[17:45:23.873]                     }
[17:45:23.873]                     else if (inherits(cond, "condition")) {
[17:45:23.873]                       if (!is.null(pattern)) {
[17:45:23.873]                         computeRestarts <- base::computeRestarts
[17:45:23.873]                         grepl <- base::grepl
[17:45:23.873]                         restarts <- computeRestarts(cond)
[17:45:23.873]                         for (restart in restarts) {
[17:45:23.873]                           name <- restart$name
[17:45:23.873]                           if (is.null(name)) 
[17:45:23.873]                             next
[17:45:23.873]                           if (!grepl(pattern, name)) 
[17:45:23.873]                             next
[17:45:23.873]                           invokeRestart(restart)
[17:45:23.873]                           muffled <- TRUE
[17:45:23.873]                           break
[17:45:23.873]                         }
[17:45:23.873]                       }
[17:45:23.873]                     }
[17:45:23.873]                     invisible(muffled)
[17:45:23.873]                   }
[17:45:23.873]                   muffleCondition(cond)
[17:45:23.873]                 })
[17:45:23.873]             }))
[17:45:23.873]             future::FutureResult(value = ...future.value$value, 
[17:45:23.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.873]                   ...future.rng), globalenv = if (FALSE) 
[17:45:23.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:23.873]                     ...future.globalenv.names))
[17:45:23.873]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:23.873]         }, condition = base::local({
[17:45:23.873]             c <- base::c
[17:45:23.873]             inherits <- base::inherits
[17:45:23.873]             invokeRestart <- base::invokeRestart
[17:45:23.873]             length <- base::length
[17:45:23.873]             list <- base::list
[17:45:23.873]             seq.int <- base::seq.int
[17:45:23.873]             signalCondition <- base::signalCondition
[17:45:23.873]             sys.calls <- base::sys.calls
[17:45:23.873]             `[[` <- base::`[[`
[17:45:23.873]             `+` <- base::`+`
[17:45:23.873]             `<<-` <- base::`<<-`
[17:45:23.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:23.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:23.873]                   3L)]
[17:45:23.873]             }
[17:45:23.873]             function(cond) {
[17:45:23.873]                 is_error <- inherits(cond, "error")
[17:45:23.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:23.873]                   NULL)
[17:45:23.873]                 if (is_error) {
[17:45:23.873]                   sessionInformation <- function() {
[17:45:23.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:23.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:23.873]                       search = base::search(), system = base::Sys.info())
[17:45:23.873]                   }
[17:45:23.873]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:23.873]                     cond$call), session = sessionInformation(), 
[17:45:23.873]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:23.873]                   signalCondition(cond)
[17:45:23.873]                 }
[17:45:23.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:23.873]                 "immediateCondition"))) {
[17:45:23.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:23.873]                   ...future.conditions[[length(...future.conditions) + 
[17:45:23.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:23.873]                   if (TRUE && !signal) {
[17:45:23.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.873]                     {
[17:45:23.873]                       inherits <- base::inherits
[17:45:23.873]                       invokeRestart <- base::invokeRestart
[17:45:23.873]                       is.null <- base::is.null
[17:45:23.873]                       muffled <- FALSE
[17:45:23.873]                       if (inherits(cond, "message")) {
[17:45:23.873]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.873]                         if (muffled) 
[17:45:23.873]                           invokeRestart("muffleMessage")
[17:45:23.873]                       }
[17:45:23.873]                       else if (inherits(cond, "warning")) {
[17:45:23.873]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.873]                         if (muffled) 
[17:45:23.873]                           invokeRestart("muffleWarning")
[17:45:23.873]                       }
[17:45:23.873]                       else if (inherits(cond, "condition")) {
[17:45:23.873]                         if (!is.null(pattern)) {
[17:45:23.873]                           computeRestarts <- base::computeRestarts
[17:45:23.873]                           grepl <- base::grepl
[17:45:23.873]                           restarts <- computeRestarts(cond)
[17:45:23.873]                           for (restart in restarts) {
[17:45:23.873]                             name <- restart$name
[17:45:23.873]                             if (is.null(name)) 
[17:45:23.873]                               next
[17:45:23.873]                             if (!grepl(pattern, name)) 
[17:45:23.873]                               next
[17:45:23.873]                             invokeRestart(restart)
[17:45:23.873]                             muffled <- TRUE
[17:45:23.873]                             break
[17:45:23.873]                           }
[17:45:23.873]                         }
[17:45:23.873]                       }
[17:45:23.873]                       invisible(muffled)
[17:45:23.873]                     }
[17:45:23.873]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.873]                   }
[17:45:23.873]                 }
[17:45:23.873]                 else {
[17:45:23.873]                   if (TRUE) {
[17:45:23.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:23.873]                     {
[17:45:23.873]                       inherits <- base::inherits
[17:45:23.873]                       invokeRestart <- base::invokeRestart
[17:45:23.873]                       is.null <- base::is.null
[17:45:23.873]                       muffled <- FALSE
[17:45:23.873]                       if (inherits(cond, "message")) {
[17:45:23.873]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:23.873]                         if (muffled) 
[17:45:23.873]                           invokeRestart("muffleMessage")
[17:45:23.873]                       }
[17:45:23.873]                       else if (inherits(cond, "warning")) {
[17:45:23.873]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:23.873]                         if (muffled) 
[17:45:23.873]                           invokeRestart("muffleWarning")
[17:45:23.873]                       }
[17:45:23.873]                       else if (inherits(cond, "condition")) {
[17:45:23.873]                         if (!is.null(pattern)) {
[17:45:23.873]                           computeRestarts <- base::computeRestarts
[17:45:23.873]                           grepl <- base::grepl
[17:45:23.873]                           restarts <- computeRestarts(cond)
[17:45:23.873]                           for (restart in restarts) {
[17:45:23.873]                             name <- restart$name
[17:45:23.873]                             if (is.null(name)) 
[17:45:23.873]                               next
[17:45:23.873]                             if (!grepl(pattern, name)) 
[17:45:23.873]                               next
[17:45:23.873]                             invokeRestart(restart)
[17:45:23.873]                             muffled <- TRUE
[17:45:23.873]                             break
[17:45:23.873]                           }
[17:45:23.873]                         }
[17:45:23.873]                       }
[17:45:23.873]                       invisible(muffled)
[17:45:23.873]                     }
[17:45:23.873]                     muffleCondition(cond, pattern = "^muffle")
[17:45:23.873]                   }
[17:45:23.873]                 }
[17:45:23.873]             }
[17:45:23.873]         }))
[17:45:23.873]     }, error = function(ex) {
[17:45:23.873]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:23.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:23.873]                 ...future.rng), started = ...future.startTime, 
[17:45:23.873]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:23.873]             version = "1.8"), class = "FutureResult")
[17:45:23.873]     }, finally = {
[17:45:23.873]         if (!identical(...future.workdir, getwd())) 
[17:45:23.873]             setwd(...future.workdir)
[17:45:23.873]         {
[17:45:23.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:23.873]                 ...future.oldOptions$nwarnings <- NULL
[17:45:23.873]             }
[17:45:23.873]             base::options(...future.oldOptions)
[17:45:23.873]             if (.Platform$OS.type == "windows") {
[17:45:23.873]                 old_names <- names(...future.oldEnvVars)
[17:45:23.873]                 envs <- base::Sys.getenv()
[17:45:23.873]                 names <- names(envs)
[17:45:23.873]                 common <- intersect(names, old_names)
[17:45:23.873]                 added <- setdiff(names, old_names)
[17:45:23.873]                 removed <- setdiff(old_names, names)
[17:45:23.873]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:23.873]                   envs[common]]
[17:45:23.873]                 NAMES <- toupper(changed)
[17:45:23.873]                 args <- list()
[17:45:23.873]                 for (kk in seq_along(NAMES)) {
[17:45:23.873]                   name <- changed[[kk]]
[17:45:23.873]                   NAME <- NAMES[[kk]]
[17:45:23.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.873]                     next
[17:45:23.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.873]                 }
[17:45:23.873]                 NAMES <- toupper(added)
[17:45:23.873]                 for (kk in seq_along(NAMES)) {
[17:45:23.873]                   name <- added[[kk]]
[17:45:23.873]                   NAME <- NAMES[[kk]]
[17:45:23.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.873]                     next
[17:45:23.873]                   args[[name]] <- ""
[17:45:23.873]                 }
[17:45:23.873]                 NAMES <- toupper(removed)
[17:45:23.873]                 for (kk in seq_along(NAMES)) {
[17:45:23.873]                   name <- removed[[kk]]
[17:45:23.873]                   NAME <- NAMES[[kk]]
[17:45:23.873]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:23.873]                     next
[17:45:23.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:23.873]                 }
[17:45:23.873]                 if (length(args) > 0) 
[17:45:23.873]                   base::do.call(base::Sys.setenv, args = args)
[17:45:23.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:23.873]             }
[17:45:23.873]             else {
[17:45:23.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:23.873]             }
[17:45:23.873]             {
[17:45:23.873]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:23.873]                   0L) {
[17:45:23.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:23.873]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:23.873]                   base::options(opts)
[17:45:23.873]                 }
[17:45:23.873]                 {
[17:45:23.873]                   {
[17:45:23.873]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:23.873]                     NULL
[17:45:23.873]                   }
[17:45:23.873]                   options(future.plan = NULL)
[17:45:23.873]                   if (is.na(NA_character_)) 
[17:45:23.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:23.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:23.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:23.873]                     .init = FALSE)
[17:45:23.873]                 }
[17:45:23.873]             }
[17:45:23.873]         }
[17:45:23.873]     })
[17:45:23.873]     if (TRUE) {
[17:45:23.873]         base::sink(type = "output", split = FALSE)
[17:45:23.873]         if (TRUE) {
[17:45:23.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:23.873]         }
[17:45:23.873]         else {
[17:45:23.873]             ...future.result["stdout"] <- base::list(NULL)
[17:45:23.873]         }
[17:45:23.873]         base::close(...future.stdout)
[17:45:23.873]         ...future.stdout <- NULL
[17:45:23.873]     }
[17:45:23.873]     ...future.result$conditions <- ...future.conditions
[17:45:23.873]     ...future.result$finished <- base::Sys.time()
[17:45:23.873]     ...future.result
[17:45:23.873] }
[17:45:23.876] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[17:45:23.876] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:23.920] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:23.920] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[17:45:23.920] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[17:45:23.920] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:23.921] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:23.921] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:23.964] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:23.964] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:24.008] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:24.008] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:45:24.008] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:45:24.008] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:24.009] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:24.009] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:24.009] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.010] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[17:45:24.010] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[17:45:24.010] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:24.010] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.010] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:24.011] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.011] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[17:45:24.011] MultisessionFuture started
[17:45:24.012] - Launch lazy future ... done
[17:45:24.012] run() for ‘MultisessionFuture’ ... done
[17:45:24.012] Created future:
[17:45:24.012] MultisessionFuture:
[17:45:24.012] Label: ‘future_vapply-1’
[17:45:24.012] Expression:
[17:45:24.012] {
[17:45:24.012]     do.call(function(...) {
[17:45:24.012]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.012]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.012]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.012]             on.exit(options(oopts), add = TRUE)
[17:45:24.012]         }
[17:45:24.012]         {
[17:45:24.012]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.012]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.012]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.012]             })
[17:45:24.012]         }
[17:45:24.012]     }, args = future.call.arguments)
[17:45:24.012] }
[17:45:24.012] Lazy evaluation: FALSE
[17:45:24.012] Asynchronous evaluation: TRUE
[17:45:24.012] Local evaluation: TRUE
[17:45:24.012] Environment: R_GlobalEnv
[17:45:24.012] Capture standard output: TRUE
[17:45:24.012] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:24.012] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:24.012] Packages: 1 packages (‘future.apply’)
[17:45:24.012] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:24.012] Resolved: FALSE
[17:45:24.012] Value: <not collected>
[17:45:24.012] Conditions captured: <none>
[17:45:24.012] Early signaling: FALSE
[17:45:24.012] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:24.012] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.024] Chunk #1 of 2 ... DONE
[17:45:24.024] Chunk #2 of 2 ...
[17:45:24.024]  - Finding globals in 'X' for chunk #2 ...
[17:45:24.024] getGlobalsAndPackages() ...
[17:45:24.024] Searching for globals...
[17:45:24.025] 
[17:45:24.025] Searching for globals ... DONE
[17:45:24.025] - globals: [0] <none>
[17:45:24.025] getGlobalsAndPackages() ... DONE
[17:45:24.025]    + additional globals found: [n=0] 
[17:45:24.025]    + additional namespaces needed: [n=0] 
[17:45:24.025]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:24.025]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:24.025]  - seeds: <none>
[17:45:24.025]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.025] getGlobalsAndPackages() ...
[17:45:24.026] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.026] Resolving globals: FALSE
[17:45:24.026] Tweak future expression to call with '...' arguments ...
[17:45:24.026] {
[17:45:24.026]     do.call(function(...) {
[17:45:24.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.026]             on.exit(options(oopts), add = TRUE)
[17:45:24.026]         }
[17:45:24.026]         {
[17:45:24.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.026]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.026]             })
[17:45:24.026]         }
[17:45:24.026]     }, args = future.call.arguments)
[17:45:24.026] }
[17:45:24.026] Tweak future expression to call with '...' arguments ... DONE
[17:45:24.027] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.027] - packages: [1] ‘future.apply’
[17:45:24.027] getGlobalsAndPackages() ... DONE
[17:45:24.027] run() for ‘Future’ ...
[17:45:24.027] - state: ‘created’
[17:45:24.028] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:24.042] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.042] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:24.042]   - Field: ‘node’
[17:45:24.042]   - Field: ‘label’
[17:45:24.042]   - Field: ‘local’
[17:45:24.042]   - Field: ‘owner’
[17:45:24.042]   - Field: ‘envir’
[17:45:24.042]   - Field: ‘workers’
[17:45:24.042]   - Field: ‘packages’
[17:45:24.043]   - Field: ‘gc’
[17:45:24.043]   - Field: ‘conditions’
[17:45:24.043]   - Field: ‘persistent’
[17:45:24.043]   - Field: ‘expr’
[17:45:24.043]   - Field: ‘uuid’
[17:45:24.043]   - Field: ‘seed’
[17:45:24.043]   - Field: ‘version’
[17:45:24.043]   - Field: ‘result’
[17:45:24.043]   - Field: ‘asynchronous’
[17:45:24.043]   - Field: ‘calls’
[17:45:24.044]   - Field: ‘globals’
[17:45:24.044]   - Field: ‘stdout’
[17:45:24.044]   - Field: ‘earlySignal’
[17:45:24.044]   - Field: ‘lazy’
[17:45:24.044]   - Field: ‘state’
[17:45:24.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:24.044] - Launch lazy future ...
[17:45:24.044] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:24.044] Packages needed by future strategies (n = 0): <none>
[17:45:24.045] {
[17:45:24.045]     {
[17:45:24.045]         {
[17:45:24.045]             ...future.startTime <- base::Sys.time()
[17:45:24.045]             {
[17:45:24.045]                 {
[17:45:24.045]                   {
[17:45:24.045]                     {
[17:45:24.045]                       {
[17:45:24.045]                         base::local({
[17:45:24.045]                           has_future <- base::requireNamespace("future", 
[17:45:24.045]                             quietly = TRUE)
[17:45:24.045]                           if (has_future) {
[17:45:24.045]                             ns <- base::getNamespace("future")
[17:45:24.045]                             version <- ns[[".package"]][["version"]]
[17:45:24.045]                             if (is.null(version)) 
[17:45:24.045]                               version <- utils::packageVersion("future")
[17:45:24.045]                           }
[17:45:24.045]                           else {
[17:45:24.045]                             version <- NULL
[17:45:24.045]                           }
[17:45:24.045]                           if (!has_future || version < "1.8.0") {
[17:45:24.045]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:24.045]                               "", base::R.version$version.string), 
[17:45:24.045]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:24.045]                                 base::R.version$platform, 8 * 
[17:45:24.045]                                   base::.Machine$sizeof.pointer), 
[17:45:24.045]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:24.045]                                 "release", "version")], collapse = " "), 
[17:45:24.045]                               hostname = base::Sys.info()[["nodename"]])
[17:45:24.045]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:24.045]                               info)
[17:45:24.045]                             info <- base::paste(info, collapse = "; ")
[17:45:24.045]                             if (!has_future) {
[17:45:24.045]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:24.045]                                 info)
[17:45:24.045]                             }
[17:45:24.045]                             else {
[17:45:24.045]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:24.045]                                 info, version)
[17:45:24.045]                             }
[17:45:24.045]                             base::stop(msg)
[17:45:24.045]                           }
[17:45:24.045]                         })
[17:45:24.045]                       }
[17:45:24.045]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:24.045]                       base::options(mc.cores = 1L)
[17:45:24.045]                     }
[17:45:24.045]                     base::local({
[17:45:24.045]                       for (pkg in "future.apply") {
[17:45:24.045]                         base::loadNamespace(pkg)
[17:45:24.045]                         base::library(pkg, character.only = TRUE)
[17:45:24.045]                       }
[17:45:24.045]                     })
[17:45:24.045]                   }
[17:45:24.045]                   ...future.strategy.old <- future::plan("list")
[17:45:24.045]                   options(future.plan = NULL)
[17:45:24.045]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.045]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:24.045]                 }
[17:45:24.045]                 ...future.workdir <- getwd()
[17:45:24.045]             }
[17:45:24.045]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:24.045]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:24.045]         }
[17:45:24.045]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:24.045]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:24.045]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:24.045]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:24.045]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:24.045]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:24.045]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:24.045]             base::names(...future.oldOptions))
[17:45:24.045]     }
[17:45:24.045]     if (FALSE) {
[17:45:24.045]     }
[17:45:24.045]     else {
[17:45:24.045]         if (TRUE) {
[17:45:24.045]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:24.045]                 open = "w")
[17:45:24.045]         }
[17:45:24.045]         else {
[17:45:24.045]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:24.045]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:24.045]         }
[17:45:24.045]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:24.045]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:24.045]             base::sink(type = "output", split = FALSE)
[17:45:24.045]             base::close(...future.stdout)
[17:45:24.045]         }, add = TRUE)
[17:45:24.045]     }
[17:45:24.045]     ...future.frame <- base::sys.nframe()
[17:45:24.045]     ...future.conditions <- base::list()
[17:45:24.045]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:24.045]     if (FALSE) {
[17:45:24.045]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:24.045]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:24.045]     }
[17:45:24.045]     ...future.result <- base::tryCatch({
[17:45:24.045]         base::withCallingHandlers({
[17:45:24.045]             ...future.value <- base::withVisible(base::local({
[17:45:24.045]                 ...future.makeSendCondition <- base::local({
[17:45:24.045]                   sendCondition <- NULL
[17:45:24.045]                   function(frame = 1L) {
[17:45:24.045]                     if (is.function(sendCondition)) 
[17:45:24.045]                       return(sendCondition)
[17:45:24.045]                     ns <- getNamespace("parallel")
[17:45:24.045]                     if (exists("sendData", mode = "function", 
[17:45:24.045]                       envir = ns)) {
[17:45:24.045]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:24.045]                         envir = ns)
[17:45:24.045]                       envir <- sys.frame(frame)
[17:45:24.045]                       master <- NULL
[17:45:24.045]                       while (!identical(envir, .GlobalEnv) && 
[17:45:24.045]                         !identical(envir, emptyenv())) {
[17:45:24.045]                         if (exists("master", mode = "list", envir = envir, 
[17:45:24.045]                           inherits = FALSE)) {
[17:45:24.045]                           master <- get("master", mode = "list", 
[17:45:24.045]                             envir = envir, inherits = FALSE)
[17:45:24.045]                           if (inherits(master, c("SOCKnode", 
[17:45:24.045]                             "SOCK0node"))) {
[17:45:24.045]                             sendCondition <<- function(cond) {
[17:45:24.045]                               data <- list(type = "VALUE", value = cond, 
[17:45:24.045]                                 success = TRUE)
[17:45:24.045]                               parallel_sendData(master, data)
[17:45:24.045]                             }
[17:45:24.045]                             return(sendCondition)
[17:45:24.045]                           }
[17:45:24.045]                         }
[17:45:24.045]                         frame <- frame + 1L
[17:45:24.045]                         envir <- sys.frame(frame)
[17:45:24.045]                       }
[17:45:24.045]                     }
[17:45:24.045]                     sendCondition <<- function(cond) NULL
[17:45:24.045]                   }
[17:45:24.045]                 })
[17:45:24.045]                 withCallingHandlers({
[17:45:24.045]                   {
[17:45:24.045]                     do.call(function(...) {
[17:45:24.045]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.045]                       if (!identical(...future.globals.maxSize.org, 
[17:45:24.045]                         ...future.globals.maxSize)) {
[17:45:24.045]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.045]                         on.exit(options(oopts), add = TRUE)
[17:45:24.045]                       }
[17:45:24.045]                       {
[17:45:24.045]                         lapply(seq_along(...future.elements_ii), 
[17:45:24.045]                           FUN = function(jj) {
[17:45:24.045]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.045]                             ...future.FUN(...future.X_jj, ...)
[17:45:24.045]                           })
[17:45:24.045]                       }
[17:45:24.045]                     }, args = future.call.arguments)
[17:45:24.045]                   }
[17:45:24.045]                 }, immediateCondition = function(cond) {
[17:45:24.045]                   sendCondition <- ...future.makeSendCondition()
[17:45:24.045]                   sendCondition(cond)
[17:45:24.045]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.045]                   {
[17:45:24.045]                     inherits <- base::inherits
[17:45:24.045]                     invokeRestart <- base::invokeRestart
[17:45:24.045]                     is.null <- base::is.null
[17:45:24.045]                     muffled <- FALSE
[17:45:24.045]                     if (inherits(cond, "message")) {
[17:45:24.045]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:24.045]                       if (muffled) 
[17:45:24.045]                         invokeRestart("muffleMessage")
[17:45:24.045]                     }
[17:45:24.045]                     else if (inherits(cond, "warning")) {
[17:45:24.045]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:24.045]                       if (muffled) 
[17:45:24.045]                         invokeRestart("muffleWarning")
[17:45:24.045]                     }
[17:45:24.045]                     else if (inherits(cond, "condition")) {
[17:45:24.045]                       if (!is.null(pattern)) {
[17:45:24.045]                         computeRestarts <- base::computeRestarts
[17:45:24.045]                         grepl <- base::grepl
[17:45:24.045]                         restarts <- computeRestarts(cond)
[17:45:24.045]                         for (restart in restarts) {
[17:45:24.045]                           name <- restart$name
[17:45:24.045]                           if (is.null(name)) 
[17:45:24.045]                             next
[17:45:24.045]                           if (!grepl(pattern, name)) 
[17:45:24.045]                             next
[17:45:24.045]                           invokeRestart(restart)
[17:45:24.045]                           muffled <- TRUE
[17:45:24.045]                           break
[17:45:24.045]                         }
[17:45:24.045]                       }
[17:45:24.045]                     }
[17:45:24.045]                     invisible(muffled)
[17:45:24.045]                   }
[17:45:24.045]                   muffleCondition(cond)
[17:45:24.045]                 })
[17:45:24.045]             }))
[17:45:24.045]             future::FutureResult(value = ...future.value$value, 
[17:45:24.045]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.045]                   ...future.rng), globalenv = if (FALSE) 
[17:45:24.045]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:24.045]                     ...future.globalenv.names))
[17:45:24.045]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:24.045]         }, condition = base::local({
[17:45:24.045]             c <- base::c
[17:45:24.045]             inherits <- base::inherits
[17:45:24.045]             invokeRestart <- base::invokeRestart
[17:45:24.045]             length <- base::length
[17:45:24.045]             list <- base::list
[17:45:24.045]             seq.int <- base::seq.int
[17:45:24.045]             signalCondition <- base::signalCondition
[17:45:24.045]             sys.calls <- base::sys.calls
[17:45:24.045]             `[[` <- base::`[[`
[17:45:24.045]             `+` <- base::`+`
[17:45:24.045]             `<<-` <- base::`<<-`
[17:45:24.045]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:24.045]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:24.045]                   3L)]
[17:45:24.045]             }
[17:45:24.045]             function(cond) {
[17:45:24.045]                 is_error <- inherits(cond, "error")
[17:45:24.045]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:24.045]                   NULL)
[17:45:24.045]                 if (is_error) {
[17:45:24.045]                   sessionInformation <- function() {
[17:45:24.045]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:24.045]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:24.045]                       search = base::search(), system = base::Sys.info())
[17:45:24.045]                   }
[17:45:24.045]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.045]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:24.045]                     cond$call), session = sessionInformation(), 
[17:45:24.045]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:24.045]                   signalCondition(cond)
[17:45:24.045]                 }
[17:45:24.045]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:24.045]                 "immediateCondition"))) {
[17:45:24.045]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:24.045]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.045]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:24.045]                   if (TRUE && !signal) {
[17:45:24.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.045]                     {
[17:45:24.045]                       inherits <- base::inherits
[17:45:24.045]                       invokeRestart <- base::invokeRestart
[17:45:24.045]                       is.null <- base::is.null
[17:45:24.045]                       muffled <- FALSE
[17:45:24.045]                       if (inherits(cond, "message")) {
[17:45:24.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.045]                         if (muffled) 
[17:45:24.045]                           invokeRestart("muffleMessage")
[17:45:24.045]                       }
[17:45:24.045]                       else if (inherits(cond, "warning")) {
[17:45:24.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.045]                         if (muffled) 
[17:45:24.045]                           invokeRestart("muffleWarning")
[17:45:24.045]                       }
[17:45:24.045]                       else if (inherits(cond, "condition")) {
[17:45:24.045]                         if (!is.null(pattern)) {
[17:45:24.045]                           computeRestarts <- base::computeRestarts
[17:45:24.045]                           grepl <- base::grepl
[17:45:24.045]                           restarts <- computeRestarts(cond)
[17:45:24.045]                           for (restart in restarts) {
[17:45:24.045]                             name <- restart$name
[17:45:24.045]                             if (is.null(name)) 
[17:45:24.045]                               next
[17:45:24.045]                             if (!grepl(pattern, name)) 
[17:45:24.045]                               next
[17:45:24.045]                             invokeRestart(restart)
[17:45:24.045]                             muffled <- TRUE
[17:45:24.045]                             break
[17:45:24.045]                           }
[17:45:24.045]                         }
[17:45:24.045]                       }
[17:45:24.045]                       invisible(muffled)
[17:45:24.045]                     }
[17:45:24.045]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.045]                   }
[17:45:24.045]                 }
[17:45:24.045]                 else {
[17:45:24.045]                   if (TRUE) {
[17:45:24.045]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.045]                     {
[17:45:24.045]                       inherits <- base::inherits
[17:45:24.045]                       invokeRestart <- base::invokeRestart
[17:45:24.045]                       is.null <- base::is.null
[17:45:24.045]                       muffled <- FALSE
[17:45:24.045]                       if (inherits(cond, "message")) {
[17:45:24.045]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.045]                         if (muffled) 
[17:45:24.045]                           invokeRestart("muffleMessage")
[17:45:24.045]                       }
[17:45:24.045]                       else if (inherits(cond, "warning")) {
[17:45:24.045]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.045]                         if (muffled) 
[17:45:24.045]                           invokeRestart("muffleWarning")
[17:45:24.045]                       }
[17:45:24.045]                       else if (inherits(cond, "condition")) {
[17:45:24.045]                         if (!is.null(pattern)) {
[17:45:24.045]                           computeRestarts <- base::computeRestarts
[17:45:24.045]                           grepl <- base::grepl
[17:45:24.045]                           restarts <- computeRestarts(cond)
[17:45:24.045]                           for (restart in restarts) {
[17:45:24.045]                             name <- restart$name
[17:45:24.045]                             if (is.null(name)) 
[17:45:24.045]                               next
[17:45:24.045]                             if (!grepl(pattern, name)) 
[17:45:24.045]                               next
[17:45:24.045]                             invokeRestart(restart)
[17:45:24.045]                             muffled <- TRUE
[17:45:24.045]                             break
[17:45:24.045]                           }
[17:45:24.045]                         }
[17:45:24.045]                       }
[17:45:24.045]                       invisible(muffled)
[17:45:24.045]                     }
[17:45:24.045]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.045]                   }
[17:45:24.045]                 }
[17:45:24.045]             }
[17:45:24.045]         }))
[17:45:24.045]     }, error = function(ex) {
[17:45:24.045]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:24.045]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.045]                 ...future.rng), started = ...future.startTime, 
[17:45:24.045]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:24.045]             version = "1.8"), class = "FutureResult")
[17:45:24.045]     }, finally = {
[17:45:24.045]         if (!identical(...future.workdir, getwd())) 
[17:45:24.045]             setwd(...future.workdir)
[17:45:24.045]         {
[17:45:24.045]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:24.045]                 ...future.oldOptions$nwarnings <- NULL
[17:45:24.045]             }
[17:45:24.045]             base::options(...future.oldOptions)
[17:45:24.045]             if (.Platform$OS.type == "windows") {
[17:45:24.045]                 old_names <- names(...future.oldEnvVars)
[17:45:24.045]                 envs <- base::Sys.getenv()
[17:45:24.045]                 names <- names(envs)
[17:45:24.045]                 common <- intersect(names, old_names)
[17:45:24.045]                 added <- setdiff(names, old_names)
[17:45:24.045]                 removed <- setdiff(old_names, names)
[17:45:24.045]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:24.045]                   envs[common]]
[17:45:24.045]                 NAMES <- toupper(changed)
[17:45:24.045]                 args <- list()
[17:45:24.045]                 for (kk in seq_along(NAMES)) {
[17:45:24.045]                   name <- changed[[kk]]
[17:45:24.045]                   NAME <- NAMES[[kk]]
[17:45:24.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.045]                     next
[17:45:24.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.045]                 }
[17:45:24.045]                 NAMES <- toupper(added)
[17:45:24.045]                 for (kk in seq_along(NAMES)) {
[17:45:24.045]                   name <- added[[kk]]
[17:45:24.045]                   NAME <- NAMES[[kk]]
[17:45:24.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.045]                     next
[17:45:24.045]                   args[[name]] <- ""
[17:45:24.045]                 }
[17:45:24.045]                 NAMES <- toupper(removed)
[17:45:24.045]                 for (kk in seq_along(NAMES)) {
[17:45:24.045]                   name <- removed[[kk]]
[17:45:24.045]                   NAME <- NAMES[[kk]]
[17:45:24.045]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.045]                     next
[17:45:24.045]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.045]                 }
[17:45:24.045]                 if (length(args) > 0) 
[17:45:24.045]                   base::do.call(base::Sys.setenv, args = args)
[17:45:24.045]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:24.045]             }
[17:45:24.045]             else {
[17:45:24.045]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:24.045]             }
[17:45:24.045]             {
[17:45:24.045]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:24.045]                   0L) {
[17:45:24.045]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:24.045]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:24.045]                   base::options(opts)
[17:45:24.045]                 }
[17:45:24.045]                 {
[17:45:24.045]                   {
[17:45:24.045]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:24.045]                     NULL
[17:45:24.045]                   }
[17:45:24.045]                   options(future.plan = NULL)
[17:45:24.045]                   if (is.na(NA_character_)) 
[17:45:24.045]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.045]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:24.045]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:24.045]                     .init = FALSE)
[17:45:24.045]                 }
[17:45:24.045]             }
[17:45:24.045]         }
[17:45:24.045]     })
[17:45:24.045]     if (TRUE) {
[17:45:24.045]         base::sink(type = "output", split = FALSE)
[17:45:24.045]         if (TRUE) {
[17:45:24.045]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:24.045]         }
[17:45:24.045]         else {
[17:45:24.045]             ...future.result["stdout"] <- base::list(NULL)
[17:45:24.045]         }
[17:45:24.045]         base::close(...future.stdout)
[17:45:24.045]         ...future.stdout <- NULL
[17:45:24.045]     }
[17:45:24.045]     ...future.result$conditions <- ...future.conditions
[17:45:24.045]     ...future.result$finished <- base::Sys.time()
[17:45:24.045]     ...future.result
[17:45:24.045] }
[17:45:24.048] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[17:45:24.048] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:24.092] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:24.092] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[17:45:24.092] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[17:45:24.092] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:24.093] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:24.093] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:24.136] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:24.136] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:24.180] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:24.180] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:45:24.180] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:45:24.181] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:45:24.181] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:45:24.181] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:24.182] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:24.182] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[17:45:24.182] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[17:45:24.182] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:24.183] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:24.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:24.183] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:24.183] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[17:45:24.184] MultisessionFuture started
[17:45:24.184] - Launch lazy future ... done
[17:45:24.184] run() for ‘MultisessionFuture’ ... done
[17:45:24.184] Created future:
[17:45:24.186] receiveMessageFromWorker() for ClusterFuture ...
[17:45:24.186] - Validating connection of MultisessionFuture
[17:45:24.186] - received message: FutureResult
[17:45:24.186] - Received FutureResult
[17:45:24.186] - Erased future from FutureRegistry
[17:45:24.186] result() for ClusterFuture ...
[17:45:24.186] - result already collected: FutureResult
[17:45:24.186] result() for ClusterFuture ... done
[17:45:24.186] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:24.184] MultisessionFuture:
[17:45:24.184] Label: ‘future_vapply-2’
[17:45:24.184] Expression:
[17:45:24.184] {
[17:45:24.184]     do.call(function(...) {
[17:45:24.184]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.184]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.184]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.184]             on.exit(options(oopts), add = TRUE)
[17:45:24.184]         }
[17:45:24.184]         {
[17:45:24.184]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.184]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.184]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.184]             })
[17:45:24.184]         }
[17:45:24.184]     }, args = future.call.arguments)
[17:45:24.184] }
[17:45:24.184] Lazy evaluation: FALSE
[17:45:24.184] Asynchronous evaluation: TRUE
[17:45:24.184] Local evaluation: TRUE
[17:45:24.184] Environment: R_GlobalEnv
[17:45:24.184] Capture standard output: TRUE
[17:45:24.184] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:24.184] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:24.184] Packages: 1 packages (‘future.apply’)
[17:45:24.184] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:24.184] Resolved: TRUE
[17:45:24.184] Value: <not collected>
[17:45:24.184] Conditions captured: <none>
[17:45:24.184] Early signaling: FALSE
[17:45:24.184] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:24.184] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.187] Chunk #2 of 2 ... DONE
[17:45:24.187] Launching 2 futures (chunks) ... DONE
[17:45:24.187] Resolving 2 futures (chunks) ...
[17:45:24.187] resolve() on list ...
[17:45:24.187]  recursive: 0
[17:45:24.187]  length: 2
[17:45:24.187] 
[17:45:24.188] receiveMessageFromWorker() for ClusterFuture ...
[17:45:24.188] - Validating connection of MultisessionFuture
[17:45:24.188] - received message: FutureResult
[17:45:24.188] - Received FutureResult
[17:45:24.188] - Erased future from FutureRegistry
[17:45:24.188] result() for ClusterFuture ...
[17:45:24.188] - result already collected: FutureResult
[17:45:24.188] result() for ClusterFuture ... done
[17:45:24.188] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:24.189] Future #1
[17:45:24.189] result() for ClusterFuture ...
[17:45:24.189] - result already collected: FutureResult
[17:45:24.189] result() for ClusterFuture ... done
[17:45:24.189] result() for ClusterFuture ...
[17:45:24.189] - result already collected: FutureResult
[17:45:24.189] result() for ClusterFuture ... done
[17:45:24.189] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:24.189] - nx: 2
[17:45:24.189] - relay: TRUE
[17:45:24.189] - stdout: TRUE
[17:45:24.189] - signal: TRUE
[17:45:24.190] - resignal: FALSE
[17:45:24.190] - force: TRUE
[17:45:24.190] - relayed: [n=2] FALSE, FALSE
[17:45:24.190] - queued futures: [n=2] FALSE, FALSE
[17:45:24.190]  - until=1
[17:45:24.190]  - relaying element #1
[17:45:24.190] result() for ClusterFuture ...
[17:45:24.190] - result already collected: FutureResult
[17:45:24.190] result() for ClusterFuture ... done
[17:45:24.190] result() for ClusterFuture ...
[17:45:24.190] - result already collected: FutureResult
[17:45:24.190] result() for ClusterFuture ... done
[17:45:24.191] result() for ClusterFuture ...
[17:45:24.191] - result already collected: FutureResult
[17:45:24.191] result() for ClusterFuture ... done
[17:45:24.191] result() for ClusterFuture ...
[17:45:24.191] - result already collected: FutureResult
[17:45:24.191] result() for ClusterFuture ... done
[17:45:24.191] - relayed: [n=2] TRUE, FALSE
[17:45:24.191] - queued futures: [n=2] TRUE, FALSE
[17:45:24.191] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:24.191]  length: 1 (resolved future 1)
[17:45:24.192] Future #2
[17:45:24.192] result() for ClusterFuture ...
[17:45:24.192] - result already collected: FutureResult
[17:45:24.192] result() for ClusterFuture ... done
[17:45:24.192] result() for ClusterFuture ...
[17:45:24.192] - result already collected: FutureResult
[17:45:24.192] result() for ClusterFuture ... done
[17:45:24.192] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:24.192] - nx: 2
[17:45:24.192] - relay: TRUE
[17:45:24.192] - stdout: TRUE
[17:45:24.192] - signal: TRUE
[17:45:24.193] - resignal: FALSE
[17:45:24.193] - force: TRUE
[17:45:24.193] - relayed: [n=2] TRUE, FALSE
[17:45:24.193] - queued futures: [n=2] TRUE, FALSE
[17:45:24.193]  - until=2
[17:45:24.193]  - relaying element #2
[17:45:24.193] result() for ClusterFuture ...
[17:45:24.193] - result already collected: FutureResult
[17:45:24.193] result() for ClusterFuture ... done
[17:45:24.193] result() for ClusterFuture ...
[17:45:24.193] - result already collected: FutureResult
[17:45:24.193] result() for ClusterFuture ... done
[17:45:24.194] result() for ClusterFuture ...
[17:45:24.194] - result already collected: FutureResult
[17:45:24.194] result() for ClusterFuture ... done
[17:45:24.194] result() for ClusterFuture ...
[17:45:24.194] - result already collected: FutureResult
[17:45:24.194] result() for ClusterFuture ... done
[17:45:24.194] - relayed: [n=2] TRUE, TRUE
[17:45:24.194] - queued futures: [n=2] TRUE, TRUE
[17:45:24.194] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:24.194]  length: 0 (resolved future 2)
[17:45:24.194] Relaying remaining futures
[17:45:24.194] signalConditionsASAP(NULL, pos=0) ...
[17:45:24.195] - nx: 2
[17:45:24.195] - relay: TRUE
[17:45:24.195] - stdout: TRUE
[17:45:24.195] - signal: TRUE
[17:45:24.195] - resignal: FALSE
[17:45:24.195] - force: TRUE
[17:45:24.195] - relayed: [n=2] TRUE, TRUE
[17:45:24.195] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:24.195] - relayed: [n=2] TRUE, TRUE
[17:45:24.195] - queued futures: [n=2] TRUE, TRUE
[17:45:24.195] signalConditionsASAP(NULL, pos=0) ... done
[17:45:24.195] resolve() on list ... DONE
[17:45:24.196] result() for ClusterFuture ...
[17:45:24.196] - result already collected: FutureResult
[17:45:24.196] result() for ClusterFuture ... done
[17:45:24.196] result() for ClusterFuture ...
[17:45:24.196] - result already collected: FutureResult
[17:45:24.196] result() for ClusterFuture ... done
[17:45:24.196] result() for ClusterFuture ...
[17:45:24.196] - result already collected: FutureResult
[17:45:24.196] result() for ClusterFuture ... done
[17:45:24.196] result() for ClusterFuture ...
[17:45:24.196] - result already collected: FutureResult
[17:45:24.196] result() for ClusterFuture ... done
[17:45:24.197]  - Number of value chunks collected: 2
[17:45:24.197] Resolving 2 futures (chunks) ... DONE
[17:45:24.197] Reducing values from 2 chunks ...
[17:45:24.197]  - Number of values collected after concatenation: 10
[17:45:24.197]  - Number of values expected: 10
[17:45:24.197] Reducing values from 2 chunks ... DONE
[17:45:24.197] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[17:45:24.199] future_lapply() ...
[17:45:24.205] Number of chunks: 2
[17:45:24.205] getGlobalsAndPackagesXApply() ...
[17:45:24.205]  - future.globals: TRUE
[17:45:24.205] getGlobalsAndPackages() ...
[17:45:24.205] Searching for globals...
[17:45:24.208] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[17:45:24.209] Searching for globals ... DONE
[17:45:24.209] Resolving globals: FALSE
[17:45:24.209] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[17:45:24.210] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:24.210] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:24.210] - packages: [2] ‘stats’, ‘future.apply’
[17:45:24.210] getGlobalsAndPackages() ... DONE
[17:45:24.210]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:24.210]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:45:24.210] Finding globals ... DONE
[17:45:24.211]  - use_args: TRUE
[17:45:24.211]  - Getting '...' globals ...
[17:45:24.211] resolve() on list ...
[17:45:24.211]  recursive: 0
[17:45:24.211]  length: 1
[17:45:24.211]  elements: ‘...’
[17:45:24.211]  length: 0 (resolved future 1)
[17:45:24.211] resolve() on list ... DONE
[17:45:24.212]    - '...' content: [n=0] 
[17:45:24.212] List of 1
[17:45:24.212]  $ ...: list()
[17:45:24.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:24.212]  - attr(*, "where")=List of 1
[17:45:24.212]   ..$ ...:<environment: 0x5561f75508c8> 
[17:45:24.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:24.212]  - attr(*, "resolved")= logi TRUE
[17:45:24.212]  - attr(*, "total_size")= num NA
[17:45:24.214]  - Getting '...' globals ... DONE
[17:45:24.214] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:24.214] List of 8
[17:45:24.214]  $ ...future.FUN:function (x, ...)  
[17:45:24.214]  $ x_FUN        :function (x, ...)  
[17:45:24.214]  $ times        : int 5
[17:45:24.214]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:24.214]  $ stop_if_not  :function (...)  
[17:45:24.214]  $ dim          : NULL
[17:45:24.214]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:24.214]  $ ...          : list()
[17:45:24.214]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:24.214]  - attr(*, "where")=List of 8
[17:45:24.214]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:24.214]   ..$ ...          :<environment: 0x5561f75508c8> 
[17:45:24.214]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:24.214]  - attr(*, "resolved")= logi FALSE
[17:45:24.214]  - attr(*, "total_size")= num 95528
[17:45:24.219] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:45:24.220] getGlobalsAndPackagesXApply() ... DONE
[17:45:24.220] Number of futures (= number of chunks): 2
[17:45:24.220] Launching 2 futures (chunks) ...
[17:45:24.220] Chunk #1 of 2 ...
[17:45:24.220]  - Finding globals in 'X' for chunk #1 ...
[17:45:24.220] getGlobalsAndPackages() ...
[17:45:24.220] Searching for globals...
[17:45:24.220] 
[17:45:24.221] Searching for globals ... DONE
[17:45:24.221] - globals: [0] <none>
[17:45:24.221] getGlobalsAndPackages() ... DONE
[17:45:24.221]    + additional globals found: [n=0] 
[17:45:24.221]    + additional namespaces needed: [n=0] 
[17:45:24.221]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:24.221]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:24.221]  - seeds: <none>
[17:45:24.221]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.221] getGlobalsAndPackages() ...
[17:45:24.221] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.222] Resolving globals: FALSE
[17:45:24.222] Tweak future expression to call with '...' arguments ...
[17:45:24.222] {
[17:45:24.222]     do.call(function(...) {
[17:45:24.222]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.222]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.222]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.222]             on.exit(options(oopts), add = TRUE)
[17:45:24.222]         }
[17:45:24.222]         {
[17:45:24.222]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.222]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.222]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.222]             })
[17:45:24.222]         }
[17:45:24.222]     }, args = future.call.arguments)
[17:45:24.222] }
[17:45:24.222] Tweak future expression to call with '...' arguments ... DONE
[17:45:24.223] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.223] - packages: [2] ‘stats’, ‘future.apply’
[17:45:24.223] getGlobalsAndPackages() ... DONE
[17:45:24.223] run() for ‘Future’ ...
[17:45:24.223] - state: ‘created’
[17:45:24.223] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:24.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:24.240]   - Field: ‘node’
[17:45:24.240]   - Field: ‘label’
[17:45:24.240]   - Field: ‘local’
[17:45:24.240]   - Field: ‘owner’
[17:45:24.240]   - Field: ‘envir’
[17:45:24.240]   - Field: ‘workers’
[17:45:24.240]   - Field: ‘packages’
[17:45:24.241]   - Field: ‘gc’
[17:45:24.241]   - Field: ‘conditions’
[17:45:24.241]   - Field: ‘persistent’
[17:45:24.241]   - Field: ‘expr’
[17:45:24.241]   - Field: ‘uuid’
[17:45:24.241]   - Field: ‘seed’
[17:45:24.241]   - Field: ‘version’
[17:45:24.241]   - Field: ‘result’
[17:45:24.241]   - Field: ‘asynchronous’
[17:45:24.241]   - Field: ‘calls’
[17:45:24.241]   - Field: ‘globals’
[17:45:24.242]   - Field: ‘stdout’
[17:45:24.242]   - Field: ‘earlySignal’
[17:45:24.242]   - Field: ‘lazy’
[17:45:24.242]   - Field: ‘state’
[17:45:24.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:24.242] - Launch lazy future ...
[17:45:24.242] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:24.242] Packages needed by future strategies (n = 0): <none>
[17:45:24.243] {
[17:45:24.243]     {
[17:45:24.243]         {
[17:45:24.243]             ...future.startTime <- base::Sys.time()
[17:45:24.243]             {
[17:45:24.243]                 {
[17:45:24.243]                   {
[17:45:24.243]                     {
[17:45:24.243]                       {
[17:45:24.243]                         base::local({
[17:45:24.243]                           has_future <- base::requireNamespace("future", 
[17:45:24.243]                             quietly = TRUE)
[17:45:24.243]                           if (has_future) {
[17:45:24.243]                             ns <- base::getNamespace("future")
[17:45:24.243]                             version <- ns[[".package"]][["version"]]
[17:45:24.243]                             if (is.null(version)) 
[17:45:24.243]                               version <- utils::packageVersion("future")
[17:45:24.243]                           }
[17:45:24.243]                           else {
[17:45:24.243]                             version <- NULL
[17:45:24.243]                           }
[17:45:24.243]                           if (!has_future || version < "1.8.0") {
[17:45:24.243]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:24.243]                               "", base::R.version$version.string), 
[17:45:24.243]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:24.243]                                 base::R.version$platform, 8 * 
[17:45:24.243]                                   base::.Machine$sizeof.pointer), 
[17:45:24.243]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:24.243]                                 "release", "version")], collapse = " "), 
[17:45:24.243]                               hostname = base::Sys.info()[["nodename"]])
[17:45:24.243]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:24.243]                               info)
[17:45:24.243]                             info <- base::paste(info, collapse = "; ")
[17:45:24.243]                             if (!has_future) {
[17:45:24.243]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:24.243]                                 info)
[17:45:24.243]                             }
[17:45:24.243]                             else {
[17:45:24.243]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:24.243]                                 info, version)
[17:45:24.243]                             }
[17:45:24.243]                             base::stop(msg)
[17:45:24.243]                           }
[17:45:24.243]                         })
[17:45:24.243]                       }
[17:45:24.243]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:24.243]                       base::options(mc.cores = 1L)
[17:45:24.243]                     }
[17:45:24.243]                     base::local({
[17:45:24.243]                       for (pkg in c("stats", "future.apply")) {
[17:45:24.243]                         base::loadNamespace(pkg)
[17:45:24.243]                         base::library(pkg, character.only = TRUE)
[17:45:24.243]                       }
[17:45:24.243]                     })
[17:45:24.243]                   }
[17:45:24.243]                   ...future.strategy.old <- future::plan("list")
[17:45:24.243]                   options(future.plan = NULL)
[17:45:24.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:24.243]                 }
[17:45:24.243]                 ...future.workdir <- getwd()
[17:45:24.243]             }
[17:45:24.243]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:24.243]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:24.243]         }
[17:45:24.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:24.243]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:24.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:24.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:24.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:24.243]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:24.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:24.243]             base::names(...future.oldOptions))
[17:45:24.243]     }
[17:45:24.243]     if (FALSE) {
[17:45:24.243]     }
[17:45:24.243]     else {
[17:45:24.243]         if (TRUE) {
[17:45:24.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:24.243]                 open = "w")
[17:45:24.243]         }
[17:45:24.243]         else {
[17:45:24.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:24.243]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:24.243]         }
[17:45:24.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:24.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:24.243]             base::sink(type = "output", split = FALSE)
[17:45:24.243]             base::close(...future.stdout)
[17:45:24.243]         }, add = TRUE)
[17:45:24.243]     }
[17:45:24.243]     ...future.frame <- base::sys.nframe()
[17:45:24.243]     ...future.conditions <- base::list()
[17:45:24.243]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:24.243]     if (FALSE) {
[17:45:24.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:24.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:24.243]     }
[17:45:24.243]     ...future.result <- base::tryCatch({
[17:45:24.243]         base::withCallingHandlers({
[17:45:24.243]             ...future.value <- base::withVisible(base::local({
[17:45:24.243]                 ...future.makeSendCondition <- base::local({
[17:45:24.243]                   sendCondition <- NULL
[17:45:24.243]                   function(frame = 1L) {
[17:45:24.243]                     if (is.function(sendCondition)) 
[17:45:24.243]                       return(sendCondition)
[17:45:24.243]                     ns <- getNamespace("parallel")
[17:45:24.243]                     if (exists("sendData", mode = "function", 
[17:45:24.243]                       envir = ns)) {
[17:45:24.243]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:24.243]                         envir = ns)
[17:45:24.243]                       envir <- sys.frame(frame)
[17:45:24.243]                       master <- NULL
[17:45:24.243]                       while (!identical(envir, .GlobalEnv) && 
[17:45:24.243]                         !identical(envir, emptyenv())) {
[17:45:24.243]                         if (exists("master", mode = "list", envir = envir, 
[17:45:24.243]                           inherits = FALSE)) {
[17:45:24.243]                           master <- get("master", mode = "list", 
[17:45:24.243]                             envir = envir, inherits = FALSE)
[17:45:24.243]                           if (inherits(master, c("SOCKnode", 
[17:45:24.243]                             "SOCK0node"))) {
[17:45:24.243]                             sendCondition <<- function(cond) {
[17:45:24.243]                               data <- list(type = "VALUE", value = cond, 
[17:45:24.243]                                 success = TRUE)
[17:45:24.243]                               parallel_sendData(master, data)
[17:45:24.243]                             }
[17:45:24.243]                             return(sendCondition)
[17:45:24.243]                           }
[17:45:24.243]                         }
[17:45:24.243]                         frame <- frame + 1L
[17:45:24.243]                         envir <- sys.frame(frame)
[17:45:24.243]                       }
[17:45:24.243]                     }
[17:45:24.243]                     sendCondition <<- function(cond) NULL
[17:45:24.243]                   }
[17:45:24.243]                 })
[17:45:24.243]                 withCallingHandlers({
[17:45:24.243]                   {
[17:45:24.243]                     do.call(function(...) {
[17:45:24.243]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.243]                       if (!identical(...future.globals.maxSize.org, 
[17:45:24.243]                         ...future.globals.maxSize)) {
[17:45:24.243]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.243]                         on.exit(options(oopts), add = TRUE)
[17:45:24.243]                       }
[17:45:24.243]                       {
[17:45:24.243]                         lapply(seq_along(...future.elements_ii), 
[17:45:24.243]                           FUN = function(jj) {
[17:45:24.243]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.243]                             ...future.FUN(...future.X_jj, ...)
[17:45:24.243]                           })
[17:45:24.243]                       }
[17:45:24.243]                     }, args = future.call.arguments)
[17:45:24.243]                   }
[17:45:24.243]                 }, immediateCondition = function(cond) {
[17:45:24.243]                   sendCondition <- ...future.makeSendCondition()
[17:45:24.243]                   sendCondition(cond)
[17:45:24.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.243]                   {
[17:45:24.243]                     inherits <- base::inherits
[17:45:24.243]                     invokeRestart <- base::invokeRestart
[17:45:24.243]                     is.null <- base::is.null
[17:45:24.243]                     muffled <- FALSE
[17:45:24.243]                     if (inherits(cond, "message")) {
[17:45:24.243]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:24.243]                       if (muffled) 
[17:45:24.243]                         invokeRestart("muffleMessage")
[17:45:24.243]                     }
[17:45:24.243]                     else if (inherits(cond, "warning")) {
[17:45:24.243]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:24.243]                       if (muffled) 
[17:45:24.243]                         invokeRestart("muffleWarning")
[17:45:24.243]                     }
[17:45:24.243]                     else if (inherits(cond, "condition")) {
[17:45:24.243]                       if (!is.null(pattern)) {
[17:45:24.243]                         computeRestarts <- base::computeRestarts
[17:45:24.243]                         grepl <- base::grepl
[17:45:24.243]                         restarts <- computeRestarts(cond)
[17:45:24.243]                         for (restart in restarts) {
[17:45:24.243]                           name <- restart$name
[17:45:24.243]                           if (is.null(name)) 
[17:45:24.243]                             next
[17:45:24.243]                           if (!grepl(pattern, name)) 
[17:45:24.243]                             next
[17:45:24.243]                           invokeRestart(restart)
[17:45:24.243]                           muffled <- TRUE
[17:45:24.243]                           break
[17:45:24.243]                         }
[17:45:24.243]                       }
[17:45:24.243]                     }
[17:45:24.243]                     invisible(muffled)
[17:45:24.243]                   }
[17:45:24.243]                   muffleCondition(cond)
[17:45:24.243]                 })
[17:45:24.243]             }))
[17:45:24.243]             future::FutureResult(value = ...future.value$value, 
[17:45:24.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.243]                   ...future.rng), globalenv = if (FALSE) 
[17:45:24.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:24.243]                     ...future.globalenv.names))
[17:45:24.243]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:24.243]         }, condition = base::local({
[17:45:24.243]             c <- base::c
[17:45:24.243]             inherits <- base::inherits
[17:45:24.243]             invokeRestart <- base::invokeRestart
[17:45:24.243]             length <- base::length
[17:45:24.243]             list <- base::list
[17:45:24.243]             seq.int <- base::seq.int
[17:45:24.243]             signalCondition <- base::signalCondition
[17:45:24.243]             sys.calls <- base::sys.calls
[17:45:24.243]             `[[` <- base::`[[`
[17:45:24.243]             `+` <- base::`+`
[17:45:24.243]             `<<-` <- base::`<<-`
[17:45:24.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:24.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:24.243]                   3L)]
[17:45:24.243]             }
[17:45:24.243]             function(cond) {
[17:45:24.243]                 is_error <- inherits(cond, "error")
[17:45:24.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:24.243]                   NULL)
[17:45:24.243]                 if (is_error) {
[17:45:24.243]                   sessionInformation <- function() {
[17:45:24.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:24.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:24.243]                       search = base::search(), system = base::Sys.info())
[17:45:24.243]                   }
[17:45:24.243]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:24.243]                     cond$call), session = sessionInformation(), 
[17:45:24.243]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:24.243]                   signalCondition(cond)
[17:45:24.243]                 }
[17:45:24.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:24.243]                 "immediateCondition"))) {
[17:45:24.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:24.243]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:24.243]                   if (TRUE && !signal) {
[17:45:24.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.243]                     {
[17:45:24.243]                       inherits <- base::inherits
[17:45:24.243]                       invokeRestart <- base::invokeRestart
[17:45:24.243]                       is.null <- base::is.null
[17:45:24.243]                       muffled <- FALSE
[17:45:24.243]                       if (inherits(cond, "message")) {
[17:45:24.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.243]                         if (muffled) 
[17:45:24.243]                           invokeRestart("muffleMessage")
[17:45:24.243]                       }
[17:45:24.243]                       else if (inherits(cond, "warning")) {
[17:45:24.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.243]                         if (muffled) 
[17:45:24.243]                           invokeRestart("muffleWarning")
[17:45:24.243]                       }
[17:45:24.243]                       else if (inherits(cond, "condition")) {
[17:45:24.243]                         if (!is.null(pattern)) {
[17:45:24.243]                           computeRestarts <- base::computeRestarts
[17:45:24.243]                           grepl <- base::grepl
[17:45:24.243]                           restarts <- computeRestarts(cond)
[17:45:24.243]                           for (restart in restarts) {
[17:45:24.243]                             name <- restart$name
[17:45:24.243]                             if (is.null(name)) 
[17:45:24.243]                               next
[17:45:24.243]                             if (!grepl(pattern, name)) 
[17:45:24.243]                               next
[17:45:24.243]                             invokeRestart(restart)
[17:45:24.243]                             muffled <- TRUE
[17:45:24.243]                             break
[17:45:24.243]                           }
[17:45:24.243]                         }
[17:45:24.243]                       }
[17:45:24.243]                       invisible(muffled)
[17:45:24.243]                     }
[17:45:24.243]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.243]                   }
[17:45:24.243]                 }
[17:45:24.243]                 else {
[17:45:24.243]                   if (TRUE) {
[17:45:24.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.243]                     {
[17:45:24.243]                       inherits <- base::inherits
[17:45:24.243]                       invokeRestart <- base::invokeRestart
[17:45:24.243]                       is.null <- base::is.null
[17:45:24.243]                       muffled <- FALSE
[17:45:24.243]                       if (inherits(cond, "message")) {
[17:45:24.243]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.243]                         if (muffled) 
[17:45:24.243]                           invokeRestart("muffleMessage")
[17:45:24.243]                       }
[17:45:24.243]                       else if (inherits(cond, "warning")) {
[17:45:24.243]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.243]                         if (muffled) 
[17:45:24.243]                           invokeRestart("muffleWarning")
[17:45:24.243]                       }
[17:45:24.243]                       else if (inherits(cond, "condition")) {
[17:45:24.243]                         if (!is.null(pattern)) {
[17:45:24.243]                           computeRestarts <- base::computeRestarts
[17:45:24.243]                           grepl <- base::grepl
[17:45:24.243]                           restarts <- computeRestarts(cond)
[17:45:24.243]                           for (restart in restarts) {
[17:45:24.243]                             name <- restart$name
[17:45:24.243]                             if (is.null(name)) 
[17:45:24.243]                               next
[17:45:24.243]                             if (!grepl(pattern, name)) 
[17:45:24.243]                               next
[17:45:24.243]                             invokeRestart(restart)
[17:45:24.243]                             muffled <- TRUE
[17:45:24.243]                             break
[17:45:24.243]                           }
[17:45:24.243]                         }
[17:45:24.243]                       }
[17:45:24.243]                       invisible(muffled)
[17:45:24.243]                     }
[17:45:24.243]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.243]                   }
[17:45:24.243]                 }
[17:45:24.243]             }
[17:45:24.243]         }))
[17:45:24.243]     }, error = function(ex) {
[17:45:24.243]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:24.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.243]                 ...future.rng), started = ...future.startTime, 
[17:45:24.243]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:24.243]             version = "1.8"), class = "FutureResult")
[17:45:24.243]     }, finally = {
[17:45:24.243]         if (!identical(...future.workdir, getwd())) 
[17:45:24.243]             setwd(...future.workdir)
[17:45:24.243]         {
[17:45:24.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:24.243]                 ...future.oldOptions$nwarnings <- NULL
[17:45:24.243]             }
[17:45:24.243]             base::options(...future.oldOptions)
[17:45:24.243]             if (.Platform$OS.type == "windows") {
[17:45:24.243]                 old_names <- names(...future.oldEnvVars)
[17:45:24.243]                 envs <- base::Sys.getenv()
[17:45:24.243]                 names <- names(envs)
[17:45:24.243]                 common <- intersect(names, old_names)
[17:45:24.243]                 added <- setdiff(names, old_names)
[17:45:24.243]                 removed <- setdiff(old_names, names)
[17:45:24.243]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:24.243]                   envs[common]]
[17:45:24.243]                 NAMES <- toupper(changed)
[17:45:24.243]                 args <- list()
[17:45:24.243]                 for (kk in seq_along(NAMES)) {
[17:45:24.243]                   name <- changed[[kk]]
[17:45:24.243]                   NAME <- NAMES[[kk]]
[17:45:24.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.243]                     next
[17:45:24.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.243]                 }
[17:45:24.243]                 NAMES <- toupper(added)
[17:45:24.243]                 for (kk in seq_along(NAMES)) {
[17:45:24.243]                   name <- added[[kk]]
[17:45:24.243]                   NAME <- NAMES[[kk]]
[17:45:24.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.243]                     next
[17:45:24.243]                   args[[name]] <- ""
[17:45:24.243]                 }
[17:45:24.243]                 NAMES <- toupper(removed)
[17:45:24.243]                 for (kk in seq_along(NAMES)) {
[17:45:24.243]                   name <- removed[[kk]]
[17:45:24.243]                   NAME <- NAMES[[kk]]
[17:45:24.243]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.243]                     next
[17:45:24.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.243]                 }
[17:45:24.243]                 if (length(args) > 0) 
[17:45:24.243]                   base::do.call(base::Sys.setenv, args = args)
[17:45:24.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:24.243]             }
[17:45:24.243]             else {
[17:45:24.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:24.243]             }
[17:45:24.243]             {
[17:45:24.243]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:24.243]                   0L) {
[17:45:24.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:24.243]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:24.243]                   base::options(opts)
[17:45:24.243]                 }
[17:45:24.243]                 {
[17:45:24.243]                   {
[17:45:24.243]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:24.243]                     NULL
[17:45:24.243]                   }
[17:45:24.243]                   options(future.plan = NULL)
[17:45:24.243]                   if (is.na(NA_character_)) 
[17:45:24.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:24.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:24.243]                     .init = FALSE)
[17:45:24.243]                 }
[17:45:24.243]             }
[17:45:24.243]         }
[17:45:24.243]     })
[17:45:24.243]     if (TRUE) {
[17:45:24.243]         base::sink(type = "output", split = FALSE)
[17:45:24.243]         if (TRUE) {
[17:45:24.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:24.243]         }
[17:45:24.243]         else {
[17:45:24.243]             ...future.result["stdout"] <- base::list(NULL)
[17:45:24.243]         }
[17:45:24.243]         base::close(...future.stdout)
[17:45:24.243]         ...future.stdout <- NULL
[17:45:24.243]     }
[17:45:24.243]     ...future.result$conditions <- ...future.conditions
[17:45:24.243]     ...future.result$finished <- base::Sys.time()
[17:45:24.243]     ...future.result
[17:45:24.243] }
[17:45:24.246] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[17:45:24.246] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:24.288] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:24.288] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[17:45:24.288] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:45:24.288] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:24.289] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:24.289] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:24.332] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:24.332] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:24.376] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:24.376] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:24.376] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.376] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:24.377] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:24.377] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:24.377] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.377] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[17:45:24.378] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[17:45:24.378] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:24.378] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.378] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:24.379] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.379] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[17:45:24.379] MultisessionFuture started
[17:45:24.380] - Launch lazy future ... done
[17:45:24.380] run() for ‘MultisessionFuture’ ... done
[17:45:24.380] Created future:
[17:45:24.383] receiveMessageFromWorker() for ClusterFuture ...
[17:45:24.383] - Validating connection of MultisessionFuture
[17:45:24.383] - received message: FutureResult
[17:45:24.383] - Received FutureResult
[17:45:24.384] - Erased future from FutureRegistry
[17:45:24.384] result() for ClusterFuture ...
[17:45:24.384] - result already collected: FutureResult
[17:45:24.384] result() for ClusterFuture ... done
[17:45:24.384] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:24.380] MultisessionFuture:
[17:45:24.380] Label: ‘future_vapply-1’
[17:45:24.380] Expression:
[17:45:24.380] {
[17:45:24.380]     do.call(function(...) {
[17:45:24.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.380]             on.exit(options(oopts), add = TRUE)
[17:45:24.380]         }
[17:45:24.380]         {
[17:45:24.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.380]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.380]             })
[17:45:24.380]         }
[17:45:24.380]     }, args = future.call.arguments)
[17:45:24.380] }
[17:45:24.380] Lazy evaluation: FALSE
[17:45:24.380] Asynchronous evaluation: TRUE
[17:45:24.380] Local evaluation: TRUE
[17:45:24.380] Environment: R_GlobalEnv
[17:45:24.380] Capture standard output: TRUE
[17:45:24.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:24.380] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:24.380] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:24.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:24.380] Resolved: TRUE
[17:45:24.380] Value: <not collected>
[17:45:24.380] Conditions captured: <none>
[17:45:24.380] Early signaling: FALSE
[17:45:24.380] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:24.380] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.384] Chunk #1 of 2 ... DONE
[17:45:24.384] Chunk #2 of 2 ...
[17:45:24.384]  - Finding globals in 'X' for chunk #2 ...
[17:45:24.385] getGlobalsAndPackages() ...
[17:45:24.385] Searching for globals...
[17:45:24.385] 
[17:45:24.385] Searching for globals ... DONE
[17:45:24.385] - globals: [0] <none>
[17:45:24.385] getGlobalsAndPackages() ... DONE
[17:45:24.385]    + additional globals found: [n=0] 
[17:45:24.385]    + additional namespaces needed: [n=0] 
[17:45:24.385]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:24.386]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:24.386]  - seeds: <none>
[17:45:24.386]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.386] getGlobalsAndPackages() ...
[17:45:24.386] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.386] Resolving globals: FALSE
[17:45:24.386] Tweak future expression to call with '...' arguments ...
[17:45:24.386] {
[17:45:24.386]     do.call(function(...) {
[17:45:24.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.386]             on.exit(options(oopts), add = TRUE)
[17:45:24.386]         }
[17:45:24.386]         {
[17:45:24.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.386]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.386]             })
[17:45:24.386]         }
[17:45:24.386]     }, args = future.call.arguments)
[17:45:24.386] }
[17:45:24.387] Tweak future expression to call with '...' arguments ... DONE
[17:45:24.387] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.387] - packages: [2] ‘stats’, ‘future.apply’
[17:45:24.387] getGlobalsAndPackages() ... DONE
[17:45:24.388] run() for ‘Future’ ...
[17:45:24.388] - state: ‘created’
[17:45:24.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:24.405] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.405] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:24.405]   - Field: ‘node’
[17:45:24.405]   - Field: ‘label’
[17:45:24.405]   - Field: ‘local’
[17:45:24.405]   - Field: ‘owner’
[17:45:24.405]   - Field: ‘envir’
[17:45:24.405]   - Field: ‘workers’
[17:45:24.405]   - Field: ‘packages’
[17:45:24.406]   - Field: ‘gc’
[17:45:24.406]   - Field: ‘conditions’
[17:45:24.406]   - Field: ‘persistent’
[17:45:24.406]   - Field: ‘expr’
[17:45:24.406]   - Field: ‘uuid’
[17:45:24.406]   - Field: ‘seed’
[17:45:24.406]   - Field: ‘version’
[17:45:24.406]   - Field: ‘result’
[17:45:24.406]   - Field: ‘asynchronous’
[17:45:24.406]   - Field: ‘calls’
[17:45:24.406]   - Field: ‘globals’
[17:45:24.407]   - Field: ‘stdout’
[17:45:24.407]   - Field: ‘earlySignal’
[17:45:24.407]   - Field: ‘lazy’
[17:45:24.407]   - Field: ‘state’
[17:45:24.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:24.407] - Launch lazy future ...
[17:45:24.407] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:24.407] Packages needed by future strategies (n = 0): <none>
[17:45:24.408] {
[17:45:24.408]     {
[17:45:24.408]         {
[17:45:24.408]             ...future.startTime <- base::Sys.time()
[17:45:24.408]             {
[17:45:24.408]                 {
[17:45:24.408]                   {
[17:45:24.408]                     {
[17:45:24.408]                       {
[17:45:24.408]                         base::local({
[17:45:24.408]                           has_future <- base::requireNamespace("future", 
[17:45:24.408]                             quietly = TRUE)
[17:45:24.408]                           if (has_future) {
[17:45:24.408]                             ns <- base::getNamespace("future")
[17:45:24.408]                             version <- ns[[".package"]][["version"]]
[17:45:24.408]                             if (is.null(version)) 
[17:45:24.408]                               version <- utils::packageVersion("future")
[17:45:24.408]                           }
[17:45:24.408]                           else {
[17:45:24.408]                             version <- NULL
[17:45:24.408]                           }
[17:45:24.408]                           if (!has_future || version < "1.8.0") {
[17:45:24.408]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:24.408]                               "", base::R.version$version.string), 
[17:45:24.408]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:24.408]                                 base::R.version$platform, 8 * 
[17:45:24.408]                                   base::.Machine$sizeof.pointer), 
[17:45:24.408]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:24.408]                                 "release", "version")], collapse = " "), 
[17:45:24.408]                               hostname = base::Sys.info()[["nodename"]])
[17:45:24.408]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:24.408]                               info)
[17:45:24.408]                             info <- base::paste(info, collapse = "; ")
[17:45:24.408]                             if (!has_future) {
[17:45:24.408]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:24.408]                                 info)
[17:45:24.408]                             }
[17:45:24.408]                             else {
[17:45:24.408]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:24.408]                                 info, version)
[17:45:24.408]                             }
[17:45:24.408]                             base::stop(msg)
[17:45:24.408]                           }
[17:45:24.408]                         })
[17:45:24.408]                       }
[17:45:24.408]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:24.408]                       base::options(mc.cores = 1L)
[17:45:24.408]                     }
[17:45:24.408]                     base::local({
[17:45:24.408]                       for (pkg in c("stats", "future.apply")) {
[17:45:24.408]                         base::loadNamespace(pkg)
[17:45:24.408]                         base::library(pkg, character.only = TRUE)
[17:45:24.408]                       }
[17:45:24.408]                     })
[17:45:24.408]                   }
[17:45:24.408]                   ...future.strategy.old <- future::plan("list")
[17:45:24.408]                   options(future.plan = NULL)
[17:45:24.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:24.408]                 }
[17:45:24.408]                 ...future.workdir <- getwd()
[17:45:24.408]             }
[17:45:24.408]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:24.408]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:24.408]         }
[17:45:24.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:24.408]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:24.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:24.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:24.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:24.408]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:24.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:24.408]             base::names(...future.oldOptions))
[17:45:24.408]     }
[17:45:24.408]     if (FALSE) {
[17:45:24.408]     }
[17:45:24.408]     else {
[17:45:24.408]         if (TRUE) {
[17:45:24.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:24.408]                 open = "w")
[17:45:24.408]         }
[17:45:24.408]         else {
[17:45:24.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:24.408]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:24.408]         }
[17:45:24.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:24.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:24.408]             base::sink(type = "output", split = FALSE)
[17:45:24.408]             base::close(...future.stdout)
[17:45:24.408]         }, add = TRUE)
[17:45:24.408]     }
[17:45:24.408]     ...future.frame <- base::sys.nframe()
[17:45:24.408]     ...future.conditions <- base::list()
[17:45:24.408]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:24.408]     if (FALSE) {
[17:45:24.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:24.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:24.408]     }
[17:45:24.408]     ...future.result <- base::tryCatch({
[17:45:24.408]         base::withCallingHandlers({
[17:45:24.408]             ...future.value <- base::withVisible(base::local({
[17:45:24.408]                 ...future.makeSendCondition <- base::local({
[17:45:24.408]                   sendCondition <- NULL
[17:45:24.408]                   function(frame = 1L) {
[17:45:24.408]                     if (is.function(sendCondition)) 
[17:45:24.408]                       return(sendCondition)
[17:45:24.408]                     ns <- getNamespace("parallel")
[17:45:24.408]                     if (exists("sendData", mode = "function", 
[17:45:24.408]                       envir = ns)) {
[17:45:24.408]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:24.408]                         envir = ns)
[17:45:24.408]                       envir <- sys.frame(frame)
[17:45:24.408]                       master <- NULL
[17:45:24.408]                       while (!identical(envir, .GlobalEnv) && 
[17:45:24.408]                         !identical(envir, emptyenv())) {
[17:45:24.408]                         if (exists("master", mode = "list", envir = envir, 
[17:45:24.408]                           inherits = FALSE)) {
[17:45:24.408]                           master <- get("master", mode = "list", 
[17:45:24.408]                             envir = envir, inherits = FALSE)
[17:45:24.408]                           if (inherits(master, c("SOCKnode", 
[17:45:24.408]                             "SOCK0node"))) {
[17:45:24.408]                             sendCondition <<- function(cond) {
[17:45:24.408]                               data <- list(type = "VALUE", value = cond, 
[17:45:24.408]                                 success = TRUE)
[17:45:24.408]                               parallel_sendData(master, data)
[17:45:24.408]                             }
[17:45:24.408]                             return(sendCondition)
[17:45:24.408]                           }
[17:45:24.408]                         }
[17:45:24.408]                         frame <- frame + 1L
[17:45:24.408]                         envir <- sys.frame(frame)
[17:45:24.408]                       }
[17:45:24.408]                     }
[17:45:24.408]                     sendCondition <<- function(cond) NULL
[17:45:24.408]                   }
[17:45:24.408]                 })
[17:45:24.408]                 withCallingHandlers({
[17:45:24.408]                   {
[17:45:24.408]                     do.call(function(...) {
[17:45:24.408]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.408]                       if (!identical(...future.globals.maxSize.org, 
[17:45:24.408]                         ...future.globals.maxSize)) {
[17:45:24.408]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.408]                         on.exit(options(oopts), add = TRUE)
[17:45:24.408]                       }
[17:45:24.408]                       {
[17:45:24.408]                         lapply(seq_along(...future.elements_ii), 
[17:45:24.408]                           FUN = function(jj) {
[17:45:24.408]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.408]                             ...future.FUN(...future.X_jj, ...)
[17:45:24.408]                           })
[17:45:24.408]                       }
[17:45:24.408]                     }, args = future.call.arguments)
[17:45:24.408]                   }
[17:45:24.408]                 }, immediateCondition = function(cond) {
[17:45:24.408]                   sendCondition <- ...future.makeSendCondition()
[17:45:24.408]                   sendCondition(cond)
[17:45:24.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.408]                   {
[17:45:24.408]                     inherits <- base::inherits
[17:45:24.408]                     invokeRestart <- base::invokeRestart
[17:45:24.408]                     is.null <- base::is.null
[17:45:24.408]                     muffled <- FALSE
[17:45:24.408]                     if (inherits(cond, "message")) {
[17:45:24.408]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:24.408]                       if (muffled) 
[17:45:24.408]                         invokeRestart("muffleMessage")
[17:45:24.408]                     }
[17:45:24.408]                     else if (inherits(cond, "warning")) {
[17:45:24.408]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:24.408]                       if (muffled) 
[17:45:24.408]                         invokeRestart("muffleWarning")
[17:45:24.408]                     }
[17:45:24.408]                     else if (inherits(cond, "condition")) {
[17:45:24.408]                       if (!is.null(pattern)) {
[17:45:24.408]                         computeRestarts <- base::computeRestarts
[17:45:24.408]                         grepl <- base::grepl
[17:45:24.408]                         restarts <- computeRestarts(cond)
[17:45:24.408]                         for (restart in restarts) {
[17:45:24.408]                           name <- restart$name
[17:45:24.408]                           if (is.null(name)) 
[17:45:24.408]                             next
[17:45:24.408]                           if (!grepl(pattern, name)) 
[17:45:24.408]                             next
[17:45:24.408]                           invokeRestart(restart)
[17:45:24.408]                           muffled <- TRUE
[17:45:24.408]                           break
[17:45:24.408]                         }
[17:45:24.408]                       }
[17:45:24.408]                     }
[17:45:24.408]                     invisible(muffled)
[17:45:24.408]                   }
[17:45:24.408]                   muffleCondition(cond)
[17:45:24.408]                 })
[17:45:24.408]             }))
[17:45:24.408]             future::FutureResult(value = ...future.value$value, 
[17:45:24.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.408]                   ...future.rng), globalenv = if (FALSE) 
[17:45:24.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:24.408]                     ...future.globalenv.names))
[17:45:24.408]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:24.408]         }, condition = base::local({
[17:45:24.408]             c <- base::c
[17:45:24.408]             inherits <- base::inherits
[17:45:24.408]             invokeRestart <- base::invokeRestart
[17:45:24.408]             length <- base::length
[17:45:24.408]             list <- base::list
[17:45:24.408]             seq.int <- base::seq.int
[17:45:24.408]             signalCondition <- base::signalCondition
[17:45:24.408]             sys.calls <- base::sys.calls
[17:45:24.408]             `[[` <- base::`[[`
[17:45:24.408]             `+` <- base::`+`
[17:45:24.408]             `<<-` <- base::`<<-`
[17:45:24.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:24.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:24.408]                   3L)]
[17:45:24.408]             }
[17:45:24.408]             function(cond) {
[17:45:24.408]                 is_error <- inherits(cond, "error")
[17:45:24.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:24.408]                   NULL)
[17:45:24.408]                 if (is_error) {
[17:45:24.408]                   sessionInformation <- function() {
[17:45:24.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:24.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:24.408]                       search = base::search(), system = base::Sys.info())
[17:45:24.408]                   }
[17:45:24.408]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:24.408]                     cond$call), session = sessionInformation(), 
[17:45:24.408]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:24.408]                   signalCondition(cond)
[17:45:24.408]                 }
[17:45:24.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:24.408]                 "immediateCondition"))) {
[17:45:24.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:24.408]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:24.408]                   if (TRUE && !signal) {
[17:45:24.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.408]                     {
[17:45:24.408]                       inherits <- base::inherits
[17:45:24.408]                       invokeRestart <- base::invokeRestart
[17:45:24.408]                       is.null <- base::is.null
[17:45:24.408]                       muffled <- FALSE
[17:45:24.408]                       if (inherits(cond, "message")) {
[17:45:24.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.408]                         if (muffled) 
[17:45:24.408]                           invokeRestart("muffleMessage")
[17:45:24.408]                       }
[17:45:24.408]                       else if (inherits(cond, "warning")) {
[17:45:24.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.408]                         if (muffled) 
[17:45:24.408]                           invokeRestart("muffleWarning")
[17:45:24.408]                       }
[17:45:24.408]                       else if (inherits(cond, "condition")) {
[17:45:24.408]                         if (!is.null(pattern)) {
[17:45:24.408]                           computeRestarts <- base::computeRestarts
[17:45:24.408]                           grepl <- base::grepl
[17:45:24.408]                           restarts <- computeRestarts(cond)
[17:45:24.408]                           for (restart in restarts) {
[17:45:24.408]                             name <- restart$name
[17:45:24.408]                             if (is.null(name)) 
[17:45:24.408]                               next
[17:45:24.408]                             if (!grepl(pattern, name)) 
[17:45:24.408]                               next
[17:45:24.408]                             invokeRestart(restart)
[17:45:24.408]                             muffled <- TRUE
[17:45:24.408]                             break
[17:45:24.408]                           }
[17:45:24.408]                         }
[17:45:24.408]                       }
[17:45:24.408]                       invisible(muffled)
[17:45:24.408]                     }
[17:45:24.408]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.408]                   }
[17:45:24.408]                 }
[17:45:24.408]                 else {
[17:45:24.408]                   if (TRUE) {
[17:45:24.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.408]                     {
[17:45:24.408]                       inherits <- base::inherits
[17:45:24.408]                       invokeRestart <- base::invokeRestart
[17:45:24.408]                       is.null <- base::is.null
[17:45:24.408]                       muffled <- FALSE
[17:45:24.408]                       if (inherits(cond, "message")) {
[17:45:24.408]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.408]                         if (muffled) 
[17:45:24.408]                           invokeRestart("muffleMessage")
[17:45:24.408]                       }
[17:45:24.408]                       else if (inherits(cond, "warning")) {
[17:45:24.408]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.408]                         if (muffled) 
[17:45:24.408]                           invokeRestart("muffleWarning")
[17:45:24.408]                       }
[17:45:24.408]                       else if (inherits(cond, "condition")) {
[17:45:24.408]                         if (!is.null(pattern)) {
[17:45:24.408]                           computeRestarts <- base::computeRestarts
[17:45:24.408]                           grepl <- base::grepl
[17:45:24.408]                           restarts <- computeRestarts(cond)
[17:45:24.408]                           for (restart in restarts) {
[17:45:24.408]                             name <- restart$name
[17:45:24.408]                             if (is.null(name)) 
[17:45:24.408]                               next
[17:45:24.408]                             if (!grepl(pattern, name)) 
[17:45:24.408]                               next
[17:45:24.408]                             invokeRestart(restart)
[17:45:24.408]                             muffled <- TRUE
[17:45:24.408]                             break
[17:45:24.408]                           }
[17:45:24.408]                         }
[17:45:24.408]                       }
[17:45:24.408]                       invisible(muffled)
[17:45:24.408]                     }
[17:45:24.408]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.408]                   }
[17:45:24.408]                 }
[17:45:24.408]             }
[17:45:24.408]         }))
[17:45:24.408]     }, error = function(ex) {
[17:45:24.408]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:24.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.408]                 ...future.rng), started = ...future.startTime, 
[17:45:24.408]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:24.408]             version = "1.8"), class = "FutureResult")
[17:45:24.408]     }, finally = {
[17:45:24.408]         if (!identical(...future.workdir, getwd())) 
[17:45:24.408]             setwd(...future.workdir)
[17:45:24.408]         {
[17:45:24.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:24.408]                 ...future.oldOptions$nwarnings <- NULL
[17:45:24.408]             }
[17:45:24.408]             base::options(...future.oldOptions)
[17:45:24.408]             if (.Platform$OS.type == "windows") {
[17:45:24.408]                 old_names <- names(...future.oldEnvVars)
[17:45:24.408]                 envs <- base::Sys.getenv()
[17:45:24.408]                 names <- names(envs)
[17:45:24.408]                 common <- intersect(names, old_names)
[17:45:24.408]                 added <- setdiff(names, old_names)
[17:45:24.408]                 removed <- setdiff(old_names, names)
[17:45:24.408]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:24.408]                   envs[common]]
[17:45:24.408]                 NAMES <- toupper(changed)
[17:45:24.408]                 args <- list()
[17:45:24.408]                 for (kk in seq_along(NAMES)) {
[17:45:24.408]                   name <- changed[[kk]]
[17:45:24.408]                   NAME <- NAMES[[kk]]
[17:45:24.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.408]                     next
[17:45:24.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.408]                 }
[17:45:24.408]                 NAMES <- toupper(added)
[17:45:24.408]                 for (kk in seq_along(NAMES)) {
[17:45:24.408]                   name <- added[[kk]]
[17:45:24.408]                   NAME <- NAMES[[kk]]
[17:45:24.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.408]                     next
[17:45:24.408]                   args[[name]] <- ""
[17:45:24.408]                 }
[17:45:24.408]                 NAMES <- toupper(removed)
[17:45:24.408]                 for (kk in seq_along(NAMES)) {
[17:45:24.408]                   name <- removed[[kk]]
[17:45:24.408]                   NAME <- NAMES[[kk]]
[17:45:24.408]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.408]                     next
[17:45:24.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.408]                 }
[17:45:24.408]                 if (length(args) > 0) 
[17:45:24.408]                   base::do.call(base::Sys.setenv, args = args)
[17:45:24.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:24.408]             }
[17:45:24.408]             else {
[17:45:24.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:24.408]             }
[17:45:24.408]             {
[17:45:24.408]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:24.408]                   0L) {
[17:45:24.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:24.408]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:24.408]                   base::options(opts)
[17:45:24.408]                 }
[17:45:24.408]                 {
[17:45:24.408]                   {
[17:45:24.408]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:24.408]                     NULL
[17:45:24.408]                   }
[17:45:24.408]                   options(future.plan = NULL)
[17:45:24.408]                   if (is.na(NA_character_)) 
[17:45:24.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:24.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:24.408]                     .init = FALSE)
[17:45:24.408]                 }
[17:45:24.408]             }
[17:45:24.408]         }
[17:45:24.408]     })
[17:45:24.408]     if (TRUE) {
[17:45:24.408]         base::sink(type = "output", split = FALSE)
[17:45:24.408]         if (TRUE) {
[17:45:24.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:24.408]         }
[17:45:24.408]         else {
[17:45:24.408]             ...future.result["stdout"] <- base::list(NULL)
[17:45:24.408]         }
[17:45:24.408]         base::close(...future.stdout)
[17:45:24.408]         ...future.stdout <- NULL
[17:45:24.408]     }
[17:45:24.408]     ...future.result$conditions <- ...future.conditions
[17:45:24.408]     ...future.result$finished <- base::Sys.time()
[17:45:24.408]     ...future.result
[17:45:24.408] }
[17:45:24.411] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[17:45:24.411] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:24.452] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:24.452] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[17:45:24.452] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[17:45:24.452] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:24.453] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:24.453] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:24.496] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:24.496] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:24.540] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:24.540] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:24.540] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.540] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:24.541] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:24.541] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:24.541] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.542] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ...
[17:45:24.542] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ... DONE
[17:45:24.542] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:24.543] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:24.543] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.543] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[17:45:24.544] MultisessionFuture started
[17:45:24.544] - Launch lazy future ... done
[17:45:24.544] run() for ‘MultisessionFuture’ ... done
[17:45:24.544] Created future:
[17:45:24.544] MultisessionFuture:
[17:45:24.544] Label: ‘future_vapply-2’
[17:45:24.544] Expression:
[17:45:24.544] {
[17:45:24.544]     do.call(function(...) {
[17:45:24.544]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.544]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.544]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.544]             on.exit(options(oopts), add = TRUE)
[17:45:24.544]         }
[17:45:24.544]         {
[17:45:24.544]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.544]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.544]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.544]             })
[17:45:24.544]         }
[17:45:24.544]     }, args = future.call.arguments)
[17:45:24.544] }
[17:45:24.544] Lazy evaluation: FALSE
[17:45:24.544] Asynchronous evaluation: TRUE
[17:45:24.544] Local evaluation: TRUE
[17:45:24.544] Environment: R_GlobalEnv
[17:45:24.544] Capture standard output: TRUE
[17:45:24.544] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:24.544] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:24.544] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:24.544] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:24.544] Resolved: FALSE
[17:45:24.544] Value: <not collected>
[17:45:24.544] Conditions captured: <none>
[17:45:24.544] Early signaling: FALSE
[17:45:24.544] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:24.544] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.556] Chunk #2 of 2 ... DONE
[17:45:24.556] Launching 2 futures (chunks) ... DONE
[17:45:24.556] Resolving 2 futures (chunks) ...
[17:45:24.556] resolve() on list ...
[17:45:24.556]  recursive: 0
[17:45:24.557]  length: 2
[17:45:24.557] 
[17:45:24.557] Future #1
[17:45:24.557] result() for ClusterFuture ...
[17:45:24.557] - result already collected: FutureResult
[17:45:24.557] result() for ClusterFuture ... done
[17:45:24.557] result() for ClusterFuture ...
[17:45:24.557] - result already collected: FutureResult
[17:45:24.557] result() for ClusterFuture ... done
[17:45:24.557] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:24.557] - nx: 2
[17:45:24.558] - relay: TRUE
[17:45:24.558] - stdout: TRUE
[17:45:24.558] - signal: TRUE
[17:45:24.558] - resignal: FALSE
[17:45:24.558] - force: TRUE
[17:45:24.558] - relayed: [n=2] FALSE, FALSE
[17:45:24.558] - queued futures: [n=2] FALSE, FALSE
[17:45:24.558]  - until=1
[17:45:24.558]  - relaying element #1
[17:45:24.558] result() for ClusterFuture ...
[17:45:24.558] - result already collected: FutureResult
[17:45:24.559] result() for ClusterFuture ... done
[17:45:24.559] result() for ClusterFuture ...
[17:45:24.559] - result already collected: FutureResult
[17:45:24.559] result() for ClusterFuture ... done
[17:45:24.559] result() for ClusterFuture ...
[17:45:24.559] - result already collected: FutureResult
[17:45:24.559] result() for ClusterFuture ... done
[17:45:24.559] result() for ClusterFuture ...
[17:45:24.559] - result already collected: FutureResult
[17:45:24.559] result() for ClusterFuture ... done
[17:45:24.559] - relayed: [n=2] TRUE, FALSE
[17:45:24.560] - queued futures: [n=2] TRUE, FALSE
[17:45:24.560] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:24.560]  length: 1 (resolved future 1)
[17:45:24.590] receiveMessageFromWorker() for ClusterFuture ...
[17:45:24.590] - Validating connection of MultisessionFuture
[17:45:24.590] - received message: FutureResult
[17:45:24.590] - Received FutureResult
[17:45:24.590] - Erased future from FutureRegistry
[17:45:24.590] result() for ClusterFuture ...
[17:45:24.590] - result already collected: FutureResult
[17:45:24.590] result() for ClusterFuture ... done
[17:45:24.590] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:24.591] Future #2
[17:45:24.591] result() for ClusterFuture ...
[17:45:24.591] - result already collected: FutureResult
[17:45:24.591] result() for ClusterFuture ... done
[17:45:24.591] result() for ClusterFuture ...
[17:45:24.591] - result already collected: FutureResult
[17:45:24.591] result() for ClusterFuture ... done
[17:45:24.591] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:24.591] - nx: 2
[17:45:24.591] - relay: TRUE
[17:45:24.591] - stdout: TRUE
[17:45:24.592] - signal: TRUE
[17:45:24.592] - resignal: FALSE
[17:45:24.592] - force: TRUE
[17:45:24.592] - relayed: [n=2] TRUE, FALSE
[17:45:24.592] - queued futures: [n=2] TRUE, FALSE
[17:45:24.592]  - until=2
[17:45:24.592]  - relaying element #2
[17:45:24.592] result() for ClusterFuture ...
[17:45:24.592] - result already collected: FutureResult
[17:45:24.592] result() for ClusterFuture ... done
[17:45:24.592] result() for ClusterFuture ...
[17:45:24.592] - result already collected: FutureResult
[17:45:24.593] result() for ClusterFuture ... done
[17:45:24.593] result() for ClusterFuture ...
[17:45:24.593] - result already collected: FutureResult
[17:45:24.593] result() for ClusterFuture ... done
[17:45:24.593] result() for ClusterFuture ...
[17:45:24.593] - result already collected: FutureResult
[17:45:24.593] result() for ClusterFuture ... done
[17:45:24.593] - relayed: [n=2] TRUE, TRUE
[17:45:24.593] - queued futures: [n=2] TRUE, TRUE
[17:45:24.593] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:24.593]  length: 0 (resolved future 2)
[17:45:24.594] Relaying remaining futures
[17:45:24.594] signalConditionsASAP(NULL, pos=0) ...
[17:45:24.594] - nx: 2
[17:45:24.594] - relay: TRUE
[17:45:24.594] - stdout: TRUE
[17:45:24.594] - signal: TRUE
[17:45:24.594] - resignal: FALSE
[17:45:24.594] - force: TRUE
[17:45:24.594] - relayed: [n=2] TRUE, TRUE
[17:45:24.594] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:24.594] - relayed: [n=2] TRUE, TRUE
[17:45:24.594] - queued futures: [n=2] TRUE, TRUE
[17:45:24.595] signalConditionsASAP(NULL, pos=0) ... done
[17:45:24.595] resolve() on list ... DONE
[17:45:24.595] result() for ClusterFuture ...
[17:45:24.595] - result already collected: FutureResult
[17:45:24.595] result() for ClusterFuture ... done
[17:45:24.595] result() for ClusterFuture ...
[17:45:24.595] - result already collected: FutureResult
[17:45:24.595] result() for ClusterFuture ... done
[17:45:24.595] result() for ClusterFuture ...
[17:45:24.595] - result already collected: FutureResult
[17:45:24.595] result() for ClusterFuture ... done
[17:45:24.596] result() for ClusterFuture ...
[17:45:24.596] - result already collected: FutureResult
[17:45:24.596] result() for ClusterFuture ... done
[17:45:24.596]  - Number of value chunks collected: 2
[17:45:24.596] Resolving 2 futures (chunks) ... DONE
[17:45:24.596] Reducing values from 2 chunks ...
[17:45:24.596]  - Number of values collected after concatenation: 3
[17:45:24.596]  - Number of values expected: 3
[17:45:24.596] Reducing values from 2 chunks ... DONE
[17:45:24.596] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[17:45:24.598] future_lapply() ...
[17:45:24.605] Number of chunks: 2
[17:45:24.605] getGlobalsAndPackagesXApply() ...
[17:45:24.606]  - future.globals: TRUE
[17:45:24.606] getGlobalsAndPackages() ...
[17:45:24.606] Searching for globals...
[17:45:24.610] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:45:24.611] Searching for globals ... DONE
[17:45:24.611] Resolving globals: FALSE
[17:45:24.611] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[17:45:24.612] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[17:45:24.612] - globals: [1] ‘FUN’
[17:45:24.612] - packages: [1] ‘stats’
[17:45:24.612] getGlobalsAndPackages() ... DONE
[17:45:24.612]  - globals found/used: [n=1] ‘FUN’
[17:45:24.612]  - needed namespaces: [n=1] ‘stats’
[17:45:24.612] Finding globals ... DONE
[17:45:24.613]  - use_args: TRUE
[17:45:24.613]  - Getting '...' globals ...
[17:45:24.613] resolve() on list ...
[17:45:24.613]  recursive: 0
[17:45:24.613]  length: 1
[17:45:24.613]  elements: ‘...’
[17:45:24.613]  length: 0 (resolved future 1)
[17:45:24.613] resolve() on list ... DONE
[17:45:24.614]    - '...' content: [n=0] 
[17:45:24.614] List of 1
[17:45:24.614]  $ ...: list()
[17:45:24.614]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:24.614]  - attr(*, "where")=List of 1
[17:45:24.614]   ..$ ...:<environment: 0x5561f6e7afa0> 
[17:45:24.614]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:24.614]  - attr(*, "resolved")= logi TRUE
[17:45:24.614]  - attr(*, "total_size")= num NA
[17:45:24.616]  - Getting '...' globals ... DONE
[17:45:24.616] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:24.617] List of 2
[17:45:24.617]  $ ...future.FUN:function (x, na.rm = TRUE)  
[17:45:24.617]  $ ...          : list()
[17:45:24.617]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:24.617]  - attr(*, "where")=List of 2
[17:45:24.617]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:24.617]   ..$ ...          :<environment: 0x5561f6e7afa0> 
[17:45:24.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:24.617]  - attr(*, "resolved")= logi FALSE
[17:45:24.617]  - attr(*, "total_size")= num 46960
[17:45:24.619] Packages to be attached in all futures: [n=1] ‘stats’
[17:45:24.619] getGlobalsAndPackagesXApply() ... DONE
[17:45:24.619] Number of futures (= number of chunks): 2
[17:45:24.620] Launching 2 futures (chunks) ...
[17:45:24.620] Chunk #1 of 2 ...
[17:45:24.620]  - Finding globals in 'X' for chunk #1 ...
[17:45:24.620] getGlobalsAndPackages() ...
[17:45:24.620] Searching for globals...
[17:45:24.620] 
[17:45:24.620] Searching for globals ... DONE
[17:45:24.620] - globals: [0] <none>
[17:45:24.620] getGlobalsAndPackages() ... DONE
[17:45:24.620]    + additional globals found: [n=0] 
[17:45:24.621]    + additional namespaces needed: [n=0] 
[17:45:24.621]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:24.621]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:24.621]  - seeds: <none>
[17:45:24.621]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.621] getGlobalsAndPackages() ...
[17:45:24.621] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.621] Resolving globals: FALSE
[17:45:24.621] Tweak future expression to call with '...' arguments ...
[17:45:24.621] {
[17:45:24.621]     do.call(function(...) {
[17:45:24.621]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.621]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.621]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.621]             on.exit(options(oopts), add = TRUE)
[17:45:24.621]         }
[17:45:24.621]         {
[17:45:24.621]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.621]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.621]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.621]             })
[17:45:24.621]         }
[17:45:24.621]     }, args = future.call.arguments)
[17:45:24.621] }
[17:45:24.622] Tweak future expression to call with '...' arguments ... DONE
[17:45:24.622] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.622] - packages: [1] ‘stats’
[17:45:24.622] getGlobalsAndPackages() ... DONE
[17:45:24.623] run() for ‘Future’ ...
[17:45:24.623] - state: ‘created’
[17:45:24.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:24.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:24.637]   - Field: ‘node’
[17:45:24.637]   - Field: ‘label’
[17:45:24.637]   - Field: ‘local’
[17:45:24.638]   - Field: ‘owner’
[17:45:24.638]   - Field: ‘envir’
[17:45:24.638]   - Field: ‘workers’
[17:45:24.638]   - Field: ‘packages’
[17:45:24.638]   - Field: ‘gc’
[17:45:24.638]   - Field: ‘conditions’
[17:45:24.638]   - Field: ‘persistent’
[17:45:24.638]   - Field: ‘expr’
[17:45:24.638]   - Field: ‘uuid’
[17:45:24.638]   - Field: ‘seed’
[17:45:24.638]   - Field: ‘version’
[17:45:24.639]   - Field: ‘result’
[17:45:24.639]   - Field: ‘asynchronous’
[17:45:24.639]   - Field: ‘calls’
[17:45:24.639]   - Field: ‘globals’
[17:45:24.639]   - Field: ‘stdout’
[17:45:24.639]   - Field: ‘earlySignal’
[17:45:24.639]   - Field: ‘lazy’
[17:45:24.639]   - Field: ‘state’
[17:45:24.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:24.639] - Launch lazy future ...
[17:45:24.640] Packages needed by the future expression (n = 1): ‘stats’
[17:45:24.640] Packages needed by future strategies (n = 0): <none>
[17:45:24.640] {
[17:45:24.640]     {
[17:45:24.640]         {
[17:45:24.640]             ...future.startTime <- base::Sys.time()
[17:45:24.640]             {
[17:45:24.640]                 {
[17:45:24.640]                   {
[17:45:24.640]                     {
[17:45:24.640]                       {
[17:45:24.640]                         base::local({
[17:45:24.640]                           has_future <- base::requireNamespace("future", 
[17:45:24.640]                             quietly = TRUE)
[17:45:24.640]                           if (has_future) {
[17:45:24.640]                             ns <- base::getNamespace("future")
[17:45:24.640]                             version <- ns[[".package"]][["version"]]
[17:45:24.640]                             if (is.null(version)) 
[17:45:24.640]                               version <- utils::packageVersion("future")
[17:45:24.640]                           }
[17:45:24.640]                           else {
[17:45:24.640]                             version <- NULL
[17:45:24.640]                           }
[17:45:24.640]                           if (!has_future || version < "1.8.0") {
[17:45:24.640]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:24.640]                               "", base::R.version$version.string), 
[17:45:24.640]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:24.640]                                 base::R.version$platform, 8 * 
[17:45:24.640]                                   base::.Machine$sizeof.pointer), 
[17:45:24.640]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:24.640]                                 "release", "version")], collapse = " "), 
[17:45:24.640]                               hostname = base::Sys.info()[["nodename"]])
[17:45:24.640]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:24.640]                               info)
[17:45:24.640]                             info <- base::paste(info, collapse = "; ")
[17:45:24.640]                             if (!has_future) {
[17:45:24.640]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:24.640]                                 info)
[17:45:24.640]                             }
[17:45:24.640]                             else {
[17:45:24.640]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:24.640]                                 info, version)
[17:45:24.640]                             }
[17:45:24.640]                             base::stop(msg)
[17:45:24.640]                           }
[17:45:24.640]                         })
[17:45:24.640]                       }
[17:45:24.640]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:24.640]                       base::options(mc.cores = 1L)
[17:45:24.640]                     }
[17:45:24.640]                     base::local({
[17:45:24.640]                       for (pkg in "stats") {
[17:45:24.640]                         base::loadNamespace(pkg)
[17:45:24.640]                         base::library(pkg, character.only = TRUE)
[17:45:24.640]                       }
[17:45:24.640]                     })
[17:45:24.640]                   }
[17:45:24.640]                   ...future.strategy.old <- future::plan("list")
[17:45:24.640]                   options(future.plan = NULL)
[17:45:24.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:24.640]                 }
[17:45:24.640]                 ...future.workdir <- getwd()
[17:45:24.640]             }
[17:45:24.640]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:24.640]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:24.640]         }
[17:45:24.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:24.640]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:24.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:24.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:24.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:24.640]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:24.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:24.640]             base::names(...future.oldOptions))
[17:45:24.640]     }
[17:45:24.640]     if (FALSE) {
[17:45:24.640]     }
[17:45:24.640]     else {
[17:45:24.640]         if (TRUE) {
[17:45:24.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:24.640]                 open = "w")
[17:45:24.640]         }
[17:45:24.640]         else {
[17:45:24.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:24.640]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:24.640]         }
[17:45:24.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:24.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:24.640]             base::sink(type = "output", split = FALSE)
[17:45:24.640]             base::close(...future.stdout)
[17:45:24.640]         }, add = TRUE)
[17:45:24.640]     }
[17:45:24.640]     ...future.frame <- base::sys.nframe()
[17:45:24.640]     ...future.conditions <- base::list()
[17:45:24.640]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:24.640]     if (FALSE) {
[17:45:24.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:24.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:24.640]     }
[17:45:24.640]     ...future.result <- base::tryCatch({
[17:45:24.640]         base::withCallingHandlers({
[17:45:24.640]             ...future.value <- base::withVisible(base::local({
[17:45:24.640]                 ...future.makeSendCondition <- base::local({
[17:45:24.640]                   sendCondition <- NULL
[17:45:24.640]                   function(frame = 1L) {
[17:45:24.640]                     if (is.function(sendCondition)) 
[17:45:24.640]                       return(sendCondition)
[17:45:24.640]                     ns <- getNamespace("parallel")
[17:45:24.640]                     if (exists("sendData", mode = "function", 
[17:45:24.640]                       envir = ns)) {
[17:45:24.640]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:24.640]                         envir = ns)
[17:45:24.640]                       envir <- sys.frame(frame)
[17:45:24.640]                       master <- NULL
[17:45:24.640]                       while (!identical(envir, .GlobalEnv) && 
[17:45:24.640]                         !identical(envir, emptyenv())) {
[17:45:24.640]                         if (exists("master", mode = "list", envir = envir, 
[17:45:24.640]                           inherits = FALSE)) {
[17:45:24.640]                           master <- get("master", mode = "list", 
[17:45:24.640]                             envir = envir, inherits = FALSE)
[17:45:24.640]                           if (inherits(master, c("SOCKnode", 
[17:45:24.640]                             "SOCK0node"))) {
[17:45:24.640]                             sendCondition <<- function(cond) {
[17:45:24.640]                               data <- list(type = "VALUE", value = cond, 
[17:45:24.640]                                 success = TRUE)
[17:45:24.640]                               parallel_sendData(master, data)
[17:45:24.640]                             }
[17:45:24.640]                             return(sendCondition)
[17:45:24.640]                           }
[17:45:24.640]                         }
[17:45:24.640]                         frame <- frame + 1L
[17:45:24.640]                         envir <- sys.frame(frame)
[17:45:24.640]                       }
[17:45:24.640]                     }
[17:45:24.640]                     sendCondition <<- function(cond) NULL
[17:45:24.640]                   }
[17:45:24.640]                 })
[17:45:24.640]                 withCallingHandlers({
[17:45:24.640]                   {
[17:45:24.640]                     do.call(function(...) {
[17:45:24.640]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.640]                       if (!identical(...future.globals.maxSize.org, 
[17:45:24.640]                         ...future.globals.maxSize)) {
[17:45:24.640]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.640]                         on.exit(options(oopts), add = TRUE)
[17:45:24.640]                       }
[17:45:24.640]                       {
[17:45:24.640]                         lapply(seq_along(...future.elements_ii), 
[17:45:24.640]                           FUN = function(jj) {
[17:45:24.640]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.640]                             ...future.FUN(...future.X_jj, ...)
[17:45:24.640]                           })
[17:45:24.640]                       }
[17:45:24.640]                     }, args = future.call.arguments)
[17:45:24.640]                   }
[17:45:24.640]                 }, immediateCondition = function(cond) {
[17:45:24.640]                   sendCondition <- ...future.makeSendCondition()
[17:45:24.640]                   sendCondition(cond)
[17:45:24.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.640]                   {
[17:45:24.640]                     inherits <- base::inherits
[17:45:24.640]                     invokeRestart <- base::invokeRestart
[17:45:24.640]                     is.null <- base::is.null
[17:45:24.640]                     muffled <- FALSE
[17:45:24.640]                     if (inherits(cond, "message")) {
[17:45:24.640]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:24.640]                       if (muffled) 
[17:45:24.640]                         invokeRestart("muffleMessage")
[17:45:24.640]                     }
[17:45:24.640]                     else if (inherits(cond, "warning")) {
[17:45:24.640]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:24.640]                       if (muffled) 
[17:45:24.640]                         invokeRestart("muffleWarning")
[17:45:24.640]                     }
[17:45:24.640]                     else if (inherits(cond, "condition")) {
[17:45:24.640]                       if (!is.null(pattern)) {
[17:45:24.640]                         computeRestarts <- base::computeRestarts
[17:45:24.640]                         grepl <- base::grepl
[17:45:24.640]                         restarts <- computeRestarts(cond)
[17:45:24.640]                         for (restart in restarts) {
[17:45:24.640]                           name <- restart$name
[17:45:24.640]                           if (is.null(name)) 
[17:45:24.640]                             next
[17:45:24.640]                           if (!grepl(pattern, name)) 
[17:45:24.640]                             next
[17:45:24.640]                           invokeRestart(restart)
[17:45:24.640]                           muffled <- TRUE
[17:45:24.640]                           break
[17:45:24.640]                         }
[17:45:24.640]                       }
[17:45:24.640]                     }
[17:45:24.640]                     invisible(muffled)
[17:45:24.640]                   }
[17:45:24.640]                   muffleCondition(cond)
[17:45:24.640]                 })
[17:45:24.640]             }))
[17:45:24.640]             future::FutureResult(value = ...future.value$value, 
[17:45:24.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.640]                   ...future.rng), globalenv = if (FALSE) 
[17:45:24.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:24.640]                     ...future.globalenv.names))
[17:45:24.640]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:24.640]         }, condition = base::local({
[17:45:24.640]             c <- base::c
[17:45:24.640]             inherits <- base::inherits
[17:45:24.640]             invokeRestart <- base::invokeRestart
[17:45:24.640]             length <- base::length
[17:45:24.640]             list <- base::list
[17:45:24.640]             seq.int <- base::seq.int
[17:45:24.640]             signalCondition <- base::signalCondition
[17:45:24.640]             sys.calls <- base::sys.calls
[17:45:24.640]             `[[` <- base::`[[`
[17:45:24.640]             `+` <- base::`+`
[17:45:24.640]             `<<-` <- base::`<<-`
[17:45:24.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:24.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:24.640]                   3L)]
[17:45:24.640]             }
[17:45:24.640]             function(cond) {
[17:45:24.640]                 is_error <- inherits(cond, "error")
[17:45:24.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:24.640]                   NULL)
[17:45:24.640]                 if (is_error) {
[17:45:24.640]                   sessionInformation <- function() {
[17:45:24.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:24.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:24.640]                       search = base::search(), system = base::Sys.info())
[17:45:24.640]                   }
[17:45:24.640]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:24.640]                     cond$call), session = sessionInformation(), 
[17:45:24.640]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:24.640]                   signalCondition(cond)
[17:45:24.640]                 }
[17:45:24.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:24.640]                 "immediateCondition"))) {
[17:45:24.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:24.640]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:24.640]                   if (TRUE && !signal) {
[17:45:24.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.640]                     {
[17:45:24.640]                       inherits <- base::inherits
[17:45:24.640]                       invokeRestart <- base::invokeRestart
[17:45:24.640]                       is.null <- base::is.null
[17:45:24.640]                       muffled <- FALSE
[17:45:24.640]                       if (inherits(cond, "message")) {
[17:45:24.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.640]                         if (muffled) 
[17:45:24.640]                           invokeRestart("muffleMessage")
[17:45:24.640]                       }
[17:45:24.640]                       else if (inherits(cond, "warning")) {
[17:45:24.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.640]                         if (muffled) 
[17:45:24.640]                           invokeRestart("muffleWarning")
[17:45:24.640]                       }
[17:45:24.640]                       else if (inherits(cond, "condition")) {
[17:45:24.640]                         if (!is.null(pattern)) {
[17:45:24.640]                           computeRestarts <- base::computeRestarts
[17:45:24.640]                           grepl <- base::grepl
[17:45:24.640]                           restarts <- computeRestarts(cond)
[17:45:24.640]                           for (restart in restarts) {
[17:45:24.640]                             name <- restart$name
[17:45:24.640]                             if (is.null(name)) 
[17:45:24.640]                               next
[17:45:24.640]                             if (!grepl(pattern, name)) 
[17:45:24.640]                               next
[17:45:24.640]                             invokeRestart(restart)
[17:45:24.640]                             muffled <- TRUE
[17:45:24.640]                             break
[17:45:24.640]                           }
[17:45:24.640]                         }
[17:45:24.640]                       }
[17:45:24.640]                       invisible(muffled)
[17:45:24.640]                     }
[17:45:24.640]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.640]                   }
[17:45:24.640]                 }
[17:45:24.640]                 else {
[17:45:24.640]                   if (TRUE) {
[17:45:24.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.640]                     {
[17:45:24.640]                       inherits <- base::inherits
[17:45:24.640]                       invokeRestart <- base::invokeRestart
[17:45:24.640]                       is.null <- base::is.null
[17:45:24.640]                       muffled <- FALSE
[17:45:24.640]                       if (inherits(cond, "message")) {
[17:45:24.640]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.640]                         if (muffled) 
[17:45:24.640]                           invokeRestart("muffleMessage")
[17:45:24.640]                       }
[17:45:24.640]                       else if (inherits(cond, "warning")) {
[17:45:24.640]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.640]                         if (muffled) 
[17:45:24.640]                           invokeRestart("muffleWarning")
[17:45:24.640]                       }
[17:45:24.640]                       else if (inherits(cond, "condition")) {
[17:45:24.640]                         if (!is.null(pattern)) {
[17:45:24.640]                           computeRestarts <- base::computeRestarts
[17:45:24.640]                           grepl <- base::grepl
[17:45:24.640]                           restarts <- computeRestarts(cond)
[17:45:24.640]                           for (restart in restarts) {
[17:45:24.640]                             name <- restart$name
[17:45:24.640]                             if (is.null(name)) 
[17:45:24.640]                               next
[17:45:24.640]                             if (!grepl(pattern, name)) 
[17:45:24.640]                               next
[17:45:24.640]                             invokeRestart(restart)
[17:45:24.640]                             muffled <- TRUE
[17:45:24.640]                             break
[17:45:24.640]                           }
[17:45:24.640]                         }
[17:45:24.640]                       }
[17:45:24.640]                       invisible(muffled)
[17:45:24.640]                     }
[17:45:24.640]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.640]                   }
[17:45:24.640]                 }
[17:45:24.640]             }
[17:45:24.640]         }))
[17:45:24.640]     }, error = function(ex) {
[17:45:24.640]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:24.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.640]                 ...future.rng), started = ...future.startTime, 
[17:45:24.640]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:24.640]             version = "1.8"), class = "FutureResult")
[17:45:24.640]     }, finally = {
[17:45:24.640]         if (!identical(...future.workdir, getwd())) 
[17:45:24.640]             setwd(...future.workdir)
[17:45:24.640]         {
[17:45:24.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:24.640]                 ...future.oldOptions$nwarnings <- NULL
[17:45:24.640]             }
[17:45:24.640]             base::options(...future.oldOptions)
[17:45:24.640]             if (.Platform$OS.type == "windows") {
[17:45:24.640]                 old_names <- names(...future.oldEnvVars)
[17:45:24.640]                 envs <- base::Sys.getenv()
[17:45:24.640]                 names <- names(envs)
[17:45:24.640]                 common <- intersect(names, old_names)
[17:45:24.640]                 added <- setdiff(names, old_names)
[17:45:24.640]                 removed <- setdiff(old_names, names)
[17:45:24.640]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:24.640]                   envs[common]]
[17:45:24.640]                 NAMES <- toupper(changed)
[17:45:24.640]                 args <- list()
[17:45:24.640]                 for (kk in seq_along(NAMES)) {
[17:45:24.640]                   name <- changed[[kk]]
[17:45:24.640]                   NAME <- NAMES[[kk]]
[17:45:24.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.640]                     next
[17:45:24.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.640]                 }
[17:45:24.640]                 NAMES <- toupper(added)
[17:45:24.640]                 for (kk in seq_along(NAMES)) {
[17:45:24.640]                   name <- added[[kk]]
[17:45:24.640]                   NAME <- NAMES[[kk]]
[17:45:24.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.640]                     next
[17:45:24.640]                   args[[name]] <- ""
[17:45:24.640]                 }
[17:45:24.640]                 NAMES <- toupper(removed)
[17:45:24.640]                 for (kk in seq_along(NAMES)) {
[17:45:24.640]                   name <- removed[[kk]]
[17:45:24.640]                   NAME <- NAMES[[kk]]
[17:45:24.640]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.640]                     next
[17:45:24.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.640]                 }
[17:45:24.640]                 if (length(args) > 0) 
[17:45:24.640]                   base::do.call(base::Sys.setenv, args = args)
[17:45:24.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:24.640]             }
[17:45:24.640]             else {
[17:45:24.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:24.640]             }
[17:45:24.640]             {
[17:45:24.640]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:24.640]                   0L) {
[17:45:24.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:24.640]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:24.640]                   base::options(opts)
[17:45:24.640]                 }
[17:45:24.640]                 {
[17:45:24.640]                   {
[17:45:24.640]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:24.640]                     NULL
[17:45:24.640]                   }
[17:45:24.640]                   options(future.plan = NULL)
[17:45:24.640]                   if (is.na(NA_character_)) 
[17:45:24.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:24.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:24.640]                     .init = FALSE)
[17:45:24.640]                 }
[17:45:24.640]             }
[17:45:24.640]         }
[17:45:24.640]     })
[17:45:24.640]     if (TRUE) {
[17:45:24.640]         base::sink(type = "output", split = FALSE)
[17:45:24.640]         if (TRUE) {
[17:45:24.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:24.640]         }
[17:45:24.640]         else {
[17:45:24.640]             ...future.result["stdout"] <- base::list(NULL)
[17:45:24.640]         }
[17:45:24.640]         base::close(...future.stdout)
[17:45:24.640]         ...future.stdout <- NULL
[17:45:24.640]     }
[17:45:24.640]     ...future.result$conditions <- ...future.conditions
[17:45:24.640]     ...future.result$finished <- base::Sys.time()
[17:45:24.640]     ...future.result
[17:45:24.640] }
[17:45:24.643] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[17:45:24.643] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[17:45:24.688] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:45:24.688] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:24.689] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.689] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:45:24.689] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:45:24.689] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:24.690] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:24.690] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:24.690] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[17:45:24.691] MultisessionFuture started
[17:45:24.691] - Launch lazy future ... done
[17:45:24.691] run() for ‘MultisessionFuture’ ... done
[17:45:24.692] Created future:
[17:45:24.692] MultisessionFuture:
[17:45:24.692] Label: ‘future_sapply-1’
[17:45:24.692] Expression:
[17:45:24.692] {
[17:45:24.692]     do.call(function(...) {
[17:45:24.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.692]             on.exit(options(oopts), add = TRUE)
[17:45:24.692]         }
[17:45:24.692]         {
[17:45:24.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.692]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.692]             })
[17:45:24.692]         }
[17:45:24.692]     }, args = future.call.arguments)
[17:45:24.692] }
[17:45:24.692] Lazy evaluation: FALSE
[17:45:24.692] Asynchronous evaluation: TRUE
[17:45:24.692] Local evaluation: TRUE
[17:45:24.692] Environment: R_GlobalEnv
[17:45:24.692] Capture standard output: TRUE
[17:45:24.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:24.692] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:24.692] Packages: 1 packages (‘stats’)
[17:45:24.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:24.692] Resolved: FALSE
[17:45:24.692] Value: <not collected>
[17:45:24.692] Conditions captured: <none>
[17:45:24.692] Early signaling: FALSE
[17:45:24.692] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:24.692] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.703] Chunk #1 of 2 ... DONE
[17:45:24.703] Chunk #2 of 2 ...
[17:45:24.704]  - Finding globals in 'X' for chunk #2 ...
[17:45:24.704] getGlobalsAndPackages() ...
[17:45:24.704] Searching for globals...
[17:45:24.704] 
[17:45:24.704] Searching for globals ... DONE
[17:45:24.704] - globals: [0] <none>
[17:45:24.704] getGlobalsAndPackages() ... DONE
[17:45:24.704]    + additional globals found: [n=0] 
[17:45:24.705]    + additional namespaces needed: [n=0] 
[17:45:24.705]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:24.705]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:24.705]  - seeds: <none>
[17:45:24.705]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.705] getGlobalsAndPackages() ...
[17:45:24.705] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.705] Resolving globals: FALSE
[17:45:24.705] Tweak future expression to call with '...' arguments ...
[17:45:24.705] {
[17:45:24.705]     do.call(function(...) {
[17:45:24.705]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.705]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.705]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.705]             on.exit(options(oopts), add = TRUE)
[17:45:24.705]         }
[17:45:24.705]         {
[17:45:24.705]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.705]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.705]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.705]             })
[17:45:24.705]         }
[17:45:24.705]     }, args = future.call.arguments)
[17:45:24.705] }
[17:45:24.706] Tweak future expression to call with '...' arguments ... DONE
[17:45:24.706] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.706] - packages: [1] ‘stats’
[17:45:24.706] getGlobalsAndPackages() ... DONE
[17:45:24.707] run() for ‘Future’ ...
[17:45:24.707] - state: ‘created’
[17:45:24.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:24.721] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.722] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:24.724]   - Field: ‘node’
[17:45:24.724]   - Field: ‘label’
[17:45:24.724]   - Field: ‘local’
[17:45:24.725]   - Field: ‘owner’
[17:45:24.725]   - Field: ‘envir’
[17:45:24.725]   - Field: ‘workers’
[17:45:24.725]   - Field: ‘packages’
[17:45:24.725]   - Field: ‘gc’
[17:45:24.725]   - Field: ‘conditions’
[17:45:24.725]   - Field: ‘persistent’
[17:45:24.725]   - Field: ‘expr’
[17:45:24.725]   - Field: ‘uuid’
[17:45:24.725]   - Field: ‘seed’
[17:45:24.725]   - Field: ‘version’
[17:45:24.726]   - Field: ‘result’
[17:45:24.726]   - Field: ‘asynchronous’
[17:45:24.726]   - Field: ‘calls’
[17:45:24.726]   - Field: ‘globals’
[17:45:24.726]   - Field: ‘stdout’
[17:45:24.726]   - Field: ‘earlySignal’
[17:45:24.726]   - Field: ‘lazy’
[17:45:24.726]   - Field: ‘state’
[17:45:24.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:24.726] - Launch lazy future ...
[17:45:24.727] Packages needed by the future expression (n = 1): ‘stats’
[17:45:24.727] Packages needed by future strategies (n = 0): <none>
[17:45:24.727] {
[17:45:24.727]     {
[17:45:24.727]         {
[17:45:24.727]             ...future.startTime <- base::Sys.time()
[17:45:24.727]             {
[17:45:24.727]                 {
[17:45:24.727]                   {
[17:45:24.727]                     {
[17:45:24.727]                       {
[17:45:24.727]                         base::local({
[17:45:24.727]                           has_future <- base::requireNamespace("future", 
[17:45:24.727]                             quietly = TRUE)
[17:45:24.727]                           if (has_future) {
[17:45:24.727]                             ns <- base::getNamespace("future")
[17:45:24.727]                             version <- ns[[".package"]][["version"]]
[17:45:24.727]                             if (is.null(version)) 
[17:45:24.727]                               version <- utils::packageVersion("future")
[17:45:24.727]                           }
[17:45:24.727]                           else {
[17:45:24.727]                             version <- NULL
[17:45:24.727]                           }
[17:45:24.727]                           if (!has_future || version < "1.8.0") {
[17:45:24.727]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:24.727]                               "", base::R.version$version.string), 
[17:45:24.727]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:24.727]                                 base::R.version$platform, 8 * 
[17:45:24.727]                                   base::.Machine$sizeof.pointer), 
[17:45:24.727]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:24.727]                                 "release", "version")], collapse = " "), 
[17:45:24.727]                               hostname = base::Sys.info()[["nodename"]])
[17:45:24.727]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:24.727]                               info)
[17:45:24.727]                             info <- base::paste(info, collapse = "; ")
[17:45:24.727]                             if (!has_future) {
[17:45:24.727]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:24.727]                                 info)
[17:45:24.727]                             }
[17:45:24.727]                             else {
[17:45:24.727]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:24.727]                                 info, version)
[17:45:24.727]                             }
[17:45:24.727]                             base::stop(msg)
[17:45:24.727]                           }
[17:45:24.727]                         })
[17:45:24.727]                       }
[17:45:24.727]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:24.727]                       base::options(mc.cores = 1L)
[17:45:24.727]                     }
[17:45:24.727]                     base::local({
[17:45:24.727]                       for (pkg in "stats") {
[17:45:24.727]                         base::loadNamespace(pkg)
[17:45:24.727]                         base::library(pkg, character.only = TRUE)
[17:45:24.727]                       }
[17:45:24.727]                     })
[17:45:24.727]                   }
[17:45:24.727]                   ...future.strategy.old <- future::plan("list")
[17:45:24.727]                   options(future.plan = NULL)
[17:45:24.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:24.727]                 }
[17:45:24.727]                 ...future.workdir <- getwd()
[17:45:24.727]             }
[17:45:24.727]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:24.727]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:24.727]         }
[17:45:24.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:24.727]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:24.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:24.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:24.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:24.727]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:24.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:24.727]             base::names(...future.oldOptions))
[17:45:24.727]     }
[17:45:24.727]     if (FALSE) {
[17:45:24.727]     }
[17:45:24.727]     else {
[17:45:24.727]         if (TRUE) {
[17:45:24.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:24.727]                 open = "w")
[17:45:24.727]         }
[17:45:24.727]         else {
[17:45:24.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:24.727]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:24.727]         }
[17:45:24.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:24.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:24.727]             base::sink(type = "output", split = FALSE)
[17:45:24.727]             base::close(...future.stdout)
[17:45:24.727]         }, add = TRUE)
[17:45:24.727]     }
[17:45:24.727]     ...future.frame <- base::sys.nframe()
[17:45:24.727]     ...future.conditions <- base::list()
[17:45:24.727]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:24.727]     if (FALSE) {
[17:45:24.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:24.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:24.727]     }
[17:45:24.727]     ...future.result <- base::tryCatch({
[17:45:24.727]         base::withCallingHandlers({
[17:45:24.727]             ...future.value <- base::withVisible(base::local({
[17:45:24.727]                 ...future.makeSendCondition <- base::local({
[17:45:24.727]                   sendCondition <- NULL
[17:45:24.727]                   function(frame = 1L) {
[17:45:24.727]                     if (is.function(sendCondition)) 
[17:45:24.727]                       return(sendCondition)
[17:45:24.727]                     ns <- getNamespace("parallel")
[17:45:24.727]                     if (exists("sendData", mode = "function", 
[17:45:24.727]                       envir = ns)) {
[17:45:24.727]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:24.727]                         envir = ns)
[17:45:24.727]                       envir <- sys.frame(frame)
[17:45:24.727]                       master <- NULL
[17:45:24.727]                       while (!identical(envir, .GlobalEnv) && 
[17:45:24.727]                         !identical(envir, emptyenv())) {
[17:45:24.727]                         if (exists("master", mode = "list", envir = envir, 
[17:45:24.727]                           inherits = FALSE)) {
[17:45:24.727]                           master <- get("master", mode = "list", 
[17:45:24.727]                             envir = envir, inherits = FALSE)
[17:45:24.727]                           if (inherits(master, c("SOCKnode", 
[17:45:24.727]                             "SOCK0node"))) {
[17:45:24.727]                             sendCondition <<- function(cond) {
[17:45:24.727]                               data <- list(type = "VALUE", value = cond, 
[17:45:24.727]                                 success = TRUE)
[17:45:24.727]                               parallel_sendData(master, data)
[17:45:24.727]                             }
[17:45:24.727]                             return(sendCondition)
[17:45:24.727]                           }
[17:45:24.727]                         }
[17:45:24.727]                         frame <- frame + 1L
[17:45:24.727]                         envir <- sys.frame(frame)
[17:45:24.727]                       }
[17:45:24.727]                     }
[17:45:24.727]                     sendCondition <<- function(cond) NULL
[17:45:24.727]                   }
[17:45:24.727]                 })
[17:45:24.727]                 withCallingHandlers({
[17:45:24.727]                   {
[17:45:24.727]                     do.call(function(...) {
[17:45:24.727]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.727]                       if (!identical(...future.globals.maxSize.org, 
[17:45:24.727]                         ...future.globals.maxSize)) {
[17:45:24.727]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.727]                         on.exit(options(oopts), add = TRUE)
[17:45:24.727]                       }
[17:45:24.727]                       {
[17:45:24.727]                         lapply(seq_along(...future.elements_ii), 
[17:45:24.727]                           FUN = function(jj) {
[17:45:24.727]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.727]                             ...future.FUN(...future.X_jj, ...)
[17:45:24.727]                           })
[17:45:24.727]                       }
[17:45:24.727]                     }, args = future.call.arguments)
[17:45:24.727]                   }
[17:45:24.727]                 }, immediateCondition = function(cond) {
[17:45:24.727]                   sendCondition <- ...future.makeSendCondition()
[17:45:24.727]                   sendCondition(cond)
[17:45:24.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.727]                   {
[17:45:24.727]                     inherits <- base::inherits
[17:45:24.727]                     invokeRestart <- base::invokeRestart
[17:45:24.727]                     is.null <- base::is.null
[17:45:24.727]                     muffled <- FALSE
[17:45:24.727]                     if (inherits(cond, "message")) {
[17:45:24.727]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:24.727]                       if (muffled) 
[17:45:24.727]                         invokeRestart("muffleMessage")
[17:45:24.727]                     }
[17:45:24.727]                     else if (inherits(cond, "warning")) {
[17:45:24.727]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:24.727]                       if (muffled) 
[17:45:24.727]                         invokeRestart("muffleWarning")
[17:45:24.727]                     }
[17:45:24.727]                     else if (inherits(cond, "condition")) {
[17:45:24.727]                       if (!is.null(pattern)) {
[17:45:24.727]                         computeRestarts <- base::computeRestarts
[17:45:24.727]                         grepl <- base::grepl
[17:45:24.727]                         restarts <- computeRestarts(cond)
[17:45:24.727]                         for (restart in restarts) {
[17:45:24.727]                           name <- restart$name
[17:45:24.727]                           if (is.null(name)) 
[17:45:24.727]                             next
[17:45:24.727]                           if (!grepl(pattern, name)) 
[17:45:24.727]                             next
[17:45:24.727]                           invokeRestart(restart)
[17:45:24.727]                           muffled <- TRUE
[17:45:24.727]                           break
[17:45:24.727]                         }
[17:45:24.727]                       }
[17:45:24.727]                     }
[17:45:24.727]                     invisible(muffled)
[17:45:24.727]                   }
[17:45:24.727]                   muffleCondition(cond)
[17:45:24.727]                 })
[17:45:24.727]             }))
[17:45:24.727]             future::FutureResult(value = ...future.value$value, 
[17:45:24.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.727]                   ...future.rng), globalenv = if (FALSE) 
[17:45:24.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:24.727]                     ...future.globalenv.names))
[17:45:24.727]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:24.727]         }, condition = base::local({
[17:45:24.727]             c <- base::c
[17:45:24.727]             inherits <- base::inherits
[17:45:24.727]             invokeRestart <- base::invokeRestart
[17:45:24.727]             length <- base::length
[17:45:24.727]             list <- base::list
[17:45:24.727]             seq.int <- base::seq.int
[17:45:24.727]             signalCondition <- base::signalCondition
[17:45:24.727]             sys.calls <- base::sys.calls
[17:45:24.727]             `[[` <- base::`[[`
[17:45:24.727]             `+` <- base::`+`
[17:45:24.727]             `<<-` <- base::`<<-`
[17:45:24.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:24.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:24.727]                   3L)]
[17:45:24.727]             }
[17:45:24.727]             function(cond) {
[17:45:24.727]                 is_error <- inherits(cond, "error")
[17:45:24.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:24.727]                   NULL)
[17:45:24.727]                 if (is_error) {
[17:45:24.727]                   sessionInformation <- function() {
[17:45:24.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:24.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:24.727]                       search = base::search(), system = base::Sys.info())
[17:45:24.727]                   }
[17:45:24.727]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:24.727]                     cond$call), session = sessionInformation(), 
[17:45:24.727]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:24.727]                   signalCondition(cond)
[17:45:24.727]                 }
[17:45:24.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:24.727]                 "immediateCondition"))) {
[17:45:24.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:24.727]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:24.727]                   if (TRUE && !signal) {
[17:45:24.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.727]                     {
[17:45:24.727]                       inherits <- base::inherits
[17:45:24.727]                       invokeRestart <- base::invokeRestart
[17:45:24.727]                       is.null <- base::is.null
[17:45:24.727]                       muffled <- FALSE
[17:45:24.727]                       if (inherits(cond, "message")) {
[17:45:24.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.727]                         if (muffled) 
[17:45:24.727]                           invokeRestart("muffleMessage")
[17:45:24.727]                       }
[17:45:24.727]                       else if (inherits(cond, "warning")) {
[17:45:24.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.727]                         if (muffled) 
[17:45:24.727]                           invokeRestart("muffleWarning")
[17:45:24.727]                       }
[17:45:24.727]                       else if (inherits(cond, "condition")) {
[17:45:24.727]                         if (!is.null(pattern)) {
[17:45:24.727]                           computeRestarts <- base::computeRestarts
[17:45:24.727]                           grepl <- base::grepl
[17:45:24.727]                           restarts <- computeRestarts(cond)
[17:45:24.727]                           for (restart in restarts) {
[17:45:24.727]                             name <- restart$name
[17:45:24.727]                             if (is.null(name)) 
[17:45:24.727]                               next
[17:45:24.727]                             if (!grepl(pattern, name)) 
[17:45:24.727]                               next
[17:45:24.727]                             invokeRestart(restart)
[17:45:24.727]                             muffled <- TRUE
[17:45:24.727]                             break
[17:45:24.727]                           }
[17:45:24.727]                         }
[17:45:24.727]                       }
[17:45:24.727]                       invisible(muffled)
[17:45:24.727]                     }
[17:45:24.727]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.727]                   }
[17:45:24.727]                 }
[17:45:24.727]                 else {
[17:45:24.727]                   if (TRUE) {
[17:45:24.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.727]                     {
[17:45:24.727]                       inherits <- base::inherits
[17:45:24.727]                       invokeRestart <- base::invokeRestart
[17:45:24.727]                       is.null <- base::is.null
[17:45:24.727]                       muffled <- FALSE
[17:45:24.727]                       if (inherits(cond, "message")) {
[17:45:24.727]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.727]                         if (muffled) 
[17:45:24.727]                           invokeRestart("muffleMessage")
[17:45:24.727]                       }
[17:45:24.727]                       else if (inherits(cond, "warning")) {
[17:45:24.727]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.727]                         if (muffled) 
[17:45:24.727]                           invokeRestart("muffleWarning")
[17:45:24.727]                       }
[17:45:24.727]                       else if (inherits(cond, "condition")) {
[17:45:24.727]                         if (!is.null(pattern)) {
[17:45:24.727]                           computeRestarts <- base::computeRestarts
[17:45:24.727]                           grepl <- base::grepl
[17:45:24.727]                           restarts <- computeRestarts(cond)
[17:45:24.727]                           for (restart in restarts) {
[17:45:24.727]                             name <- restart$name
[17:45:24.727]                             if (is.null(name)) 
[17:45:24.727]                               next
[17:45:24.727]                             if (!grepl(pattern, name)) 
[17:45:24.727]                               next
[17:45:24.727]                             invokeRestart(restart)
[17:45:24.727]                             muffled <- TRUE
[17:45:24.727]                             break
[17:45:24.727]                           }
[17:45:24.727]                         }
[17:45:24.727]                       }
[17:45:24.727]                       invisible(muffled)
[17:45:24.727]                     }
[17:45:24.727]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.727]                   }
[17:45:24.727]                 }
[17:45:24.727]             }
[17:45:24.727]         }))
[17:45:24.727]     }, error = function(ex) {
[17:45:24.727]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:24.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.727]                 ...future.rng), started = ...future.startTime, 
[17:45:24.727]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:24.727]             version = "1.8"), class = "FutureResult")
[17:45:24.727]     }, finally = {
[17:45:24.727]         if (!identical(...future.workdir, getwd())) 
[17:45:24.727]             setwd(...future.workdir)
[17:45:24.727]         {
[17:45:24.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:24.727]                 ...future.oldOptions$nwarnings <- NULL
[17:45:24.727]             }
[17:45:24.727]             base::options(...future.oldOptions)
[17:45:24.727]             if (.Platform$OS.type == "windows") {
[17:45:24.727]                 old_names <- names(...future.oldEnvVars)
[17:45:24.727]                 envs <- base::Sys.getenv()
[17:45:24.727]                 names <- names(envs)
[17:45:24.727]                 common <- intersect(names, old_names)
[17:45:24.727]                 added <- setdiff(names, old_names)
[17:45:24.727]                 removed <- setdiff(old_names, names)
[17:45:24.727]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:24.727]                   envs[common]]
[17:45:24.727]                 NAMES <- toupper(changed)
[17:45:24.727]                 args <- list()
[17:45:24.727]                 for (kk in seq_along(NAMES)) {
[17:45:24.727]                   name <- changed[[kk]]
[17:45:24.727]                   NAME <- NAMES[[kk]]
[17:45:24.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.727]                     next
[17:45:24.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.727]                 }
[17:45:24.727]                 NAMES <- toupper(added)
[17:45:24.727]                 for (kk in seq_along(NAMES)) {
[17:45:24.727]                   name <- added[[kk]]
[17:45:24.727]                   NAME <- NAMES[[kk]]
[17:45:24.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.727]                     next
[17:45:24.727]                   args[[name]] <- ""
[17:45:24.727]                 }
[17:45:24.727]                 NAMES <- toupper(removed)
[17:45:24.727]                 for (kk in seq_along(NAMES)) {
[17:45:24.727]                   name <- removed[[kk]]
[17:45:24.727]                   NAME <- NAMES[[kk]]
[17:45:24.727]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.727]                     next
[17:45:24.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.727]                 }
[17:45:24.727]                 if (length(args) > 0) 
[17:45:24.727]                   base::do.call(base::Sys.setenv, args = args)
[17:45:24.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:24.727]             }
[17:45:24.727]             else {
[17:45:24.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:24.727]             }
[17:45:24.727]             {
[17:45:24.727]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:24.727]                   0L) {
[17:45:24.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:24.727]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:24.727]                   base::options(opts)
[17:45:24.727]                 }
[17:45:24.727]                 {
[17:45:24.727]                   {
[17:45:24.727]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:24.727]                     NULL
[17:45:24.727]                   }
[17:45:24.727]                   options(future.plan = NULL)
[17:45:24.727]                   if (is.na(NA_character_)) 
[17:45:24.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:24.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:24.727]                     .init = FALSE)
[17:45:24.727]                 }
[17:45:24.727]             }
[17:45:24.727]         }
[17:45:24.727]     })
[17:45:24.727]     if (TRUE) {
[17:45:24.727]         base::sink(type = "output", split = FALSE)
[17:45:24.727]         if (TRUE) {
[17:45:24.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:24.727]         }
[17:45:24.727]         else {
[17:45:24.727]             ...future.result["stdout"] <- base::list(NULL)
[17:45:24.727]         }
[17:45:24.727]         base::close(...future.stdout)
[17:45:24.727]         ...future.stdout <- NULL
[17:45:24.727]     }
[17:45:24.727]     ...future.result$conditions <- ...future.conditions
[17:45:24.727]     ...future.result$finished <- base::Sys.time()
[17:45:24.727]     ...future.result
[17:45:24.727] }
[17:45:24.730] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[17:45:24.730] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[17:45:24.772] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:45:24.772] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:24.773] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:24.773] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:45:24.773] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:45:24.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:24.773] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:24.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:24.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:24.774] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[17:45:24.775] MultisessionFuture started
[17:45:24.775] - Launch lazy future ... done
[17:45:24.775] run() for ‘MultisessionFuture’ ... done
[17:45:24.775] Created future:
[17:45:24.775] MultisessionFuture:
[17:45:24.775] Label: ‘future_sapply-2’
[17:45:24.775] Expression:
[17:45:24.775] {
[17:45:24.775]     do.call(function(...) {
[17:45:24.775]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.775]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.775]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.775]             on.exit(options(oopts), add = TRUE)
[17:45:24.775]         }
[17:45:24.775]         {
[17:45:24.775]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.775]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.775]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.775]             })
[17:45:24.775]         }
[17:45:24.775]     }, args = future.call.arguments)
[17:45:24.775] }
[17:45:24.775] Lazy evaluation: FALSE
[17:45:24.775] Asynchronous evaluation: TRUE
[17:45:24.775] Local evaluation: TRUE
[17:45:24.775] Environment: R_GlobalEnv
[17:45:24.775] Capture standard output: TRUE
[17:45:24.775] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:24.775] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:24.775] Packages: 1 packages (‘stats’)
[17:45:24.775] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:24.775] Resolved: FALSE
[17:45:24.775] Value: <not collected>
[17:45:24.775] Conditions captured: <none>
[17:45:24.775] Early signaling: FALSE
[17:45:24.775] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:24.775] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.787] Chunk #2 of 2 ... DONE
[17:45:24.787] Launching 2 futures (chunks) ... DONE
[17:45:24.787] Resolving 2 futures (chunks) ...
[17:45:24.787] resolve() on list ...
[17:45:24.787]  recursive: 0
[17:45:24.787]  length: 2
[17:45:24.787] 
[17:45:24.788] receiveMessageFromWorker() for ClusterFuture ...
[17:45:24.788] - Validating connection of MultisessionFuture
[17:45:24.788] - received message: FutureResult
[17:45:24.788] - Received FutureResult
[17:45:24.788] - Erased future from FutureRegistry
[17:45:24.788] result() for ClusterFuture ...
[17:45:24.788] - result already collected: FutureResult
[17:45:24.788] result() for ClusterFuture ... done
[17:45:24.789] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:24.789] Future #1
[17:45:24.789] result() for ClusterFuture ...
[17:45:24.789] - result already collected: FutureResult
[17:45:24.789] result() for ClusterFuture ... done
[17:45:24.789] result() for ClusterFuture ...
[17:45:24.789] - result already collected: FutureResult
[17:45:24.789] result() for ClusterFuture ... done
[17:45:24.789] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:24.789] - nx: 2
[17:45:24.789] - relay: TRUE
[17:45:24.790] - stdout: TRUE
[17:45:24.790] - signal: TRUE
[17:45:24.790] - resignal: FALSE
[17:45:24.790] - force: TRUE
[17:45:24.790] - relayed: [n=2] FALSE, FALSE
[17:45:24.790] - queued futures: [n=2] FALSE, FALSE
[17:45:24.790]  - until=1
[17:45:24.790]  - relaying element #1
[17:45:24.790] result() for ClusterFuture ...
[17:45:24.790] - result already collected: FutureResult
[17:45:24.790] result() for ClusterFuture ... done
[17:45:24.790] result() for ClusterFuture ...
[17:45:24.791] - result already collected: FutureResult
[17:45:24.791] result() for ClusterFuture ... done
[17:45:24.791] result() for ClusterFuture ...
[17:45:24.791] - result already collected: FutureResult
[17:45:24.791] result() for ClusterFuture ... done
[17:45:24.791] result() for ClusterFuture ...
[17:45:24.791] - result already collected: FutureResult
[17:45:24.791] result() for ClusterFuture ... done
[17:45:24.791] - relayed: [n=2] TRUE, FALSE
[17:45:24.791] - queued futures: [n=2] TRUE, FALSE
[17:45:24.791] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:24.792]  length: 1 (resolved future 1)
[17:45:24.817] receiveMessageFromWorker() for ClusterFuture ...
[17:45:24.818] - Validating connection of MultisessionFuture
[17:45:24.818] - received message: FutureResult
[17:45:24.818] - Received FutureResult
[17:45:24.818] - Erased future from FutureRegistry
[17:45:24.818] result() for ClusterFuture ...
[17:45:24.818] - result already collected: FutureResult
[17:45:24.818] result() for ClusterFuture ... done
[17:45:24.818] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:24.818] Future #2
[17:45:24.819] result() for ClusterFuture ...
[17:45:24.819] - result already collected: FutureResult
[17:45:24.819] result() for ClusterFuture ... done
[17:45:24.819] result() for ClusterFuture ...
[17:45:24.819] - result already collected: FutureResult
[17:45:24.819] result() for ClusterFuture ... done
[17:45:24.819] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:24.819] - nx: 2
[17:45:24.819] - relay: TRUE
[17:45:24.819] - stdout: TRUE
[17:45:24.819] - signal: TRUE
[17:45:24.820] - resignal: FALSE
[17:45:24.820] - force: TRUE
[17:45:24.820] - relayed: [n=2] TRUE, FALSE
[17:45:24.820] - queued futures: [n=2] TRUE, FALSE
[17:45:24.820]  - until=2
[17:45:24.820]  - relaying element #2
[17:45:24.820] result() for ClusterFuture ...
[17:45:24.820] - result already collected: FutureResult
[17:45:24.820] result() for ClusterFuture ... done
[17:45:24.820] result() for ClusterFuture ...
[17:45:24.820] - result already collected: FutureResult
[17:45:24.820] result() for ClusterFuture ... done
[17:45:24.821] result() for ClusterFuture ...
[17:45:24.821] - result already collected: FutureResult
[17:45:24.821] result() for ClusterFuture ... done
[17:45:24.821] result() for ClusterFuture ...
[17:45:24.821] - result already collected: FutureResult
[17:45:24.821] result() for ClusterFuture ... done
[17:45:24.821] - relayed: [n=2] TRUE, TRUE
[17:45:24.821] - queued futures: [n=2] TRUE, TRUE
[17:45:24.821] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:24.821]  length: 0 (resolved future 2)
[17:45:24.822] Relaying remaining futures
[17:45:24.822] signalConditionsASAP(NULL, pos=0) ...
[17:45:24.822] - nx: 2
[17:45:24.822] - relay: TRUE
[17:45:24.822] - stdout: TRUE
[17:45:24.822] - signal: TRUE
[17:45:24.822] - resignal: FALSE
[17:45:24.822] - force: TRUE
[17:45:24.822] - relayed: [n=2] TRUE, TRUE
[17:45:24.822] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:24.822] - relayed: [n=2] TRUE, TRUE
[17:45:24.823] - queued futures: [n=2] TRUE, TRUE
[17:45:24.823] signalConditionsASAP(NULL, pos=0) ... done
[17:45:24.823] resolve() on list ... DONE
[17:45:24.823] result() for ClusterFuture ...
[17:45:24.823] - result already collected: FutureResult
[17:45:24.823] result() for ClusterFuture ... done
[17:45:24.823] result() for ClusterFuture ...
[17:45:24.823] - result already collected: FutureResult
[17:45:24.823] result() for ClusterFuture ... done
[17:45:24.823] result() for ClusterFuture ...
[17:45:24.823] - result already collected: FutureResult
[17:45:24.824] result() for ClusterFuture ... done
[17:45:24.824] result() for ClusterFuture ...
[17:45:24.824] - result already collected: FutureResult
[17:45:24.824] result() for ClusterFuture ... done
[17:45:24.824]  - Number of value chunks collected: 2
[17:45:24.824] Resolving 2 futures (chunks) ... DONE
[17:45:24.824] Reducing values from 2 chunks ...
[17:45:24.824]  - Number of values collected after concatenation: 7
[17:45:24.824]  - Number of values expected: 7
[17:45:24.824] Reducing values from 2 chunks ... DONE
[17:45:24.824] future_lapply() ... DONE
[17:45:24.825] future_lapply() ...
[17:45:24.830] Number of chunks: 2
[17:45:24.830] getGlobalsAndPackagesXApply() ...
[17:45:24.830]  - future.globals: TRUE
[17:45:24.831] getGlobalsAndPackages() ...
[17:45:24.831] Searching for globals...
[17:45:24.838] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[17:45:24.838] Searching for globals ... DONE
[17:45:24.838] Resolving globals: FALSE
[17:45:24.839] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[17:45:24.839] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[17:45:24.840] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:24.840] - packages: [2] ‘stats’, ‘future.apply’
[17:45:24.840] getGlobalsAndPackages() ... DONE
[17:45:24.840]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:24.840]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[17:45:24.840] Finding globals ... DONE
[17:45:24.840]  - use_args: TRUE
[17:45:24.840]  - Getting '...' globals ...
[17:45:24.841] resolve() on list ...
[17:45:24.841]  recursive: 0
[17:45:24.841]  length: 1
[17:45:24.841]  elements: ‘...’
[17:45:24.841]  length: 0 (resolved future 1)
[17:45:24.841] resolve() on list ... DONE
[17:45:24.841]    - '...' content: [n=0] 
[17:45:24.841] List of 1
[17:45:24.841]  $ ...: list()
[17:45:24.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:24.841]  - attr(*, "where")=List of 1
[17:45:24.841]   ..$ ...:<environment: 0x5561f650d7b8> 
[17:45:24.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:24.841]  - attr(*, "resolved")= logi TRUE
[17:45:24.841]  - attr(*, "total_size")= num NA
[17:45:24.844]  - Getting '...' globals ... DONE
[17:45:24.844] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:24.844] List of 8
[17:45:24.844]  $ ...future.FUN:function (x, ...)  
[17:45:24.844]  $ x_FUN        :function (x, na.rm = TRUE)  
[17:45:24.844]  $ times        : int 5
[17:45:24.844]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:24.844]  $ stop_if_not  :function (...)  
[17:45:24.844]  $ dim          : NULL
[17:45:24.844]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:24.844]  $ ...          : list()
[17:45:24.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:24.844]  - attr(*, "where")=List of 8
[17:45:24.844]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:24.844]   ..$ ...          :<environment: 0x5561f650d7b8> 
[17:45:24.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:24.844]  - attr(*, "resolved")= logi FALSE
[17:45:24.844]  - attr(*, "total_size")= num 141240
[17:45:24.849] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[17:45:24.849] getGlobalsAndPackagesXApply() ... DONE
[17:45:24.850] Number of futures (= number of chunks): 2
[17:45:24.850] Launching 2 futures (chunks) ...
[17:45:24.850] Chunk #1 of 2 ...
[17:45:24.850]  - Finding globals in 'X' for chunk #1 ...
[17:45:24.850] getGlobalsAndPackages() ...
[17:45:24.850] Searching for globals...
[17:45:24.850] 
[17:45:24.851] Searching for globals ... DONE
[17:45:24.851] - globals: [0] <none>
[17:45:24.851] getGlobalsAndPackages() ... DONE
[17:45:24.851]    + additional globals found: [n=0] 
[17:45:24.851]    + additional namespaces needed: [n=0] 
[17:45:24.851]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:24.851]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:24.851]  - seeds: <none>
[17:45:24.851]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.851] getGlobalsAndPackages() ...
[17:45:24.851] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.852] Resolving globals: FALSE
[17:45:24.852] Tweak future expression to call with '...' arguments ...
[17:45:24.852] {
[17:45:24.852]     do.call(function(...) {
[17:45:24.852]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.852]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:24.852]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.852]             on.exit(options(oopts), add = TRUE)
[17:45:24.852]         }
[17:45:24.852]         {
[17:45:24.852]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:24.852]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.852]                 ...future.FUN(...future.X_jj, ...)
[17:45:24.852]             })
[17:45:24.852]         }
[17:45:24.852]     }, args = future.call.arguments)
[17:45:24.852] }
[17:45:24.852] Tweak future expression to call with '...' arguments ... DONE
[17:45:24.853] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:24.853] - packages: [2] ‘stats’, ‘future.apply’
[17:45:24.853] getGlobalsAndPackages() ... DONE
[17:45:24.853] run() for ‘Future’ ...
[17:45:24.853] - state: ‘created’
[17:45:24.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:24.868] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:24.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:24.868]   - Field: ‘node’
[17:45:24.868]   - Field: ‘label’
[17:45:24.868]   - Field: ‘local’
[17:45:24.868]   - Field: ‘owner’
[17:45:24.868]   - Field: ‘envir’
[17:45:24.868]   - Field: ‘workers’
[17:45:24.869]   - Field: ‘packages’
[17:45:24.869]   - Field: ‘gc’
[17:45:24.869]   - Field: ‘conditions’
[17:45:24.869]   - Field: ‘persistent’
[17:45:24.869]   - Field: ‘expr’
[17:45:24.869]   - Field: ‘uuid’
[17:45:24.869]   - Field: ‘seed’
[17:45:24.869]   - Field: ‘version’
[17:45:24.869]   - Field: ‘result’
[17:45:24.869]   - Field: ‘asynchronous’
[17:45:24.869]   - Field: ‘calls’
[17:45:24.870]   - Field: ‘globals’
[17:45:24.870]   - Field: ‘stdout’
[17:45:24.870]   - Field: ‘earlySignal’
[17:45:24.870]   - Field: ‘lazy’
[17:45:24.870]   - Field: ‘state’
[17:45:24.870] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:24.870] - Launch lazy future ...
[17:45:24.870] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:24.870] Packages needed by future strategies (n = 0): <none>
[17:45:24.871] {
[17:45:24.871]     {
[17:45:24.871]         {
[17:45:24.871]             ...future.startTime <- base::Sys.time()
[17:45:24.871]             {
[17:45:24.871]                 {
[17:45:24.871]                   {
[17:45:24.871]                     {
[17:45:24.871]                       {
[17:45:24.871]                         base::local({
[17:45:24.871]                           has_future <- base::requireNamespace("future", 
[17:45:24.871]                             quietly = TRUE)
[17:45:24.871]                           if (has_future) {
[17:45:24.871]                             ns <- base::getNamespace("future")
[17:45:24.871]                             version <- ns[[".package"]][["version"]]
[17:45:24.871]                             if (is.null(version)) 
[17:45:24.871]                               version <- utils::packageVersion("future")
[17:45:24.871]                           }
[17:45:24.871]                           else {
[17:45:24.871]                             version <- NULL
[17:45:24.871]                           }
[17:45:24.871]                           if (!has_future || version < "1.8.0") {
[17:45:24.871]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:24.871]                               "", base::R.version$version.string), 
[17:45:24.871]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:24.871]                                 base::R.version$platform, 8 * 
[17:45:24.871]                                   base::.Machine$sizeof.pointer), 
[17:45:24.871]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:24.871]                                 "release", "version")], collapse = " "), 
[17:45:24.871]                               hostname = base::Sys.info()[["nodename"]])
[17:45:24.871]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:24.871]                               info)
[17:45:24.871]                             info <- base::paste(info, collapse = "; ")
[17:45:24.871]                             if (!has_future) {
[17:45:24.871]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:24.871]                                 info)
[17:45:24.871]                             }
[17:45:24.871]                             else {
[17:45:24.871]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:24.871]                                 info, version)
[17:45:24.871]                             }
[17:45:24.871]                             base::stop(msg)
[17:45:24.871]                           }
[17:45:24.871]                         })
[17:45:24.871]                       }
[17:45:24.871]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:24.871]                       base::options(mc.cores = 1L)
[17:45:24.871]                     }
[17:45:24.871]                     base::local({
[17:45:24.871]                       for (pkg in c("stats", "future.apply")) {
[17:45:24.871]                         base::loadNamespace(pkg)
[17:45:24.871]                         base::library(pkg, character.only = TRUE)
[17:45:24.871]                       }
[17:45:24.871]                     })
[17:45:24.871]                   }
[17:45:24.871]                   ...future.strategy.old <- future::plan("list")
[17:45:24.871]                   options(future.plan = NULL)
[17:45:24.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:24.871]                 }
[17:45:24.871]                 ...future.workdir <- getwd()
[17:45:24.871]             }
[17:45:24.871]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:24.871]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:24.871]         }
[17:45:24.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:24.871]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:24.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:24.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:24.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:24.871]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:24.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:24.871]             base::names(...future.oldOptions))
[17:45:24.871]     }
[17:45:24.871]     if (FALSE) {
[17:45:24.871]     }
[17:45:24.871]     else {
[17:45:24.871]         if (TRUE) {
[17:45:24.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:24.871]                 open = "w")
[17:45:24.871]         }
[17:45:24.871]         else {
[17:45:24.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:24.871]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:24.871]         }
[17:45:24.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:24.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:24.871]             base::sink(type = "output", split = FALSE)
[17:45:24.871]             base::close(...future.stdout)
[17:45:24.871]         }, add = TRUE)
[17:45:24.871]     }
[17:45:24.871]     ...future.frame <- base::sys.nframe()
[17:45:24.871]     ...future.conditions <- base::list()
[17:45:24.871]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:24.871]     if (FALSE) {
[17:45:24.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:24.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:24.871]     }
[17:45:24.871]     ...future.result <- base::tryCatch({
[17:45:24.871]         base::withCallingHandlers({
[17:45:24.871]             ...future.value <- base::withVisible(base::local({
[17:45:24.871]                 ...future.makeSendCondition <- base::local({
[17:45:24.871]                   sendCondition <- NULL
[17:45:24.871]                   function(frame = 1L) {
[17:45:24.871]                     if (is.function(sendCondition)) 
[17:45:24.871]                       return(sendCondition)
[17:45:24.871]                     ns <- getNamespace("parallel")
[17:45:24.871]                     if (exists("sendData", mode = "function", 
[17:45:24.871]                       envir = ns)) {
[17:45:24.871]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:24.871]                         envir = ns)
[17:45:24.871]                       envir <- sys.frame(frame)
[17:45:24.871]                       master <- NULL
[17:45:24.871]                       while (!identical(envir, .GlobalEnv) && 
[17:45:24.871]                         !identical(envir, emptyenv())) {
[17:45:24.871]                         if (exists("master", mode = "list", envir = envir, 
[17:45:24.871]                           inherits = FALSE)) {
[17:45:24.871]                           master <- get("master", mode = "list", 
[17:45:24.871]                             envir = envir, inherits = FALSE)
[17:45:24.871]                           if (inherits(master, c("SOCKnode", 
[17:45:24.871]                             "SOCK0node"))) {
[17:45:24.871]                             sendCondition <<- function(cond) {
[17:45:24.871]                               data <- list(type = "VALUE", value = cond, 
[17:45:24.871]                                 success = TRUE)
[17:45:24.871]                               parallel_sendData(master, data)
[17:45:24.871]                             }
[17:45:24.871]                             return(sendCondition)
[17:45:24.871]                           }
[17:45:24.871]                         }
[17:45:24.871]                         frame <- frame + 1L
[17:45:24.871]                         envir <- sys.frame(frame)
[17:45:24.871]                       }
[17:45:24.871]                     }
[17:45:24.871]                     sendCondition <<- function(cond) NULL
[17:45:24.871]                   }
[17:45:24.871]                 })
[17:45:24.871]                 withCallingHandlers({
[17:45:24.871]                   {
[17:45:24.871]                     do.call(function(...) {
[17:45:24.871]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:24.871]                       if (!identical(...future.globals.maxSize.org, 
[17:45:24.871]                         ...future.globals.maxSize)) {
[17:45:24.871]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:24.871]                         on.exit(options(oopts), add = TRUE)
[17:45:24.871]                       }
[17:45:24.871]                       {
[17:45:24.871]                         lapply(seq_along(...future.elements_ii), 
[17:45:24.871]                           FUN = function(jj) {
[17:45:24.871]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:24.871]                             ...future.FUN(...future.X_jj, ...)
[17:45:24.871]                           })
[17:45:24.871]                       }
[17:45:24.871]                     }, args = future.call.arguments)
[17:45:24.871]                   }
[17:45:24.871]                 }, immediateCondition = function(cond) {
[17:45:24.871]                   sendCondition <- ...future.makeSendCondition()
[17:45:24.871]                   sendCondition(cond)
[17:45:24.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.871]                   {
[17:45:24.871]                     inherits <- base::inherits
[17:45:24.871]                     invokeRestart <- base::invokeRestart
[17:45:24.871]                     is.null <- base::is.null
[17:45:24.871]                     muffled <- FALSE
[17:45:24.871]                     if (inherits(cond, "message")) {
[17:45:24.871]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:24.871]                       if (muffled) 
[17:45:24.871]                         invokeRestart("muffleMessage")
[17:45:24.871]                     }
[17:45:24.871]                     else if (inherits(cond, "warning")) {
[17:45:24.871]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:24.871]                       if (muffled) 
[17:45:24.871]                         invokeRestart("muffleWarning")
[17:45:24.871]                     }
[17:45:24.871]                     else if (inherits(cond, "condition")) {
[17:45:24.871]                       if (!is.null(pattern)) {
[17:45:24.871]                         computeRestarts <- base::computeRestarts
[17:45:24.871]                         grepl <- base::grepl
[17:45:24.871]                         restarts <- computeRestarts(cond)
[17:45:24.871]                         for (restart in restarts) {
[17:45:24.871]                           name <- restart$name
[17:45:24.871]                           if (is.null(name)) 
[17:45:24.871]                             next
[17:45:24.871]                           if (!grepl(pattern, name)) 
[17:45:24.871]                             next
[17:45:24.871]                           invokeRestart(restart)
[17:45:24.871]                           muffled <- TRUE
[17:45:24.871]                           break
[17:45:24.871]                         }
[17:45:24.871]                       }
[17:45:24.871]                     }
[17:45:24.871]                     invisible(muffled)
[17:45:24.871]                   }
[17:45:24.871]                   muffleCondition(cond)
[17:45:24.871]                 })
[17:45:24.871]             }))
[17:45:24.871]             future::FutureResult(value = ...future.value$value, 
[17:45:24.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.871]                   ...future.rng), globalenv = if (FALSE) 
[17:45:24.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:24.871]                     ...future.globalenv.names))
[17:45:24.871]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:24.871]         }, condition = base::local({
[17:45:24.871]             c <- base::c
[17:45:24.871]             inherits <- base::inherits
[17:45:24.871]             invokeRestart <- base::invokeRestart
[17:45:24.871]             length <- base::length
[17:45:24.871]             list <- base::list
[17:45:24.871]             seq.int <- base::seq.int
[17:45:24.871]             signalCondition <- base::signalCondition
[17:45:24.871]             sys.calls <- base::sys.calls
[17:45:24.871]             `[[` <- base::`[[`
[17:45:24.871]             `+` <- base::`+`
[17:45:24.871]             `<<-` <- base::`<<-`
[17:45:24.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:24.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:24.871]                   3L)]
[17:45:24.871]             }
[17:45:24.871]             function(cond) {
[17:45:24.871]                 is_error <- inherits(cond, "error")
[17:45:24.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:24.871]                   NULL)
[17:45:24.871]                 if (is_error) {
[17:45:24.871]                   sessionInformation <- function() {
[17:45:24.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:24.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:24.871]                       search = base::search(), system = base::Sys.info())
[17:45:24.871]                   }
[17:45:24.871]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:24.871]                     cond$call), session = sessionInformation(), 
[17:45:24.871]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:24.871]                   signalCondition(cond)
[17:45:24.871]                 }
[17:45:24.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:24.871]                 "immediateCondition"))) {
[17:45:24.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:24.871]                   ...future.conditions[[length(...future.conditions) + 
[17:45:24.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:24.871]                   if (TRUE && !signal) {
[17:45:24.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.871]                     {
[17:45:24.871]                       inherits <- base::inherits
[17:45:24.871]                       invokeRestart <- base::invokeRestart
[17:45:24.871]                       is.null <- base::is.null
[17:45:24.871]                       muffled <- FALSE
[17:45:24.871]                       if (inherits(cond, "message")) {
[17:45:24.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.871]                         if (muffled) 
[17:45:24.871]                           invokeRestart("muffleMessage")
[17:45:24.871]                       }
[17:45:24.871]                       else if (inherits(cond, "warning")) {
[17:45:24.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.871]                         if (muffled) 
[17:45:24.871]                           invokeRestart("muffleWarning")
[17:45:24.871]                       }
[17:45:24.871]                       else if (inherits(cond, "condition")) {
[17:45:24.871]                         if (!is.null(pattern)) {
[17:45:24.871]                           computeRestarts <- base::computeRestarts
[17:45:24.871]                           grepl <- base::grepl
[17:45:24.871]                           restarts <- computeRestarts(cond)
[17:45:24.871]                           for (restart in restarts) {
[17:45:24.871]                             name <- restart$name
[17:45:24.871]                             if (is.null(name)) 
[17:45:24.871]                               next
[17:45:24.871]                             if (!grepl(pattern, name)) 
[17:45:24.871]                               next
[17:45:24.871]                             invokeRestart(restart)
[17:45:24.871]                             muffled <- TRUE
[17:45:24.871]                             break
[17:45:24.871]                           }
[17:45:24.871]                         }
[17:45:24.871]                       }
[17:45:24.871]                       invisible(muffled)
[17:45:24.871]                     }
[17:45:24.871]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.871]                   }
[17:45:24.871]                 }
[17:45:24.871]                 else {
[17:45:24.871]                   if (TRUE) {
[17:45:24.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:24.871]                     {
[17:45:24.871]                       inherits <- base::inherits
[17:45:24.871]                       invokeRestart <- base::invokeRestart
[17:45:24.871]                       is.null <- base::is.null
[17:45:24.871]                       muffled <- FALSE
[17:45:24.871]                       if (inherits(cond, "message")) {
[17:45:24.871]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:24.871]                         if (muffled) 
[17:45:24.871]                           invokeRestart("muffleMessage")
[17:45:24.871]                       }
[17:45:24.871]                       else if (inherits(cond, "warning")) {
[17:45:24.871]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:24.871]                         if (muffled) 
[17:45:24.871]                           invokeRestart("muffleWarning")
[17:45:24.871]                       }
[17:45:24.871]                       else if (inherits(cond, "condition")) {
[17:45:24.871]                         if (!is.null(pattern)) {
[17:45:24.871]                           computeRestarts <- base::computeRestarts
[17:45:24.871]                           grepl <- base::grepl
[17:45:24.871]                           restarts <- computeRestarts(cond)
[17:45:24.871]                           for (restart in restarts) {
[17:45:24.871]                             name <- restart$name
[17:45:24.871]                             if (is.null(name)) 
[17:45:24.871]                               next
[17:45:24.871]                             if (!grepl(pattern, name)) 
[17:45:24.871]                               next
[17:45:24.871]                             invokeRestart(restart)
[17:45:24.871]                             muffled <- TRUE
[17:45:24.871]                             break
[17:45:24.871]                           }
[17:45:24.871]                         }
[17:45:24.871]                       }
[17:45:24.871]                       invisible(muffled)
[17:45:24.871]                     }
[17:45:24.871]                     muffleCondition(cond, pattern = "^muffle")
[17:45:24.871]                   }
[17:45:24.871]                 }
[17:45:24.871]             }
[17:45:24.871]         }))
[17:45:24.871]     }, error = function(ex) {
[17:45:24.871]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:24.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:24.871]                 ...future.rng), started = ...future.startTime, 
[17:45:24.871]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:24.871]             version = "1.8"), class = "FutureResult")
[17:45:24.871]     }, finally = {
[17:45:24.871]         if (!identical(...future.workdir, getwd())) 
[17:45:24.871]             setwd(...future.workdir)
[17:45:24.871]         {
[17:45:24.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:24.871]                 ...future.oldOptions$nwarnings <- NULL
[17:45:24.871]             }
[17:45:24.871]             base::options(...future.oldOptions)
[17:45:24.871]             if (.Platform$OS.type == "windows") {
[17:45:24.871]                 old_names <- names(...future.oldEnvVars)
[17:45:24.871]                 envs <- base::Sys.getenv()
[17:45:24.871]                 names <- names(envs)
[17:45:24.871]                 common <- intersect(names, old_names)
[17:45:24.871]                 added <- setdiff(names, old_names)
[17:45:24.871]                 removed <- setdiff(old_names, names)
[17:45:24.871]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:24.871]                   envs[common]]
[17:45:24.871]                 NAMES <- toupper(changed)
[17:45:24.871]                 args <- list()
[17:45:24.871]                 for (kk in seq_along(NAMES)) {
[17:45:24.871]                   name <- changed[[kk]]
[17:45:24.871]                   NAME <- NAMES[[kk]]
[17:45:24.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.871]                     next
[17:45:24.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.871]                 }
[17:45:24.871]                 NAMES <- toupper(added)
[17:45:24.871]                 for (kk in seq_along(NAMES)) {
[17:45:24.871]                   name <- added[[kk]]
[17:45:24.871]                   NAME <- NAMES[[kk]]
[17:45:24.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.871]                     next
[17:45:24.871]                   args[[name]] <- ""
[17:45:24.871]                 }
[17:45:24.871]                 NAMES <- toupper(removed)
[17:45:24.871]                 for (kk in seq_along(NAMES)) {
[17:45:24.871]                   name <- removed[[kk]]
[17:45:24.871]                   NAME <- NAMES[[kk]]
[17:45:24.871]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:24.871]                     next
[17:45:24.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:24.871]                 }
[17:45:24.871]                 if (length(args) > 0) 
[17:45:24.871]                   base::do.call(base::Sys.setenv, args = args)
[17:45:24.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:24.871]             }
[17:45:24.871]             else {
[17:45:24.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:24.871]             }
[17:45:24.871]             {
[17:45:24.871]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:24.871]                   0L) {
[17:45:24.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:24.871]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:24.871]                   base::options(opts)
[17:45:24.871]                 }
[17:45:24.871]                 {
[17:45:24.871]                   {
[17:45:24.871]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:24.871]                     NULL
[17:45:24.871]                   }
[17:45:24.871]                   options(future.plan = NULL)
[17:45:24.871]                   if (is.na(NA_character_)) 
[17:45:24.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:24.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:24.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:24.871]                     .init = FALSE)
[17:45:24.871]                 }
[17:45:24.871]             }
[17:45:24.871]         }
[17:45:24.871]     })
[17:45:24.871]     if (TRUE) {
[17:45:24.871]         base::sink(type = "output", split = FALSE)
[17:45:24.871]         if (TRUE) {
[17:45:24.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:24.871]         }
[17:45:24.871]         else {
[17:45:24.871]             ...future.result["stdout"] <- base::list(NULL)
[17:45:24.871]         }
[17:45:24.871]         base::close(...future.stdout)
[17:45:24.871]         ...future.stdout <- NULL
[17:45:24.871]     }
[17:45:24.871]     ...future.result$conditions <- ...future.conditions
[17:45:24.871]     ...future.result$finished <- base::Sys.time()
[17:45:24.871]     ...future.result
[17:45:24.871] }
[17:45:24.876] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[17:45:24.876] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:24.920] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:24.920] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[17:45:24.964] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[17:45:24.964] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:24.964] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:24.965] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:25.008] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:25.008] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:25.052] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:25.052] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:25.052] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.052] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:25.053] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:25.053] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:25.053] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.054] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[17:45:25.054] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[17:45:25.054] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:25.055] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:25.055] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.055] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[17:45:25.056] MultisessionFuture started
[17:45:25.056] - Launch lazy future ... done
[17:45:25.056] run() for ‘MultisessionFuture’ ... done
[17:45:25.056] Created future:
[17:45:25.056] MultisessionFuture:
[17:45:25.056] Label: ‘future_vapply-1’
[17:45:25.056] Expression:
[17:45:25.056] {
[17:45:25.056]     do.call(function(...) {
[17:45:25.056]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.056]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.056]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.056]             on.exit(options(oopts), add = TRUE)
[17:45:25.056]         }
[17:45:25.056]         {
[17:45:25.056]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.056]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.056]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.056]             })
[17:45:25.056]         }
[17:45:25.056]     }, args = future.call.arguments)
[17:45:25.056] }
[17:45:25.056] Lazy evaluation: FALSE
[17:45:25.056] Asynchronous evaluation: TRUE
[17:45:25.056] Local evaluation: TRUE
[17:45:25.056] Environment: R_GlobalEnv
[17:45:25.056] Capture standard output: TRUE
[17:45:25.056] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.056] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:25.056] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:25.056] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.056] Resolved: FALSE
[17:45:25.056] Value: <not collected>
[17:45:25.056] Conditions captured: <none>
[17:45:25.056] Early signaling: FALSE
[17:45:25.056] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.056] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.068] Chunk #1 of 2 ... DONE
[17:45:25.068] Chunk #2 of 2 ...
[17:45:25.069]  - Finding globals in 'X' for chunk #2 ...
[17:45:25.069] getGlobalsAndPackages() ...
[17:45:25.069] Searching for globals...
[17:45:25.069] 
[17:45:25.069] Searching for globals ... DONE
[17:45:25.069] - globals: [0] <none>
[17:45:25.069] getGlobalsAndPackages() ... DONE
[17:45:25.069]    + additional globals found: [n=0] 
[17:45:25.069]    + additional namespaces needed: [n=0] 
[17:45:25.070]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:25.070]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.070]  - seeds: <none>
[17:45:25.070]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.070] getGlobalsAndPackages() ...
[17:45:25.070] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.070] Resolving globals: FALSE
[17:45:25.070] Tweak future expression to call with '...' arguments ...
[17:45:25.070] {
[17:45:25.070]     do.call(function(...) {
[17:45:25.070]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.070]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.070]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.070]             on.exit(options(oopts), add = TRUE)
[17:45:25.070]         }
[17:45:25.070]         {
[17:45:25.070]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.070]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.070]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.070]             })
[17:45:25.070]         }
[17:45:25.070]     }, args = future.call.arguments)
[17:45:25.070] }
[17:45:25.071] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.071] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.071] - packages: [2] ‘stats’, ‘future.apply’
[17:45:25.072] getGlobalsAndPackages() ... DONE
[17:45:25.072] run() for ‘Future’ ...
[17:45:25.072] - state: ‘created’
[17:45:25.072] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:25.086] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:25.087]   - Field: ‘node’
[17:45:25.087]   - Field: ‘label’
[17:45:25.087]   - Field: ‘local’
[17:45:25.087]   - Field: ‘owner’
[17:45:25.087]   - Field: ‘envir’
[17:45:25.087]   - Field: ‘workers’
[17:45:25.087]   - Field: ‘packages’
[17:45:25.087]   - Field: ‘gc’
[17:45:25.087]   - Field: ‘conditions’
[17:45:25.088]   - Field: ‘persistent’
[17:45:25.088]   - Field: ‘expr’
[17:45:25.088]   - Field: ‘uuid’
[17:45:25.088]   - Field: ‘seed’
[17:45:25.088]   - Field: ‘version’
[17:45:25.088]   - Field: ‘result’
[17:45:25.088]   - Field: ‘asynchronous’
[17:45:25.088]   - Field: ‘calls’
[17:45:25.088]   - Field: ‘globals’
[17:45:25.088]   - Field: ‘stdout’
[17:45:25.088]   - Field: ‘earlySignal’
[17:45:25.089]   - Field: ‘lazy’
[17:45:25.089]   - Field: ‘state’
[17:45:25.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:25.089] - Launch lazy future ...
[17:45:25.089] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[17:45:25.089] Packages needed by future strategies (n = 0): <none>
[17:45:25.090] {
[17:45:25.090]     {
[17:45:25.090]         {
[17:45:25.090]             ...future.startTime <- base::Sys.time()
[17:45:25.090]             {
[17:45:25.090]                 {
[17:45:25.090]                   {
[17:45:25.090]                     {
[17:45:25.090]                       {
[17:45:25.090]                         base::local({
[17:45:25.090]                           has_future <- base::requireNamespace("future", 
[17:45:25.090]                             quietly = TRUE)
[17:45:25.090]                           if (has_future) {
[17:45:25.090]                             ns <- base::getNamespace("future")
[17:45:25.090]                             version <- ns[[".package"]][["version"]]
[17:45:25.090]                             if (is.null(version)) 
[17:45:25.090]                               version <- utils::packageVersion("future")
[17:45:25.090]                           }
[17:45:25.090]                           else {
[17:45:25.090]                             version <- NULL
[17:45:25.090]                           }
[17:45:25.090]                           if (!has_future || version < "1.8.0") {
[17:45:25.090]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:25.090]                               "", base::R.version$version.string), 
[17:45:25.090]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:25.090]                                 base::R.version$platform, 8 * 
[17:45:25.090]                                   base::.Machine$sizeof.pointer), 
[17:45:25.090]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:25.090]                                 "release", "version")], collapse = " "), 
[17:45:25.090]                               hostname = base::Sys.info()[["nodename"]])
[17:45:25.090]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:25.090]                               info)
[17:45:25.090]                             info <- base::paste(info, collapse = "; ")
[17:45:25.090]                             if (!has_future) {
[17:45:25.090]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:25.090]                                 info)
[17:45:25.090]                             }
[17:45:25.090]                             else {
[17:45:25.090]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:25.090]                                 info, version)
[17:45:25.090]                             }
[17:45:25.090]                             base::stop(msg)
[17:45:25.090]                           }
[17:45:25.090]                         })
[17:45:25.090]                       }
[17:45:25.090]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:25.090]                       base::options(mc.cores = 1L)
[17:45:25.090]                     }
[17:45:25.090]                     base::local({
[17:45:25.090]                       for (pkg in c("stats", "future.apply")) {
[17:45:25.090]                         base::loadNamespace(pkg)
[17:45:25.090]                         base::library(pkg, character.only = TRUE)
[17:45:25.090]                       }
[17:45:25.090]                     })
[17:45:25.090]                   }
[17:45:25.090]                   ...future.strategy.old <- future::plan("list")
[17:45:25.090]                   options(future.plan = NULL)
[17:45:25.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:25.090]                 }
[17:45:25.090]                 ...future.workdir <- getwd()
[17:45:25.090]             }
[17:45:25.090]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:25.090]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:25.090]         }
[17:45:25.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:25.090]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:25.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:25.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:25.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:25.090]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:25.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:25.090]             base::names(...future.oldOptions))
[17:45:25.090]     }
[17:45:25.090]     if (FALSE) {
[17:45:25.090]     }
[17:45:25.090]     else {
[17:45:25.090]         if (TRUE) {
[17:45:25.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:25.090]                 open = "w")
[17:45:25.090]         }
[17:45:25.090]         else {
[17:45:25.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:25.090]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:25.090]         }
[17:45:25.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:25.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:25.090]             base::sink(type = "output", split = FALSE)
[17:45:25.090]             base::close(...future.stdout)
[17:45:25.090]         }, add = TRUE)
[17:45:25.090]     }
[17:45:25.090]     ...future.frame <- base::sys.nframe()
[17:45:25.090]     ...future.conditions <- base::list()
[17:45:25.090]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:25.090]     if (FALSE) {
[17:45:25.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:25.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:25.090]     }
[17:45:25.090]     ...future.result <- base::tryCatch({
[17:45:25.090]         base::withCallingHandlers({
[17:45:25.090]             ...future.value <- base::withVisible(base::local({
[17:45:25.090]                 ...future.makeSendCondition <- base::local({
[17:45:25.090]                   sendCondition <- NULL
[17:45:25.090]                   function(frame = 1L) {
[17:45:25.090]                     if (is.function(sendCondition)) 
[17:45:25.090]                       return(sendCondition)
[17:45:25.090]                     ns <- getNamespace("parallel")
[17:45:25.090]                     if (exists("sendData", mode = "function", 
[17:45:25.090]                       envir = ns)) {
[17:45:25.090]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:25.090]                         envir = ns)
[17:45:25.090]                       envir <- sys.frame(frame)
[17:45:25.090]                       master <- NULL
[17:45:25.090]                       while (!identical(envir, .GlobalEnv) && 
[17:45:25.090]                         !identical(envir, emptyenv())) {
[17:45:25.090]                         if (exists("master", mode = "list", envir = envir, 
[17:45:25.090]                           inherits = FALSE)) {
[17:45:25.090]                           master <- get("master", mode = "list", 
[17:45:25.090]                             envir = envir, inherits = FALSE)
[17:45:25.090]                           if (inherits(master, c("SOCKnode", 
[17:45:25.090]                             "SOCK0node"))) {
[17:45:25.090]                             sendCondition <<- function(cond) {
[17:45:25.090]                               data <- list(type = "VALUE", value = cond, 
[17:45:25.090]                                 success = TRUE)
[17:45:25.090]                               parallel_sendData(master, data)
[17:45:25.090]                             }
[17:45:25.090]                             return(sendCondition)
[17:45:25.090]                           }
[17:45:25.090]                         }
[17:45:25.090]                         frame <- frame + 1L
[17:45:25.090]                         envir <- sys.frame(frame)
[17:45:25.090]                       }
[17:45:25.090]                     }
[17:45:25.090]                     sendCondition <<- function(cond) NULL
[17:45:25.090]                   }
[17:45:25.090]                 })
[17:45:25.090]                 withCallingHandlers({
[17:45:25.090]                   {
[17:45:25.090]                     do.call(function(...) {
[17:45:25.090]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.090]                       if (!identical(...future.globals.maxSize.org, 
[17:45:25.090]                         ...future.globals.maxSize)) {
[17:45:25.090]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.090]                         on.exit(options(oopts), add = TRUE)
[17:45:25.090]                       }
[17:45:25.090]                       {
[17:45:25.090]                         lapply(seq_along(...future.elements_ii), 
[17:45:25.090]                           FUN = function(jj) {
[17:45:25.090]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.090]                             ...future.FUN(...future.X_jj, ...)
[17:45:25.090]                           })
[17:45:25.090]                       }
[17:45:25.090]                     }, args = future.call.arguments)
[17:45:25.090]                   }
[17:45:25.090]                 }, immediateCondition = function(cond) {
[17:45:25.090]                   sendCondition <- ...future.makeSendCondition()
[17:45:25.090]                   sendCondition(cond)
[17:45:25.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.090]                   {
[17:45:25.090]                     inherits <- base::inherits
[17:45:25.090]                     invokeRestart <- base::invokeRestart
[17:45:25.090]                     is.null <- base::is.null
[17:45:25.090]                     muffled <- FALSE
[17:45:25.090]                     if (inherits(cond, "message")) {
[17:45:25.090]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:25.090]                       if (muffled) 
[17:45:25.090]                         invokeRestart("muffleMessage")
[17:45:25.090]                     }
[17:45:25.090]                     else if (inherits(cond, "warning")) {
[17:45:25.090]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:25.090]                       if (muffled) 
[17:45:25.090]                         invokeRestart("muffleWarning")
[17:45:25.090]                     }
[17:45:25.090]                     else if (inherits(cond, "condition")) {
[17:45:25.090]                       if (!is.null(pattern)) {
[17:45:25.090]                         computeRestarts <- base::computeRestarts
[17:45:25.090]                         grepl <- base::grepl
[17:45:25.090]                         restarts <- computeRestarts(cond)
[17:45:25.090]                         for (restart in restarts) {
[17:45:25.090]                           name <- restart$name
[17:45:25.090]                           if (is.null(name)) 
[17:45:25.090]                             next
[17:45:25.090]                           if (!grepl(pattern, name)) 
[17:45:25.090]                             next
[17:45:25.090]                           invokeRestart(restart)
[17:45:25.090]                           muffled <- TRUE
[17:45:25.090]                           break
[17:45:25.090]                         }
[17:45:25.090]                       }
[17:45:25.090]                     }
[17:45:25.090]                     invisible(muffled)
[17:45:25.090]                   }
[17:45:25.090]                   muffleCondition(cond)
[17:45:25.090]                 })
[17:45:25.090]             }))
[17:45:25.090]             future::FutureResult(value = ...future.value$value, 
[17:45:25.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.090]                   ...future.rng), globalenv = if (FALSE) 
[17:45:25.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:25.090]                     ...future.globalenv.names))
[17:45:25.090]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:25.090]         }, condition = base::local({
[17:45:25.090]             c <- base::c
[17:45:25.090]             inherits <- base::inherits
[17:45:25.090]             invokeRestart <- base::invokeRestart
[17:45:25.090]             length <- base::length
[17:45:25.090]             list <- base::list
[17:45:25.090]             seq.int <- base::seq.int
[17:45:25.090]             signalCondition <- base::signalCondition
[17:45:25.090]             sys.calls <- base::sys.calls
[17:45:25.090]             `[[` <- base::`[[`
[17:45:25.090]             `+` <- base::`+`
[17:45:25.090]             `<<-` <- base::`<<-`
[17:45:25.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:25.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:25.090]                   3L)]
[17:45:25.090]             }
[17:45:25.090]             function(cond) {
[17:45:25.090]                 is_error <- inherits(cond, "error")
[17:45:25.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:25.090]                   NULL)
[17:45:25.090]                 if (is_error) {
[17:45:25.090]                   sessionInformation <- function() {
[17:45:25.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:25.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:25.090]                       search = base::search(), system = base::Sys.info())
[17:45:25.090]                   }
[17:45:25.090]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:25.090]                     cond$call), session = sessionInformation(), 
[17:45:25.090]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:25.090]                   signalCondition(cond)
[17:45:25.090]                 }
[17:45:25.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:25.090]                 "immediateCondition"))) {
[17:45:25.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:25.090]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:25.090]                   if (TRUE && !signal) {
[17:45:25.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.090]                     {
[17:45:25.090]                       inherits <- base::inherits
[17:45:25.090]                       invokeRestart <- base::invokeRestart
[17:45:25.090]                       is.null <- base::is.null
[17:45:25.090]                       muffled <- FALSE
[17:45:25.090]                       if (inherits(cond, "message")) {
[17:45:25.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.090]                         if (muffled) 
[17:45:25.090]                           invokeRestart("muffleMessage")
[17:45:25.090]                       }
[17:45:25.090]                       else if (inherits(cond, "warning")) {
[17:45:25.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.090]                         if (muffled) 
[17:45:25.090]                           invokeRestart("muffleWarning")
[17:45:25.090]                       }
[17:45:25.090]                       else if (inherits(cond, "condition")) {
[17:45:25.090]                         if (!is.null(pattern)) {
[17:45:25.090]                           computeRestarts <- base::computeRestarts
[17:45:25.090]                           grepl <- base::grepl
[17:45:25.090]                           restarts <- computeRestarts(cond)
[17:45:25.090]                           for (restart in restarts) {
[17:45:25.090]                             name <- restart$name
[17:45:25.090]                             if (is.null(name)) 
[17:45:25.090]                               next
[17:45:25.090]                             if (!grepl(pattern, name)) 
[17:45:25.090]                               next
[17:45:25.090]                             invokeRestart(restart)
[17:45:25.090]                             muffled <- TRUE
[17:45:25.090]                             break
[17:45:25.090]                           }
[17:45:25.090]                         }
[17:45:25.090]                       }
[17:45:25.090]                       invisible(muffled)
[17:45:25.090]                     }
[17:45:25.090]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.090]                   }
[17:45:25.090]                 }
[17:45:25.090]                 else {
[17:45:25.090]                   if (TRUE) {
[17:45:25.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.090]                     {
[17:45:25.090]                       inherits <- base::inherits
[17:45:25.090]                       invokeRestart <- base::invokeRestart
[17:45:25.090]                       is.null <- base::is.null
[17:45:25.090]                       muffled <- FALSE
[17:45:25.090]                       if (inherits(cond, "message")) {
[17:45:25.090]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.090]                         if (muffled) 
[17:45:25.090]                           invokeRestart("muffleMessage")
[17:45:25.090]                       }
[17:45:25.090]                       else if (inherits(cond, "warning")) {
[17:45:25.090]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.090]                         if (muffled) 
[17:45:25.090]                           invokeRestart("muffleWarning")
[17:45:25.090]                       }
[17:45:25.090]                       else if (inherits(cond, "condition")) {
[17:45:25.090]                         if (!is.null(pattern)) {
[17:45:25.090]                           computeRestarts <- base::computeRestarts
[17:45:25.090]                           grepl <- base::grepl
[17:45:25.090]                           restarts <- computeRestarts(cond)
[17:45:25.090]                           for (restart in restarts) {
[17:45:25.090]                             name <- restart$name
[17:45:25.090]                             if (is.null(name)) 
[17:45:25.090]                               next
[17:45:25.090]                             if (!grepl(pattern, name)) 
[17:45:25.090]                               next
[17:45:25.090]                             invokeRestart(restart)
[17:45:25.090]                             muffled <- TRUE
[17:45:25.090]                             break
[17:45:25.090]                           }
[17:45:25.090]                         }
[17:45:25.090]                       }
[17:45:25.090]                       invisible(muffled)
[17:45:25.090]                     }
[17:45:25.090]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.090]                   }
[17:45:25.090]                 }
[17:45:25.090]             }
[17:45:25.090]         }))
[17:45:25.090]     }, error = function(ex) {
[17:45:25.090]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:25.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.090]                 ...future.rng), started = ...future.startTime, 
[17:45:25.090]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:25.090]             version = "1.8"), class = "FutureResult")
[17:45:25.090]     }, finally = {
[17:45:25.090]         if (!identical(...future.workdir, getwd())) 
[17:45:25.090]             setwd(...future.workdir)
[17:45:25.090]         {
[17:45:25.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:25.090]                 ...future.oldOptions$nwarnings <- NULL
[17:45:25.090]             }
[17:45:25.090]             base::options(...future.oldOptions)
[17:45:25.090]             if (.Platform$OS.type == "windows") {
[17:45:25.090]                 old_names <- names(...future.oldEnvVars)
[17:45:25.090]                 envs <- base::Sys.getenv()
[17:45:25.090]                 names <- names(envs)
[17:45:25.090]                 common <- intersect(names, old_names)
[17:45:25.090]                 added <- setdiff(names, old_names)
[17:45:25.090]                 removed <- setdiff(old_names, names)
[17:45:25.090]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:25.090]                   envs[common]]
[17:45:25.090]                 NAMES <- toupper(changed)
[17:45:25.090]                 args <- list()
[17:45:25.090]                 for (kk in seq_along(NAMES)) {
[17:45:25.090]                   name <- changed[[kk]]
[17:45:25.090]                   NAME <- NAMES[[kk]]
[17:45:25.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.090]                     next
[17:45:25.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.090]                 }
[17:45:25.090]                 NAMES <- toupper(added)
[17:45:25.090]                 for (kk in seq_along(NAMES)) {
[17:45:25.090]                   name <- added[[kk]]
[17:45:25.090]                   NAME <- NAMES[[kk]]
[17:45:25.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.090]                     next
[17:45:25.090]                   args[[name]] <- ""
[17:45:25.090]                 }
[17:45:25.090]                 NAMES <- toupper(removed)
[17:45:25.090]                 for (kk in seq_along(NAMES)) {
[17:45:25.090]                   name <- removed[[kk]]
[17:45:25.090]                   NAME <- NAMES[[kk]]
[17:45:25.090]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.090]                     next
[17:45:25.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.090]                 }
[17:45:25.090]                 if (length(args) > 0) 
[17:45:25.090]                   base::do.call(base::Sys.setenv, args = args)
[17:45:25.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:25.090]             }
[17:45:25.090]             else {
[17:45:25.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:25.090]             }
[17:45:25.090]             {
[17:45:25.090]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:25.090]                   0L) {
[17:45:25.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:25.090]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:25.090]                   base::options(opts)
[17:45:25.090]                 }
[17:45:25.090]                 {
[17:45:25.090]                   {
[17:45:25.090]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:25.090]                     NULL
[17:45:25.090]                   }
[17:45:25.090]                   options(future.plan = NULL)
[17:45:25.090]                   if (is.na(NA_character_)) 
[17:45:25.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:25.090]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:25.090]                     .init = FALSE)
[17:45:25.090]                 }
[17:45:25.090]             }
[17:45:25.090]         }
[17:45:25.090]     })
[17:45:25.090]     if (TRUE) {
[17:45:25.090]         base::sink(type = "output", split = FALSE)
[17:45:25.090]         if (TRUE) {
[17:45:25.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:25.090]         }
[17:45:25.090]         else {
[17:45:25.090]             ...future.result["stdout"] <- base::list(NULL)
[17:45:25.090]         }
[17:45:25.090]         base::close(...future.stdout)
[17:45:25.090]         ...future.stdout <- NULL
[17:45:25.090]     }
[17:45:25.090]     ...future.result$conditions <- ...future.conditions
[17:45:25.090]     ...future.result$finished <- base::Sys.time()
[17:45:25.090]     ...future.result
[17:45:25.090] }
[17:45:25.093] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[17:45:25.093] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:25.136] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:25.136] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[17:45:25.180] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[17:45:25.180] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:25.181] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:25.181] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:25.224] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:25.224] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:25.268] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:25.268] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:25.269] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.269] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:45:25.269] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:45:25.269] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:25.270] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.270] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[17:45:25.270] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[17:45:25.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:25.271] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.271] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:25.272] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.272] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[17:45:25.272] MultisessionFuture started
[17:45:25.272] - Launch lazy future ... done
[17:45:25.272] run() for ‘MultisessionFuture’ ... done
[17:45:25.273] Created future:
[17:45:25.274] receiveMessageFromWorker() for ClusterFuture ...
[17:45:25.274] - Validating connection of MultisessionFuture
[17:45:25.274] - received message: FutureResult
[17:45:25.275] - Received FutureResult
[17:45:25.275] - Erased future from FutureRegistry
[17:45:25.275] result() for ClusterFuture ...
[17:45:25.275] - result already collected: FutureResult
[17:45:25.275] result() for ClusterFuture ... done
[17:45:25.275] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:25.273] MultisessionFuture:
[17:45:25.273] Label: ‘future_vapply-2’
[17:45:25.273] Expression:
[17:45:25.273] {
[17:45:25.273]     do.call(function(...) {
[17:45:25.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.273]             on.exit(options(oopts), add = TRUE)
[17:45:25.273]         }
[17:45:25.273]         {
[17:45:25.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.273]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.273]             })
[17:45:25.273]         }
[17:45:25.273]     }, args = future.call.arguments)
[17:45:25.273] }
[17:45:25.273] Lazy evaluation: FALSE
[17:45:25.273] Asynchronous evaluation: TRUE
[17:45:25.273] Local evaluation: TRUE
[17:45:25.273] Environment: R_GlobalEnv
[17:45:25.273] Capture standard output: TRUE
[17:45:25.273] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.273] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:25.273] Packages: 2 packages (‘stats’, ‘future.apply’)
[17:45:25.273] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.273] Resolved: TRUE
[17:45:25.273] Value: <not collected>
[17:45:25.273] Conditions captured: <none>
[17:45:25.273] Early signaling: FALSE
[17:45:25.273] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.273] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.275] Chunk #2 of 2 ... DONE
[17:45:25.275] Launching 2 futures (chunks) ... DONE
[17:45:25.275] Resolving 2 futures (chunks) ...
[17:45:25.276] resolve() on list ...
[17:45:25.276]  recursive: 0
[17:45:25.276]  length: 2
[17:45:25.276] 
[17:45:25.276] receiveMessageFromWorker() for ClusterFuture ...
[17:45:25.276] - Validating connection of MultisessionFuture
[17:45:25.277] - received message: FutureResult
[17:45:25.277] - Received FutureResult
[17:45:25.277] - Erased future from FutureRegistry
[17:45:25.277] result() for ClusterFuture ...
[17:45:25.277] - result already collected: FutureResult
[17:45:25.277] result() for ClusterFuture ... done
[17:45:25.277] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:25.277] Future #1
[17:45:25.277] result() for ClusterFuture ...
[17:45:25.285] - result already collected: FutureResult
[17:45:25.286] result() for ClusterFuture ... done
[17:45:25.286] result() for ClusterFuture ...
[17:45:25.286] - result already collected: FutureResult
[17:45:25.286] result() for ClusterFuture ... done
[17:45:25.286] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:25.286] - nx: 2
[17:45:25.286] - relay: TRUE
[17:45:25.286] - stdout: TRUE
[17:45:25.287] - signal: TRUE
[17:45:25.287] - resignal: FALSE
[17:45:25.287] - force: TRUE
[17:45:25.287] - relayed: [n=2] FALSE, FALSE
[17:45:25.287] - queued futures: [n=2] FALSE, FALSE
[17:45:25.287]  - until=1
[17:45:25.287]  - relaying element #1
[17:45:25.287] result() for ClusterFuture ...
[17:45:25.287] - result already collected: FutureResult
[17:45:25.287] result() for ClusterFuture ... done
[17:45:25.287] result() for ClusterFuture ...
[17:45:25.288] - result already collected: FutureResult
[17:45:25.288] result() for ClusterFuture ... done
[17:45:25.288] result() for ClusterFuture ...
[17:45:25.288] - result already collected: FutureResult
[17:45:25.288] result() for ClusterFuture ... done
[17:45:25.288] result() for ClusterFuture ...
[17:45:25.288] - result already collected: FutureResult
[17:45:25.288] result() for ClusterFuture ... done
[17:45:25.288] - relayed: [n=2] TRUE, FALSE
[17:45:25.288] - queued futures: [n=2] TRUE, FALSE
[17:45:25.288] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:25.289]  length: 1 (resolved future 1)
[17:45:25.289] Future #2
[17:45:25.289] result() for ClusterFuture ...
[17:45:25.289] - result already collected: FutureResult
[17:45:25.289] result() for ClusterFuture ... done
[17:45:25.289] result() for ClusterFuture ...
[17:45:25.289] - result already collected: FutureResult
[17:45:25.289] result() for ClusterFuture ... done
[17:45:25.289] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:25.289] - nx: 2
[17:45:25.289] - relay: TRUE
[17:45:25.289] - stdout: TRUE
[17:45:25.290] - signal: TRUE
[17:45:25.290] - resignal: FALSE
[17:45:25.290] - force: TRUE
[17:45:25.290] - relayed: [n=2] TRUE, FALSE
[17:45:25.290] - queued futures: [n=2] TRUE, FALSE
[17:45:25.290]  - until=2
[17:45:25.290]  - relaying element #2
[17:45:25.290] result() for ClusterFuture ...
[17:45:25.290] - result already collected: FutureResult
[17:45:25.290] result() for ClusterFuture ... done
[17:45:25.290] result() for ClusterFuture ...
[17:45:25.290] - result already collected: FutureResult
[17:45:25.290] result() for ClusterFuture ... done
[17:45:25.291] result() for ClusterFuture ...
[17:45:25.291] - result already collected: FutureResult
[17:45:25.291] result() for ClusterFuture ... done
[17:45:25.291] result() for ClusterFuture ...
[17:45:25.291] - result already collected: FutureResult
[17:45:25.291] result() for ClusterFuture ... done
[17:45:25.291] - relayed: [n=2] TRUE, TRUE
[17:45:25.291] - queued futures: [n=2] TRUE, TRUE
[17:45:25.291] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:25.291]  length: 0 (resolved future 2)
[17:45:25.291] Relaying remaining futures
[17:45:25.292] signalConditionsASAP(NULL, pos=0) ...
[17:45:25.292] - nx: 2
[17:45:25.292] - relay: TRUE
[17:45:25.292] - stdout: TRUE
[17:45:25.292] - signal: TRUE
[17:45:25.292] - resignal: FALSE
[17:45:25.292] - force: TRUE
[17:45:25.292] - relayed: [n=2] TRUE, TRUE
[17:45:25.292] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:25.292] - relayed: [n=2] TRUE, TRUE
[17:45:25.292] - queued futures: [n=2] TRUE, TRUE
[17:45:25.292] signalConditionsASAP(NULL, pos=0) ... done
[17:45:25.293] resolve() on list ... DONE
[17:45:25.293] result() for ClusterFuture ...
[17:45:25.293] - result already collected: FutureResult
[17:45:25.293] result() for ClusterFuture ... done
[17:45:25.293] result() for ClusterFuture ...
[17:45:25.293] - result already collected: FutureResult
[17:45:25.293] result() for ClusterFuture ... done
[17:45:25.293] result() for ClusterFuture ...
[17:45:25.293] - result already collected: FutureResult
[17:45:25.293] result() for ClusterFuture ... done
[17:45:25.293] result() for ClusterFuture ...
[17:45:25.293] - result already collected: FutureResult
[17:45:25.294] result() for ClusterFuture ... done
[17:45:25.294]  - Number of value chunks collected: 2
[17:45:25.294] Resolving 2 futures (chunks) ... DONE
[17:45:25.294] Reducing values from 2 chunks ...
[17:45:25.294]  - Number of values collected after concatenation: 7
[17:45:25.294]  - Number of values expected: 7
[17:45:25.294] Reducing values from 2 chunks ... DONE
[17:45:25.294] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[17:45:25.296] future_lapply() ...
[17:45:25.300] Number of chunks: 2
[17:45:25.300] getGlobalsAndPackagesXApply() ...
[17:45:25.300]  - future.globals: TRUE
[17:45:25.300] getGlobalsAndPackages() ...
[17:45:25.301] Searching for globals...
[17:45:25.302] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[17:45:25.302] Searching for globals ... DONE
[17:45:25.302] Resolving globals: FALSE
[17:45:25.302] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[17:45:25.303] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[17:45:25.303] - globals: [1] ‘FUN’
[17:45:25.303] 
[17:45:25.303] getGlobalsAndPackages() ... DONE
[17:45:25.303]  - globals found/used: [n=1] ‘FUN’
[17:45:25.303]  - needed namespaces: [n=0] 
[17:45:25.303] Finding globals ... DONE
[17:45:25.303]  - use_args: TRUE
[17:45:25.304]  - Getting '...' globals ...
[17:45:25.304] resolve() on list ...
[17:45:25.304]  recursive: 0
[17:45:25.304]  length: 1
[17:45:25.304]  elements: ‘...’
[17:45:25.304]  length: 0 (resolved future 1)
[17:45:25.304] resolve() on list ... DONE
[17:45:25.304]    - '...' content: [n=1] ‘y’
[17:45:25.305] List of 1
[17:45:25.305]  $ ...:List of 1
[17:45:25.305]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:25.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:25.305]  - attr(*, "where")=List of 1
[17:45:25.305]   ..$ ...:<environment: 0x5561f53dada8> 
[17:45:25.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:25.305]  - attr(*, "resolved")= logi TRUE
[17:45:25.305]  - attr(*, "total_size")= num NA
[17:45:25.307]  - Getting '...' globals ... DONE
[17:45:25.308] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[17:45:25.308] List of 2
[17:45:25.308]  $ ...future.FUN:function (x, y)  
[17:45:25.308]  $ ...          :List of 1
[17:45:25.308]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:25.308]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:25.308]  - attr(*, "where")=List of 2
[17:45:25.308]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:25.308]   ..$ ...          :<environment: 0x5561f53dada8> 
[17:45:25.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:25.308]  - attr(*, "resolved")= logi FALSE
[17:45:25.308]  - attr(*, "total_size")= num 4264
[17:45:25.311] Packages to be attached in all futures: [n=0] 
[17:45:25.311] getGlobalsAndPackagesXApply() ... DONE
[17:45:25.311] Number of futures (= number of chunks): 2
[17:45:25.311] Launching 2 futures (chunks) ...
[17:45:25.311] Chunk #1 of 2 ...
[17:45:25.311]  - Finding globals in 'X' for chunk #1 ...
[17:45:25.311] getGlobalsAndPackages() ...
[17:45:25.312] Searching for globals...
[17:45:25.312] 
[17:45:25.312] Searching for globals ... DONE
[17:45:25.312] - globals: [0] <none>
[17:45:25.312] getGlobalsAndPackages() ... DONE
[17:45:25.312]    + additional globals found: [n=0] 
[17:45:25.312]    + additional namespaces needed: [n=0] 
[17:45:25.312]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:25.312]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.312]  - seeds: <none>
[17:45:25.313]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.313] getGlobalsAndPackages() ...
[17:45:25.313] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.313] Resolving globals: FALSE
[17:45:25.313] Tweak future expression to call with '...' arguments ...
[17:45:25.313] {
[17:45:25.313]     do.call(function(...) {
[17:45:25.313]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.313]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.313]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.313]             on.exit(options(oopts), add = TRUE)
[17:45:25.313]         }
[17:45:25.313]         {
[17:45:25.313]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.313]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.313]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.313]             })
[17:45:25.313]         }
[17:45:25.313]     }, args = future.call.arguments)
[17:45:25.313] }
[17:45:25.313] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.314] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.314] 
[17:45:25.314] getGlobalsAndPackages() ... DONE
[17:45:25.314] run() for ‘Future’ ...
[17:45:25.314] - state: ‘created’
[17:45:25.314] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:25.328] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:25.328]   - Field: ‘node’
[17:45:25.329]   - Field: ‘label’
[17:45:25.329]   - Field: ‘local’
[17:45:25.329]   - Field: ‘owner’
[17:45:25.329]   - Field: ‘envir’
[17:45:25.329]   - Field: ‘workers’
[17:45:25.329]   - Field: ‘packages’
[17:45:25.329]   - Field: ‘gc’
[17:45:25.329]   - Field: ‘conditions’
[17:45:25.329]   - Field: ‘persistent’
[17:45:25.329]   - Field: ‘expr’
[17:45:25.329]   - Field: ‘uuid’
[17:45:25.330]   - Field: ‘seed’
[17:45:25.330]   - Field: ‘version’
[17:45:25.330]   - Field: ‘result’
[17:45:25.330]   - Field: ‘asynchronous’
[17:45:25.330]   - Field: ‘calls’
[17:45:25.330]   - Field: ‘globals’
[17:45:25.330]   - Field: ‘stdout’
[17:45:25.330]   - Field: ‘earlySignal’
[17:45:25.330]   - Field: ‘lazy’
[17:45:25.330]   - Field: ‘state’
[17:45:25.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:25.331] - Launch lazy future ...
[17:45:25.331] Packages needed by the future expression (n = 0): <none>
[17:45:25.331] Packages needed by future strategies (n = 0): <none>
[17:45:25.331] {
[17:45:25.331]     {
[17:45:25.331]         {
[17:45:25.331]             ...future.startTime <- base::Sys.time()
[17:45:25.331]             {
[17:45:25.331]                 {
[17:45:25.331]                   {
[17:45:25.331]                     {
[17:45:25.331]                       base::local({
[17:45:25.331]                         has_future <- base::requireNamespace("future", 
[17:45:25.331]                           quietly = TRUE)
[17:45:25.331]                         if (has_future) {
[17:45:25.331]                           ns <- base::getNamespace("future")
[17:45:25.331]                           version <- ns[[".package"]][["version"]]
[17:45:25.331]                           if (is.null(version)) 
[17:45:25.331]                             version <- utils::packageVersion("future")
[17:45:25.331]                         }
[17:45:25.331]                         else {
[17:45:25.331]                           version <- NULL
[17:45:25.331]                         }
[17:45:25.331]                         if (!has_future || version < "1.8.0") {
[17:45:25.331]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:25.331]                             "", base::R.version$version.string), 
[17:45:25.331]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:25.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:25.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:25.331]                               "release", "version")], collapse = " "), 
[17:45:25.331]                             hostname = base::Sys.info()[["nodename"]])
[17:45:25.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:25.331]                             info)
[17:45:25.331]                           info <- base::paste(info, collapse = "; ")
[17:45:25.331]                           if (!has_future) {
[17:45:25.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:25.331]                               info)
[17:45:25.331]                           }
[17:45:25.331]                           else {
[17:45:25.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:25.331]                               info, version)
[17:45:25.331]                           }
[17:45:25.331]                           base::stop(msg)
[17:45:25.331]                         }
[17:45:25.331]                       })
[17:45:25.331]                     }
[17:45:25.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:25.331]                     base::options(mc.cores = 1L)
[17:45:25.331]                   }
[17:45:25.331]                   ...future.strategy.old <- future::plan("list")
[17:45:25.331]                   options(future.plan = NULL)
[17:45:25.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:25.331]                 }
[17:45:25.331]                 ...future.workdir <- getwd()
[17:45:25.331]             }
[17:45:25.331]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:25.331]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:25.331]         }
[17:45:25.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:25.331]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:25.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:25.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:25.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:25.331]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:25.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:25.331]             base::names(...future.oldOptions))
[17:45:25.331]     }
[17:45:25.331]     if (FALSE) {
[17:45:25.331]     }
[17:45:25.331]     else {
[17:45:25.331]         if (TRUE) {
[17:45:25.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:25.331]                 open = "w")
[17:45:25.331]         }
[17:45:25.331]         else {
[17:45:25.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:25.331]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:25.331]         }
[17:45:25.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:25.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:25.331]             base::sink(type = "output", split = FALSE)
[17:45:25.331]             base::close(...future.stdout)
[17:45:25.331]         }, add = TRUE)
[17:45:25.331]     }
[17:45:25.331]     ...future.frame <- base::sys.nframe()
[17:45:25.331]     ...future.conditions <- base::list()
[17:45:25.331]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:25.331]     if (FALSE) {
[17:45:25.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:25.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:25.331]     }
[17:45:25.331]     ...future.result <- base::tryCatch({
[17:45:25.331]         base::withCallingHandlers({
[17:45:25.331]             ...future.value <- base::withVisible(base::local({
[17:45:25.331]                 ...future.makeSendCondition <- base::local({
[17:45:25.331]                   sendCondition <- NULL
[17:45:25.331]                   function(frame = 1L) {
[17:45:25.331]                     if (is.function(sendCondition)) 
[17:45:25.331]                       return(sendCondition)
[17:45:25.331]                     ns <- getNamespace("parallel")
[17:45:25.331]                     if (exists("sendData", mode = "function", 
[17:45:25.331]                       envir = ns)) {
[17:45:25.331]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:25.331]                         envir = ns)
[17:45:25.331]                       envir <- sys.frame(frame)
[17:45:25.331]                       master <- NULL
[17:45:25.331]                       while (!identical(envir, .GlobalEnv) && 
[17:45:25.331]                         !identical(envir, emptyenv())) {
[17:45:25.331]                         if (exists("master", mode = "list", envir = envir, 
[17:45:25.331]                           inherits = FALSE)) {
[17:45:25.331]                           master <- get("master", mode = "list", 
[17:45:25.331]                             envir = envir, inherits = FALSE)
[17:45:25.331]                           if (inherits(master, c("SOCKnode", 
[17:45:25.331]                             "SOCK0node"))) {
[17:45:25.331]                             sendCondition <<- function(cond) {
[17:45:25.331]                               data <- list(type = "VALUE", value = cond, 
[17:45:25.331]                                 success = TRUE)
[17:45:25.331]                               parallel_sendData(master, data)
[17:45:25.331]                             }
[17:45:25.331]                             return(sendCondition)
[17:45:25.331]                           }
[17:45:25.331]                         }
[17:45:25.331]                         frame <- frame + 1L
[17:45:25.331]                         envir <- sys.frame(frame)
[17:45:25.331]                       }
[17:45:25.331]                     }
[17:45:25.331]                     sendCondition <<- function(cond) NULL
[17:45:25.331]                   }
[17:45:25.331]                 })
[17:45:25.331]                 withCallingHandlers({
[17:45:25.331]                   {
[17:45:25.331]                     do.call(function(...) {
[17:45:25.331]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.331]                       if (!identical(...future.globals.maxSize.org, 
[17:45:25.331]                         ...future.globals.maxSize)) {
[17:45:25.331]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.331]                         on.exit(options(oopts), add = TRUE)
[17:45:25.331]                       }
[17:45:25.331]                       {
[17:45:25.331]                         lapply(seq_along(...future.elements_ii), 
[17:45:25.331]                           FUN = function(jj) {
[17:45:25.331]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.331]                             ...future.FUN(...future.X_jj, ...)
[17:45:25.331]                           })
[17:45:25.331]                       }
[17:45:25.331]                     }, args = future.call.arguments)
[17:45:25.331]                   }
[17:45:25.331]                 }, immediateCondition = function(cond) {
[17:45:25.331]                   sendCondition <- ...future.makeSendCondition()
[17:45:25.331]                   sendCondition(cond)
[17:45:25.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.331]                   {
[17:45:25.331]                     inherits <- base::inherits
[17:45:25.331]                     invokeRestart <- base::invokeRestart
[17:45:25.331]                     is.null <- base::is.null
[17:45:25.331]                     muffled <- FALSE
[17:45:25.331]                     if (inherits(cond, "message")) {
[17:45:25.331]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:25.331]                       if (muffled) 
[17:45:25.331]                         invokeRestart("muffleMessage")
[17:45:25.331]                     }
[17:45:25.331]                     else if (inherits(cond, "warning")) {
[17:45:25.331]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:25.331]                       if (muffled) 
[17:45:25.331]                         invokeRestart("muffleWarning")
[17:45:25.331]                     }
[17:45:25.331]                     else if (inherits(cond, "condition")) {
[17:45:25.331]                       if (!is.null(pattern)) {
[17:45:25.331]                         computeRestarts <- base::computeRestarts
[17:45:25.331]                         grepl <- base::grepl
[17:45:25.331]                         restarts <- computeRestarts(cond)
[17:45:25.331]                         for (restart in restarts) {
[17:45:25.331]                           name <- restart$name
[17:45:25.331]                           if (is.null(name)) 
[17:45:25.331]                             next
[17:45:25.331]                           if (!grepl(pattern, name)) 
[17:45:25.331]                             next
[17:45:25.331]                           invokeRestart(restart)
[17:45:25.331]                           muffled <- TRUE
[17:45:25.331]                           break
[17:45:25.331]                         }
[17:45:25.331]                       }
[17:45:25.331]                     }
[17:45:25.331]                     invisible(muffled)
[17:45:25.331]                   }
[17:45:25.331]                   muffleCondition(cond)
[17:45:25.331]                 })
[17:45:25.331]             }))
[17:45:25.331]             future::FutureResult(value = ...future.value$value, 
[17:45:25.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.331]                   ...future.rng), globalenv = if (FALSE) 
[17:45:25.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:25.331]                     ...future.globalenv.names))
[17:45:25.331]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:25.331]         }, condition = base::local({
[17:45:25.331]             c <- base::c
[17:45:25.331]             inherits <- base::inherits
[17:45:25.331]             invokeRestart <- base::invokeRestart
[17:45:25.331]             length <- base::length
[17:45:25.331]             list <- base::list
[17:45:25.331]             seq.int <- base::seq.int
[17:45:25.331]             signalCondition <- base::signalCondition
[17:45:25.331]             sys.calls <- base::sys.calls
[17:45:25.331]             `[[` <- base::`[[`
[17:45:25.331]             `+` <- base::`+`
[17:45:25.331]             `<<-` <- base::`<<-`
[17:45:25.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:25.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:25.331]                   3L)]
[17:45:25.331]             }
[17:45:25.331]             function(cond) {
[17:45:25.331]                 is_error <- inherits(cond, "error")
[17:45:25.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:25.331]                   NULL)
[17:45:25.331]                 if (is_error) {
[17:45:25.331]                   sessionInformation <- function() {
[17:45:25.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:25.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:25.331]                       search = base::search(), system = base::Sys.info())
[17:45:25.331]                   }
[17:45:25.331]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:25.331]                     cond$call), session = sessionInformation(), 
[17:45:25.331]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:25.331]                   signalCondition(cond)
[17:45:25.331]                 }
[17:45:25.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:25.331]                 "immediateCondition"))) {
[17:45:25.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:25.331]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:25.331]                   if (TRUE && !signal) {
[17:45:25.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.331]                     {
[17:45:25.331]                       inherits <- base::inherits
[17:45:25.331]                       invokeRestart <- base::invokeRestart
[17:45:25.331]                       is.null <- base::is.null
[17:45:25.331]                       muffled <- FALSE
[17:45:25.331]                       if (inherits(cond, "message")) {
[17:45:25.331]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.331]                         if (muffled) 
[17:45:25.331]                           invokeRestart("muffleMessage")
[17:45:25.331]                       }
[17:45:25.331]                       else if (inherits(cond, "warning")) {
[17:45:25.331]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.331]                         if (muffled) 
[17:45:25.331]                           invokeRestart("muffleWarning")
[17:45:25.331]                       }
[17:45:25.331]                       else if (inherits(cond, "condition")) {
[17:45:25.331]                         if (!is.null(pattern)) {
[17:45:25.331]                           computeRestarts <- base::computeRestarts
[17:45:25.331]                           grepl <- base::grepl
[17:45:25.331]                           restarts <- computeRestarts(cond)
[17:45:25.331]                           for (restart in restarts) {
[17:45:25.331]                             name <- restart$name
[17:45:25.331]                             if (is.null(name)) 
[17:45:25.331]                               next
[17:45:25.331]                             if (!grepl(pattern, name)) 
[17:45:25.331]                               next
[17:45:25.331]                             invokeRestart(restart)
[17:45:25.331]                             muffled <- TRUE
[17:45:25.331]                             break
[17:45:25.331]                           }
[17:45:25.331]                         }
[17:45:25.331]                       }
[17:45:25.331]                       invisible(muffled)
[17:45:25.331]                     }
[17:45:25.331]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.331]                   }
[17:45:25.331]                 }
[17:45:25.331]                 else {
[17:45:25.331]                   if (TRUE) {
[17:45:25.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.331]                     {
[17:45:25.331]                       inherits <- base::inherits
[17:45:25.331]                       invokeRestart <- base::invokeRestart
[17:45:25.331]                       is.null <- base::is.null
[17:45:25.331]                       muffled <- FALSE
[17:45:25.331]                       if (inherits(cond, "message")) {
[17:45:25.331]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.331]                         if (muffled) 
[17:45:25.331]                           invokeRestart("muffleMessage")
[17:45:25.331]                       }
[17:45:25.331]                       else if (inherits(cond, "warning")) {
[17:45:25.331]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.331]                         if (muffled) 
[17:45:25.331]                           invokeRestart("muffleWarning")
[17:45:25.331]                       }
[17:45:25.331]                       else if (inherits(cond, "condition")) {
[17:45:25.331]                         if (!is.null(pattern)) {
[17:45:25.331]                           computeRestarts <- base::computeRestarts
[17:45:25.331]                           grepl <- base::grepl
[17:45:25.331]                           restarts <- computeRestarts(cond)
[17:45:25.331]                           for (restart in restarts) {
[17:45:25.331]                             name <- restart$name
[17:45:25.331]                             if (is.null(name)) 
[17:45:25.331]                               next
[17:45:25.331]                             if (!grepl(pattern, name)) 
[17:45:25.331]                               next
[17:45:25.331]                             invokeRestart(restart)
[17:45:25.331]                             muffled <- TRUE
[17:45:25.331]                             break
[17:45:25.331]                           }
[17:45:25.331]                         }
[17:45:25.331]                       }
[17:45:25.331]                       invisible(muffled)
[17:45:25.331]                     }
[17:45:25.331]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.331]                   }
[17:45:25.331]                 }
[17:45:25.331]             }
[17:45:25.331]         }))
[17:45:25.331]     }, error = function(ex) {
[17:45:25.331]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:25.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.331]                 ...future.rng), started = ...future.startTime, 
[17:45:25.331]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:25.331]             version = "1.8"), class = "FutureResult")
[17:45:25.331]     }, finally = {
[17:45:25.331]         if (!identical(...future.workdir, getwd())) 
[17:45:25.331]             setwd(...future.workdir)
[17:45:25.331]         {
[17:45:25.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:25.331]                 ...future.oldOptions$nwarnings <- NULL
[17:45:25.331]             }
[17:45:25.331]             base::options(...future.oldOptions)
[17:45:25.331]             if (.Platform$OS.type == "windows") {
[17:45:25.331]                 old_names <- names(...future.oldEnvVars)
[17:45:25.331]                 envs <- base::Sys.getenv()
[17:45:25.331]                 names <- names(envs)
[17:45:25.331]                 common <- intersect(names, old_names)
[17:45:25.331]                 added <- setdiff(names, old_names)
[17:45:25.331]                 removed <- setdiff(old_names, names)
[17:45:25.331]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:25.331]                   envs[common]]
[17:45:25.331]                 NAMES <- toupper(changed)
[17:45:25.331]                 args <- list()
[17:45:25.331]                 for (kk in seq_along(NAMES)) {
[17:45:25.331]                   name <- changed[[kk]]
[17:45:25.331]                   NAME <- NAMES[[kk]]
[17:45:25.331]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.331]                     next
[17:45:25.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.331]                 }
[17:45:25.331]                 NAMES <- toupper(added)
[17:45:25.331]                 for (kk in seq_along(NAMES)) {
[17:45:25.331]                   name <- added[[kk]]
[17:45:25.331]                   NAME <- NAMES[[kk]]
[17:45:25.331]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.331]                     next
[17:45:25.331]                   args[[name]] <- ""
[17:45:25.331]                 }
[17:45:25.331]                 NAMES <- toupper(removed)
[17:45:25.331]                 for (kk in seq_along(NAMES)) {
[17:45:25.331]                   name <- removed[[kk]]
[17:45:25.331]                   NAME <- NAMES[[kk]]
[17:45:25.331]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.331]                     next
[17:45:25.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.331]                 }
[17:45:25.331]                 if (length(args) > 0) 
[17:45:25.331]                   base::do.call(base::Sys.setenv, args = args)
[17:45:25.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:25.331]             }
[17:45:25.331]             else {
[17:45:25.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:25.331]             }
[17:45:25.331]             {
[17:45:25.331]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:25.331]                   0L) {
[17:45:25.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:25.331]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:25.331]                   base::options(opts)
[17:45:25.331]                 }
[17:45:25.331]                 {
[17:45:25.331]                   {
[17:45:25.331]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:25.331]                     NULL
[17:45:25.331]                   }
[17:45:25.331]                   options(future.plan = NULL)
[17:45:25.331]                   if (is.na(NA_character_)) 
[17:45:25.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:25.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:25.331]                     .init = FALSE)
[17:45:25.331]                 }
[17:45:25.331]             }
[17:45:25.331]         }
[17:45:25.331]     })
[17:45:25.331]     if (TRUE) {
[17:45:25.331]         base::sink(type = "output", split = FALSE)
[17:45:25.331]         if (TRUE) {
[17:45:25.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:25.331]         }
[17:45:25.331]         else {
[17:45:25.331]             ...future.result["stdout"] <- base::list(NULL)
[17:45:25.331]         }
[17:45:25.331]         base::close(...future.stdout)
[17:45:25.331]         ...future.stdout <- NULL
[17:45:25.331]     }
[17:45:25.331]     ...future.result$conditions <- ...future.conditions
[17:45:25.331]     ...future.result$finished <- base::Sys.time()
[17:45:25.331]     ...future.result
[17:45:25.331] }
[17:45:25.334] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[17:45:25.334] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[17:45:25.335] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:45:25.335] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:45:25.335] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:45:25.335] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:45:25.336] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:45:25.336] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:25.336] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.336] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:25.337] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.337] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[17:45:25.337] MultisessionFuture started
[17:45:25.337] - Launch lazy future ... done
[17:45:25.337] run() for ‘MultisessionFuture’ ... done
[17:45:25.337] Created future:
[17:45:25.337] MultisessionFuture:
[17:45:25.337] Label: ‘future_sapply-1’
[17:45:25.337] Expression:
[17:45:25.337] {
[17:45:25.337]     do.call(function(...) {
[17:45:25.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.337]             on.exit(options(oopts), add = TRUE)
[17:45:25.337]         }
[17:45:25.337]         {
[17:45:25.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.337]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.337]             })
[17:45:25.337]         }
[17:45:25.337]     }, args = future.call.arguments)
[17:45:25.337] }
[17:45:25.337] Lazy evaluation: FALSE
[17:45:25.337] Asynchronous evaluation: TRUE
[17:45:25.337] Local evaluation: TRUE
[17:45:25.337] Environment: R_GlobalEnv
[17:45:25.337] Capture standard output: TRUE
[17:45:25.337] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.337] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:25.337] Packages: <none>
[17:45:25.337] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.337] Resolved: FALSE
[17:45:25.337] Value: <not collected>
[17:45:25.337] Conditions captured: <none>
[17:45:25.337] Early signaling: FALSE
[17:45:25.337] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.337] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.349] Chunk #1 of 2 ... DONE
[17:45:25.349] Chunk #2 of 2 ...
[17:45:25.349]  - Finding globals in 'X' for chunk #2 ...
[17:45:25.349] getGlobalsAndPackages() ...
[17:45:25.350] Searching for globals...
[17:45:25.350] 
[17:45:25.350] Searching for globals ... DONE
[17:45:25.350] - globals: [0] <none>
[17:45:25.350] getGlobalsAndPackages() ... DONE
[17:45:25.350]    + additional globals found: [n=0] 
[17:45:25.350]    + additional namespaces needed: [n=0] 
[17:45:25.350]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:25.350]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.351]  - seeds: <none>
[17:45:25.351]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.351] getGlobalsAndPackages() ...
[17:45:25.351] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.351] Resolving globals: FALSE
[17:45:25.351] Tweak future expression to call with '...' arguments ...
[17:45:25.351] {
[17:45:25.351]     do.call(function(...) {
[17:45:25.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.351]             on.exit(options(oopts), add = TRUE)
[17:45:25.351]         }
[17:45:25.351]         {
[17:45:25.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.351]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.351]             })
[17:45:25.351]         }
[17:45:25.351]     }, args = future.call.arguments)
[17:45:25.351] }
[17:45:25.351] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.352] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.352] 
[17:45:25.352] getGlobalsAndPackages() ... DONE
[17:45:25.352] run() for ‘Future’ ...
[17:45:25.352] - state: ‘created’
[17:45:25.353] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:25.366] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.367] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:25.367]   - Field: ‘node’
[17:45:25.367]   - Field: ‘label’
[17:45:25.367]   - Field: ‘local’
[17:45:25.367]   - Field: ‘owner’
[17:45:25.367]   - Field: ‘envir’
[17:45:25.367]   - Field: ‘workers’
[17:45:25.367]   - Field: ‘packages’
[17:45:25.367]   - Field: ‘gc’
[17:45:25.367]   - Field: ‘conditions’
[17:45:25.368]   - Field: ‘persistent’
[17:45:25.368]   - Field: ‘expr’
[17:45:25.368]   - Field: ‘uuid’
[17:45:25.368]   - Field: ‘seed’
[17:45:25.368]   - Field: ‘version’
[17:45:25.368]   - Field: ‘result’
[17:45:25.368]   - Field: ‘asynchronous’
[17:45:25.368]   - Field: ‘calls’
[17:45:25.368]   - Field: ‘globals’
[17:45:25.368]   - Field: ‘stdout’
[17:45:25.368]   - Field: ‘earlySignal’
[17:45:25.369]   - Field: ‘lazy’
[17:45:25.369]   - Field: ‘state’
[17:45:25.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:25.369] - Launch lazy future ...
[17:45:25.369] Packages needed by the future expression (n = 0): <none>
[17:45:25.369] Packages needed by future strategies (n = 0): <none>
[17:45:25.370] {
[17:45:25.370]     {
[17:45:25.370]         {
[17:45:25.370]             ...future.startTime <- base::Sys.time()
[17:45:25.370]             {
[17:45:25.370]                 {
[17:45:25.370]                   {
[17:45:25.370]                     {
[17:45:25.370]                       base::local({
[17:45:25.370]                         has_future <- base::requireNamespace("future", 
[17:45:25.370]                           quietly = TRUE)
[17:45:25.370]                         if (has_future) {
[17:45:25.370]                           ns <- base::getNamespace("future")
[17:45:25.370]                           version <- ns[[".package"]][["version"]]
[17:45:25.370]                           if (is.null(version)) 
[17:45:25.370]                             version <- utils::packageVersion("future")
[17:45:25.370]                         }
[17:45:25.370]                         else {
[17:45:25.370]                           version <- NULL
[17:45:25.370]                         }
[17:45:25.370]                         if (!has_future || version < "1.8.0") {
[17:45:25.370]                           info <- base::c(r_version = base::gsub("R version ", 
[17:45:25.370]                             "", base::R.version$version.string), 
[17:45:25.370]                             platform = base::sprintf("%s (%s-bit)", 
[17:45:25.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[17:45:25.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:25.370]                               "release", "version")], collapse = " "), 
[17:45:25.370]                             hostname = base::Sys.info()[["nodename"]])
[17:45:25.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[17:45:25.370]                             info)
[17:45:25.370]                           info <- base::paste(info, collapse = "; ")
[17:45:25.370]                           if (!has_future) {
[17:45:25.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:25.370]                               info)
[17:45:25.370]                           }
[17:45:25.370]                           else {
[17:45:25.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:25.370]                               info, version)
[17:45:25.370]                           }
[17:45:25.370]                           base::stop(msg)
[17:45:25.370]                         }
[17:45:25.370]                       })
[17:45:25.370]                     }
[17:45:25.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:25.370]                     base::options(mc.cores = 1L)
[17:45:25.370]                   }
[17:45:25.370]                   ...future.strategy.old <- future::plan("list")
[17:45:25.370]                   options(future.plan = NULL)
[17:45:25.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:25.370]                 }
[17:45:25.370]                 ...future.workdir <- getwd()
[17:45:25.370]             }
[17:45:25.370]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:25.370]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:25.370]         }
[17:45:25.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:25.370]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:25.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:25.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:25.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:25.370]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:25.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:25.370]             base::names(...future.oldOptions))
[17:45:25.370]     }
[17:45:25.370]     if (FALSE) {
[17:45:25.370]     }
[17:45:25.370]     else {
[17:45:25.370]         if (TRUE) {
[17:45:25.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:25.370]                 open = "w")
[17:45:25.370]         }
[17:45:25.370]         else {
[17:45:25.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:25.370]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:25.370]         }
[17:45:25.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:25.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:25.370]             base::sink(type = "output", split = FALSE)
[17:45:25.370]             base::close(...future.stdout)
[17:45:25.370]         }, add = TRUE)
[17:45:25.370]     }
[17:45:25.370]     ...future.frame <- base::sys.nframe()
[17:45:25.370]     ...future.conditions <- base::list()
[17:45:25.370]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:25.370]     if (FALSE) {
[17:45:25.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:25.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:25.370]     }
[17:45:25.370]     ...future.result <- base::tryCatch({
[17:45:25.370]         base::withCallingHandlers({
[17:45:25.370]             ...future.value <- base::withVisible(base::local({
[17:45:25.370]                 ...future.makeSendCondition <- base::local({
[17:45:25.370]                   sendCondition <- NULL
[17:45:25.370]                   function(frame = 1L) {
[17:45:25.370]                     if (is.function(sendCondition)) 
[17:45:25.370]                       return(sendCondition)
[17:45:25.370]                     ns <- getNamespace("parallel")
[17:45:25.370]                     if (exists("sendData", mode = "function", 
[17:45:25.370]                       envir = ns)) {
[17:45:25.370]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:25.370]                         envir = ns)
[17:45:25.370]                       envir <- sys.frame(frame)
[17:45:25.370]                       master <- NULL
[17:45:25.370]                       while (!identical(envir, .GlobalEnv) && 
[17:45:25.370]                         !identical(envir, emptyenv())) {
[17:45:25.370]                         if (exists("master", mode = "list", envir = envir, 
[17:45:25.370]                           inherits = FALSE)) {
[17:45:25.370]                           master <- get("master", mode = "list", 
[17:45:25.370]                             envir = envir, inherits = FALSE)
[17:45:25.370]                           if (inherits(master, c("SOCKnode", 
[17:45:25.370]                             "SOCK0node"))) {
[17:45:25.370]                             sendCondition <<- function(cond) {
[17:45:25.370]                               data <- list(type = "VALUE", value = cond, 
[17:45:25.370]                                 success = TRUE)
[17:45:25.370]                               parallel_sendData(master, data)
[17:45:25.370]                             }
[17:45:25.370]                             return(sendCondition)
[17:45:25.370]                           }
[17:45:25.370]                         }
[17:45:25.370]                         frame <- frame + 1L
[17:45:25.370]                         envir <- sys.frame(frame)
[17:45:25.370]                       }
[17:45:25.370]                     }
[17:45:25.370]                     sendCondition <<- function(cond) NULL
[17:45:25.370]                   }
[17:45:25.370]                 })
[17:45:25.370]                 withCallingHandlers({
[17:45:25.370]                   {
[17:45:25.370]                     do.call(function(...) {
[17:45:25.370]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.370]                       if (!identical(...future.globals.maxSize.org, 
[17:45:25.370]                         ...future.globals.maxSize)) {
[17:45:25.370]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.370]                         on.exit(options(oopts), add = TRUE)
[17:45:25.370]                       }
[17:45:25.370]                       {
[17:45:25.370]                         lapply(seq_along(...future.elements_ii), 
[17:45:25.370]                           FUN = function(jj) {
[17:45:25.370]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.370]                             ...future.FUN(...future.X_jj, ...)
[17:45:25.370]                           })
[17:45:25.370]                       }
[17:45:25.370]                     }, args = future.call.arguments)
[17:45:25.370]                   }
[17:45:25.370]                 }, immediateCondition = function(cond) {
[17:45:25.370]                   sendCondition <- ...future.makeSendCondition()
[17:45:25.370]                   sendCondition(cond)
[17:45:25.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.370]                   {
[17:45:25.370]                     inherits <- base::inherits
[17:45:25.370]                     invokeRestart <- base::invokeRestart
[17:45:25.370]                     is.null <- base::is.null
[17:45:25.370]                     muffled <- FALSE
[17:45:25.370]                     if (inherits(cond, "message")) {
[17:45:25.370]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:25.370]                       if (muffled) 
[17:45:25.370]                         invokeRestart("muffleMessage")
[17:45:25.370]                     }
[17:45:25.370]                     else if (inherits(cond, "warning")) {
[17:45:25.370]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:25.370]                       if (muffled) 
[17:45:25.370]                         invokeRestart("muffleWarning")
[17:45:25.370]                     }
[17:45:25.370]                     else if (inherits(cond, "condition")) {
[17:45:25.370]                       if (!is.null(pattern)) {
[17:45:25.370]                         computeRestarts <- base::computeRestarts
[17:45:25.370]                         grepl <- base::grepl
[17:45:25.370]                         restarts <- computeRestarts(cond)
[17:45:25.370]                         for (restart in restarts) {
[17:45:25.370]                           name <- restart$name
[17:45:25.370]                           if (is.null(name)) 
[17:45:25.370]                             next
[17:45:25.370]                           if (!grepl(pattern, name)) 
[17:45:25.370]                             next
[17:45:25.370]                           invokeRestart(restart)
[17:45:25.370]                           muffled <- TRUE
[17:45:25.370]                           break
[17:45:25.370]                         }
[17:45:25.370]                       }
[17:45:25.370]                     }
[17:45:25.370]                     invisible(muffled)
[17:45:25.370]                   }
[17:45:25.370]                   muffleCondition(cond)
[17:45:25.370]                 })
[17:45:25.370]             }))
[17:45:25.370]             future::FutureResult(value = ...future.value$value, 
[17:45:25.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.370]                   ...future.rng), globalenv = if (FALSE) 
[17:45:25.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:25.370]                     ...future.globalenv.names))
[17:45:25.370]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:25.370]         }, condition = base::local({
[17:45:25.370]             c <- base::c
[17:45:25.370]             inherits <- base::inherits
[17:45:25.370]             invokeRestart <- base::invokeRestart
[17:45:25.370]             length <- base::length
[17:45:25.370]             list <- base::list
[17:45:25.370]             seq.int <- base::seq.int
[17:45:25.370]             signalCondition <- base::signalCondition
[17:45:25.370]             sys.calls <- base::sys.calls
[17:45:25.370]             `[[` <- base::`[[`
[17:45:25.370]             `+` <- base::`+`
[17:45:25.370]             `<<-` <- base::`<<-`
[17:45:25.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:25.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:25.370]                   3L)]
[17:45:25.370]             }
[17:45:25.370]             function(cond) {
[17:45:25.370]                 is_error <- inherits(cond, "error")
[17:45:25.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:25.370]                   NULL)
[17:45:25.370]                 if (is_error) {
[17:45:25.370]                   sessionInformation <- function() {
[17:45:25.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:25.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:25.370]                       search = base::search(), system = base::Sys.info())
[17:45:25.370]                   }
[17:45:25.370]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:25.370]                     cond$call), session = sessionInformation(), 
[17:45:25.370]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:25.370]                   signalCondition(cond)
[17:45:25.370]                 }
[17:45:25.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:25.370]                 "immediateCondition"))) {
[17:45:25.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:25.370]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:25.370]                   if (TRUE && !signal) {
[17:45:25.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.370]                     {
[17:45:25.370]                       inherits <- base::inherits
[17:45:25.370]                       invokeRestart <- base::invokeRestart
[17:45:25.370]                       is.null <- base::is.null
[17:45:25.370]                       muffled <- FALSE
[17:45:25.370]                       if (inherits(cond, "message")) {
[17:45:25.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.370]                         if (muffled) 
[17:45:25.370]                           invokeRestart("muffleMessage")
[17:45:25.370]                       }
[17:45:25.370]                       else if (inherits(cond, "warning")) {
[17:45:25.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.370]                         if (muffled) 
[17:45:25.370]                           invokeRestart("muffleWarning")
[17:45:25.370]                       }
[17:45:25.370]                       else if (inherits(cond, "condition")) {
[17:45:25.370]                         if (!is.null(pattern)) {
[17:45:25.370]                           computeRestarts <- base::computeRestarts
[17:45:25.370]                           grepl <- base::grepl
[17:45:25.370]                           restarts <- computeRestarts(cond)
[17:45:25.370]                           for (restart in restarts) {
[17:45:25.370]                             name <- restart$name
[17:45:25.370]                             if (is.null(name)) 
[17:45:25.370]                               next
[17:45:25.370]                             if (!grepl(pattern, name)) 
[17:45:25.370]                               next
[17:45:25.370]                             invokeRestart(restart)
[17:45:25.370]                             muffled <- TRUE
[17:45:25.370]                             break
[17:45:25.370]                           }
[17:45:25.370]                         }
[17:45:25.370]                       }
[17:45:25.370]                       invisible(muffled)
[17:45:25.370]                     }
[17:45:25.370]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.370]                   }
[17:45:25.370]                 }
[17:45:25.370]                 else {
[17:45:25.370]                   if (TRUE) {
[17:45:25.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.370]                     {
[17:45:25.370]                       inherits <- base::inherits
[17:45:25.370]                       invokeRestart <- base::invokeRestart
[17:45:25.370]                       is.null <- base::is.null
[17:45:25.370]                       muffled <- FALSE
[17:45:25.370]                       if (inherits(cond, "message")) {
[17:45:25.370]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.370]                         if (muffled) 
[17:45:25.370]                           invokeRestart("muffleMessage")
[17:45:25.370]                       }
[17:45:25.370]                       else if (inherits(cond, "warning")) {
[17:45:25.370]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.370]                         if (muffled) 
[17:45:25.370]                           invokeRestart("muffleWarning")
[17:45:25.370]                       }
[17:45:25.370]                       else if (inherits(cond, "condition")) {
[17:45:25.370]                         if (!is.null(pattern)) {
[17:45:25.370]                           computeRestarts <- base::computeRestarts
[17:45:25.370]                           grepl <- base::grepl
[17:45:25.370]                           restarts <- computeRestarts(cond)
[17:45:25.370]                           for (restart in restarts) {
[17:45:25.370]                             name <- restart$name
[17:45:25.370]                             if (is.null(name)) 
[17:45:25.370]                               next
[17:45:25.370]                             if (!grepl(pattern, name)) 
[17:45:25.370]                               next
[17:45:25.370]                             invokeRestart(restart)
[17:45:25.370]                             muffled <- TRUE
[17:45:25.370]                             break
[17:45:25.370]                           }
[17:45:25.370]                         }
[17:45:25.370]                       }
[17:45:25.370]                       invisible(muffled)
[17:45:25.370]                     }
[17:45:25.370]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.370]                   }
[17:45:25.370]                 }
[17:45:25.370]             }
[17:45:25.370]         }))
[17:45:25.370]     }, error = function(ex) {
[17:45:25.370]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:25.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.370]                 ...future.rng), started = ...future.startTime, 
[17:45:25.370]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:25.370]             version = "1.8"), class = "FutureResult")
[17:45:25.370]     }, finally = {
[17:45:25.370]         if (!identical(...future.workdir, getwd())) 
[17:45:25.370]             setwd(...future.workdir)
[17:45:25.370]         {
[17:45:25.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:25.370]                 ...future.oldOptions$nwarnings <- NULL
[17:45:25.370]             }
[17:45:25.370]             base::options(...future.oldOptions)
[17:45:25.370]             if (.Platform$OS.type == "windows") {
[17:45:25.370]                 old_names <- names(...future.oldEnvVars)
[17:45:25.370]                 envs <- base::Sys.getenv()
[17:45:25.370]                 names <- names(envs)
[17:45:25.370]                 common <- intersect(names, old_names)
[17:45:25.370]                 added <- setdiff(names, old_names)
[17:45:25.370]                 removed <- setdiff(old_names, names)
[17:45:25.370]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:25.370]                   envs[common]]
[17:45:25.370]                 NAMES <- toupper(changed)
[17:45:25.370]                 args <- list()
[17:45:25.370]                 for (kk in seq_along(NAMES)) {
[17:45:25.370]                   name <- changed[[kk]]
[17:45:25.370]                   NAME <- NAMES[[kk]]
[17:45:25.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.370]                     next
[17:45:25.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.370]                 }
[17:45:25.370]                 NAMES <- toupper(added)
[17:45:25.370]                 for (kk in seq_along(NAMES)) {
[17:45:25.370]                   name <- added[[kk]]
[17:45:25.370]                   NAME <- NAMES[[kk]]
[17:45:25.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.370]                     next
[17:45:25.370]                   args[[name]] <- ""
[17:45:25.370]                 }
[17:45:25.370]                 NAMES <- toupper(removed)
[17:45:25.370]                 for (kk in seq_along(NAMES)) {
[17:45:25.370]                   name <- removed[[kk]]
[17:45:25.370]                   NAME <- NAMES[[kk]]
[17:45:25.370]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.370]                     next
[17:45:25.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.370]                 }
[17:45:25.370]                 if (length(args) > 0) 
[17:45:25.370]                   base::do.call(base::Sys.setenv, args = args)
[17:45:25.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:25.370]             }
[17:45:25.370]             else {
[17:45:25.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:25.370]             }
[17:45:25.370]             {
[17:45:25.370]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:25.370]                   0L) {
[17:45:25.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:25.370]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:25.370]                   base::options(opts)
[17:45:25.370]                 }
[17:45:25.370]                 {
[17:45:25.370]                   {
[17:45:25.370]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:25.370]                     NULL
[17:45:25.370]                   }
[17:45:25.370]                   options(future.plan = NULL)
[17:45:25.370]                   if (is.na(NA_character_)) 
[17:45:25.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:25.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:25.370]                     .init = FALSE)
[17:45:25.370]                 }
[17:45:25.370]             }
[17:45:25.370]         }
[17:45:25.370]     })
[17:45:25.370]     if (TRUE) {
[17:45:25.370]         base::sink(type = "output", split = FALSE)
[17:45:25.370]         if (TRUE) {
[17:45:25.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:25.370]         }
[17:45:25.370]         else {
[17:45:25.370]             ...future.result["stdout"] <- base::list(NULL)
[17:45:25.370]         }
[17:45:25.370]         base::close(...future.stdout)
[17:45:25.370]         ...future.stdout <- NULL
[17:45:25.370]     }
[17:45:25.370]     ...future.result$conditions <- ...future.conditions
[17:45:25.370]     ...future.result$finished <- base::Sys.time()
[17:45:25.370]     ...future.result
[17:45:25.370] }
[17:45:25.372] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[17:45:25.372] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[17:45:25.373] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:45:25.373] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:45:25.373] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:45:25.373] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:45:25.374] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:45:25.374] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:25.374] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.374] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:25.375] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.375] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[17:45:25.375] MultisessionFuture started
[17:45:25.375] - Launch lazy future ... done
[17:45:25.375] run() for ‘MultisessionFuture’ ... done
[17:45:25.376] Created future:
[17:45:25.376] MultisessionFuture:
[17:45:25.376] Label: ‘future_sapply-2’
[17:45:25.376] Expression:
[17:45:25.376] {
[17:45:25.376]     do.call(function(...) {
[17:45:25.376]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.376]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.376]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.376]             on.exit(options(oopts), add = TRUE)
[17:45:25.376]         }
[17:45:25.376]         {
[17:45:25.376]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.376]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.376]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.376]             })
[17:45:25.376]         }
[17:45:25.376]     }, args = future.call.arguments)
[17:45:25.376] }
[17:45:25.376] Lazy evaluation: FALSE
[17:45:25.376] Asynchronous evaluation: TRUE
[17:45:25.376] Local evaluation: TRUE
[17:45:25.376] Environment: R_GlobalEnv
[17:45:25.376] Capture standard output: TRUE
[17:45:25.376] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.376] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[17:45:25.376] Packages: <none>
[17:45:25.376] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.376] Resolved: FALSE
[17:45:25.376] Value: <not collected>
[17:45:25.376] Conditions captured: <none>
[17:45:25.376] Early signaling: FALSE
[17:45:25.376] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.376] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.387] Chunk #2 of 2 ... DONE
[17:45:25.387] Launching 2 futures (chunks) ... DONE
[17:45:25.387] Resolving 2 futures (chunks) ...
[17:45:25.388] resolve() on list ...
[17:45:25.388]  recursive: 0
[17:45:25.388]  length: 2
[17:45:25.388] 
[17:45:25.388] receiveMessageFromWorker() for ClusterFuture ...
[17:45:25.388] - Validating connection of MultisessionFuture
[17:45:25.389] - received message: FutureResult
[17:45:25.389] - Received FutureResult
[17:45:25.389] - Erased future from FutureRegistry
[17:45:25.389] result() for ClusterFuture ...
[17:45:25.389] - result already collected: FutureResult
[17:45:25.389] result() for ClusterFuture ... done
[17:45:25.389] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:25.389] Future #1
[17:45:25.389] result() for ClusterFuture ...
[17:45:25.390] - result already collected: FutureResult
[17:45:25.390] result() for ClusterFuture ... done
[17:45:25.390] result() for ClusterFuture ...
[17:45:25.390] - result already collected: FutureResult
[17:45:25.390] result() for ClusterFuture ... done
[17:45:25.390] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:25.390] - nx: 2
[17:45:25.390] - relay: TRUE
[17:45:25.390] - stdout: TRUE
[17:45:25.390] - signal: TRUE
[17:45:25.390] - resignal: FALSE
[17:45:25.390] - force: TRUE
[17:45:25.391] - relayed: [n=2] FALSE, FALSE
[17:45:25.391] - queued futures: [n=2] FALSE, FALSE
[17:45:25.391]  - until=1
[17:45:25.391]  - relaying element #1
[17:45:25.391] result() for ClusterFuture ...
[17:45:25.391] - result already collected: FutureResult
[17:45:25.391] result() for ClusterFuture ... done
[17:45:25.391] result() for ClusterFuture ...
[17:45:25.391] - result already collected: FutureResult
[17:45:25.391] result() for ClusterFuture ... done
[17:45:25.391] result() for ClusterFuture ...
[17:45:25.392] - result already collected: FutureResult
[17:45:25.392] result() for ClusterFuture ... done
[17:45:25.392] result() for ClusterFuture ...
[17:45:25.392] - result already collected: FutureResult
[17:45:25.392] result() for ClusterFuture ... done
[17:45:25.392] - relayed: [n=2] TRUE, FALSE
[17:45:25.392] - queued futures: [n=2] TRUE, FALSE
[17:45:25.392] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:25.392]  length: 1 (resolved future 1)
[17:45:25.417] receiveMessageFromWorker() for ClusterFuture ...
[17:45:25.417] - Validating connection of MultisessionFuture
[17:45:25.417] - received message: FutureResult
[17:45:25.418] - Received FutureResult
[17:45:25.418] - Erased future from FutureRegistry
[17:45:25.418] result() for ClusterFuture ...
[17:45:25.418] - result already collected: FutureResult
[17:45:25.418] result() for ClusterFuture ... done
[17:45:25.418] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:25.418] Future #2
[17:45:25.418] result() for ClusterFuture ...
[17:45:25.418] - result already collected: FutureResult
[17:45:25.418] result() for ClusterFuture ... done
[17:45:25.419] result() for ClusterFuture ...
[17:45:25.419] - result already collected: FutureResult
[17:45:25.419] result() for ClusterFuture ... done
[17:45:25.419] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:25.419] - nx: 2
[17:45:25.419] - relay: TRUE
[17:45:25.419] - stdout: TRUE
[17:45:25.419] - signal: TRUE
[17:45:25.419] - resignal: FALSE
[17:45:25.419] - force: TRUE
[17:45:25.419] - relayed: [n=2] TRUE, FALSE
[17:45:25.420] - queued futures: [n=2] TRUE, FALSE
[17:45:25.420]  - until=2
[17:45:25.420]  - relaying element #2
[17:45:25.420] result() for ClusterFuture ...
[17:45:25.420] - result already collected: FutureResult
[17:45:25.420] result() for ClusterFuture ... done
[17:45:25.420] result() for ClusterFuture ...
[17:45:25.420] - result already collected: FutureResult
[17:45:25.420] result() for ClusterFuture ... done
[17:45:25.420] result() for ClusterFuture ...
[17:45:25.420] - result already collected: FutureResult
[17:45:25.421] result() for ClusterFuture ... done
[17:45:25.421] result() for ClusterFuture ...
[17:45:25.421] - result already collected: FutureResult
[17:45:25.421] result() for ClusterFuture ... done
[17:45:25.421] - relayed: [n=2] TRUE, TRUE
[17:45:25.421] - queued futures: [n=2] TRUE, TRUE
[17:45:25.421] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:25.421]  length: 0 (resolved future 2)
[17:45:25.421] Relaying remaining futures
[17:45:25.421] signalConditionsASAP(NULL, pos=0) ...
[17:45:25.421] - nx: 2
[17:45:25.421] - relay: TRUE
[17:45:25.422] - stdout: TRUE
[17:45:25.422] - signal: TRUE
[17:45:25.422] - resignal: FALSE
[17:45:25.422] - force: TRUE
[17:45:25.422] - relayed: [n=2] TRUE, TRUE
[17:45:25.422] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:25.422] - relayed: [n=2] TRUE, TRUE
[17:45:25.422] - queued futures: [n=2] TRUE, TRUE
[17:45:25.422] signalConditionsASAP(NULL, pos=0) ... done
[17:45:25.422] resolve() on list ... DONE
[17:45:25.422] result() for ClusterFuture ...
[17:45:25.423] - result already collected: FutureResult
[17:45:25.423] result() for ClusterFuture ... done
[17:45:25.423] result() for ClusterFuture ...
[17:45:25.423] - result already collected: FutureResult
[17:45:25.423] result() for ClusterFuture ... done
[17:45:25.423] result() for ClusterFuture ...
[17:45:25.423] - result already collected: FutureResult
[17:45:25.423] result() for ClusterFuture ... done
[17:45:25.423] result() for ClusterFuture ...
[17:45:25.423] - result already collected: FutureResult
[17:45:25.423] result() for ClusterFuture ... done
[17:45:25.424]  - Number of value chunks collected: 2
[17:45:25.424] Resolving 2 futures (chunks) ... DONE
[17:45:25.424] Reducing values from 2 chunks ...
[17:45:25.424]  - Number of values collected after concatenation: 4
[17:45:25.424]  - Number of values expected: 4
[17:45:25.424] Reducing values from 2 chunks ... DONE
[17:45:25.424] future_lapply() ... DONE
[17:45:25.425] future_lapply() ...
[17:45:25.430] Number of chunks: 2
[17:45:25.430] getGlobalsAndPackagesXApply() ...
[17:45:25.430]  - future.globals: TRUE
[17:45:25.430] getGlobalsAndPackages() ...
[17:45:25.430] Searching for globals...
[17:45:25.434] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[17:45:25.434] Searching for globals ... DONE
[17:45:25.434] Resolving globals: FALSE
[17:45:25.435] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[17:45:25.435] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:25.436] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:25.436] - packages: [1] ‘future.apply’
[17:45:25.436] getGlobalsAndPackages() ... DONE
[17:45:25.436]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:25.436]  - needed namespaces: [n=1] ‘future.apply’
[17:45:25.436] Finding globals ... DONE
[17:45:25.436]  - use_args: TRUE
[17:45:25.436]  - Getting '...' globals ...
[17:45:25.437] resolve() on list ...
[17:45:25.437]  recursive: 0
[17:45:25.437]  length: 1
[17:45:25.437]  elements: ‘...’
[17:45:25.437]  length: 0 (resolved future 1)
[17:45:25.437] resolve() on list ... DONE
[17:45:25.437]    - '...' content: [n=1] ‘y’
[17:45:25.437] List of 1
[17:45:25.437]  $ ...:List of 1
[17:45:25.437]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:25.437]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:25.437]  - attr(*, "where")=List of 1
[17:45:25.437]   ..$ ...:<environment: 0x5561f7b0cdd8> 
[17:45:25.437]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:25.437]  - attr(*, "resolved")= logi TRUE
[17:45:25.437]  - attr(*, "total_size")= num NA
[17:45:25.440]  - Getting '...' globals ... DONE
[17:45:25.440] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:25.441] List of 8
[17:45:25.441]  $ ...future.FUN:function (x, ...)  
[17:45:25.441]  $ x_FUN        :function (x, y)  
[17:45:25.441]  $ times        : int 15
[17:45:25.441]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:25.441]  $ stop_if_not  :function (...)  
[17:45:25.441]  $ dim          : int [1:2] 3 5
[17:45:25.441]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:25.441]  $ ...          :List of 1
[17:45:25.441]   ..$ y: num [1:5] 2 4 6 8 10
[17:45:25.441]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:25.441]  - attr(*, "where")=List of 8
[17:45:25.441]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:25.441]   ..$ ...          :<environment: 0x5561f7b0cdd8> 
[17:45:25.441]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:25.441]  - attr(*, "resolved")= logi FALSE
[17:45:25.441]  - attr(*, "total_size")= num 98600
[17:45:25.449] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:25.449] getGlobalsAndPackagesXApply() ... DONE
[17:45:25.449] Number of futures (= number of chunks): 2
[17:45:25.449] Launching 2 futures (chunks) ...
[17:45:25.449] Chunk #1 of 2 ...
[17:45:25.449]  - Finding globals in 'X' for chunk #1 ...
[17:45:25.450] getGlobalsAndPackages() ...
[17:45:25.450] Searching for globals...
[17:45:25.450] 
[17:45:25.450] Searching for globals ... DONE
[17:45:25.450] - globals: [0] <none>
[17:45:25.450] getGlobalsAndPackages() ... DONE
[17:45:25.450]    + additional globals found: [n=0] 
[17:45:25.450]    + additional namespaces needed: [n=0] 
[17:45:25.450]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:25.450]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.451]  - seeds: <none>
[17:45:25.451]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.451] getGlobalsAndPackages() ...
[17:45:25.451] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.451] Resolving globals: FALSE
[17:45:25.451] Tweak future expression to call with '...' arguments ...
[17:45:25.451] {
[17:45:25.451]     do.call(function(...) {
[17:45:25.451]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.451]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.451]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.451]             on.exit(options(oopts), add = TRUE)
[17:45:25.451]         }
[17:45:25.451]         {
[17:45:25.451]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.451]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.451]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.451]             })
[17:45:25.451]         }
[17:45:25.451]     }, args = future.call.arguments)
[17:45:25.451] }
[17:45:25.451] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.452] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.452] - packages: [1] ‘future.apply’
[17:45:25.452] getGlobalsAndPackages() ... DONE
[17:45:25.452] run() for ‘Future’ ...
[17:45:25.453] - state: ‘created’
[17:45:25.453] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:25.467] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:25.467]   - Field: ‘node’
[17:45:25.467]   - Field: ‘label’
[17:45:25.467]   - Field: ‘local’
[17:45:25.467]   - Field: ‘owner’
[17:45:25.467]   - Field: ‘envir’
[17:45:25.468]   - Field: ‘workers’
[17:45:25.468]   - Field: ‘packages’
[17:45:25.468]   - Field: ‘gc’
[17:45:25.468]   - Field: ‘conditions’
[17:45:25.468]   - Field: ‘persistent’
[17:45:25.468]   - Field: ‘expr’
[17:45:25.468]   - Field: ‘uuid’
[17:45:25.468]   - Field: ‘seed’
[17:45:25.468]   - Field: ‘version’
[17:45:25.468]   - Field: ‘result’
[17:45:25.468]   - Field: ‘asynchronous’
[17:45:25.469]   - Field: ‘calls’
[17:45:25.469]   - Field: ‘globals’
[17:45:25.469]   - Field: ‘stdout’
[17:45:25.469]   - Field: ‘earlySignal’
[17:45:25.469]   - Field: ‘lazy’
[17:45:25.469]   - Field: ‘state’
[17:45:25.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:25.469] - Launch lazy future ...
[17:45:25.469] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:25.470] Packages needed by future strategies (n = 0): <none>
[17:45:25.470] {
[17:45:25.470]     {
[17:45:25.470]         {
[17:45:25.470]             ...future.startTime <- base::Sys.time()
[17:45:25.470]             {
[17:45:25.470]                 {
[17:45:25.470]                   {
[17:45:25.470]                     {
[17:45:25.470]                       {
[17:45:25.470]                         base::local({
[17:45:25.470]                           has_future <- base::requireNamespace("future", 
[17:45:25.470]                             quietly = TRUE)
[17:45:25.470]                           if (has_future) {
[17:45:25.470]                             ns <- base::getNamespace("future")
[17:45:25.470]                             version <- ns[[".package"]][["version"]]
[17:45:25.470]                             if (is.null(version)) 
[17:45:25.470]                               version <- utils::packageVersion("future")
[17:45:25.470]                           }
[17:45:25.470]                           else {
[17:45:25.470]                             version <- NULL
[17:45:25.470]                           }
[17:45:25.470]                           if (!has_future || version < "1.8.0") {
[17:45:25.470]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:25.470]                               "", base::R.version$version.string), 
[17:45:25.470]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:25.470]                                 base::R.version$platform, 8 * 
[17:45:25.470]                                   base::.Machine$sizeof.pointer), 
[17:45:25.470]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:25.470]                                 "release", "version")], collapse = " "), 
[17:45:25.470]                               hostname = base::Sys.info()[["nodename"]])
[17:45:25.470]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:25.470]                               info)
[17:45:25.470]                             info <- base::paste(info, collapse = "; ")
[17:45:25.470]                             if (!has_future) {
[17:45:25.470]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:25.470]                                 info)
[17:45:25.470]                             }
[17:45:25.470]                             else {
[17:45:25.470]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:25.470]                                 info, version)
[17:45:25.470]                             }
[17:45:25.470]                             base::stop(msg)
[17:45:25.470]                           }
[17:45:25.470]                         })
[17:45:25.470]                       }
[17:45:25.470]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:25.470]                       base::options(mc.cores = 1L)
[17:45:25.470]                     }
[17:45:25.470]                     base::local({
[17:45:25.470]                       for (pkg in "future.apply") {
[17:45:25.470]                         base::loadNamespace(pkg)
[17:45:25.470]                         base::library(pkg, character.only = TRUE)
[17:45:25.470]                       }
[17:45:25.470]                     })
[17:45:25.470]                   }
[17:45:25.470]                   ...future.strategy.old <- future::plan("list")
[17:45:25.470]                   options(future.plan = NULL)
[17:45:25.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:25.470]                 }
[17:45:25.470]                 ...future.workdir <- getwd()
[17:45:25.470]             }
[17:45:25.470]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:25.470]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:25.470]         }
[17:45:25.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:25.470]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:25.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:25.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:25.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:25.470]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:25.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:25.470]             base::names(...future.oldOptions))
[17:45:25.470]     }
[17:45:25.470]     if (FALSE) {
[17:45:25.470]     }
[17:45:25.470]     else {
[17:45:25.470]         if (TRUE) {
[17:45:25.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:25.470]                 open = "w")
[17:45:25.470]         }
[17:45:25.470]         else {
[17:45:25.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:25.470]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:25.470]         }
[17:45:25.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:25.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:25.470]             base::sink(type = "output", split = FALSE)
[17:45:25.470]             base::close(...future.stdout)
[17:45:25.470]         }, add = TRUE)
[17:45:25.470]     }
[17:45:25.470]     ...future.frame <- base::sys.nframe()
[17:45:25.470]     ...future.conditions <- base::list()
[17:45:25.470]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:25.470]     if (FALSE) {
[17:45:25.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:25.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:25.470]     }
[17:45:25.470]     ...future.result <- base::tryCatch({
[17:45:25.470]         base::withCallingHandlers({
[17:45:25.470]             ...future.value <- base::withVisible(base::local({
[17:45:25.470]                 ...future.makeSendCondition <- base::local({
[17:45:25.470]                   sendCondition <- NULL
[17:45:25.470]                   function(frame = 1L) {
[17:45:25.470]                     if (is.function(sendCondition)) 
[17:45:25.470]                       return(sendCondition)
[17:45:25.470]                     ns <- getNamespace("parallel")
[17:45:25.470]                     if (exists("sendData", mode = "function", 
[17:45:25.470]                       envir = ns)) {
[17:45:25.470]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:25.470]                         envir = ns)
[17:45:25.470]                       envir <- sys.frame(frame)
[17:45:25.470]                       master <- NULL
[17:45:25.470]                       while (!identical(envir, .GlobalEnv) && 
[17:45:25.470]                         !identical(envir, emptyenv())) {
[17:45:25.470]                         if (exists("master", mode = "list", envir = envir, 
[17:45:25.470]                           inherits = FALSE)) {
[17:45:25.470]                           master <- get("master", mode = "list", 
[17:45:25.470]                             envir = envir, inherits = FALSE)
[17:45:25.470]                           if (inherits(master, c("SOCKnode", 
[17:45:25.470]                             "SOCK0node"))) {
[17:45:25.470]                             sendCondition <<- function(cond) {
[17:45:25.470]                               data <- list(type = "VALUE", value = cond, 
[17:45:25.470]                                 success = TRUE)
[17:45:25.470]                               parallel_sendData(master, data)
[17:45:25.470]                             }
[17:45:25.470]                             return(sendCondition)
[17:45:25.470]                           }
[17:45:25.470]                         }
[17:45:25.470]                         frame <- frame + 1L
[17:45:25.470]                         envir <- sys.frame(frame)
[17:45:25.470]                       }
[17:45:25.470]                     }
[17:45:25.470]                     sendCondition <<- function(cond) NULL
[17:45:25.470]                   }
[17:45:25.470]                 })
[17:45:25.470]                 withCallingHandlers({
[17:45:25.470]                   {
[17:45:25.470]                     do.call(function(...) {
[17:45:25.470]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.470]                       if (!identical(...future.globals.maxSize.org, 
[17:45:25.470]                         ...future.globals.maxSize)) {
[17:45:25.470]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.470]                         on.exit(options(oopts), add = TRUE)
[17:45:25.470]                       }
[17:45:25.470]                       {
[17:45:25.470]                         lapply(seq_along(...future.elements_ii), 
[17:45:25.470]                           FUN = function(jj) {
[17:45:25.470]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.470]                             ...future.FUN(...future.X_jj, ...)
[17:45:25.470]                           })
[17:45:25.470]                       }
[17:45:25.470]                     }, args = future.call.arguments)
[17:45:25.470]                   }
[17:45:25.470]                 }, immediateCondition = function(cond) {
[17:45:25.470]                   sendCondition <- ...future.makeSendCondition()
[17:45:25.470]                   sendCondition(cond)
[17:45:25.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.470]                   {
[17:45:25.470]                     inherits <- base::inherits
[17:45:25.470]                     invokeRestart <- base::invokeRestart
[17:45:25.470]                     is.null <- base::is.null
[17:45:25.470]                     muffled <- FALSE
[17:45:25.470]                     if (inherits(cond, "message")) {
[17:45:25.470]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:25.470]                       if (muffled) 
[17:45:25.470]                         invokeRestart("muffleMessage")
[17:45:25.470]                     }
[17:45:25.470]                     else if (inherits(cond, "warning")) {
[17:45:25.470]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:25.470]                       if (muffled) 
[17:45:25.470]                         invokeRestart("muffleWarning")
[17:45:25.470]                     }
[17:45:25.470]                     else if (inherits(cond, "condition")) {
[17:45:25.470]                       if (!is.null(pattern)) {
[17:45:25.470]                         computeRestarts <- base::computeRestarts
[17:45:25.470]                         grepl <- base::grepl
[17:45:25.470]                         restarts <- computeRestarts(cond)
[17:45:25.470]                         for (restart in restarts) {
[17:45:25.470]                           name <- restart$name
[17:45:25.470]                           if (is.null(name)) 
[17:45:25.470]                             next
[17:45:25.470]                           if (!grepl(pattern, name)) 
[17:45:25.470]                             next
[17:45:25.470]                           invokeRestart(restart)
[17:45:25.470]                           muffled <- TRUE
[17:45:25.470]                           break
[17:45:25.470]                         }
[17:45:25.470]                       }
[17:45:25.470]                     }
[17:45:25.470]                     invisible(muffled)
[17:45:25.470]                   }
[17:45:25.470]                   muffleCondition(cond)
[17:45:25.470]                 })
[17:45:25.470]             }))
[17:45:25.470]             future::FutureResult(value = ...future.value$value, 
[17:45:25.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.470]                   ...future.rng), globalenv = if (FALSE) 
[17:45:25.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:25.470]                     ...future.globalenv.names))
[17:45:25.470]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:25.470]         }, condition = base::local({
[17:45:25.470]             c <- base::c
[17:45:25.470]             inherits <- base::inherits
[17:45:25.470]             invokeRestart <- base::invokeRestart
[17:45:25.470]             length <- base::length
[17:45:25.470]             list <- base::list
[17:45:25.470]             seq.int <- base::seq.int
[17:45:25.470]             signalCondition <- base::signalCondition
[17:45:25.470]             sys.calls <- base::sys.calls
[17:45:25.470]             `[[` <- base::`[[`
[17:45:25.470]             `+` <- base::`+`
[17:45:25.470]             `<<-` <- base::`<<-`
[17:45:25.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:25.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:25.470]                   3L)]
[17:45:25.470]             }
[17:45:25.470]             function(cond) {
[17:45:25.470]                 is_error <- inherits(cond, "error")
[17:45:25.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:25.470]                   NULL)
[17:45:25.470]                 if (is_error) {
[17:45:25.470]                   sessionInformation <- function() {
[17:45:25.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:25.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:25.470]                       search = base::search(), system = base::Sys.info())
[17:45:25.470]                   }
[17:45:25.470]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:25.470]                     cond$call), session = sessionInformation(), 
[17:45:25.470]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:25.470]                   signalCondition(cond)
[17:45:25.470]                 }
[17:45:25.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:25.470]                 "immediateCondition"))) {
[17:45:25.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:25.470]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:25.470]                   if (TRUE && !signal) {
[17:45:25.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.470]                     {
[17:45:25.470]                       inherits <- base::inherits
[17:45:25.470]                       invokeRestart <- base::invokeRestart
[17:45:25.470]                       is.null <- base::is.null
[17:45:25.470]                       muffled <- FALSE
[17:45:25.470]                       if (inherits(cond, "message")) {
[17:45:25.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.470]                         if (muffled) 
[17:45:25.470]                           invokeRestart("muffleMessage")
[17:45:25.470]                       }
[17:45:25.470]                       else if (inherits(cond, "warning")) {
[17:45:25.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.470]                         if (muffled) 
[17:45:25.470]                           invokeRestart("muffleWarning")
[17:45:25.470]                       }
[17:45:25.470]                       else if (inherits(cond, "condition")) {
[17:45:25.470]                         if (!is.null(pattern)) {
[17:45:25.470]                           computeRestarts <- base::computeRestarts
[17:45:25.470]                           grepl <- base::grepl
[17:45:25.470]                           restarts <- computeRestarts(cond)
[17:45:25.470]                           for (restart in restarts) {
[17:45:25.470]                             name <- restart$name
[17:45:25.470]                             if (is.null(name)) 
[17:45:25.470]                               next
[17:45:25.470]                             if (!grepl(pattern, name)) 
[17:45:25.470]                               next
[17:45:25.470]                             invokeRestart(restart)
[17:45:25.470]                             muffled <- TRUE
[17:45:25.470]                             break
[17:45:25.470]                           }
[17:45:25.470]                         }
[17:45:25.470]                       }
[17:45:25.470]                       invisible(muffled)
[17:45:25.470]                     }
[17:45:25.470]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.470]                   }
[17:45:25.470]                 }
[17:45:25.470]                 else {
[17:45:25.470]                   if (TRUE) {
[17:45:25.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.470]                     {
[17:45:25.470]                       inherits <- base::inherits
[17:45:25.470]                       invokeRestart <- base::invokeRestart
[17:45:25.470]                       is.null <- base::is.null
[17:45:25.470]                       muffled <- FALSE
[17:45:25.470]                       if (inherits(cond, "message")) {
[17:45:25.470]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.470]                         if (muffled) 
[17:45:25.470]                           invokeRestart("muffleMessage")
[17:45:25.470]                       }
[17:45:25.470]                       else if (inherits(cond, "warning")) {
[17:45:25.470]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.470]                         if (muffled) 
[17:45:25.470]                           invokeRestart("muffleWarning")
[17:45:25.470]                       }
[17:45:25.470]                       else if (inherits(cond, "condition")) {
[17:45:25.470]                         if (!is.null(pattern)) {
[17:45:25.470]                           computeRestarts <- base::computeRestarts
[17:45:25.470]                           grepl <- base::grepl
[17:45:25.470]                           restarts <- computeRestarts(cond)
[17:45:25.470]                           for (restart in restarts) {
[17:45:25.470]                             name <- restart$name
[17:45:25.470]                             if (is.null(name)) 
[17:45:25.470]                               next
[17:45:25.470]                             if (!grepl(pattern, name)) 
[17:45:25.470]                               next
[17:45:25.470]                             invokeRestart(restart)
[17:45:25.470]                             muffled <- TRUE
[17:45:25.470]                             break
[17:45:25.470]                           }
[17:45:25.470]                         }
[17:45:25.470]                       }
[17:45:25.470]                       invisible(muffled)
[17:45:25.470]                     }
[17:45:25.470]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.470]                   }
[17:45:25.470]                 }
[17:45:25.470]             }
[17:45:25.470]         }))
[17:45:25.470]     }, error = function(ex) {
[17:45:25.470]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:25.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.470]                 ...future.rng), started = ...future.startTime, 
[17:45:25.470]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:25.470]             version = "1.8"), class = "FutureResult")
[17:45:25.470]     }, finally = {
[17:45:25.470]         if (!identical(...future.workdir, getwd())) 
[17:45:25.470]             setwd(...future.workdir)
[17:45:25.470]         {
[17:45:25.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:25.470]                 ...future.oldOptions$nwarnings <- NULL
[17:45:25.470]             }
[17:45:25.470]             base::options(...future.oldOptions)
[17:45:25.470]             if (.Platform$OS.type == "windows") {
[17:45:25.470]                 old_names <- names(...future.oldEnvVars)
[17:45:25.470]                 envs <- base::Sys.getenv()
[17:45:25.470]                 names <- names(envs)
[17:45:25.470]                 common <- intersect(names, old_names)
[17:45:25.470]                 added <- setdiff(names, old_names)
[17:45:25.470]                 removed <- setdiff(old_names, names)
[17:45:25.470]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:25.470]                   envs[common]]
[17:45:25.470]                 NAMES <- toupper(changed)
[17:45:25.470]                 args <- list()
[17:45:25.470]                 for (kk in seq_along(NAMES)) {
[17:45:25.470]                   name <- changed[[kk]]
[17:45:25.470]                   NAME <- NAMES[[kk]]
[17:45:25.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.470]                     next
[17:45:25.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.470]                 }
[17:45:25.470]                 NAMES <- toupper(added)
[17:45:25.470]                 for (kk in seq_along(NAMES)) {
[17:45:25.470]                   name <- added[[kk]]
[17:45:25.470]                   NAME <- NAMES[[kk]]
[17:45:25.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.470]                     next
[17:45:25.470]                   args[[name]] <- ""
[17:45:25.470]                 }
[17:45:25.470]                 NAMES <- toupper(removed)
[17:45:25.470]                 for (kk in seq_along(NAMES)) {
[17:45:25.470]                   name <- removed[[kk]]
[17:45:25.470]                   NAME <- NAMES[[kk]]
[17:45:25.470]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.470]                     next
[17:45:25.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.470]                 }
[17:45:25.470]                 if (length(args) > 0) 
[17:45:25.470]                   base::do.call(base::Sys.setenv, args = args)
[17:45:25.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:25.470]             }
[17:45:25.470]             else {
[17:45:25.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:25.470]             }
[17:45:25.470]             {
[17:45:25.470]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:25.470]                   0L) {
[17:45:25.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:25.470]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:25.470]                   base::options(opts)
[17:45:25.470]                 }
[17:45:25.470]                 {
[17:45:25.470]                   {
[17:45:25.470]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:25.470]                     NULL
[17:45:25.470]                   }
[17:45:25.470]                   options(future.plan = NULL)
[17:45:25.470]                   if (is.na(NA_character_)) 
[17:45:25.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:25.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:25.470]                     .init = FALSE)
[17:45:25.470]                 }
[17:45:25.470]             }
[17:45:25.470]         }
[17:45:25.470]     })
[17:45:25.470]     if (TRUE) {
[17:45:25.470]         base::sink(type = "output", split = FALSE)
[17:45:25.470]         if (TRUE) {
[17:45:25.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:25.470]         }
[17:45:25.470]         else {
[17:45:25.470]             ...future.result["stdout"] <- base::list(NULL)
[17:45:25.470]         }
[17:45:25.470]         base::close(...future.stdout)
[17:45:25.470]         ...future.stdout <- NULL
[17:45:25.470]     }
[17:45:25.470]     ...future.result$conditions <- ...future.conditions
[17:45:25.470]     ...future.result$finished <- base::Sys.time()
[17:45:25.470]     ...future.result
[17:45:25.470] }
[17:45:25.473] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[17:45:25.473] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:25.516] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:25.516] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[17:45:25.516] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[17:45:25.517] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:25.517] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:25.517] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:25.560] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:25.560] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:25.604] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:25.604] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[17:45:25.604] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[17:45:25.604] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:25.605] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:25.605] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[17:45:25.606] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[17:45:25.606] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:45:25.606] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:45:25.606] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:25.607] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.607] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:25.607] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.607] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[17:45:25.608] MultisessionFuture started
[17:45:25.608] - Launch lazy future ... done
[17:45:25.608] run() for ‘MultisessionFuture’ ... done
[17:45:25.608] Created future:
[17:45:25.608] MultisessionFuture:
[17:45:25.608] Label: ‘future_vapply-1’
[17:45:25.608] Expression:
[17:45:25.608] {
[17:45:25.608]     do.call(function(...) {
[17:45:25.608]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.608]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.608]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.608]             on.exit(options(oopts), add = TRUE)
[17:45:25.608]         }
[17:45:25.608]         {
[17:45:25.608]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.608]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.608]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.608]             })
[17:45:25.608]         }
[17:45:25.608]     }, args = future.call.arguments)
[17:45:25.608] }
[17:45:25.608] Lazy evaluation: FALSE
[17:45:25.608] Asynchronous evaluation: TRUE
[17:45:25.608] Local evaluation: TRUE
[17:45:25.608] Environment: R_GlobalEnv
[17:45:25.608] Capture standard output: TRUE
[17:45:25.608] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.608] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:25.608] Packages: 1 packages (‘future.apply’)
[17:45:25.608] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.608] Resolved: FALSE
[17:45:25.608] Value: <not collected>
[17:45:25.608] Conditions captured: <none>
[17:45:25.608] Early signaling: FALSE
[17:45:25.608] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.608] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.620] Chunk #1 of 2 ... DONE
[17:45:25.620] Chunk #2 of 2 ...
[17:45:25.621]  - Finding globals in 'X' for chunk #2 ...
[17:45:25.621] getGlobalsAndPackages() ...
[17:45:25.621] Searching for globals...
[17:45:25.621] 
[17:45:25.621] Searching for globals ... DONE
[17:45:25.621] - globals: [0] <none>
[17:45:25.621] getGlobalsAndPackages() ... DONE
[17:45:25.622]    + additional globals found: [n=0] 
[17:45:25.622]    + additional namespaces needed: [n=0] 
[17:45:25.622]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:25.622]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.622]  - seeds: <none>
[17:45:25.622]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.622] getGlobalsAndPackages() ...
[17:45:25.622] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.622] Resolving globals: FALSE
[17:45:25.622] Tweak future expression to call with '...' arguments ...
[17:45:25.623] {
[17:45:25.623]     do.call(function(...) {
[17:45:25.623]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.623]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.623]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.623]             on.exit(options(oopts), add = TRUE)
[17:45:25.623]         }
[17:45:25.623]         {
[17:45:25.623]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.623]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.623]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.623]             })
[17:45:25.623]         }
[17:45:25.623]     }, args = future.call.arguments)
[17:45:25.623] }
[17:45:25.623] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.624] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.624] - packages: [1] ‘future.apply’
[17:45:25.624] getGlobalsAndPackages() ... DONE
[17:45:25.624] run() for ‘Future’ ...
[17:45:25.624] - state: ‘created’
[17:45:25.624] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:25.639] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.639] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:25.639]   - Field: ‘node’
[17:45:25.639]   - Field: ‘label’
[17:45:25.639]   - Field: ‘local’
[17:45:25.639]   - Field: ‘owner’
[17:45:25.639]   - Field: ‘envir’
[17:45:25.639]   - Field: ‘workers’
[17:45:25.639]   - Field: ‘packages’
[17:45:25.639]   - Field: ‘gc’
[17:45:25.640]   - Field: ‘conditions’
[17:45:25.640]   - Field: ‘persistent’
[17:45:25.640]   - Field: ‘expr’
[17:45:25.640]   - Field: ‘uuid’
[17:45:25.640]   - Field: ‘seed’
[17:45:25.640]   - Field: ‘version’
[17:45:25.640]   - Field: ‘result’
[17:45:25.640]   - Field: ‘asynchronous’
[17:45:25.640]   - Field: ‘calls’
[17:45:25.640]   - Field: ‘globals’
[17:45:25.640]   - Field: ‘stdout’
[17:45:25.641]   - Field: ‘earlySignal’
[17:45:25.641]   - Field: ‘lazy’
[17:45:25.641]   - Field: ‘state’
[17:45:25.641] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:25.641] - Launch lazy future ...
[17:45:25.641] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:25.641] Packages needed by future strategies (n = 0): <none>
[17:45:25.642] {
[17:45:25.642]     {
[17:45:25.642]         {
[17:45:25.642]             ...future.startTime <- base::Sys.time()
[17:45:25.642]             {
[17:45:25.642]                 {
[17:45:25.642]                   {
[17:45:25.642]                     {
[17:45:25.642]                       {
[17:45:25.642]                         base::local({
[17:45:25.642]                           has_future <- base::requireNamespace("future", 
[17:45:25.642]                             quietly = TRUE)
[17:45:25.642]                           if (has_future) {
[17:45:25.642]                             ns <- base::getNamespace("future")
[17:45:25.642]                             version <- ns[[".package"]][["version"]]
[17:45:25.642]                             if (is.null(version)) 
[17:45:25.642]                               version <- utils::packageVersion("future")
[17:45:25.642]                           }
[17:45:25.642]                           else {
[17:45:25.642]                             version <- NULL
[17:45:25.642]                           }
[17:45:25.642]                           if (!has_future || version < "1.8.0") {
[17:45:25.642]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:25.642]                               "", base::R.version$version.string), 
[17:45:25.642]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:25.642]                                 base::R.version$platform, 8 * 
[17:45:25.642]                                   base::.Machine$sizeof.pointer), 
[17:45:25.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:25.642]                                 "release", "version")], collapse = " "), 
[17:45:25.642]                               hostname = base::Sys.info()[["nodename"]])
[17:45:25.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:25.642]                               info)
[17:45:25.642]                             info <- base::paste(info, collapse = "; ")
[17:45:25.642]                             if (!has_future) {
[17:45:25.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:25.642]                                 info)
[17:45:25.642]                             }
[17:45:25.642]                             else {
[17:45:25.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:25.642]                                 info, version)
[17:45:25.642]                             }
[17:45:25.642]                             base::stop(msg)
[17:45:25.642]                           }
[17:45:25.642]                         })
[17:45:25.642]                       }
[17:45:25.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:25.642]                       base::options(mc.cores = 1L)
[17:45:25.642]                     }
[17:45:25.642]                     base::local({
[17:45:25.642]                       for (pkg in "future.apply") {
[17:45:25.642]                         base::loadNamespace(pkg)
[17:45:25.642]                         base::library(pkg, character.only = TRUE)
[17:45:25.642]                       }
[17:45:25.642]                     })
[17:45:25.642]                   }
[17:45:25.642]                   ...future.strategy.old <- future::plan("list")
[17:45:25.642]                   options(future.plan = NULL)
[17:45:25.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:25.642]                 }
[17:45:25.642]                 ...future.workdir <- getwd()
[17:45:25.642]             }
[17:45:25.642]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:25.642]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:25.642]         }
[17:45:25.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:25.642]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:25.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:25.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:25.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:25.642]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:25.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:25.642]             base::names(...future.oldOptions))
[17:45:25.642]     }
[17:45:25.642]     if (FALSE) {
[17:45:25.642]     }
[17:45:25.642]     else {
[17:45:25.642]         if (TRUE) {
[17:45:25.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:25.642]                 open = "w")
[17:45:25.642]         }
[17:45:25.642]         else {
[17:45:25.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:25.642]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:25.642]         }
[17:45:25.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:25.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:25.642]             base::sink(type = "output", split = FALSE)
[17:45:25.642]             base::close(...future.stdout)
[17:45:25.642]         }, add = TRUE)
[17:45:25.642]     }
[17:45:25.642]     ...future.frame <- base::sys.nframe()
[17:45:25.642]     ...future.conditions <- base::list()
[17:45:25.642]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:25.642]     if (FALSE) {
[17:45:25.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:25.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:25.642]     }
[17:45:25.642]     ...future.result <- base::tryCatch({
[17:45:25.642]         base::withCallingHandlers({
[17:45:25.642]             ...future.value <- base::withVisible(base::local({
[17:45:25.642]                 ...future.makeSendCondition <- base::local({
[17:45:25.642]                   sendCondition <- NULL
[17:45:25.642]                   function(frame = 1L) {
[17:45:25.642]                     if (is.function(sendCondition)) 
[17:45:25.642]                       return(sendCondition)
[17:45:25.642]                     ns <- getNamespace("parallel")
[17:45:25.642]                     if (exists("sendData", mode = "function", 
[17:45:25.642]                       envir = ns)) {
[17:45:25.642]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:25.642]                         envir = ns)
[17:45:25.642]                       envir <- sys.frame(frame)
[17:45:25.642]                       master <- NULL
[17:45:25.642]                       while (!identical(envir, .GlobalEnv) && 
[17:45:25.642]                         !identical(envir, emptyenv())) {
[17:45:25.642]                         if (exists("master", mode = "list", envir = envir, 
[17:45:25.642]                           inherits = FALSE)) {
[17:45:25.642]                           master <- get("master", mode = "list", 
[17:45:25.642]                             envir = envir, inherits = FALSE)
[17:45:25.642]                           if (inherits(master, c("SOCKnode", 
[17:45:25.642]                             "SOCK0node"))) {
[17:45:25.642]                             sendCondition <<- function(cond) {
[17:45:25.642]                               data <- list(type = "VALUE", value = cond, 
[17:45:25.642]                                 success = TRUE)
[17:45:25.642]                               parallel_sendData(master, data)
[17:45:25.642]                             }
[17:45:25.642]                             return(sendCondition)
[17:45:25.642]                           }
[17:45:25.642]                         }
[17:45:25.642]                         frame <- frame + 1L
[17:45:25.642]                         envir <- sys.frame(frame)
[17:45:25.642]                       }
[17:45:25.642]                     }
[17:45:25.642]                     sendCondition <<- function(cond) NULL
[17:45:25.642]                   }
[17:45:25.642]                 })
[17:45:25.642]                 withCallingHandlers({
[17:45:25.642]                   {
[17:45:25.642]                     do.call(function(...) {
[17:45:25.642]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.642]                       if (!identical(...future.globals.maxSize.org, 
[17:45:25.642]                         ...future.globals.maxSize)) {
[17:45:25.642]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.642]                         on.exit(options(oopts), add = TRUE)
[17:45:25.642]                       }
[17:45:25.642]                       {
[17:45:25.642]                         lapply(seq_along(...future.elements_ii), 
[17:45:25.642]                           FUN = function(jj) {
[17:45:25.642]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.642]                             ...future.FUN(...future.X_jj, ...)
[17:45:25.642]                           })
[17:45:25.642]                       }
[17:45:25.642]                     }, args = future.call.arguments)
[17:45:25.642]                   }
[17:45:25.642]                 }, immediateCondition = function(cond) {
[17:45:25.642]                   sendCondition <- ...future.makeSendCondition()
[17:45:25.642]                   sendCondition(cond)
[17:45:25.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.642]                   {
[17:45:25.642]                     inherits <- base::inherits
[17:45:25.642]                     invokeRestart <- base::invokeRestart
[17:45:25.642]                     is.null <- base::is.null
[17:45:25.642]                     muffled <- FALSE
[17:45:25.642]                     if (inherits(cond, "message")) {
[17:45:25.642]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:25.642]                       if (muffled) 
[17:45:25.642]                         invokeRestart("muffleMessage")
[17:45:25.642]                     }
[17:45:25.642]                     else if (inherits(cond, "warning")) {
[17:45:25.642]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:25.642]                       if (muffled) 
[17:45:25.642]                         invokeRestart("muffleWarning")
[17:45:25.642]                     }
[17:45:25.642]                     else if (inherits(cond, "condition")) {
[17:45:25.642]                       if (!is.null(pattern)) {
[17:45:25.642]                         computeRestarts <- base::computeRestarts
[17:45:25.642]                         grepl <- base::grepl
[17:45:25.642]                         restarts <- computeRestarts(cond)
[17:45:25.642]                         for (restart in restarts) {
[17:45:25.642]                           name <- restart$name
[17:45:25.642]                           if (is.null(name)) 
[17:45:25.642]                             next
[17:45:25.642]                           if (!grepl(pattern, name)) 
[17:45:25.642]                             next
[17:45:25.642]                           invokeRestart(restart)
[17:45:25.642]                           muffled <- TRUE
[17:45:25.642]                           break
[17:45:25.642]                         }
[17:45:25.642]                       }
[17:45:25.642]                     }
[17:45:25.642]                     invisible(muffled)
[17:45:25.642]                   }
[17:45:25.642]                   muffleCondition(cond)
[17:45:25.642]                 })
[17:45:25.642]             }))
[17:45:25.642]             future::FutureResult(value = ...future.value$value, 
[17:45:25.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.642]                   ...future.rng), globalenv = if (FALSE) 
[17:45:25.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:25.642]                     ...future.globalenv.names))
[17:45:25.642]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:25.642]         }, condition = base::local({
[17:45:25.642]             c <- base::c
[17:45:25.642]             inherits <- base::inherits
[17:45:25.642]             invokeRestart <- base::invokeRestart
[17:45:25.642]             length <- base::length
[17:45:25.642]             list <- base::list
[17:45:25.642]             seq.int <- base::seq.int
[17:45:25.642]             signalCondition <- base::signalCondition
[17:45:25.642]             sys.calls <- base::sys.calls
[17:45:25.642]             `[[` <- base::`[[`
[17:45:25.642]             `+` <- base::`+`
[17:45:25.642]             `<<-` <- base::`<<-`
[17:45:25.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:25.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:25.642]                   3L)]
[17:45:25.642]             }
[17:45:25.642]             function(cond) {
[17:45:25.642]                 is_error <- inherits(cond, "error")
[17:45:25.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:25.642]                   NULL)
[17:45:25.642]                 if (is_error) {
[17:45:25.642]                   sessionInformation <- function() {
[17:45:25.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:25.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:25.642]                       search = base::search(), system = base::Sys.info())
[17:45:25.642]                   }
[17:45:25.642]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:25.642]                     cond$call), session = sessionInformation(), 
[17:45:25.642]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:25.642]                   signalCondition(cond)
[17:45:25.642]                 }
[17:45:25.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:25.642]                 "immediateCondition"))) {
[17:45:25.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:25.642]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:25.642]                   if (TRUE && !signal) {
[17:45:25.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.642]                     {
[17:45:25.642]                       inherits <- base::inherits
[17:45:25.642]                       invokeRestart <- base::invokeRestart
[17:45:25.642]                       is.null <- base::is.null
[17:45:25.642]                       muffled <- FALSE
[17:45:25.642]                       if (inherits(cond, "message")) {
[17:45:25.642]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.642]                         if (muffled) 
[17:45:25.642]                           invokeRestart("muffleMessage")
[17:45:25.642]                       }
[17:45:25.642]                       else if (inherits(cond, "warning")) {
[17:45:25.642]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.642]                         if (muffled) 
[17:45:25.642]                           invokeRestart("muffleWarning")
[17:45:25.642]                       }
[17:45:25.642]                       else if (inherits(cond, "condition")) {
[17:45:25.642]                         if (!is.null(pattern)) {
[17:45:25.642]                           computeRestarts <- base::computeRestarts
[17:45:25.642]                           grepl <- base::grepl
[17:45:25.642]                           restarts <- computeRestarts(cond)
[17:45:25.642]                           for (restart in restarts) {
[17:45:25.642]                             name <- restart$name
[17:45:25.642]                             if (is.null(name)) 
[17:45:25.642]                               next
[17:45:25.642]                             if (!grepl(pattern, name)) 
[17:45:25.642]                               next
[17:45:25.642]                             invokeRestart(restart)
[17:45:25.642]                             muffled <- TRUE
[17:45:25.642]                             break
[17:45:25.642]                           }
[17:45:25.642]                         }
[17:45:25.642]                       }
[17:45:25.642]                       invisible(muffled)
[17:45:25.642]                     }
[17:45:25.642]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.642]                   }
[17:45:25.642]                 }
[17:45:25.642]                 else {
[17:45:25.642]                   if (TRUE) {
[17:45:25.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.642]                     {
[17:45:25.642]                       inherits <- base::inherits
[17:45:25.642]                       invokeRestart <- base::invokeRestart
[17:45:25.642]                       is.null <- base::is.null
[17:45:25.642]                       muffled <- FALSE
[17:45:25.642]                       if (inherits(cond, "message")) {
[17:45:25.642]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.642]                         if (muffled) 
[17:45:25.642]                           invokeRestart("muffleMessage")
[17:45:25.642]                       }
[17:45:25.642]                       else if (inherits(cond, "warning")) {
[17:45:25.642]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.642]                         if (muffled) 
[17:45:25.642]                           invokeRestart("muffleWarning")
[17:45:25.642]                       }
[17:45:25.642]                       else if (inherits(cond, "condition")) {
[17:45:25.642]                         if (!is.null(pattern)) {
[17:45:25.642]                           computeRestarts <- base::computeRestarts
[17:45:25.642]                           grepl <- base::grepl
[17:45:25.642]                           restarts <- computeRestarts(cond)
[17:45:25.642]                           for (restart in restarts) {
[17:45:25.642]                             name <- restart$name
[17:45:25.642]                             if (is.null(name)) 
[17:45:25.642]                               next
[17:45:25.642]                             if (!grepl(pattern, name)) 
[17:45:25.642]                               next
[17:45:25.642]                             invokeRestart(restart)
[17:45:25.642]                             muffled <- TRUE
[17:45:25.642]                             break
[17:45:25.642]                           }
[17:45:25.642]                         }
[17:45:25.642]                       }
[17:45:25.642]                       invisible(muffled)
[17:45:25.642]                     }
[17:45:25.642]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.642]                   }
[17:45:25.642]                 }
[17:45:25.642]             }
[17:45:25.642]         }))
[17:45:25.642]     }, error = function(ex) {
[17:45:25.642]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:25.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.642]                 ...future.rng), started = ...future.startTime, 
[17:45:25.642]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:25.642]             version = "1.8"), class = "FutureResult")
[17:45:25.642]     }, finally = {
[17:45:25.642]         if (!identical(...future.workdir, getwd())) 
[17:45:25.642]             setwd(...future.workdir)
[17:45:25.642]         {
[17:45:25.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:25.642]                 ...future.oldOptions$nwarnings <- NULL
[17:45:25.642]             }
[17:45:25.642]             base::options(...future.oldOptions)
[17:45:25.642]             if (.Platform$OS.type == "windows") {
[17:45:25.642]                 old_names <- names(...future.oldEnvVars)
[17:45:25.642]                 envs <- base::Sys.getenv()
[17:45:25.642]                 names <- names(envs)
[17:45:25.642]                 common <- intersect(names, old_names)
[17:45:25.642]                 added <- setdiff(names, old_names)
[17:45:25.642]                 removed <- setdiff(old_names, names)
[17:45:25.642]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:25.642]                   envs[common]]
[17:45:25.642]                 NAMES <- toupper(changed)
[17:45:25.642]                 args <- list()
[17:45:25.642]                 for (kk in seq_along(NAMES)) {
[17:45:25.642]                   name <- changed[[kk]]
[17:45:25.642]                   NAME <- NAMES[[kk]]
[17:45:25.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.642]                     next
[17:45:25.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.642]                 }
[17:45:25.642]                 NAMES <- toupper(added)
[17:45:25.642]                 for (kk in seq_along(NAMES)) {
[17:45:25.642]                   name <- added[[kk]]
[17:45:25.642]                   NAME <- NAMES[[kk]]
[17:45:25.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.642]                     next
[17:45:25.642]                   args[[name]] <- ""
[17:45:25.642]                 }
[17:45:25.642]                 NAMES <- toupper(removed)
[17:45:25.642]                 for (kk in seq_along(NAMES)) {
[17:45:25.642]                   name <- removed[[kk]]
[17:45:25.642]                   NAME <- NAMES[[kk]]
[17:45:25.642]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.642]                     next
[17:45:25.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.642]                 }
[17:45:25.642]                 if (length(args) > 0) 
[17:45:25.642]                   base::do.call(base::Sys.setenv, args = args)
[17:45:25.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:25.642]             }
[17:45:25.642]             else {
[17:45:25.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:25.642]             }
[17:45:25.642]             {
[17:45:25.642]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:25.642]                   0L) {
[17:45:25.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:25.642]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:25.642]                   base::options(opts)
[17:45:25.642]                 }
[17:45:25.642]                 {
[17:45:25.642]                   {
[17:45:25.642]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:25.642]                     NULL
[17:45:25.642]                   }
[17:45:25.642]                   options(future.plan = NULL)
[17:45:25.642]                   if (is.na(NA_character_)) 
[17:45:25.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:25.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:25.642]                     .init = FALSE)
[17:45:25.642]                 }
[17:45:25.642]             }
[17:45:25.642]         }
[17:45:25.642]     })
[17:45:25.642]     if (TRUE) {
[17:45:25.642]         base::sink(type = "output", split = FALSE)
[17:45:25.642]         if (TRUE) {
[17:45:25.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:25.642]         }
[17:45:25.642]         else {
[17:45:25.642]             ...future.result["stdout"] <- base::list(NULL)
[17:45:25.642]         }
[17:45:25.642]         base::close(...future.stdout)
[17:45:25.642]         ...future.stdout <- NULL
[17:45:25.642]     }
[17:45:25.642]     ...future.result$conditions <- ...future.conditions
[17:45:25.642]     ...future.result$finished <- base::Sys.time()
[17:45:25.642]     ...future.result
[17:45:25.642] }
[17:45:25.645] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[17:45:25.645] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:25.688] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:25.688] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[17:45:25.688] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[17:45:25.688] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:25.689] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:25.689] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:25.732] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:25.732] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:25.776] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:25.776] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[17:45:25.776] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[17:45:25.777] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:45:25.777] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:45:25.777] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[17:45:25.778] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[17:45:25.778] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:45:25.778] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:45:25.778] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:25.779] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:25.779] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:25.780] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[17:45:25.780] MultisessionFuture started
[17:45:25.780] - Launch lazy future ... done
[17:45:25.780] run() for ‘MultisessionFuture’ ... done
[17:45:25.780] Created future:
[17:45:25.782] receiveMessageFromWorker() for ClusterFuture ...
[17:45:25.782] - Validating connection of MultisessionFuture
[17:45:25.782] - received message: FutureResult
[17:45:25.782] - Received FutureResult
[17:45:25.782] - Erased future from FutureRegistry
[17:45:25.782] result() for ClusterFuture ...
[17:45:25.783] - result already collected: FutureResult
[17:45:25.783] result() for ClusterFuture ... done
[17:45:25.783] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:25.781] MultisessionFuture:
[17:45:25.781] Label: ‘future_vapply-2’
[17:45:25.781] Expression:
[17:45:25.781] {
[17:45:25.781]     do.call(function(...) {
[17:45:25.781]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.781]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.781]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.781]             on.exit(options(oopts), add = TRUE)
[17:45:25.781]         }
[17:45:25.781]         {
[17:45:25.781]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.781]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.781]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.781]             })
[17:45:25.781]         }
[17:45:25.781]     }, args = future.call.arguments)
[17:45:25.781] }
[17:45:25.781] Lazy evaluation: FALSE
[17:45:25.781] Asynchronous evaluation: TRUE
[17:45:25.781] Local evaluation: TRUE
[17:45:25.781] Environment: R_GlobalEnv
[17:45:25.781] Capture standard output: TRUE
[17:45:25.781] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.781] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:25.781] Packages: 1 packages (‘future.apply’)
[17:45:25.781] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.781] Resolved: TRUE
[17:45:25.781] Value: <not collected>
[17:45:25.781] Conditions captured: <none>
[17:45:25.781] Early signaling: FALSE
[17:45:25.781] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.781] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.783] Chunk #2 of 2 ... DONE
[17:45:25.783] Launching 2 futures (chunks) ... DONE
[17:45:25.783] Resolving 2 futures (chunks) ...
[17:45:25.783] resolve() on list ...
[17:45:25.783]  recursive: 0
[17:45:25.784]  length: 2
[17:45:25.784] 
[17:45:25.784] receiveMessageFromWorker() for ClusterFuture ...
[17:45:25.784] - Validating connection of MultisessionFuture
[17:45:25.784] - received message: FutureResult
[17:45:25.784] - Received FutureResult
[17:45:25.784] - Erased future from FutureRegistry
[17:45:25.785] result() for ClusterFuture ...
[17:45:25.785] - result already collected: FutureResult
[17:45:25.785] result() for ClusterFuture ... done
[17:45:25.785] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:25.785] Future #1
[17:45:25.785] result() for ClusterFuture ...
[17:45:25.785] - result already collected: FutureResult
[17:45:25.785] result() for ClusterFuture ... done
[17:45:25.785] result() for ClusterFuture ...
[17:45:25.785] - result already collected: FutureResult
[17:45:25.785] result() for ClusterFuture ... done
[17:45:25.786] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:25.786] - nx: 2
[17:45:25.786] - relay: TRUE
[17:45:25.786] - stdout: TRUE
[17:45:25.786] - signal: TRUE
[17:45:25.786] - resignal: FALSE
[17:45:25.786] - force: TRUE
[17:45:25.786] - relayed: [n=2] FALSE, FALSE
[17:45:25.786] - queued futures: [n=2] FALSE, FALSE
[17:45:25.786]  - until=1
[17:45:25.786]  - relaying element #1
[17:45:25.786] result() for ClusterFuture ...
[17:45:25.787] - result already collected: FutureResult
[17:45:25.787] result() for ClusterFuture ... done
[17:45:25.787] result() for ClusterFuture ...
[17:45:25.787] - result already collected: FutureResult
[17:45:25.787] result() for ClusterFuture ... done
[17:45:25.787] result() for ClusterFuture ...
[17:45:25.787] - result already collected: FutureResult
[17:45:25.787] result() for ClusterFuture ... done
[17:45:25.787] result() for ClusterFuture ...
[17:45:25.787] - result already collected: FutureResult
[17:45:25.787] result() for ClusterFuture ... done
[17:45:25.787] - relayed: [n=2] TRUE, FALSE
[17:45:25.788] - queued futures: [n=2] TRUE, FALSE
[17:45:25.788] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:25.788]  length: 1 (resolved future 1)
[17:45:25.788] Future #2
[17:45:25.788] result() for ClusterFuture ...
[17:45:25.788] - result already collected: FutureResult
[17:45:25.788] result() for ClusterFuture ... done
[17:45:25.788] result() for ClusterFuture ...
[17:45:25.788] - result already collected: FutureResult
[17:45:25.788] result() for ClusterFuture ... done
[17:45:25.788] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:25.789] - nx: 2
[17:45:25.789] - relay: TRUE
[17:45:25.789] - stdout: TRUE
[17:45:25.789] - signal: TRUE
[17:45:25.789] - resignal: FALSE
[17:45:25.789] - force: TRUE
[17:45:25.789] - relayed: [n=2] TRUE, FALSE
[17:45:25.789] - queued futures: [n=2] TRUE, FALSE
[17:45:25.789]  - until=2
[17:45:25.789]  - relaying element #2
[17:45:25.789] result() for ClusterFuture ...
[17:45:25.789] - result already collected: FutureResult
[17:45:25.790] result() for ClusterFuture ... done
[17:45:25.790] result() for ClusterFuture ...
[17:45:25.790] - result already collected: FutureResult
[17:45:25.790] result() for ClusterFuture ... done
[17:45:25.790] result() for ClusterFuture ...
[17:45:25.790] - result already collected: FutureResult
[17:45:25.790] result() for ClusterFuture ... done
[17:45:25.790] result() for ClusterFuture ...
[17:45:25.790] - result already collected: FutureResult
[17:45:25.790] result() for ClusterFuture ... done
[17:45:25.790] - relayed: [n=2] TRUE, TRUE
[17:45:25.790] - queued futures: [n=2] TRUE, TRUE
[17:45:25.791] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:25.791]  length: 0 (resolved future 2)
[17:45:25.791] Relaying remaining futures
[17:45:25.791] signalConditionsASAP(NULL, pos=0) ...
[17:45:25.791] - nx: 2
[17:45:25.791] - relay: TRUE
[17:45:25.791] - stdout: TRUE
[17:45:25.791] - signal: TRUE
[17:45:25.791] - resignal: FALSE
[17:45:25.791] - force: TRUE
[17:45:25.791] - relayed: [n=2] TRUE, TRUE
[17:45:25.791] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:25.792] - relayed: [n=2] TRUE, TRUE
[17:45:25.792] - queued futures: [n=2] TRUE, TRUE
[17:45:25.792] signalConditionsASAP(NULL, pos=0) ... done
[17:45:25.792] resolve() on list ... DONE
[17:45:25.792] result() for ClusterFuture ...
[17:45:25.792] - result already collected: FutureResult
[17:45:25.792] result() for ClusterFuture ... done
[17:45:25.792] result() for ClusterFuture ...
[17:45:25.792] - result already collected: FutureResult
[17:45:25.792] result() for ClusterFuture ... done
[17:45:25.792] result() for ClusterFuture ...
[17:45:25.793] - result already collected: FutureResult
[17:45:25.793] result() for ClusterFuture ... done
[17:45:25.793] result() for ClusterFuture ...
[17:45:25.793] - result already collected: FutureResult
[17:45:25.793] result() for ClusterFuture ... done
[17:45:25.793]  - Number of value chunks collected: 2
[17:45:25.793] Resolving 2 futures (chunks) ... DONE
[17:45:25.793] Reducing values from 2 chunks ...
[17:45:25.793]  - Number of values collected after concatenation: 4
[17:45:25.793]  - Number of values expected: 4
[17:45:25.793] Reducing values from 2 chunks ... DONE
[17:45:25.793] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[17:45:25.795] future_lapply() ...
[17:45:25.800] Number of chunks: 2
[17:45:25.801] getGlobalsAndPackagesXApply() ...
[17:45:25.801]  - future.globals: TRUE
[17:45:25.801] getGlobalsAndPackages() ...
[17:45:25.801] Searching for globals...
[17:45:25.804] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:25.804] Searching for globals ... DONE
[17:45:25.804] Resolving globals: FALSE
[17:45:25.805] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[17:45:25.805] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:25.805] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:25.805] - packages: [1] ‘future.apply’
[17:45:25.806] getGlobalsAndPackages() ... DONE
[17:45:25.806]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:25.806]  - needed namespaces: [n=1] ‘future.apply’
[17:45:25.806] Finding globals ... DONE
[17:45:25.806]  - use_args: TRUE
[17:45:25.806]  - Getting '...' globals ...
[17:45:25.806] resolve() on list ...
[17:45:25.806]  recursive: 0
[17:45:25.806]  length: 1
[17:45:25.807]  elements: ‘...’
[17:45:25.807]  length: 0 (resolved future 1)
[17:45:25.807] resolve() on list ... DONE
[17:45:25.807]    - '...' content: [n=0] 
[17:45:25.807] List of 1
[17:45:25.807]  $ ...: list()
[17:45:25.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:25.807]  - attr(*, "where")=List of 1
[17:45:25.807]   ..$ ...:<environment: 0x5561f6dbdc30> 
[17:45:25.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:25.807]  - attr(*, "resolved")= logi TRUE
[17:45:25.807]  - attr(*, "total_size")= num NA
[17:45:25.809]  - Getting '...' globals ... DONE
[17:45:25.810] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:25.810] List of 8
[17:45:25.810]  $ ...future.FUN:function (x, ...)  
[17:45:25.810]  $ x_FUN        :function (x)  
[17:45:25.810]  $ times        : int 1
[17:45:25.810]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:25.810]  $ stop_if_not  :function (...)  
[17:45:25.810]  $ dim          : NULL
[17:45:25.810]  $ valid_types  : chr "logical"
[17:45:25.810]  $ ...          : list()
[17:45:25.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:25.810]  - attr(*, "where")=List of 8
[17:45:25.810]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:25.810]   ..$ ...          :<environment: 0x5561f6dbdc30> 
[17:45:25.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:25.810]  - attr(*, "resolved")= logi FALSE
[17:45:25.810]  - attr(*, "total_size")= num 94200
[17:45:25.815] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:25.815] getGlobalsAndPackagesXApply() ... DONE
[17:45:25.815] Number of futures (= number of chunks): 2
[17:45:25.815] Launching 2 futures (chunks) ...
[17:45:25.815] Chunk #1 of 2 ...
[17:45:25.815]  - Finding globals in 'X' for chunk #1 ...
[17:45:25.816] getGlobalsAndPackages() ...
[17:45:25.816] Searching for globals...
[17:45:25.816] 
[17:45:25.816] Searching for globals ... DONE
[17:45:25.816] - globals: [0] <none>
[17:45:25.816] getGlobalsAndPackages() ... DONE
[17:45:25.816]    + additional globals found: [n=0] 
[17:45:25.816]    + additional namespaces needed: [n=0] 
[17:45:25.816]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:25.817]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.817]  - seeds: <none>
[17:45:25.817]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.817] getGlobalsAndPackages() ...
[17:45:25.817] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.817] Resolving globals: FALSE
[17:45:25.817] Tweak future expression to call with '...' arguments ...
[17:45:25.817] {
[17:45:25.817]     do.call(function(...) {
[17:45:25.817]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.817]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.817]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.817]             on.exit(options(oopts), add = TRUE)
[17:45:25.817]         }
[17:45:25.817]         {
[17:45:25.817]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.817]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.817]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.817]             })
[17:45:25.817]         }
[17:45:25.817]     }, args = future.call.arguments)
[17:45:25.817] }
[17:45:25.817] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.818] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.818] - packages: [1] ‘future.apply’
[17:45:25.818] getGlobalsAndPackages() ... DONE
[17:45:25.818] run() for ‘Future’ ...
[17:45:25.819] - state: ‘created’
[17:45:25.819] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:25.833] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:25.833]   - Field: ‘node’
[17:45:25.833]   - Field: ‘label’
[17:45:25.833]   - Field: ‘local’
[17:45:25.833]   - Field: ‘owner’
[17:45:25.833]   - Field: ‘envir’
[17:45:25.833]   - Field: ‘workers’
[17:45:25.833]   - Field: ‘packages’
[17:45:25.833]   - Field: ‘gc’
[17:45:25.834]   - Field: ‘conditions’
[17:45:25.834]   - Field: ‘persistent’
[17:45:25.834]   - Field: ‘expr’
[17:45:25.834]   - Field: ‘uuid’
[17:45:25.834]   - Field: ‘seed’
[17:45:25.834]   - Field: ‘version’
[17:45:25.834]   - Field: ‘result’
[17:45:25.834]   - Field: ‘asynchronous’
[17:45:25.834]   - Field: ‘calls’
[17:45:25.834]   - Field: ‘globals’
[17:45:25.834]   - Field: ‘stdout’
[17:45:25.835]   - Field: ‘earlySignal’
[17:45:25.835]   - Field: ‘lazy’
[17:45:25.835]   - Field: ‘state’
[17:45:25.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:25.835] - Launch lazy future ...
[17:45:25.835] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:25.835] Packages needed by future strategies (n = 0): <none>
[17:45:25.836] {
[17:45:25.836]     {
[17:45:25.836]         {
[17:45:25.836]             ...future.startTime <- base::Sys.time()
[17:45:25.836]             {
[17:45:25.836]                 {
[17:45:25.836]                   {
[17:45:25.836]                     {
[17:45:25.836]                       {
[17:45:25.836]                         base::local({
[17:45:25.836]                           has_future <- base::requireNamespace("future", 
[17:45:25.836]                             quietly = TRUE)
[17:45:25.836]                           if (has_future) {
[17:45:25.836]                             ns <- base::getNamespace("future")
[17:45:25.836]                             version <- ns[[".package"]][["version"]]
[17:45:25.836]                             if (is.null(version)) 
[17:45:25.836]                               version <- utils::packageVersion("future")
[17:45:25.836]                           }
[17:45:25.836]                           else {
[17:45:25.836]                             version <- NULL
[17:45:25.836]                           }
[17:45:25.836]                           if (!has_future || version < "1.8.0") {
[17:45:25.836]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:25.836]                               "", base::R.version$version.string), 
[17:45:25.836]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:25.836]                                 base::R.version$platform, 8 * 
[17:45:25.836]                                   base::.Machine$sizeof.pointer), 
[17:45:25.836]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:25.836]                                 "release", "version")], collapse = " "), 
[17:45:25.836]                               hostname = base::Sys.info()[["nodename"]])
[17:45:25.836]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:25.836]                               info)
[17:45:25.836]                             info <- base::paste(info, collapse = "; ")
[17:45:25.836]                             if (!has_future) {
[17:45:25.836]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:25.836]                                 info)
[17:45:25.836]                             }
[17:45:25.836]                             else {
[17:45:25.836]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:25.836]                                 info, version)
[17:45:25.836]                             }
[17:45:25.836]                             base::stop(msg)
[17:45:25.836]                           }
[17:45:25.836]                         })
[17:45:25.836]                       }
[17:45:25.836]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:25.836]                       base::options(mc.cores = 1L)
[17:45:25.836]                     }
[17:45:25.836]                     base::local({
[17:45:25.836]                       for (pkg in "future.apply") {
[17:45:25.836]                         base::loadNamespace(pkg)
[17:45:25.836]                         base::library(pkg, character.only = TRUE)
[17:45:25.836]                       }
[17:45:25.836]                     })
[17:45:25.836]                   }
[17:45:25.836]                   ...future.strategy.old <- future::plan("list")
[17:45:25.836]                   options(future.plan = NULL)
[17:45:25.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:25.836]                 }
[17:45:25.836]                 ...future.workdir <- getwd()
[17:45:25.836]             }
[17:45:25.836]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:25.836]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:25.836]         }
[17:45:25.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:25.836]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:25.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:25.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:25.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:25.836]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:25.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:25.836]             base::names(...future.oldOptions))
[17:45:25.836]     }
[17:45:25.836]     if (FALSE) {
[17:45:25.836]     }
[17:45:25.836]     else {
[17:45:25.836]         if (TRUE) {
[17:45:25.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:25.836]                 open = "w")
[17:45:25.836]         }
[17:45:25.836]         else {
[17:45:25.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:25.836]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:25.836]         }
[17:45:25.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:25.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:25.836]             base::sink(type = "output", split = FALSE)
[17:45:25.836]             base::close(...future.stdout)
[17:45:25.836]         }, add = TRUE)
[17:45:25.836]     }
[17:45:25.836]     ...future.frame <- base::sys.nframe()
[17:45:25.836]     ...future.conditions <- base::list()
[17:45:25.836]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:25.836]     if (FALSE) {
[17:45:25.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:25.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:25.836]     }
[17:45:25.836]     ...future.result <- base::tryCatch({
[17:45:25.836]         base::withCallingHandlers({
[17:45:25.836]             ...future.value <- base::withVisible(base::local({
[17:45:25.836]                 ...future.makeSendCondition <- base::local({
[17:45:25.836]                   sendCondition <- NULL
[17:45:25.836]                   function(frame = 1L) {
[17:45:25.836]                     if (is.function(sendCondition)) 
[17:45:25.836]                       return(sendCondition)
[17:45:25.836]                     ns <- getNamespace("parallel")
[17:45:25.836]                     if (exists("sendData", mode = "function", 
[17:45:25.836]                       envir = ns)) {
[17:45:25.836]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:25.836]                         envir = ns)
[17:45:25.836]                       envir <- sys.frame(frame)
[17:45:25.836]                       master <- NULL
[17:45:25.836]                       while (!identical(envir, .GlobalEnv) && 
[17:45:25.836]                         !identical(envir, emptyenv())) {
[17:45:25.836]                         if (exists("master", mode = "list", envir = envir, 
[17:45:25.836]                           inherits = FALSE)) {
[17:45:25.836]                           master <- get("master", mode = "list", 
[17:45:25.836]                             envir = envir, inherits = FALSE)
[17:45:25.836]                           if (inherits(master, c("SOCKnode", 
[17:45:25.836]                             "SOCK0node"))) {
[17:45:25.836]                             sendCondition <<- function(cond) {
[17:45:25.836]                               data <- list(type = "VALUE", value = cond, 
[17:45:25.836]                                 success = TRUE)
[17:45:25.836]                               parallel_sendData(master, data)
[17:45:25.836]                             }
[17:45:25.836]                             return(sendCondition)
[17:45:25.836]                           }
[17:45:25.836]                         }
[17:45:25.836]                         frame <- frame + 1L
[17:45:25.836]                         envir <- sys.frame(frame)
[17:45:25.836]                       }
[17:45:25.836]                     }
[17:45:25.836]                     sendCondition <<- function(cond) NULL
[17:45:25.836]                   }
[17:45:25.836]                 })
[17:45:25.836]                 withCallingHandlers({
[17:45:25.836]                   {
[17:45:25.836]                     do.call(function(...) {
[17:45:25.836]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.836]                       if (!identical(...future.globals.maxSize.org, 
[17:45:25.836]                         ...future.globals.maxSize)) {
[17:45:25.836]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.836]                         on.exit(options(oopts), add = TRUE)
[17:45:25.836]                       }
[17:45:25.836]                       {
[17:45:25.836]                         lapply(seq_along(...future.elements_ii), 
[17:45:25.836]                           FUN = function(jj) {
[17:45:25.836]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.836]                             ...future.FUN(...future.X_jj, ...)
[17:45:25.836]                           })
[17:45:25.836]                       }
[17:45:25.836]                     }, args = future.call.arguments)
[17:45:25.836]                   }
[17:45:25.836]                 }, immediateCondition = function(cond) {
[17:45:25.836]                   sendCondition <- ...future.makeSendCondition()
[17:45:25.836]                   sendCondition(cond)
[17:45:25.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.836]                   {
[17:45:25.836]                     inherits <- base::inherits
[17:45:25.836]                     invokeRestart <- base::invokeRestart
[17:45:25.836]                     is.null <- base::is.null
[17:45:25.836]                     muffled <- FALSE
[17:45:25.836]                     if (inherits(cond, "message")) {
[17:45:25.836]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:25.836]                       if (muffled) 
[17:45:25.836]                         invokeRestart("muffleMessage")
[17:45:25.836]                     }
[17:45:25.836]                     else if (inherits(cond, "warning")) {
[17:45:25.836]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:25.836]                       if (muffled) 
[17:45:25.836]                         invokeRestart("muffleWarning")
[17:45:25.836]                     }
[17:45:25.836]                     else if (inherits(cond, "condition")) {
[17:45:25.836]                       if (!is.null(pattern)) {
[17:45:25.836]                         computeRestarts <- base::computeRestarts
[17:45:25.836]                         grepl <- base::grepl
[17:45:25.836]                         restarts <- computeRestarts(cond)
[17:45:25.836]                         for (restart in restarts) {
[17:45:25.836]                           name <- restart$name
[17:45:25.836]                           if (is.null(name)) 
[17:45:25.836]                             next
[17:45:25.836]                           if (!grepl(pattern, name)) 
[17:45:25.836]                             next
[17:45:25.836]                           invokeRestart(restart)
[17:45:25.836]                           muffled <- TRUE
[17:45:25.836]                           break
[17:45:25.836]                         }
[17:45:25.836]                       }
[17:45:25.836]                     }
[17:45:25.836]                     invisible(muffled)
[17:45:25.836]                   }
[17:45:25.836]                   muffleCondition(cond)
[17:45:25.836]                 })
[17:45:25.836]             }))
[17:45:25.836]             future::FutureResult(value = ...future.value$value, 
[17:45:25.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.836]                   ...future.rng), globalenv = if (FALSE) 
[17:45:25.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:25.836]                     ...future.globalenv.names))
[17:45:25.836]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:25.836]         }, condition = base::local({
[17:45:25.836]             c <- base::c
[17:45:25.836]             inherits <- base::inherits
[17:45:25.836]             invokeRestart <- base::invokeRestart
[17:45:25.836]             length <- base::length
[17:45:25.836]             list <- base::list
[17:45:25.836]             seq.int <- base::seq.int
[17:45:25.836]             signalCondition <- base::signalCondition
[17:45:25.836]             sys.calls <- base::sys.calls
[17:45:25.836]             `[[` <- base::`[[`
[17:45:25.836]             `+` <- base::`+`
[17:45:25.836]             `<<-` <- base::`<<-`
[17:45:25.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:25.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:25.836]                   3L)]
[17:45:25.836]             }
[17:45:25.836]             function(cond) {
[17:45:25.836]                 is_error <- inherits(cond, "error")
[17:45:25.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:25.836]                   NULL)
[17:45:25.836]                 if (is_error) {
[17:45:25.836]                   sessionInformation <- function() {
[17:45:25.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:25.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:25.836]                       search = base::search(), system = base::Sys.info())
[17:45:25.836]                   }
[17:45:25.836]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:25.836]                     cond$call), session = sessionInformation(), 
[17:45:25.836]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:25.836]                   signalCondition(cond)
[17:45:25.836]                 }
[17:45:25.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:25.836]                 "immediateCondition"))) {
[17:45:25.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:25.836]                   ...future.conditions[[length(...future.conditions) + 
[17:45:25.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:25.836]                   if (TRUE && !signal) {
[17:45:25.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.836]                     {
[17:45:25.836]                       inherits <- base::inherits
[17:45:25.836]                       invokeRestart <- base::invokeRestart
[17:45:25.836]                       is.null <- base::is.null
[17:45:25.836]                       muffled <- FALSE
[17:45:25.836]                       if (inherits(cond, "message")) {
[17:45:25.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.836]                         if (muffled) 
[17:45:25.836]                           invokeRestart("muffleMessage")
[17:45:25.836]                       }
[17:45:25.836]                       else if (inherits(cond, "warning")) {
[17:45:25.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.836]                         if (muffled) 
[17:45:25.836]                           invokeRestart("muffleWarning")
[17:45:25.836]                       }
[17:45:25.836]                       else if (inherits(cond, "condition")) {
[17:45:25.836]                         if (!is.null(pattern)) {
[17:45:25.836]                           computeRestarts <- base::computeRestarts
[17:45:25.836]                           grepl <- base::grepl
[17:45:25.836]                           restarts <- computeRestarts(cond)
[17:45:25.836]                           for (restart in restarts) {
[17:45:25.836]                             name <- restart$name
[17:45:25.836]                             if (is.null(name)) 
[17:45:25.836]                               next
[17:45:25.836]                             if (!grepl(pattern, name)) 
[17:45:25.836]                               next
[17:45:25.836]                             invokeRestart(restart)
[17:45:25.836]                             muffled <- TRUE
[17:45:25.836]                             break
[17:45:25.836]                           }
[17:45:25.836]                         }
[17:45:25.836]                       }
[17:45:25.836]                       invisible(muffled)
[17:45:25.836]                     }
[17:45:25.836]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.836]                   }
[17:45:25.836]                 }
[17:45:25.836]                 else {
[17:45:25.836]                   if (TRUE) {
[17:45:25.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:25.836]                     {
[17:45:25.836]                       inherits <- base::inherits
[17:45:25.836]                       invokeRestart <- base::invokeRestart
[17:45:25.836]                       is.null <- base::is.null
[17:45:25.836]                       muffled <- FALSE
[17:45:25.836]                       if (inherits(cond, "message")) {
[17:45:25.836]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:25.836]                         if (muffled) 
[17:45:25.836]                           invokeRestart("muffleMessage")
[17:45:25.836]                       }
[17:45:25.836]                       else if (inherits(cond, "warning")) {
[17:45:25.836]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:25.836]                         if (muffled) 
[17:45:25.836]                           invokeRestart("muffleWarning")
[17:45:25.836]                       }
[17:45:25.836]                       else if (inherits(cond, "condition")) {
[17:45:25.836]                         if (!is.null(pattern)) {
[17:45:25.836]                           computeRestarts <- base::computeRestarts
[17:45:25.836]                           grepl <- base::grepl
[17:45:25.836]                           restarts <- computeRestarts(cond)
[17:45:25.836]                           for (restart in restarts) {
[17:45:25.836]                             name <- restart$name
[17:45:25.836]                             if (is.null(name)) 
[17:45:25.836]                               next
[17:45:25.836]                             if (!grepl(pattern, name)) 
[17:45:25.836]                               next
[17:45:25.836]                             invokeRestart(restart)
[17:45:25.836]                             muffled <- TRUE
[17:45:25.836]                             break
[17:45:25.836]                           }
[17:45:25.836]                         }
[17:45:25.836]                       }
[17:45:25.836]                       invisible(muffled)
[17:45:25.836]                     }
[17:45:25.836]                     muffleCondition(cond, pattern = "^muffle")
[17:45:25.836]                   }
[17:45:25.836]                 }
[17:45:25.836]             }
[17:45:25.836]         }))
[17:45:25.836]     }, error = function(ex) {
[17:45:25.836]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:25.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:25.836]                 ...future.rng), started = ...future.startTime, 
[17:45:25.836]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:25.836]             version = "1.8"), class = "FutureResult")
[17:45:25.836]     }, finally = {
[17:45:25.836]         if (!identical(...future.workdir, getwd())) 
[17:45:25.836]             setwd(...future.workdir)
[17:45:25.836]         {
[17:45:25.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:25.836]                 ...future.oldOptions$nwarnings <- NULL
[17:45:25.836]             }
[17:45:25.836]             base::options(...future.oldOptions)
[17:45:25.836]             if (.Platform$OS.type == "windows") {
[17:45:25.836]                 old_names <- names(...future.oldEnvVars)
[17:45:25.836]                 envs <- base::Sys.getenv()
[17:45:25.836]                 names <- names(envs)
[17:45:25.836]                 common <- intersect(names, old_names)
[17:45:25.836]                 added <- setdiff(names, old_names)
[17:45:25.836]                 removed <- setdiff(old_names, names)
[17:45:25.836]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:25.836]                   envs[common]]
[17:45:25.836]                 NAMES <- toupper(changed)
[17:45:25.836]                 args <- list()
[17:45:25.836]                 for (kk in seq_along(NAMES)) {
[17:45:25.836]                   name <- changed[[kk]]
[17:45:25.836]                   NAME <- NAMES[[kk]]
[17:45:25.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.836]                     next
[17:45:25.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.836]                 }
[17:45:25.836]                 NAMES <- toupper(added)
[17:45:25.836]                 for (kk in seq_along(NAMES)) {
[17:45:25.836]                   name <- added[[kk]]
[17:45:25.836]                   NAME <- NAMES[[kk]]
[17:45:25.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.836]                     next
[17:45:25.836]                   args[[name]] <- ""
[17:45:25.836]                 }
[17:45:25.836]                 NAMES <- toupper(removed)
[17:45:25.836]                 for (kk in seq_along(NAMES)) {
[17:45:25.836]                   name <- removed[[kk]]
[17:45:25.836]                   NAME <- NAMES[[kk]]
[17:45:25.836]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:25.836]                     next
[17:45:25.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:25.836]                 }
[17:45:25.836]                 if (length(args) > 0) 
[17:45:25.836]                   base::do.call(base::Sys.setenv, args = args)
[17:45:25.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:25.836]             }
[17:45:25.836]             else {
[17:45:25.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:25.836]             }
[17:45:25.836]             {
[17:45:25.836]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:25.836]                   0L) {
[17:45:25.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:25.836]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:25.836]                   base::options(opts)
[17:45:25.836]                 }
[17:45:25.836]                 {
[17:45:25.836]                   {
[17:45:25.836]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:25.836]                     NULL
[17:45:25.836]                   }
[17:45:25.836]                   options(future.plan = NULL)
[17:45:25.836]                   if (is.na(NA_character_)) 
[17:45:25.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:25.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:25.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:25.836]                     .init = FALSE)
[17:45:25.836]                 }
[17:45:25.836]             }
[17:45:25.836]         }
[17:45:25.836]     })
[17:45:25.836]     if (TRUE) {
[17:45:25.836]         base::sink(type = "output", split = FALSE)
[17:45:25.836]         if (TRUE) {
[17:45:25.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:25.836]         }
[17:45:25.836]         else {
[17:45:25.836]             ...future.result["stdout"] <- base::list(NULL)
[17:45:25.836]         }
[17:45:25.836]         base::close(...future.stdout)
[17:45:25.836]         ...future.stdout <- NULL
[17:45:25.836]     }
[17:45:25.836]     ...future.result$conditions <- ...future.conditions
[17:45:25.836]     ...future.result$finished <- base::Sys.time()
[17:45:25.836]     ...future.result
[17:45:25.836] }
[17:45:25.839] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[17:45:25.839] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:25.880] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:25.880] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:45:25.880] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:45:25.880] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:25.881] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:25.881] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:25.924] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:25.924] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:25.968] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:25.968] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:25.968] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.968] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[17:45:25.969] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[17:45:25.969] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:25.969] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.970] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[17:45:25.970] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[17:45:25.970] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:25.970] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.970] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:25.971] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:25.971] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[17:45:25.972] MultisessionFuture started
[17:45:25.972] - Launch lazy future ... done
[17:45:25.972] run() for ‘MultisessionFuture’ ... done
[17:45:25.972] Created future:
[17:45:25.972] MultisessionFuture:
[17:45:25.972] Label: ‘future_vapply-1’
[17:45:25.972] Expression:
[17:45:25.972] {
[17:45:25.972]     do.call(function(...) {
[17:45:25.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.972]             on.exit(options(oopts), add = TRUE)
[17:45:25.972]         }
[17:45:25.972]         {
[17:45:25.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.972]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.972]             })
[17:45:25.972]         }
[17:45:25.972]     }, args = future.call.arguments)
[17:45:25.972] }
[17:45:25.972] Lazy evaluation: FALSE
[17:45:25.972] Asynchronous evaluation: TRUE
[17:45:25.972] Local evaluation: TRUE
[17:45:25.972] Environment: R_GlobalEnv
[17:45:25.972] Capture standard output: TRUE
[17:45:25.972] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:25.972] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:25.972] Packages: 1 packages (‘future.apply’)
[17:45:25.972] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:25.972] Resolved: FALSE
[17:45:25.972] Value: <not collected>
[17:45:25.972] Conditions captured: <none>
[17:45:25.972] Early signaling: FALSE
[17:45:25.972] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:25.972] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:25.987] Chunk #1 of 2 ... DONE
[17:45:25.987] Chunk #2 of 2 ...
[17:45:25.987]  - Finding globals in 'X' for chunk #2 ...
[17:45:25.987] getGlobalsAndPackages() ...
[17:45:25.987] Searching for globals...
[17:45:25.988] 
[17:45:25.988] Searching for globals ... DONE
[17:45:25.988] - globals: [0] <none>
[17:45:25.988] getGlobalsAndPackages() ... DONE
[17:45:25.988]    + additional globals found: [n=0] 
[17:45:25.988]    + additional namespaces needed: [n=0] 
[17:45:25.988]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:25.988]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:25.988]  - seeds: <none>
[17:45:25.988]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.989] getGlobalsAndPackages() ...
[17:45:25.989] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.989] Resolving globals: FALSE
[17:45:25.989] Tweak future expression to call with '...' arguments ...
[17:45:25.989] {
[17:45:25.989]     do.call(function(...) {
[17:45:25.989]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:25.989]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:25.989]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:25.989]             on.exit(options(oopts), add = TRUE)
[17:45:25.989]         }
[17:45:25.989]         {
[17:45:25.989]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:25.989]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:25.989]                 ...future.FUN(...future.X_jj, ...)
[17:45:25.989]             })
[17:45:25.989]         }
[17:45:25.989]     }, args = future.call.arguments)
[17:45:25.989] }
[17:45:25.989] Tweak future expression to call with '...' arguments ... DONE
[17:45:25.990] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:25.990] - packages: [1] ‘future.apply’
[17:45:25.990] getGlobalsAndPackages() ... DONE
[17:45:25.990] run() for ‘Future’ ...
[17:45:25.990] - state: ‘created’
[17:45:25.991] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:26.005] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.005] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:26.005]   - Field: ‘node’
[17:45:26.005]   - Field: ‘label’
[17:45:26.005]   - Field: ‘local’
[17:45:26.006]   - Field: ‘owner’
[17:45:26.006]   - Field: ‘envir’
[17:45:26.006]   - Field: ‘workers’
[17:45:26.006]   - Field: ‘packages’
[17:45:26.006]   - Field: ‘gc’
[17:45:26.006]   - Field: ‘conditions’
[17:45:26.006]   - Field: ‘persistent’
[17:45:26.006]   - Field: ‘expr’
[17:45:26.006]   - Field: ‘uuid’
[17:45:26.006]   - Field: ‘seed’
[17:45:26.007]   - Field: ‘version’
[17:45:26.007]   - Field: ‘result’
[17:45:26.007]   - Field: ‘asynchronous’
[17:45:26.007]   - Field: ‘calls’
[17:45:26.007]   - Field: ‘globals’
[17:45:26.007]   - Field: ‘stdout’
[17:45:26.007]   - Field: ‘earlySignal’
[17:45:26.007]   - Field: ‘lazy’
[17:45:26.007]   - Field: ‘state’
[17:45:26.007] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:26.007] - Launch lazy future ...
[17:45:26.008] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:26.008] Packages needed by future strategies (n = 0): <none>
[17:45:26.008] {
[17:45:26.008]     {
[17:45:26.008]         {
[17:45:26.008]             ...future.startTime <- base::Sys.time()
[17:45:26.008]             {
[17:45:26.008]                 {
[17:45:26.008]                   {
[17:45:26.008]                     {
[17:45:26.008]                       {
[17:45:26.008]                         base::local({
[17:45:26.008]                           has_future <- base::requireNamespace("future", 
[17:45:26.008]                             quietly = TRUE)
[17:45:26.008]                           if (has_future) {
[17:45:26.008]                             ns <- base::getNamespace("future")
[17:45:26.008]                             version <- ns[[".package"]][["version"]]
[17:45:26.008]                             if (is.null(version)) 
[17:45:26.008]                               version <- utils::packageVersion("future")
[17:45:26.008]                           }
[17:45:26.008]                           else {
[17:45:26.008]                             version <- NULL
[17:45:26.008]                           }
[17:45:26.008]                           if (!has_future || version < "1.8.0") {
[17:45:26.008]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:26.008]                               "", base::R.version$version.string), 
[17:45:26.008]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:26.008]                                 base::R.version$platform, 8 * 
[17:45:26.008]                                   base::.Machine$sizeof.pointer), 
[17:45:26.008]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:26.008]                                 "release", "version")], collapse = " "), 
[17:45:26.008]                               hostname = base::Sys.info()[["nodename"]])
[17:45:26.008]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:26.008]                               info)
[17:45:26.008]                             info <- base::paste(info, collapse = "; ")
[17:45:26.008]                             if (!has_future) {
[17:45:26.008]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:26.008]                                 info)
[17:45:26.008]                             }
[17:45:26.008]                             else {
[17:45:26.008]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:26.008]                                 info, version)
[17:45:26.008]                             }
[17:45:26.008]                             base::stop(msg)
[17:45:26.008]                           }
[17:45:26.008]                         })
[17:45:26.008]                       }
[17:45:26.008]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:26.008]                       base::options(mc.cores = 1L)
[17:45:26.008]                     }
[17:45:26.008]                     base::local({
[17:45:26.008]                       for (pkg in "future.apply") {
[17:45:26.008]                         base::loadNamespace(pkg)
[17:45:26.008]                         base::library(pkg, character.only = TRUE)
[17:45:26.008]                       }
[17:45:26.008]                     })
[17:45:26.008]                   }
[17:45:26.008]                   ...future.strategy.old <- future::plan("list")
[17:45:26.008]                   options(future.plan = NULL)
[17:45:26.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:26.008]                 }
[17:45:26.008]                 ...future.workdir <- getwd()
[17:45:26.008]             }
[17:45:26.008]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:26.008]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:26.008]         }
[17:45:26.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:26.008]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:26.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:26.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:26.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:26.008]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:26.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:26.008]             base::names(...future.oldOptions))
[17:45:26.008]     }
[17:45:26.008]     if (FALSE) {
[17:45:26.008]     }
[17:45:26.008]     else {
[17:45:26.008]         if (TRUE) {
[17:45:26.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:26.008]                 open = "w")
[17:45:26.008]         }
[17:45:26.008]         else {
[17:45:26.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:26.008]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:26.008]         }
[17:45:26.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:26.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:26.008]             base::sink(type = "output", split = FALSE)
[17:45:26.008]             base::close(...future.stdout)
[17:45:26.008]         }, add = TRUE)
[17:45:26.008]     }
[17:45:26.008]     ...future.frame <- base::sys.nframe()
[17:45:26.008]     ...future.conditions <- base::list()
[17:45:26.008]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:26.008]     if (FALSE) {
[17:45:26.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:26.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:26.008]     }
[17:45:26.008]     ...future.result <- base::tryCatch({
[17:45:26.008]         base::withCallingHandlers({
[17:45:26.008]             ...future.value <- base::withVisible(base::local({
[17:45:26.008]                 ...future.makeSendCondition <- base::local({
[17:45:26.008]                   sendCondition <- NULL
[17:45:26.008]                   function(frame = 1L) {
[17:45:26.008]                     if (is.function(sendCondition)) 
[17:45:26.008]                       return(sendCondition)
[17:45:26.008]                     ns <- getNamespace("parallel")
[17:45:26.008]                     if (exists("sendData", mode = "function", 
[17:45:26.008]                       envir = ns)) {
[17:45:26.008]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:26.008]                         envir = ns)
[17:45:26.008]                       envir <- sys.frame(frame)
[17:45:26.008]                       master <- NULL
[17:45:26.008]                       while (!identical(envir, .GlobalEnv) && 
[17:45:26.008]                         !identical(envir, emptyenv())) {
[17:45:26.008]                         if (exists("master", mode = "list", envir = envir, 
[17:45:26.008]                           inherits = FALSE)) {
[17:45:26.008]                           master <- get("master", mode = "list", 
[17:45:26.008]                             envir = envir, inherits = FALSE)
[17:45:26.008]                           if (inherits(master, c("SOCKnode", 
[17:45:26.008]                             "SOCK0node"))) {
[17:45:26.008]                             sendCondition <<- function(cond) {
[17:45:26.008]                               data <- list(type = "VALUE", value = cond, 
[17:45:26.008]                                 success = TRUE)
[17:45:26.008]                               parallel_sendData(master, data)
[17:45:26.008]                             }
[17:45:26.008]                             return(sendCondition)
[17:45:26.008]                           }
[17:45:26.008]                         }
[17:45:26.008]                         frame <- frame + 1L
[17:45:26.008]                         envir <- sys.frame(frame)
[17:45:26.008]                       }
[17:45:26.008]                     }
[17:45:26.008]                     sendCondition <<- function(cond) NULL
[17:45:26.008]                   }
[17:45:26.008]                 })
[17:45:26.008]                 withCallingHandlers({
[17:45:26.008]                   {
[17:45:26.008]                     do.call(function(...) {
[17:45:26.008]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.008]                       if (!identical(...future.globals.maxSize.org, 
[17:45:26.008]                         ...future.globals.maxSize)) {
[17:45:26.008]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.008]                         on.exit(options(oopts), add = TRUE)
[17:45:26.008]                       }
[17:45:26.008]                       {
[17:45:26.008]                         lapply(seq_along(...future.elements_ii), 
[17:45:26.008]                           FUN = function(jj) {
[17:45:26.008]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.008]                             ...future.FUN(...future.X_jj, ...)
[17:45:26.008]                           })
[17:45:26.008]                       }
[17:45:26.008]                     }, args = future.call.arguments)
[17:45:26.008]                   }
[17:45:26.008]                 }, immediateCondition = function(cond) {
[17:45:26.008]                   sendCondition <- ...future.makeSendCondition()
[17:45:26.008]                   sendCondition(cond)
[17:45:26.008]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.008]                   {
[17:45:26.008]                     inherits <- base::inherits
[17:45:26.008]                     invokeRestart <- base::invokeRestart
[17:45:26.008]                     is.null <- base::is.null
[17:45:26.008]                     muffled <- FALSE
[17:45:26.008]                     if (inherits(cond, "message")) {
[17:45:26.008]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:26.008]                       if (muffled) 
[17:45:26.008]                         invokeRestart("muffleMessage")
[17:45:26.008]                     }
[17:45:26.008]                     else if (inherits(cond, "warning")) {
[17:45:26.008]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:26.008]                       if (muffled) 
[17:45:26.008]                         invokeRestart("muffleWarning")
[17:45:26.008]                     }
[17:45:26.008]                     else if (inherits(cond, "condition")) {
[17:45:26.008]                       if (!is.null(pattern)) {
[17:45:26.008]                         computeRestarts <- base::computeRestarts
[17:45:26.008]                         grepl <- base::grepl
[17:45:26.008]                         restarts <- computeRestarts(cond)
[17:45:26.008]                         for (restart in restarts) {
[17:45:26.008]                           name <- restart$name
[17:45:26.008]                           if (is.null(name)) 
[17:45:26.008]                             next
[17:45:26.008]                           if (!grepl(pattern, name)) 
[17:45:26.008]                             next
[17:45:26.008]                           invokeRestart(restart)
[17:45:26.008]                           muffled <- TRUE
[17:45:26.008]                           break
[17:45:26.008]                         }
[17:45:26.008]                       }
[17:45:26.008]                     }
[17:45:26.008]                     invisible(muffled)
[17:45:26.008]                   }
[17:45:26.008]                   muffleCondition(cond)
[17:45:26.008]                 })
[17:45:26.008]             }))
[17:45:26.008]             future::FutureResult(value = ...future.value$value, 
[17:45:26.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.008]                   ...future.rng), globalenv = if (FALSE) 
[17:45:26.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:26.008]                     ...future.globalenv.names))
[17:45:26.008]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:26.008]         }, condition = base::local({
[17:45:26.008]             c <- base::c
[17:45:26.008]             inherits <- base::inherits
[17:45:26.008]             invokeRestart <- base::invokeRestart
[17:45:26.008]             length <- base::length
[17:45:26.008]             list <- base::list
[17:45:26.008]             seq.int <- base::seq.int
[17:45:26.008]             signalCondition <- base::signalCondition
[17:45:26.008]             sys.calls <- base::sys.calls
[17:45:26.008]             `[[` <- base::`[[`
[17:45:26.008]             `+` <- base::`+`
[17:45:26.008]             `<<-` <- base::`<<-`
[17:45:26.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:26.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:26.008]                   3L)]
[17:45:26.008]             }
[17:45:26.008]             function(cond) {
[17:45:26.008]                 is_error <- inherits(cond, "error")
[17:45:26.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:26.008]                   NULL)
[17:45:26.008]                 if (is_error) {
[17:45:26.008]                   sessionInformation <- function() {
[17:45:26.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:26.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:26.008]                       search = base::search(), system = base::Sys.info())
[17:45:26.008]                   }
[17:45:26.008]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:26.008]                     cond$call), session = sessionInformation(), 
[17:45:26.008]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:26.008]                   signalCondition(cond)
[17:45:26.008]                 }
[17:45:26.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:26.008]                 "immediateCondition"))) {
[17:45:26.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:26.008]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:26.008]                   if (TRUE && !signal) {
[17:45:26.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.008]                     {
[17:45:26.008]                       inherits <- base::inherits
[17:45:26.008]                       invokeRestart <- base::invokeRestart
[17:45:26.008]                       is.null <- base::is.null
[17:45:26.008]                       muffled <- FALSE
[17:45:26.008]                       if (inherits(cond, "message")) {
[17:45:26.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.008]                         if (muffled) 
[17:45:26.008]                           invokeRestart("muffleMessage")
[17:45:26.008]                       }
[17:45:26.008]                       else if (inherits(cond, "warning")) {
[17:45:26.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.008]                         if (muffled) 
[17:45:26.008]                           invokeRestart("muffleWarning")
[17:45:26.008]                       }
[17:45:26.008]                       else if (inherits(cond, "condition")) {
[17:45:26.008]                         if (!is.null(pattern)) {
[17:45:26.008]                           computeRestarts <- base::computeRestarts
[17:45:26.008]                           grepl <- base::grepl
[17:45:26.008]                           restarts <- computeRestarts(cond)
[17:45:26.008]                           for (restart in restarts) {
[17:45:26.008]                             name <- restart$name
[17:45:26.008]                             if (is.null(name)) 
[17:45:26.008]                               next
[17:45:26.008]                             if (!grepl(pattern, name)) 
[17:45:26.008]                               next
[17:45:26.008]                             invokeRestart(restart)
[17:45:26.008]                             muffled <- TRUE
[17:45:26.008]                             break
[17:45:26.008]                           }
[17:45:26.008]                         }
[17:45:26.008]                       }
[17:45:26.008]                       invisible(muffled)
[17:45:26.008]                     }
[17:45:26.008]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.008]                   }
[17:45:26.008]                 }
[17:45:26.008]                 else {
[17:45:26.008]                   if (TRUE) {
[17:45:26.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.008]                     {
[17:45:26.008]                       inherits <- base::inherits
[17:45:26.008]                       invokeRestart <- base::invokeRestart
[17:45:26.008]                       is.null <- base::is.null
[17:45:26.008]                       muffled <- FALSE
[17:45:26.008]                       if (inherits(cond, "message")) {
[17:45:26.008]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.008]                         if (muffled) 
[17:45:26.008]                           invokeRestart("muffleMessage")
[17:45:26.008]                       }
[17:45:26.008]                       else if (inherits(cond, "warning")) {
[17:45:26.008]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.008]                         if (muffled) 
[17:45:26.008]                           invokeRestart("muffleWarning")
[17:45:26.008]                       }
[17:45:26.008]                       else if (inherits(cond, "condition")) {
[17:45:26.008]                         if (!is.null(pattern)) {
[17:45:26.008]                           computeRestarts <- base::computeRestarts
[17:45:26.008]                           grepl <- base::grepl
[17:45:26.008]                           restarts <- computeRestarts(cond)
[17:45:26.008]                           for (restart in restarts) {
[17:45:26.008]                             name <- restart$name
[17:45:26.008]                             if (is.null(name)) 
[17:45:26.008]                               next
[17:45:26.008]                             if (!grepl(pattern, name)) 
[17:45:26.008]                               next
[17:45:26.008]                             invokeRestart(restart)
[17:45:26.008]                             muffled <- TRUE
[17:45:26.008]                             break
[17:45:26.008]                           }
[17:45:26.008]                         }
[17:45:26.008]                       }
[17:45:26.008]                       invisible(muffled)
[17:45:26.008]                     }
[17:45:26.008]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.008]                   }
[17:45:26.008]                 }
[17:45:26.008]             }
[17:45:26.008]         }))
[17:45:26.008]     }, error = function(ex) {
[17:45:26.008]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:26.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.008]                 ...future.rng), started = ...future.startTime, 
[17:45:26.008]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:26.008]             version = "1.8"), class = "FutureResult")
[17:45:26.008]     }, finally = {
[17:45:26.008]         if (!identical(...future.workdir, getwd())) 
[17:45:26.008]             setwd(...future.workdir)
[17:45:26.008]         {
[17:45:26.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:26.008]                 ...future.oldOptions$nwarnings <- NULL
[17:45:26.008]             }
[17:45:26.008]             base::options(...future.oldOptions)
[17:45:26.008]             if (.Platform$OS.type == "windows") {
[17:45:26.008]                 old_names <- names(...future.oldEnvVars)
[17:45:26.008]                 envs <- base::Sys.getenv()
[17:45:26.008]                 names <- names(envs)
[17:45:26.008]                 common <- intersect(names, old_names)
[17:45:26.008]                 added <- setdiff(names, old_names)
[17:45:26.008]                 removed <- setdiff(old_names, names)
[17:45:26.008]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:26.008]                   envs[common]]
[17:45:26.008]                 NAMES <- toupper(changed)
[17:45:26.008]                 args <- list()
[17:45:26.008]                 for (kk in seq_along(NAMES)) {
[17:45:26.008]                   name <- changed[[kk]]
[17:45:26.008]                   NAME <- NAMES[[kk]]
[17:45:26.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.008]                     next
[17:45:26.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.008]                 }
[17:45:26.008]                 NAMES <- toupper(added)
[17:45:26.008]                 for (kk in seq_along(NAMES)) {
[17:45:26.008]                   name <- added[[kk]]
[17:45:26.008]                   NAME <- NAMES[[kk]]
[17:45:26.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.008]                     next
[17:45:26.008]                   args[[name]] <- ""
[17:45:26.008]                 }
[17:45:26.008]                 NAMES <- toupper(removed)
[17:45:26.008]                 for (kk in seq_along(NAMES)) {
[17:45:26.008]                   name <- removed[[kk]]
[17:45:26.008]                   NAME <- NAMES[[kk]]
[17:45:26.008]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.008]                     next
[17:45:26.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.008]                 }
[17:45:26.008]                 if (length(args) > 0) 
[17:45:26.008]                   base::do.call(base::Sys.setenv, args = args)
[17:45:26.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:26.008]             }
[17:45:26.008]             else {
[17:45:26.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:26.008]             }
[17:45:26.008]             {
[17:45:26.008]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:26.008]                   0L) {
[17:45:26.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:26.008]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:26.008]                   base::options(opts)
[17:45:26.008]                 }
[17:45:26.008]                 {
[17:45:26.008]                   {
[17:45:26.008]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:26.008]                     NULL
[17:45:26.008]                   }
[17:45:26.008]                   options(future.plan = NULL)
[17:45:26.008]                   if (is.na(NA_character_)) 
[17:45:26.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:26.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:26.008]                     .init = FALSE)
[17:45:26.008]                 }
[17:45:26.008]             }
[17:45:26.008]         }
[17:45:26.008]     })
[17:45:26.008]     if (TRUE) {
[17:45:26.008]         base::sink(type = "output", split = FALSE)
[17:45:26.008]         if (TRUE) {
[17:45:26.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:26.008]         }
[17:45:26.008]         else {
[17:45:26.008]             ...future.result["stdout"] <- base::list(NULL)
[17:45:26.008]         }
[17:45:26.008]         base::close(...future.stdout)
[17:45:26.008]         ...future.stdout <- NULL
[17:45:26.008]     }
[17:45:26.008]     ...future.result$conditions <- ...future.conditions
[17:45:26.008]     ...future.result$finished <- base::Sys.time()
[17:45:26.008]     ...future.result
[17:45:26.008] }
[17:45:26.011] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[17:45:26.011] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:26.056] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:26.056] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[17:45:26.056] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[17:45:26.056] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:26.057] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:26.057] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:26.100] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:26.100] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:26.144] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:26.144] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:26.144] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.145] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[17:45:26.145] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[17:45:26.145] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:26.146] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.146] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[17:45:26.146] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[17:45:26.146] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:26.147] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:26.147] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.147] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[17:45:26.148] MultisessionFuture started
[17:45:26.148] - Launch lazy future ... done
[17:45:26.148] run() for ‘MultisessionFuture’ ... done
[17:45:26.148] Created future:
[17:45:26.148] MultisessionFuture:
[17:45:26.148] Label: ‘future_vapply-2’
[17:45:26.148] Expression:
[17:45:26.148] {
[17:45:26.148]     do.call(function(...) {
[17:45:26.148]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.148]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.148]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.148]             on.exit(options(oopts), add = TRUE)
[17:45:26.148]         }
[17:45:26.148]         {
[17:45:26.148]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.148]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.148]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.148]             })
[17:45:26.148]         }
[17:45:26.148]     }, args = future.call.arguments)
[17:45:26.148] }
[17:45:26.148] Lazy evaluation: FALSE
[17:45:26.148] Asynchronous evaluation: TRUE
[17:45:26.148] Local evaluation: TRUE
[17:45:26.148] Environment: R_GlobalEnv
[17:45:26.148] Capture standard output: TRUE
[17:45:26.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:26.148] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:26.148] Packages: 1 packages (‘future.apply’)
[17:45:26.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:26.148] Resolved: FALSE
[17:45:26.148] Value: <not collected>
[17:45:26.148] Conditions captured: <none>
[17:45:26.148] Early signaling: FALSE
[17:45:26.148] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:26.148] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.160] Chunk #2 of 2 ... DONE
[17:45:26.160] Launching 2 futures (chunks) ... DONE
[17:45:26.160] Resolving 2 futures (chunks) ...
[17:45:26.160] resolve() on list ...
[17:45:26.160]  recursive: 0
[17:45:26.161]  length: 2
[17:45:26.161] 
[17:45:26.161] receiveMessageFromWorker() for ClusterFuture ...
[17:45:26.161] - Validating connection of MultisessionFuture
[17:45:26.161] - received message: FutureResult
[17:45:26.162] - Received FutureResult
[17:45:26.162] - Erased future from FutureRegistry
[17:45:26.162] result() for ClusterFuture ...
[17:45:26.162] - result already collected: FutureResult
[17:45:26.162] result() for ClusterFuture ... done
[17:45:26.162] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:26.162] Future #1
[17:45:26.162] result() for ClusterFuture ...
[17:45:26.162] - result already collected: FutureResult
[17:45:26.162] result() for ClusterFuture ... done
[17:45:26.162] result() for ClusterFuture ...
[17:45:26.163] - result already collected: FutureResult
[17:45:26.163] result() for ClusterFuture ... done
[17:45:26.163] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:26.163] - nx: 2
[17:45:26.163] - relay: TRUE
[17:45:26.163] - stdout: TRUE
[17:45:26.163] - signal: TRUE
[17:45:26.163] - resignal: FALSE
[17:45:26.163] - force: TRUE
[17:45:26.163] - relayed: [n=2] FALSE, FALSE
[17:45:26.163] - queued futures: [n=2] FALSE, FALSE
[17:45:26.164]  - until=1
[17:45:26.164]  - relaying element #1
[17:45:26.164] result() for ClusterFuture ...
[17:45:26.164] - result already collected: FutureResult
[17:45:26.164] result() for ClusterFuture ... done
[17:45:26.164] result() for ClusterFuture ...
[17:45:26.164] - result already collected: FutureResult
[17:45:26.164] result() for ClusterFuture ... done
[17:45:26.164] result() for ClusterFuture ...
[17:45:26.164] - result already collected: FutureResult
[17:45:26.164] result() for ClusterFuture ... done
[17:45:26.165] result() for ClusterFuture ...
[17:45:26.165] - result already collected: FutureResult
[17:45:26.165] result() for ClusterFuture ... done
[17:45:26.165] - relayed: [n=2] TRUE, FALSE
[17:45:26.165] - queued futures: [n=2] TRUE, FALSE
[17:45:26.165] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:26.165]  length: 1 (resolved future 1)
[17:45:26.193] receiveMessageFromWorker() for ClusterFuture ...
[17:45:26.193] - Validating connection of MultisessionFuture
[17:45:26.193] - received message: FutureResult
[17:45:26.193] - Received FutureResult
[17:45:26.194] - Erased future from FutureRegistry
[17:45:26.194] result() for ClusterFuture ...
[17:45:26.194] - result already collected: FutureResult
[17:45:26.194] result() for ClusterFuture ... done
[17:45:26.194] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:26.194] Future #2
[17:45:26.194] result() for ClusterFuture ...
[17:45:26.194] - result already collected: FutureResult
[17:45:26.194] result() for ClusterFuture ... done
[17:45:26.194] result() for ClusterFuture ...
[17:45:26.194] - result already collected: FutureResult
[17:45:26.194] result() for ClusterFuture ... done
[17:45:26.195] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:26.195] - nx: 2
[17:45:26.195] - relay: TRUE
[17:45:26.195] - stdout: TRUE
[17:45:26.195] - signal: TRUE
[17:45:26.195] - resignal: FALSE
[17:45:26.195] - force: TRUE
[17:45:26.195] - relayed: [n=2] TRUE, FALSE
[17:45:26.195] - queued futures: [n=2] TRUE, FALSE
[17:45:26.195]  - until=2
[17:45:26.195]  - relaying element #2
[17:45:26.196] result() for ClusterFuture ...
[17:45:26.196] - result already collected: FutureResult
[17:45:26.196] result() for ClusterFuture ... done
[17:45:26.196] result() for ClusterFuture ...
[17:45:26.196] - result already collected: FutureResult
[17:45:26.196] result() for ClusterFuture ... done
[17:45:26.196] result() for ClusterFuture ...
[17:45:26.196] - result already collected: FutureResult
[17:45:26.196] result() for ClusterFuture ... done
[17:45:26.196] result() for ClusterFuture ...
[17:45:26.196] - result already collected: FutureResult
[17:45:26.196] result() for ClusterFuture ... done
[17:45:26.197] - relayed: [n=2] TRUE, TRUE
[17:45:26.197] - queued futures: [n=2] TRUE, TRUE
[17:45:26.197] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:26.197]  length: 0 (resolved future 2)
[17:45:26.197] Relaying remaining futures
[17:45:26.197] signalConditionsASAP(NULL, pos=0) ...
[17:45:26.197] - nx: 2
[17:45:26.197] - relay: TRUE
[17:45:26.197] - stdout: TRUE
[17:45:26.197] - signal: TRUE
[17:45:26.197] - resignal: FALSE
[17:45:26.198] - force: TRUE
[17:45:26.198] - relayed: [n=2] TRUE, TRUE
[17:45:26.198] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:26.198] - relayed: [n=2] TRUE, TRUE
[17:45:26.198] - queued futures: [n=2] TRUE, TRUE
[17:45:26.198] signalConditionsASAP(NULL, pos=0) ... done
[17:45:26.198] resolve() on list ... DONE
[17:45:26.198] result() for ClusterFuture ...
[17:45:26.198] - result already collected: FutureResult
[17:45:26.198] result() for ClusterFuture ... done
[17:45:26.198] result() for ClusterFuture ...
[17:45:26.199] - result already collected: FutureResult
[17:45:26.199] result() for ClusterFuture ... done
[17:45:26.199] result() for ClusterFuture ...
[17:45:26.199] - result already collected: FutureResult
[17:45:26.199] result() for ClusterFuture ... done
[17:45:26.199] result() for ClusterFuture ...
[17:45:26.199] - result already collected: FutureResult
[17:45:26.199] result() for ClusterFuture ... done
[17:45:26.199]  - Number of value chunks collected: 2
[17:45:26.199] Resolving 2 futures (chunks) ... DONE
[17:45:26.199] Reducing values from 2 chunks ...
[17:45:26.200]  - Number of values collected after concatenation: 11
[17:45:26.200]  - Number of values expected: 11
[17:45:26.200] Reducing values from 2 chunks ... DONE
[17:45:26.200] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[17:45:26.201] future_lapply() ...
[17:45:26.206] Number of chunks: 2
[17:45:26.206] getGlobalsAndPackagesXApply() ...
[17:45:26.206]  - future.globals: TRUE
[17:45:26.206] getGlobalsAndPackages() ...
[17:45:26.207] Searching for globals...
[17:45:26.210] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:26.210] Searching for globals ... DONE
[17:45:26.210] Resolving globals: FALSE
[17:45:26.211] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[17:45:26.211] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:26.211] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:26.211] - packages: [1] ‘future.apply’
[17:45:26.211] getGlobalsAndPackages() ... DONE
[17:45:26.212]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:26.212]  - needed namespaces: [n=1] ‘future.apply’
[17:45:26.212] Finding globals ... DONE
[17:45:26.212]  - use_args: TRUE
[17:45:26.212]  - Getting '...' globals ...
[17:45:26.212] resolve() on list ...
[17:45:26.212]  recursive: 0
[17:45:26.212]  length: 1
[17:45:26.213]  elements: ‘...’
[17:45:26.213]  length: 0 (resolved future 1)
[17:45:26.213] resolve() on list ... DONE
[17:45:26.213]    - '...' content: [n=0] 
[17:45:26.213] List of 1
[17:45:26.213]  $ ...: list()
[17:45:26.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:26.213]  - attr(*, "where")=List of 1
[17:45:26.213]   ..$ ...:<environment: 0x5561f6a07220> 
[17:45:26.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:26.213]  - attr(*, "resolved")= logi TRUE
[17:45:26.213]  - attr(*, "total_size")= num NA
[17:45:26.215]  - Getting '...' globals ... DONE
[17:45:26.216] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:26.216] List of 8
[17:45:26.216]  $ ...future.FUN:function (x, ...)  
[17:45:26.216]  $ x_FUN        :function (x)  
[17:45:26.216]  $ times        : int 1
[17:45:26.216]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:26.216]  $ stop_if_not  :function (...)  
[17:45:26.216]  $ dim          : NULL
[17:45:26.216]  $ valid_types  : chr [1:2] "logical" "integer"
[17:45:26.216]  $ ...          : list()
[17:45:26.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:26.216]  - attr(*, "where")=List of 8
[17:45:26.216]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:26.216]   ..$ ...          :<environment: 0x5561f6a07220> 
[17:45:26.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:26.216]  - attr(*, "resolved")= logi FALSE
[17:45:26.216]  - attr(*, "total_size")= num 94264
[17:45:26.221] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:26.221] getGlobalsAndPackagesXApply() ... DONE
[17:45:26.221] Number of futures (= number of chunks): 2
[17:45:26.221] Launching 2 futures (chunks) ...
[17:45:26.221] Chunk #1 of 2 ...
[17:45:26.221]  - Finding globals in 'X' for chunk #1 ...
[17:45:26.221] getGlobalsAndPackages() ...
[17:45:26.222] Searching for globals...
[17:45:26.222] 
[17:45:26.222] Searching for globals ... DONE
[17:45:26.222] - globals: [0] <none>
[17:45:26.222] getGlobalsAndPackages() ... DONE
[17:45:26.222]    + additional globals found: [n=0] 
[17:45:26.222]    + additional namespaces needed: [n=0] 
[17:45:26.222]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:26.222]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:26.223]  - seeds: <none>
[17:45:26.223]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.223] getGlobalsAndPackages() ...
[17:45:26.223] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.223] Resolving globals: FALSE
[17:45:26.223] Tweak future expression to call with '...' arguments ...
[17:45:26.223] {
[17:45:26.223]     do.call(function(...) {
[17:45:26.223]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.223]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.223]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.223]             on.exit(options(oopts), add = TRUE)
[17:45:26.223]         }
[17:45:26.223]         {
[17:45:26.223]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.223]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.223]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.223]             })
[17:45:26.223]         }
[17:45:26.223]     }, args = future.call.arguments)
[17:45:26.223] }
[17:45:26.223] Tweak future expression to call with '...' arguments ... DONE
[17:45:26.224] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.224] - packages: [1] ‘future.apply’
[17:45:26.224] getGlobalsAndPackages() ... DONE
[17:45:26.224] run() for ‘Future’ ...
[17:45:26.225] - state: ‘created’
[17:45:26.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:26.239] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:26.239]   - Field: ‘node’
[17:45:26.239]   - Field: ‘label’
[17:45:26.239]   - Field: ‘local’
[17:45:26.239]   - Field: ‘owner’
[17:45:26.239]   - Field: ‘envir’
[17:45:26.239]   - Field: ‘workers’
[17:45:26.239]   - Field: ‘packages’
[17:45:26.239]   - Field: ‘gc’
[17:45:26.240]   - Field: ‘conditions’
[17:45:26.240]   - Field: ‘persistent’
[17:45:26.240]   - Field: ‘expr’
[17:45:26.240]   - Field: ‘uuid’
[17:45:26.240]   - Field: ‘seed’
[17:45:26.240]   - Field: ‘version’
[17:45:26.240]   - Field: ‘result’
[17:45:26.240]   - Field: ‘asynchronous’
[17:45:26.240]   - Field: ‘calls’
[17:45:26.240]   - Field: ‘globals’
[17:45:26.240]   - Field: ‘stdout’
[17:45:26.241]   - Field: ‘earlySignal’
[17:45:26.241]   - Field: ‘lazy’
[17:45:26.241]   - Field: ‘state’
[17:45:26.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:26.241] - Launch lazy future ...
[17:45:26.241] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:26.241] Packages needed by future strategies (n = 0): <none>
[17:45:26.242] {
[17:45:26.242]     {
[17:45:26.242]         {
[17:45:26.242]             ...future.startTime <- base::Sys.time()
[17:45:26.242]             {
[17:45:26.242]                 {
[17:45:26.242]                   {
[17:45:26.242]                     {
[17:45:26.242]                       {
[17:45:26.242]                         base::local({
[17:45:26.242]                           has_future <- base::requireNamespace("future", 
[17:45:26.242]                             quietly = TRUE)
[17:45:26.242]                           if (has_future) {
[17:45:26.242]                             ns <- base::getNamespace("future")
[17:45:26.242]                             version <- ns[[".package"]][["version"]]
[17:45:26.242]                             if (is.null(version)) 
[17:45:26.242]                               version <- utils::packageVersion("future")
[17:45:26.242]                           }
[17:45:26.242]                           else {
[17:45:26.242]                             version <- NULL
[17:45:26.242]                           }
[17:45:26.242]                           if (!has_future || version < "1.8.0") {
[17:45:26.242]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:26.242]                               "", base::R.version$version.string), 
[17:45:26.242]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:26.242]                                 base::R.version$platform, 8 * 
[17:45:26.242]                                   base::.Machine$sizeof.pointer), 
[17:45:26.242]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:26.242]                                 "release", "version")], collapse = " "), 
[17:45:26.242]                               hostname = base::Sys.info()[["nodename"]])
[17:45:26.242]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:26.242]                               info)
[17:45:26.242]                             info <- base::paste(info, collapse = "; ")
[17:45:26.242]                             if (!has_future) {
[17:45:26.242]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:26.242]                                 info)
[17:45:26.242]                             }
[17:45:26.242]                             else {
[17:45:26.242]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:26.242]                                 info, version)
[17:45:26.242]                             }
[17:45:26.242]                             base::stop(msg)
[17:45:26.242]                           }
[17:45:26.242]                         })
[17:45:26.242]                       }
[17:45:26.242]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:26.242]                       base::options(mc.cores = 1L)
[17:45:26.242]                     }
[17:45:26.242]                     base::local({
[17:45:26.242]                       for (pkg in "future.apply") {
[17:45:26.242]                         base::loadNamespace(pkg)
[17:45:26.242]                         base::library(pkg, character.only = TRUE)
[17:45:26.242]                       }
[17:45:26.242]                     })
[17:45:26.242]                   }
[17:45:26.242]                   ...future.strategy.old <- future::plan("list")
[17:45:26.242]                   options(future.plan = NULL)
[17:45:26.242]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.242]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:26.242]                 }
[17:45:26.242]                 ...future.workdir <- getwd()
[17:45:26.242]             }
[17:45:26.242]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:26.242]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:26.242]         }
[17:45:26.242]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:26.242]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:26.242]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:26.242]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:26.242]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:26.242]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:26.242]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:26.242]             base::names(...future.oldOptions))
[17:45:26.242]     }
[17:45:26.242]     if (FALSE) {
[17:45:26.242]     }
[17:45:26.242]     else {
[17:45:26.242]         if (TRUE) {
[17:45:26.242]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:26.242]                 open = "w")
[17:45:26.242]         }
[17:45:26.242]         else {
[17:45:26.242]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:26.242]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:26.242]         }
[17:45:26.242]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:26.242]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:26.242]             base::sink(type = "output", split = FALSE)
[17:45:26.242]             base::close(...future.stdout)
[17:45:26.242]         }, add = TRUE)
[17:45:26.242]     }
[17:45:26.242]     ...future.frame <- base::sys.nframe()
[17:45:26.242]     ...future.conditions <- base::list()
[17:45:26.242]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:26.242]     if (FALSE) {
[17:45:26.242]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:26.242]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:26.242]     }
[17:45:26.242]     ...future.result <- base::tryCatch({
[17:45:26.242]         base::withCallingHandlers({
[17:45:26.242]             ...future.value <- base::withVisible(base::local({
[17:45:26.242]                 ...future.makeSendCondition <- base::local({
[17:45:26.242]                   sendCondition <- NULL
[17:45:26.242]                   function(frame = 1L) {
[17:45:26.242]                     if (is.function(sendCondition)) 
[17:45:26.242]                       return(sendCondition)
[17:45:26.242]                     ns <- getNamespace("parallel")
[17:45:26.242]                     if (exists("sendData", mode = "function", 
[17:45:26.242]                       envir = ns)) {
[17:45:26.242]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:26.242]                         envir = ns)
[17:45:26.242]                       envir <- sys.frame(frame)
[17:45:26.242]                       master <- NULL
[17:45:26.242]                       while (!identical(envir, .GlobalEnv) && 
[17:45:26.242]                         !identical(envir, emptyenv())) {
[17:45:26.242]                         if (exists("master", mode = "list", envir = envir, 
[17:45:26.242]                           inherits = FALSE)) {
[17:45:26.242]                           master <- get("master", mode = "list", 
[17:45:26.242]                             envir = envir, inherits = FALSE)
[17:45:26.242]                           if (inherits(master, c("SOCKnode", 
[17:45:26.242]                             "SOCK0node"))) {
[17:45:26.242]                             sendCondition <<- function(cond) {
[17:45:26.242]                               data <- list(type = "VALUE", value = cond, 
[17:45:26.242]                                 success = TRUE)
[17:45:26.242]                               parallel_sendData(master, data)
[17:45:26.242]                             }
[17:45:26.242]                             return(sendCondition)
[17:45:26.242]                           }
[17:45:26.242]                         }
[17:45:26.242]                         frame <- frame + 1L
[17:45:26.242]                         envir <- sys.frame(frame)
[17:45:26.242]                       }
[17:45:26.242]                     }
[17:45:26.242]                     sendCondition <<- function(cond) NULL
[17:45:26.242]                   }
[17:45:26.242]                 })
[17:45:26.242]                 withCallingHandlers({
[17:45:26.242]                   {
[17:45:26.242]                     do.call(function(...) {
[17:45:26.242]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.242]                       if (!identical(...future.globals.maxSize.org, 
[17:45:26.242]                         ...future.globals.maxSize)) {
[17:45:26.242]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.242]                         on.exit(options(oopts), add = TRUE)
[17:45:26.242]                       }
[17:45:26.242]                       {
[17:45:26.242]                         lapply(seq_along(...future.elements_ii), 
[17:45:26.242]                           FUN = function(jj) {
[17:45:26.242]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.242]                             ...future.FUN(...future.X_jj, ...)
[17:45:26.242]                           })
[17:45:26.242]                       }
[17:45:26.242]                     }, args = future.call.arguments)
[17:45:26.242]                   }
[17:45:26.242]                 }, immediateCondition = function(cond) {
[17:45:26.242]                   sendCondition <- ...future.makeSendCondition()
[17:45:26.242]                   sendCondition(cond)
[17:45:26.242]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.242]                   {
[17:45:26.242]                     inherits <- base::inherits
[17:45:26.242]                     invokeRestart <- base::invokeRestart
[17:45:26.242]                     is.null <- base::is.null
[17:45:26.242]                     muffled <- FALSE
[17:45:26.242]                     if (inherits(cond, "message")) {
[17:45:26.242]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:26.242]                       if (muffled) 
[17:45:26.242]                         invokeRestart("muffleMessage")
[17:45:26.242]                     }
[17:45:26.242]                     else if (inherits(cond, "warning")) {
[17:45:26.242]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:26.242]                       if (muffled) 
[17:45:26.242]                         invokeRestart("muffleWarning")
[17:45:26.242]                     }
[17:45:26.242]                     else if (inherits(cond, "condition")) {
[17:45:26.242]                       if (!is.null(pattern)) {
[17:45:26.242]                         computeRestarts <- base::computeRestarts
[17:45:26.242]                         grepl <- base::grepl
[17:45:26.242]                         restarts <- computeRestarts(cond)
[17:45:26.242]                         for (restart in restarts) {
[17:45:26.242]                           name <- restart$name
[17:45:26.242]                           if (is.null(name)) 
[17:45:26.242]                             next
[17:45:26.242]                           if (!grepl(pattern, name)) 
[17:45:26.242]                             next
[17:45:26.242]                           invokeRestart(restart)
[17:45:26.242]                           muffled <- TRUE
[17:45:26.242]                           break
[17:45:26.242]                         }
[17:45:26.242]                       }
[17:45:26.242]                     }
[17:45:26.242]                     invisible(muffled)
[17:45:26.242]                   }
[17:45:26.242]                   muffleCondition(cond)
[17:45:26.242]                 })
[17:45:26.242]             }))
[17:45:26.242]             future::FutureResult(value = ...future.value$value, 
[17:45:26.242]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.242]                   ...future.rng), globalenv = if (FALSE) 
[17:45:26.242]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:26.242]                     ...future.globalenv.names))
[17:45:26.242]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:26.242]         }, condition = base::local({
[17:45:26.242]             c <- base::c
[17:45:26.242]             inherits <- base::inherits
[17:45:26.242]             invokeRestart <- base::invokeRestart
[17:45:26.242]             length <- base::length
[17:45:26.242]             list <- base::list
[17:45:26.242]             seq.int <- base::seq.int
[17:45:26.242]             signalCondition <- base::signalCondition
[17:45:26.242]             sys.calls <- base::sys.calls
[17:45:26.242]             `[[` <- base::`[[`
[17:45:26.242]             `+` <- base::`+`
[17:45:26.242]             `<<-` <- base::`<<-`
[17:45:26.242]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:26.242]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:26.242]                   3L)]
[17:45:26.242]             }
[17:45:26.242]             function(cond) {
[17:45:26.242]                 is_error <- inherits(cond, "error")
[17:45:26.242]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:26.242]                   NULL)
[17:45:26.242]                 if (is_error) {
[17:45:26.242]                   sessionInformation <- function() {
[17:45:26.242]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:26.242]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:26.242]                       search = base::search(), system = base::Sys.info())
[17:45:26.242]                   }
[17:45:26.242]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.242]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:26.242]                     cond$call), session = sessionInformation(), 
[17:45:26.242]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:26.242]                   signalCondition(cond)
[17:45:26.242]                 }
[17:45:26.242]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:26.242]                 "immediateCondition"))) {
[17:45:26.242]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:26.242]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.242]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:26.242]                   if (TRUE && !signal) {
[17:45:26.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.242]                     {
[17:45:26.242]                       inherits <- base::inherits
[17:45:26.242]                       invokeRestart <- base::invokeRestart
[17:45:26.242]                       is.null <- base::is.null
[17:45:26.242]                       muffled <- FALSE
[17:45:26.242]                       if (inherits(cond, "message")) {
[17:45:26.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.242]                         if (muffled) 
[17:45:26.242]                           invokeRestart("muffleMessage")
[17:45:26.242]                       }
[17:45:26.242]                       else if (inherits(cond, "warning")) {
[17:45:26.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.242]                         if (muffled) 
[17:45:26.242]                           invokeRestart("muffleWarning")
[17:45:26.242]                       }
[17:45:26.242]                       else if (inherits(cond, "condition")) {
[17:45:26.242]                         if (!is.null(pattern)) {
[17:45:26.242]                           computeRestarts <- base::computeRestarts
[17:45:26.242]                           grepl <- base::grepl
[17:45:26.242]                           restarts <- computeRestarts(cond)
[17:45:26.242]                           for (restart in restarts) {
[17:45:26.242]                             name <- restart$name
[17:45:26.242]                             if (is.null(name)) 
[17:45:26.242]                               next
[17:45:26.242]                             if (!grepl(pattern, name)) 
[17:45:26.242]                               next
[17:45:26.242]                             invokeRestart(restart)
[17:45:26.242]                             muffled <- TRUE
[17:45:26.242]                             break
[17:45:26.242]                           }
[17:45:26.242]                         }
[17:45:26.242]                       }
[17:45:26.242]                       invisible(muffled)
[17:45:26.242]                     }
[17:45:26.242]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.242]                   }
[17:45:26.242]                 }
[17:45:26.242]                 else {
[17:45:26.242]                   if (TRUE) {
[17:45:26.242]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.242]                     {
[17:45:26.242]                       inherits <- base::inherits
[17:45:26.242]                       invokeRestart <- base::invokeRestart
[17:45:26.242]                       is.null <- base::is.null
[17:45:26.242]                       muffled <- FALSE
[17:45:26.242]                       if (inherits(cond, "message")) {
[17:45:26.242]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.242]                         if (muffled) 
[17:45:26.242]                           invokeRestart("muffleMessage")
[17:45:26.242]                       }
[17:45:26.242]                       else if (inherits(cond, "warning")) {
[17:45:26.242]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.242]                         if (muffled) 
[17:45:26.242]                           invokeRestart("muffleWarning")
[17:45:26.242]                       }
[17:45:26.242]                       else if (inherits(cond, "condition")) {
[17:45:26.242]                         if (!is.null(pattern)) {
[17:45:26.242]                           computeRestarts <- base::computeRestarts
[17:45:26.242]                           grepl <- base::grepl
[17:45:26.242]                           restarts <- computeRestarts(cond)
[17:45:26.242]                           for (restart in restarts) {
[17:45:26.242]                             name <- restart$name
[17:45:26.242]                             if (is.null(name)) 
[17:45:26.242]                               next
[17:45:26.242]                             if (!grepl(pattern, name)) 
[17:45:26.242]                               next
[17:45:26.242]                             invokeRestart(restart)
[17:45:26.242]                             muffled <- TRUE
[17:45:26.242]                             break
[17:45:26.242]                           }
[17:45:26.242]                         }
[17:45:26.242]                       }
[17:45:26.242]                       invisible(muffled)
[17:45:26.242]                     }
[17:45:26.242]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.242]                   }
[17:45:26.242]                 }
[17:45:26.242]             }
[17:45:26.242]         }))
[17:45:26.242]     }, error = function(ex) {
[17:45:26.242]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:26.242]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.242]                 ...future.rng), started = ...future.startTime, 
[17:45:26.242]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:26.242]             version = "1.8"), class = "FutureResult")
[17:45:26.242]     }, finally = {
[17:45:26.242]         if (!identical(...future.workdir, getwd())) 
[17:45:26.242]             setwd(...future.workdir)
[17:45:26.242]         {
[17:45:26.242]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:26.242]                 ...future.oldOptions$nwarnings <- NULL
[17:45:26.242]             }
[17:45:26.242]             base::options(...future.oldOptions)
[17:45:26.242]             if (.Platform$OS.type == "windows") {
[17:45:26.242]                 old_names <- names(...future.oldEnvVars)
[17:45:26.242]                 envs <- base::Sys.getenv()
[17:45:26.242]                 names <- names(envs)
[17:45:26.242]                 common <- intersect(names, old_names)
[17:45:26.242]                 added <- setdiff(names, old_names)
[17:45:26.242]                 removed <- setdiff(old_names, names)
[17:45:26.242]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:26.242]                   envs[common]]
[17:45:26.242]                 NAMES <- toupper(changed)
[17:45:26.242]                 args <- list()
[17:45:26.242]                 for (kk in seq_along(NAMES)) {
[17:45:26.242]                   name <- changed[[kk]]
[17:45:26.242]                   NAME <- NAMES[[kk]]
[17:45:26.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.242]                     next
[17:45:26.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.242]                 }
[17:45:26.242]                 NAMES <- toupper(added)
[17:45:26.242]                 for (kk in seq_along(NAMES)) {
[17:45:26.242]                   name <- added[[kk]]
[17:45:26.242]                   NAME <- NAMES[[kk]]
[17:45:26.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.242]                     next
[17:45:26.242]                   args[[name]] <- ""
[17:45:26.242]                 }
[17:45:26.242]                 NAMES <- toupper(removed)
[17:45:26.242]                 for (kk in seq_along(NAMES)) {
[17:45:26.242]                   name <- removed[[kk]]
[17:45:26.242]                   NAME <- NAMES[[kk]]
[17:45:26.242]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.242]                     next
[17:45:26.242]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.242]                 }
[17:45:26.242]                 if (length(args) > 0) 
[17:45:26.242]                   base::do.call(base::Sys.setenv, args = args)
[17:45:26.242]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:26.242]             }
[17:45:26.242]             else {
[17:45:26.242]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:26.242]             }
[17:45:26.242]             {
[17:45:26.242]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:26.242]                   0L) {
[17:45:26.242]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:26.242]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:26.242]                   base::options(opts)
[17:45:26.242]                 }
[17:45:26.242]                 {
[17:45:26.242]                   {
[17:45:26.242]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:26.242]                     NULL
[17:45:26.242]                   }
[17:45:26.242]                   options(future.plan = NULL)
[17:45:26.242]                   if (is.na(NA_character_)) 
[17:45:26.242]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.242]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:26.242]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:26.242]                     .init = FALSE)
[17:45:26.242]                 }
[17:45:26.242]             }
[17:45:26.242]         }
[17:45:26.242]     })
[17:45:26.242]     if (TRUE) {
[17:45:26.242]         base::sink(type = "output", split = FALSE)
[17:45:26.242]         if (TRUE) {
[17:45:26.242]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:26.242]         }
[17:45:26.242]         else {
[17:45:26.242]             ...future.result["stdout"] <- base::list(NULL)
[17:45:26.242]         }
[17:45:26.242]         base::close(...future.stdout)
[17:45:26.242]         ...future.stdout <- NULL
[17:45:26.242]     }
[17:45:26.242]     ...future.result$conditions <- ...future.conditions
[17:45:26.242]     ...future.result$finished <- base::Sys.time()
[17:45:26.242]     ...future.result
[17:45:26.242] }
[17:45:26.244] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[17:45:26.245] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:26.288] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:26.288] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:45:26.288] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.288] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:26.289] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.289] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:26.331] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:26.332] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:26.376] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:26.376] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:26.376] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.377] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:45:26.377] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:45:26.377] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:26.378] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.378] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:45:26.378] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.378] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:26.379] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.379] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:26.379] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.379] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[17:45:26.380] MultisessionFuture started
[17:45:26.380] - Launch lazy future ... done
[17:45:26.380] run() for ‘MultisessionFuture’ ... done
[17:45:26.380] Created future:
[17:45:26.381] receiveMessageFromWorker() for ClusterFuture ...
[17:45:26.382] - Validating connection of MultisessionFuture
[17:45:26.382] - received message: FutureResult
[17:45:26.382] - Received FutureResult
[17:45:26.382] - Erased future from FutureRegistry
[17:45:26.382] result() for ClusterFuture ...
[17:45:26.382] - result already collected: FutureResult
[17:45:26.382] result() for ClusterFuture ... done
[17:45:26.382] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:26.380] MultisessionFuture:
[17:45:26.380] Label: ‘future_vapply-1’
[17:45:26.380] Expression:
[17:45:26.380] {
[17:45:26.380]     do.call(function(...) {
[17:45:26.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.380]             on.exit(options(oopts), add = TRUE)
[17:45:26.380]         }
[17:45:26.380]         {
[17:45:26.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.380]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.380]             })
[17:45:26.380]         }
[17:45:26.380]     }, args = future.call.arguments)
[17:45:26.380] }
[17:45:26.380] Lazy evaluation: FALSE
[17:45:26.380] Asynchronous evaluation: TRUE
[17:45:26.380] Local evaluation: TRUE
[17:45:26.380] Environment: R_GlobalEnv
[17:45:26.380] Capture standard output: TRUE
[17:45:26.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:26.380] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:26.380] Packages: 1 packages (‘future.apply’)
[17:45:26.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:26.380] Resolved: TRUE
[17:45:26.380] Value: <not collected>
[17:45:26.380] Conditions captured: <none>
[17:45:26.380] Early signaling: FALSE
[17:45:26.380] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:26.380] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.383] Chunk #1 of 2 ... DONE
[17:45:26.383] Chunk #2 of 2 ...
[17:45:26.383]  - Finding globals in 'X' for chunk #2 ...
[17:45:26.383] getGlobalsAndPackages() ...
[17:45:26.383] Searching for globals...
[17:45:26.383] 
[17:45:26.383] Searching for globals ... DONE
[17:45:26.383] - globals: [0] <none>
[17:45:26.384] getGlobalsAndPackages() ... DONE
[17:45:26.384]    + additional globals found: [n=0] 
[17:45:26.384]    + additional namespaces needed: [n=0] 
[17:45:26.384]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:26.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:26.384]  - seeds: <none>
[17:45:26.384]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.384] getGlobalsAndPackages() ...
[17:45:26.384] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.384] Resolving globals: FALSE
[17:45:26.384] Tweak future expression to call with '...' arguments ...
[17:45:26.385] {
[17:45:26.385]     do.call(function(...) {
[17:45:26.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.385]             on.exit(options(oopts), add = TRUE)
[17:45:26.385]         }
[17:45:26.385]         {
[17:45:26.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.385]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.385]             })
[17:45:26.385]         }
[17:45:26.385]     }, args = future.call.arguments)
[17:45:26.385] }
[17:45:26.385] Tweak future expression to call with '...' arguments ... DONE
[17:45:26.385] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.386] - packages: [1] ‘future.apply’
[17:45:26.386] getGlobalsAndPackages() ... DONE
[17:45:26.386] run() for ‘Future’ ...
[17:45:26.386] - state: ‘created’
[17:45:26.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:26.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:26.400]   - Field: ‘node’
[17:45:26.400]   - Field: ‘label’
[17:45:26.401]   - Field: ‘local’
[17:45:26.401]   - Field: ‘owner’
[17:45:26.401]   - Field: ‘envir’
[17:45:26.401]   - Field: ‘workers’
[17:45:26.401]   - Field: ‘packages’
[17:45:26.401]   - Field: ‘gc’
[17:45:26.401]   - Field: ‘conditions’
[17:45:26.401]   - Field: ‘persistent’
[17:45:26.401]   - Field: ‘expr’
[17:45:26.401]   - Field: ‘uuid’
[17:45:26.401]   - Field: ‘seed’
[17:45:26.402]   - Field: ‘version’
[17:45:26.402]   - Field: ‘result’
[17:45:26.402]   - Field: ‘asynchronous’
[17:45:26.402]   - Field: ‘calls’
[17:45:26.402]   - Field: ‘globals’
[17:45:26.402]   - Field: ‘stdout’
[17:45:26.402]   - Field: ‘earlySignal’
[17:45:26.402]   - Field: ‘lazy’
[17:45:26.402]   - Field: ‘state’
[17:45:26.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:26.402] - Launch lazy future ...
[17:45:26.403] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:26.403] Packages needed by future strategies (n = 0): <none>
[17:45:26.403] {
[17:45:26.403]     {
[17:45:26.403]         {
[17:45:26.403]             ...future.startTime <- base::Sys.time()
[17:45:26.403]             {
[17:45:26.403]                 {
[17:45:26.403]                   {
[17:45:26.403]                     {
[17:45:26.403]                       {
[17:45:26.403]                         base::local({
[17:45:26.403]                           has_future <- base::requireNamespace("future", 
[17:45:26.403]                             quietly = TRUE)
[17:45:26.403]                           if (has_future) {
[17:45:26.403]                             ns <- base::getNamespace("future")
[17:45:26.403]                             version <- ns[[".package"]][["version"]]
[17:45:26.403]                             if (is.null(version)) 
[17:45:26.403]                               version <- utils::packageVersion("future")
[17:45:26.403]                           }
[17:45:26.403]                           else {
[17:45:26.403]                             version <- NULL
[17:45:26.403]                           }
[17:45:26.403]                           if (!has_future || version < "1.8.0") {
[17:45:26.403]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:26.403]                               "", base::R.version$version.string), 
[17:45:26.403]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:26.403]                                 base::R.version$platform, 8 * 
[17:45:26.403]                                   base::.Machine$sizeof.pointer), 
[17:45:26.403]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:26.403]                                 "release", "version")], collapse = " "), 
[17:45:26.403]                               hostname = base::Sys.info()[["nodename"]])
[17:45:26.403]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:26.403]                               info)
[17:45:26.403]                             info <- base::paste(info, collapse = "; ")
[17:45:26.403]                             if (!has_future) {
[17:45:26.403]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:26.403]                                 info)
[17:45:26.403]                             }
[17:45:26.403]                             else {
[17:45:26.403]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:26.403]                                 info, version)
[17:45:26.403]                             }
[17:45:26.403]                             base::stop(msg)
[17:45:26.403]                           }
[17:45:26.403]                         })
[17:45:26.403]                       }
[17:45:26.403]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:26.403]                       base::options(mc.cores = 1L)
[17:45:26.403]                     }
[17:45:26.403]                     base::local({
[17:45:26.403]                       for (pkg in "future.apply") {
[17:45:26.403]                         base::loadNamespace(pkg)
[17:45:26.403]                         base::library(pkg, character.only = TRUE)
[17:45:26.403]                       }
[17:45:26.403]                     })
[17:45:26.403]                   }
[17:45:26.403]                   ...future.strategy.old <- future::plan("list")
[17:45:26.403]                   options(future.plan = NULL)
[17:45:26.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:26.403]                 }
[17:45:26.403]                 ...future.workdir <- getwd()
[17:45:26.403]             }
[17:45:26.403]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:26.403]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:26.403]         }
[17:45:26.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:26.403]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:26.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:26.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:26.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:26.403]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:26.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:26.403]             base::names(...future.oldOptions))
[17:45:26.403]     }
[17:45:26.403]     if (FALSE) {
[17:45:26.403]     }
[17:45:26.403]     else {
[17:45:26.403]         if (TRUE) {
[17:45:26.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:26.403]                 open = "w")
[17:45:26.403]         }
[17:45:26.403]         else {
[17:45:26.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:26.403]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:26.403]         }
[17:45:26.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:26.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:26.403]             base::sink(type = "output", split = FALSE)
[17:45:26.403]             base::close(...future.stdout)
[17:45:26.403]         }, add = TRUE)
[17:45:26.403]     }
[17:45:26.403]     ...future.frame <- base::sys.nframe()
[17:45:26.403]     ...future.conditions <- base::list()
[17:45:26.403]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:26.403]     if (FALSE) {
[17:45:26.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:26.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:26.403]     }
[17:45:26.403]     ...future.result <- base::tryCatch({
[17:45:26.403]         base::withCallingHandlers({
[17:45:26.403]             ...future.value <- base::withVisible(base::local({
[17:45:26.403]                 ...future.makeSendCondition <- base::local({
[17:45:26.403]                   sendCondition <- NULL
[17:45:26.403]                   function(frame = 1L) {
[17:45:26.403]                     if (is.function(sendCondition)) 
[17:45:26.403]                       return(sendCondition)
[17:45:26.403]                     ns <- getNamespace("parallel")
[17:45:26.403]                     if (exists("sendData", mode = "function", 
[17:45:26.403]                       envir = ns)) {
[17:45:26.403]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:26.403]                         envir = ns)
[17:45:26.403]                       envir <- sys.frame(frame)
[17:45:26.403]                       master <- NULL
[17:45:26.403]                       while (!identical(envir, .GlobalEnv) && 
[17:45:26.403]                         !identical(envir, emptyenv())) {
[17:45:26.403]                         if (exists("master", mode = "list", envir = envir, 
[17:45:26.403]                           inherits = FALSE)) {
[17:45:26.403]                           master <- get("master", mode = "list", 
[17:45:26.403]                             envir = envir, inherits = FALSE)
[17:45:26.403]                           if (inherits(master, c("SOCKnode", 
[17:45:26.403]                             "SOCK0node"))) {
[17:45:26.403]                             sendCondition <<- function(cond) {
[17:45:26.403]                               data <- list(type = "VALUE", value = cond, 
[17:45:26.403]                                 success = TRUE)
[17:45:26.403]                               parallel_sendData(master, data)
[17:45:26.403]                             }
[17:45:26.403]                             return(sendCondition)
[17:45:26.403]                           }
[17:45:26.403]                         }
[17:45:26.403]                         frame <- frame + 1L
[17:45:26.403]                         envir <- sys.frame(frame)
[17:45:26.403]                       }
[17:45:26.403]                     }
[17:45:26.403]                     sendCondition <<- function(cond) NULL
[17:45:26.403]                   }
[17:45:26.403]                 })
[17:45:26.403]                 withCallingHandlers({
[17:45:26.403]                   {
[17:45:26.403]                     do.call(function(...) {
[17:45:26.403]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.403]                       if (!identical(...future.globals.maxSize.org, 
[17:45:26.403]                         ...future.globals.maxSize)) {
[17:45:26.403]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.403]                         on.exit(options(oopts), add = TRUE)
[17:45:26.403]                       }
[17:45:26.403]                       {
[17:45:26.403]                         lapply(seq_along(...future.elements_ii), 
[17:45:26.403]                           FUN = function(jj) {
[17:45:26.403]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.403]                             ...future.FUN(...future.X_jj, ...)
[17:45:26.403]                           })
[17:45:26.403]                       }
[17:45:26.403]                     }, args = future.call.arguments)
[17:45:26.403]                   }
[17:45:26.403]                 }, immediateCondition = function(cond) {
[17:45:26.403]                   sendCondition <- ...future.makeSendCondition()
[17:45:26.403]                   sendCondition(cond)
[17:45:26.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.403]                   {
[17:45:26.403]                     inherits <- base::inherits
[17:45:26.403]                     invokeRestart <- base::invokeRestart
[17:45:26.403]                     is.null <- base::is.null
[17:45:26.403]                     muffled <- FALSE
[17:45:26.403]                     if (inherits(cond, "message")) {
[17:45:26.403]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:26.403]                       if (muffled) 
[17:45:26.403]                         invokeRestart("muffleMessage")
[17:45:26.403]                     }
[17:45:26.403]                     else if (inherits(cond, "warning")) {
[17:45:26.403]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:26.403]                       if (muffled) 
[17:45:26.403]                         invokeRestart("muffleWarning")
[17:45:26.403]                     }
[17:45:26.403]                     else if (inherits(cond, "condition")) {
[17:45:26.403]                       if (!is.null(pattern)) {
[17:45:26.403]                         computeRestarts <- base::computeRestarts
[17:45:26.403]                         grepl <- base::grepl
[17:45:26.403]                         restarts <- computeRestarts(cond)
[17:45:26.403]                         for (restart in restarts) {
[17:45:26.403]                           name <- restart$name
[17:45:26.403]                           if (is.null(name)) 
[17:45:26.403]                             next
[17:45:26.403]                           if (!grepl(pattern, name)) 
[17:45:26.403]                             next
[17:45:26.403]                           invokeRestart(restart)
[17:45:26.403]                           muffled <- TRUE
[17:45:26.403]                           break
[17:45:26.403]                         }
[17:45:26.403]                       }
[17:45:26.403]                     }
[17:45:26.403]                     invisible(muffled)
[17:45:26.403]                   }
[17:45:26.403]                   muffleCondition(cond)
[17:45:26.403]                 })
[17:45:26.403]             }))
[17:45:26.403]             future::FutureResult(value = ...future.value$value, 
[17:45:26.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.403]                   ...future.rng), globalenv = if (FALSE) 
[17:45:26.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:26.403]                     ...future.globalenv.names))
[17:45:26.403]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:26.403]         }, condition = base::local({
[17:45:26.403]             c <- base::c
[17:45:26.403]             inherits <- base::inherits
[17:45:26.403]             invokeRestart <- base::invokeRestart
[17:45:26.403]             length <- base::length
[17:45:26.403]             list <- base::list
[17:45:26.403]             seq.int <- base::seq.int
[17:45:26.403]             signalCondition <- base::signalCondition
[17:45:26.403]             sys.calls <- base::sys.calls
[17:45:26.403]             `[[` <- base::`[[`
[17:45:26.403]             `+` <- base::`+`
[17:45:26.403]             `<<-` <- base::`<<-`
[17:45:26.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:26.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:26.403]                   3L)]
[17:45:26.403]             }
[17:45:26.403]             function(cond) {
[17:45:26.403]                 is_error <- inherits(cond, "error")
[17:45:26.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:26.403]                   NULL)
[17:45:26.403]                 if (is_error) {
[17:45:26.403]                   sessionInformation <- function() {
[17:45:26.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:26.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:26.403]                       search = base::search(), system = base::Sys.info())
[17:45:26.403]                   }
[17:45:26.403]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:26.403]                     cond$call), session = sessionInformation(), 
[17:45:26.403]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:26.403]                   signalCondition(cond)
[17:45:26.403]                 }
[17:45:26.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:26.403]                 "immediateCondition"))) {
[17:45:26.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:26.403]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:26.403]                   if (TRUE && !signal) {
[17:45:26.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.403]                     {
[17:45:26.403]                       inherits <- base::inherits
[17:45:26.403]                       invokeRestart <- base::invokeRestart
[17:45:26.403]                       is.null <- base::is.null
[17:45:26.403]                       muffled <- FALSE
[17:45:26.403]                       if (inherits(cond, "message")) {
[17:45:26.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.403]                         if (muffled) 
[17:45:26.403]                           invokeRestart("muffleMessage")
[17:45:26.403]                       }
[17:45:26.403]                       else if (inherits(cond, "warning")) {
[17:45:26.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.403]                         if (muffled) 
[17:45:26.403]                           invokeRestart("muffleWarning")
[17:45:26.403]                       }
[17:45:26.403]                       else if (inherits(cond, "condition")) {
[17:45:26.403]                         if (!is.null(pattern)) {
[17:45:26.403]                           computeRestarts <- base::computeRestarts
[17:45:26.403]                           grepl <- base::grepl
[17:45:26.403]                           restarts <- computeRestarts(cond)
[17:45:26.403]                           for (restart in restarts) {
[17:45:26.403]                             name <- restart$name
[17:45:26.403]                             if (is.null(name)) 
[17:45:26.403]                               next
[17:45:26.403]                             if (!grepl(pattern, name)) 
[17:45:26.403]                               next
[17:45:26.403]                             invokeRestart(restart)
[17:45:26.403]                             muffled <- TRUE
[17:45:26.403]                             break
[17:45:26.403]                           }
[17:45:26.403]                         }
[17:45:26.403]                       }
[17:45:26.403]                       invisible(muffled)
[17:45:26.403]                     }
[17:45:26.403]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.403]                   }
[17:45:26.403]                 }
[17:45:26.403]                 else {
[17:45:26.403]                   if (TRUE) {
[17:45:26.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.403]                     {
[17:45:26.403]                       inherits <- base::inherits
[17:45:26.403]                       invokeRestart <- base::invokeRestart
[17:45:26.403]                       is.null <- base::is.null
[17:45:26.403]                       muffled <- FALSE
[17:45:26.403]                       if (inherits(cond, "message")) {
[17:45:26.403]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.403]                         if (muffled) 
[17:45:26.403]                           invokeRestart("muffleMessage")
[17:45:26.403]                       }
[17:45:26.403]                       else if (inherits(cond, "warning")) {
[17:45:26.403]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.403]                         if (muffled) 
[17:45:26.403]                           invokeRestart("muffleWarning")
[17:45:26.403]                       }
[17:45:26.403]                       else if (inherits(cond, "condition")) {
[17:45:26.403]                         if (!is.null(pattern)) {
[17:45:26.403]                           computeRestarts <- base::computeRestarts
[17:45:26.403]                           grepl <- base::grepl
[17:45:26.403]                           restarts <- computeRestarts(cond)
[17:45:26.403]                           for (restart in restarts) {
[17:45:26.403]                             name <- restart$name
[17:45:26.403]                             if (is.null(name)) 
[17:45:26.403]                               next
[17:45:26.403]                             if (!grepl(pattern, name)) 
[17:45:26.403]                               next
[17:45:26.403]                             invokeRestart(restart)
[17:45:26.403]                             muffled <- TRUE
[17:45:26.403]                             break
[17:45:26.403]                           }
[17:45:26.403]                         }
[17:45:26.403]                       }
[17:45:26.403]                       invisible(muffled)
[17:45:26.403]                     }
[17:45:26.403]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.403]                   }
[17:45:26.403]                 }
[17:45:26.403]             }
[17:45:26.403]         }))
[17:45:26.403]     }, error = function(ex) {
[17:45:26.403]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:26.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.403]                 ...future.rng), started = ...future.startTime, 
[17:45:26.403]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:26.403]             version = "1.8"), class = "FutureResult")
[17:45:26.403]     }, finally = {
[17:45:26.403]         if (!identical(...future.workdir, getwd())) 
[17:45:26.403]             setwd(...future.workdir)
[17:45:26.403]         {
[17:45:26.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:26.403]                 ...future.oldOptions$nwarnings <- NULL
[17:45:26.403]             }
[17:45:26.403]             base::options(...future.oldOptions)
[17:45:26.403]             if (.Platform$OS.type == "windows") {
[17:45:26.403]                 old_names <- names(...future.oldEnvVars)
[17:45:26.403]                 envs <- base::Sys.getenv()
[17:45:26.403]                 names <- names(envs)
[17:45:26.403]                 common <- intersect(names, old_names)
[17:45:26.403]                 added <- setdiff(names, old_names)
[17:45:26.403]                 removed <- setdiff(old_names, names)
[17:45:26.403]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:26.403]                   envs[common]]
[17:45:26.403]                 NAMES <- toupper(changed)
[17:45:26.403]                 args <- list()
[17:45:26.403]                 for (kk in seq_along(NAMES)) {
[17:45:26.403]                   name <- changed[[kk]]
[17:45:26.403]                   NAME <- NAMES[[kk]]
[17:45:26.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.403]                     next
[17:45:26.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.403]                 }
[17:45:26.403]                 NAMES <- toupper(added)
[17:45:26.403]                 for (kk in seq_along(NAMES)) {
[17:45:26.403]                   name <- added[[kk]]
[17:45:26.403]                   NAME <- NAMES[[kk]]
[17:45:26.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.403]                     next
[17:45:26.403]                   args[[name]] <- ""
[17:45:26.403]                 }
[17:45:26.403]                 NAMES <- toupper(removed)
[17:45:26.403]                 for (kk in seq_along(NAMES)) {
[17:45:26.403]                   name <- removed[[kk]]
[17:45:26.403]                   NAME <- NAMES[[kk]]
[17:45:26.403]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.403]                     next
[17:45:26.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.403]                 }
[17:45:26.403]                 if (length(args) > 0) 
[17:45:26.403]                   base::do.call(base::Sys.setenv, args = args)
[17:45:26.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:26.403]             }
[17:45:26.403]             else {
[17:45:26.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:26.403]             }
[17:45:26.403]             {
[17:45:26.403]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:26.403]                   0L) {
[17:45:26.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:26.403]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:26.403]                   base::options(opts)
[17:45:26.403]                 }
[17:45:26.403]                 {
[17:45:26.403]                   {
[17:45:26.403]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:26.403]                     NULL
[17:45:26.403]                   }
[17:45:26.403]                   options(future.plan = NULL)
[17:45:26.403]                   if (is.na(NA_character_)) 
[17:45:26.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:26.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:26.403]                     .init = FALSE)
[17:45:26.403]                 }
[17:45:26.403]             }
[17:45:26.403]         }
[17:45:26.403]     })
[17:45:26.403]     if (TRUE) {
[17:45:26.403]         base::sink(type = "output", split = FALSE)
[17:45:26.403]         if (TRUE) {
[17:45:26.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:26.403]         }
[17:45:26.403]         else {
[17:45:26.403]             ...future.result["stdout"] <- base::list(NULL)
[17:45:26.403]         }
[17:45:26.403]         base::close(...future.stdout)
[17:45:26.403]         ...future.stdout <- NULL
[17:45:26.403]     }
[17:45:26.403]     ...future.result$conditions <- ...future.conditions
[17:45:26.403]     ...future.result$finished <- base::Sys.time()
[17:45:26.403]     ...future.result
[17:45:26.403] }
[17:45:26.406] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[17:45:26.406] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:26.448] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:26.448] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[17:45:26.448] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.448] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:26.449] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.449] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:26.492] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:26.492] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:26.536] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:26.536] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:26.536] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.537] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[17:45:26.537] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[17:45:26.537] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:26.538] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.538] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[17:45:26.538] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[17:45:26.538] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:26.539] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:26.539] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.539] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[17:45:26.540] MultisessionFuture started
[17:45:26.540] - Launch lazy future ... done
[17:45:26.540] run() for ‘MultisessionFuture’ ... done
[17:45:26.540] Created future:
[17:45:26.542] receiveMessageFromWorker() for ClusterFuture ...
[17:45:26.544] - Validating connection of MultisessionFuture
[17:45:26.544] - received message: FutureResult
[17:45:26.545] - Received FutureResult
[17:45:26.545] - Erased future from FutureRegistry
[17:45:26.545] result() for ClusterFuture ...
[17:45:26.545] - result already collected: FutureResult
[17:45:26.545] result() for ClusterFuture ... done
[17:45:26.545] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:26.540] MultisessionFuture:
[17:45:26.540] Label: ‘future_vapply-2’
[17:45:26.540] Expression:
[17:45:26.540] {
[17:45:26.540]     do.call(function(...) {
[17:45:26.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.540]             on.exit(options(oopts), add = TRUE)
[17:45:26.540]         }
[17:45:26.540]         {
[17:45:26.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.540]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.540]             })
[17:45:26.540]         }
[17:45:26.540]     }, args = future.call.arguments)
[17:45:26.540] }
[17:45:26.540] Lazy evaluation: FALSE
[17:45:26.540] Asynchronous evaluation: TRUE
[17:45:26.540] Local evaluation: TRUE
[17:45:26.540] Environment: R_GlobalEnv
[17:45:26.540] Capture standard output: TRUE
[17:45:26.540] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:26.540] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:26.540] Packages: 1 packages (‘future.apply’)
[17:45:26.540] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:26.540] Resolved: TRUE
[17:45:26.540] Value: <not collected>
[17:45:26.540] Conditions captured: <none>
[17:45:26.540] Early signaling: FALSE
[17:45:26.540] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:26.540] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.546] Chunk #2 of 2 ... DONE
[17:45:26.546] Launching 2 futures (chunks) ... DONE
[17:45:26.546] Resolving 2 futures (chunks) ...
[17:45:26.546] resolve() on list ...
[17:45:26.546]  recursive: 0
[17:45:26.546]  length: 2
[17:45:26.546] 
[17:45:26.546] Future #1
[17:45:26.546] result() for ClusterFuture ...
[17:45:26.546] - result already collected: FutureResult
[17:45:26.546] result() for ClusterFuture ... done
[17:45:26.547] result() for ClusterFuture ...
[17:45:26.547] - result already collected: FutureResult
[17:45:26.547] result() for ClusterFuture ... done
[17:45:26.547] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:26.547] - nx: 2
[17:45:26.547] - relay: TRUE
[17:45:26.547] - stdout: TRUE
[17:45:26.547] - signal: TRUE
[17:45:26.547] - resignal: FALSE
[17:45:26.547] - force: TRUE
[17:45:26.547] - relayed: [n=2] FALSE, FALSE
[17:45:26.547] - queued futures: [n=2] FALSE, FALSE
[17:45:26.548]  - until=1
[17:45:26.548]  - relaying element #1
[17:45:26.548] result() for ClusterFuture ...
[17:45:26.548] - result already collected: FutureResult
[17:45:26.548] result() for ClusterFuture ... done
[17:45:26.548] result() for ClusterFuture ...
[17:45:26.548] - result already collected: FutureResult
[17:45:26.548] result() for ClusterFuture ... done
[17:45:26.548] result() for ClusterFuture ...
[17:45:26.548] - result already collected: FutureResult
[17:45:26.548] result() for ClusterFuture ... done
[17:45:26.548] result() for ClusterFuture ...
[17:45:26.549] - result already collected: FutureResult
[17:45:26.549] result() for ClusterFuture ... done
[17:45:26.549] - relayed: [n=2] TRUE, FALSE
[17:45:26.549] - queued futures: [n=2] TRUE, FALSE
[17:45:26.549] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:26.549]  length: 1 (resolved future 1)
[17:45:26.549] Future #2
[17:45:26.549] result() for ClusterFuture ...
[17:45:26.549] - result already collected: FutureResult
[17:45:26.549] result() for ClusterFuture ... done
[17:45:26.549] result() for ClusterFuture ...
[17:45:26.550] - result already collected: FutureResult
[17:45:26.550] result() for ClusterFuture ... done
[17:45:26.550] signalConditionsASAP(MultisessionFuture, pos=2) ...
[17:45:26.550] - nx: 2
[17:45:26.550] - relay: TRUE
[17:45:26.550] - stdout: TRUE
[17:45:26.550] - signal: TRUE
[17:45:26.550] - resignal: FALSE
[17:45:26.550] - force: TRUE
[17:45:26.550] - relayed: [n=2] TRUE, FALSE
[17:45:26.550] - queued futures: [n=2] TRUE, FALSE
[17:45:26.550]  - until=2
[17:45:26.550]  - relaying element #2
[17:45:26.551] result() for ClusterFuture ...
[17:45:26.551] - result already collected: FutureResult
[17:45:26.551] result() for ClusterFuture ... done
[17:45:26.551] result() for ClusterFuture ...
[17:45:26.551] - result already collected: FutureResult
[17:45:26.551] result() for ClusterFuture ... done
[17:45:26.551] result() for ClusterFuture ...
[17:45:26.551] - result already collected: FutureResult
[17:45:26.551] result() for ClusterFuture ... done
[17:45:26.551] result() for ClusterFuture ...
[17:45:26.551] - result already collected: FutureResult
[17:45:26.552] result() for ClusterFuture ... done
[17:45:26.552] - relayed: [n=2] TRUE, TRUE
[17:45:26.552] - queued futures: [n=2] TRUE, TRUE
[17:45:26.552] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[17:45:26.552]  length: 0 (resolved future 2)
[17:45:26.552] Relaying remaining futures
[17:45:26.552] signalConditionsASAP(NULL, pos=0) ...
[17:45:26.552] - nx: 2
[17:45:26.552] - relay: TRUE
[17:45:26.552] - stdout: TRUE
[17:45:26.552] - signal: TRUE
[17:45:26.552] - resignal: FALSE
[17:45:26.552] - force: TRUE
[17:45:26.553] - relayed: [n=2] TRUE, TRUE
[17:45:26.553] - queued futures: [n=2] TRUE, TRUE
 - flush all
[17:45:26.553] - relayed: [n=2] TRUE, TRUE
[17:45:26.553] - queued futures: [n=2] TRUE, TRUE
[17:45:26.553] signalConditionsASAP(NULL, pos=0) ... done
[17:45:26.553] resolve() on list ... DONE
[17:45:26.553] result() for ClusterFuture ...
[17:45:26.553] - result already collected: FutureResult
[17:45:26.553] result() for ClusterFuture ... done
[17:45:26.553] result() for ClusterFuture ...
[17:45:26.553] - result already collected: FutureResult
[17:45:26.554] result() for ClusterFuture ... done
[17:45:26.554] result() for ClusterFuture ...
[17:45:26.554] - result already collected: FutureResult
[17:45:26.554] result() for ClusterFuture ... done
[17:45:26.554] result() for ClusterFuture ...
[17:45:26.554] - result already collected: FutureResult
[17:45:26.554] result() for ClusterFuture ... done
[17:45:26.554]  - Number of value chunks collected: 2
[17:45:26.554] Resolving 2 futures (chunks) ... DONE
[17:45:26.554] Reducing values from 2 chunks ...
[17:45:26.554]  - Number of values collected after concatenation: 3
[17:45:26.554]  - Number of values expected: 3
[17:45:26.555] Reducing values from 2 chunks ... DONE
[17:45:26.555] future_lapply() ... DONE
- exceptions ...
[17:45:26.555] future_lapply() ...
[17:45:26.560] Number of chunks: 2
[17:45:26.560] getGlobalsAndPackagesXApply() ...
[17:45:26.560]  - future.globals: TRUE
[17:45:26.561] getGlobalsAndPackages() ...
[17:45:26.561] Searching for globals...
[17:45:26.564] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[17:45:26.564] Searching for globals ... DONE
[17:45:26.564] Resolving globals: FALSE
[17:45:26.565] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[17:45:26.565] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[17:45:26.566] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:26.566] - packages: [1] ‘future.apply’
[17:45:26.566] getGlobalsAndPackages() ... DONE
[17:45:26.566]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[17:45:26.566]  - needed namespaces: [n=1] ‘future.apply’
[17:45:26.566] Finding globals ... DONE
[17:45:26.566]  - use_args: TRUE
[17:45:26.567]  - Getting '...' globals ...
[17:45:26.567] resolve() on list ...
[17:45:26.567]  recursive: 0
[17:45:26.567]  length: 1
[17:45:26.567]  elements: ‘...’
[17:45:26.568]  length: 0 (resolved future 1)
[17:45:26.568] resolve() on list ... DONE
[17:45:26.568]    - '...' content: [n=0] 
[17:45:26.568] List of 1
[17:45:26.568]  $ ...: list()
[17:45:26.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:26.568]  - attr(*, "where")=List of 1
[17:45:26.568]   ..$ ...:<environment: 0x5561f535ace8> 
[17:45:26.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:26.568]  - attr(*, "resolved")= logi TRUE
[17:45:26.568]  - attr(*, "total_size")= num NA
[17:45:26.572]  - Getting '...' globals ... DONE
[17:45:26.572] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[17:45:26.572] List of 8
[17:45:26.572]  $ ...future.FUN:function (x, ...)  
[17:45:26.572]  $ x_FUN        :function (x)  
[17:45:26.572]  $ times        : int 2
[17:45:26.572]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[17:45:26.572]  $ stop_if_not  :function (...)  
[17:45:26.572]  $ dim          : NULL
[17:45:26.572]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[17:45:26.572]  $ ...          : list()
[17:45:26.572]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[17:45:26.572]  - attr(*, "where")=List of 8
[17:45:26.572]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ times        :<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ stopf        :<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ dim          :<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ valid_types  :<environment: R_EmptyEnv> 
[17:45:26.572]   ..$ ...          :<environment: 0x5561f535ace8> 
[17:45:26.572]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[17:45:26.572]  - attr(*, "resolved")= logi FALSE
[17:45:26.572]  - attr(*, "total_size")= num 95128
[17:45:26.577] Packages to be attached in all futures: [n=1] ‘future.apply’
[17:45:26.577] getGlobalsAndPackagesXApply() ... DONE
[17:45:26.578] Number of futures (= number of chunks): 2
[17:45:26.578] Launching 2 futures (chunks) ...
[17:45:26.578] Chunk #1 of 2 ...
[17:45:26.578]  - Finding globals in 'X' for chunk #1 ...
[17:45:26.578] getGlobalsAndPackages() ...
[17:45:26.578] Searching for globals...
[17:45:26.578] 
[17:45:26.578] Searching for globals ... DONE
[17:45:26.578] - globals: [0] <none>
[17:45:26.579] getGlobalsAndPackages() ... DONE
[17:45:26.579]    + additional globals found: [n=0] 
[17:45:26.579]    + additional namespaces needed: [n=0] 
[17:45:26.579]  - Finding globals in 'X' for chunk #1 ... DONE
[17:45:26.579]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:26.579]  - seeds: <none>
[17:45:26.579]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.579] getGlobalsAndPackages() ...
[17:45:26.579] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.579] Resolving globals: FALSE
[17:45:26.580] Tweak future expression to call with '...' arguments ...
[17:45:26.580] {
[17:45:26.580]     do.call(function(...) {
[17:45:26.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.580]             on.exit(options(oopts), add = TRUE)
[17:45:26.580]         }
[17:45:26.580]         {
[17:45:26.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.580]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.580]             })
[17:45:26.580]         }
[17:45:26.580]     }, args = future.call.arguments)
[17:45:26.580] }
[17:45:26.580] Tweak future expression to call with '...' arguments ... DONE
[17:45:26.580] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.580] - packages: [1] ‘future.apply’
[17:45:26.581] getGlobalsAndPackages() ... DONE
[17:45:26.581] run() for ‘Future’ ...
[17:45:26.581] - state: ‘created’
[17:45:26.581] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:26.595] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.595] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:26.595]   - Field: ‘node’
[17:45:26.595]   - Field: ‘label’
[17:45:26.595]   - Field: ‘local’
[17:45:26.595]   - Field: ‘owner’
[17:45:26.596]   - Field: ‘envir’
[17:45:26.596]   - Field: ‘workers’
[17:45:26.596]   - Field: ‘packages’
[17:45:26.596]   - Field: ‘gc’
[17:45:26.596]   - Field: ‘conditions’
[17:45:26.596]   - Field: ‘persistent’
[17:45:26.596]   - Field: ‘expr’
[17:45:26.596]   - Field: ‘uuid’
[17:45:26.596]   - Field: ‘seed’
[17:45:26.596]   - Field: ‘version’
[17:45:26.596]   - Field: ‘result’
[17:45:26.597]   - Field: ‘asynchronous’
[17:45:26.597]   - Field: ‘calls’
[17:45:26.597]   - Field: ‘globals’
[17:45:26.597]   - Field: ‘stdout’
[17:45:26.597]   - Field: ‘earlySignal’
[17:45:26.597]   - Field: ‘lazy’
[17:45:26.597]   - Field: ‘state’
[17:45:26.597] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:26.597] - Launch lazy future ...
[17:45:26.597] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:26.598] Packages needed by future strategies (n = 0): <none>
[17:45:26.598] {
[17:45:26.598]     {
[17:45:26.598]         {
[17:45:26.598]             ...future.startTime <- base::Sys.time()
[17:45:26.598]             {
[17:45:26.598]                 {
[17:45:26.598]                   {
[17:45:26.598]                     {
[17:45:26.598]                       {
[17:45:26.598]                         base::local({
[17:45:26.598]                           has_future <- base::requireNamespace("future", 
[17:45:26.598]                             quietly = TRUE)
[17:45:26.598]                           if (has_future) {
[17:45:26.598]                             ns <- base::getNamespace("future")
[17:45:26.598]                             version <- ns[[".package"]][["version"]]
[17:45:26.598]                             if (is.null(version)) 
[17:45:26.598]                               version <- utils::packageVersion("future")
[17:45:26.598]                           }
[17:45:26.598]                           else {
[17:45:26.598]                             version <- NULL
[17:45:26.598]                           }
[17:45:26.598]                           if (!has_future || version < "1.8.0") {
[17:45:26.598]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:26.598]                               "", base::R.version$version.string), 
[17:45:26.598]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:26.598]                                 base::R.version$platform, 8 * 
[17:45:26.598]                                   base::.Machine$sizeof.pointer), 
[17:45:26.598]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:26.598]                                 "release", "version")], collapse = " "), 
[17:45:26.598]                               hostname = base::Sys.info()[["nodename"]])
[17:45:26.598]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:26.598]                               info)
[17:45:26.598]                             info <- base::paste(info, collapse = "; ")
[17:45:26.598]                             if (!has_future) {
[17:45:26.598]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:26.598]                                 info)
[17:45:26.598]                             }
[17:45:26.598]                             else {
[17:45:26.598]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:26.598]                                 info, version)
[17:45:26.598]                             }
[17:45:26.598]                             base::stop(msg)
[17:45:26.598]                           }
[17:45:26.598]                         })
[17:45:26.598]                       }
[17:45:26.598]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:26.598]                       base::options(mc.cores = 1L)
[17:45:26.598]                     }
[17:45:26.598]                     base::local({
[17:45:26.598]                       for (pkg in "future.apply") {
[17:45:26.598]                         base::loadNamespace(pkg)
[17:45:26.598]                         base::library(pkg, character.only = TRUE)
[17:45:26.598]                       }
[17:45:26.598]                     })
[17:45:26.598]                   }
[17:45:26.598]                   ...future.strategy.old <- future::plan("list")
[17:45:26.598]                   options(future.plan = NULL)
[17:45:26.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.598]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:26.598]                 }
[17:45:26.598]                 ...future.workdir <- getwd()
[17:45:26.598]             }
[17:45:26.598]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:26.598]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:26.598]         }
[17:45:26.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:26.598]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:26.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:26.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:26.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:26.598]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:26.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:26.598]             base::names(...future.oldOptions))
[17:45:26.598]     }
[17:45:26.598]     if (FALSE) {
[17:45:26.598]     }
[17:45:26.598]     else {
[17:45:26.598]         if (TRUE) {
[17:45:26.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:26.598]                 open = "w")
[17:45:26.598]         }
[17:45:26.598]         else {
[17:45:26.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:26.598]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:26.598]         }
[17:45:26.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:26.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:26.598]             base::sink(type = "output", split = FALSE)
[17:45:26.598]             base::close(...future.stdout)
[17:45:26.598]         }, add = TRUE)
[17:45:26.598]     }
[17:45:26.598]     ...future.frame <- base::sys.nframe()
[17:45:26.598]     ...future.conditions <- base::list()
[17:45:26.598]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:26.598]     if (FALSE) {
[17:45:26.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:26.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:26.598]     }
[17:45:26.598]     ...future.result <- base::tryCatch({
[17:45:26.598]         base::withCallingHandlers({
[17:45:26.598]             ...future.value <- base::withVisible(base::local({
[17:45:26.598]                 ...future.makeSendCondition <- base::local({
[17:45:26.598]                   sendCondition <- NULL
[17:45:26.598]                   function(frame = 1L) {
[17:45:26.598]                     if (is.function(sendCondition)) 
[17:45:26.598]                       return(sendCondition)
[17:45:26.598]                     ns <- getNamespace("parallel")
[17:45:26.598]                     if (exists("sendData", mode = "function", 
[17:45:26.598]                       envir = ns)) {
[17:45:26.598]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:26.598]                         envir = ns)
[17:45:26.598]                       envir <- sys.frame(frame)
[17:45:26.598]                       master <- NULL
[17:45:26.598]                       while (!identical(envir, .GlobalEnv) && 
[17:45:26.598]                         !identical(envir, emptyenv())) {
[17:45:26.598]                         if (exists("master", mode = "list", envir = envir, 
[17:45:26.598]                           inherits = FALSE)) {
[17:45:26.598]                           master <- get("master", mode = "list", 
[17:45:26.598]                             envir = envir, inherits = FALSE)
[17:45:26.598]                           if (inherits(master, c("SOCKnode", 
[17:45:26.598]                             "SOCK0node"))) {
[17:45:26.598]                             sendCondition <<- function(cond) {
[17:45:26.598]                               data <- list(type = "VALUE", value = cond, 
[17:45:26.598]                                 success = TRUE)
[17:45:26.598]                               parallel_sendData(master, data)
[17:45:26.598]                             }
[17:45:26.598]                             return(sendCondition)
[17:45:26.598]                           }
[17:45:26.598]                         }
[17:45:26.598]                         frame <- frame + 1L
[17:45:26.598]                         envir <- sys.frame(frame)
[17:45:26.598]                       }
[17:45:26.598]                     }
[17:45:26.598]                     sendCondition <<- function(cond) NULL
[17:45:26.598]                   }
[17:45:26.598]                 })
[17:45:26.598]                 withCallingHandlers({
[17:45:26.598]                   {
[17:45:26.598]                     do.call(function(...) {
[17:45:26.598]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.598]                       if (!identical(...future.globals.maxSize.org, 
[17:45:26.598]                         ...future.globals.maxSize)) {
[17:45:26.598]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.598]                         on.exit(options(oopts), add = TRUE)
[17:45:26.598]                       }
[17:45:26.598]                       {
[17:45:26.598]                         lapply(seq_along(...future.elements_ii), 
[17:45:26.598]                           FUN = function(jj) {
[17:45:26.598]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.598]                             ...future.FUN(...future.X_jj, ...)
[17:45:26.598]                           })
[17:45:26.598]                       }
[17:45:26.598]                     }, args = future.call.arguments)
[17:45:26.598]                   }
[17:45:26.598]                 }, immediateCondition = function(cond) {
[17:45:26.598]                   sendCondition <- ...future.makeSendCondition()
[17:45:26.598]                   sendCondition(cond)
[17:45:26.598]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.598]                   {
[17:45:26.598]                     inherits <- base::inherits
[17:45:26.598]                     invokeRestart <- base::invokeRestart
[17:45:26.598]                     is.null <- base::is.null
[17:45:26.598]                     muffled <- FALSE
[17:45:26.598]                     if (inherits(cond, "message")) {
[17:45:26.598]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:26.598]                       if (muffled) 
[17:45:26.598]                         invokeRestart("muffleMessage")
[17:45:26.598]                     }
[17:45:26.598]                     else if (inherits(cond, "warning")) {
[17:45:26.598]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:26.598]                       if (muffled) 
[17:45:26.598]                         invokeRestart("muffleWarning")
[17:45:26.598]                     }
[17:45:26.598]                     else if (inherits(cond, "condition")) {
[17:45:26.598]                       if (!is.null(pattern)) {
[17:45:26.598]                         computeRestarts <- base::computeRestarts
[17:45:26.598]                         grepl <- base::grepl
[17:45:26.598]                         restarts <- computeRestarts(cond)
[17:45:26.598]                         for (restart in restarts) {
[17:45:26.598]                           name <- restart$name
[17:45:26.598]                           if (is.null(name)) 
[17:45:26.598]                             next
[17:45:26.598]                           if (!grepl(pattern, name)) 
[17:45:26.598]                             next
[17:45:26.598]                           invokeRestart(restart)
[17:45:26.598]                           muffled <- TRUE
[17:45:26.598]                           break
[17:45:26.598]                         }
[17:45:26.598]                       }
[17:45:26.598]                     }
[17:45:26.598]                     invisible(muffled)
[17:45:26.598]                   }
[17:45:26.598]                   muffleCondition(cond)
[17:45:26.598]                 })
[17:45:26.598]             }))
[17:45:26.598]             future::FutureResult(value = ...future.value$value, 
[17:45:26.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.598]                   ...future.rng), globalenv = if (FALSE) 
[17:45:26.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:26.598]                     ...future.globalenv.names))
[17:45:26.598]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:26.598]         }, condition = base::local({
[17:45:26.598]             c <- base::c
[17:45:26.598]             inherits <- base::inherits
[17:45:26.598]             invokeRestart <- base::invokeRestart
[17:45:26.598]             length <- base::length
[17:45:26.598]             list <- base::list
[17:45:26.598]             seq.int <- base::seq.int
[17:45:26.598]             signalCondition <- base::signalCondition
[17:45:26.598]             sys.calls <- base::sys.calls
[17:45:26.598]             `[[` <- base::`[[`
[17:45:26.598]             `+` <- base::`+`
[17:45:26.598]             `<<-` <- base::`<<-`
[17:45:26.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:26.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:26.598]                   3L)]
[17:45:26.598]             }
[17:45:26.598]             function(cond) {
[17:45:26.598]                 is_error <- inherits(cond, "error")
[17:45:26.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:26.598]                   NULL)
[17:45:26.598]                 if (is_error) {
[17:45:26.598]                   sessionInformation <- function() {
[17:45:26.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:26.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:26.598]                       search = base::search(), system = base::Sys.info())
[17:45:26.598]                   }
[17:45:26.598]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:26.598]                     cond$call), session = sessionInformation(), 
[17:45:26.598]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:26.598]                   signalCondition(cond)
[17:45:26.598]                 }
[17:45:26.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:26.598]                 "immediateCondition"))) {
[17:45:26.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:26.598]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:26.598]                   if (TRUE && !signal) {
[17:45:26.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.598]                     {
[17:45:26.598]                       inherits <- base::inherits
[17:45:26.598]                       invokeRestart <- base::invokeRestart
[17:45:26.598]                       is.null <- base::is.null
[17:45:26.598]                       muffled <- FALSE
[17:45:26.598]                       if (inherits(cond, "message")) {
[17:45:26.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.598]                         if (muffled) 
[17:45:26.598]                           invokeRestart("muffleMessage")
[17:45:26.598]                       }
[17:45:26.598]                       else if (inherits(cond, "warning")) {
[17:45:26.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.598]                         if (muffled) 
[17:45:26.598]                           invokeRestart("muffleWarning")
[17:45:26.598]                       }
[17:45:26.598]                       else if (inherits(cond, "condition")) {
[17:45:26.598]                         if (!is.null(pattern)) {
[17:45:26.598]                           computeRestarts <- base::computeRestarts
[17:45:26.598]                           grepl <- base::grepl
[17:45:26.598]                           restarts <- computeRestarts(cond)
[17:45:26.598]                           for (restart in restarts) {
[17:45:26.598]                             name <- restart$name
[17:45:26.598]                             if (is.null(name)) 
[17:45:26.598]                               next
[17:45:26.598]                             if (!grepl(pattern, name)) 
[17:45:26.598]                               next
[17:45:26.598]                             invokeRestart(restart)
[17:45:26.598]                             muffled <- TRUE
[17:45:26.598]                             break
[17:45:26.598]                           }
[17:45:26.598]                         }
[17:45:26.598]                       }
[17:45:26.598]                       invisible(muffled)
[17:45:26.598]                     }
[17:45:26.598]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.598]                   }
[17:45:26.598]                 }
[17:45:26.598]                 else {
[17:45:26.598]                   if (TRUE) {
[17:45:26.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.598]                     {
[17:45:26.598]                       inherits <- base::inherits
[17:45:26.598]                       invokeRestart <- base::invokeRestart
[17:45:26.598]                       is.null <- base::is.null
[17:45:26.598]                       muffled <- FALSE
[17:45:26.598]                       if (inherits(cond, "message")) {
[17:45:26.598]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.598]                         if (muffled) 
[17:45:26.598]                           invokeRestart("muffleMessage")
[17:45:26.598]                       }
[17:45:26.598]                       else if (inherits(cond, "warning")) {
[17:45:26.598]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.598]                         if (muffled) 
[17:45:26.598]                           invokeRestart("muffleWarning")
[17:45:26.598]                       }
[17:45:26.598]                       else if (inherits(cond, "condition")) {
[17:45:26.598]                         if (!is.null(pattern)) {
[17:45:26.598]                           computeRestarts <- base::computeRestarts
[17:45:26.598]                           grepl <- base::grepl
[17:45:26.598]                           restarts <- computeRestarts(cond)
[17:45:26.598]                           for (restart in restarts) {
[17:45:26.598]                             name <- restart$name
[17:45:26.598]                             if (is.null(name)) 
[17:45:26.598]                               next
[17:45:26.598]                             if (!grepl(pattern, name)) 
[17:45:26.598]                               next
[17:45:26.598]                             invokeRestart(restart)
[17:45:26.598]                             muffled <- TRUE
[17:45:26.598]                             break
[17:45:26.598]                           }
[17:45:26.598]                         }
[17:45:26.598]                       }
[17:45:26.598]                       invisible(muffled)
[17:45:26.598]                     }
[17:45:26.598]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.598]                   }
[17:45:26.598]                 }
[17:45:26.598]             }
[17:45:26.598]         }))
[17:45:26.598]     }, error = function(ex) {
[17:45:26.598]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:26.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.598]                 ...future.rng), started = ...future.startTime, 
[17:45:26.598]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:26.598]             version = "1.8"), class = "FutureResult")
[17:45:26.598]     }, finally = {
[17:45:26.598]         if (!identical(...future.workdir, getwd())) 
[17:45:26.598]             setwd(...future.workdir)
[17:45:26.598]         {
[17:45:26.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:26.598]                 ...future.oldOptions$nwarnings <- NULL
[17:45:26.598]             }
[17:45:26.598]             base::options(...future.oldOptions)
[17:45:26.598]             if (.Platform$OS.type == "windows") {
[17:45:26.598]                 old_names <- names(...future.oldEnvVars)
[17:45:26.598]                 envs <- base::Sys.getenv()
[17:45:26.598]                 names <- names(envs)
[17:45:26.598]                 common <- intersect(names, old_names)
[17:45:26.598]                 added <- setdiff(names, old_names)
[17:45:26.598]                 removed <- setdiff(old_names, names)
[17:45:26.598]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:26.598]                   envs[common]]
[17:45:26.598]                 NAMES <- toupper(changed)
[17:45:26.598]                 args <- list()
[17:45:26.598]                 for (kk in seq_along(NAMES)) {
[17:45:26.598]                   name <- changed[[kk]]
[17:45:26.598]                   NAME <- NAMES[[kk]]
[17:45:26.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.598]                     next
[17:45:26.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.598]                 }
[17:45:26.598]                 NAMES <- toupper(added)
[17:45:26.598]                 for (kk in seq_along(NAMES)) {
[17:45:26.598]                   name <- added[[kk]]
[17:45:26.598]                   NAME <- NAMES[[kk]]
[17:45:26.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.598]                     next
[17:45:26.598]                   args[[name]] <- ""
[17:45:26.598]                 }
[17:45:26.598]                 NAMES <- toupper(removed)
[17:45:26.598]                 for (kk in seq_along(NAMES)) {
[17:45:26.598]                   name <- removed[[kk]]
[17:45:26.598]                   NAME <- NAMES[[kk]]
[17:45:26.598]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.598]                     next
[17:45:26.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.598]                 }
[17:45:26.598]                 if (length(args) > 0) 
[17:45:26.598]                   base::do.call(base::Sys.setenv, args = args)
[17:45:26.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:26.598]             }
[17:45:26.598]             else {
[17:45:26.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:26.598]             }
[17:45:26.598]             {
[17:45:26.598]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:26.598]                   0L) {
[17:45:26.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:26.598]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:26.598]                   base::options(opts)
[17:45:26.598]                 }
[17:45:26.598]                 {
[17:45:26.598]                   {
[17:45:26.598]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:26.598]                     NULL
[17:45:26.598]                   }
[17:45:26.598]                   options(future.plan = NULL)
[17:45:26.598]                   if (is.na(NA_character_)) 
[17:45:26.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:26.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:26.598]                     .init = FALSE)
[17:45:26.598]                 }
[17:45:26.598]             }
[17:45:26.598]         }
[17:45:26.598]     })
[17:45:26.598]     if (TRUE) {
[17:45:26.598]         base::sink(type = "output", split = FALSE)
[17:45:26.598]         if (TRUE) {
[17:45:26.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:26.598]         }
[17:45:26.598]         else {
[17:45:26.598]             ...future.result["stdout"] <- base::list(NULL)
[17:45:26.598]         }
[17:45:26.598]         base::close(...future.stdout)
[17:45:26.598]         ...future.stdout <- NULL
[17:45:26.598]     }
[17:45:26.598]     ...future.result$conditions <- ...future.conditions
[17:45:26.598]     ...future.result$finished <- base::Sys.time()
[17:45:26.598]     ...future.result
[17:45:26.598] }
[17:45:26.601] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[17:45:26.601] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[17:45:26.644] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[17:45:26.644] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[17:45:26.644] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[17:45:26.645] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[17:45:26.645] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.645] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[17:45:26.688] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[17:45:26.688] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[17:45:26.732] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[17:45:26.732] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[17:45:26.732] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.732] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[17:45:26.733] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[17:45:26.733] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[17:45:26.733] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.733] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[17:45:26.734] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[17:45:26.734] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[17:45:26.734] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.734] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[17:45:26.735] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[17:45:26.735] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[17:45:26.735] MultisessionFuture started
[17:45:26.735] - Launch lazy future ... done
[17:45:26.736] run() for ‘MultisessionFuture’ ... done
[17:45:26.736] Created future:
[17:45:26.736] MultisessionFuture:
[17:45:26.736] Label: ‘future_vapply-1’
[17:45:26.736] Expression:
[17:45:26.736] {
[17:45:26.736]     do.call(function(...) {
[17:45:26.736]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.736]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.736]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.736]             on.exit(options(oopts), add = TRUE)
[17:45:26.736]         }
[17:45:26.736]         {
[17:45:26.736]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.736]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.736]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.736]             })
[17:45:26.736]         }
[17:45:26.736]     }, args = future.call.arguments)
[17:45:26.736] }
[17:45:26.736] Lazy evaluation: FALSE
[17:45:26.736] Asynchronous evaluation: TRUE
[17:45:26.736] Local evaluation: TRUE
[17:45:26.736] Environment: R_GlobalEnv
[17:45:26.736] Capture standard output: TRUE
[17:45:26.736] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:26.736] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:26.736] Packages: 1 packages (‘future.apply’)
[17:45:26.736] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:26.736] Resolved: FALSE
[17:45:26.736] Value: <not collected>
[17:45:26.736] Conditions captured: <none>
[17:45:26.736] Early signaling: FALSE
[17:45:26.736] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:26.736] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.747] Chunk #1 of 2 ... DONE
[17:45:26.748] Chunk #2 of 2 ...
[17:45:26.748]  - Finding globals in 'X' for chunk #2 ...
[17:45:26.748] getGlobalsAndPackages() ...
[17:45:26.748] Searching for globals...
[17:45:26.748] 
[17:45:26.748] Searching for globals ... DONE
[17:45:26.748] - globals: [0] <none>
[17:45:26.749] getGlobalsAndPackages() ... DONE
[17:45:26.749]    + additional globals found: [n=0] 
[17:45:26.749]    + additional namespaces needed: [n=0] 
[17:45:26.749]  - Finding globals in 'X' for chunk #2 ... DONE
[17:45:26.749]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[17:45:26.749]  - seeds: <none>
[17:45:26.749]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.749] getGlobalsAndPackages() ...
[17:45:26.749] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.749] Resolving globals: FALSE
[17:45:26.749] Tweak future expression to call with '...' arguments ...
[17:45:26.750] {
[17:45:26.750]     do.call(function(...) {
[17:45:26.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.750]             on.exit(options(oopts), add = TRUE)
[17:45:26.750]         }
[17:45:26.750]         {
[17:45:26.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.750]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.750]             })
[17:45:26.750]         }
[17:45:26.750]     }, args = future.call.arguments)
[17:45:26.750] }
[17:45:26.750] Tweak future expression to call with '...' arguments ... DONE
[17:45:26.750] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[17:45:26.750] - packages: [1] ‘future.apply’
[17:45:26.751] getGlobalsAndPackages() ... DONE
[17:45:26.751] run() for ‘Future’ ...
[17:45:26.751] - state: ‘created’
[17:45:26.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[17:45:26.765] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[17:45:26.765]   - Field: ‘node’
[17:45:26.766]   - Field: ‘label’
[17:45:26.766]   - Field: ‘local’
[17:45:26.766]   - Field: ‘owner’
[17:45:26.766]   - Field: ‘envir’
[17:45:26.766]   - Field: ‘workers’
[17:45:26.766]   - Field: ‘packages’
[17:45:26.766]   - Field: ‘gc’
[17:45:26.766]   - Field: ‘conditions’
[17:45:26.766]   - Field: ‘persistent’
[17:45:26.766]   - Field: ‘expr’
[17:45:26.766]   - Field: ‘uuid’
[17:45:26.767]   - Field: ‘seed’
[17:45:26.767]   - Field: ‘version’
[17:45:26.767]   - Field: ‘result’
[17:45:26.767]   - Field: ‘asynchronous’
[17:45:26.767]   - Field: ‘calls’
[17:45:26.767]   - Field: ‘globals’
[17:45:26.767]   - Field: ‘stdout’
[17:45:26.767]   - Field: ‘earlySignal’
[17:45:26.767]   - Field: ‘lazy’
[17:45:26.767]   - Field: ‘state’
[17:45:26.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[17:45:26.768] - Launch lazy future ...
[17:45:26.768] Packages needed by the future expression (n = 1): ‘future.apply’
[17:45:26.768] Packages needed by future strategies (n = 0): <none>
[17:45:26.768] {
[17:45:26.768]     {
[17:45:26.768]         {
[17:45:26.768]             ...future.startTime <- base::Sys.time()
[17:45:26.768]             {
[17:45:26.768]                 {
[17:45:26.768]                   {
[17:45:26.768]                     {
[17:45:26.768]                       {
[17:45:26.768]                         base::local({
[17:45:26.768]                           has_future <- base::requireNamespace("future", 
[17:45:26.768]                             quietly = TRUE)
[17:45:26.768]                           if (has_future) {
[17:45:26.768]                             ns <- base::getNamespace("future")
[17:45:26.768]                             version <- ns[[".package"]][["version"]]
[17:45:26.768]                             if (is.null(version)) 
[17:45:26.768]                               version <- utils::packageVersion("future")
[17:45:26.768]                           }
[17:45:26.768]                           else {
[17:45:26.768]                             version <- NULL
[17:45:26.768]                           }
[17:45:26.768]                           if (!has_future || version < "1.8.0") {
[17:45:26.768]                             info <- base::c(r_version = base::gsub("R version ", 
[17:45:26.768]                               "", base::R.version$version.string), 
[17:45:26.768]                               platform = base::sprintf("%s (%s-bit)", 
[17:45:26.768]                                 base::R.version$platform, 8 * 
[17:45:26.768]                                   base::.Machine$sizeof.pointer), 
[17:45:26.768]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[17:45:26.768]                                 "release", "version")], collapse = " "), 
[17:45:26.768]                               hostname = base::Sys.info()[["nodename"]])
[17:45:26.768]                             info <- base::sprintf("%s: %s", base::names(info), 
[17:45:26.768]                               info)
[17:45:26.768]                             info <- base::paste(info, collapse = "; ")
[17:45:26.768]                             if (!has_future) {
[17:45:26.768]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[17:45:26.768]                                 info)
[17:45:26.768]                             }
[17:45:26.768]                             else {
[17:45:26.768]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[17:45:26.768]                                 info, version)
[17:45:26.768]                             }
[17:45:26.768]                             base::stop(msg)
[17:45:26.768]                           }
[17:45:26.768]                         })
[17:45:26.768]                       }
[17:45:26.768]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[17:45:26.768]                       base::options(mc.cores = 1L)
[17:45:26.768]                     }
[17:45:26.768]                     base::local({
[17:45:26.768]                       for (pkg in "future.apply") {
[17:45:26.768]                         base::loadNamespace(pkg)
[17:45:26.768]                         base::library(pkg, character.only = TRUE)
[17:45:26.768]                       }
[17:45:26.768]                     })
[17:45:26.768]                   }
[17:45:26.768]                   ...future.strategy.old <- future::plan("list")
[17:45:26.768]                   options(future.plan = NULL)
[17:45:26.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[17:45:26.768]                 }
[17:45:26.768]                 ...future.workdir <- getwd()
[17:45:26.768]             }
[17:45:26.768]             ...future.oldOptions <- base::as.list(base::.Options)
[17:45:26.768]             ...future.oldEnvVars <- base::Sys.getenv()
[17:45:26.768]         }
[17:45:26.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[17:45:26.768]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[17:45:26.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[17:45:26.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[17:45:26.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[17:45:26.768]             future.stdout.windows.reencode = NULL, width = 80L)
[17:45:26.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[17:45:26.768]             base::names(...future.oldOptions))
[17:45:26.768]     }
[17:45:26.768]     if (FALSE) {
[17:45:26.768]     }
[17:45:26.768]     else {
[17:45:26.768]         if (TRUE) {
[17:45:26.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[17:45:26.768]                 open = "w")
[17:45:26.768]         }
[17:45:26.768]         else {
[17:45:26.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[17:45:26.768]                 windows = "NUL", "/dev/null"), open = "w")
[17:45:26.768]         }
[17:45:26.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[17:45:26.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[17:45:26.768]             base::sink(type = "output", split = FALSE)
[17:45:26.768]             base::close(...future.stdout)
[17:45:26.768]         }, add = TRUE)
[17:45:26.768]     }
[17:45:26.768]     ...future.frame <- base::sys.nframe()
[17:45:26.768]     ...future.conditions <- base::list()
[17:45:26.768]     ...future.rng <- base::globalenv()$.Random.seed
[17:45:26.768]     if (FALSE) {
[17:45:26.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[17:45:26.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[17:45:26.768]     }
[17:45:26.768]     ...future.result <- base::tryCatch({
[17:45:26.768]         base::withCallingHandlers({
[17:45:26.768]             ...future.value <- base::withVisible(base::local({
[17:45:26.768]                 ...future.makeSendCondition <- base::local({
[17:45:26.768]                   sendCondition <- NULL
[17:45:26.768]                   function(frame = 1L) {
[17:45:26.768]                     if (is.function(sendCondition)) 
[17:45:26.768]                       return(sendCondition)
[17:45:26.768]                     ns <- getNamespace("parallel")
[17:45:26.768]                     if (exists("sendData", mode = "function", 
[17:45:26.768]                       envir = ns)) {
[17:45:26.768]                       parallel_sendData <- get("sendData", mode = "function", 
[17:45:26.768]                         envir = ns)
[17:45:26.768]                       envir <- sys.frame(frame)
[17:45:26.768]                       master <- NULL
[17:45:26.768]                       while (!identical(envir, .GlobalEnv) && 
[17:45:26.768]                         !identical(envir, emptyenv())) {
[17:45:26.768]                         if (exists("master", mode = "list", envir = envir, 
[17:45:26.768]                           inherits = FALSE)) {
[17:45:26.768]                           master <- get("master", mode = "list", 
[17:45:26.768]                             envir = envir, inherits = FALSE)
[17:45:26.768]                           if (inherits(master, c("SOCKnode", 
[17:45:26.768]                             "SOCK0node"))) {
[17:45:26.768]                             sendCondition <<- function(cond) {
[17:45:26.768]                               data <- list(type = "VALUE", value = cond, 
[17:45:26.768]                                 success = TRUE)
[17:45:26.768]                               parallel_sendData(master, data)
[17:45:26.768]                             }
[17:45:26.768]                             return(sendCondition)
[17:45:26.768]                           }
[17:45:26.768]                         }
[17:45:26.768]                         frame <- frame + 1L
[17:45:26.768]                         envir <- sys.frame(frame)
[17:45:26.768]                       }
[17:45:26.768]                     }
[17:45:26.768]                     sendCondition <<- function(cond) NULL
[17:45:26.768]                   }
[17:45:26.768]                 })
[17:45:26.768]                 withCallingHandlers({
[17:45:26.768]                   {
[17:45:26.768]                     do.call(function(...) {
[17:45:26.768]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.768]                       if (!identical(...future.globals.maxSize.org, 
[17:45:26.768]                         ...future.globals.maxSize)) {
[17:45:26.768]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.768]                         on.exit(options(oopts), add = TRUE)
[17:45:26.768]                       }
[17:45:26.768]                       {
[17:45:26.768]                         lapply(seq_along(...future.elements_ii), 
[17:45:26.768]                           FUN = function(jj) {
[17:45:26.768]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.768]                             ...future.FUN(...future.X_jj, ...)
[17:45:26.768]                           })
[17:45:26.768]                       }
[17:45:26.768]                     }, args = future.call.arguments)
[17:45:26.768]                   }
[17:45:26.768]                 }, immediateCondition = function(cond) {
[17:45:26.768]                   sendCondition <- ...future.makeSendCondition()
[17:45:26.768]                   sendCondition(cond)
[17:45:26.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.768]                   {
[17:45:26.768]                     inherits <- base::inherits
[17:45:26.768]                     invokeRestart <- base::invokeRestart
[17:45:26.768]                     is.null <- base::is.null
[17:45:26.768]                     muffled <- FALSE
[17:45:26.768]                     if (inherits(cond, "message")) {
[17:45:26.768]                       muffled <- grepl(pattern, "muffleMessage")
[17:45:26.768]                       if (muffled) 
[17:45:26.768]                         invokeRestart("muffleMessage")
[17:45:26.768]                     }
[17:45:26.768]                     else if (inherits(cond, "warning")) {
[17:45:26.768]                       muffled <- grepl(pattern, "muffleWarning")
[17:45:26.768]                       if (muffled) 
[17:45:26.768]                         invokeRestart("muffleWarning")
[17:45:26.768]                     }
[17:45:26.768]                     else if (inherits(cond, "condition")) {
[17:45:26.768]                       if (!is.null(pattern)) {
[17:45:26.768]                         computeRestarts <- base::computeRestarts
[17:45:26.768]                         grepl <- base::grepl
[17:45:26.768]                         restarts <- computeRestarts(cond)
[17:45:26.768]                         for (restart in restarts) {
[17:45:26.768]                           name <- restart$name
[17:45:26.768]                           if (is.null(name)) 
[17:45:26.768]                             next
[17:45:26.768]                           if (!grepl(pattern, name)) 
[17:45:26.768]                             next
[17:45:26.768]                           invokeRestart(restart)
[17:45:26.768]                           muffled <- TRUE
[17:45:26.768]                           break
[17:45:26.768]                         }
[17:45:26.768]                       }
[17:45:26.768]                     }
[17:45:26.768]                     invisible(muffled)
[17:45:26.768]                   }
[17:45:26.768]                   muffleCondition(cond)
[17:45:26.768]                 })
[17:45:26.768]             }))
[17:45:26.768]             future::FutureResult(value = ...future.value$value, 
[17:45:26.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.768]                   ...future.rng), globalenv = if (FALSE) 
[17:45:26.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[17:45:26.768]                     ...future.globalenv.names))
[17:45:26.768]                 else NULL, started = ...future.startTime, version = "1.8")
[17:45:26.768]         }, condition = base::local({
[17:45:26.768]             c <- base::c
[17:45:26.768]             inherits <- base::inherits
[17:45:26.768]             invokeRestart <- base::invokeRestart
[17:45:26.768]             length <- base::length
[17:45:26.768]             list <- base::list
[17:45:26.768]             seq.int <- base::seq.int
[17:45:26.768]             signalCondition <- base::signalCondition
[17:45:26.768]             sys.calls <- base::sys.calls
[17:45:26.768]             `[[` <- base::`[[`
[17:45:26.768]             `+` <- base::`+`
[17:45:26.768]             `<<-` <- base::`<<-`
[17:45:26.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[17:45:26.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[17:45:26.768]                   3L)]
[17:45:26.768]             }
[17:45:26.768]             function(cond) {
[17:45:26.768]                 is_error <- inherits(cond, "error")
[17:45:26.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[17:45:26.768]                   NULL)
[17:45:26.768]                 if (is_error) {
[17:45:26.768]                   sessionInformation <- function() {
[17:45:26.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[17:45:26.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[17:45:26.768]                       search = base::search(), system = base::Sys.info())
[17:45:26.768]                   }
[17:45:26.768]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[17:45:26.768]                     cond$call), session = sessionInformation(), 
[17:45:26.768]                     timestamp = base::Sys.time(), signaled = 0L)
[17:45:26.768]                   signalCondition(cond)
[17:45:26.768]                 }
[17:45:26.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[17:45:26.768]                 "immediateCondition"))) {
[17:45:26.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[17:45:26.768]                   ...future.conditions[[length(...future.conditions) + 
[17:45:26.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[17:45:26.768]                   if (TRUE && !signal) {
[17:45:26.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.768]                     {
[17:45:26.768]                       inherits <- base::inherits
[17:45:26.768]                       invokeRestart <- base::invokeRestart
[17:45:26.768]                       is.null <- base::is.null
[17:45:26.768]                       muffled <- FALSE
[17:45:26.768]                       if (inherits(cond, "message")) {
[17:45:26.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.768]                         if (muffled) 
[17:45:26.768]                           invokeRestart("muffleMessage")
[17:45:26.768]                       }
[17:45:26.768]                       else if (inherits(cond, "warning")) {
[17:45:26.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.768]                         if (muffled) 
[17:45:26.768]                           invokeRestart("muffleWarning")
[17:45:26.768]                       }
[17:45:26.768]                       else if (inherits(cond, "condition")) {
[17:45:26.768]                         if (!is.null(pattern)) {
[17:45:26.768]                           computeRestarts <- base::computeRestarts
[17:45:26.768]                           grepl <- base::grepl
[17:45:26.768]                           restarts <- computeRestarts(cond)
[17:45:26.768]                           for (restart in restarts) {
[17:45:26.768]                             name <- restart$name
[17:45:26.768]                             if (is.null(name)) 
[17:45:26.768]                               next
[17:45:26.768]                             if (!grepl(pattern, name)) 
[17:45:26.768]                               next
[17:45:26.768]                             invokeRestart(restart)
[17:45:26.768]                             muffled <- TRUE
[17:45:26.768]                             break
[17:45:26.768]                           }
[17:45:26.768]                         }
[17:45:26.768]                       }
[17:45:26.768]                       invisible(muffled)
[17:45:26.768]                     }
[17:45:26.768]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.768]                   }
[17:45:26.768]                 }
[17:45:26.768]                 else {
[17:45:26.768]                   if (TRUE) {
[17:45:26.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[17:45:26.768]                     {
[17:45:26.768]                       inherits <- base::inherits
[17:45:26.768]                       invokeRestart <- base::invokeRestart
[17:45:26.768]                       is.null <- base::is.null
[17:45:26.768]                       muffled <- FALSE
[17:45:26.768]                       if (inherits(cond, "message")) {
[17:45:26.768]                         muffled <- grepl(pattern, "muffleMessage")
[17:45:26.768]                         if (muffled) 
[17:45:26.768]                           invokeRestart("muffleMessage")
[17:45:26.768]                       }
[17:45:26.768]                       else if (inherits(cond, "warning")) {
[17:45:26.768]                         muffled <- grepl(pattern, "muffleWarning")
[17:45:26.768]                         if (muffled) 
[17:45:26.768]                           invokeRestart("muffleWarning")
[17:45:26.768]                       }
[17:45:26.768]                       else if (inherits(cond, "condition")) {
[17:45:26.768]                         if (!is.null(pattern)) {
[17:45:26.768]                           computeRestarts <- base::computeRestarts
[17:45:26.768]                           grepl <- base::grepl
[17:45:26.768]                           restarts <- computeRestarts(cond)
[17:45:26.768]                           for (restart in restarts) {
[17:45:26.768]                             name <- restart$name
[17:45:26.768]                             if (is.null(name)) 
[17:45:26.768]                               next
[17:45:26.768]                             if (!grepl(pattern, name)) 
[17:45:26.768]                               next
[17:45:26.768]                             invokeRestart(restart)
[17:45:26.768]                             muffled <- TRUE
[17:45:26.768]                             break
[17:45:26.768]                           }
[17:45:26.768]                         }
[17:45:26.768]                       }
[17:45:26.768]                       invisible(muffled)
[17:45:26.768]                     }
[17:45:26.768]                     muffleCondition(cond, pattern = "^muffle")
[17:45:26.768]                   }
[17:45:26.768]                 }
[17:45:26.768]             }
[17:45:26.768]         }))
[17:45:26.768]     }, error = function(ex) {
[17:45:26.768]         base::structure(base::list(value = NULL, visible = NULL, 
[17:45:26.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[17:45:26.768]                 ...future.rng), started = ...future.startTime, 
[17:45:26.768]             finished = Sys.time(), session_uuid = NA_character_, 
[17:45:26.768]             version = "1.8"), class = "FutureResult")
[17:45:26.768]     }, finally = {
[17:45:26.768]         if (!identical(...future.workdir, getwd())) 
[17:45:26.768]             setwd(...future.workdir)
[17:45:26.768]         {
[17:45:26.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[17:45:26.768]                 ...future.oldOptions$nwarnings <- NULL
[17:45:26.768]             }
[17:45:26.768]             base::options(...future.oldOptions)
[17:45:26.768]             if (.Platform$OS.type == "windows") {
[17:45:26.768]                 old_names <- names(...future.oldEnvVars)
[17:45:26.768]                 envs <- base::Sys.getenv()
[17:45:26.768]                 names <- names(envs)
[17:45:26.768]                 common <- intersect(names, old_names)
[17:45:26.768]                 added <- setdiff(names, old_names)
[17:45:26.768]                 removed <- setdiff(old_names, names)
[17:45:26.768]                 changed <- common[...future.oldEnvVars[common] != 
[17:45:26.768]                   envs[common]]
[17:45:26.768]                 NAMES <- toupper(changed)
[17:45:26.768]                 args <- list()
[17:45:26.768]                 for (kk in seq_along(NAMES)) {
[17:45:26.768]                   name <- changed[[kk]]
[17:45:26.768]                   NAME <- NAMES[[kk]]
[17:45:26.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.768]                     next
[17:45:26.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.768]                 }
[17:45:26.768]                 NAMES <- toupper(added)
[17:45:26.768]                 for (kk in seq_along(NAMES)) {
[17:45:26.768]                   name <- added[[kk]]
[17:45:26.768]                   NAME <- NAMES[[kk]]
[17:45:26.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.768]                     next
[17:45:26.768]                   args[[name]] <- ""
[17:45:26.768]                 }
[17:45:26.768]                 NAMES <- toupper(removed)
[17:45:26.768]                 for (kk in seq_along(NAMES)) {
[17:45:26.768]                   name <- removed[[kk]]
[17:45:26.768]                   NAME <- NAMES[[kk]]
[17:45:26.768]                   if (name != NAME && is.element(NAME, old_names)) 
[17:45:26.768]                     next
[17:45:26.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[17:45:26.768]                 }
[17:45:26.768]                 if (length(args) > 0) 
[17:45:26.768]                   base::do.call(base::Sys.setenv, args = args)
[17:45:26.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[17:45:26.768]             }
[17:45:26.768]             else {
[17:45:26.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[17:45:26.768]             }
[17:45:26.768]             {
[17:45:26.768]                 if (base::length(...future.futureOptionsAdded) > 
[17:45:26.768]                   0L) {
[17:45:26.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[17:45:26.768]                   base::names(opts) <- ...future.futureOptionsAdded
[17:45:26.768]                   base::options(opts)
[17:45:26.768]                 }
[17:45:26.768]                 {
[17:45:26.768]                   {
[17:45:26.768]                     base::options(mc.cores = ...future.mc.cores.old)
[17:45:26.768]                     NULL
[17:45:26.768]                   }
[17:45:26.768]                   options(future.plan = NULL)
[17:45:26.768]                   if (is.na(NA_character_)) 
[17:45:26.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[17:45:26.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[17:45:26.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[17:45:26.768]                     .init = FALSE)
[17:45:26.768]                 }
[17:45:26.768]             }
[17:45:26.768]         }
[17:45:26.768]     })
[17:45:26.768]     if (TRUE) {
[17:45:26.768]         base::sink(type = "output", split = FALSE)
[17:45:26.768]         if (TRUE) {
[17:45:26.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[17:45:26.768]         }
[17:45:26.768]         else {
[17:45:26.768]             ...future.result["stdout"] <- base::list(NULL)
[17:45:26.768]         }
[17:45:26.768]         base::close(...future.stdout)
[17:45:26.768]         ...future.stdout <- NULL
[17:45:26.768]     }
[17:45:26.768]     ...future.result$conditions <- ...future.conditions
[17:45:26.768]     ...future.result$finished <- base::Sys.time()
[17:45:26.768]     ...future.result
[17:45:26.768] }
[17:45:26.771] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[17:45:26.771] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[17:45:26.816] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[17:45:26.816] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[17:45:26.816] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[17:45:26.817] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[17:45:26.817] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[17:45:26.817] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[17:45:26.860] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[17:45:26.860] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[17:45:26.904] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[17:45:26.904] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[17:45:26.904] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.905] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[17:45:26.905] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[17:45:26.905] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[17:45:26.906] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.906] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[17:45:26.906] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[17:45:26.906] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[17:45:26.907] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.907] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[17:45:26.907] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[17:45:26.907] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[17:45:26.908] MultisessionFuture started
[17:45:26.908] - Launch lazy future ... done
[17:45:26.908] run() for ‘MultisessionFuture’ ... done
[17:45:26.908] Created future:
[17:45:26.910] receiveMessageFromWorker() for ClusterFuture ...
[17:45:26.910] - Validating connection of MultisessionFuture
[17:45:26.910] - received message: FutureResult
[17:45:26.911] - Received FutureResult
[17:45:26.911] - Erased future from FutureRegistry
[17:45:26.911] result() for ClusterFuture ...
[17:45:26.911] - result already collected: FutureResult
[17:45:26.911] result() for ClusterFuture ... done
[17:45:26.911] signalConditions() ...
[17:45:26.911]  - include = ‘immediateCondition’
[17:45:26.911]  - exclude = 
[17:45:26.911]  - resignal = FALSE
[17:45:26.911]  - Number of conditions: 1
[17:45:26.912] signalConditions() ... done
[17:45:26.912] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:26.908] MultisessionFuture:
[17:45:26.908] Label: ‘future_vapply-2’
[17:45:26.908] Expression:
[17:45:26.908] {
[17:45:26.908]     do.call(function(...) {
[17:45:26.908]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[17:45:26.908]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[17:45:26.908]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[17:45:26.908]             on.exit(options(oopts), add = TRUE)
[17:45:26.908]         }
[17:45:26.908]         {
[17:45:26.908]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[17:45:26.908]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[17:45:26.908]                 ...future.FUN(...future.X_jj, ...)
[17:45:26.908]             })
[17:45:26.908]         }
[17:45:26.908]     }, args = future.call.arguments)
[17:45:26.908] }
[17:45:26.908] Lazy evaluation: FALSE
[17:45:26.908] Asynchronous evaluation: TRUE
[17:45:26.908] Local evaluation: TRUE
[17:45:26.908] Environment: R_GlobalEnv
[17:45:26.908] Capture standard output: TRUE
[17:45:26.908] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[17:45:26.908] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[17:45:26.908] Packages: 1 packages (‘future.apply’)
[17:45:26.908] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[17:45:26.908] Resolved: TRUE
[17:45:26.908] Value: <not collected>
[17:45:26.908] Conditions captured: <none>
[17:45:26.908] Early signaling: FALSE
[17:45:26.908] Owner process: 9163bfc2-62df-65ee-f5e6-a0ae8267d107
[17:45:26.908] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[17:45:26.912] Chunk #2 of 2 ... DONE
[17:45:26.912] Launching 2 futures (chunks) ... DONE
[17:45:26.912] Resolving 2 futures (chunks) ...
[17:45:26.912] resolve() on list ...
[17:45:26.912]  recursive: 0
[17:45:26.912]  length: 2
[17:45:26.912] 
[17:45:26.913] receiveMessageFromWorker() for ClusterFuture ...
[17:45:26.913] - Validating connection of MultisessionFuture
[17:45:26.913] - received message: FutureResult
[17:45:26.913] - Received FutureResult
[17:45:26.914] - Erased future from FutureRegistry
[17:45:26.914] result() for ClusterFuture ...
[17:45:26.914] - result already collected: FutureResult
[17:45:26.914] result() for ClusterFuture ... done
[17:45:26.914] signalConditions() ...
[17:45:26.914]  - include = ‘immediateCondition’
[17:45:26.914]  - exclude = 
[17:45:26.914]  - resignal = FALSE
[17:45:26.914]  - Number of conditions: 1
[17:45:26.914] signalConditions() ... done
[17:45:26.914] receiveMessageFromWorker() for ClusterFuture ... done
[17:45:26.914] Future #1
[17:45:26.915] result() for ClusterFuture ...
[17:45:26.915] - result already collected: FutureResult
[17:45:26.915] result() for ClusterFuture ... done
[17:45:26.915] result() for ClusterFuture ...
[17:45:26.915] - result already collected: FutureResult
[17:45:26.915] result() for ClusterFuture ... done
[17:45:26.915] signalConditions() ...
[17:45:26.915]  - include = ‘immediateCondition’
[17:45:26.915]  - exclude = 
[17:45:26.915]  - resignal = FALSE
[17:45:26.915]  - Number of conditions: 1
[17:45:26.915] signalConditions() ... done
[17:45:26.916] signalConditionsASAP(MultisessionFuture, pos=1) ...
[17:45:26.916] - nx: 2
[17:45:26.916] - relay: TRUE
[17:45:26.916] - stdout: TRUE
[17:45:26.916] - signal: TRUE
[17:45:26.916] - resignal: FALSE
[17:45:26.916] - force: TRUE
[17:45:26.916] - relayed: [n=2] FALSE, FALSE
[17:45:26.916] - queued futures: [n=2] FALSE, FALSE
[17:45:26.916]  - until=1
[17:45:26.916]  - relaying element #1
[17:45:26.917] result() for ClusterFuture ...
[17:45:26.917] - result already collected: FutureResult
[17:45:26.917] result() for ClusterFuture ... done
[17:45:26.917] result() for ClusterFuture ...
[17:45:26.917] - result already collected: FutureResult
[17:45:26.917] result() for ClusterFuture ... done
[17:45:26.917] signalConditions() ...
[17:45:26.917]  - include = ‘immediateCondition’
[17:45:26.917]  - exclude = 
[17:45:26.917]  - resignal = FALSE
[17:45:26.917]  - Number of conditions: 1
[17:45:26.917] signalConditions() ... done
[17:45:26.918] result() for ClusterFuture ...
[17:45:26.918] - result already collected: FutureResult
[17:45:26.918] result() for ClusterFuture ... done
[17:45:26.918] signalConditions() ...
[17:45:26.918]  - include = ‘immediateCondition’
[17:45:26.918]  - exclude = 
[17:45:26.918]  - resignal = FALSE
[17:45:26.918]  - Number of conditions: 1
[17:45:26.918] signalConditions() ... done
[17:45:26.918] result() for ClusterFuture ...
[17:45:26.918] - result already collected: FutureResult
[17:45:26.918] result() for ClusterFuture ... done
[17:45:26.919] signalConditions() ...
[17:45:26.919]  - include = ‘condition’
[17:45:26.919]  - exclude = ‘immediateCondition’
[17:45:26.919]  - resignal = TRUE
[17:45:26.919]  - Number of conditions: 1
[17:45:26.919]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[17:45:26.919] signalConditions() ... done
[17:45:26.919] - relayed: [n=2] FALSE, FALSE
[17:45:26.919] - queued futures: [n=2] TRUE, FALSE
[17:45:26.919] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[17:45:26.920] plan(): Setting new future strategy stack:
[17:45:26.920] List of future strategies:
[17:45:26.920] 1. sequential:
[17:45:26.920]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:26.920]    - tweaked: FALSE
[17:45:26.920]    - call: plan(sequential)
[17:45:26.920] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[17:45:26.921] plan(): Setting new future strategy stack:
[17:45:26.921] List of future strategies:
[17:45:26.921] 1. FutureStrategy:
[17:45:26.921]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[17:45:26.921]    - tweaked: FALSE
[17:45:26.921]    - call: future::plan(oplan)
[17:45:26.922] plan(): nbrOfWorkers() = 1
> 
